{"sha": "a8d1066b5ec6b8ec6db6bdb47d947fccaa7d07bf", "log": "[COLLECTIONS-452] Change package to o.a.c.collections4.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ArrayStack.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.EmptyStackException;\n+\n+/**\n+ * An implementation of the {@link java.util.Stack} API that is based on an\n+ * <code>ArrayList</code> instead of a <code>Vector</code>, so it is not\n+ * synchronized to protect against multi-threaded access.  The implementation\n+ * is therefore operates faster in environments where you do not need to\n+ * worry about multiple thread contention.\n+ * <p>\n+ * The removal order of an <code>ArrayStack</code> is based on insertion \n+ * order: The most recently added element is removed first.  The iteration\n+ * order is <i>not</i> the same as the removal order.  The iterator returns\n+ * elements from the bottom up.\n+ * <p>\n+ * Unlike <code>Stack</code>, <code>ArrayStack</code> accepts null entries.\n+ * <p>\n+ * <b>Note:</b> From version 4.0 onwards, this class does not implement the\n+ * removed {@code Buffer} interface anymore.\n+ *\n+ * @see java.util.Stack\n+ * @since 1.0\n+ * @version $Id$\n+ * @deprecated use {@link java.util.ArrayDeque} instead (available from Java 1.6)\n+ */\n+@Deprecated\n+public class ArrayStack<E> extends ArrayList<E> {\n+\n+    /** Ensure serialization compatibility */    \n+    private static final long serialVersionUID = 2130079159931574599L;\n+\n+    /**\n+     * Constructs a new empty <code>ArrayStack</code>. The initial size\n+     * is controlled by <code>ArrayList</code> and is currently 10.\n+     */\n+    public ArrayStack() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty <code>ArrayStack</code> with an initial size.\n+     * \n+     * @param initialSize  the initial size to use\n+     * @throws IllegalArgumentException  if the specified initial size\n+     *  is negative\n+     */\n+    public ArrayStack(final int initialSize) {\n+        super(initialSize);\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this stack is currently empty.\n+     * <p>\n+     * This method exists for compatibility with <code>java.util.Stack</code>.\n+     * New users of this class should use <code>isEmpty</code> instead.\n+     * \n+     * @return true if the stack is currently empty\n+     */\n+    public boolean empty() {\n+        return isEmpty();\n+    }\n+\n+    /**\n+     * Returns the top item off of this stack without removing it.\n+     *\n+     * @return the top item on the stack\n+     * @throws EmptyStackException  if the stack is empty\n+     */\n+    public E peek() throws EmptyStackException {\n+        final int n = size();\n+        if (n <= 0) {\n+            throw new EmptyStackException();\n+        } else {\n+            return get(n - 1);\n+        }\n+    }\n+\n+    /**\n+     * Returns the n'th item down (zero-relative) from the top of this\n+     * stack without removing it.\n+     *\n+     * @param n  the number of items down to go\n+     * @return the n'th item on the stack, zero relative\n+     * @throws EmptyStackException  if there are not enough items on the\n+     *  stack to satisfy this request\n+     */\n+    public E peek(final int n) throws EmptyStackException {\n+        final int m = (size() - n) - 1;\n+        if (m < 0) {\n+            throw new EmptyStackException();\n+        } else {\n+            return get(m);\n+        }\n+    }\n+\n+    /**\n+     * Pops the top item off of this stack and return it.\n+     *\n+     * @return the top item on the stack\n+     * @throws EmptyStackException  if the stack is empty\n+     */\n+    public E pop() throws EmptyStackException {\n+        final int n = size();\n+        if (n <= 0) {\n+            throw new EmptyStackException();\n+        } else {\n+            return remove(n - 1);\n+        }\n+    }\n+\n+    /**\n+     * Pushes a new item onto the top of this stack. The pushed item is also\n+     * returned. This is equivalent to calling <code>add</code>.\n+     *\n+     * @param item  the item to be added\n+     * @return the item just pushed\n+     */\n+    public E push(final E item) {\n+        add(item);\n+        return item;\n+    }\n+\n+    /**\n+     * Returns the one-based position of the distance from the top that the\n+     * specified object exists on this stack, where the top-most element is\n+     * considered to be at distance <code>1</code>.  If the object is not\n+     * present on the stack, return <code>-1</code> instead.  The\n+     * <code>equals()</code> method is used to compare to the items\n+     * in this stack.\n+     *\n+     * @param object  the object to be searched for\n+     * @return the 1-based depth into the stack of the object, or -1 if not found\n+     */\n+    public int search(final Object object) {\n+        int i = size() - 1;        // Current index\n+        int n = 1;                 // Current distance\n+        while (i >= 0) {\n+            final Object current = get(i);\n+            if ((object == null && current == null) ||\n+                (object != null && object.equals(current))) {\n+                return n;\n+            }\n+            i--;\n+            n++;\n+        }\n+        return -1;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Bag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Defines a collection that counts the number of times an object appears in\n+ * the collection.\n+ * <p>\n+ * Suppose you have a Bag that contains <code>{a, a, b, c}</code>.\n+ * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n+ * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n+ * <p>\n+ * <i>NOTE: This interface violates the {@link Collection} contract.</i> \n+ * The behavior specified in many of these methods is <i>not</i> the same\n+ * as the behavior specified by <code>Collection</code>.\n+ * The noncompliant methods are clearly marked with \"(Violation)\".\n+ * Exercise caution when using a bag as a <code>Collection</code>.\n+ * <p>\n+ * This violation resulted from the original specification of this interface.\n+ * In an ideal world, the interface would be changed to fix the problems, however\n+ * it has been decided to maintain backwards compatibility instead.\n+ *\n+ * @param <E> the type held in the bag\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public interface Bag<E> extends Collection<E> {\n+\n+    /**\n+     * Returns the number of occurrences (cardinality) of the given\n+     * object currently in the bag. If the object does not exist in the\n+     * bag, return 0.\n+     * \n+     * @param object  the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    int getCount(Object object);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Adds one copy the specified object to the Bag.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as 1.\n+     * <p>\n+     * Since this method always increases the size of the bag,\n+     * according to the {@link Collection#add(Object)} contract, it \n+     * should always return <code>true</code>.  Since it sometimes returns\n+     * <code>false</code>, this method violates the contract.\n+     *\n+     * @param object  the object to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    boolean add(E object);\n+\n+    /**\n+     * Adds <code>nCopies</code> copies of the specified object to the Bag.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n+     * \n+     * @param object  the object to add\n+     * @param nCopies  the number of copies to add\n+     * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n+     */\n+    boolean add(E object, int nCopies);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Removes all occurrences of the given object from the bag.\n+     * <p>\n+     * This will also remove the object from the {@link #uniqueSet()}.\n+     * <p>\n+     * According to the {@link Collection#remove(Object)} method,\n+     * this method should only remove the <i>first</i> occurrence of the\n+     * given object, not <i>all</i> occurrences.\n+     *\n+     * @param object  the object to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean remove(Object object);\n+\n+    /**\n+     * Removes <code>nCopies</code> copies of the specified object from the Bag.\n+     * <p>\n+     * If the number of copies to remove is greater than the actual number of\n+     * copies in the Bag, no error is thrown.\n+     * \n+     * @param object  the object to remove\n+     * @param nCopies  the number of copies to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean remove(Object object, int nCopies);\n+\n+    /**\n+     * Returns a {@link Set} of unique elements in the Bag.\n+     * <p>\n+     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n+     * \n+     * @return the Set of unique Bag elements\n+     */\n+    Set<E> uniqueSet();\n+\n+    /**\n+     * Returns the total number of items in the bag across all types.\n+     * \n+     * @return the total size of the Bag\n+     */\n+    int size();\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Returns <code>true</code> if the bag contains all elements in\n+     * the given collection, respecting cardinality.  That is, if the\n+     * given collection <code>coll</code> contains <code>n</code> copies\n+     * of a given object, calling {@link #getCount(Object)} on that object must\n+     * be <code>&gt;= n</code> for all <code>n</code> in <code>coll</code>.\n+     * <p>\n+     * The {@link Collection#containsAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * return true if the bag contains at least one of every object contained\n+     * in the given collection.\n+     * \n+     * @param coll  the collection to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    boolean containsAll(Collection<?> coll);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Remove all elements represented in the given collection,\n+     * respecting cardinality.  That is, if the given collection\n+     * <code>coll</code> contains <code>n</code> copies of a given object,\n+     * the bag will have <code>n</code> fewer copies, assuming the bag\n+     * had at least <code>n</code> copies to begin with.\n+     *\n+     * <p>The {@link Collection#removeAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * remove <i>all</i> occurrences of every object contained in the \n+     * given collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean removeAll(Collection<?> coll);\n+\n+    /**\n+     * <i>(Violation)</i>\n+     * Remove any members of the bag that are not in the given\n+     * collection, respecting cardinality.  That is, if the given\n+     * collection <code>coll</code> contains <code>n</code> copies of a\n+     * given object and the bag has <code>m &gt; n</code> copies, then\n+     * delete <code>m - n</code> copies from the bag.  In addition, if\n+     * <code>e</code> is an object in the bag but\n+     * <code>!coll.contains(e)</code>, then remove <code>e</code> and any\n+     * of its copies.\n+     *\n+     * <p>The {@link Collection#retainAll(Collection)} method specifies\n+     * that cardinality should <i>not</i> be respected; this method should\n+     * keep <i>all</i> occurrences of every object contained in the \n+     * given collection.\n+     *\n+     * @param coll  the collection to retain\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean retainAll(Collection<?> coll);\n+\n+    /**\n+     * Returns an {@link Iterator} over the entire set of members,\n+     * including copies due to cardinality. This iterator is fail-fast\n+     * and will not tolerate concurrent modifications.\n+     * \n+     * @return iterator over all elements in the Bag\n+     */\n+    Iterator<E> iterator();\n+\n+    // The following is not part of the formal Bag interface, however where possible\n+    // Bag implementations should follow these comments.\n+//    /**\n+//     * Compares this Bag to another.\n+//     * This Bag equals another Bag if it contains the same number of occurrences of\n+//     * the same elements.\n+//     * This equals definition is compatible with the Set interface.\n+//     * \n+//     * @param obj  the Bag to compare to\n+//     * @return true if equal\n+//     */\n+//    boolean equals(Object obj);\n+//\n+//    /**\n+//     * Gets a hash code for the Bag compatible with the definition of equals.\n+//     * The hash code is defined as the sum total of a hash code for each element.\n+//     * The per element hash code is defined as\n+//     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>.\n+//     * This hash code definition is compatible with the Set interface.\n+//     * \n+//     * @return the hash code of the Bag\n+//     */\n+//    int hashCode();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/BagUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.bag.PredicatedBag;\n+import org.apache.commons.collections4.bag.PredicatedSortedBag;\n+import org.apache.commons.collections4.bag.SynchronizedBag;\n+import org.apache.commons.collections4.bag.SynchronizedSortedBag;\n+import org.apache.commons.collections4.bag.TransformedBag;\n+import org.apache.commons.collections4.bag.TransformedSortedBag;\n+import org.apache.commons.collections4.bag.TreeBag;\n+import org.apache.commons.collections4.bag.UnmodifiableBag;\n+import org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Bag} and {@link SortedBag} instances.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class BagUtils {\n+\n+    /**\n+     * An empty unmodifiable bag.\n+     */\n+    public static final Bag<Object> EMPTY_BAG = UnmodifiableBag.unmodifiableBag(new HashBag<Object>());\n+\n+    /**\n+     * An empty unmodifiable sorted bag.\n+     */\n+    public static final Bag<Object> EMPTY_SORTED_BAG =\n+            UnmodifiableSortedBag.unmodifiableSortedBag(new TreeBag<Object>());\n+\n+    /**\n+     * Instantiation of BagUtils is not intended or required.\n+     */\n+    private BagUtils() {}\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n+     * order to guarantee serial access, it is critical that all access to the\n+     * backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned bag\n+     * when iterating over it:\n+     * \n+     * <pre>\n+     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n+     * ...\n+     * synchronized(bag) {\n+     *     Iterator i = bag.iterator(); // Must be in synchronized block\n+     *     while (i.hasNext())\n+     *         foo(i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * Failure to follow this advice may result in non-deterministic behavior.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag to synchronize, must not be null\n+     * @return a synchronized bag backed by that bag\n+     * @throws IllegalArgumentException if the Bag is null\n+     */\n+    public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n+        return SynchronizedBag.synchronizedBag(bag);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the given bag. Any modification attempts\n+     * to the returned bag will raise an {@link UnsupportedOperationException}.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n+     * @return an unmodifiable view of that bag\n+     * @throws IllegalArgumentException if the Bag is null\n+     */\n+    public static <E> Bag<E> unmodifiableBag(final Bag<E> bag) {\n+        return UnmodifiableBag.unmodifiableBag(bag);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) bag backed by the given bag.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to\n+     * the bag. Trying to add an invalid object results in an\n+     * IllegalArgumentException. It is important not to use the original bag\n+     * after invoking this method, as it is a backdoor for adding invalid\n+     * objects.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag to predicate, must not be null\n+     * @param predicate the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Predicate is null\n+     */\n+    public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n+        return PredicatedBag.predicatedBag(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed bag backed by the given bag.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the Bag.\n+     * It is important not to use the original bag after invoking this method,\n+     * as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified bag will not be transformed.\n+     * If you want that behaviour, see {@link TransformedBag#transformedBag(Bag, Transformer)}.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag to predicate, must not be null\n+     * @param transformer the transformer for the bag, must not be null\n+     * @return a transformed bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     */\n+    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedBag.transformingBag(bag, transformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized (thread-safe) sorted bag backed by the given\n+     * sorted bag. In order to guarantee serial access, it is critical that all\n+     * access to the backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned bag\n+     * when iterating over it:\n+     * \n+     * <pre>\n+     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n+     * ...\n+     * synchronized(bag) {\n+     *     Iterator i = bag.iterator(); // Must be in synchronized block\n+     *     while (i.hasNext())\n+     *         foo(i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * Failure to follow this advice may result in non-deterministic behavior.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag to synchronize, must not be null\n+     * @return a synchronized bag backed by that bag\n+     * @throws IllegalArgumentException if the SortedBag is null\n+     */\n+    public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n+        return SynchronizedSortedBag.synchronizedSortedBag(bag);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the given sorted bag. Any modification\n+     * attempts to the returned bag will raise an\n+     * {@link UnsupportedOperationException}.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag whose unmodifiable view is to be returned, must not be null\n+     * @return an unmodifiable view of that bag\n+     * @throws IllegalArgumentException if the SortedBag is null\n+     */\n+    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n+        return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) sorted bag backed by the given sorted\n+     * bag.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to\n+     * the bag. Trying to add an invalid object results in an\n+     * IllegalArgumentException. It is important not to use the original bag\n+     * after invoking this method, as it is a backdoor for adding invalid\n+     * objects.\n+     * \n+     * @param <E> the element type\n+     * @param bag the sorted bag to predicate, must not be null\n+     * @param predicate the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException if the SortedBag or Predicate is null\n+     */\n+    public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n+            final Predicate<? super E> predicate) {\n+        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted bag backed by the given bag.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the Bag.\n+     * It is important not to use the original bag after invoking this method,\n+     * as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified bag will not be transformed.\n+     * If you want that behaviour, see\n+     * {@link TransformedSortedBag#transformedSortedBag(SortedBag, Transformer)}.\n+     * \n+     * @param <E> the element type\n+     * @param bag the bag to predicate, must not be null\n+     * @param transformer the transformer for the bag, must not be null\n+     * @return a transformed bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     */\n+    public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n+                                                         final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSortedBag.transformingSortedBag(bag, transformer);\n+    }\n+\n+    /**\n+     * Get an empty <code>Bag</code>.\n+     *\n+     * @param <E> the element type\n+     * @return an empty Bag\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n+    public static <E> Bag<E> emptyBag() {\n+        return (Bag<E>) EMPTY_BAG;        \n+    }\n+\n+    /**\n+     * Get an empty <code>SortedBag</code>.\n+     *\n+     * @param <E> the element type\n+     * @return an empty sorted Bag\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK, empty bag is compatible with any type\n+    public static <E> SortedBag<E> emptySortedBag() {\n+        return (SortedBag<E>) EMPTY_SORTED_BAG;        \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/BidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values.\n+ * <p>\n+ * This extended <code>Map</code> represents a mapping where a key may\n+ * lookup a value and a value may lookup a key with equal ease.\n+ * This interface extends <code>Map</code> and so may be used anywhere a map\n+ * is required. The interface provides an inverse map view, enabling\n+ * full access to both directions of the <code>BidiMap</code>.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ * <p>\n+ * This map enforces the restriction that there is a 1:1 relation between\n+ * keys and values, meaning that multiple keys cannot map to the same value. \n+ * This is required so that \"inverting\" the map results in a map without \n+ * duplicate keys. See the {@link #put} method description for more information.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface BidiMap<K, V> extends IterableMap<K, V> {\n+\n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new DualHashBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     * \n+     *  BidiMap map2 = new DualHashBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     *\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the previous value mapped to this key\n+     * \n+     * @throws UnsupportedOperationException if the <code>put</code> method is not supported\n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specified value is inappropriate\n+     * @throws IllegalArgumentException (optional) if the map limits the values\n+     *  in some way and the value was invalid\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     */\n+    V put(K key, V value);\n+\n+    /**\n+     * Gets the key that is currently mapped to the specified value.\n+     * <p>\n+     * If the value is not contained in the map, <code>null</code> is returned.\n+     * <p>\n+     * Implementations should seek to make this method perform equally as well\n+     * as <code>get(Object)</code>.\n+     *\n+     * @param value  the value to find the key for\n+     * @return the mapped key, or <code>null</code> if not found\n+     * \n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specified value is inappropriate\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     */\n+    K getKey(Object value);\n+\n+    /**\n+     * Removes the key-value pair that is currently mapped to the specified\n+     * value (optional operation).\n+     * <p>\n+     * If the value is not contained in the map, <code>null</code> is returned.\n+     * <p>\n+     * Implementations should seek to make this method perform equally as well\n+     * as <code>remove(Object)</code>.\n+     *\n+     * @param value  the value to find the key-value pair for\n+     * @return the key that was removed, <code>null</code> if nothing removed\n+     * \n+     * @throws ClassCastException (optional) if the map limits the type of the \n+     *  value and the specified value is inappropriate\n+     * @throws NullPointerException (optional) if the map limits the values to\n+     *  non-null and null was specified\n+     * @throws UnsupportedOperationException if this method is not supported\n+     *  by the implementation\n+     */\n+    K removeValue(Object value);\n+\n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed as a <code>Map</code>.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    BidiMap<V, K> inverseBidiMap();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/BoundedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Defines a collection that is bounded in size.\n+ * <p>\n+ * The size of the collection can vary, but it can never exceed a preset \n+ * maximum number of elements. This interface allows the querying of details\n+ * associated with the maximum number of elements.\n+ *\n+ * @see CollectionUtils#isFull\n+ * @see CollectionUtils#maxSize\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface BoundedCollection<E> extends Collection<E> {\n+\n+    /**\n+     * Returns true if this collection is full and no new elements can be added.\n+     *\n+     * @return <code>true</code> if the collection is full\n+     */\n+    boolean isFull();\n+\n+    /**\n+     * Gets the maximum size of the collection (the bound).\n+     *\n+     * @return the maximum number of elements the collection can hold\n+     */\n+    int maxSize();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/BoundedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a map that is bounded in size.\n+ * <p>\n+ * The size of the map can vary, but it can never exceed a preset \n+ * maximum number of elements. This interface allows the querying of details\n+ * associated with the maximum number of elements.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface BoundedMap<K, V> extends IterableMap<K, V> {\n+\n+    /**\n+     * Returns true if this map is full and no new elements can be added.\n+     *\n+     * @return <code>true</code> if the map is full\n+     */\n+    boolean isFull();\n+\n+    /**\n+     * Gets the maximum size of the map (the bound).\n+     *\n+     * @return the maximum number of elements the map can hold\n+     */\n+    int maxSize();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Closure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a functor interface implemented by classes that do something.\n+ * <p>\n+ * A <code>Closure</code> represents a block of code which is executed from\n+ * inside some block, function or iteration. It operates an input object.\n+ * <p>\n+ * Standard implementations of common closures are provided by\n+ * {@link ClosureUtils}. These include method invocation and for/while loops.\n+ *\n+ * @param <T> the type that the closure acts on\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public interface Closure<T> {\n+\n+    /**\n+     * Performs an action on the specified input object.\n+     *\n+     * @param input  the input to execute on\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if any other error occurs\n+     */\n+    public void execute(T input);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.functors.ChainedClosure;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.functors.ExceptionClosure;\n+import org.apache.commons.collections4.functors.ForClosure;\n+import org.apache.commons.collections4.functors.IfClosure;\n+import org.apache.commons.collections4.functors.InvokerTransformer;\n+import org.apache.commons.collections4.functors.NOPClosure;\n+import org.apache.commons.collections4.functors.SwitchClosure;\n+import org.apache.commons.collections4.functors.TransformerClosure;\n+import org.apache.commons.collections4.functors.WhileClosure;\n+\n+/**\n+ * <code>ClosureUtils</code> provides reference implementations and utilities\n+ * for the Closure functor interface. The supplied closures are:\n+ * <ul>\n+ * <li>Invoker - invokes a method on the input object\n+ * <li>For - repeatedly calls a closure for a fixed number of times\n+ * <li>While - repeatedly calls a closure while a predicate is true\n+ * <li>DoWhile - repeatedly calls a closure while a predicate is true\n+ * <li>Chained - chains two or more closures together\n+ * <li>Switch - calls one closure based on one or more predicates\n+ * <li>SwitchMap - calls one closure looked up from a Map\n+ * <li>Transformer - wraps a Transformer as a Closure\n+ * <li>NOP - does nothing\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied closures are Serializable.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ClosureUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    private ClosureUtils() {}\n+\n+    /**\n+     * Gets a Closure that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections4.functors.ExceptionClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @return the closure\n+     */\n+    public static <E> Closure<E> exceptionClosure() {\n+        return ExceptionClosure.<E>exceptionClosure();\n+    }\n+\n+    /**\n+     * Gets a Closure that will do nothing.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections4.functors.NOPClosure\n+     *\n+     * @param <E>  the type that the closure acts on\n+     * @return the closure\n+     */\n+    public static <E> Closure<E> nopClosure() {\n+        return NOPClosure.<E>nopClosure();\n+    }\n+\n+    /**\n+     * Creates a Closure that calls a Transformer each time it is called.\n+     * The transformer will be called using the closure's input object.\n+     * The transformer's result will be ignored.\n+     *\n+     * @see org.apache.commons.collections4.functors.TransformerClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param transformer  the transformer to run each time in the closure, null means nop\n+     * @return the closure\n+     */\n+    public static <E> Closure<E> asClosure(final Transformer<? super E, ?> transformer) {\n+        return TransformerClosure.transformerClosure(transformer);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure <code>count</code> times.\n+     * <p>\n+     * A null closure or zero count returns the <code>NOPClosure</code>.\n+     *\n+     * @see org.apache.commons.collections4.functors.ForClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param count  the number of times to loop\n+     * @param closure  the closure to call repeatedly\n+     * @return the <code>for</code> closure\n+     */\n+    public static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n+        return ForClosure.forClosure(count, closure);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure repeatedly until the \n+     * predicate returns false.\n+     *\n+     * @see org.apache.commons.collections4.functors.WhileClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param predicate  the predicate to use as an end of loop test, not null\n+     * @param closure  the closure to call repeatedly, not null\n+     * @return the <code>while</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n+        return WhileClosure.<E>whileClosure(predicate, closure, false);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure once and then repeatedly\n+     * until the predicate returns false.\n+     *\n+     * @see org.apache.commons.collections4.functors.WhileClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param closure  the closure to call repeatedly, not null\n+     * @param predicate  the predicate to use as an end of loop test, not null\n+     * @return the <code>do-while</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static <E> Closure<E> doWhileClosure(final Closure<? super E> closure,\n+                                                final Predicate<? super E> predicate) {\n+        return WhileClosure.<E>whileClosure(predicate, closure, true);\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the closure's\n+     * input object by reflection.\n+     *\n+     * @see org.apache.commons.collections4.functors.InvokerTransformer\n+     * @see org.apache.commons.collections4.functors.TransformerClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param methodName  the name of the method\n+     * @return the <code>invoker</code> closure\n+     * @throws IllegalArgumentException if the method name is null\n+     */\n+    public static <E> Closure<E> invokerClosure(final String methodName) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName));\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the closure's\n+     * input object by reflection.\n+     *\n+     * @see org.apache.commons.collections4.functors.InvokerTransformer\n+     * @see org.apache.commons.collections4.functors.TransformerClosure\n+     *\n+     * @param <E>  the type that the closure acts on\n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the <code>invoker</code> closure\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes,\n+                                                final Object[] args) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    /**\n+     * Create a new Closure that calls two Closures, passing the result of\n+     * the first into the second.\n+     * \n+     * @see org.apache.commons.collections4.functors.ChainedClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param closure1  the first closure\n+     * @param closure2  the second closure\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static <E> Closure<E> chainedClosure(final Closure<? super E> closure1, final Closure<? super E> closure2) {\n+        return ChainedClosure.<E>chainedClosure(closure1, closure2);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure.\n+     * \n+     * @see org.apache.commons.collections4.functors.ChainedClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param closures  an array of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures array is null\n+     * @throws IllegalArgumentException if any closure in the array is null\n+     */\n+    public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n+        return ChainedClosure.chainedClosure(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @see org.apache.commons.collections4.functors.ChainedClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param closures  a collection of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws IllegalArgumentException if the closures collection is empty\n+     * @throws IllegalArgumentException if any closure in the collection is null\n+     */\n+    public static <E> Closure<E> chainedClosure(final Collection<Closure<E>> closures) {\n+        return ChainedClosure.chainedClosure(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls another closure based on the\n+     * result of the specified predicate.\n+     * \n+     * @see org.apache.commons.collections4.functors.IfClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param predicate  the validating predicate\n+     * @param trueClosure  the closure called if the predicate is true\n+     * @return the <code>if</code> closure\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if the closure is null\n+     * @since 3.2\n+     */\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n+                                           final Closure<? super E> trueClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of two closures depending \n+     * on the specified predicate.\n+     * \n+     * @see org.apache.commons.collections4.functors.IfClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param predicate  the predicate to switch on\n+     * @param trueClosure  the closure called if the predicate is true\n+     * @param falseClosure  the closure called if the predicate is false\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n+                                           final Closure<? super E> trueClosure,\n+                                           final Closure<? super E> falseClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure, falseClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates.\n+     * <p>\n+     * The closure at array location 0 is called if the predicate at array \n+     * location 0 returned true. Each predicate is evaluated\n+     * until one returns true.\n+     * \n+     * @see org.apache.commons.collections4.functors.SwitchClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param predicates  an array of predicates to check, not null\n+     * @param closures  an array of closures to call, not null\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n+                                               final Closure<? super E>[] closures) {\n+        return SwitchClosure.<E>switchClosure(predicates, closures, null);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates.\n+     * <p>\n+     * The closure at array location 0 is called if the predicate at array\n+     * location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called.\n+     * \n+     * @see org.apache.commons.collections4.functors.SwitchClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param predicates  an array of predicates to check, not null\n+     * @param closures  an array of closures to call, not null\n+     * @param defaultClosure  the default to call if no predicate matches\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n+                                               final Closure<? super E>[] closures,\n+                                               final Closure<? super E> defaultClosure) {\n+        return SwitchClosure.<E>switchClosure(predicates, closures, defaultClosure);\n+    }\n+    \n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called. The default closure is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @see org.apache.commons.collections4.functors.SwitchClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param predicatesAndClosures  a map of predicates to closures\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+        return SwitchClosure.switchClosure(predicatesAndClosures);\n+    }\n+\n+    /**\n+     * Create a new Closure that uses the input object as a key to find the\n+     * closure to call. \n+     * <p>\n+     * The Map consists of object keys and Closure values. A closure \n+     * is called if the input object equals the key. If there is no match, the\n+     * default closure is called. The default closure is set in the map\n+     * using a null key.\n+     * \n+     * @see org.apache.commons.collections4.functors.SwitchClosure\n+     * \n+     * @param <E>  the type that the closure acts on\n+     * @param objectsAndClosures  a map of objects to closures\n+     * @return the closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n+        if (objectsAndClosures == null) {\n+            throw new IllegalArgumentException(\"The object and closure map must not be null\");\n+        }\n+        final Closure<? super E> def = objectsAndClosures.remove(null);\n+        final int size = objectsAndClosures.size();\n+        final Closure<? super E>[] trs = new Closure[size];\n+        final Predicate<E>[] preds = new Predicate[size];\n+        int i = 0;\n+        for (final Map.Entry<? extends E, Closure<E>> entry : objectsAndClosures.entrySet()) {\n+            preds[i] = EqualPredicate.<E>equalPredicate(entry.getKey());\n+            trs[i] = entry.getValue();\n+            i++;\n+        }\n+        return ClosureUtils.<E>switchClosure(preds, trs, def);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+import org.apache.commons.collections4.collection.SynchronizedCollection;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+import org.apache.commons.collections4.collection.UnmodifiableBoundedCollection;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.functors.Equator;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Collection} instances.\n+ * Method parameters will take {@link Iterable} objects when possible.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+//TODO - note generic types for review in wiki - especially <?> ones\n+public class CollectionUtils {\n+\n+    /**\n+     * Helper class to easily access cardinality properties of two collections.\n+     * @param <O>  the element type\n+     */\n+    private static class CardinalityHelper<O> {\n+        \n+        /** Contains the cardinality for each object in collection A. */\n+        final Map<O, Integer> cardinalityA;\n+        \n+        /** Contains the cardinality for each object in collection B. */\n+        final Map<O, Integer> cardinalityB;\n+\n+        /**\n+         * Create a new CardinalityHelper for two collections.\n+         * @param a  the first collection\n+         * @param b  the second collection\n+         */\n+        public CardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+            cardinalityA = CollectionUtils.<O>getCardinalityMap(a);\n+            cardinalityB = CollectionUtils.<O>getCardinalityMap(b);\n+        }\n+\n+        /**\n+         * Returns the maximum frequency of an object.\n+         * @param obj  the object\n+         * @return the maximum frequency of the object \n+         */\n+        public final int max(final Object obj) {\n+            return Math.max(freqA(obj), freqB(obj));\n+        }\n+\n+        /**\n+         * Returns the minimum frequency of an object.\n+         * @param obj  the object\n+         * @return the minimum frequency of the object\n+         */\n+        public final int min(final Object obj) {\n+            return Math.min(freqA(obj), freqB(obj));\n+        }\n+\n+        /**\n+         * Returns the frequency of this object in collection A.\n+         * @param obj  the object\n+         * @return the frequency of the object in collection A\n+         */\n+        public int freqA(final Object obj) {\n+            return getFreq(obj, cardinalityA);\n+        }\n+\n+        /**\n+         * Returns the frequency of this object in collection B.\n+         * @param obj  the object\n+         * @return the frequency of the object in collection B\n+         */\n+        public int freqB(final Object obj) {\n+            return getFreq(obj, cardinalityB);\n+        }\n+\n+        /**\n+         * Returns the number of unique elements in collection A.\n+         * @return the number of unique elements in collection A\n+         */\n+        @SuppressWarnings(\"unused\")\n+        public int sizeA() {\n+            return cardinalityA.size();\n+        }\n+        \n+        /**\n+         * Returns the number of unique elements in collection A.\n+         * @return the number of unique elements in collection A\n+         */\n+        public int sizeB() {\n+            return cardinalityB.size();\n+        }\n+\n+        private final int getFreq(final Object obj, final Map<?, Integer> freqMap) {\n+            final Integer count = freqMap.get(obj);\n+            if (count != null) {\n+                return count.intValue();\n+            }\n+            return 0;\n+        }\n+    }\n+\n+    /**\n+     * Helper class for set-related operations, e.g. union, subtract, intersection.\n+     * @param <O>  the element type\n+     */\n+    private static class SetOperationCardinalityHelper<O> extends CardinalityHelper<O> implements Iterable<O> {\n+        \n+        /** Contains the unique elements of the two collections. */\n+        private final Set<O> elements;\n+        \n+        /** Output collection. */\n+        private final List<O> newList;\n+\n+        /**\n+         * Create a new set operation helper from the two collections.\n+         * @param a  the first collection\n+         * @param b  the second collection\n+         */\n+        public SetOperationCardinalityHelper(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+            super(a, b);\n+            elements = new HashSet<O>();\n+            addAll(elements, a);\n+            addAll(elements, b);\n+            // the resulting list must contain at least each unique element, but may grow\n+            newList = new ArrayList<O>(elements.size());\n+        }\n+\n+        public Iterator<O> iterator() {\n+            return elements.iterator();\n+        }\n+\n+        /**\n+         * Add the object {@code count} times to the result collection.\n+         * @param obj  the object to add\n+         * @param count  the count\n+         */\n+        public void setCardinality(final O obj, final int count) {\n+            for (int i = 0; i < count; i++) {\n+                newList.add(obj);\n+            }\n+        }\n+\n+        /**\n+         * Returns the resulting collection.\n+         * @return the result\n+         */\n+        public Collection<O> list() {\n+            return newList;\n+        }\n+\n+    }\n+\n+    /**\n+     * An empty unmodifiable collection.\n+     * The JDK provides empty Set and List implementations which could be used for\n+     * this purpose. However they could be cast to Set or List which might be\n+     * undesirable. This implementation only implements Collection.\n+     */\n+    @SuppressWarnings(\"rawtypes\") // we deliberately use the raw type here\n+    public static final Collection EMPTY_COLLECTION =\n+        UnmodifiableCollection.unmodifiableCollection(new ArrayList<Object>());\n+\n+    /**\n+     * <code>CollectionUtils</code> should not normally be instantiated.\n+     */\n+    private CollectionUtils() {}\n+\n+    /**\n+     * Returns the immutable EMPTY_COLLECTION with generic type safety.\n+     *\n+     * @see #EMPTY_COLLECTION\n+     * @since 4.0\n+     * @param <T> the element type\n+     * @return immutable empty collection\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n+    public static <T> Collection<T> emptyCollection() {\n+        return EMPTY_COLLECTION;\n+    }\n+\n+    /**\n+     * Returns an immutable empty collection if the argument is <code>null</code>,\n+     * or the argument itself otherwise.\n+     * \n+     * @param <T> the element type\n+     * @param collection the collection, possibly <code>null</code>\n+     * @return an empty collection if the argument is <code>null</code>\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK, empty collection is compatible with any type\n+    public static <T> Collection<T> emptyIfNull(final Collection<T> collection) {\n+        return collection == null ? EMPTY_COLLECTION : collection;\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the union of the given\n+     * {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection} will\n+     * be equal to the maximum of the cardinality of that element in the two\n+     * given {@link Collection}s.\n+     *\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the union of the two collections\n+     * @see Collection#addAll\n+     */\n+    public static <O> Collection<O> union(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (final O obj : helper) {\n+            helper.setCardinality(obj, helper.max(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the intersection of the given\n+     * {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element in the returned {@link Collection} will\n+     * be equal to the minimum of the cardinality of that element in the two\n+     * given {@link Collection}s.\n+     *\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the intersection of the two collections\n+     * @see Collection#retainAll\n+     * @see #containsAny\n+     */\n+    public static <O> Collection<O> intersection(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (final O obj : helper) {\n+            helper.setCardinality(obj, helper.min(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a {@link Collection} containing the exclusive disjunction\n+     * (symmetric difference) of the given {@link Collection}s.\n+     * <p>\n+     * The cardinality of each element <i>e</i> in the returned\n+     * {@link Collection} will be equal to\n+     * <tt>max(cardinality(<i>e</i>,<i>a</i>),cardinality(<i>e</i>,<i>b</i>)) - min(cardinality(<i>e</i>,<i>a</i>),\n+     * cardinality(<i>e</i>,<i>b</i>))</tt>.\n+     * <p>\n+     * This is equivalent to\n+     * <tt>{@link #subtract subtract}({@link #union union(a,b)},{@link #intersection intersection(a,b)})</tt>\n+     * or\n+     * <tt>{@link #union union}({@link #subtract subtract(a,b)},{@link #subtract subtract(b,a)})</tt>.\n+\n+     * @param a the first collection, must not be null\n+     * @param b the second collection, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return the symmetric difference of the two collections\n+     */\n+    public static <O> Collection<O> disjunction(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        final SetOperationCardinalityHelper<O> helper = new SetOperationCardinalityHelper<O>(a, b);\n+        for (final O obj : helper) {\n+            helper.setCardinality(obj, helper.max(obj) - helper.min(obj));\n+        }\n+        return helper.list();\n+    }\n+\n+    /**\n+     * Returns a new {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n+     * The cardinality of each element <i>e</i> in the returned {@link Collection}\n+     * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n+     * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n+     *\n+     * @param a  the collection to subtract from, must not be null\n+     * @param b  the collection to subtract, must not be null\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return a new collection with the results\n+     * @see Collection#removeAll\n+     */\n+    public static <O> Collection<O> subtract(final Iterable<? extends O> a, final Iterable<? extends O> b) {\n+        final Predicate<O> p = TruePredicate.truePredicate();\n+        return subtract(a, b, p);\n+    }\n+\n+    /**\n+     * Returns a new {@link Collection} containing <i>a</i> minus a subset of\n+     * <i>b</i>.  Only the elements of <i>b</i> that satisfy the predicate\n+     * condition, <i>p</i> are subtracted from <i>a</i>.\n+     * \n+     * <p>The cardinality of each element <i>e</i> in the returned {@link Collection}\n+     * that satisfies the predicate condition will be the cardinality of <i>e</i> in <i>a</i>\n+     * minus the cardinality of <i>e</i> in <i>b</i>, or zero, whichever is greater.</p>\n+     * <p>The cardinality of each element <i>e</i> in the returned {@link Collection} that does <b>not</b>\n+     * satisfy the predicate condition will be equal to the cardinality of <i>e</i> in <i>a</i>.</p>\n+     *\n+     * @param a  the collection to subtract from, must not be null\n+     * @param b  the collection to subtract, must not be null\n+     * @param p  the condition used to determine which elements of <i>b</i> are\n+     *        subtracted.\n+     * @param <O> the generic type that is able to represent the types contained\n+     *        in both input collections.\n+     * @return a new collection with the results\n+     * @since 4.0\n+     * @see Collection#removeAll\n+     */\n+    public static <O> Collection<O> subtract(final Iterable<? extends O> a,\n+                                             final Iterable<? extends O> b,\n+                                             final Predicate<O> p) {\n+        final ArrayList<O> list = new ArrayList<O>();\n+        final HashBag<O> bag = new HashBag<O>();\n+        for (final O element : b) {\n+            if (p.evaluate(element)) {\n+                bag.add(element);\n+            }\n+        }\n+        for (final O element : a) {\n+            if (!bag.remove(element, 1)) {\n+                list.add(element);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff all elements of {@code coll2} are also contained\n+     * in {@code coll1}. The cardinality of values in {@code coll2} is not taken into account,\n+     * which is the same behavior as {@link Collection#containsAll(Collection)}.\n+     * <p>\n+     * In other words, this method returns <code>true</code> iff the\n+     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> has the same cardinality as\n+     * the set of unique values from {@code coll2}. In case {@code coll2} is empty, {@code true}\n+     * will be returned.\n+     * <p>\n+     * This method is intended as a replacement for {@link Collection#containsAll(Collection)}\n+     * with a guaranteed runtime complexity of {@code O(n)}. Depending on the type of\n+     * {@link Collection} provided, this method will be much faster than calling\n+     * {@link Collection#containsAll(Collection)} instead.\n+     *\n+     * @param coll1  the first collection, must not be null\n+     * @param coll2  the second collection, must not be null\n+     * @return <code>true</code> iff the intersection of the collections has the same cardinality\n+     *   as the set of unique elements from the second collection\n+     * @since 4.0\n+     */\n+    public static boolean containsAll(final Collection<?> coll1, final Collection<?> coll2) {\n+        if (coll2.isEmpty()) {\n+            return true;\n+        } else {\n+            final SetOperationCardinalityHelper<Object> helper =\n+                    new SetOperationCardinalityHelper<Object>(coll1, coll2);\n+            for (final Object obj : helper) {\n+                helper.setCardinality(obj, helper.min(obj));\n+            }\n+            return helper.list().size() == helper.sizeB();\n+        }\n+    }\n+    \n+    /**\n+     * Returns <code>true</code> iff at least one element is in both collections.\n+     * <p>\n+     * In other words, this method returns <code>true</code> iff the\n+     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n+     *\n+     * @param coll1  the first collection, must not be null\n+     * @param coll2  the second collection, must not be null\n+     * @return <code>true</code> iff the intersection of the collections is non-empty\n+     * @since 2.1\n+     * @see #intersection\n+     */\n+    public static boolean containsAny(final Collection<?> coll1, final Collection<?> coll2) {\n+        if (coll1.size() < coll2.size()) {\n+            for (final Object aColl1 : coll1) {\n+                if (coll2.contains(aColl1)) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (final Object aColl2 : coll2) {\n+                if (coll1.contains(aColl2)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a {@link Map} mapping each unique element in the given\n+     * {@link Collection} to an {@link Integer} representing the number\n+     * of occurrences of that element in the {@link Collection}.\n+     * <p>\n+     * Only those elements present in the collection will appear as\n+     * keys in the map.\n+     *\n+     * @param coll\n+     *            the collection to get the cardinality map for, must not be\n+     *            null\n+     * @param <O>\n+     *            the type of object in the returned {@link Map}. This is a\n+     *            super type of <I>.\n+     * @return the populated cardinality map\n+     */\n+    public static <O> Map<O, Integer> getCardinalityMap(final Iterable<? extends O> coll) {\n+        final Map<O, Integer> count = new HashMap<O, Integer>();\n+        for (final O obj : coll) {\n+            final Integer c = count.get(obj);\n+            if (c == null) {\n+                count.put(obj, Integer.valueOf(1));\n+            } else {\n+                count.put(obj, Integer.valueOf(c.intValue() + 1));\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff <i>a</i> is a sub-collection of <i>b</i>,\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less than or\n+     * equal to the cardinality of <i>e</i> in <i>b</i>, for each element <i>e</i>\n+     * in <i>a</i>.\n+     *\n+     * @param a the first (sub?) collection, must not be null\n+     * @param b the second (super?) collection, must not be null\n+     * @return <code>true</code> iff <i>a</i> is a sub-collection of <i>b</i>\n+     * @see #isProperSubCollection\n+     * @see Collection#containsAll\n+     */\n+    public static boolean isSubCollection(final Collection<?> a, final Collection<?> b) {\n+        final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        for (final Object obj : a) {\n+            if (helper.freqA(obj) > helper.freqB(obj)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>,\n+     * that is, iff the cardinality of <i>e</i> in <i>a</i> is less\n+     * than or equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i>, and there is at least one\n+     * element <i>f</i> such that the cardinality of <i>f</i> in <i>b</i>\n+     * is strictly greater than the cardinality of <i>f</i> in <i>a</i>.\n+     * <p>\n+     * The implementation assumes\n+     * <ul>\n+     *    <li><code>a.size()</code> and <code>b.size()</code> represent the\n+     *    total cardinality of <i>a</i> and <i>b</i>, resp. </li>\n+     *    <li><code>a.size() < Integer.MAXVALUE</code></li>\n+     * </ul>\n+     *\n+     * @param a  the first (sub?) collection, must not be null\n+     * @param b  the second (super?) collection, must not be null\n+     * @return <code>true</code> iff <i>a</i> is a <i>proper</i> sub-collection of <i>b</i>\n+     * @see #isSubCollection\n+     * @see Collection#containsAll\n+     */\n+    public static boolean isProperSubCollection(final Collection<?> a, final Collection<?> b) {\n+        return a.size() < b.size() && CollectionUtils.isSubCollection(a, b);\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n+     * exactly the same elements with exactly the same cardinalities.\n+     * <p>\n+     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n+     * equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n+     *\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n+     */\n+    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b) {\n+        if(a.size() != b.size()) {\n+            return false;\n+        }\n+        final CardinalityHelper<Object> helper = new CardinalityHelper<Object>(a, b);\n+        if(helper.cardinalityA.size() != helper.cardinalityB.size()) {\n+            return false;\n+        }\n+        for( final Object obj : helper.cardinalityA.keySet()) {\n+            if(helper.freqA(obj) != helper.freqB(obj)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> iff the given {@link Collection}s contain\n+     * exactly the same elements with exactly the same cardinalities.\n+     * <p>\n+     * That is, iff the cardinality of <i>e</i> in <i>a</i> is\n+     * equal to the cardinality of <i>e</i> in <i>b</i>,\n+     * for each element <i>e</i> in <i>a</i> or <i>b</i>.\n+     *\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @param equator  the Equator used for testing equality\n+     * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n+     * @throws IllegalArgumentException if the equator is null\n+     * @since 4.0\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) // we don't know the types due to wildcards in the signature\n+    public static boolean isEqualCollection(final Collection<?> a, final Collection<?> b, final Equator<?> equator) {\n+        if (equator == null) {\n+            throw new IllegalArgumentException(\"equator may not be null\");\n+        }\n+\n+        if(a.size() != b.size()) {\n+            return false;\n+        }\n+\n+        final Transformer transformer = new Transformer() {\n+            public EquatorWrapper<?> transform(final Object input) {\n+                return new EquatorWrapper(equator, input);\n+            }\n+        };\n+        \n+        return isEqualCollection(collect(a, transformer), collect(b, transformer));\n+    }\n+\n+    /**\n+     * Wraps another object and uses the provided Equator to implement\n+     * {@link #equals(Object)} and {@link #hashCode()}.\n+     * <p>\n+     * This class can be used to store objects into a Map.\n+     *  \n+     * @param <O>  the element type\n+     * @since 4.0\n+     */\n+    private static class EquatorWrapper<O> {\n+        private final Equator<O> equator;\n+        private final O object;\n+        \n+        public EquatorWrapper(final Equator<O> equator, final O object) {\n+            this.equator = equator;\n+            this.object = object;\n+        }\n+        \n+        public O getObject() {\n+            return object; \n+        }\n+        \n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (!(obj instanceof EquatorWrapper)) {\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final EquatorWrapper<O> otherObj = (EquatorWrapper<O>) obj;\n+            return equator.equate(object, otherObj.getObject());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return equator.hash(object);\n+        }        \n+    }\n+    \n+    /**\n+     * Returns the number of occurrences of <i>obj</i> in <i>coll</i>.\n+     *\n+     * @param obj the object to find the cardinality of\n+     * @param coll the {@link Iterable} to search\n+     * @param <O> the type of object that the {@link Iterable} may contain.\n+     * @return the the number of occurrences of obj in coll\n+     */\n+    public static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n+        if (coll instanceof Set<?>) {\n+            return ((Set<? super O>) coll).contains(obj) ? 1 : 0;\n+        }\n+        if (coll instanceof Bag<?>) {\n+            return ((Bag<? super O>) coll).getCount(obj);\n+        }\n+        int count = 0;\n+        if (obj == null) {\n+            for (final Object element : coll) {\n+                if (element == null) {\n+                    count++;\n+                }\n+            }\n+        } else {\n+            for (final Object element : coll) {\n+                if (obj.equals(element)) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Finds the first element in the given collection which matches the given predicate.\n+     * <p>\n+     * If the input collection or predicate is null, or no element of the collection\n+     * matches the predicate, null is returned.\n+     *\n+     * @param <T>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to search, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the first element of the collection which matches the predicate or null if none could be found\n+     */\n+    public static <T> T find(final Collection<T> collection, final Predicate<? super T> predicate) {\n+        if (collection != null && predicate != null) {\n+            for (final T item : collection) {\n+                if (predicate.evaluate(item)) {\n+                    return item;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Executes the given closure on each element in the collection.\n+     * <p>\n+     * If the input collection or closure is null, there is no change made.\n+     *\n+     * @param <T>  the type of object the {@link Collection} contains\n+     * @param <C>  the closure type\n+     * @param collection  the collection to get the input from, may be null\n+     * @param closure  the closure to perform, may be null\n+     * @return closure\n+     */\n+    public static <T, C extends Closure<? super T>> C forAllDo(final Collection<T> collection, final C closure) {\n+        if (collection != null && closure != null) {\n+            for (final T element : collection) {\n+                closure.execute(element);\n+            }\n+        }\n+        return closure;\n+    }\n+\n+    /**\n+     * Executes the given closure on each element in the collection.\n+     * <p>\n+     * If the input collection or closure is null, there is no change made.\n+     *\n+     * @param <T>  the type of object the {@link Iterator} contains\n+     * @param <C>  the closure type\n+     * @param iterator  the iterator to get the input from, may be null\n+     * @param closure  the closure to perform, may be null\n+     * @return closure\n+     * @since 4.0\n+     */\n+    public static <T, C extends Closure<? super T>> C forAllDo(final Iterator<T> iterator, final C closure) {\n+        if (iterator != null && closure != null) {\n+            while (iterator.hasNext()) {\n+                closure.execute(iterator.next());\n+            }\n+        }\n+        return closure;\n+    }\n+\n+    /**\n+     * Filter the collection by applying a Predicate to each element. If the\n+     * predicate returns false, remove the element.\n+     * <p>\n+     * If the input collection or predicate is null, there is no change made.\n+     *\n+     * @param <T>  the type of object the {@link Iterable} contains\n+     * @param collection  the collection to get the input from, may be null\n+     * @param predicate  the predicate to use as a filter, may be null\n+     * @return true if the collection is modified by this call, false otherwise.\n+     */\n+    public static <T> boolean filter(final Iterable<T> collection, final Predicate<? super T> predicate) {\n+        boolean result = false;\n+        if (collection != null && predicate != null) {\n+            for (final Iterator<T> it = collection.iterator(); it.hasNext();) {\n+                if (!predicate.evaluate(it.next())) {\n+                    it.remove();\n+                    result = true;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Filter the collection by applying a Predicate to each element. If the\n+     * predicate returns true, remove the element.\n+     * <p>\n+     * This is equivalent to <pre>filter(collection, PredicateUtils.notPredicate(predicate))</pre>\n+     * if predicate is != null.\n+     * <p>\n+     * If the input collection or predicate is null, there is no change made.\n+     *\n+     * @param <T>  the type of object the {@link Iterable} contains\n+     * @param collection  the collection to get the input from, may be null\n+     * @param predicate  the predicate to use as a filter, may be null\n+     * @return true if the collection is modified by this call, false otherwise.\n+     */\n+    public static <T> boolean filterInverse(final Iterable<T> collection, final Predicate<? super T> predicate) {\n+        return filter(collection, predicate == null ? null : PredicateUtils.notPredicate(predicate));\n+    }\n+\n+    /**\n+     * Transform the collection by applying a Transformer to each element.\n+     * <p>\n+     * If the input collection or transformer is null, there is no change made.\n+     * <p>\n+     * This routine is best for Lists, for which set() is used to do the\n+     * transformations \"in place.\" For other Collections, clear() and addAll()\n+     * are used to replace elements.\n+     * <p>\n+     * If the input collection controls its input, such as a Set, and the\n+     * Transformer creates duplicates (or are otherwise invalid), the collection\n+     * may reduce in size due to calling this method.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the {@link Iterable} to get the input from, may be null\n+     * @param transformer  the transformer to perform, may be null\n+     */\n+    public static <C> void transform(final Collection<C> collection,\n+            final Transformer<? super C, ? extends C> transformer) {\n+\n+        if (collection != null && transformer != null) {\n+            if (collection instanceof List<?>) {\n+                final List<C> list = (List<C>) collection;\n+                for (final ListIterator<C> it = list.listIterator(); it.hasNext();) {\n+                    it.set(transformer.transform(it.next()));\n+                }\n+            } else {\n+                final Collection<C> resultCollection = collect(collection, transformer);\n+                collection.clear();\n+                collection.addAll(resultCollection);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Counts the number of elements in the input collection that match the\n+     * predicate.\n+     * <p>\n+     * A <code>null</code> collection or predicate matches no elements.\n+     *\n+     * @param <C>  the type of object the {@link Iterable} contains\n+     * @param input  the {@link Iterable} to get the input from, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the number of matches for the predicate in the collection\n+     */\n+    public static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n+        int count = 0;\n+        if (input != null && predicate != null) {\n+            for (final C o : input) {\n+                if (predicate.evaluate(o)) {\n+                    count++;\n+                }\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Answers true if a predicate is true for at least one element of a\n+     * collection.\n+     * <p>\n+     * A <code>null</code> collection or predicate returns false.\n+     *\n+     * @param <C>  the type of object the {@link Iterable} contains\n+     * @param input  the {@link Iterable} to get the input from, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return true if at least one element of the collection matches the predicate\n+     */\n+    public static <C> boolean exists(final Iterable<C> input, final Predicate<? super C> predicate) {\n+        if (input != null && predicate != null) {\n+            for (final C o : input) {\n+                if (predicate.evaluate(o)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate into an output collection.\n+     * <p>\n+     * A <code>null</code> predicate matches no elements.\n+     *\n+     * @param <O>  the type of object the {@link Collection} contains\n+     * @param inputCollection  the collection to get the input from, may not be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the elements matching the predicate (new list)\n+     * @throws NullPointerException if the input collection is null\n+     */\n+    public static <O> Collection<O> select(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate) {\n+        return select(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate and adds them to outputCollection.\n+     * <p>\n+     * If the input collection or predicate is null, there is no change to the\n+     * output collection.\n+     *\n+     * @param <O>  the type of object the {@link Collection} contains\n+     * @param <R>  the type of the output {@link Collection}\n+     * @param inputCollection  the collection to get the input from, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n+     *   and predicate or not null\n+     * @return the outputCollection\n+     */\n+    public static <O, R extends Collection<? super O>> R select(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate, final R outputCollection) {\n+\n+        if (inputCollection != null && predicate != null) {\n+            for (final O item : inputCollection) {\n+                if (predicate.evaluate(item)) {\n+                    outputCollection.add(item);\n+                }\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate into an output collection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, the result is an empty\n+     * list.\n+     *\n+     * @param <O>  the type of object the {@link Collection} contains\n+     * @param inputCollection  the collection to get the input from, may not be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the elements <b>not</b> matching the predicate (new list)\n+     * @throws NullPointerException if the input collection is null\n+     */\n+    public static <O> Collection<O> selectRejected(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate) {\n+        return selectRejected(inputCollection, predicate, new ArrayList<O>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate and adds them to outputCollection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, no elements are added to\n+     * <code>outputCollection</code>.\n+     *\n+     * @param <O>  the type of object the {@link Collection} contains\n+     * @param <R>  the type of the output {@link Collection}\n+     * @param inputCollection  the collection to get the input from, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n+     *   and predicate or not null\n+     * @return outputCollection\n+     */\n+    public static <O, R extends Collection<? super O>> R selectRejected(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate, final R outputCollection) {\n+\n+        if (inputCollection != null && predicate != null) {\n+            for (final O item : inputCollection) {\n+                if (!predicate.evaluate(item)) {\n+                    outputCollection.add(item);\n+                }\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Returns a new Collection consisting of the elements of inputCollection\n+     * transformed by the given transformer.\n+     * <p>\n+     * If the input transformer is null, the result is an empty list.\n+     *\n+     * @param inputCollection  the collection to get the input from, may not be null\n+     * @param transformer  the transformer to use, may be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @return the transformed result (new list)\n+     * @throws NullPointerException if the input collection is null\n+     */\n+    public static <I, O> Collection<O> collect(final Iterable<I> inputCollection,\n+            final Transformer<? super I, ? extends O> transformer) {\n+        final ArrayList<O> answer = new ArrayList<O>();\n+        collect(inputCollection, transformer, answer);\n+        return answer;\n+    }\n+\n+    /**\n+     * Transforms all elements from the inputIterator with the given transformer\n+     * and adds them to the outputCollection.\n+     * <p>\n+     * If the input iterator or transformer is null, the result is an empty\n+     * list.\n+     *\n+     * @param inputIterator  the iterator to get the input from, may be null\n+     * @param transformer  the transformer to use, may be null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @return the transformed result (new list)\n+     */\n+    public static <I, O> Collection<O> collect(final Iterator<I> inputIterator,\n+            final Transformer<? super I, ? extends O> transformer) {\n+        final ArrayList<O> answer = new ArrayList<O>();\n+        collect(inputIterator, transformer, answer);\n+        return answer;\n+    }\n+\n+    /**\n+     * Transforms all elements from inputCollection with the given transformer\n+     * and adds them to the outputCollection.\n+     * <p>\n+     * If the input collection or transformer is null, there is no change to the\n+     * output collection.\n+     *\n+     * @param inputCollection  the collection to get the input from, may be null\n+     * @param transformer  the transformer to use, may be null\n+     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n+     *   and transformer are not null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n+     * @return the outputCollection with the transformed input added\n+     * @throws NullPointerException if the output collection is null and both, inputCollection and\n+     *   transformer are not null\n+     */\n+    public static <I, O, R extends Collection<? super O>> R collect(final Iterable<? extends I> inputCollection,\n+            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n+        if (inputCollection != null) {\n+            return collect(inputCollection.iterator(), transformer, outputCollection);\n+        }\n+        return outputCollection;\n+    }\n+\n+    /**\n+     * Transforms all elements from the inputIterator with the given transformer\n+     * and adds them to the outputCollection.\n+     * <p>\n+     * If the input iterator or transformer is null, there is no change to the\n+     * output collection.\n+     *\n+     * @param inputIterator  the iterator to get the input from, may be null\n+     * @param transformer  the transformer to use, may be null\n+     * @param outputCollection  the collection to output into, may not be null if the inputCollection\n+     *   and transformer are not null\n+     * @param <I> the type of object in the input collection\n+     * @param <O> the type of object in the output collection\n+     * @param <R> the output type of the transformer - this extends O.\n+     * @return the outputCollection with the transformed input added\n+     * @throws NullPointerException if the output collection is null and both, inputCollection and\n+     *   transformer are not null\n+     */\n+    //TODO - deprecate and replace with IteratorIterable\n+    public static <I, O, R extends Collection<? super O>> R collect(final Iterator<? extends I> inputIterator,\n+            final Transformer<? super I, ? extends O> transformer, final R outputCollection) {\n+        if (inputIterator != null && transformer != null) {\n+            while (inputIterator.hasNext()) {\n+                final I item = inputIterator.next();\n+                final O value = transformer.transform(item);\n+                outputCollection.add(value);\n+            }\n+        }\n+        return outputCollection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds an element to the collection unless the element is null.\n+     *\n+     * @param <T>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to add to, must not be null\n+     * @param object  the object to add, if null it will not be added\n+     * @return true if the collection changed\n+     * @throws NullPointerException if the collection is null\n+     * @since 3.2\n+     */\n+    public static <T> boolean addIgnoreNull(final Collection<T> collection, final T object) {\n+        if (collection == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        return object != null && collection.add(object);\n+    }\n+\n+    /**\n+     * Adds all elements in the {@link Iterable} to the given collection. If the\n+     * {@link Iterable} is a {@link Collection} then it is cast and will be\n+     * added using {@link Collection#addAll(Collection)} instead of iterating.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to add to, must not be null\n+     * @param iterable  the iterable of elements to add, must not be null\n+     * @return a boolean indicating whether the collection has changed or not.\n+     * @throws NullPointerException if the collection or iterator is null\n+     */\n+    public static <C> boolean addAll(final Collection<C> collection, final Iterable<? extends C> iterable) {\n+        if (iterable instanceof Collection<?>) {\n+            return collection.addAll((Collection<? extends C>) iterable);\n+        }\n+        return addAll(collection, iterable.iterator());\n+    }\n+\n+    /**\n+     * Adds all elements in the iteration to the given collection.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to add to, must not be null\n+     * @param iterator  the iterator of elements to add, must not be null\n+     * @return a boolean indicating whether the collection has changed or not.\n+     * @throws NullPointerException if the collection or iterator is null\n+     */\n+    public static <C> boolean addAll(final Collection<C> collection, final Iterator<? extends C> iterator) {\n+        boolean changed = false;\n+        while (iterator.hasNext()) {\n+            changed |= collection.add(iterator.next());\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Adds all elements in the enumeration to the given collection.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to add to, must not be null\n+     * @param enumeration  the enumeration of elements to add, must not be null\n+     * @return {@code true} if the collections was changed, {@code false} otherwise\n+     * @throws NullPointerException if the collection or enumeration is null\n+     */\n+    public static <C> boolean addAll(final Collection<C> collection, final Enumeration<? extends C> enumeration) {\n+        boolean changed = false;\n+        while (enumeration.hasMoreElements()) {\n+            changed |= collection.add(enumeration.nextElement());\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Adds all elements in the array to the given collection.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to add to, must not be null\n+     * @param elements  the array of elements to add, must not be null\n+     * @return {@code true} if the collection was changed, {@code false} otherwise\n+     * @throws NullPointerException if the collection or array is null\n+     */\n+    public static <C> boolean addAll(final Collection<C> collection, final C[] elements) {\n+        boolean changed = false;\n+        for (final C element : elements) {\n+            changed |= collection.add(element);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * <p>\n+     * The Iterator is advanced to <code>index</code> (or to the end, if\n+     * <code>index</code> exceeds the number of entries) as a side effect of this method.\n+     *\n+     * @param iterator  the iterator to get a value from\n+     * @param index  the index to get\n+     * @param <T> the type of object in the {@link Iterator}\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @throws IllegalArgumentException if the object type is invalid\n+     */\n+    public static <T> T get(final Iterator<T> iterator, final int index) {\n+        int i = index;\n+        checkIndexBounds(i);\n+        while (iterator.hasNext()) {\n+            i--;\n+            if (i == -1) {\n+                return iterator.next();\n+            }\n+            iterator.next();\n+        }\n+        throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+    }\n+\n+    /**\n+     * Ensures an index is not negative.\n+     * @param index the index to check.\n+     * @throws IndexOutOfBoundsException if the index is negative.\n+     */\n+    private static void checkIndexBounds(final int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + index);\n+        }\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in the <code>iterable</code>'s {@link Iterator}, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element.\n+     * <p>\n+     * If the {@link Iterable} is a {@link List}, then it will use {@link List#get(int)}.\n+     *\n+     * @param iterable  the {@link Iterable} to get a value from\n+     * @param index  the index to get\n+     * @param <T> the type of object in the {@link Iterable}.\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <T> T get(final Iterable<T> iterable, final int index) {\n+        checkIndexBounds(index);\n+        if (iterable instanceof List<?>) {\n+            return ((List<T>) iterable).get(index);\n+        }\n+        return get(iterable.iterator(), index);\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th value in <code>object</code>, throwing\n+     * <code>IndexOutOfBoundsException</code> if there is no such element or\n+     * <code>IllegalArgumentException</code> if <code>object</code> is not an\n+     * instance of one of the supported types.\n+     * <p>\n+     * The supported types, and associated semantics are:\n+     * <ul>\n+     * <li> Map -- the value returned is the <code>Map.Entry</code> in position\n+     *      <code>index</code> in the map's <code>entrySet</code> iterator,\n+     *      if there is such an entry.</li>\n+     * <li> List -- this method is equivalent to the list's get method.</li>\n+     * <li> Array -- the <code>index</code>-th array entry is returned,\n+     *      if there is such an entry; otherwise an <code>IndexOutOfBoundsException</code>\n+     *      is thrown.</li>\n+     * <li> Collection -- the value returned is the <code>index</code>-th object\n+     *      returned by the collection's default iterator, if there is such an element.</li>\n+     * <li> Iterator or Enumeration -- the value returned is the\n+     *      <code>index</code>-th object in the Iterator/Enumeration, if there\n+     *      is such an element.  The Iterator/Enumeration is advanced to\n+     *      <code>index</code> (or to the end, if <code>index</code> exceeds the\n+     *      number of entries) as a side effect of this method.</li>\n+     * </ul>\n+     *\n+     * @param object  the object to get a value from\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @throws IllegalArgumentException if the object type is invalid\n+     */\n+    public static Object get(final Object object, final int index) {\n+        int i = index;\n+        if (i < 0) {\n+            throw new IndexOutOfBoundsException(\"Index cannot be negative: \" + i);\n+        }\n+        if (object instanceof Map<?,?>) {\n+            final Map<?, ?> map = (Map<?, ?>) object;\n+            final Iterator<?> iterator = map.entrySet().iterator();\n+            return get(iterator, i);\n+        } else if (object instanceof Object[]) {\n+            return ((Object[]) object)[i];\n+        } else if (object instanceof Iterator<?>) {\n+            final Iterator<?> it = (Iterator<?>) object;\n+            while (it.hasNext()) {\n+                i--;\n+                if (i == -1) {\n+                    return it.next();\n+                }\n+                it.next();\n+            }\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+        } else if (object instanceof Collection<?>) {\n+            final Iterator<?> iterator = ((Collection<?>) object).iterator();\n+            return get(iterator, i);\n+        } else if (object instanceof Enumeration<?>) {\n+            final Enumeration<?> it = (Enumeration<?>) object;\n+            while (it.hasMoreElements()) {\n+                i--;\n+                if (i == -1) {\n+                    return it.nextElement();\n+                } else {\n+                    it.nextElement();\n+                }\n+            }\n+            throw new IndexOutOfBoundsException(\"Entry does not exist: \" + i);\n+        } else if (object == null) {\n+            throw new IllegalArgumentException(\"Unsupported object type: null\");\n+        } else {\n+            try {\n+                return Array.get(object, i);\n+            } catch (final IllegalArgumentException ex) {\n+                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the <code>index</code>-th <code>Map.Entry</code> in the <code>map</code>'s <code>entrySet</code>,\n+     * throwing <code>IndexOutOfBoundsException</code> if there is no such element.\n+     *\n+     * @param <K>  the key type in the {@link Map}\n+     * @param <V>  the key type in the {@link Map}\n+     * @param map  the object to get a value from\n+     * @param index  the index to get\n+     * @return the object at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public static <K,V> Map.Entry<K, V> get(final Map<K,V> map, final int index) {\n+        checkIndexBounds(index);\n+        return get(map.entrySet(), index);\n+    }\n+\n+    /**\n+     * Gets the size of the collection/iterator specified.\n+     * <p>\n+     * This method can handles objects as follows\n+     * <ul>\n+     * <li>Collection - the collection size\n+     * <li>Map - the map size\n+     * <li>Array - the array size\n+     * <li>Iterator - the number of elements remaining in the iterator\n+     * <li>Enumeration - the number of elements remaining in the enumeration\n+     * </ul>\n+     *\n+     * @param object  the object to get the size of, may be null\n+     * @return the size of the specified collection or 0 if the object was null\n+     * @throws IllegalArgumentException thrown if object is not recognised\n+     * @since 3.1\n+     */\n+    public static int size(final Object object) {\n+        if (object == null) {\n+            return 0;\n+        }\n+        int total = 0;\n+        if (object instanceof Map<?,?>) {\n+            total = ((Map<?, ?>) object).size();\n+        } else if (object instanceof Collection<?>) {\n+            total = ((Collection<?>) object).size();\n+        } else if (object instanceof Object[]) {\n+            total = ((Object[]) object).length;\n+        } else if (object instanceof Iterator<?>) {\n+            final Iterator<?> it = (Iterator<?>) object;\n+            while (it.hasNext()) {\n+                total++;\n+                it.next();\n+            }\n+        } else if (object instanceof Enumeration<?>) {\n+            final Enumeration<?> it = (Enumeration<?>) object;\n+            while (it.hasMoreElements()) {\n+                total++;\n+                it.nextElement();\n+            }\n+        } else {\n+            try {\n+                total = Array.getLength(object);\n+            } catch (final IllegalArgumentException ex) {\n+                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n+            }\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Checks if the specified collection/array/iterator is empty.\n+     * <p>\n+     * This method can handles objects as follows\n+     * <ul>\n+     * <li>Collection - via collection isEmpty\n+     * <li>Map - via map isEmpty\n+     * <li>Array - using array size\n+     * <li>Iterator - via hasNext\n+     * <li>Enumeration - via hasMoreElements\n+     * </ul>\n+     * <p>\n+     * Note: This method is named to avoid clashing with\n+     * {@link #isEmpty(Collection)}.\n+     *\n+     * @param object  the object to get the size of, may be null\n+     * @return true if empty or null\n+     * @throws IllegalArgumentException thrown if object is not recognised\n+     * @since 3.2\n+     */\n+    public static boolean sizeIsEmpty(final Object object) {\n+        if (object == null) {\n+            return true;\n+        } else if (object instanceof Collection<?>) {\n+            return ((Collection<?>) object).isEmpty();\n+        } else if (object instanceof Map<?, ?>) {\n+            return ((Map<?, ?>) object).isEmpty();\n+        } else if (object instanceof Object[]) {\n+            return ((Object[]) object).length == 0;\n+        } else if (object instanceof Iterator<?>) {\n+            return ((Iterator<?>) object).hasNext() == false;\n+        } else if (object instanceof Enumeration<?>) {\n+            return ((Enumeration<?>) object).hasMoreElements() == false;\n+        } else {\n+            try {\n+                return Array.getLength(object) == 0;\n+            } catch (final IllegalArgumentException ex) {\n+                throw new IllegalArgumentException(\"Unsupported object type: \" + object.getClass().getName());\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Null-safe check if the specified collection is empty.\n+     * <p>\n+     * Null returns true.\n+     *\n+     * @param coll  the collection to check, may be null\n+     * @return true if empty or null\n+     * @since 3.2\n+     */\n+    public static boolean isEmpty(final Collection<?> coll) {\n+        return coll == null || coll.isEmpty();\n+    }\n+\n+    /**\n+     * Null-safe check if the specified collection is not empty.\n+     * <p>\n+     * Null returns false.\n+     *\n+     * @param coll  the collection to check, may be null\n+     * @return true if non-null and non-empty\n+     * @since 3.2\n+     */\n+    public static boolean isNotEmpty(final Collection<?> coll) {\n+        return !isEmpty(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverses the order of the given array.\n+     *\n+     * @param array  the array to reverse\n+     */\n+    public static void reverseArray(final Object[] array) {\n+        int i = 0;\n+        int j = array.length - 1;\n+        Object tmp;\n+\n+        while (j > i) {\n+            tmp = array[j];\n+            array[j] = array[i];\n+            array[i] = tmp;\n+            j--;\n+            i++;\n+        }\n+    }\n+\n+    /**\n+     * Returns true if no more elements can be added to the Collection.\n+     * <p>\n+     * This method uses the {@link BoundedCollection} interface to determine the\n+     * full status. If the collection does not implement this interface then\n+     * false is returned.\n+     * <p>\n+     * The collection does not have to implement this interface directly.\n+     * If the collection has been decorated using the decorators subpackage\n+     * then these will be removed to access the BoundedCollection.\n+     *\n+     * @param coll  the collection to check\n+     * @return true if the BoundedCollection is full\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public static boolean isFull(final Collection<? extends Object> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        if (coll instanceof BoundedCollection) {\n+            return ((BoundedCollection<?>) coll).isFull();\n+        }\n+        try {\n+            final BoundedCollection<?> bcoll =\n+                    UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n+            return bcoll.isFull();\n+        } catch (final IllegalArgumentException ex) {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Get the maximum number of elements that the Collection can contain.\n+     * <p>\n+     * This method uses the {@link BoundedCollection} interface to determine the\n+     * maximum size. If the collection does not implement this interface then\n+     * -1 is returned.\n+     * <p>\n+     * The collection does not have to implement this interface directly.\n+     * If the collection has been decorated using the decorators subpackage\n+     * then these will be removed to access the BoundedCollection.\n+     *\n+     * @param coll  the collection to check\n+     * @return the maximum size of the BoundedCollection, -1 if no maximum size\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public static int maxSize(final Collection<? extends Object> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        if (coll instanceof BoundedCollection) {\n+            return ((BoundedCollection<?>) coll).maxSize();\n+        }\n+        try {\n+            final BoundedCollection<?> bcoll =\n+                    UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n+            return bcoll.maxSize();\n+        } catch (final IllegalArgumentException ex) {\n+            return -1;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a collection containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>c.retainAll(retain);</code>.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since 3.2\n+     */\n+    public static <C> Collection<C> retainAll(final Collection<C> collection, final Collection<?> retain) {\n+        return ListUtils.retainAll(collection, retain);\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a collection containing all the elements in <code>c</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     *\n+     * @param <E>  the type of object the {@link Collection} contains\n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>Collection</code> containing all the elements of <code>collection</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since 4.0 (method existed in 3.2 but was completely broken)\n+     */\n+    public static <E> Collection<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n+        return ListUtils.removeAll(collection, remove);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized collection backed by the given collection.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to\n+     * avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Collection c = CollectionUtils.synchronizedCollection(myCollection);\n+     * synchronized (c) {\n+     *     Iterator i = c.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to synchronize, must not be null\n+     * @return a synchronized collection backed by the given collection\n+     * @throws IllegalArgumentException  if the collection is null\n+     */\n+    public static <C> Collection<C> synchronizedCollection(final Collection<C> collection) {\n+        return SynchronizedCollection.synchronizedCollection(collection);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable collection backed by the given collection.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <C>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to make unmodifiable, must not be null\n+     * @return an unmodifiable collection backed by the given collection\n+     * @throws IllegalArgumentException  if the collection is null\n+     */\n+    public static <C> Collection<C> unmodifiableCollection(final Collection<C> collection) {\n+        return UnmodifiableCollection.unmodifiableCollection(collection);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) collection backed by the given collection.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the collection.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original collection after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param collection  the collection to predicate, must not be null\n+     * @param predicate  the predicate for the collection, must not be null\n+     * @param <C> the type of objects in the Collection.\n+     * @return a predicated collection backed by the given collection\n+     * @throws IllegalArgumentException  if the Collection is null\n+     */\n+    public static <C> Collection<C> predicatedCollection(final Collection<C> collection,\n+                                                         final Predicate<? super C> predicate) {\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed bag backed by the given collection.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Collection. It is important not to use the original collection after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified collection will not be transformed.\n+     * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n+     *\n+     * @param <E>  the type of object the {@link Collection} contains\n+     * @param collection  the collection to predicate, must not be null\n+     * @param transformer  the transformer for the collection, must not be null\n+     * @return a transformed collection backed by the given collection\n+     * @throws IllegalArgumentException  if the Collection or Transformer is null\n+     */\n+    public static <E> Collection<E> transformingCollection(final Collection<E> collection,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedCollection.transformingCollection(collection, transformer);\n+    }\n+\n+    /**\n+     * Extract the lone element of the specified Collection.\n+     * @param <E> collection type\n+     * @param collection to read\n+     * @return sole member of collection\n+     * @throws IllegalArgumentException if collection is null/empty or contains more than one element\n+     * @since 4.0\n+     */\n+    public static <E> E extractSingleton(final Collection<E> collection) {\n+        if (collection == null || collection.size() != 1) {\n+            throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n+        }\n+        return collection.iterator().next();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ComparatorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.comparators.BooleanComparator;\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+import org.apache.commons.collections4.comparators.ComparatorChain;\n+import org.apache.commons.collections4.comparators.NullComparator;\n+import org.apache.commons.collections4.comparators.ReverseComparator;\n+import org.apache.commons.collections4.comparators.TransformingComparator;\n+\n+/**\n+ * Provides convenient static utility methods for <Code>Comparator</Code>\n+ * objects.\n+ * <p>\n+ * Most of the functionality in this class can also be found in the \n+ * <code>comparators</code> package. This class merely provides a \n+ * convenient central place if you have use for more than one class\n+ * in the <code>comparators</code> subpackage.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class ComparatorUtils {\n+\n+    /**\n+     * ComparatorUtils should not normally be instantiated.\n+     */\n+    private ComparatorUtils() {}\n+\n+    /**\n+     * Comparator for natural sort order.\n+     *\n+     * @see ComparableComparator#comparableComparator()\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static final Comparator NATURAL_COMPARATOR = ComparableComparator.<Comparable>comparableComparator();\n+\n+    /**\n+     * Gets a comparator that uses the natural order of the objects.\n+     *\n+     * @param <E>  the object type to compare\n+     * @return  a comparator which uses natural order\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> naturalComparator() {\n+        return NATURAL_COMPARATOR;\n+    }\n+\n+    /**\n+     * Gets a comparator that compares using two {@link Comparator}s.\n+     * <p>\n+     * The second comparator is used if the first comparator returns equal.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param comparator1  the first comparator to use, not null\n+     * @param comparator2  the first comparator to use, not null\n+     * @return a {@link ComparatorChain} formed from the two comparators\n+     * @throws NullPointerException if either comparator is null\n+     * @see ComparatorChain\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(final Comparator<E> comparator1,\n+                                                                                    final Comparator<E> comparator2) {\n+        return chainedComparator(new Comparator[] {comparator1, comparator2});\n+    }\n+\n+    /**\n+     * Gets a comparator that compares using an array of {@link Comparator}s, applied\n+     * in sequence until one returns not equal or the array is exhausted.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param comparators  the comparators to use, not null or empty or containing nulls\n+     * @return a {@link ComparatorChain} formed from the input comparators\n+     * @throws NullPointerException if comparators array is null or contains a null\n+     * @see ComparatorChain\n+     */\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(\n+            final Comparator<E>[] comparators) {\n+\n+        final ComparatorChain<E> chain = new ComparatorChain<E>();\n+        for (final Comparator<E> comparator : comparators) {\n+            if (comparator == null) {\n+                throw new NullPointerException(\"Comparator cannot be null\");\n+            }\n+            chain.addComparator(comparator);\n+        }\n+        return chain;\n+    }\n+\n+    /**\n+     * Gets a comparator that compares using a collection of {@link Comparator}s,\n+     * applied in (default iterator) sequence until one returns not equal or the \n+     * collection is exhausted.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param comparators  the comparators to use, not null or empty or containing nulls\n+     * @return a {@link ComparatorChain} formed from the input comparators\n+     * @throws NullPointerException if comparators collection is null or contains a null\n+     * @throws ClassCastException if the comparators collection contains the wrong object type\n+     * @see ComparatorChain\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(\n+            final Collection<Comparator<E>> comparators) {\n+        \n+        return chainedComparator(\n+            (Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()])\n+        );\n+    }\n+\n+    /**\n+     * Gets a comparator that reverses the order of the given comparator.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param comparator  the comparator to reverse\n+     * @return  a comparator that reverses the order of the input comparator\n+     * @see ReverseComparator\n+     */\n+    public static <E> Comparator<E> reversedComparator(final Comparator<E> comparator) {\n+        return new ReverseComparator<E>(comparator);\n+    }\n+\n+    /**\n+     * Gets a Comparator that can sort Boolean objects.\n+     * <p>\n+     * The parameter specifies whether true or false is sorted first.\n+     * <p>\n+     * The comparator throws NullPointerException if a null value is compared.\n+     * \n+     * @param trueFirst  when <code>true</code>, sort \n+     *        <code>true</code> {@link Boolean}s before\n+     *        <code>false</code> {@link Boolean}s.\n+     * @return  a comparator that sorts booleans\n+     */\n+    public static Comparator<Boolean> booleanComparator(final boolean trueFirst) {\n+        return BooleanComparator.booleanComparator(trueFirst);\n+    }\n+    \n+    /**\n+     * Gets a Comparator that controls the comparison of <code>null</code> values.\n+     * <p>\n+     * The returned comparator will consider a null value to be less than\n+     * any nonnull value, and equal to any other null value.  Two nonnull\n+     * values will be evaluated with the given comparator.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param comparator the comparator that wants to allow nulls\n+     * @return  a version of that comparator that allows nulls\n+     * @see NullComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> nullLowComparator(Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new NullComparator<E>(comparator, false);\n+    }\n+\n+    /**\n+     * Gets a Comparator that controls the comparison of <code>null</code> values.\n+     * <p>\n+     * The returned comparator will consider a null value to be greater than\n+     * any nonnull value, and equal to any other null value.  Two nonnull\n+     * values will be evaluated with the given comparator.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param comparator the comparator that wants to allow nulls\n+     * @return  a version of that comparator that allows nulls\n+     * @see NullComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Comparator<E> nullHighComparator(Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new NullComparator<E>(comparator, true);\n+    }\n+\n+    /**\n+     * Gets a Comparator that passes transformed objects to the given comparator.\n+     * <p>\n+     * Objects passed to the returned comparator will first be transformed\n+     * by the given transformer before they are compared by the given\n+     * comparator.\n+     *\n+     * @param <I>  the input object type of the transformed comparator\n+     * @param <O>  the object type of the decorated comparator\n+     * @param comparator  the sort order to use\n+     * @param transformer  the transformer to use\n+     * @return  a comparator that transforms its input objects before comparing them\n+     * @see  TransformingComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Comparator<I> transformedComparator(Comparator<O> comparator,\n+            final Transformer<? super I, ? extends O> transformer) {\n+\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        return new TransformingComparator<I, O>(transformer, comparator);\n+    }\n+\n+    /**\n+     * Returns the smaller of the given objects according to the given \n+     * comparator, returning the second object if the comparator\n+     * returns equal.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param o1  the first object to compare\n+     * @param o2  the second object to compare\n+     * @param comparator  the sort order to use\n+     * @return  the smaller of the two objects\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E min(final E o1, final E o2, Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        final int c = comparator.compare(o1, o2);\n+        return c < 0 ? o1 : o2;\n+    }\n+\n+    /**\n+     * Returns the larger of the given objects according to the given \n+     * comparator, returning the second object if the comparator \n+     * returns equal.\n+     *\n+     * @param <E>  the object type to compare\n+     * @param o1  the first object to compare\n+     * @param o2  the second object to compare\n+     * @param comparator  the sort order to use\n+     * @return  the larger of the two objects\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> E max(final E o1, final E o2, Comparator<E> comparator) {\n+        if (comparator == null) {\n+            comparator = NATURAL_COMPARATOR;\n+        }\n+        final int c = comparator.compare(o1, o2);\n+        return c > 0 ? o1 : o2;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/EnumerationUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.collections4.iterators.EnumerationIterator;\n+\n+/**\n+ * Provides utility methods for {@link Enumeration} instances.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class EnumerationUtils {\n+\n+    /**\n+     * EnumerationUtils is not normally instantiated.\n+     */\n+    private EnumerationUtils() {}\n+    \n+    /**\n+     * Creates a list based on an enumeration.\n+     * \n+     * <p>As the enumeration is traversed, an ArrayList of its values is\n+     * created. The new list is returned.</p>\n+     *\n+     * @param <E> the element type\n+     * @param enumeration  the enumeration to traverse, which should not be <code>null</code>.\n+     * @return a list containing all elements of the given enumeration\n+     * @throws NullPointerException if the enumeration parameter is <code>null</code>.\n+     */\n+    public static <E> List<E> toList(final Enumeration<E> enumeration) {\n+        return IteratorUtils.toList(new EnumerationIterator<E>(enumeration));\n+    }\n+\n+    /**\n+     * Override toList(Enumeration) for StringTokenizer as it implements Enumeration<String>\n+     * for the sake of backward compatibility.\n+     *\n+     * @param stringTokenizer  the tokenizer to convert to a {@link #List(String)}\n+     * @return List<String>\n+     */\n+    public static List<String> toList(final StringTokenizer stringTokenizer) {\n+        final List<String> result = new ArrayList<String>(stringTokenizer.countTokens());\n+        while (stringTokenizer.hasMoreTokens()) {\n+            result.add(stringTokenizer.nextToken());\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Factory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a functor interface implemented by classes that create objects.\n+ * <p>\n+ * A <code>Factory</code> creates an object without using an input parameter.\n+ * If an input parameter is required, then {@link Transformer} is more appropriate.\n+ * <p>\n+ * Standard implementations of common factories are provided by\n+ * {@link FactoryUtils}. These include factories that return a constant,\n+ * a copy of a prototype or a new instance.\n+ *\n+ * @param <T> the type that the factory creates\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public interface Factory<T> {\n+\n+    /**\n+     * Create a new object.\n+     *\n+     * @return a new object\n+     * @throws FunctorException (runtime) if the factory cannot create an object\n+     */\n+    public T create();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/FactoryUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import org.apache.commons.collections4.functors.ConstantFactory;\n+import org.apache.commons.collections4.functors.ExceptionFactory;\n+import org.apache.commons.collections4.functors.InstantiateFactory;\n+import org.apache.commons.collections4.functors.PrototypeFactory;\n+\n+/**\n+ * <code>FactoryUtils</code> provides reference implementations and utilities\n+ * for the Factory functor interface. The supplied factories are:\n+ * <ul>\n+ * <li>Prototype - clones a specified object\n+ * <li>Reflection - creates objects using reflection\n+ * <li>Constant - always returns the same object\n+ * <li>Null - always returns null\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied factories are Serializable.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FactoryUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    private FactoryUtils() {}\n+\n+    /**\n+     * Gets a Factory that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections4.functors.ExceptionFactory\n+     * \n+     * @param <T> the type that the factory creates\n+     * @return the factory\n+     */\n+    public static <T> Factory<T> exceptionFactory() {\n+        return ExceptionFactory.<T>exceptionFactory();\n+    }\n+\n+    /**\n+     * Gets a Factory that will return null each time the factory is used.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @see org.apache.commons.collections4.functors.ConstantFactory\n+     * @param <T> the \"type\" of null object the factory should return.\n+     * @return the factory\n+     */\n+    public static <T> Factory<T> nullFactory() {\n+        return ConstantFactory.<T>constantFactory(null);\n+    }\n+\n+    /**\n+     * Creates a Factory that will return the same object each time the factory\n+     * is used. No check is made that the object is immutable. In general, only\n+     * immutable objects should use the constant factory. Mutable objects should\n+     * use the prototype factory.\n+     *\n+     * @see org.apache.commons.collections4.functors.ConstantFactory\n+     * \n+     * @param <T> the type that the factory creates\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n+        return ConstantFactory.constantFactory(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Factory that will return a clone of the same prototype object\n+     * each time the factory is used. The prototype will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     *\n+     * @see org.apache.commons.collections4.functors.PrototypeFactory\n+     * \n+     * @param <T> the type that the factory creates\n+     * @param prototype  the object to clone each time in the factory\n+     * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n+     * the {@code prototype} is {@code null}\n+     * @throws IllegalArgumentException if the prototype cannot be cloned\n+     */\n+    public static <T> Factory<T> prototypeFactory(final T prototype) {\n+        return PrototypeFactory.<T>prototypeFactory(prototype);\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * a no-args constructor.\n+     *\n+     * @see org.apache.commons.collections4.functors.InstantiateFactory\n+     * \n+     * @param <T> the type that the factory creates\n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @return the <code>reflection</code> factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     */\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n+        return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * the arguments specified to this method.\n+     *\n+     * @see org.apache.commons.collections4.functors.InstantiateFactory\n+     * \n+     * @param <T> the type that the factory creates\n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the <code>reflection</code> factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     * @throws IllegalArgumentException if the constructor doesn't exist\n+     */\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes,\n+                                                    final Object[] args) {\n+        return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/FunctorException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Runtime exception thrown from functors.\n+ * If required, a root cause error can be wrapped within this one.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FunctorException extends RuntimeException {\n+    \n+    /** Serialization version */\n+    private static final long serialVersionUID = -4704772662059351193L;\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> without specified\n+     * detail message.\n+     */\n+    public FunctorException() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public FunctorException(final String msg) {\n+        super(msg);\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FunctorException(final Throwable rootCause) {\n+        super(rootCause);\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FunctorException(final String msg, final Throwable rootCause) {\n+        super(msg, rootCause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Get.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Set;\n+\n+/**\n+ * The \"read\" subset of the {@link java.util.Map} interface.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ *\n+ * @see Put\n+ */\n+public interface Get<K, V> {\n+\n+    /**\n+     * @see java.util.Map#containsKey(Object)\n+     */\n+    public boolean containsKey(Object key);\n+\n+    /**\n+     * @see java.util.Map#containsValue(Object)\n+     */\n+    public boolean containsValue(Object value);\n+\n+    /**\n+     * @see java.util.Map#entrySet()\n+     */\n+    public Set<java.util.Map.Entry<K, V>> entrySet();\n+\n+    /**\n+     * @see java.util.Map#get(Object)\n+     */\n+    public V get(Object key);\n+\n+    /**\n+     * @see java.util.Map#remove(Object)\n+     */\n+    public V remove(Object key);\n+\n+    /**\n+     * @see java.util.Map#isEmpty()\n+     */\n+    public boolean isEmpty();\n+\n+    /**\n+     * @see java.util.Map#keySet()\n+     */\n+    public Set<K> keySet();\n+\n+    /**\n+     * @see java.util.Map#size()\n+     */\n+    public int size();\n+\n+    /**\n+     * @see java.util.Map#values()\n+     */\n+    public Collection<V> values();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/IterableGet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * The \"read\" subset of the {@link java.util.Map} interface.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ *\n+ * @see Put\n+ */\n+public interface IterableGet<K, V> extends Get<K, V> {\n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * <p>\n+     * A map iterator is an efficient way of iterating over maps.\n+     * There is no need to access the entry set or use Map Entry objects.\n+     * <pre>\n+     * IterableMap<String,Integer> map = new HashedMap<String,Integer>();\n+     * MapIterator<String,Integer> it = map.mapIterator();\n+     * while (it.hasNext()) {\n+     *   String key = it.next();\n+     *   Integer value = it.getValue();\n+     *   it.setValue(value + 1);\n+     * }\n+     * </pre>\n+     * \n+     * @return a map iterator\n+     */\n+    MapIterator<K, V> mapIterator();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/IterableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Map;\n+\n+/**\n+ * Defines a map that can be iterated directly without needing to create an entry set.\n+ * <p>\n+ * A map iterator is an efficient way of iterating over maps.\n+ * There is no need to access the entry set or use Map Entry objects.\n+ * <pre>\n+ * IterableMap<String,Integer> map = new HashedMap<String,Integer>();\n+ * MapIterator<String,Integer> it = map.mapIterator();\n+ * while (it.hasNext()) {\n+ *   String key = it.next();\n+ *   Integer value = it.getValue();\n+ *   it.setValue(value + 1);\n+ * }\n+ * </pre>\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface IterableMap<K, V> extends Map<K, V>, Put<K, V>, IterableGet<K, V> {\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/IterableSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.SortedMap;\n+\n+/**\n+ * {@link SortedMap} + {@link OrderedMap}.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface IterableSortedMap<K, V> extends SortedMap<K, V>, OrderedMap<K, V> {\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Dictionary;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.iterators.ArrayIterator;\n+import org.apache.commons.collections4.iterators.ArrayListIterator;\n+import org.apache.commons.collections4.iterators.CollatingIterator;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.EmptyListIterator;\n+import org.apache.commons.collections4.iterators.EmptyMapIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\n+import org.apache.commons.collections4.iterators.EnumerationIterator;\n+import org.apache.commons.collections4.iterators.FilterIterator;\n+import org.apache.commons.collections4.iterators.FilterListIterator;\n+import org.apache.commons.collections4.iterators.IteratorChain;\n+import org.apache.commons.collections4.iterators.IteratorEnumeration;\n+import org.apache.commons.collections4.iterators.IteratorIterable;\n+import org.apache.commons.collections4.iterators.ListIteratorWrapper;\n+import org.apache.commons.collections4.iterators.LoopingIterator;\n+import org.apache.commons.collections4.iterators.LoopingListIterator;\n+import org.apache.commons.collections4.iterators.NodeListIterator;\n+import org.apache.commons.collections4.iterators.ObjectArrayIterator;\n+import org.apache.commons.collections4.iterators.ObjectArrayListIterator;\n+import org.apache.commons.collections4.iterators.ObjectGraphIterator;\n+import org.apache.commons.collections4.iterators.SingletonIterator;\n+import org.apache.commons.collections4.iterators.SingletonListIterator;\n+import org.apache.commons.collections4.iterators.TransformIterator;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections4.iterators.UnmodifiableListIterator;\n+import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Provides static utility methods and decorators for {@link Iterator}\n+ * instances. The implementations are provided in the iterators subpackage.\n+ * <p>\n+ * WARNING: Due to human error certain binary incompatibilities were introduced\n+ * between Commons Collections 2.1 and 3.0. The class remained source and test\n+ * compatible, so if you can recompile all your classes and dependencies\n+ * everything is OK. Those methods which are binary incompatible are marked as\n+ * such, together with alternate solutions that are binary compatible\n+ * against versions 2.1.1 and 3.1.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class IteratorUtils {\n+    // validation is done in this class in certain cases because the\n+    // public classes allow invalid states\n+\n+    /**\n+     * An iterator over no elements.\n+     * <p>\n+     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n+     */\n+    public static final ResettableIterator<Object> EMPTY_ITERATOR = EmptyIterator.RESETTABLE_INSTANCE;\n+\n+    /**\n+     * A list iterator over no elements.\n+     * <p>\n+     * WARNING: This constant is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyListIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n+     */\n+    public static final ResettableListIterator<Object> EMPTY_LIST_ITERATOR = EmptyListIterator.RESETTABLE_INSTANCE;\n+\n+    /**\n+     * An ordered iterator over no elements.\n+     */\n+    public static final OrderedIterator<Object> EMPTY_ORDERED_ITERATOR = EmptyOrderedIterator.INSTANCE;\n+\n+    /**\n+     * A map iterator over no elements.\n+     */\n+    public static final MapIterator<Object, Object> EMPTY_MAP_ITERATOR = EmptyMapIterator.INSTANCE;\n+\n+    /**\n+     * An ordered map iterator over no elements.\n+     */\n+    public static final OrderedMapIterator<Object, Object> EMPTY_ORDERED_MAP_ITERATOR =\n+            EmptyOrderedMapIterator.INSTANCE;\n+\n+    /**\n+     * IteratorUtils is not normally instantiated.\n+     */\n+    private IteratorUtils() {}\n+\n+    // Empty\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an empty iterator.\n+     * <p>\n+     * This iterator is a valid iterator object that will iterate over\n+     * nothing.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n+     *\n+     * @param <E>  the element type\n+     * @return  an iterator over nothing\n+     */\n+    public static <E> ResettableIterator<E> emptyIterator() {\n+        return EmptyIterator.<E>resettableEmptyIterator();\n+    }\n+\n+    /**\n+     * Gets an empty list iterator.\n+     * <p>\n+     * This iterator is a valid list iterator object that will iterate\n+     * over nothing.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>EmptyListIterator.INSTANCE</code> for compatibility with Commons Collections 2.1.1.\n+     *\n+     * @param <E>  the element type\n+     * @return  a list iterator over nothing\n+     */\n+    public static <E> ResettableListIterator<E> emptyListIterator() {\n+        return EmptyListIterator.<E>resettableEmptyListIterator();\n+    }\n+\n+    /**\n+     * Gets an empty ordered iterator.\n+     * <p>\n+     * This iterator is a valid iterator object that will iterate\n+     * over nothing.\n+     *\n+     * @param <E>  the element type\n+     * @return  an ordered iterator over nothing\n+     */\n+    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n+        return EmptyOrderedIterator.<E>emptyOrderedIterator();\n+    }\n+\n+    /**\n+     * Gets an empty map iterator.\n+     * <p>\n+     * This iterator is a valid map iterator object that will iterate\n+     * over nothing.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @return  a map iterator over nothing\n+     */\n+    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n+        return EmptyMapIterator.<K, V>emptyMapIterator();\n+    }\n+\n+    /**\n+     * Gets an empty ordered map iterator.\n+     * <p>\n+     * This iterator is a valid map iterator object that will iterate\n+     * over nothing.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @return  a map iterator over nothing\n+     */\n+    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n+        return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n+    }\n+\n+    // Singleton\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a singleton iterator.\n+     * <p>\n+     * This iterator is a valid iterator object that will iterate over\n+     * the specified object.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new SingletonIterator(object)</code> for compatibility.\n+     *\n+     * @param <E>  the element type\n+     * @param object  the single object over which to iterate\n+     * @return  a singleton iterator over the object\n+     */\n+    public static <E> ResettableIterator<E> singletonIterator(final E object) {\n+        return new SingletonIterator<E>(object);\n+    }\n+\n+    /**\n+     * Gets a singleton list iterator.\n+     * <p>\n+     * This iterator is a valid list iterator object that will iterate over\n+     * the specified object.\n+     *\n+     * @param <E>  the element type\n+     * @param object  the single object over which to iterate\n+     * @return  a singleton list iterator over the object\n+     */\n+    public static <E> ListIterator<E> singletonListIterator(final E object) {\n+        return new SingletonListIterator<E>(object);\n+    }\n+\n+    // Arrays\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over an object array.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new ArrayIterator(array)</code> for compatibility.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @return  an iterator over the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(final E[] array) {\n+        return new ObjectArrayIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets an iterator over an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @return  an iterator over the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(final Object array) {\n+        return new ArrayIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets an iterator over the end part of an object array.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new ArrayIterator(array,start)</code> for compatibility.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return an iterator over part of the array\n+     * @throws IndexOutOfBoundsException if start is less than zero or greater\n+     *   than the length of the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start) {\n+        return new ObjectArrayIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets an iterator over the end part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return an iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws IndexOutOfBoundsException if start is less than zero or greater\n+     *   than the length of the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start) {\n+        return new ArrayIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets an iterator over part of an object array.\n+     * <p>\n+     * WARNING: This method is binary incompatible with Commons Collections 2.1 and 2.1.1.\n+     * Use <code>new ArrayIterator(array,start,end)</code> for compatibility.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return an iterator over part of the array\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws IllegalArgumentException if end is before start\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(final E[] array, final int start, final int end) {\n+        return new ObjectArrayIterator<E>(array, start, end);\n+    }\n+\n+    /**\n+     * Gets an iterator over part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return an iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array or end is before start\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableIterator<E> arrayIterator(final Object array, final int start, final int end) {\n+        return new ArrayIterator<E>(array, start, end);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a list iterator over an object array.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @return  a list iterator over the array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets a list iterator over an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @return  a list iterator over the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(final Object array) {\n+        return new ArrayListIterator<E>(array);\n+    }\n+\n+    /**\n+     * Gets a list iterator over the end part of an object array.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IndexOutOfBoundsException if start is less than zero\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start) {\n+        return new ObjectArrayListIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets a list iterator over the end part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array\n+     * @throws IndexOutOfBoundsException if start is less than zero\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start) {\n+        return new ArrayListIterator<E>(array, start);\n+    }\n+\n+    /**\n+     * Gets a list iterator over part of an object array.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws IllegalArgumentException if end is before start\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(final E[] array, final int start, final int end) {\n+        return new ObjectArrayListIterator<E>(array, start, end);\n+    }\n+\n+    /**\n+     * Gets a list iterator over part of an object or primitive array.\n+     * <p>\n+     * This method will handle primitive arrays as well as object arrays.\n+     * The primitives will be wrapped in the appropriate wrapper class.\n+     *\n+     * @param <E>  the element type\n+     * @param array  the array over which to iterate\n+     * @param start  the index to start iterating at\n+     * @param end  the index to finish iterating at\n+     * @return a list iterator over part of the array\n+     * @throws IllegalArgumentException if the array is not an array or end is before start\n+     * @throws IndexOutOfBoundsException if array bounds are invalid\n+     * @throws NullPointerException if array is null\n+     */\n+    public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n+        return new ArrayListIterator<E>(array, start, end);\n+    }\n+\n+    // Unmodifiable\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an immutable version of an {@link Iterator}. The returned object\n+     * will always throw an {@link UnsupportedOperationException} for\n+     * the {@link Iterator#remove} method.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to make immutable\n+     * @return an immutable version of the iterator\n+     */\n+    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n+        return UnmodifiableIterator.unmodifiableIterator(iterator);\n+    }\n+\n+    /**\n+     * Gets an immutable version of a {@link ListIterator}. The returned object\n+     * will always throw an {@link UnsupportedOperationException} for\n+     * the {@link Iterator#remove}, {@link ListIterator#add} and\n+     * {@link ListIterator#set} methods.\n+     *\n+     * @param <E>  the element type\n+     * @param listIterator  the iterator to make immutable\n+     * @return an immutable version of the iterator\n+     */\n+    public static <E> ListIterator<E> unmodifiableListIterator(final ListIterator<E> listIterator) {\n+        return UnmodifiableListIterator.umodifiableListIterator(listIterator);\n+    }\n+\n+    /**\n+     * Gets an immutable version of a {@link MapIterator}. The returned object\n+     * will always throw an {@link UnsupportedOperationException} for\n+     * the {@link Iterator#remove}, {@link MapIterator#setValue(Object)} methods.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param mapIterator  the iterator to make immutable\n+     * @return an immutable version of the iterator\n+     */\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> mapIterator) {\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(mapIterator);\n+    }\n+\n+    // Chained\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that iterates through two {@link Iterator}s\n+     * one after another.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator1  the first iterator to use, not null\n+     * @param iterator2  the second iterator to use, not null\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,\n+                                                  final Iterator<? extends E> iterator2) {\n+        return new IteratorChain<E>(iterator1, iterator2);\n+    }\n+\n+    /**\n+     * Gets an iterator that iterates through an array of {@link Iterator}s\n+     * one after another.\n+     *\n+     * @param <E>  the element type\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators array is null or contains a null\n+     */\n+    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E>[] iterators) {\n+        return new IteratorChain<E>(iterators);\n+    }\n+\n+    /**\n+     * Gets an iterator that iterates through a collections of {@link Iterator}s\n+     * one after another.\n+     *\n+     * @param <E>  the element type\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators collection is null or contains a null\n+     * @throws ClassCastException if the iterators collection contains the wrong object type\n+     */\n+    public static <E> Iterator<E> chainedIterator(final Collection<Iterator<? extends E>> iterators) {\n+        return new IteratorChain<E>(iterators);\n+    }\n+\n+    // Collated\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that provides an ordered iteration over the elements\n+     * contained in a collection of ordered {@link Iterator}s.\n+     * <p>\n+     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n+     * the {@link Iterator#next()} method will return the lesser of\n+     * <code>A.next()</code> and <code>B.next()</code>.\n+     * <p>\n+     * The comparator is optional. If null is specified then natural order is used.\n+     *\n+     * @param <E>  the element type\n+     * @param comparator  the comparator to use, may be null for natural order\n+     * @param iterator1  the first iterators to use, not null\n+     * @param iterator2  the first iterators to use, not null\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n+                                                   final Iterator<? extends E> iterator1,\n+                                                   final Iterator<? extends E> iterator2) {\n+        return new CollatingIterator<E>(comparator, iterator1, iterator2);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an ordered iteration over the elements\n+     * contained in an array of {@link Iterator}s.\n+     * <p>\n+     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n+     * the {@link Iterator#next()} method will return the lesser of\n+     * <code>A.next()</code> and <code>B.next()</code> and so on.\n+     * <p>\n+     * The comparator is optional. If null is specified then natural order is used.\n+     *\n+     * @param <E>  the element type\n+     * @param comparator  the comparator to use, may be null for natural order\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators array is null or contains a null value\n+     */\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n+                                                   final Iterator<? extends E>[] iterators) {\n+        return new CollatingIterator<E>(comparator, iterators);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an ordered iteration over the elements\n+     * contained in a collection of {@link Iterator}s.\n+     * <p>\n+     * Given two ordered {@link Iterator}s <code>A</code> and <code>B</code>,\n+     * the {@link Iterator#next()} method will return the lesser of\n+     * <code>A.next()</code> and <code>B.next()</code> and so on.\n+     * <p>\n+     * The comparator is optional. If null is specified then natural order is used.\n+     *\n+     * @param <E>  the element type\n+     * @param comparator  the comparator to use, may be null for natural order\n+     * @param iterators  the iterators to use, not null or empty or contain nulls\n+     * @return a combination iterator over the iterators\n+     * @throws NullPointerException if iterators collection is null or contains a null\n+     * @throws ClassCastException if the iterators collection contains the wrong object type\n+     */\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n+            final Collection<Iterator<? extends E>> iterators) {\n+        return new CollatingIterator<E>(comparator, iterators);\n+    }\n+\n+    // Object Graph\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that operates over an object graph.\n+     * <p>\n+     * This iterator can extract multiple objects from a complex tree-like object graph.\n+     * The iteration starts from a single root object.\n+     * It uses a <code>Transformer</code> to extract the iterators and elements.\n+     * Its main benefit is that no intermediate <code>List</code> is created.\n+     * <p>\n+     * For example, consider an object graph:\n+     * <pre>\n+     *                 |- Branch -- Leaf\n+     *                 |         \\- Leaf\n+     *         |- Tree |         /- Leaf\n+     *         |       |- Branch -- Leaf\n+     *  Forest |                 \\- Leaf\n+     *         |       |- Branch -- Leaf\n+     *         |       |         \\- Leaf\n+     *         |- Tree |         /- Leaf\n+     *                 |- Branch -- Leaf\n+     *                 |- Branch -- Leaf</pre>\n+     * The following <code>Transformer</code>, used in this class, will extract all\n+     * the Leaf objects without creating a combined intermediate list:\n+     * <pre>\n+     * public Object transform(Object input) {\n+     *   if (input instanceof Forest) {\n+     *     return ((Forest) input).treeIterator();\n+     *   }\n+     *   if (input instanceof Tree) {\n+     *     return ((Tree) input).branchIterator();\n+     *   }\n+     *   if (input instanceof Branch) {\n+     *     return ((Branch) input).leafIterator();\n+     *   }\n+     *   if (input instanceof Leaf) {\n+     *     return input;\n+     *   }\n+     *   throw new ClassCastException();\n+     * }</pre>\n+     * <p>\n+     * Internally, iteration starts from the root object. When next is called,\n+     * the transformer is called to examine the object. The transformer will return\n+     * either an iterator or an object. If the object is an Iterator, the next element\n+     * from that iterator is obtained and the process repeats. If the element is an object\n+     * it is returned.\n+     * <p>\n+     * Under many circumstances, linking Iterators together in this manner is\n+     * more efficient (and convenient) than using nested for loops to extract a list.\n+     *\n+     * @param <E>  the element type\n+     * @param root  the root object to start iterating from, null results in an empty iterator\n+     * @param transformer  the transformer to use, see above, null uses no effect transformer\n+     * @return a new object graph iterator\n+     * @since 3.1\n+     */\n+    public static <E> Iterator<E> objectGraphIterator(final E root,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return new ObjectGraphIterator<E>(root, transformer);\n+    }\n+\n+    // Transformed\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that transforms the elements of another iterator.\n+     * <p>\n+     * The transformation occurs during the next() method and the underlying\n+     * iterator is unaffected by the transformation.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param iterator  the iterator to use, not null\n+     * @param transform  the transform to use, not null\n+     * @return a new transforming iterator\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator,\n+            final Transformer<? super I, ? extends O> transform) {\n+\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (transform == null) {\n+            throw new NullPointerException(\"Transformer must not be null\");\n+        }\n+        return new TransformIterator<I, O>(iterator, transform);\n+    }\n+\n+    // Filtered\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that filters another iterator.\n+     * <p>\n+     * The returned iterator will only return objects that match the specified\n+     * filtering predicate.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @param predicate  the predicate to use as a filter, not null\n+     * @return a new filtered iterator\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator,\n+                                                   final Predicate<? super E> predicate) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new NullPointerException(\"Predicate must not be null\");\n+        }\n+        return new FilterIterator<E>(iterator, predicate);\n+    }\n+\n+    /**\n+     * Gets a list iterator that filters another list iterator.\n+     * <p>\n+     * The returned iterator will only return objects that match the specified\n+     * filtering predicate.\n+     *\n+     * @param <E>  the element type\n+     * @param listIterator  the list iterator to use, not null\n+     * @param predicate  the predicate to use as a filter, not null\n+     * @return a new filtered iterator\n+     * @throws NullPointerException if either parameter is null\n+     */\n+    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,\n+            final Predicate<? super E> predicate) {\n+\n+        if (listIterator == null) {\n+            throw new NullPointerException(\"ListIterator must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new NullPointerException(\"Predicate must not be null\");\n+        }\n+        return new FilterListIterator<E>(listIterator, predicate);\n+    }\n+\n+    // Looping\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that loops continuously over the supplied collection.\n+     * <p>\n+     * The iterator will only stop looping if the remove method is called\n+     * enough times to empty the collection, or if the collection is empty\n+     * to start with.\n+     *\n+     * @param <E>  the element type\n+     * @param coll  the collection to iterate over, not null\n+     * @return a new looping iterator\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public static <E> ResettableIterator<E> loopingIterator(final Collection<? extends E> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"Collection must not be null\");\n+        }\n+        return new LoopingIterator<E>(coll);\n+    }\n+\n+    /**\n+     * Gets an iterator that loops continuously over the supplied list.\n+     * <p>\n+     * The iterator will only stop looping if the remove method is called\n+     * enough times to empty the list, or if the list is empty to start with.\n+     *\n+     * @param <E>  the element type\n+     * @param list  the list to iterate over, not null\n+     * @return a new looping iterator\n+     * @throws NullPointerException if the list is null\n+     * @since 3.2\n+     */\n+    public static <E> ResettableListIterator<E> loopingListIterator(final List<E> list) {\n+        if (list == null) {\n+            throw new NullPointerException(\"List must not be null\");\n+        }\n+        return new LoopingListIterator<E>(list);\n+    }\n+\n+    // org.w3c.dom.NodeList iterators\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n+     * The returned {@link Iterator} can be used for a single iteration.\n+     *\n+     * @param nodeList the node list to use, not null\n+     * @return a new, single use {@link Iterator}\n+     * @throws NullPointerException if nodeList is null\n+     * @since 4.0\n+     */\n+    public static NodeListIterator nodeListIterator(final NodeList nodeList) {\n+        if (nodeList == null) {\n+            throw new NullPointerException(\"NodeList must not be null\");\n+        }\n+        return new NodeListIterator(nodeList);\n+    }\n+\n+    /**\n+     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n+     * The returned {@link Iterator} can be used for a single iteration.\n+     * <p>\n+     * Convenience method, allows easy iteration over NodeLists:\n+     * <pre>\n+     *   Iterator&lt;Node&gt; iterator = IteratorUtils.nodeListIterator(node);\n+     *   for(Node childNode : IteratorUtils.asIterable(iterator)) {\n+     *     ...\n+     *   }\n+     * </pre>\n+     *\n+     * @param node the node to use, not null\n+     * @return a new, single use {@link Iterator}\n+     * @throws NullPointerException if node is null\n+     * @since 4.0\n+     */\n+    public static NodeListIterator nodeListIterator(final Node node) {\n+        if (node == null) {\n+            throw new NullPointerException(\"Node must not be null\");\n+        }\n+        return new NodeListIterator(node);\n+    }\n+\n+    // Views\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator that provides an iterator view of the given enumeration.\n+     *\n+     * @param <E>  the element type\n+     * @param enumeration  the enumeration to use\n+     * @return a new iterator\n+     */\n+    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration) {\n+        if (enumeration == null) {\n+            throw new NullPointerException(\"Enumeration must not be null\");\n+        }\n+        return new EnumerationIterator<E>(enumeration);\n+    }\n+\n+    /**\n+     * Gets an iterator that provides an iterator view of the given enumeration\n+     * that will remove elements from the specified collection.\n+     *\n+     * @param <E>  the element type\n+     * @param enumeration  the enumeration to use\n+     * @param removeCollection  the collection to remove elements from\n+     * @return a new iterator\n+     */\n+    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n+                                             final Collection<? super E> removeCollection) {\n+        if (enumeration == null) {\n+            throw new NullPointerException(\"Enumeration must not be null\");\n+        }\n+        if (removeCollection == null) {\n+            throw new NullPointerException(\"Collection must not be null\");\n+        }\n+        return new EnumerationIterator<E>(enumeration, removeCollection);\n+    }\n+\n+    /**\n+     * Gets an enumeration that wraps an iterator.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @return a new enumeration\n+     * @throws NullPointerException if iterator is null\n+     */\n+    public static <E> Enumeration<E> asEnumeration(final Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new IteratorEnumeration<E>(iterator);\n+    }\n+\n+    /**\n+     * Gets an {@link Iterable} that wraps an iterator.  The returned {@link Iterable} can be\n+     * used for a single iteration.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @return a new, single use {@link Iterable}\n+     * @throws NullPointerException if iterator is null\n+     */\n+    public static <E> Iterable<E> asIterable(final Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new IteratorIterable<E>(iterator, false);\n+    }\n+\n+    \n+    /**\n+     * Gets an iterable that wraps an iterator.  The returned iterable can be\n+     * used for multiple iterations.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @return a new, multiple use iterable\n+     * @throws NullPointerException if iterator is null\n+     */\n+    public static <E> Iterable<E> asMultipleUseIterable(final Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new IteratorIterable<E>(iterator, true);\n+    }\n+\n+    /**\n+     * Gets a list iterator based on a simple iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, a LinkedList of its values is\n+     * cached, permitting all required operations of ListIterator.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @return a new iterator\n+     * @throws NullPointerException if iterator parameter is null\n+     */\n+    public static <E> ListIterator<E> toListIterator(final Iterator<? extends E> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        return new ListIteratorWrapper<E>(iterator);\n+    }\n+\n+    /**\n+     * Gets an array based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, this is converted to an array.\n+     *\n+     * @param iterator  the iterator to use, not null\n+     * @return an array of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     */\n+    public static Object[] toArray(final Iterator<?> iterator) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        final List<?> list = toList(iterator, 100);\n+        return list.toArray();\n+    }\n+\n+    /**\n+     * Gets an array based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, this is converted to an array.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @param arrayClass  the class of array to create\n+     * @return an array of the iterator contents\n+     * @throws NullPointerException if iterator parameter or arrayClass is null\n+     * @throws ClassCastException if the arrayClass is invalid\n+     */\n+    public static <E> E[] toArray(final Iterator<? extends E> iterator, final Class<E> arrayClass) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (arrayClass == null) {\n+            throw new NullPointerException(\"Array class must not be null\");\n+        }\n+        final List<E> list = toList(iterator, 100);\n+        @SuppressWarnings(\"unchecked\") // as per Javadoc, will throw CCE if class is wrong\n+        final E[] array = (E[]) Array.newInstance(arrayClass, list.size());\n+        return list.toArray(array);\n+    }\n+\n+    /**\n+     * Gets a list based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, the list is returned.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @return a list of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     */\n+    public static <E> List<E> toList(final Iterator<? extends E> iterator) {\n+        return toList(iterator, 10);\n+    }\n+\n+    /**\n+     * Gets a list based on an iterator.\n+     * <p>\n+     * As the wrapped Iterator is traversed, an ArrayList of its values is\n+     * created. At the end, the list is returned.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to use, not null\n+     * @param estimatedSize  the initial size of the ArrayList\n+     * @return a list of the iterator contents\n+     * @throws NullPointerException if iterator parameter is null\n+     * @throws IllegalArgumentException if the size is less than 1\n+     */\n+    public static <E> List<E> toList(final Iterator<? extends E> iterator, final int estimatedSize) {\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        if (estimatedSize < 1) {\n+            throw new IllegalArgumentException(\"Estimated size must be greater than 0\");\n+        }\n+        final List<E> list = new ArrayList<E>(estimatedSize);\n+        while (iterator.hasNext()) {\n+            list.add(iterator.next());\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Gets a suitable Iterator for the given object.\n+     * <p>\n+     * This method can handle objects as follows\n+     * <ul>\n+     * <li>null - empty iterator\n+     * <li>Iterator - returned directly\n+     * <li>Enumeration - wrapped\n+     * <li>Collection - iterator from collection returned\n+     * <li>Map - values iterator returned\n+     * <li>Dictionary - values (elements) enumeration returned as iterator\n+     * <li>array - iterator over array returned\n+     * <li>object with iterator() public method accessed by reflection\n+     * <li>object - singleton iterator\n+     * <li>NodeList - iterator over the list\n+     * <li>Node - iterator over the child nodes\n+     * </ul>\n+     *\n+     * @param obj  the object to convert to an iterator\n+     * @return a suitable iterator, never null\n+     */\n+    public static Iterator<?> getIterator(final Object obj) {\n+        if (obj == null) {\n+            return emptyIterator();\n+        }\n+        if (obj instanceof Iterator) {\n+            return (Iterator<?>) obj;\n+        }\n+        if (obj instanceof Collection) {\n+            return ((Collection<?>) obj).iterator();\n+        }\n+        if (obj instanceof Object[]) {\n+            return new ObjectArrayIterator<Object>((Object[]) obj);\n+        }\n+        if (obj instanceof Enumeration) {\n+            return new EnumerationIterator<Object>((Enumeration<?>) obj);\n+        }\n+        if (obj instanceof Map) {\n+            return ((Map<?, ?>) obj).values().iterator();\n+        }\n+        if (obj instanceof NodeList) {\n+            return new NodeListIterator((NodeList) obj);\n+        }\n+        if (obj instanceof Node) {\n+            return new NodeListIterator((Node) obj);\n+        }\n+        if (obj instanceof Dictionary) {\n+            return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n+        } else if (obj.getClass().isArray()) {\n+            return new ArrayIterator<Object>(obj);\n+        }\n+        try {\n+            final Method method = obj.getClass().getMethod(\"iterator\", (Class[]) null);\n+            if (Iterator.class.isAssignableFrom(method.getReturnType())) {\n+                final Iterator<?> it = (Iterator<?>) method.invoke(obj, (Object[]) null);\n+                if (it != null) {\n+                    return it;\n+                }\n+            }\n+        } catch (final RuntimeException e) {\n+            // ignore\n+        } catch (final NoSuchMethodException e) {\n+            // ignore\n+        } catch (final IllegalAccessException e) {\n+            // ignore\n+        } catch (final InvocationTargetException e) {\n+            // ignore\n+        }\n+        return singletonIterator(obj);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/KeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a simple key value pair.\n+ * <p>\n+ * A Map Entry has considerable additional semantics over and above a simple\n+ * key-value pair. This interface defines the minimum key value, with just the\n+ * two get methods.\n+ *\n+ * @param <K> the type of the key\n+ * @param <V> the type of the value\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface KeyValue<K, V> {\n+\n+    /**\n+     * Gets the key from the pair.\n+     *\n+     * @return the key \n+     */\n+    K getKey();\n+\n+    /**\n+     * Gets the value from the pair.\n+     *\n+     * @return the value\n+     */\n+    V getValue();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.list.FixedSizeList;\n+import org.apache.commons.collections4.list.LazyList;\n+import org.apache.commons.collections4.list.PredicatedList;\n+import org.apache.commons.collections4.list.TransformedList;\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * Provides utility methods and decorators for {@link List} instances.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ListUtils {\n+\n+    /**\n+     * <code>ListUtils</code> should not normally be instantiated.\n+     */\n+    private ListUtils() {}\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Returns an immutable empty list if the argument is <code>null</code>,\n+     * or the argument itself otherwise.\n+     * \n+     * @param <T> the element type\n+     * @param list the list, possibly <code>null</code>\n+     * @return an empty list if the argument is <code>null</code>\n+     */\n+    public static <T> List<T> emptyIfNull(final List<T> list) {\n+        return list == null ? Collections.<T>emptyList() : list;\n+    }\n+\n+    /**\n+     * Returns either the passed in list, or if the list is {@code null},\n+     * the value of {@code defaultList}.\n+     * \n+     * @param <T> the element type\n+     * @param list  the list, possibly {@code null}\n+     * @param defaultList  the returned values if list is {@code null}\n+     * @return an empty list if the argument is <code>null</code>\n+     * @since 4.0\n+     */\n+    public static <T> List<T> defaultIfNull(final List<T> list, final List<T> defaultList) {\n+        return list == null ? defaultList : list;\n+    }\n+    \n+    /**\n+     * Returns a new list containing all elements that are contained in\n+     * both given lists.\n+     *\n+     * @param <E>  the element type\n+     * @param list1  the first list\n+     * @param list2  the second list\n+     * @return  the intersection of those two lists\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static <E> List<E> intersection(final List<? extends E> list1, final List<? extends E> list2) {\n+        final List<E> result = new ArrayList<E>();\n+\n+        List<? extends E> smaller = list1;\n+        List<? extends E> larger = list2;\n+        if (list1.size() > list2.size()) {\n+            smaller = list2;\n+            larger = list1;\n+        }\n+        \n+        final HashSet<E> hashSet = new HashSet<E>(smaller);\n+\n+        for (final E e : larger) {\n+            if (hashSet.contains(e)) {\n+                result.add(e);\n+                hashSet.remove(e);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Subtracts all elements in the second list from the first list,\n+     * placing the results in a new list.\n+     * <p>\n+     * This differs from {@link List#removeAll(Collection)} in that\n+     * cardinality is respected; if <Code>list1</Code> contains two\n+     * occurrences of <Code>null</Code> and <Code>list2</Code> only\n+     * contains one occurrence, then the returned list will still contain\n+     * one occurrence.\n+     *\n+     * @param <E>  the element type\n+     * @param list1  the list to subtract from\n+     * @param list2  the list to subtract\n+     * @return  a new list containing the results\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n+        final ArrayList<E> result = new ArrayList<E>();\n+        final HashBag<E> bag = new HashBag<E>(list2);\n+        for (final E e : list1) {\n+            if (!bag.remove(e, 1)) {\n+                result.add(e);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the sum of the given lists.  This is their intersection\n+     * subtracted from their union.\n+     *\n+     * @param <E>  the element type\n+     * @param list1  the first list \n+     * @param list2  the second list\n+     * @return  a new list containing the sum of those lists\n+     * @throws NullPointerException if either list is null\n+     */ \n+    public static <E> List<E> sum(final List<? extends E> list1, final List<? extends E> list2) {\n+        return subtract(union(list1, list2), intersection(list1, list2));\n+    }\n+\n+    /**\n+     * Returns a new list containing the second list appended to the\n+     * first list.  The {@link List#addAll(Collection)} operation is\n+     * used to append the two given lists into a new list.\n+     *\n+     * @param <E>  the element type\n+     * @param list1  the first list \n+     * @param list2  the second list\n+     * @return  a new list containing the union of those lists\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n+        final ArrayList<E> result = new ArrayList<E>(list1);\n+        result.addAll(list2);\n+        return result;\n+    }\n+\n+    /**\n+     * Selects all elements from input collection which match the given\n+     * predicate into an output list.\n+     * <p>\n+     * A <code>null</code> predicate matches no elements.\n+     *\n+     * @param <E>  the element type\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return the elements matching the predicate (new list)\n+     * @throws NullPointerException\n+     *             if the input list is null\n+     *          \n+     * @since 4.0\n+     * @see CollectionUtils#select(Collection, Predicate)\n+     */\n+    public static <E> List<E> select(final Collection<? extends E> inputCollection,\n+            final Predicate<? super E> predicate) {\n+        return CollectionUtils.select(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Selects all elements from inputCollection which don't match the given\n+     * predicate into an output collection.\n+     * <p>\n+     * If the input predicate is <code>null</code>, the result is an empty\n+     * list.\n+     *\n+     * @param <E>  the element type\n+     * @param inputCollection\n+     *            the collection to get the input from, may not be null\n+     * @param predicate\n+     *            the predicate to use, may be null\n+     * @return the elements <b>not</b> matching the predicate (new list)\n+     * @throws NullPointerException\n+     *             if the input collection is null\n+     *          \n+     * @since 4.0\n+     * @see CollectionUtils#selectRejected(Collection, Predicate)\n+     */\n+    public static <E> List<E> selectRejected(final Collection<? extends E> inputCollection,\n+            final Predicate<? super E> predicate) {\n+        return CollectionUtils.selectRejected(inputCollection, predicate, new ArrayList<E>(inputCollection.size()));\n+    }\n+\n+    /**\n+     * Tests two lists for value-equality as per the equality contract in\n+     * {@link java.util.List#equals(java.lang.Object)}.\n+     * <p>\n+     * This method is useful for implementing <code>List</code> when you cannot\n+     * extend AbstractList. The method takes Collection instances to enable other\n+     * collection types to use the List implementation algorithm.\n+     * <p>\n+     * The relevant text (slightly paraphrased as this is a static method) is:\n+     * <blockquote>\n+     * Compares the two list objects for equality.  Returns\n+     * <tt>true</tt> if and only if both\n+     * lists have the same size, and all corresponding pairs of elements in\n+     * the two lists are <i>equal</i>.  (Two elements <tt>e1</tt> and\n+     * <tt>e2</tt> are <i>equal</i> if <tt>(e1==null ? e2==null :\n+     * e1.equals(e2))</tt>.)  In other words, two lists are defined to be\n+     * equal if they contain the same elements in the same order.  This\n+     * definition ensures that the equals method works properly across\n+     * different implementations of the <tt>List</tt> interface.\n+     * </blockquote>\n+     *\n+     * <b>Note:</b> The behaviour of this method is undefined if the lists are\n+     * modified during the equals comparison.\n+     * \n+     * @see java.util.List\n+     * @param list1  the first list, may be null\n+     * @param list2  the second list, may be null\n+     * @return whether the lists are equal by value comparison\n+     */\n+    public static boolean isEqualList(final Collection<?> list1, final Collection<?> list2) {\n+        if (list1 == list2) {\n+            return true;\n+        }\n+        if (list1 == null || list2 == null || list1.size() != list2.size()) {\n+            return false;\n+        }\n+\n+        final Iterator<?> it1 = list1.iterator();\n+        final Iterator<?> it2 = list2.iterator();\n+        Object obj1 = null;\n+        Object obj2 = null;\n+\n+        while (it1.hasNext() && it2.hasNext()) {\n+            obj1 = it1.next();\n+            obj2 = it2.next();\n+\n+            if (!(obj1 == null ? obj2 == null : obj1.equals(obj2))) {\n+                return false;\n+            }\n+        }\n+\n+        return !(it1.hasNext() || it2.hasNext());\n+    }\n+    \n+    /**\n+     * Generates a hash code using the algorithm specified in \n+     * {@link java.util.List#hashCode()}.\n+     * <p>\n+     * This method is useful for implementing <code>List</code> when you cannot\n+     * extend AbstractList. The method takes Collection instances to enable other\n+     * collection types to use the List implementation algorithm.\n+     * \n+     * @see java.util.List#hashCode()\n+     * @param list  the list to generate the hashCode for, may be null\n+     * @return the hash code\n+     */\n+    public static int hashCodeForList(final Collection<?> list) {\n+        if (list == null) {\n+            return 0;\n+        }\n+        int hashCode = 1;\n+        final Iterator<?> it = list.iterator();\n+        \n+        while (it.hasNext()) {\n+            final Object obj = it.next();\n+            hashCode = 31 * hashCode + (obj == null ? 0 : obj.hashCode());\n+        }\n+        return hashCode;\n+    }   \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a List containing all the elements in <code>collection</code>\n+     * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n+     * in the returned list is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>retain</code> does not contain <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * the collection <code>c</code> and thus cannot call <code>collection.retainAll(retain);</code>.\n+     * <p> \n+     * This implementation iterates over <code>collection</code>, checking each element in\n+     * turn to see if it's contained in <code>retain</code>. If it's contained, it's added\n+     * to the returned list. As a consequence, it is advised to use a collection type for\n+     * <code>retain</code> that provides a fast (e.g. O(1)) implementation of\n+     * {@link Collection#contains(Object)}.\n+     * \n+     * @param <E>  the element type\n+     * @param collection  the collection whose contents are the target of the #retailAll operation\n+     * @param retain  the collection containing the elements to be retained in the returned collection\n+     * @return a <code>List</code> containing all the elements of <code>c</code>\n+     * that occur at least once in <code>retain</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since 3.2\n+     */\n+    public static <E> List<E> retainAll(final Collection<E> collection, final Collection<?> retain) {\n+        final List<E> list = new ArrayList<E>(Math.min(collection.size(), retain.size()));\n+\n+        for (final E obj : collection) {\n+            if (retain.contains(obj)) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    /**\n+     * Removes the elements in <code>remove</code> from <code>collection</code>. That is, this\n+     * method returns a list containing all the elements in <code>collection</code>\n+     * that are not in <code>remove</code>. The cardinality of an element <code>e</code>\n+     * in the returned collection is the same as the cardinality of <code>e</code>\n+     * in <code>collection</code> unless <code>remove</code> contains <code>e</code>, in which\n+     * case the cardinality is zero. This method is useful if you do not wish to modify\n+     * <code>collection</code> and thus cannot call <code>collection.removeAll(remove);</code>.\n+     * <p> \n+     * This implementation iterates over <code>collection</code>, checking each element in\n+     * turn to see if it's contained in <code>remove</code>. If it's not contained, it's added\n+     * to the returned list. As a consequence, it is advised to use a collection type for\n+     * <code>remove</code> that provides a fast (e.g. O(1)) implementation of\n+     * {@link Collection#contains(Object)}.\n+     * \n+     * @param <E>  the element type\n+     * @param collection  the collection from which items are removed (in the returned collection)\n+     * @param remove  the items to be removed from the returned <code>collection</code>\n+     * @return a <code>List</code> containing all the elements of <code>c</code> except\n+     * any elements that also occur in <code>remove</code>.\n+     * @throws NullPointerException if either parameter is null\n+     * @since 3.2\n+     */\n+    public static <E> List<E> removeAll(final Collection<E> collection, final Collection<?> remove) {\n+        final List<E> list = new ArrayList<E>();\n+        for (final E obj : collection) {\n+            if (!remove.contains(obj)) {\n+                list.add(obj);\n+            }\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized list backed by the given list.\n+     * <p>\n+     * You must manually synchronize on the returned list's iterator to \n+     * avoid non-deterministic behavior:\n+     *  \n+     * <pre>\n+     * List list = ListUtils.synchronizedList(myList);\n+     * synchronized (list) {\n+     *     Iterator i = list.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n+     * \n+     * @param <E>  the element type\n+     * @param list  the list to synchronize, must not be null\n+     * @return a synchronized list backed by the given list\n+     * @throws IllegalArgumentException  if the list is null\n+     */\n+    public static <E> List<E> synchronizedList(final List<E> list) {\n+        return Collections.synchronizedList(list);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable list backed by the given list.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <E>  the element type\n+     * @param list  the list to make unmodifiable, must not be null\n+     * @return an unmodifiable list backed by the given list\n+     * @throws IllegalArgumentException  if the list is null\n+     */\n+    public static <E> List<E> unmodifiableList(final List<E> list) {\n+        return UnmodifiableList.unmodifiableList(list);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) list backed by the given list.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the list.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original list after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <E>  the element type\n+     * @param list  the list to predicate, must not be null\n+     * @param predicate  the predicate for the list, must not be null\n+     * @return a predicated list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Predicate is null\n+     */\n+    public static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n+        return PredicatedList.predicatedList(list, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed list backed by the given list.\n+     * <p>\n+     * This method returns a new list (decorating the specified list) that\n+     * will transform any new entries added to it.\n+     * Existing entries in the specified list will not be transformed.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * List. It is important not to use the original list after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified list will not be transformed.\n+     * If you want that behaviour, see {@link TransformedList#transformedList}.\n+     *\n+     * @param <E>  the element type\n+     * @param list  the list to predicate, must not be null\n+     * @param transformer  the transformer for the list, must not be null\n+     * @return a transformed list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Transformer is null\n+     */\n+    public static <E> List<E> transformedList(final List<E> list,\n+                                              final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedList.transformingList(list, transformer);\n+    }\n+    \n+    /**\n+     * Returns a \"lazy\" list whose elements will be created on demand.\n+     * <p>\n+     * When the index passed to the returned list's {@link List#get(int) get}\n+     * method is greater than the list's size, then the factory will be used\n+     * to create a new object and that object will be inserted at that index.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n+     *     public Date create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * List&lt;Date&gt; lazy = ListUtils.lazyList(new ArrayList&lt;Date&gt;(), factory);\n+     * Date date = lazy.get(3);\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>date</code> will refer to\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the fourth element in the list.  The first, second, \n+     * and third element are all set to <code>null</code>.\n+     *\n+     * @param <E>  the element type\n+     * @param list  the list to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Factory is null\n+     */\n+    public static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n+        return LazyList.lazyList(list, factory);\n+    }\n+\n+    /**\n+     * Returns a fixed-sized list backed by the given list.\n+     * Elements may not be added or removed from the returned list, but \n+     * existing elements can be changed (for instance, via the \n+     * {@link List#set(int,E)} method).\n+     *\n+     * @param <E>  the element type\n+     * @param list  the list whose size to fix, must not be null\n+     * @return a fixed-size list backed by that list\n+     * @throws IllegalArgumentException  if the List is null\n+     */\n+    public static <E> List<E> fixedSizeList(final List<E> list) {\n+        return FixedSizeList.fixedSizeList(list);\n+    }\n+\n+    /**\n+     * Finds the first index in the given List which matches the given predicate.\n+     * <p>\n+     * If the input List or predicate is null, or no element of the List\n+     * matches the predicate, -1 is returned.\n+     *\n+     * @param <E>  the element type\n+     * @param list the List to search, may be null\n+     * @param predicate  the predicate to use, may be null\n+     * @return the first index of an Object in the List which matches the predicate or -1 if none could be found\n+     */\n+    public static <E> int indexOf(final List<E> list, final Predicate<E> predicate) {\n+        if (list != null && predicate != null) {\n+            for (int i = 0; i < list.size(); i++) {\n+                final E item = list.get(i);\n+                if (predicate.evaluate(item)) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns consecutive {@link List#subList(int, int) sublists} of a\n+     * list, each of the same size (the final list may be smaller). For example,\n+     * partitioning a list containing {@code [a, b, c, d, e]} with a partition\n+     * size of 3 yields {@code [[a, b, c], [d, e]]} -- an outer list containing\n+     * two inner lists of three and two elements, all in the original order.\n+     * <p>\n+     * The outer list is unmodifiable, but reflects the latest state of the\n+     * source list. The inner lists are sublist views of the original list,\n+     * produced on demand using {@link List#subList(int, int)}, and are subject\n+     * to all the usual caveats about modification as explained in that API.\n+     * <p>\n+     * Adapted from http://code.google.com/p/guava-libraries/\n+     * \n+     * @param <T>  the element type\n+     * @param list  the list to return consecutive sublists of\n+     * @param size  the desired size of each sublist (the last may be smaller)\n+     * @return a list of consecutive sublists\n+     * @throws IllegalArgumentException if list is {@code null} or size is not strictly positive\n+     * @since 4.0\n+     */\n+    public static <T> List<List<T>> partition(final List<T> list, final int size) {\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");          \n+        }\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"Size must be greater than 0\");            \n+        }\n+        return new Partition<T>(list, size);\n+    }\n+    \n+    /**\n+     * Provides a partition view on a {@link List}.\n+     * @since 4.0\n+     */\n+    private static class Partition<T> extends AbstractList<List<T>> {\n+        private final List<T> list;\n+        private final int size;\n+\n+        private Partition(final List<T> list, final int size) {\n+            this.list = list;\n+            this.size = size;\n+        }\n+\n+        @Override\n+        public List<T> get(final int index) {\n+            final int listSize = size();\n+            if (listSize < 0) {\n+                throw new IllegalArgumentException(\"negative size: \" + listSize);           \n+            }\n+            if (index < 0) {\n+                throw new IndexOutOfBoundsException(\"Index \" + index + \" must not be negative\");         \n+            }\n+            if (index >= listSize) {\n+                throw new IndexOutOfBoundsException(\"Index \" + index + \" must be less than size \" +\n+                                                    listSize);           \n+            }           \n+            final int start = index * size;\n+            final int end = Math.min(start + size, list.size());\n+            return list.subList(start, end);\n+        }\n+\n+        @Override\n+        public int size() {\n+            return (list.size() + size - 1) / size;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return list.isEmpty();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/MapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Defines an iterator that operates over a <code>Map</code>.\n+ * <p>\n+ * This iterator is a special version designed for maps. It can be more\n+ * efficient to use this rather than an entry set iterator where the option\n+ * is available, and it is certainly more convenient.\n+ * <p>\n+ * A map that provides this interface may not hold the data internally using\n+ * Map Entry objects, thus this interface can avoid lots of object creation.\n+ * <p>\n+ * In use, this iterator iterates through the keys in the map. After each call\n+ * to <code>next()</code>, the <code>getValue()</code> method provides direct\n+ * access to the value. The value can also be set using <code>setValue()</code>.\n+ * <pre>\n+ * MapIterator<String,Integer> it = map.mapIterator();\n+ * while (it.hasNext()) {\n+ *   String key = it.next();\n+ *   Integer value = it.getValue();\n+ *   it.setValue(value + 1);\n+ * }\n+ * </pre>\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface MapIterator<K, V> extends Iterator<K> {\n+\n+    /**\n+     * Checks to see if there are more entries still to be iterated.\n+     *\n+     * @return <code>true</code> if the iterator has more elements\n+     */\n+    boolean hasNext();\n+\n+    /**\n+     * Gets the next <em>key</em> from the <code>Map</code>.\n+     *\n+     * @return the next key in the iteration\n+     * @throws java.util.NoSuchElementException if the iteration is finished\n+     */\n+    K next();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current key, which is the key returned by the last call\n+     * to <code>next()</code>.\n+     *\n+     * @return the current key\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    K getKey();\n+\n+    /**\n+     * Gets the current value, which is the value associated with the last key\n+     * returned by <code>next()</code>.\n+     *\n+     * @return the current value\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    V getValue();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes the last returned key from the underlying <code>Map</code> (optional operation).\n+     * <p>\n+     * This method can be called once per call to <code>next()</code>.\n+     *\n+     * @throws UnsupportedOperationException if remove is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has already been called\n+     *  since the last call to <code>next()</code>\n+     */\n+    void remove();\n+\n+    /**\n+     * Sets the value associated with the current key (optional operation).\n+     *\n+     * @param value  the new value\n+     * @return the previous value\n+     * @throws UnsupportedOperationException if setValue is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has been called since the\n+     *  last call to <code>next()</code>\n+     */\n+    V setValue(V value);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/MapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.io.PrintStream;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Properties;\n+import java.util.ResourceBundle;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.map.AbstractMapDecorator;\n+import org.apache.commons.collections4.map.AbstractSortedMapDecorator;\n+import org.apache.commons.collections4.map.FixedSizeMap;\n+import org.apache.commons.collections4.map.FixedSizeSortedMap;\n+import org.apache.commons.collections4.map.LazyMap;\n+import org.apache.commons.collections4.map.LazySortedMap;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+import org.apache.commons.collections4.map.MultiValueMap;\n+import org.apache.commons.collections4.map.PredicatedMap;\n+import org.apache.commons.collections4.map.PredicatedSortedMap;\n+import org.apache.commons.collections4.map.TransformedMap;\n+import org.apache.commons.collections4.map.TransformedSortedMap;\n+import org.apache.commons.collections4.map.UnmodifiableMap;\n+import org.apache.commons.collections4.map.UnmodifiableSortedMap;\n+\n+/**\n+ * Provides utility methods and decorators for\n+ * {@link Map} and {@link SortedMap} instances.\n+ * <p>\n+ * It contains various type safe methods\n+ * as well as other useful features like deep copying.\n+ * <p>\n+ * It also provides the following decorators:\n+ *\n+ *  <ul>\n+ *  <li>{@link #fixedSizeMap(Map)}\n+ *  <li>{@link #fixedSizeSortedMap(SortedMap)}\n+ *  <li>{@link #lazyMap(Map,Factory)}\n+ *  <li>{@link #lazyMap(Map,Transformer)}\n+ *  <li>{@link #lazySortedMap(SortedMap,Factory)}\n+ *  <li>{@link #lazySortedMap(SortedMap,Transformer)}\n+ *  <li>{@link #predicatedMap(Map,Predicate,Predicate)}\n+ *  <li>{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}\n+ *  <li>{@link #transformedMap(Map, Transformer, Transformer)}\n+ *  <li>{@link #transformedSortedMap(SortedMap, Transformer, Transformer)}\n+ *  <li>{@link #multiValueMap( Map )}\n+ *  <li>{@link #multiValueMap( Map, Class )}\n+ *  <li>{@link #multiValueMap( Map, Factory )}\n+ *  </ul>\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class MapUtils {\n+\n+    /**\n+     * An empty unmodifiable sorted map.\n+     * This is not provided in the JDK.\n+     */\n+    public static final SortedMap<Object, Object> EMPTY_SORTED_MAP =\n+            UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<Object, Object>());\n+\n+    /**\n+     * String used to indent the verbose and debug Map prints.\n+     */\n+    private static final String INDENT_STRING = \"    \";\n+\n+    /**\n+     * <code>MapUtils</code> should not normally be instantiated.\n+     */\n+    private MapUtils() {}\n+\n+    // Type safe getters\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets from a Map in a null-safe manner.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map, <code>null</code> if null map input\n+     */\n+    public static <K, V> V getObject(final Map<? super K, V> map, final K key) {\n+        if (map != null) {\n+            return map.get(key);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a String from a Map in a null-safe manner.\n+     * <p>\n+     * The String is obtained via <code>toString</code>.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a String, <code>null</code> if null map input\n+     */\n+    public static <K> String getString(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            final Object answer = map.get(key);\n+            if (answer != null) {\n+                return answer.toString();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Boolean from a Map in a null-safe manner.\n+     * <p>\n+     * If the value is a <code>Boolean</code> it is returned directly.\n+     * If the value is a <code>String</code> and it equals 'true' ignoring case\n+     * then <code>true</code> is returned, otherwise <code>false</code>.\n+     * If the value is a <code>Number</code> an integer zero value returns\n+     * <code>false</code> and non-zero returns <code>true</code>.\n+     * Otherwise, <code>null</code> is returned.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Boolean, <code>null</code> if null map input\n+     */\n+    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            final Object answer = map.get(key);\n+            if (answer != null) {\n+                if (answer instanceof Boolean) {\n+                    return (Boolean) answer;\n+                }\n+                if (answer instanceof String) {\n+                    return Boolean.valueOf((String) answer);\n+                }\n+                if (answer instanceof Number) {\n+                    final Number n = (Number) answer;\n+                    return n.intValue() != 0 ? Boolean.TRUE : Boolean.FALSE;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Number from a Map in a null-safe manner.\n+     * <p>\n+     * If the value is a <code>Number</code> it is returned directly.\n+     * If the value is a <code>String</code> it is converted using\n+     * {@link NumberFormat#parse(String)} on the system default formatter\n+     * returning <code>null</code> if the conversion fails.\n+     * Otherwise, <code>null</code> is returned.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Number, <code>null</code> if null map input\n+     */\n+    public static <K> Number getNumber(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            final Object answer = map.get(key);\n+            if (answer != null) {\n+                if (answer instanceof Number) {\n+                    return (Number) answer;\n+                }\n+                if (answer instanceof String) {\n+                    try {\n+                        final String text = (String) answer;\n+                        return NumberFormat.getInstance().parse(text);\n+                    } catch (final ParseException e) {\n+                        // failure means null is returned\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Byte from a Map in a null-safe manner.\n+     * <p>\n+     * The Byte is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Byte, <code>null</code> if null map input\n+     */\n+    public static <K> Byte getByte(final Map<? super K, ?> map, final K key) {\n+        final Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Byte) {\n+            return (Byte) answer;\n+        }\n+        return Byte.valueOf(answer.byteValue());\n+    }\n+\n+    /**\n+     * Gets a Short from a Map in a null-safe manner.\n+     * <p>\n+     * The Short is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Short, <code>null</code> if null map input\n+     */\n+    public static <K> Short getShort(final Map<? super K, ?> map, final K key) {\n+        final Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Short) {\n+            return (Short) answer;\n+        }\n+        return Short.valueOf(answer.shortValue());\n+    }\n+\n+    /**\n+     * Gets a Integer from a Map in a null-safe manner.\n+     * <p>\n+     * The Integer is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Integer, <code>null</code> if null map input\n+     */\n+    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key) {\n+        final Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Integer) {\n+            return (Integer) answer;\n+        }\n+        return Integer.valueOf(answer.intValue());\n+    }\n+\n+    /**\n+     * Gets a Long from a Map in a null-safe manner.\n+     * <p>\n+     * The Long is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Long, <code>null</code> if null map input\n+     */\n+    public static <K> Long getLong(final Map<? super K, ?> map, final K key) {\n+        final Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Long) {\n+            return (Long) answer;\n+        }\n+        return Long.valueOf(answer.longValue());\n+    }\n+\n+    /**\n+     * Gets a Float from a Map in a null-safe manner.\n+     * <p>\n+     * The Float is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Float, <code>null</code> if null map input\n+     */\n+    public static <K> Float getFloat(final Map<? super K, ?> map, final K key) {\n+        final Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Float) {\n+            return (Float) answer;\n+        }\n+        return Float.valueOf(answer.floatValue());\n+    }\n+\n+    /**\n+     * Gets a Double from a Map in a null-safe manner.\n+     * <p>\n+     * The Double is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Double, <code>null</code> if null map input\n+     */\n+    public static <K> Double getDouble(final Map<? super K, ?> map, final K key) {\n+        final Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            return null;\n+        }\n+        if (answer instanceof Double) {\n+            return (Double) answer;\n+        }\n+        return Double.valueOf(answer.doubleValue());\n+    }\n+\n+    /**\n+     * Gets a Map from a Map in a null-safe manner.\n+     * <p>\n+     * If the value returned from the specified map is not a Map then\n+     * <code>null</code> is returned.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Map, <code>null</code> if null map input\n+     */\n+    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key) {\n+        if (map != null) {\n+            final Object answer = map.get(key);\n+            if (answer != null && answer instanceof Map) {\n+                return (Map<?, ?>) answer;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Type safe getters with default values\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Looks up the given key in the given map, converting null into the\n+     * given default value.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null\n+     * @return  the value in the map, or defaultValue if the original value\n+     *   is null or the map is null\n+     */\n+    public static <K, V> V getObject(final Map<K, V> map, final K key, final V defaultValue) {\n+        if (map != null) {\n+            final V answer = map.get(key);\n+            if (answer != null) {\n+                return answer;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a string, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a string, or defaultValue if the\n+     *   original value is null, the map is null or the string conversion fails\n+     */\n+    public static <K> String getString(final Map<? super K, ?> map, final K key, final String defaultValue) {\n+        String answer = getString(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a boolean, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a boolean, or defaultValue if the\n+     *   original value is null, the map is null or the boolean conversion fails\n+     */\n+    public static <K> Boolean getBoolean(final Map<? super K, ?> map, final K key, final Boolean defaultValue) {\n+        Boolean answer = getBoolean(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a number, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Number getNumber(final Map<? super K, ?> map, final K key, final Number defaultValue) {\n+        Number answer = getNumber(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a byte, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Byte getByte(final Map<? super K, ?> map, final K key, final Byte defaultValue) {\n+        Byte answer = getByte(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a short, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Short getShort(final Map<? super K, ?> map, final K key, final Short defaultValue) {\n+        Short answer = getShort(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * an integer, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Integer getInteger(final Map<? super K, ?> map, final K key, final Integer defaultValue) {\n+        Integer answer = getInteger(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a long, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Long getLong(final Map<? super K, ?> map, final K key, final Long defaultValue) {\n+        Long answer = getLong(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a float, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Float getFloat(final Map<? super K, ?> map, final K key, final Float defaultValue) {\n+        Float answer = getFloat(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a double, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the number conversion fails\n+     */\n+    public static <K> Double getDouble(final Map<? super K, ?> map, final K key, final Double defaultValue) {\n+        Double answer = getDouble(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Looks up the given key in the given map, converting the result into\n+     * a map, using the default value if the the conversion fails.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map whose value to look up\n+     * @param key  the key of the value to look up in that map\n+     * @param defaultValue  what to return if the value is null or if the\n+     *   conversion fails\n+     * @return  the value in the map as a number, or defaultValue if the\n+     *   original value is null, the map is null or the map conversion fails\n+     */\n+    public static <K> Map<?, ?> getMap(final Map<? super K, ?> map, final K key, final Map<?, ?> defaultValue) {\n+        Map<?, ?> answer = getMap(map, key);\n+        if (answer == null) {\n+            answer = defaultValue;\n+        }\n+        return answer;\n+    }\n+\n+    // Type safe primitive getters\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets a boolean from a Map in a null-safe manner.\n+     * <p>\n+     * If the value is a <code>Boolean</code> its value is returned.\n+     * If the value is a <code>String</code> and it equals 'true' ignoring case\n+     * then <code>true</code> is returned, otherwise <code>false</code>.\n+     * If the value is a <code>Number</code> an integer zero value returns\n+     * <code>false</code> and non-zero returns <code>true</code>.\n+     * Otherwise, <code>false</code> is returned.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a Boolean, <code>false</code> if null map input\n+     */\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key) {\n+        return Boolean.TRUE.equals(getBoolean(map, key));\n+    }\n+\n+    /**\n+     * Gets a byte from a Map in a null-safe manner.\n+     * <p>\n+     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a byte, <code>0</code> if null map input\n+     */\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key) {\n+        final Byte byteObject = getByte(map, key);\n+        if (byteObject == null) {\n+            return 0;\n+        }\n+        return byteObject.byteValue();\n+    }\n+\n+    /**\n+     * Gets a short from a Map in a null-safe manner.\n+     * <p>\n+     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a short, <code>0</code> if null map input\n+     */\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key) {\n+        final Short shortObject = getShort(map, key);\n+        if (shortObject == null) {\n+            return 0;\n+        }\n+        return shortObject.shortValue();\n+    }\n+\n+    /**\n+     * Gets an int from a Map in a null-safe manner.\n+     * <p>\n+     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as an int, <code>0</code> if null map input\n+     */\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key) {\n+        final Integer integerObject = getInteger(map, key);\n+        if (integerObject == null) {\n+            return 0;\n+        }\n+        return integerObject.intValue();\n+    }\n+\n+    /**\n+     * Gets a long from a Map in a null-safe manner.\n+     * <p>\n+     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a long, <code>0L</code> if null map input\n+     */\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key) {\n+        final Long longObject = getLong(map, key);\n+        if (longObject == null) {\n+            return 0L;\n+        }\n+        return longObject.longValue();\n+    }\n+\n+    /**\n+     * Gets a float from a Map in a null-safe manner.\n+     * <p>\n+     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a float, <code>0.0F</code> if null map input\n+     */\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key) {\n+        final Float floatObject = getFloat(map, key);\n+        if (floatObject == null) {\n+            return 0f;\n+        }\n+        return floatObject.floatValue();\n+    }\n+\n+    /**\n+     * Gets a double from a Map in a null-safe manner.\n+     * <p>\n+     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @return the value in the Map as a double, <code>0.0</code> if null map input\n+     */\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key) {\n+        final Double doubleObject = getDouble(map, key);\n+        if (doubleObject == null) {\n+            return 0d;\n+        }\n+        return doubleObject.doubleValue();\n+    }\n+\n+    // Type safe primitive getters with default values\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets a boolean from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * If the value is a <code>Boolean</code> its value is returned.\n+     * If the value is a <code>String</code> and it equals 'true' ignoring case\n+     * then <code>true</code> is returned, otherwise <code>false</code>.\n+     * If the value is a <code>Number</code> an integer zero value returns\n+     * <code>false</code> and non-zero returns <code>true</code>.\n+     * Otherwise, <code>defaultValue</code> is returned.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as a Boolean, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> boolean getBooleanValue(final Map<? super K, ?> map, final K key, final boolean defaultValue) {\n+        final Boolean booleanObject = getBoolean(map, key);\n+        if (booleanObject == null) {\n+            return defaultValue;\n+        }\n+        return booleanObject.booleanValue();\n+    }\n+\n+    /**\n+     * Gets a byte from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The byte is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as a byte, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> byte getByteValue(final Map<? super K, ?> map, final K key, final byte defaultValue) {\n+        final Byte byteObject = getByte(map, key);\n+        if (byteObject == null) {\n+            return defaultValue;\n+        }\n+        return byteObject.byteValue();\n+    }\n+\n+    /**\n+     * Gets a short from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The short is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as a short, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> short getShortValue(final Map<? super K, ?> map, final K key, final short defaultValue) {\n+        final Short shortObject = getShort(map, key);\n+        if (shortObject == null) {\n+            return defaultValue;\n+        }\n+        return shortObject.shortValue();\n+    }\n+\n+    /**\n+     * Gets an int from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The int is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as an int, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> int getIntValue(final Map<? super K, ?> map, final K key, final int defaultValue) {\n+        final Integer integerObject = getInteger(map, key);\n+        if (integerObject == null) {\n+            return defaultValue;\n+        }\n+        return integerObject.intValue();\n+    }\n+\n+    /**\n+     * Gets a long from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The long is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as a long, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> long getLongValue(final Map<? super K, ?> map, final K key, final long defaultValue) {\n+        final Long longObject = getLong(map, key);\n+        if (longObject == null) {\n+            return defaultValue;\n+        }\n+        return longObject.longValue();\n+    }\n+\n+    /**\n+     * Gets a float from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The float is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as a float, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> float getFloatValue(final Map<? super K, ?> map, final K key, final float defaultValue) {\n+        final Float floatObject = getFloat(map, key);\n+        if (floatObject == null) {\n+            return defaultValue;\n+        }\n+        return floatObject.floatValue();\n+    }\n+\n+    /**\n+     * Gets a double from a Map in a null-safe manner,\n+     * using the default value if the the conversion fails.\n+     * <p>\n+     * The double is obtained from the results of {@link #getNumber(Map,Object)}.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to use\n+     * @param key  the key to look up\n+     * @param defaultValue  return if the value is null or if the conversion fails\n+     * @return the value in the Map as a double, <code>defaultValue</code> if null map input\n+     */\n+    public static <K> double getDoubleValue(final Map<? super K, ?> map, final K key, final double defaultValue) {\n+        final Double doubleObject = getDouble(map, key);\n+        if (doubleObject == null) {\n+            return defaultValue;\n+        }\n+        return doubleObject.doubleValue();\n+    }\n+\n+    // Conversion methods\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets a new Properties object initialised with the values from a Map.\n+     * A null input will return an empty properties object.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to convert to a Properties object\n+     * @return the properties object\n+     */\n+    public static <K, V> Properties toProperties(final Map<K, V> map) {\n+        final Properties answer = new Properties();\n+        if (map != null) {\n+            for (final Entry<K, V> entry2 : map.entrySet()) {\n+                final Map.Entry<?, ?> entry = entry2;\n+                final Object key = entry.getKey();\n+                final Object value = entry.getValue();\n+                answer.put(key, value);\n+            }\n+        }\n+        return answer;\n+    }\n+\n+    /**\n+     * Creates a new HashMap using data copied from a ResourceBundle.\n+     *\n+     * @param resourceBundle  the resource bundle to convert, may not be null\n+     * @return the hashmap containing the data\n+     * @throws NullPointerException if the bundle is null\n+     */\n+    public static Map<String, Object> toMap(final ResourceBundle resourceBundle) {\n+        final Enumeration<String> enumeration = resourceBundle.getKeys();\n+        final Map<String, Object> map = new HashMap<String, Object>();\n+\n+        while (enumeration.hasMoreElements()) {\n+            final String key = enumeration.nextElement();\n+            final Object value = resourceBundle.getObject(key);\n+            map.put(key, value);\n+        }\n+\n+        return map;\n+    }\n+\n+    // Printing methods\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Prints the given map with nice line breaks.\n+     * <p>\n+     * This method prints a nicely formatted String describing the Map.\n+     * Each map entry will be printed with key and value.\n+     * When the value is a Map, recursive behaviour occurs.\n+     * <p>\n+     * This method is NOT thread-safe in any special way. You must manually\n+     * synchronize on either this class or the stream as required.\n+     *\n+     * @param out  the stream to print to, must not be null\n+     * @param label  The label to be used, may be <code>null</code>.\n+     *  If <code>null</code>, the label is not output.\n+     *  It typically represents the name of the property in a bean or similar.\n+     * @param map  The map to print, may be <code>null</code>.\n+     *  If <code>null</code>, the text 'null' is output.\n+     * @throws NullPointerException if the stream is <code>null</code>\n+     */\n+    public static void verbosePrint(final PrintStream out, final Object label, final Map<?, ?> map) {\n+        verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), false);\n+    }\n+\n+    /**\n+     * Prints the given map with nice line breaks.\n+     * <p>\n+     * This method prints a nicely formatted String describing the Map.\n+     * Each map entry will be printed with key, value and value classname.\n+     * When the value is a Map, recursive behaviour occurs.\n+     * <p>\n+     * This method is NOT thread-safe in any special way. You must manually\n+     * synchronize on either this class or the stream as required.\n+     *\n+     * @param out  the stream to print to, must not be null\n+     * @param label  The label to be used, may be <code>null</code>.\n+     *   If <code>null</code>, the label is not output.\n+     *   It typically represents the name of the property in a bean or similar.\n+     * @param map  The map to print, may be <code>null</code>.\n+     *   If <code>null</code>, the text 'null' is output.\n+     * @throws NullPointerException if the stream is <code>null</code>\n+     */\n+    public static void debugPrint(final PrintStream out, final Object label, final Map<?, ?> map) {\n+        verbosePrintInternal(out, label, map, new ArrayStack<Map<?, ?>>(), true);\n+    }\n+\n+    // Implementation methods\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Implementation providing functionality for {@link #debugPrint} and for\n+     * {@link #verbosePrint}.  This prints the given map with nice line breaks.\n+     * If the debug flag is true, it additionally prints the type of the object\n+     * value.  If the contents of a map include the map itself, then the text\n+     * <em>(this Map)</em> is printed out.  If the contents include a\n+     * parent container of the map, the the text <em>(ancestor[i] Map)</em> is\n+     * printed, where i actually indicates the number of levels which must be\n+     * traversed in the sequential list of ancestors (e.g. father, grandfather,\n+     * great-grandfather, etc).\n+     *\n+     * @param out  the stream to print to\n+     * @param label  the label to be used, may be <code>null</code>.\n+     *   If <code>null</code>, the label is not output.\n+     *   It typically represents the name of the property in a bean or similar.\n+     * @param map  the map to print, may be <code>null</code>.\n+     *   If <code>null</code>, the text 'null' is output\n+     * @param lineage  a stack consisting of any maps in which the previous\n+     *   argument is contained. This is checked to avoid infinite recursion when\n+     *   printing the output\n+     * @param debug  flag indicating whether type names should be output.\n+     * @throws NullPointerException if the stream is <code>null</code>\n+     */\n+    private static void verbosePrintInternal(final PrintStream out, final Object label, final Map<?, ?> map,\n+                                             final ArrayStack<Map<?, ?>> lineage, final boolean debug) {\n+        printIndent(out, lineage.size());\n+\n+        if (map == null) {\n+            if (label != null) {\n+                out.print(label);\n+                out.print(\" = \");\n+            }\n+            out.println(\"null\");\n+            return;\n+        }\n+        if (label != null) {\n+            out.print(label);\n+            out.println(\" = \");\n+        }\n+\n+        printIndent(out, lineage.size());\n+        out.println(\"{\");\n+\n+        lineage.push(map);\n+\n+        for (final Map.Entry<?, ?> entry : map.entrySet()) {\n+            final Object childKey = entry.getKey();\n+            final Object childValue = entry.getValue();\n+            if (childValue instanceof Map && !lineage.contains(childValue)) {\n+                verbosePrintInternal(\n+                    out,\n+                    childKey == null ? \"null\" : childKey,\n+                    (Map<?, ?>) childValue,\n+                    lineage,\n+                    debug);\n+            } else {\n+                printIndent(out, lineage.size());\n+                out.print(childKey);\n+                out.print(\" = \");\n+\n+                final int lineageIndex = lineage.indexOf(childValue);\n+                if (lineageIndex == -1) {\n+                    out.print(childValue);\n+                } else if (lineage.size() - 1 == lineageIndex) {\n+                    out.print(\"(this Map)\");\n+                } else {\n+                    out.print(\n+                        \"(ancestor[\"\n+                            + (lineage.size() - 1 - lineageIndex - 1)\n+                            + \"] Map)\");\n+                }\n+\n+                if (debug && childValue != null) {\n+                    out.print(' ');\n+                    out.println(childValue.getClass().getName());\n+                } else {\n+                    out.println();\n+                }\n+            }\n+        }\n+\n+        lineage.pop();\n+\n+        printIndent(out, lineage.size());\n+        out.println(debug ? \"} \" + map.getClass().getName() : \"}\");\n+    }\n+\n+    /**\n+     * Writes indentation to the given stream.\n+     *\n+     * @param out  the stream to indent\n+     */\n+    private static void printIndent(final PrintStream out, final int indent) {\n+        for (int i = 0; i < indent; i++) {\n+            out.print(INDENT_STRING);\n+        }\n+    }\n+\n+    // Misc\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inverts the supplied map returning a new HashMap such that the keys of\n+     * the input are swapped with the values.\n+     * <p>\n+     * This operation assumes that the inverse mapping is well defined.\n+     * If the input map had multiple entries with the same value mapped to\n+     * different keys, the returned map will map one of those keys to the\n+     * value, but the exact key which will be mapped is undefined.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to invert, may not be null\n+     * @return a new HashMap containing the inverted data\n+     * @throws NullPointerException if the map is null\n+     */\n+    public static <K, V> Map<V, K> invertMap(final Map<K, V> map) {\n+        final Map<V, K> out = new HashMap<V, K>(map.size());\n+        for (final Entry<K, V> entry : map.entrySet()) {\n+            out.put(entry.getValue(), entry.getKey());\n+        }\n+        return out;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Protects against adding null values to a map.\n+     * <p>\n+     * This method checks the value being added to the map, and if it is null\n+     * it is replaced by an empty string.\n+     * <p>\n+     * This could be useful if the map does not accept null values, or for\n+     * receiving data from a source that may provide null or empty string\n+     * which should be held in the same way in the map.\n+     * <p>\n+     * Keys are not validated.\n+     * Note that this method can be used to circumvent the map's\n+     * value type at runtime.\n+     *\n+     * @param <K>  the key type\n+     * @param map  the map to add to, may not be null\n+     * @param key  the key\n+     * @param value  the value, null converted to \"\"\n+     * @throws NullPointerException if the map is null\n+     */\n+    public static <K> void safeAddToMap(final Map<? super K, Object> map, final K key, final Object value)\n+            throws NullPointerException {\n+        map.put(key, value == null ? \"\" : value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts all the keys and values from the specified array into the map.\n+     * <p>\n+     * This method is an alternative to the {@link java.util.Map#putAll(java.util.Map)}\n+     * method and constructors. It allows you to build a map from an object array\n+     * of various possible styles.\n+     * <p>\n+     * If the first entry in the object array implements {@link java.util.Map.Entry}\n+     * or {@link KeyValue} then the key and value are added from that object.\n+     * If the first entry in the object array is an object array itself, then\n+     * it is assumed that index 0 in the sub-array is the key and index 1 is the value.\n+     * Otherwise, the array is treated as keys and values in alternate indices.\n+     * <p>\n+     * For example, to create a color map:\n+     * <pre>\n+     * Map colorMap = MapUtils.putAll(new HashMap(), new String[][] {\n+     *     {\"RED\", \"#FF0000\"},\n+     *     {\"GREEN\", \"#00FF00\"},\n+     *     {\"BLUE\", \"#0000FF\"}\n+     * });\n+     * </pre>\n+     * or:\n+     * <pre>\n+     * Map colorMap = MapUtils.putAll(new HashMap(), new String[] {\n+     *     \"RED\", \"#FF0000\",\n+     *     \"GREEN\", \"#00FF00\",\n+     *     \"BLUE\", \"#0000FF\"\n+     * });\n+     * </pre>\n+     * or:\n+     * <pre>\n+     * Map colorMap = MapUtils.putAll(new HashMap(), new Map.Entry[] {\n+     *     new DefaultMapEntry(\"RED\", \"#FF0000\"),\n+     *     new DefaultMapEntry(\"GREEN\", \"#00FF00\"),\n+     *     new DefaultMapEntry(\"BLUE\", \"#0000FF\")\n+     * });\n+     * </pre>\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to populate, must not be null\n+     * @param array  an array to populate from, null ignored\n+     * @return the input map\n+     * @throws NullPointerException  if map is null\n+     * @throws IllegalArgumentException  if sub-array or entry matching used and an entry is invalid\n+     * @throws ClassCastException if the array contents is mixed\n+     * @since 3.2\n+     */\n+    @SuppressWarnings(\"unchecked\") // As per Javadoc throws CCE for invalid array contents\n+    public static <K, V> Map<K, V> putAll(final Map<K, V> map, final Object[] array) {\n+        map.size();  // force NPE\n+        if (array == null || array.length == 0) {\n+            return map;\n+        }\n+        final Object obj = array[0];\n+        if (obj instanceof Map.Entry) {\n+            for (final Object element : array) {\n+                // cast ok here, type is checked above\n+                final Map.Entry<K, V> entry = (Map.Entry<K, V>) element;\n+                map.put(entry.getKey(), entry.getValue());\n+            }\n+        } else if (obj instanceof KeyValue) {\n+            for (final Object element : array) {\n+                // cast ok here, type is checked above\n+                final KeyValue<K, V> keyval = (KeyValue<K, V>) element;\n+                map.put(keyval.getKey(), keyval.getValue());\n+            }\n+        } else if (obj instanceof Object[]) {\n+            for (int i = 0; i < array.length; i++) {\n+                final Object[] sub = (Object[]) array[i];\n+                if (sub == null || sub.length < 2) {\n+                    throw new IllegalArgumentException(\"Invalid array element: \" + i);\n+                }\n+                // these casts can fail if array has incorrect types\n+                map.put((K) sub[0], (V) sub[1]);\n+            }\n+        } else {\n+            for (int i = 0; i < array.length - 1;) {\n+                // these casts can fail if array has incorrect types\n+                map.put((K) array[i++], (V) array[i++]);\n+            }\n+        }\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Returns an immutable empty map if the argument is <code>null</code>,\n+     * or the argument itself otherwise.\n+     * \n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the map, possibly <code>null</code>\n+     * @return an empty map if the argument is <code>null</code>\n+     */\n+    public static <K,V> Map<K,V> emptyIfNull(final Map<K,V> map) {\n+        return map == null ? Collections.<K,V>emptyMap() : map;\n+    }\n+    \n+    /**\n+     * Null-safe check if the specified map is empty.\n+     * <p>\n+     * Null returns true.\n+     *\n+     * @param map  the map to check, may be null\n+     * @return true if empty or null\n+     * @since 3.2\n+     */\n+    public static boolean isEmpty(final Map<?,?> map) {\n+        return map == null || map.isEmpty();\n+    }\n+\n+    /**\n+     * Null-safe check if the specified map is not empty.\n+     * <p>\n+     * Null returns false.\n+     *\n+     * @param map  the map to check, may be null\n+     * @return true if non-null and non-empty\n+     * @since 3.2\n+     */\n+    public static boolean isNotEmpty(final Map<?,?> map) {\n+        return !MapUtils.isEmpty(map);\n+    }\n+\n+    // Map decorators\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized map backed by the given map.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to\n+     * avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Map m = MapUtils.synchronizedMap(myMap);\n+     * Set s = m.keySet();  // outside synchronized block\n+     * synchronized (m) {  // synchronized on MAP!\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * This method uses the implementation in {@link java.util.Collections Collections}.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to synchronize, must not be null\n+     * @return a synchronized map backed by the given map\n+     */\n+    public static <K, V> Map<K, V> synchronizedMap(final Map<K, V> map) {\n+        return Collections.synchronizedMap(map);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable map backed by the given map.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to make unmodifiable, must not be null\n+     * @return an unmodifiable map backed by the given map\n+     * @throws IllegalArgumentException  if the map is null\n+     */\n+    public static <K, V> Map<K, V> unmodifiableMap(final Map<K, V> map) {\n+        return UnmodifiableMap.unmodifiableMap(map);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) map backed by the given map.\n+     * <p>\n+     * Only objects that pass the tests in the given predicates can be added to the map.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * Keys must pass the key predicate, values must pass the value predicate.\n+     * It is important not to use the original map after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to predicate, must not be null\n+     * @param keyPred  the predicate for keys, null means no check\n+     * @param valuePred  the predicate for values, null means no check\n+     * @return a predicated map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred,\n+                                                         final Predicate<? super V> valuePred) {\n+        return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n+    }\n+\n+    /**\n+     * Returns a transformed map backed by the given map.\n+     * <p>\n+     * This method returns a new map (decorating the specified map) that\n+     * will transform any new entries added to it.\n+     * Existing entries in the specified map will not be transformed.\n+     * If you want that behaviour, see {@link TransformedMap#transformedMap}.\n+     * <p>\n+     * Each object is passed through the transformers as it is added to the\n+     * Map. It is important not to use the original map after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to transform, must not be null, typically empty\n+     * @param keyTransformer  the transformer for the map keys, null means no transformation\n+     * @param valueTransformer  the transformer for the map values, null means no transformation\n+     * @return a transformed map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        return TransformedMap.transformingMap(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Returns a fixed-sized map backed by the given map.\n+     * Elements may not be added or removed from the returned map, but\n+     * existing elements can be changed (for instance, via the\n+     * {@link Map#put(Object,Object)} method).\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map whose size to fix, must not be null\n+     * @return a fixed-size map backed by that map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n+        return FixedSizeMap.fixedSizeMap(map);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"test\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the value for the <code>\"test\"</code> key in the map.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Factory is null\n+     */\n+    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n+        return LazyMap.lazyMap(map, factory);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key. The factory is a {@link Transformer}\n+     * that will be passed the key which it must transform into the value.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Transformer factory = new Transformer() {\n+     *     public Object transform(Object mapKey) {\n+     *         return new File(mapKey);\n+     *     }\n+     * }\n+     * Map lazyMap = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazyMap.get(\"C:/dev\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>File</code> instance for the C drive dev directory.\n+     * Furthermore, that <code>File</code> instance is the value for the\n+     * <code>\"C:/dev\"</code> key in the map.\n+     * <p>\n+     * If a lazy map is wrapped by a synchronized map, the result is a simple\n+     * synchronized cache. When an object is not is the cache, the cache itself\n+     * calls back to the factory Transformer to populate itself, all within the\n+     * same synchronized block.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to make lazy, must not be null\n+     * @param transformerFactory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     */\n+    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends V> transformerFactory) {\n+        return LazyMap.lazyMap(map, transformerFactory);\n+    }\n+\n+    /**\n+     * Returns a map that maintains the order of keys that are added\n+     * backed by the given map.\n+     * <p>\n+     * If a key is added twice, the order is determined by the first add.\n+     * The order is observed through the keySet, values and entrySet.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to order, must not be null\n+     * @return an ordered map backed by the given map\n+     * @throws IllegalArgumentException  if the Map is null\n+     */\n+    public static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n+        return ListOrderedMap.listOrderedMap(map);\n+    }\n+\n+    /**\n+     * Creates a mult-value map backed by the given map which returns\n+     * collections of type ArrayList.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate\n+     * @return a multi-value map backed by the given map which returns ArrayLists of values.\n+     * @see MultiValueMap\n+     * @since 3.2\n+     */\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V>multiValueMap(map);\n+    }\n+\n+    /**\n+     * Creates a multi-value map backed by the given map which returns\n+     * collections of the specified type.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <C>  the collection class type\n+     * @param map  the map to decorate\n+     * @param collectionClass  the type of collections to return from the map (must contain public no-arg constructor\n+     *   and extend Collection).\n+     * @return a multi-value map backed by the given map which returns collections of the specified type\n+     * @see MultiValueMap\n+     * @since 3.2\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map,\n+            final Class<C> collectionClass) {\n+        return MultiValueMap.multiValueMap(map, collectionClass);\n+    }\n+\n+    /**\n+     * Creates a multi-value map backed by the given map which returns\n+     * collections created by the specified collection factory.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <C>  the collection class type\n+     * @param map  the map to decorate\n+     * @param collectionFactory  a factor which creates collection objects\n+     * @return a multi-value map backed by the given map which returns collections\n+     *   created by the specified collection factory\n+     * @see MultiValueMap\n+     * @since 3.2\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map,\n+            final Factory<C> collectionFactory) {\n+        return MultiValueMap.multiValueMap(map, collectionFactory);\n+    }\n+\n+    // SortedMap decorators\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized sorted map backed by the given sorted map.\n+     * <p>\n+     * You must manually synchronize on the returned buffer's iterator to\n+     * avoid non-deterministic behavior:\n+     *\n+     * <pre>\n+     * Map m = MapUtils.synchronizedSortedMap(myMap);\n+     * Set s = m.keySet();  // outside synchronized block\n+     * synchronized (m) {  // synchronized on MAP!\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * This method uses the implementation in {@link java.util.Collections Collections}.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to synchronize, must not be null\n+     * @return a synchronized map backed by the given map\n+     * @throws IllegalArgumentException  if the map is null\n+     */\n+    public static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n+        return Collections.synchronizedSortedMap(map);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable sorted map backed by the given sorted map.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the sorted map to make unmodifiable, must not be null\n+     * @return an unmodifiable map backed by the given map\n+     * @throws IllegalArgumentException  if the map is null\n+     */\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, V> map) {\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) sorted map backed by the given map.\n+     * <p>\n+     * Only objects that pass the tests in the given predicates can be added to the map.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * Keys must pass the key predicate, values must pass the value predicate.\n+     * It is important not to use the original map after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to predicate, must not be null\n+     * @param keyPred  the predicate for keys, null means no check\n+     * @param valuePred  the predicate for values, null means no check\n+     * @return a predicated map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n+     */\n+    public static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n+            final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPred, valuePred);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted map backed by the given map.\n+     * <p>\n+     * This method returns a new sorted map (decorating the specified map) that\n+     * will transform any new entries added to it.\n+     * Existing entries in the specified map will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSortedMap#transformedSortedMap}.\n+     * <p>\n+     * Each object is passed through the transformers as it is added to the\n+     * Map. It is important not to use the original map after invoking this\n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to transform, must not be null, typically empty\n+     * @param keyTransformer  the transformer for the map keys, null means no transformation\n+     * @param valueTransformer  the transformer for the map values, null means no transformation\n+     * @return a transformed map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n+     */\n+    public static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        return TransformedSortedMap.transformingSortedMap(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Returns a fixed-sized sorted map backed by the given sorted map.\n+     * Elements may not be added or removed from the returned map, but\n+     * existing elements can be changed (for instance, via the\n+     * {@link Map#put(Object,Object)} method).\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map whose size to fix, must not be null\n+     * @return a fixed-size map backed by that map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n+     */\n+    public static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" sorted map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n+     * Object obj = lazy.get(\"test\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the value for the <code>\"test\"</code> key.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap or Factory is null\n+     */\n+    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n+        return LazySortedMap.lazySortedMap(map, factory);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" sorted map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key. The factory is a {@link Transformer}\n+     * that will be passed the key which it must transform into the value.\n+     * <p>\n+     * For instance:\n+     * <pre>\n+     * Transformer factory = new Transformer() {\n+     *     public Object transform(Object mapKey) {\n+     *         return new File(mapKey);\n+     *     }\n+     * }\n+     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n+     * Object obj = lazy.get(\"C:/dev\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>File</code> instance for the C drive dev directory.\n+     * Furthermore, that <code>File</code> instance is the value for the\n+     * <code>\"C:/dev\"</code> key in the map.\n+     * <p>\n+     * If a lazy map is wrapped by a synchronized map, the result is a simple\n+     * synchronized cache. When an object is not is the cache, the cache itself\n+     * calls back to the factory Transformer to populate itself, all within the\n+     * same synchronized block.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to make lazy, must not be null\n+     * @param transformerFactory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     */\n+    public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends V> transformerFactory) {\n+        return LazySortedMap.lazySortedMap(map, transformerFactory);\n+    }\n+\n+    /**\n+     * Populates a Map using the supplied <code>Transformer</code> to transform the collection\n+     * values into keys, using the unaltered collection value as the value in the <code>Map</code>.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map the <code>Map</code> to populate.\n+     * @param collection the <code>Collection</code> to use as input values for the map.\n+     * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n+     * @throws NullPointerException if the map, collection or transformer are null\n+     */\n+    public static <K, V> void populateMap(final Map<K, V> map, final Collection<? extends V> collection,\n+                                          final Transformer<V, K> keyTransformer) {\n+        populateMap(map, collection, keyTransformer, TransformerUtils.<V>nopTransformer());\n+    }\n+\n+    /**\n+     * Populates a Map using the supplied <code>Transformer</code>s to transform the collection\n+     * values into keys and values.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <E>  the type of object contained in the {@link Collection}\n+     * @param map the <code>Map</code> to populate.\n+     * @param collection the <code>Collection</code> to use as input values for the map.\n+     * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n+     * @param valueTransformer the <code>Transformer</code> used to transform the collection value into a value\n+     * @throws NullPointerException if the map, collection or transformers are null\n+     */\n+    public static <K, V, E> void populateMap(final Map<K, V> map, final Collection<? extends E> collection, \n+                                             final Transformer<E, K> keyTransformer, \n+                                             final Transformer<E, V> valueTransformer) {\n+        final Iterator<? extends E> iter = collection.iterator();\n+        while (iter.hasNext()) {\n+            final E temp = iter.next();\n+            map.put(keyTransformer.transform(temp), valueTransformer.transform(temp));\n+        }\n+    }\n+\n+    /**\n+     * Get the specified {@link Map} as an {@link IterableMap}.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map to wrap if necessary.\n+     * @return IterableMap<K, V>\n+     * @since 4.0\n+     */\n+    public static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {};\n+    }\n+\n+    /**\n+     * Get the specified {@link SortedMap} as an {@link IterableSortedMap}.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param sortedMap to wrap if necessary\n+     * @return {@link IterableSortedMap}<K, V>\n+     * @since 4.0\n+     */\n+    public static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n+        if (sortedMap == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap :\n+                                                        new AbstractSortedMapDecorator<K, V>(sortedMap) {};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/MultiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+\n+/** \n+ * Defines a map that holds a collection of values against each key.\n+ * <p>\n+ * A <code>MultiMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that key.\n+ * <p>\n+ * For example:\n+ * <pre>\n+ * MultiMap mhm = new MultiValueMap();\n+ * mhm.put(key, \"A\");\n+ * mhm.put(key, \"B\");\n+ * mhm.put(key, \"C\");\n+ * Collection coll = (Collection) mhm.get(key);</pre>\n+ * <p>\n+ * <code>coll</code> will be a collection containing \"A\", \"B\", \"C\".\n+ * <p>\n+ * NOTE: Additional methods were added to this interface in Commons Collections 3.1.\n+ * These were added solely for documentation purposes and do not change the interface\n+ * as they were defined in the superinterface <code>Map</code> anyway.\n+ *\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public interface MultiMap<K, V> extends IterableMap<K, Object> {\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, implementations typically\n+     * return <code>null</code> from a subsequent <code>get(Object)</code>, however\n+     * they may choose to return an empty collection.\n+     * \n+     * @param key  the key to remove from\n+     * @param item  the item to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type\n+     * @throws NullPointerException if the key or value is null and null is invalid\n+     */\n+    public V remove(K key, V item);\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the number of keys in this map.\n+     * <p>\n+     * Implementations typically return only the count of keys in the map\n+     * This cannot be mandated due to backwards compatibility of this interface.\n+     *\n+     * @return the number of key-collection mappings in this map\n+     */\n+    int size();\n+\n+    /**\n+     * Gets the collection of values associated with the specified key.\n+     * <p>\n+     * The returned value will implement <code>Collection</code>. Implementations\n+     * are free to declare that they return <code>Collection</code> subclasses\n+     * such as <code>List</code> or <code>Set</code>.\n+     * <p>\n+     * Implementations typically return <code>null</code> if no values have\n+     * been mapped to the key, however the implementation may choose to\n+     * return an empty collection.\n+     * <p>\n+     * Implementations may choose to return a clone of the internal collection.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the <code>Collection</code> of values, implementations should\n+     *  return <code>null</code> for no mapping, but may return an empty collection\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Object get(Object key); // Cannot use get(K key) as that does not properly implement Map#get\n+\n+    /**\n+     * Checks whether the map contains the value specified.\n+     * <p>\n+     * Implementations typically check all collections against all keys for the value.\n+     * This cannot be mandated due to backwards compatibility of this interface.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     * @throws ClassCastException if the value is of an invalid type\n+     * @throws NullPointerException if the value is null and null value are invalid\n+     */\n+    boolean containsValue(Object value);\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     * The collection may be a <code>List</code>, <code>Set</code> or other\n+     * collection dependent on implementation.\n+     *\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return typically the value added if the map changed and null if the map did not change\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type\n+     * @throws NullPointerException if the key or value is null and null is invalid\n+     * @throws IllegalArgumentException if the key or value is invalid\n+     */\n+    Object put(K key, Object value);\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> from a subsequent\n+     * <code>get(Object)</code>, however they may choose to return an empty collection.\n+     *\n+     * @param key  the key to remove values from\n+     * @return the <code>Collection</code> of values removed, implementations should\n+     *  return <code>null</code> for no mapping found, but may return an empty collection\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Object remove(Object key); // Cannot use remove(K key) as that does not properly implement Map#remove\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * Implementations typically return a collection containing the combination\n+     * of values from all keys.\n+     * This cannot be mandated due to backwards compatibility of this interface.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    Collection<Object> values();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/OrderedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values\n+ * and retains and provides access to an ordering.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface OrderedBidiMap<K, V> extends BidiMap<K, V>, OrderedMap<K, V> {\n+\n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * Implementations must return an <code>OrderedBidiMap</code> instance,\n+     * usually by forwarding to <code>inverseOrderedBidiMap()</code>.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public OrderedBidiMap<V, K> inverseBidiMap();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/OrderedIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Defines an iterator that operates over an ordered container. Subset of {@link java.util.ListIterator}.\n+ * <p>\n+ * This iterator allows both forward and reverse iteration through the container.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface OrderedIterator<E> extends Iterator<E> {\n+\n+    /**\n+     * Checks to see if there is a previous element that can be iterated to.\n+     *\n+     * @return <code>true</code> if the iterator has a previous element\n+     */\n+    boolean hasPrevious();\n+\n+    /**\n+     * Gets the previous element from the container.\n+     *\n+     * @return the previous element in the iteration\n+     * @throws java.util.NoSuchElementException if the iteration is finished\n+     */\n+    E previous();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/OrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a map that maintains order and allows both forward and backward\n+ * iteration through that order.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface OrderedMap<K, V> extends IterableMap<K, V> {\n+\n+    /**\n+     * Obtains an <code>OrderedMapIterator</code> over the map.\n+     * <p>\n+     * A ordered map iterator is an efficient way of iterating over maps\n+     * in both directions.\n+     * \n+     * @return a map iterator\n+     */\n+    OrderedMapIterator<K, V> mapIterator();\n+\n+    /**\n+     * Gets the first key currently in this map.\n+     *\n+     * @return the first key currently in this map\n+     * @throws java.util.NoSuchElementException if this map is empty\n+     */\n+    public K firstKey();\n+\n+    /**\n+     * Gets the last key currently in this map.\n+     *\n+     * @return the last key currently in this map\n+     * @throws java.util.NoSuchElementException if this map is empty\n+     */\n+    public K lastKey();\n+\n+    /**\n+     * Gets the next key after the one specified.\n+     *\n+     * @param key  the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public K nextKey(K key);\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     *\n+     * @param key  the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public K previousKey(K key);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/OrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines an iterator that operates over an ordered <code>Map</code>.\n+ * <p>\n+ * This iterator allows both forward and reverse iteration through the map.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface OrderedMapIterator<K, V> extends MapIterator<K, V>, OrderedIterator<K> {\n+\n+    /**\n+     * Checks to see if there is a previous entry that can be iterated to.\n+     *\n+     * @return <code>true</code> if the iterator has a previous element\n+     */\n+    boolean hasPrevious();\n+\n+    /**\n+     * Gets the previous <em>key</em> from the <code>Map</code>.\n+     *\n+     * @return the previous key in the iteration\n+     * @throws java.util.NoSuchElementException if the iteration is finished\n+     */\n+    K previous();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Predicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a functor interface implemented by classes that perform a predicate\n+ * test on an object.\n+ * <p>\n+ * A <code>Predicate</code> is the object equivalent of an <code>if</code> statement.\n+ * It uses the input object to return a true or false value, and is often used in\n+ * validation or filtering.\n+ * <p>\n+ * Standard implementations of common predicates are provided by\n+ * {@link PredicateUtils}. These include true, false, instanceof, equals, and,\n+ * or, not, method invokation and null testing.\n+ *\n+ * @param <T> the type that the predicate queries\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public interface Predicate<T> {\n+\n+    /**\n+     * Use the specified parameter to perform a test that returns true or false.\n+     *\n+     * @param object  the object to evaluate, should not be changed\n+     * @return true or false\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if the predicate encounters a problem\n+     */\n+    public boolean evaluate(T object);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/PredicateUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.functors.AllPredicate;\n+import org.apache.commons.collections4.functors.AndPredicate;\n+import org.apache.commons.collections4.functors.AnyPredicate;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.functors.ExceptionPredicate;\n+import org.apache.commons.collections4.functors.FalsePredicate;\n+import org.apache.commons.collections4.functors.IdentityPredicate;\n+import org.apache.commons.collections4.functors.InstanceofPredicate;\n+import org.apache.commons.collections4.functors.InvokerTransformer;\n+import org.apache.commons.collections4.functors.NonePredicate;\n+import org.apache.commons.collections4.functors.NotNullPredicate;\n+import org.apache.commons.collections4.functors.NotPredicate;\n+import org.apache.commons.collections4.functors.NullIsExceptionPredicate;\n+import org.apache.commons.collections4.functors.NullIsFalsePredicate;\n+import org.apache.commons.collections4.functors.NullIsTruePredicate;\n+import org.apache.commons.collections4.functors.NullPredicate;\n+import org.apache.commons.collections4.functors.OnePredicate;\n+import org.apache.commons.collections4.functors.OrPredicate;\n+import org.apache.commons.collections4.functors.TransformedPredicate;\n+import org.apache.commons.collections4.functors.TransformerPredicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+import org.apache.commons.collections4.functors.UniquePredicate;\n+\n+/**\n+ * <code>PredicateUtils</code> provides reference implementations and utilities\n+ * for the Predicate functor interface. The supplied predicates are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>InstanceOf - true if the object is an instanceof a class\n+ * <li>Equal - true if the object equals() a specified object\n+ * <li>Identity - true if the object == a specified object\n+ * <li>Null - true if the object is null\n+ * <li>NotNull - true if the object is not null\n+ * <li>Unique - true if the object has not already been evaluated\n+ * <li>And/All - true if all of the predicates are true\n+ * <li>Or/Any - true if any of the predicates is true\n+ * <li>Either/One - true if only one of the predicate is true\n+ * <li>Neither/None - true if none of the predicates are true\n+ * <li>Not - true if the predicate is false, and vice versa\n+ * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>True - always return true\n+ * <li>False - always return false\n+ * <li>Exception - always throws an exception\n+ * <li>NullIsException/NullIsFalse/NullIsTrue - check for null input\n+ * <li>Transformed - transforms the input before calling the predicate\n+ * </ul>\n+ * All the supplied predicates are Serializable.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicateUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    private PredicateUtils() {}\n+\n+    // Simple predicates\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Predicate that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.ExceptionPredicate\n+     */\n+    public static <T> Predicate<T> exceptionPredicate() {\n+        return ExceptionPredicate.<T>exceptionPredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.TruePredicate\n+     */\n+    public static <T> Predicate<T> truePredicate() {\n+        return TruePredicate.truePredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns false.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.FalsePredicate\n+     */\n+    public static <T> Predicate<T> falsePredicate() {\n+        return FalsePredicate.<T> falsePredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is null.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.NullPredicate\n+     */\n+    public static <T> Predicate<T> nullPredicate() {\n+        return NullPredicate.nullPredicate();\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is not null.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.NotNullPredicate\n+     */\n+    public static <T> Predicate<T> notNullPredicate() {\n+        return NotNullPredicate.<T>notNullPredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object using equals().\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param value  the value to compare against\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.EqualPredicate\n+     */\n+    public static <T> Predicate<T> equalPredicate(final T value) {\n+        return EqualPredicate.equalPredicate(value);\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object by identity.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param value  the value to compare against\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.IdentityPredicate\n+     */\n+    public static <T> Predicate<T> identityPredicate(final T value) {\n+        return IdentityPredicate.<T>identityPredicate(value);\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the object passed in is of\n+     * a particular type, using instanceof. A <code>null</code> input\n+     * object will return <code>false</code>.\n+     *\n+     * @param type  the type to check for, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the class is null\n+     * @see org.apache.commons.collections4.functors.InstanceofPredicate\n+     */\n+    public static Predicate<Object> instanceofPredicate(final Class<?> type) {\n+        return InstanceofPredicate.instanceOfPredicate(type);\n+    }\n+\n+    /**\n+     * Creates a Predicate that returns true the first time an object is\n+     * encountered, and false if the same object is received\n+     * again. The comparison is by equals(). A <code>null</code> input object\n+     * is accepted and will return true the first time, and false subsequently\n+     * as well.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @return the predicate\n+     * @see org.apache.commons.collections4.functors.UniquePredicate\n+     */\n+    public static <T> Predicate<T> uniquePredicate() {\n+        // must return new instance each time\n+        return UniquePredicate.<T>uniquePredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a\n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to\n+     * determine the predicate result.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the methodName is null.\n+     * @see org.apache.commons.collections4.functors.InvokerTransformer\n+     * @see org.apache.commons.collections4.functors.TransformerPredicate\n+     */\n+    public static <T> Predicate<T> invokerPredicate(final String methodName) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName));\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a\n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to\n+     * determine the predicate result.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     * @see org.apache.commons.collections4.functors.InvokerTransformer\n+     * @see org.apache.commons.collections4.functors.TransformerPredicate\n+     */\n+    public static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes,\n+                                                    final Object[] args) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    // Boolean combinations\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that returns true only if both of the specified\n+     * predicates are true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     * @see org.apache.commons.collections4.functors.AndPredicate\n+     */\n+    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n+                                                final Predicate<? super T> predicate2) {\n+        return AndPredicate.<T>andPredicate(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @see org.apache.commons.collections4.functors.AllPredicate\n+     */\n+    public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @see org.apache.commons.collections4.functors.AllPredicate\n+     */\n+    public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<T>> predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if either of the specified\n+     * predicates are true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>or</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     * @see org.apache.commons.collections4.functors.OrPredicate\n+     */\n+    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n+                                               final Predicate<? super T> predicate2) {\n+        return OrPredicate.<T>orPredicate(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns false.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @see org.apache.commons.collections4.functors.AnyPredicate\n+     */\n+    public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n+        return AnyPredicate.anyPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns false.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @see org.apache.commons.collections4.functors.AnyPredicate\n+     */\n+    public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<T>> predicates) {\n+        return AnyPredicate.anyPredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if one, but not both, of the\n+     * specified predicates are true. XOR\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>either</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     * @see org.apache.commons.collections4.functors.OnePredicate\n+     */\n+    public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1,\n+                                                   final Predicate<? super T> predicate2) {\n+        @SuppressWarnings(\"unchecked\")\n+        final Predicate<T> onePredicate = PredicateUtils.<T>onePredicate(predicate1, predicate2);\n+        return onePredicate;\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns false.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @see org.apache.commons.collections4.functors.OnePredicate\n+     */\n+    public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n+        return OnePredicate.onePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns false.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @see org.apache.commons.collections4.functors.OnePredicate\n+     */\n+    public static <T> Predicate<T> onePredicate(final Collection<Predicate<T>> predicates) {\n+        return OnePredicate.onePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if neither of the specified\n+     * predicates are true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>neither</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     * @see org.apache.commons.collections4.functors.NonePredicate\n+     */\n+    public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1,\n+                                                    final Predicate<? super T> predicate2) {\n+        @SuppressWarnings(\"unchecked\")\n+        final Predicate<T> nonePredicate = PredicateUtils.<T>nonePredicate(predicate1, predicate2);\n+        return nonePredicate;\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true.\n+     * If the array of predicates is empty, then this predicate returns true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>none</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @see org.apache.commons.collections4.functors.NonePredicate\n+     */\n+    public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n+        return NonePredicate.nonePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * If the collection of predicates is empty, then this predicate returns true.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>none</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @see org.apache.commons.collections4.functors.NonePredicate\n+     */\n+    public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<T>> predicates) {\n+        return NonePredicate.nonePredicate(predicates);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if the specified predicate\n+     * returns false and vice versa.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate  the predicate to not\n+     * @return the <code>not</code> predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @see org.apache.commons.collections4.functors.NotPredicate\n+     */\n+    public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n+        return NotPredicate.notPredicate(predicate);\n+    }\n+\n+    // Adaptors\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that wraps a Transformer. The Transformer must\n+     * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n+     * will be thrown.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param transformer  the transformer to wrap, may not be null\n+     * @return the transformer wrapping predicate\n+     * @throws IllegalArgumentException if the transformer is null\n+     * @see org.apache.commons.collections4.functors.TransformerPredicate\n+     */\n+    public static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n+        return TransformerPredicate.transformerPredicate(transformer);\n+    }\n+\n+    // Null handlers\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Predicate that throws an exception if the input object is null,\n+     * otherwise it calls the specified Predicate. This allows null handling\n+     * behaviour to be added to Predicates that don't support nulls.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     * @see org.apache.commons.collections4.functors.NullIsExceptionPredicate\n+     */\n+    public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate){\n+        return NullIsExceptionPredicate.nullIsExceptionPredicate(predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns false if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     * @see org.apache.commons.collections4.functors.NullIsFalsePredicate\n+     */\n+    public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate){\n+        return NullIsFalsePredicate.nullIsFalsePredicate(predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns true if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     * @see org.apache.commons.collections4.functors.NullIsTruePredicate\n+     */\n+    public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate){\n+        return NullIsTruePredicate.nullIsTruePredicate(predicate);\n+    }\n+\n+    // Transformed\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a predicate that transforms the input object before passing it\n+     * to the predicate.\n+     *\n+     * @param <T>  the type that the predicate queries\n+     * @param transformer  the transformer to call first\n+     * @param predicate  the predicate to call with the result of the transform\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer or the predicate is null\n+     * @see org.apache.commons.collections4.functors.TransformedPredicate\n+     * @since 3.1\n+     */\n+    public static <T> Predicate<T> transformedPredicate(\n+            final Transformer<? super T, ? extends T> transformer, final Predicate<? super T> predicate) {\n+        return TransformedPredicate.<T>transformedPredicate(transformer, predicate);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Put.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Map;\n+\n+/**\n+ * The \"write\" subset of the {@link Map} interface.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ * \n+ * @see Get\n+ */\n+public interface Put<K, V> {\n+\n+    /**\n+     * @see Map#clear()\n+     */\n+    public void clear();\n+\n+    /**\n+     * @see Map#put(Object, Object)\n+     */\n+    public Object put(K key, V value);\n+\n+    /**\n+     * @see Map#putAll(Map)\n+     */\n+    public void putAll(Map<? extends K, ? extends V> t);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/QueueUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.queue.PredicatedQueue;\n+import org.apache.commons.collections4.queue.TransformedQueue;\n+import org.apache.commons.collections4.queue.UnmodifiableQueue;\n+\n+/**\n+ * Provides utility methods and decorators for {@link Queue} instances.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class QueueUtils {\n+\n+    /**\n+     * An empty unmodifiable queue.\n+     */\n+    public static final Queue<Object> EMPTY_QUEUE = UnmodifiableQueue.unmodifiableQueue(new LinkedList<Object>());\n+\n+    /**\n+     * <code>QueueUtils</code> should not normally be instantiated.\n+     */\n+    private QueueUtils() {}\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns an unmodifiable queue backed by the given queue.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to make unmodifiable, must not be null\n+     * @return an unmodifiable queue backed by that queue\n+     * @throws IllegalArgumentException  if the Queue is null\n+     */\n+    public static <E> Queue<E> unmodifiableQueue(final Queue<E> queue) {\n+        return UnmodifiableQueue.unmodifiableQueue(queue);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) queue backed by the given queue.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the queue.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original queue after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to predicate, must not be null\n+     * @param predicate  the predicate used to evaluate new elements, must not be null\n+     * @return a predicated queue\n+     * @throws IllegalArgumentException  if the Queue or Predicate is null\n+     */\n+    public static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n+        return PredicatedQueue.predicatedQueue(queue, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed queue backed by the given queue.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Queue. It is important not to use the original queue after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified queue will not be transformed.\n+     * If you want that behaviour, see {@link TransformedQueue#transformedQueue}.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to predicate, must not be null\n+     * @param transformer  the transformer for the queue, must not be null\n+     * @return a transformed queue backed by the given queue\n+     * @throws IllegalArgumentException  if the Queue or Transformer is null\n+     */\n+    public static <E> Queue<E> transformingQueue(final Queue<E> queue,\n+                                                 final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedQueue.transformingQueue(queue, transformer);\n+    }\n+\n+    /**\n+     * Get an empty <code>Queue</code>.\n+     *\n+     * @param <E> the type of the elements in the queue\n+     * @return an empty {@link Queue}\n+     */\n+    @SuppressWarnings(\"unchecked\") // OK, empty queue is compatible with any type\n+    public static <E> Queue<E> emptyQueue() {\n+        return (Queue<E>) EMPTY_QUEUE;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ResettableIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Iterator;\n+\n+/** \n+ * Defines an iterator that can be reset back to an initial state.\n+ * <p>\n+ * This interface allows an iterator to be repeatedly reused.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface ResettableIterator<E> extends Iterator<E> {\n+\n+    /**\n+     * Resets the iterator back to the position at which the iterator\n+     * was created.\n+     */\n+    public void reset();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ResettableListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ListIterator;\n+\n+/** \n+ * Defines a list iterator that can be reset back to an initial state.\n+ * <p>\n+ * This interface allows an iterator to be repeatedly reused.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface ResettableListIterator<E> extends ListIterator<E>, ResettableIterator<E>, OrderedIterator<E> {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections4.set.ListOrderedSet;\n+import org.apache.commons.collections4.set.PredicatedSet;\n+import org.apache.commons.collections4.set.PredicatedSortedSet;\n+import org.apache.commons.collections4.set.TransformedSet;\n+import org.apache.commons.collections4.set.TransformedSortedSet;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.set.UnmodifiableSortedSet;\n+\n+/**\n+ * Provides utility methods and decorators for\n+ * {@link Set} and {@link SortedSet} instances.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class SetUtils {\n+\n+    /**\n+     * Get a typed empty unmodifiable Set.\n+     * @param <E> the element type\n+     * @return an empty Set\n+     */\n+    public static <E> Set<E> emptySet() {\n+        return Collections.<E>emptySet();\n+    }\n+\n+    /**\n+     * An empty unmodifiable sorted set.\n+     * This is not provided in the JDK.\n+     */\n+    public static final SortedSet<?> EMPTY_SORTED_SET =\n+            UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<Object>());\n+\n+    /**\n+     * Get a typed empty unmodifiable sorted set.\n+     * @param <E> the element type\n+     * @return an empty sorted Set\n+     */\n+    @SuppressWarnings(\"unchecked\") // empty set is OK for any type\n+    public static <E> SortedSet<E> emptySortedSet() {\n+        return (SortedSet<E>) EMPTY_SORTED_SET;\n+    }\n+\n+    /**\n+     * <code>SetUtils</code> should not normally be instantiated.\n+     */\n+    private SetUtils() {}\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Returns an immutable empty set if the argument is <code>null</code>,\n+     * or the argument itself otherwise.\n+     * \n+     * @param <T> the element type\n+     * @param set the set, possibly <code>null</code>\n+     * @return an empty set if the argument is <code>null</code>\n+     */\n+    public static <T> Set<T> emptyIfNull(final Set<T> set) {\n+        return set == null ? Collections.<T>emptySet() : set;\n+    }\n+    \n+    /**\n+     * Tests two sets for equality as per the <code>equals()</code> contract\n+     * in {@link java.util.Set#equals(java.lang.Object)}.\n+     * <p>\n+     * This method is useful for implementing <code>Set</code> when you cannot\n+     * extend AbstractSet. The method takes Collection instances to enable other\n+     * collection types to use the Set implementation algorithm.\n+     * <p>\n+     * The relevant text (slightly paraphrased as this is a static method) is:\n+     * <blockquote>\n+     * <p>Two sets are considered equal if they have\n+     * the same size, and every member of the first set is contained in\n+     * the second. This ensures that the <tt>equals</tt> method works\n+     * properly across different implementations of the <tt>Set</tt>\n+     * interface.</p>\n+     * \n+     * <p>\n+     * This implementation first checks if the two sets are the same object: \n+     * if so it returns <tt>true</tt>.  Then, it checks if the two sets are\n+     * identical in size; if not, it returns false. If so, it returns\n+     * <tt>a.containsAll((Collection) b)</tt>.</p>\n+     * </blockquote>\n+     * \n+     * @see java.util.Set\n+     * @param set1  the first set, may be null\n+     * @param set2  the second set, may be null\n+     * @return whether the sets are equal by value comparison\n+     */\n+    public static boolean isEqualSet(final Collection<?> set1, final Collection<?> set2) {\n+        if (set1 == set2) {\n+            return true;\n+        }\n+        if (set1 == null || set2 == null || set1.size() != set2.size()) {\n+            return false;\n+        }\n+\n+        return set1.containsAll(set2);\n+    }\n+\n+    /**\n+     * Generates a hash code using the algorithm specified in \n+     * {@link java.util.Set#hashCode()}.\n+     * <p>\n+     * This method is useful for implementing <code>Set</code> when you cannot\n+     * extend AbstractSet. The method takes Collection instances to enable other\n+     * collection types to use the Set implementation algorithm.\n+     * \n+     * @param <T> the element type\n+     * @see java.util.Set#hashCode()\n+     * @param set  the set to calculate the hash code for, may be null\n+     * @return the hash code\n+     */\n+    public static <T> int hashCodeForSet(final Collection<T> set) {\n+        if (set == null) {\n+            return 0;\n+        }\n+\n+        int hashCode = 0;\n+        for (final T obj : set) {\n+            if (obj != null) {\n+                hashCode += obj.hashCode();\n+            }\n+        }\n+        return hashCode;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized set backed by the given set.\n+     * <p>\n+     * You must manually synchronize on the returned set's iterator to \n+     * avoid non-deterministic behavior:\n+     *  \n+     * <pre>\n+     * Set s = SetUtils.synchronizedSet(mySet);\n+     * synchronized (s) {\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * This method is just a wrapper for {@link Collections#synchronizedSet(Set)}.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to synchronize, must not be null\n+     * @return a synchronized set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <E> Set<E> synchronizedSet(final Set<E> set) {\n+        return Collections.synchronizedSet(set);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable set backed by the given set.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to make unmodifiable, must not be null\n+     * @return an unmodifiable set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <E> Set<E> unmodifiableSet(final Set<E> set) {\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) set backed by the given set.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the set.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original set after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to predicate, must not be null\n+     * @param predicate  the predicate for the set, must not be null\n+     * @return a predicated set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     */\n+    public static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n+        return PredicatedSet.predicatedSet(set, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed set backed by the given set.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Set. It is important not to use the original set after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified set will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSet#transformedSet}.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to transform, must not be null\n+     * @param transformer  the transformer for the set, must not be null\n+     * @return a transformed set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     */\n+    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSet.transformingSet(set, transformer);\n+    }\n+    \n+    /**\n+     * Returns a set that maintains the order of elements that are added\n+     * backed by the given set.\n+     * <p>\n+     * If an element is added twice, the order is determined by the first add.\n+     * The order is observed through the iterator or toArray.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to order, must not be null\n+     * @return an ordered set backed by the given set\n+     * @throws IllegalArgumentException  if the Set is null\n+     */\n+    public static <E> Set<E> orderedSet(final Set<E> set) {\n+        return ListOrderedSet.listOrderedSet(set);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a synchronized sorted set backed by the given sorted set.\n+     * <p>\n+     * You must manually synchronize on the returned set's iterator to \n+     * avoid non-deterministic behavior:\n+     *  \n+     * <pre>\n+     * Set s = SetUtils.synchronizedSet(mySet);\n+     * synchronized (s) {\n+     *     Iterator i = s.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     * \n+     * This method is just a wrapper for {@link Collections#synchronizedSortedSet(SortedSet)}.\n+     * \n+     * @param <E> the element type\n+     * @param set  the sorted set to synchronize, must not be null\n+     * @return a synchronized set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n+        return Collections.synchronizedSortedSet(set);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable sorted set backed by the given sorted set.\n+     * <p>\n+     * This method uses the implementation in the decorators subpackage.\n+     *\n+     * @param <E> the element type\n+     * @param set  the sorted set to make unmodifiable, must not be null\n+     * @return an unmodifiable set backed by the given set\n+     * @throws IllegalArgumentException  if the set is null\n+     */\n+    public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n+    }\n+\n+    /**\n+     * Returns a predicated (validating) sorted set backed by the given sorted set.  \n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to the set.\n+     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * It is important not to use the original set after invoking this method,\n+     * as it is a backdoor for adding invalid objects.\n+     *\n+     * @param <E> the element type\n+     * @param set  the sorted set to predicate, must not be null\n+     * @param predicate  the predicate for the sorted set, must not be null\n+     * @return a predicated sorted set backed by the given sorted set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     */\n+    public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n+        return PredicatedSortedSet.predicatedSortedSet(set, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted set backed by the given set.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the\n+     * Set. It is important not to use the original set after invoking this \n+     * method, as it is a backdoor for adding untransformed objects.\n+     * <p>\n+     * Existing entries in the specified set will not be transformed.\n+     * If you want that behaviour, see {@link TransformedSortedSet#transformedSortedSet}.\n+     *\n+     * @param <E> the element type\n+     * @param set  the set to transform, must not be null\n+     * @param transformer  the transformer for the set, must not be null\n+     * @return a transformed set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     */\n+    public static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set,\n+                                                        final Transformer<? super E, ? extends E> transformer) {\n+        return TransformedSortedSet.transformingSortedSet(set, transformer);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/SortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Comparator;\n+\n+/**\n+ * Defines a type of <code>Bag</code> that maintains a sorted order among\n+ * its unique representative members.\n+ *\n+ * @param <E> the type to iterate over\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public interface SortedBag<E> extends Bag<E> {\n+\n+    /**\n+     * Returns the comparator associated with this sorted set, or null\n+     * if it uses its elements' natural ordering.\n+     * \n+     * @return the comparator in use, or null if natural ordering\n+     */\n+    public Comparator<? super E> comparator();\n+\n+    /**\n+     * Returns the first (lowest) member.\n+     * \n+     * @return the first element in the sorted bag\n+     */\n+    public E first();\n+\n+    /**\n+     * Returns the last (highest) member.\n+     * \n+     * @return the last element in the sorted bag\n+     */\n+    public E last();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/SortedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+/**\n+ * Defines a map that allows bidirectional lookup between key and values\n+ * and retains both keys and values in sorted order.\n+ * <p>\n+ * Implementations should allow a value to be looked up from a key and\n+ * a key to be looked up from a value with equal performance.\n+ *  \n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface SortedBidiMap<K, V> extends OrderedBidiMap<K, V>, SortedMap<K, V> {\n+\n+    /**\n+     * Gets a view of this map where the keys and values are reversed.\n+     * <p>\n+     * Changes to one map will be visible in the other and vice versa.\n+     * This enables both directions of the map to be accessed equally.\n+     * <p>\n+     * Implementations should seek to avoid creating a new object every time this\n+     * method is called. See <code>AbstractMap.values()</code> etc. Calling this\n+     * method on the inverse map should return the original.\n+     * <p>\n+     * Implementations must return a <code>SortedBidiMap</code> instance,\n+     * usually by forwarding to <code>inverseSortedBidiMap()</code>.\n+     *\n+     * @return an inverted bidirectional map\n+     */\n+    public SortedBidiMap<V, K> inverseBidiMap();\n+\n+    /**\n+     * Get the comparator used for the values in the value-to-key map aspect.\n+     * @return Comparator<? super V>\n+     */\n+    public Comparator<? super V> valueComparator();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/SplitMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter;\n+import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+\n+/**\n+ * Utilities for working with \"split maps:\" objects that implement {@link Put}\n+ * and/or {@link Get} but not {@link Map}.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ *\n+ * @see Get\n+ * @see Put\n+ */\n+public class SplitMapUtils {\n+\n+    /**\n+     * <code>SplitMapUtils</code> should not normally be instantiated.\n+     */\n+    private SplitMapUtils() {}\n+\n+    //-----------------------------------------------------------------------\n+\n+    private static class WrappedGet<K, V> implements IterableMap<K, V>, Unmodifiable {\n+        private final Get<K, V> get;\n+\n+        private WrappedGet(final Get<K, V> get) {\n+            this.get = get;\n+        }\n+\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsKey(final Object key) {\n+            return get.containsKey(key);\n+        }\n+\n+        public boolean containsValue(final Object value) {\n+            return get.containsValue(value);\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            return UnmodifiableEntrySet.unmodifiableEntrySet(get.entrySet());\n+        }\n+\n+        @Override\n+        public boolean equals(final Object arg0) {\n+            if (arg0 == this) {\n+                return true;\n+            }\n+            return arg0 instanceof WrappedGet && ((WrappedGet<?, ?>) arg0).get.equals(this.get);\n+        }\n+\n+        public V get(final Object key) {\n+            return get.get(key);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedGet\".hashCode() << 4) | get.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            return get.isEmpty();\n+        }\n+\n+        public Set<K> keySet() {\n+            return UnmodifiableSet.unmodifiableSet(get.keySet());\n+        }\n+\n+        public V put(final K key, final V value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void putAll(final Map<? extends K, ? extends V> t) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V remove(final Object key) {\n+            return get.remove(key);\n+        }\n+\n+        public int size() {\n+            return get.size();\n+        }\n+\n+        public Collection<V> values() {\n+            return UnmodifiableCollection.unmodifiableCollection(get.values());\n+        }\n+\n+        public MapIterator<K, V> mapIterator() {\n+            MapIterator<K, V> it;\n+            if (get instanceof IterableGet) {\n+                it = ((IterableGet<K, V>) get).mapIterator();\n+            } else {\n+                it = new EntrySetToMapIteratorAdapter<K, V>(get.entrySet());\n+            }\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+        }\n+    }\n+\n+    private static class WrappedPut<K, V> implements Map<K, V>, Put<K, V> {\n+        private final Put<K, V> put;\n+\n+        private WrappedPut(final Put<K, V> put) {\n+            this.put = put;\n+        }\n+\n+        public void clear() {\n+            put.clear();\n+        }\n+\n+        public boolean containsKey(final Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean containsValue(final Object value) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<java.util.Map.Entry<K, V>> entrySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            return obj instanceof WrappedPut && ((WrappedPut<?, ?>) obj).put.equals(this.put);\n+        }\n+\n+        public V get(final Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (\"WrappedPut\".hashCode() << 4) | put.hashCode();\n+        }\n+\n+        public boolean isEmpty() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<K> keySet() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V put(final K key, final V value) {\n+            return (V) put.put(key, value);\n+        }\n+\n+        public void putAll(final Map<? extends K, ? extends V> t) {\n+            put.putAll(t);\n+        }\n+\n+        public V remove(final Object key) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int size() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Collection<V> values() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Get the specified {@link Get} as an instance of {@link IterableMap}.\n+     * If <code>get</code> implements {@link IterableMap} directly, no conversion will take place.\n+     * If <code>get</code> implements {@link Map} but not {@link IterableMap} it will be decorated.\n+     * Otherwise an {@link Unmodifiable} {@link IterableMap} will be returned.\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param get to wrap, must not be null\n+     * @return {@link IterableMap}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n+        if (get == null) {\n+            throw new IllegalArgumentException(\"Get must not be null\");\n+        }\n+        if (get instanceof Map) {\n+            return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils\n+                    .iterableMap((Map<K, V>) get);\n+        }\n+        return new WrappedGet<K, V>(get);\n+    }\n+\n+    /**\n+     * Get the specified {@link Put} as an instanceof {@link Map}.\n+     * If <code>put</code> implements {@link Map} directly, no conversion will take place.\n+     * Otherwise a <em>write-only</em> {@link Map} will be returned.  On such a {@link Map}\n+     * it is recommended that the result of #put(K, V) be discarded as it likely will not\n+     * match <code>V</code> at runtime.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the element type\n+     * @param put to wrap, must not be null\n+     * @return {@link Map}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n+        if (put == null) {\n+            throw new IllegalArgumentException(\"Put must not be null\");\n+        }\n+        if (put instanceof Map) {\n+            return (Map<K, V>) put;\n+        }\n+        return new WrappedPut<K, V>(put);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Transformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Defines a functor interface implemented by classes that transform one\n+ * object into another.\n+ * <p>\n+ * A <code>Transformer</code> converts the input object to the output object.\n+ * The input object should be left unchanged.\n+ * Transformers are typically used for type conversions, or extracting data\n+ * from an object.\n+ * <p>\n+ * Standard implementations of common transformers are provided by\n+ * {@link TransformerUtils}. These include method invocation, returning a constant,\n+ * cloning and returning the string value.\n+ *\n+ * @param <I> the input type to the transformer\n+ * @param <O> the output type from the transformer\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public interface Transformer<I, O> {\n+\n+    /**\n+     * Transforms the input object (leaving it unchanged) into some output object.\n+     *\n+     * @param input  the object to be transformed, should be left unchanged\n+     * @return a transformed object\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if the transform cannot be completed\n+     */\n+    public O transform(I input);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/TransformerUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.functors.ChainedTransformer;\n+import org.apache.commons.collections4.functors.CloneTransformer;\n+import org.apache.commons.collections4.functors.ClosureTransformer;\n+import org.apache.commons.collections4.functors.ConstantTransformer;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.functors.ExceptionTransformer;\n+import org.apache.commons.collections4.functors.FactoryTransformer;\n+import org.apache.commons.collections4.functors.InstantiateTransformer;\n+import org.apache.commons.collections4.functors.InvokerTransformer;\n+import org.apache.commons.collections4.functors.MapTransformer;\n+import org.apache.commons.collections4.functors.NOPTransformer;\n+import org.apache.commons.collections4.functors.PredicateTransformer;\n+import org.apache.commons.collections4.functors.StringValueTransformer;\n+import org.apache.commons.collections4.functors.SwitchTransformer;\n+\n+/**\n+ * <code>TransformerUtils</code> provides reference implementations and \n+ * utilities for the Transformer functor interface. The supplied transformers are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>Clone - returns a clone of the input object\n+ * <li>Constant - always returns the same object\n+ * <li>Closure - performs a Closure and returns the input object\n+ * <li>Predicate - returns the result of the predicate as a Boolean\n+ * <li>Factory - returns a new object from a factory\n+ * <li>Chained - chains two or more transformers together\n+ * <li>Switch - calls one transformer based on one or more predicates\n+ * <li>SwitchMap - calls one transformer looked up from a Map\n+ * <li>Instantiate - the Class input object is instantiated\n+ * <li>Map - returns an object from a supplied Map\n+ * <li>Null - always returns null\n+ * <li>NOP - returns the input object, which should be immutable\n+ * <li>Exception - always throws an exception\n+ * <li>StringValue - returns a <code>java.lang.String</code> representation of the input object\n+ * </ul>\n+ * All the supplied transformers are Serializable.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformerUtils {\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    private TransformerUtils() {}\n+\n+    /**\n+     * Gets a transformer that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @return the transformer\n+     * @see org.apache.commons.collections4.functors.ExceptionTransformer\n+     */\n+    public static <I, O> Transformer<I, O> exceptionTransformer() {\n+        return ExceptionTransformer.<I, O>exceptionTransformer();\n+    }\n+\n+    /**\n+     * Gets a transformer that always returns null.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @return the transformer\n+     * @see org.apache.commons.collections4.functors.ConstantTransformer\n+     */\n+    public static <I, O> Transformer<I, O> nullTransformer() {\n+        return ConstantTransformer.<I, O>nullTransformer();\n+    }\n+\n+    /**\n+     * Gets a transformer that returns the input object.\n+     * The input object should be immutable to maintain the\n+     * contract of Transformer (although this is not checked).\n+     * \n+     * @param <T>  the input/output type\n+     * @return the transformer\n+     * @see org.apache.commons.collections4.functors.NOPTransformer\n+     */\n+    public static <T> Transformer<T, T> nopTransformer() {\n+        return NOPTransformer.<T>nopTransformer();\n+    }\n+\n+    /**\n+     * Gets a transformer that returns a clone of the input\n+     * object. The input object will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     * \n+     * @param <T>  the input/output type\n+     * @return the transformer\n+     * @see org.apache.commons.collections4.functors.CloneTransformer\n+     */\n+    public static <T> Transformer<T, T> cloneTransformer() {\n+        return CloneTransformer.<T>cloneTransformer();\n+    }\n+\n+    /**\n+     * Creates a Transformer that will return the same object each time the \n+     * transformer is used.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param constantToReturn  the constant object to return each time in the transformer\n+     * @return the transformer.\n+     * @see org.apache.commons.collections4.functors.ConstantTransformer\n+     */\n+    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n+        return ConstantTransformer.constantTransformer(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Closure each time the transformer is used.\n+     * The transformer returns the input object.\n+     *\n+     * @param <T>  the input/output type\n+     * @param closure  the closure to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the closure is null\n+     * @see org.apache.commons.collections4.functors.ClosureTransformer\n+     */\n+    public static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n+        return ClosureTransformer.closureTransformer(closure);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Predicate each time the transformer is used.\n+     * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n+     *\n+     * @param <T>  the input type\n+     * @param predicate  the predicate to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @see org.apache.commons.collections4.functors.PredicateTransformer\n+     */\n+    public static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n+        return PredicateTransformer.predicateTransformer(predicate);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Factory each time the transformer is used.\n+     * The transformer will return the value returned by the factory.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param factory  the factory to run each time in the transformer, not null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the factory is null\n+     * @see org.apache.commons.collections4.functors.FactoryTransformer\n+     */\n+    public static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n+        return FactoryTransformer.factoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls two transformers, passing the result of\n+     * the first into the second.\n+     * \n+     * @param <T>  the input/output type\n+     * @param transformer1  the first transformer\n+     * @param transformer2  the second transformer\n+     * @return the transformer\n+     * @throws IllegalArgumentException if either transformer is null\n+     * @see org.apache.commons.collections4.functors.ChainedTransformer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> chainedTransformer(\n+            final Transformer<? super T, ? extends T> transformer1,\n+            final Transformer<? super T, ? extends T> transformer2) {\n+        return ChainedTransformer.<T> chainedTransformer(transformer1, transformer2);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer.\n+     * \n+     * @param <T>  the input/output type\n+     * @param transformers  an array of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers array or any of the transformers is null\n+     * @see org.apache.commons.collections4.functors.ChainedTransformer\n+     */\n+    public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>[] transformers) {\n+        return ChainedTransformer.chainedTransformer(transformers);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param <T>  the input/output type\n+     * @param transformers  a collection of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers collection or any of the transformers is null\n+     * @see org.apache.commons.collections4.functors.ChainedTransformer\n+     */\n+    public static <T> Transformer<T, T> chainedTransformer(\n+            final Collection<? extends Transformer<T, T>> transformers) {\n+        return ChainedTransformer.chainedTransformer(transformers);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of two transformers depending \n+     * on the specified predicate.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param predicate  the predicate to switch on\n+     * @param trueTransformer  the transformer called if the predicate is true\n+     * @param falseTransformer  the transformer called if the predicate is false\n+     * @return the transformer\n+     * @throws IllegalArgumentException if either the predicate or transformer is null\n+     * @see org.apache.commons.collections4.functors.SwitchTransformer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I> predicate,\n+            final Transformer<? super I, ? extends O> trueTransformer,\n+            final Transformer<? super I, ? extends O> falseTransformer) {\n+        return SwitchTransformer.switchTransformer(new Predicate[] { predicate },\n+                                                   new Transformer[] { trueTransformer }, falseTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, null is returned.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null or empty\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     * @see org.apache.commons.collections4.functors.SwitchTransformer\n+     */\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers) {\n+        return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, null);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. If the default transformer is null, null is returned.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @param defaultTransformer  the default to call if no predicate matches, null means return null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null or empty\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     * @see org.apache.commons.collections4.functors.SwitchTransformer\n+     */\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers,\n+            final Transformer<? super I, ? extends O> defaultTransformer) {\n+        return SwitchTransformer.<I, O>switchTransformer(predicates, transformers, defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. If no default transformer is set, null will be returned in a default\n+     * case. The ordering is that of the iterator() method on the entryset collection \n+     * of the map.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null or empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     * @see org.apache.commons.collections4.functors.SwitchTransformer\n+     */\n+    public static <I, O> Transformer<I, O> switchTransformer(\n+            final Map<Predicate<I>, Transformer<I, O>> predicatesAndTransformers) {\n+        return SwitchTransformer.<I, O>switchTransformer(predicatesAndTransformers);\n+    }\n+\n+    /**\n+     * Create a new Transformer that uses the input object as a key to find the\n+     * transformer to call. \n+     * <p>\n+     * The Map consists of object keys and Transformer values. A transformer \n+     * is called if the input object equals the key. If there is no match, the\n+     * default transformer is called. The default transformer is set in the map\n+     * using a null key. If no default is set, null will be returned in a default case.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param objectsAndTransformers  a map of objects to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null or empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @see org.apache.commons.collections4.functors.SwitchTransformer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchMapTransformer(\n+            final Map<I, Transformer<I, O>> objectsAndTransformers) {\n+\n+        if (objectsAndTransformers == null) {\n+            throw new IllegalArgumentException(\"The object and transformer map must not be null\");\n+        }\n+        final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n+        final int size = objectsAndTransformers.size();\n+        final Transformer<? super I, ? extends O>[] trs = new Transformer[size];\n+        final Predicate<I>[] preds = new Predicate[size];\n+        int i = 0;\n+        for (final Map.Entry<I, Transformer<I, O>> entry : objectsAndTransformers.entrySet()) {\n+            preds[i] = EqualPredicate.<I>equalPredicate(entry.getKey());\n+            trs[i++] = entry.getValue();\n+        }\n+        return TransformerUtils.<I, O>switchTransformer(preds, trs, def);\n+    }\n+\n+    /**\n+     * Gets a Transformer that expects an input Class object that it will instantiate.\n+     * \n+     * @param <T>  the output type\n+     * @return the transformer\n+     * @see org.apache.commons.collections4.functors.InstantiateTransformer\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n+        return InstantiateTransformer.<T>instantiateTransformer();\n+    }\n+\n+    /** \n+     * Creates a Transformer that expects an input Class object that it will \n+     * instantiate. The constructor used is determined by the arguments specified\n+     * to this method.\n+     *\n+     * @param <T>  the output type\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     * @see org.apache.commons.collections4.functors.InstantiateTransformer\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(\n+            final Class<?>[] paramTypes, final Object[] args) {\n+        return InstantiateTransformer.<T>instantiateTransformer(paramTypes, args);\n+    }\n+\n+    /** \n+     * Creates a Transformer that uses the passed in Map to transform the input \n+     * object (as a simple lookup).\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param map  the map to use to transform the objects\n+     * @return the transformer, or a {@link ConstantTransformer#NULL_INSTANCE} if the {@code map} is {@code null}\n+     * @see org.apache.commons.collections4.functors.MapTransformer\n+     */\n+    public static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n+        return MapTransformer.mapTransformer(map);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method must have no parameters. If the input object is null, \n+     * null is returned.\n+     * <p>\n+     * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n+     * will call the <code>getName/code> method on the input object to \n+     * determine the transformer result.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the methodName is null.\n+     * @see org.apache.commons.collections4.functors.InvokerTransformer\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n+        return InvokerTransformer.<I, O>invokerTransformer(methodName, null, null);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method parameters are specified. If the input object is {@code null}, \n+     * {@code null} is returned.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the method name is null or the paramTypes and args don't match\n+     * @see org.apache.commons.collections4.functors.InvokerTransformer\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,\n+                                                              final Object[] args) {\n+        return InvokerTransformer.<I, O>invokerTransformer(methodName, paramTypes, args);\n+    }\n+\n+    /**\n+     * Gets a transformer that returns a <code>java.lang.String</code>\n+     * representation of the input object. This is achieved via the\n+     * <code>toString</code> method, <code>null</code> returns 'null'.\n+     * \n+     * @param <T>  the input type\n+     * @return the transformer\n+     * @see org.apache.commons.collections4.functors.StringValueTransformer\n+     */\n+    public static <T> Transformer<T, String> stringValueTransformer() {\n+        return StringValueTransformer.<T>stringValueTransformer();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Trie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.Map.Entry;\n+\n+/**\n+ * Defines the interface for a prefix tree, an ordered tree data structure. For \n+ * more information, see <a href=\"http://en.wikipedia.org/wiki/Trie\">Tries</a>.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface Trie<K, V> extends SortedMap<K, V> {\n+\n+    /**\n+     * Returns the {@link Entry} whose key is closest in a bitwise XOR \n+     * metric to the given key. This is NOT lexicographic closeness.\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     * \n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n+     * return 'L', because the XOR distance between D &amp; L is smaller \n+     * than the XOR distance between D &amp; H. \n+     * \n+     * @param key  the key to use in the search\n+     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n+     *   to the provided key\n+     */\n+    public Map.Entry<K, V> select(K key);\n+    \n+    /**\n+     * Returns the key that is closest in a bitwise XOR metric to the \n+     * provided key. This is NOT lexicographic closeness!\n+     * \n+     * For example, given the keys:\n+     * \n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     * \n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n+     * return 'L', because the XOR distance between D &amp; L is smaller \n+     * than the XOR distance between D &amp; H. \n+     * \n+     * @param key  the key to use in the search\n+     * @return the key that is closest in a bitwise XOR metric to the provided key\n+     */\n+    public K selectKey(K key);\n+    \n+    /**\n+     * Returns the value whose key is closest in a bitwise XOR metric to \n+     * the provided key. This is NOT lexicographic closeness!\n+     * \n+     * For example, given the keys:\n+     * \n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     * \n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n+     * return 'L', because the XOR distance between D &amp; L is smaller \n+     * than the XOR distance between D &amp; H. \n+     * \n+     * @param key  the key to use in the search\n+     * @return the value whose key is closest in a bitwise XOR metric\n+     * to the provided key\n+     */\n+    public V selectValue(K key);\n+    \n+    /**\n+     * Iterates through the {@link Trie}, starting with the entry whose bitwise\n+     * value is closest in an XOR metric to the given key. After the closest\n+     * entry is found, the {@link Trie} will call select on that entry and continue\n+     * calling select for each entry (traversing in order of XOR closeness,\n+     * NOT lexicographically) until the cursor returns {@link Cursor.Decision#EXIT}.\n+     * <p>\n+     * The cursor can return {@link Cursor.Decision#CONTINUE} to continue traversing.\n+     * <p>\n+     * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * and stop traversing.\n+     * <p>\n+     * Note: The {@link Cursor.Decision#REMOVE} operation is not supported.\n+     * \n+     * @param key  the key to use in the search\n+     * @param cursor  the cursor used throughout the search\n+     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null \n+     * if it continued till the end\n+     */\n+    public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n+    \n+    /**\n+     * Traverses the {@link Trie} in lexicographical order. \n+     * {@link Cursor#select(java.util.Map.Entry)} will be called on each entry.\n+     * <p>\n+     * The traversal will stop when the cursor returns {@link Cursor.Decision#EXIT}, \n+     * {@link Cursor.Decision#CONTINUE} is used to continue traversing and \n+     * {@link Cursor.Decision#REMOVE} is used to remove the element that was selected \n+     * and continue traversing.\n+     * <p>\n+     * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * and stop traversing.\n+     *   \n+     * @param cursor  the cursor used while traversing the {@link Trie}\n+     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null \n+     * if it continued till the end\n+     */\n+    public Map.Entry<K,V> traverse(Cursor<? super K, ? super V> cursor);\n+    \n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed \n+     * by the given key.\n+     * <p>\n+     * In a {@link Trie} with fixed size keys, this is essentially a \n+     * {@link #get(Object)} operation.\n+     * <p>\n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', \n+     * 'Analu', 'Andreas', 'Andrea', 'Andres', and 'Anatole', then\n+     * a lookup of 'And' would return 'Andreas', 'Andrea', and 'Andres'.\n+     * \n+     * @param key  the key used in the search\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key);\n+    \n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed \n+     * by the length of the key.\n+     * <p>\n+     * {@link Trie}s with fixed size keys will not support this operation \n+     * (because all keys are the same length).\n+     * <p>\n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu', \n+     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for 'Andrey' \n+     * and a length of 4 would return 'Andreas', 'Andrea', and 'Andres'.\n+     * \n+     * @param key  the key used in the search\n+     * @param length  the length of the prefix\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int length);\n+    \n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n+     * by the key, starting at the given offset and for the given length.\n+     * <p>\n+     * {@link Trie}s with fixed size keys will not support this operation \n+     * (because all keys are the same length).\n+     * <p>\n+     * For example, if the {@link Trie} contains 'Anna', 'Anael', 'Analu', \n+     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for \n+     * 'Hello Andrey Smith', an offset of 6 and a length of 4 would return \n+     * 'Andreas', 'Andrea', and 'Andres'.\n+     * \n+     * @param key  the key used in the search\n+     * @param offset  the prefix start\n+     * @param length  the length of the prefix\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length);\n+    \n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n+     * by the number of bits in the given Key.\n+     * <p>\n+     * In {@link Trie}s with fixed size keys like IP addresses this method\n+     * can be used to lookup partial keys. That is you can lookup all addresses\n+     * that begin with '192.168' by providing the key '192.168.X.X' and a \n+     * length of 16.\n+     * \n+     * @param key  the key to use in the search\n+     * @param lengthInBits  the number of significant key bits\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits);\n+    \n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n+     * by the number of bits in the given Key.\n+     * \n+     * @param key  the key to use in the search\n+     * @param offsetInBits  the prefix offset\n+     * @param lengthInBits  the number of significant prefix bits\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits);\n+    \n+    /**\n+     * A {@link Trie.Cursor} can be used to traverse a {@link Trie}, visit each node \n+     * step by step and make {@link Decision}s on each step how to continue with \n+     * traversing the {@link Trie}.\n+     */\n+    public interface Cursor<K, V> {\n+        \n+        /**\n+         * The {@link Decision} tells the {@link Trie.Cursor} what to do on each step \n+         * while traversing the {@link Trie}.\n+         * \n+         * NOTE: Not all operations that work with a {@link Trie.Cursor} support all \n+         * {@link Decision} types\n+         */\n+        public static enum Decision {\n+            \n+            /**\n+             * Exit the traverse operation\n+             */\n+            EXIT, \n+            \n+            /**\n+             * Continue with the traverse operation\n+             */\n+            CONTINUE, \n+            \n+            /**\n+             * Remove the previously returned element\n+             * from the {@link Trie} and continue\n+             */\n+            REMOVE, \n+            \n+            /**\n+             * Remove the previously returned element\n+             * from the {@link Trie} and exit from the\n+             * traverse operation\n+             */\n+            REMOVE_AND_EXIT;\n+        }\n+        \n+        /**\n+         * Called for each {@link Entry} in the {@link Trie}. Return \n+         * {@link Decision#EXIT} to finish the {@link Trie} operation,\n+         * {@link Decision#CONTINUE} to go to the next {@link Entry},\n+         * {@link Decision#REMOVE} to remove the {@link Entry} and\n+         * continue iterating or {@link Decision#REMOVE_AND_EXIT} to\n+         * remove the {@link Entry} and stop iterating.\n+         * <p>\n+         * Note: Not all operations support {@link Decision#REMOVE}.\n+         * \n+         * @param entry  the current entry\n+         * @return the {@link Decision} based on the current entry\n+         */\n+        public Decision select(Map.Entry<? extends K, ? extends V> entry);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/TrieUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import org.apache.commons.collections4.trie.SynchronizedTrie;\n+import org.apache.commons.collections4.trie.UnmodifiableTrie;\n+\n+/**\n+ * A collection of {@link Trie} utilities.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class TrieUtils {\n+\n+    /**\n+     * {@link TrieUtils} should not normally be instantiated.\n+     */\n+    private TrieUtils() {}\n+    \n+    /**\n+     * Returns a synchronized instance of a {@link Trie}\n+     * \n+     * @see java.util.Collections#synchronizedMap(java.util.Map)\n+     */\n+    public static <K, V> Trie<K, V> synchronizedTrie(final Trie<K, V> trie) {\n+        return SynchronizedTrie.synchronizedTrie(trie);\n+    }\n+    \n+    /**\n+     * Returns an unmodifiable instance of a {@link Trie}\n+     * \n+     * @see java.util.Collections#unmodifiableMap(java.util.Map)\n+     */\n+    public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, V> trie) {\n+        return UnmodifiableTrie.unmodifiableTrie(trie);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/Unmodifiable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+/**\n+ * Marker interface for collections, maps and iterators that are unmodifiable.\n+ * <p>\n+ * This interface enables testing such as:\n+ * <pre>\n+ * if (coll instanceof Unmodifiable) {\n+ *   coll = new ArrayList(coll);\n+ * }\n+ * // now we know coll is modifiable\n+ * </pre>\n+ * Of course all this only works if you use the Unmodifiable classes defined\n+ * in this library. If you use the JDK unmodifiable class via {@code java.util Collections}\n+ * then the interface won't be there.\n+ *  \n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public interface Unmodifiable {\n+    // marker interface - no methods to implement\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>Bag</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated bag.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractBagDecorator<E>\n+        extends AbstractCollectionDecorator<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3768146017343785417L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractBagDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractBagDecorator(final Bag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected Bag<E> decorated() {\n+        return (Bag<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public int getCount(final Object object) {\n+        return decorated().getCount(object);\n+    }\n+\n+    public boolean add(final E object, final int count) {\n+        return decorated().add(object, count);\n+    }\n+\n+    public boolean remove(final Object object, final int count) {\n+        return decorated().remove(object, count);\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        return decorated().uniqueSet();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.Bag;\n+\n+/**\n+ * Abstract implementation of the {@link Bag} interface to simplify the creation\n+ * of subclass implementations.\n+ * <p>\n+ * Subclasses specify a Map implementation to use as the internal storage. The\n+ * map will be used to map bag elements to a number; the number represents the\n+ * number of occurrences of that element in the bag.\n+ *\n+ * @since 3.0 (previously DefaultMapBag v2.0)\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapBag<E> implements Bag<E> {\n+\n+    /** The map to use to store the data */\n+    private transient Map<E, MutableInteger> map;\n+    /** The current total size of the bag */\n+    private int size;\n+    /** The modification count for fail fast iterators */\n+    private transient int modCount;\n+    /** The modification count for fail fast iterators */\n+    private transient Set<E> uniqueSet;\n+\n+    /**\n+     * Constructor needed for subclass serialisation.\n+     */\n+    protected AbstractMapBag() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that assigns the specified Map as the backing store. The map\n+     * must be empty and non-null.\n+     * \n+     * @param map the map to assign\n+     */\n+    protected AbstractMapBag(final Map<E, MutableInteger> map) {\n+        super();\n+        this.map = map;\n+    }\n+\n+    /**\n+     * Utility method for implementations to access the map that backs this bag.\n+     * Not intended for interactive use outside of subclasses.\n+     * \n+     * @return the map being used by the Bag\n+     */\n+    protected Map<E, MutableInteger> getMap() {\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements in this bag.\n+     * \n+     * @return current size of the bag\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if the underlying map is empty.\n+     * \n+     * @return true if bag is empty\n+     */\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the number of occurrence of the given element in this bag by\n+     * looking up its count in the underlying map.\n+     * \n+     * @param object the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    public int getCount(final Object object) {\n+        final MutableInteger count = map.get(object);\n+        if (count != null) {\n+            return count.value;\n+        }\n+        return 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determines if the bag contains the given element by checking if the\n+     * underlying map contains the element as a key.\n+     * \n+     * @param object the object to search for\n+     * @return true if the bag contains the given element\n+     */\n+    public boolean contains(final Object object) {\n+        return map.containsKey(object);\n+    }\n+\n+    /**\n+     * Determines if the bag contains the given elements.\n+     * \n+     * @param coll the collection to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    public boolean containsAll(final Collection<?> coll) {\n+        if (coll instanceof Bag) {\n+            return containsAll((Bag<?>) coll);\n+        }\n+        return containsAll(new HashBag<Object>(coll));\n+    }\n+\n+    /**\n+     * Returns <code>true</code> if the bag contains all elements in the given\n+     * collection, respecting cardinality.\n+     * \n+     * @param other the bag to check against\n+     * @return <code>true</code> if the Bag contains all the collection\n+     */\n+    boolean containsAll(final Bag<?> other) {\n+        boolean result = true;\n+        final Iterator<?> it = other.uniqueSet().iterator();\n+        while (it.hasNext()) {\n+            final Object current = it.next();\n+            final boolean contains = getCount(current) >= other.getCount(current);\n+            result = result && contains;\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the bag elements. Elements present in the Bag more\n+     * than once will be returned repeatedly.\n+     * \n+     * @return the iterator\n+     */\n+    public Iterator<E> iterator() {\n+        return new BagIterator<E>(this);\n+    }\n+\n+    /**\n+     * Inner class iterator for the Bag.\n+     */\n+    static class BagIterator<E> implements Iterator<E> {\n+        private final AbstractMapBag<E> parent;\n+        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n+        private Map.Entry<E, MutableInteger> current;\n+        private int itemCount;\n+        private final int mods;\n+        private boolean canRemove;\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param parent the parent bag\n+         */\n+        public BagIterator(final AbstractMapBag<E> parent) {\n+            this.parent = parent;\n+            this.entryIterator = parent.map.entrySet().iterator();\n+            this.current = null;\n+            this.mods = parent.modCount;\n+            this.canRemove = false;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean hasNext() {\n+            return itemCount > 0 || entryIterator.hasNext();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public E next() {\n+            if (parent.modCount != mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (itemCount == 0) {\n+                current = entryIterator.next();\n+                itemCount = current.getValue().value;\n+            }\n+            canRemove = true;\n+            itemCount--;\n+            return current.getKey();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void remove() {\n+            if (parent.modCount != mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (canRemove == false) {\n+                throw new IllegalStateException();\n+            }\n+            final MutableInteger mut = current.getValue();\n+            if (mut.value > 1) {\n+                mut.value--;\n+            } else {\n+                entryIterator.remove();\n+            }\n+            parent.size--;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new element to the bag, incrementing its count in the underlying\n+     * map.\n+     * \n+     * @param object the object to add\n+     * @return <code>true</code> if the object was not already in the\n+     * <code>uniqueSet</code>\n+     */\n+    public boolean add(final E object) {\n+        return add(object, 1);\n+    }\n+\n+    /**\n+     * Adds a new element to the bag, incrementing its count in the map.\n+     * \n+     * @param object the object to search for\n+     * @param nCopies the number of copies to add\n+     * @return <code>true</code> if the object was not already in the\n+     * <code>uniqueSet</code>\n+     */\n+    public boolean add(final E object, final int nCopies) {\n+        modCount++;\n+        if (nCopies > 0) {\n+            final MutableInteger mut = map.get(object);\n+            size += nCopies;\n+            if (mut == null) {\n+                map.put(object, new MutableInteger(nCopies));\n+                return true;\n+            }\n+            mut.value += nCopies;\n+            return false;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Invokes {@link #add(Object)} for each element in the given collection.\n+     * \n+     * @param coll the collection to add\n+     * @return <code>true</code> if this call changed the bag\n+     */\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        boolean changed = false;\n+        final Iterator<? extends E> i = coll.iterator();\n+        while (i.hasNext()) {\n+            final boolean added = add(i.next());\n+            changed = changed || added;\n+        }\n+        return changed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clears the bag by clearing the underlying map.\n+     */\n+    public void clear() {\n+        modCount++;\n+        map.clear();\n+        size = 0;\n+    }\n+\n+    /**\n+     * Removes all copies of the specified object from the bag.\n+     * \n+     * @param object the object to remove\n+     * @return true if the bag changed\n+     */\n+    public boolean remove(final Object object) {\n+        final MutableInteger mut = map.get(object);\n+        if (mut == null) {\n+            return false;\n+        }\n+        modCount++;\n+        map.remove(object);\n+        size -= mut.value;\n+        return true;\n+    }\n+\n+    /**\n+     * Removes a specified number of copies of an object from the bag.\n+     * \n+     * @param object the object to remove\n+     * @param nCopies the number of copies to remove\n+     * @return true if the bag changed\n+     */\n+    public boolean remove(final Object object, final int nCopies) {\n+        final MutableInteger mut = map.get(object);\n+        if (mut == null) {\n+            return false;\n+        }\n+        if (nCopies <= 0) {\n+            return false;\n+        }\n+        modCount++;\n+        if (nCopies < mut.value) {\n+            mut.value -= nCopies;\n+            size -= nCopies;\n+        } else {\n+            map.remove(object);\n+            size -= mut.value;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Removes objects from the bag according to their count in the specified\n+     * collection.\n+     * \n+     * @param coll the collection to use\n+     * @return true if the bag changed\n+     */\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean result = false;\n+        if (coll != null) {\n+            final Iterator<?> i = coll.iterator();\n+            while (i.hasNext()) {\n+                final boolean changed = remove(i.next(), 1);\n+                result = result || changed;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given bag, respecting\n+     * cardinality.\n+     * \n+     * @param coll the collection to retain\n+     * @return true if this call changed the collection\n+     */\n+    public boolean retainAll(final Collection<?> coll) {\n+        if (coll instanceof Bag) {\n+            return retainAll((Bag<?>) coll);\n+        }\n+        return retainAll(new HashBag<Object>(coll));\n+    }\n+\n+    /**\n+     * Remove any members of the bag that are not in the given bag, respecting\n+     * cardinality.\n+     * @see #retainAll(Collection)\n+     * \n+     * @param other the bag to retain\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    boolean retainAll(final Bag<?> other) {\n+        boolean result = false;\n+        final Bag<E> excess = new HashBag<E>();\n+        final Iterator<E> i = uniqueSet().iterator();\n+        while (i.hasNext()) {\n+            final E current = i.next();\n+            final int myCount = getCount(current);\n+            final int otherCount = other.getCount(current);\n+            if (1 <= otherCount && otherCount <= myCount) {\n+                excess.add(current, myCount - otherCount);\n+            } else {\n+                excess.add(current, myCount);\n+            }\n+        }\n+        if (!excess.isEmpty()) {\n+            result = removeAll(excess);\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Mutable integer class for storing the data.\n+     */\n+    protected static class MutableInteger {\n+        /** The value of this mutable. */\n+        protected int value;\n+\n+        /**\n+         * Constructor.\n+         * @param value the initial value\n+         */\n+        MutableInteger(final int value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj instanceof MutableInteger == false) {\n+                return false;\n+            }\n+            return ((MutableInteger) obj).value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return value;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an array of all of this bag's elements.\n+     * \n+     * @return an array of all of this bag's elements\n+     */\n+    public Object[] toArray() {\n+        final Object[] result = new Object[size()];\n+        int i = 0;\n+        final Iterator<E> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+            final E current = it.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                result[i++] = current;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an array of all of this bag's elements.\n+     * If the input array has more elements than are in the bag,\n+     * trailing elements will be set to null.\n+     * \n+     * @param <T> the type of the array elements\n+     * @param array the array to populate\n+     * @return an array of all of this bag's elements\n+     * @throws ArrayStoreException if the runtime type of the specified array is not\n+     *   a supertype of the runtime type of the elements in this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    public <T> T[] toArray(T[] array) {\n+        final int size = size();\n+        if (array.length < size) {\n+            @SuppressWarnings(\"unchecked\") // safe as both are of type T\n+            final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n+            array = unchecked;\n+        }\n+\n+        int i = 0;\n+        final Iterator<E> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+            final E current = it.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                // unsafe, will throw ArrayStoreException if types are not compatible, see javadoc\n+                @SuppressWarnings(\"unchecked\") \n+                final T unchecked = (T) current;\n+                array[i++] = unchecked;\n+            }\n+        }\n+        while (i < array.length) {\n+            array[i++] = null;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the underlying map's key set.\n+     * \n+     * @return the set of unique elements in this bag\n+     */\n+    public Set<E> uniqueSet() {\n+        if (uniqueSet == null) {\n+            uniqueSet = UnmodifiableSet.<E> unmodifiableSet(map.keySet());\n+        }\n+        return uniqueSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * @param out the output stream\n+     * @throws IOException any of the usual I/O related exceptions\n+     */\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n+        out.writeInt(map.size());\n+        for (final Entry<E, MutableInteger> entry : map.entrySet()) {\n+            out.writeObject(entry.getKey());\n+            out.writeInt(entry.getValue().value);\n+        }\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * @param map the map to use\n+     * @param in the input stream\n+     * @throws IOException any of the usual I/O related exceptions\n+     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n+     * @throws ClassCastException if the stream does not contain the correct objects\n+     */\n+    protected void doReadObject(final Map<E, MutableInteger> map, final ObjectInputStream in)\n+            throws IOException, ClassNotFoundException {\n+        this.map = map;\n+        final int entrySize = in.readInt();\n+        for (int i = 0; i < entrySize; i++) {\n+            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n+            final E obj = (E) in.readObject();\n+            final int count = in.readInt();\n+            map.put(obj, new MutableInteger(count));\n+            size += count;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this Bag to another. This Bag equals another Bag if it contains\n+     * the same number of occurrences of the same elements.\n+     * \n+     * @param object the Bag to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        if (object instanceof Bag == false) {\n+            return false;\n+        }\n+        final Bag<?> other = (Bag<?>) object;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        for (final E element : map.keySet()) {\n+            if (other.getCount(element) != getCount(element)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets a hash code for the Bag compatible with the definition of equals.\n+     * The hash code is defined as the sum total of a hash code for each\n+     * element. The per element hash code is defined as\n+     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>. This hash code\n+     * is compatible with the Set interface.\n+     * \n+     * @return the hash code of the Bag\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        for (final Entry<E, MutableInteger> entry : map.entrySet()) {\n+            final E element = entry.getKey();\n+            final MutableInteger count = entry.getValue();\n+            total += (element == null ? 0 : element.hashCode()) ^ count.value;\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Implement a toString() method suitable for debugging.\n+     * \n+     * @return a debugging toString\n+     */\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"[]\";\n+        }\n+        final StringBuilder buf = new StringBuilder();\n+        buf.append('[');\n+        final Iterator<E> it = uniqueSet().iterator();\n+        while (it.hasNext()) {\n+            final Object current = it.next();\n+            final int count = getCount(current);\n+            buf.append(count);\n+            buf.append(':');\n+            buf.append(current);\n+            if (it.hasNext()) {\n+                buf.append(',');\n+            }\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.SortedBag;\n+\n+/**\n+ * Decorates another <code>SortedBag</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated bag.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedBagDecorator<E>\n+        extends AbstractBagDecorator<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8223473624050467718L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractSortedBagDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractSortedBagDecorator(final SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected SortedBag<E> decorated() {\n+        return (SortedBag<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/HashBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections4.Bag;\n+\n+/**\n+ * Implements {@link Bag}, using a {@link HashMap} to provide the\n+ * data storage. This is the standard implementation of a bag.\n+ * <p>\n+ * A {@link Bag} stores each object in the collection together with a\n+ * count of occurrences. Extra methods on the interface allow multiple copies\n+ * of an object to be added or removed at once. It is important to read the\n+ * interface javadoc carefully as several methods violate the\n+ * {@link Collection} interface specification.\n+ *\n+ * @since 3.0 (previously in main package v2.0)\n+ * @version $Id$\n+ */\n+public class HashBag<E> extends AbstractMapBag<E> implements Bag<E>, Serializable {\n+\n+    /** Serial version lock */\n+    private static final long serialVersionUID = -6561115435802554013L;\n+    \n+    /**\n+     * Constructs an empty {@link HashBag}.\n+     */\n+    public HashBag() {\n+        super(new HashMap<E, MutableInteger>());\n+    }\n+\n+    /**\n+     * Constructs a bag containing all the members of the given collection.\n+     * \n+     * @param coll  a collection to copy into this bag\n+     */\n+    public HashBag(final Collection<? extends E> coll) {\n+        this();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the bag out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the bag in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        super.doReadObject(new HashMap<E, MutableInteger>(), in);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another {@link Bag} to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This bag exists to provide validation for the decorated bag.\n+ * It is normally created to decorate an empty bag.\n+ * If an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the bag.\n+ * <pre>Bag bag = PredicatedBag.decorate(new HashBag(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedBag<E> extends PredicatedCollection<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2575833140344736876L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated Bag\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    public static <E> PredicatedBag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n+        return new PredicatedBag<E>(bag, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    protected PredicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n+        super(bag, predicate);\n+    }\n+\n+    /**\n+     * Gets the decorated bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected Bag<E> decorated() {\n+        return (Bag<E>) super.decorated();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    \n+    public boolean add(final E object, final int count) {\n+        validate(object);\n+        return decorated().add(object, count);\n+    }\n+\n+    public boolean remove(final Object object, final int count) {\n+        return decorated().remove(object, count);\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        return decorated().uniqueSet();\n+    }\n+\n+    public int getCount(final Object object) {\n+        return decorated().getCount(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.SortedBag;\n+\n+/**\n+ * Decorates another {@link SortedBag} to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This bag exists to provide validation for the decorated bag.\n+ * It is normally created to decorate an empty bag.\n+ * If an object cannot be added to the bag, an {@link IllegalArgumentException} is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the bag.\n+ * <pre>SortedBag bag = PredicatedSortedBag.decorate(new TreeBag(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSortedBag<E> extends PredicatedBag<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3448581314086406616L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated SortedBag\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    public static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n+                                                                 final Predicate<? super E> predicate) {\n+        return new PredicatedSortedBag<E>(bag, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>If there are any elements already in the bag being decorated, they\n+     * are validated.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws IllegalArgumentException if the bag contains invalid elements\n+     */\n+    protected PredicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n+        super(bag, predicate);\n+    }\n+\n+    /**\n+     * Gets the decorated sorted bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    @Override\n+    protected SortedBag<E> decorated() {\n+        return (SortedBag<E>) super.decorated();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    \n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.collection.SynchronizedCollection;\n+\n+/**\n+ * Decorates another {@link Bag} to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated bag.\n+ * Iterators must be separately synchronized around the loop.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SynchronizedBag<E> extends SynchronizedCollection<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8084674570753837109L;\n+\n+    /**\n+     * Factory method to create a synchronized bag.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @return a new synchronized Bag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n+        return new SynchronizedBag<E>(bag);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedBag(final Bag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param lock  the lock to use, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedBag(final Bag<E> bag, final Object lock) {\n+        super(bag, lock);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected Bag<E> getBag() {\n+        return (Bag<E>) collection;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    \n+    public boolean add(final E object, final int count) {\n+        synchronized (lock) {\n+            return getBag().add(object, count);\n+        }\n+    }\n+\n+    public boolean remove(final Object object, final int count) {\n+        synchronized (lock) {\n+            return getBag().remove(object, count);\n+        }\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        synchronized (lock) {\n+            final Set<E> set = getBag().uniqueSet();\n+            return new SynchronizedBagSet(set, lock);\n+        }\n+    }\n+\n+    public int getCount(final Object object) {\n+        synchronized (lock) {\n+            return getBag().getCount(object);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Synchronized Set for the Bag class.\n+     */\n+    class SynchronizedBagSet extends SynchronizedCollection<E> implements Set<E> {\n+        /** Serialization version */\n+        private static final long serialVersionUID = 2990565892366827855L;\n+\n+        /**\n+         * Constructor.\n+         * @param set  the set to decorate\n+         * @param lock  the lock to use, shared with the bag\n+         */\n+        SynchronizedBagSet(final Set<E> set, final Object lock) {\n+            super(set, lock);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.SortedBag;\n+\n+/**\n+ * Decorates another {@link SortedBag} to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Methods are synchronized, then forwarded to the decorated bag.\n+ * Iterators must be separately synchronized around the loop.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SynchronizedSortedBag<E> extends SynchronizedBag<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 722374056718497858L;\n+\n+    /**\n+     * Factory method to create a synchronized sorted bag.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @return a new synchronized SortedBag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n+        return new SynchronizedSortedBag<E>(bag);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedSortedBag(final SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param lock  the lock to use, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    protected SynchronizedSortedBag(final Bag<E> bag, final Object lock) {\n+        super(bag, lock);\n+    }\n+\n+    /**\n+     * Gets the bag being decorated.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected SortedBag<E> getSortedBag() {\n+        return (SortedBag<E>) collection;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    \n+    public synchronized E first() {\n+        synchronized (lock) {\n+            return getSortedBag().first();\n+        }\n+    }\n+\n+    public synchronized E last() {\n+        synchronized (lock) {\n+            return getSortedBag().last();\n+        }\n+    }\n+\n+    public synchronized Comparator<? super E> comparator() {\n+        synchronized (lock) {\n+            return getSortedBag().comparator();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.TransformedSet;\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+\n+/**\n+ * Decorates another {@link Bag} to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedBag<E> extends TransformedCollection<E> implements Bag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5421170911299074185L;\n+\n+    /**\n+     * Factory method to create a transforming bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed. Contrast this with {@link #transformedBag(Bag, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Bag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedBag<E>(bag, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming bag that will transform\n+     * existing contents of the specified bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingBag(Bag, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Bag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n+        if (transformer != null && bag != null && bag.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // Bag is of type E\n+            final E[] values = (E[]) bag.toArray();\n+            bag.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    protected TransformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n+        super(bag, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected Bag<E> getBag() {\n+        return (Bag<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public int getCount(final Object object) {\n+        return getBag().getCount(object);\n+    }\n+\n+    public boolean remove(final Object object, final int nCopies) {\n+        return getBag().remove(object, nCopies);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public boolean add(final E object, final int nCopies) {\n+        return getBag().add(transform(object), nCopies);\n+    }\n+\n+    public Set<E> uniqueSet() {\n+        final Set<E> set = getBag().uniqueSet();\n+        return TransformedSet.<E>transformingSet(set, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.SortedBag;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another {@link SortedBag} to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSortedBag<E> extends TransformedBag<E> implements SortedBag<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -251737742649401930L;\n+\n+    /**\n+     * Factory method to create a transforming sorted bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed. Contrast this with {@link #transformedSortedBag(SortedBag, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed SortedBag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    public static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSortedBag<E>(bag, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming sorted bag that will transform\n+     * existing contents of the specified sorted bag.\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSortedBag(SortedBag, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed SortedBag\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag,\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n+        final TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n+        if (transformer != null && bag != null && bag.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // bag is type E\n+            final E[] values = (E[]) bag.toArray();\n+            bag.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the bag being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if bag or transformer is null\n+     */\n+    protected TransformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n+        super(bag, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated bag.\n+     * \n+     * @return the decorated bag\n+     */\n+    protected SortedBag<E> getSortedBag() {\n+        return (SortedBag<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E first() {\n+        return getSortedBag().first();\n+    }\n+\n+    public E last() {\n+        return getSortedBag().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return getSortedBag().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/TreeBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.SortedBag;\n+\n+/**\n+ * Implements {@link SortedBag}, using a {@link TreeMap} to provide\n+ * the data storage. This is the standard implementation of a sorted bag.\n+ * <p>\n+ * Order will be maintained among the bag members and can be viewed through the\n+ * iterator.\n+ * <p>\n+ * A {@link org.apache.commons.collections4.Bag Bag} stores each object in the collection together with a count\n+ * of occurrences. Extra methods on the interface allow multiple copies of an\n+ * object to be added or removed at once. It is important to read the interface\n+ * javadoc carefully as several methods violate the {@link Collection}\n+ * interface specification.\n+ *\n+ * @since 3.0 (previously in main package v2.0)\n+ * @version $Id$\n+ */\n+public class TreeBag<E> extends AbstractMapBag<E> implements SortedBag<E>, Serializable {\n+\n+    /** Serial version lock */\n+    private static final long serialVersionUID = -7740146511091606676L;\n+\n+    /**\n+     * Constructs an empty {@link TreeBag}.\n+     */\n+    public TreeBag() {\n+        super(new TreeMap<E, MutableInteger>());\n+    }\n+\n+    /**\n+     * Constructs an empty bag that maintains order on its unique representative\n+     * members according to the given {@link Comparator}.\n+     * \n+     * @param comparator the comparator to use\n+     */\n+    public TreeBag(final Comparator<? super E> comparator) {\n+        super(new TreeMap<E, MutableInteger>(comparator));\n+    }\n+\n+    /**\n+     * Constructs a {@link TreeBag} containing all the members of the\n+     * specified collection.\n+     * \n+     * @param coll the collection to copy into the bag\n+     */\n+    public TreeBag(final Collection<? extends E> coll) {\n+        this();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @throws IllegalArgumentException if the object to be added does not implement\n+     * {@link Comparable} and the {@link TreeBag} is using natural ordering\n+     */\n+    @Override\n+    public boolean add(final E object) {\n+        if(comparator() == null && !(object instanceof Comparable)) {\n+            throw new IllegalArgumentException(\"Objects of type \" + object.getClass() + \" cannot be added to \" + \n+                                               \"a naturally ordered TreeBag as it does not implement Comparable\");\n+        }\n+        return super.add(object);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E first() {\n+        return getMap().firstKey();\n+    }\n+\n+    public E last() {\n+        return getMap().lastKey();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return getMap().comparator();\n+    }\n+\n+    @Override\n+    protected SortedMap<E, AbstractMapBag.MutableInteger> getMap() {\n+        return (SortedMap<E, AbstractMapBag.MutableInteger>) super.getMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the bag out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(comparator());\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the bag in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        @SuppressWarnings(\"unchecked\")  // This will fail at runtime if the stream is incorrect\n+        final Comparator<? super E> comp = (Comparator<? super E>) in.readObject();\n+        super.doReadObject(new TreeMap<E, MutableInteger>(comp), in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another {@link Bag} to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableBag<E>\n+        extends AbstractBagDecorator<E> implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1873799975157099624L;\n+\n+    /**\n+     * Factory method to create an unmodifiable bag.\n+     * <p>\n+     * If the bag passed in is already unmodifiable, it is returned.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @return an unmodifiable Bag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> Bag<E> unmodifiableBag(final Bag<E> bag) {\n+        if (bag instanceof Unmodifiable) {\n+            return bag;\n+        }\n+        return new UnmodifiableBag<E>(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    private UnmodifiableBag(final Bag<E> bag) {\n+        super(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.<E> unmodifiableIterator(decorated()\n+                .iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(final E object, final int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object, final int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<E> uniqueSet() {\n+        final Set<E> set = decorated().uniqueSet();\n+        return UnmodifiableSet.<E> unmodifiableSet(set);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.SortedBag;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another {@link SortedBag} to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableSortedBag<E>\n+        extends AbstractSortedBagDecorator<E> implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3190437252665717841L;\n+\n+    /**\n+     * Factory method to create an unmodifiable bag.\n+     * <p>\n+     * If the bag passed in is already unmodifiable, it is returned.\n+     * \n+     * @param <E> the type of the elements in the bag\n+     * @param bag  the bag to decorate, must not be null\n+     * @return an unmodifiable SortedBag\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n+        if (bag instanceof Unmodifiable) {\n+            return bag;\n+        }\n+        return new UnmodifiableSortedBag<E>(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param bag  the bag to decorate, must not be null\n+     * @throws IllegalArgumentException if bag is null\n+     */\n+    private UnmodifiableSortedBag(final SortedBag<E> bag) {\n+        super(bag);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(final E object, final int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object, final int count) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<E> uniqueSet() {\n+        final Set<E> set = decorated().uniqueSet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bag/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the {@link org.apache.commons.collections4.Bag Bag} and \n+ * {@link org.apache.commons.collections4.SortedBag SortedBag} interfaces.\n+ * A bag stores an object and a count of the number of occurrences of the object.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>HashBag - implementation that uses a HashMap to store the data\n+ *   <li>TreeBag - implementation that uses a TreeMap to store the data\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Unmodifiable - ensures the bag cannot be altered\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms each element added to the bag\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.bag;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.map.AbstractMapDecorator;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a BidiMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractBidiMapDecorator<K, V>\n+        extends AbstractMapDecorator<K, V> implements BidiMap<K, V> {\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractBidiMapDecorator(final BidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected BidiMap<K, V> decorated() {\n+        return (BidiMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    public K getKey(final Object value) {\n+        return decorated().getKey(value);\n+    }\n+\n+    public K removeValue(final Object value) {\n+        return decorated().removeValue(value);\n+    }\n+\n+    public BidiMap<V, K> inverseBidiMap() {\n+        return decorated().inverseBidiMap();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;\n+\n+/**\n+ * Abstract {@link BidiMap} implemented using two maps.\n+ * <p>\n+ * An implementation can be written simply by implementing the\n+ * {@link #createBidiMap(Map, Map, BidiMap)} method.\n+ *\n+ * @see DualHashBidiMap\n+ * @see DualTreeBidiMap\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractDualBidiMap<K, V> implements BidiMap<K, V> {\n+\n+    /**\n+     * Normal delegate map.\n+     */\n+    protected transient Map<K, V> normalMap;\n+\n+    /**\n+     * Reverse delegate map.\n+     */\n+    protected transient Map<V, K> reverseMap;\n+\n+    /**\n+     * Inverse view of this map.\n+     */\n+    protected transient BidiMap<V, K> inverseBidiMap = null;\n+\n+    /**\n+     * View of the keys.\n+     */\n+    protected transient Set<K> keySet = null;\n+\n+    /**\n+     * View of the values.\n+     */\n+    protected transient Collection<V> values = null;\n+\n+    /**\n+     * View of the entries.\n+     */\n+    protected transient Set<Map.Entry<K, V>> entrySet = null;\n+\n+    /**\n+     * Creates an empty map, initialised by <code>createMap</code>.\n+     * <p>\n+     * This constructor remains in place for deserialization.\n+     * All other usage is deprecated in favour of\n+     * {@link #AbstractDualBidiMap(Map, Map)}.\n+     */\n+    protected AbstractDualBidiMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Creates an empty map using the two maps specified as storage.\n+     * <p>\n+     * The two maps must be a matching pair, normal and reverse.\n+     * They will typically both be empty.\n+     * <p>\n+     * Neither map is validated, so nulls may be passed in.\n+     * If you choose to do this then the subclass constructor must populate\n+     * the <code>maps[]</code> instance variable itself.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @since 3.1\n+     */\n+    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap) {\n+        super();\n+        this.normalMap = normalMap;\n+        this.reverseMap = reverseMap;\n+    }\n+\n+    /**\n+     * Constructs a map that decorates the specified maps,\n+     * used by the subclass <code>createBidiMap</code> implementation.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                                  final BidiMap<V, K> inverseBidiMap) {\n+        super();\n+        this.normalMap = normalMap;\n+        this.reverseMap = reverseMap;\n+        this.inverseBidiMap = inverseBidiMap;\n+    }\n+\n+    /**\n+     * Creates a new instance of the subclass.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseMap  this map, which is the inverse in the new map\n+     * @return the inverse map\n+     */\n+    protected abstract BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap);\n+\n+    // Map delegation\n+    //-----------------------------------------------------------------------\n+    \n+    public V get(final Object key) {\n+        return normalMap.get(key);\n+    }\n+\n+    public int size() {\n+        return normalMap.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return normalMap.isEmpty();\n+    }\n+\n+    public boolean containsKey(final Object key) {\n+        return normalMap.containsKey(key);\n+    }\n+\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return normalMap.equals(obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return normalMap.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return normalMap.toString();\n+    }\n+\n+    // BidiMap changes\n+    //-----------------------------------------------------------------------\n+    \n+    public V put(final K key, final V value) {\n+        if (normalMap.containsKey(key)) {\n+            reverseMap.remove(normalMap.get(key));\n+        }\n+        if (reverseMap.containsKey(value)) {\n+            normalMap.remove(reverseMap.get(value));\n+        }\n+        final V obj = normalMap.put(key, value);\n+        reverseMap.put(value, key);\n+        return obj;\n+    }\n+\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public V remove(final Object key) {\n+        V value = null;\n+        if (normalMap.containsKey(key)) {\n+            value = normalMap.remove(key);\n+            reverseMap.remove(value);\n+        }\n+        return value;\n+    }\n+\n+    public void clear() {\n+        normalMap.clear();\n+        reverseMap.clear();\n+    }\n+\n+    public boolean containsValue(final Object value) {\n+        return reverseMap.containsKey(value);\n+    }\n+\n+    // BidiMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains a <code>MapIterator</code> over the map.\n+     * The iterator implements <code>ResetableMapIterator</code>.\n+     * This implementation relies on the entrySet iterator.\n+     * <p>\n+     * The setValue() methods only allow a new value to be set.\n+     * If the value being set is already in the map, an IllegalArgumentException\n+     * is thrown (as setValue cannot change the size of the map).\n+     *\n+     * @return a map iterator\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new BidiMapIterator<K, V>(this);\n+    }\n+\n+    public K getKey(final Object value) {\n+        return reverseMap.get(value);\n+    }\n+\n+    public K removeValue(final Object value) {\n+        K key = null;\n+        if (reverseMap.containsKey(value)) {\n+            key = reverseMap.remove(value);\n+            normalMap.remove(key);\n+        }\n+        return key;\n+    }\n+\n+    public BidiMap<V, K> inverseBidiMap() {\n+        if (inverseBidiMap == null) {\n+            inverseBidiMap = createBidiMap(reverseMap, normalMap, this);\n+        }\n+        return inverseBidiMap;\n+    }\n+\n+    // Map views\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a keySet view of the map.\n+     * Changes made on the view are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     *\n+     * @return the keySet view\n+     */\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet<K>(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the keySet iterator\n+     */\n+    protected Iterator<K> createKeySetIterator(final Iterator<K> iterator) {\n+        return new KeySetIterator<K>(iterator, this);\n+    }\n+\n+    /**\n+     * Gets a values view of the map.\n+     * Changes made on the view are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     *\n+     * @return the values view\n+     */\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values<V>(this);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the values iterator\n+     */\n+    protected Iterator<V> createValuesIterator(final Iterator<V> iterator) {\n+        return new ValuesIterator<V>(iterator, this);\n+    }\n+\n+    /**\n+     * Gets an entrySet view of the map.\n+     * Changes made on the set are reflected in the map.\n+     * The set supports remove and clear but not add.\n+     * <p>\n+     * The Map Entry setValue() method only allow a new value to be set.\n+     * If the value being set is already in the map, an IllegalArgumentException\n+     * is thrown (as setValue cannot change the size of the map).\n+     *\n+     * @return the entrySet view\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet<K, V>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the entrySet iterator\n+     */\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n+        return new EntrySetIterator<K, V>(iterator, this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class View.\n+     */\n+    protected static abstract class View<K, V, E> extends AbstractCollectionDecorator<E> {\n+\n+        /** Generated serial version ID. */\n+        private static final long serialVersionUID = 4621510560119690639L;\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param coll  the collection view being decorated\n+         * @param parent  the parent BidiMap\n+         */\n+        protected View(final Collection<E> coll, final AbstractDualBidiMap<K, V> parent) {\n+            super(coll);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public boolean removeAll(final Collection<?> coll) {\n+            if (parent.isEmpty() || coll.isEmpty()) {\n+                return false;\n+            }\n+            boolean modified = false;\n+            final Iterator<?> it = coll.iterator();\n+            while (it.hasNext()) {\n+                modified |= remove(it.next());\n+            }\n+            return modified;\n+        }\n+\n+        @Override\n+        public boolean retainAll(final Collection<?> coll) {\n+            if (parent.isEmpty()) {\n+                return false;\n+            }\n+            if (coll.isEmpty()) {\n+                parent.clear();\n+                return true;\n+            }\n+            boolean modified = false;\n+            final Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next()) == false) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class KeySet.\n+     */\n+    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = -7107935777385040694L;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySet(final AbstractDualBidiMap<K, ?> parent) {\n+            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return parent.createKeySetIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean contains(final Object key) {\n+            return parent.normalMap.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object key) {\n+            if (parent.normalMap.containsKey(key)) {\n+                final Object value = parent.normalMap.remove(key);\n+                parent.reverseMap.remove(value);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class KeySetIterator.\n+     */\n+    protected static class KeySetIterator<K> extends AbstractIteratorDecorator<K> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, ?> parent;\n+\n+        /** The last returned key */\n+        protected K lastKey = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent map\n+         */\n+        protected KeySetIterator(final Iterator<K> iterator, final AbstractDualBidiMap<K, ?> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public K next() {\n+            lastKey = super.next();\n+            canRemove = true;\n+            return lastKey;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            final Object value = parent.normalMap.get(lastKey);\n+            super.remove();\n+            parent.reverseMap.remove(value);\n+            lastKey = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class Values.\n+     */\n+    protected static class Values<V> extends View<Object, V, V> implements Set<V> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 4023777119829639864L;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        protected Values(final AbstractDualBidiMap<?, V> parent) {\n+            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return parent.createValuesIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean contains(final Object value) {\n+            return parent.reverseMap.containsKey(value);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object value) {\n+            if (parent.reverseMap.containsKey(value)) {\n+                final Object key = parent.reverseMap.remove(value);\n+                parent.normalMap.remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class ValuesIterator.\n+     */\n+    protected static class ValuesIterator<V> extends AbstractIteratorDecorator<V> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<Object, V> parent;\n+\n+        /** The last returned value */\n+        protected V lastValue = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent map\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(final Iterator<V> iterator, final AbstractDualBidiMap<?, V> parent) {\n+            super(iterator);\n+            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n+        }\n+\n+        @Override\n+        public V next() {\n+            lastValue = super.next();\n+            canRemove = true;\n+            return lastValue;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            super.remove(); // removes from maps[0]\n+            parent.reverseMap.remove(lastValue);\n+            lastValue = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class EntrySet.\n+     */\n+    protected static class EntrySet<K, V> extends View<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 4040410962603292348L;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        protected EntrySet(final AbstractDualBidiMap<K, V> parent) {\n+            super(parent.normalMap.entrySet(), parent);\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return parent.createEntrySetIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object key = entry.getKey();\n+            if (parent.containsKey(key)) {\n+                final V value = parent.normalMap.get(key);\n+                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n+                    parent.normalMap.remove(key);\n+                    parent.reverseMap.remove(value);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class EntrySetIterator.\n+     */\n+    protected static class EntrySetIterator<K, V> extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /** The last returned entry */\n+        protected Map.Entry<K, V> last = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent map\n+         */\n+        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractDualBidiMap<K, V> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Map.Entry<K, V> next() {\n+            last = new MapEntry<K, V>(super.next(), parent);\n+            canRemove = true;\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            final Object value = last.getValue();\n+            super.remove();\n+            parent.reverseMap.remove(value);\n+            last = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class MapEntry.\n+     */\n+    protected static class MapEntry<K, V> extends AbstractMapEntryDecorator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /**\n+         * Constructor.\n+         * @param entry  the entry to decorate\n+         * @param parent  the parent map\n+         */\n+        protected MapEntry(final Map.Entry<K, V> entry, final AbstractDualBidiMap<K, V> parent) {\n+            super(entry);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public V setValue(final V value) {\n+            final K key = MapEntry.this.getKey();\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != key) {\n+                throw new IllegalArgumentException(\n+                        \"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            parent.put(key, value);\n+            return super.setValue(value);\n+        }\n+    }\n+\n+    /**\n+     * Inner class MapIterator.\n+     */\n+    protected static class BidiMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /** The iterator being wrapped */\n+        protected Iterator<Map.Entry<K, V>> iterator;\n+\n+        /** The last returned entry */\n+        protected Map.Entry<K, V> last = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param parent  the parent map\n+         */\n+        protected BidiMapIterator(final AbstractDualBidiMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            this.iterator = parent.normalMap.entrySet().iterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public K next() {\n+            last = iterator.next();\n+            canRemove = true;\n+            return last.getKey();\n+        }\n+\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            // store value as remove may change the entry in the decorator (eg.TreeMap)\n+            final V value = last.getValue();\n+            iterator.remove();\n+            parent.reverseMap.remove(value);\n+            last = null;\n+            canRemove = false;\n+        }\n+\n+        public K getKey() {\n+            if (last == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (last == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return last.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            if (last == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\n+                        \"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            return parent.put(last.getKey(), value);\n+        }\n+\n+        public void reset() {\n+            iterator = parent.normalMap.entrySet().iterator();\n+            last = null;\n+            canRemove = false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"MapIterator[]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to an OrderedBidiMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the inverse from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractOrderedBidiMapDecorator<K, V>\n+        extends AbstractBidiMapDecorator<K, V>\n+        implements OrderedBidiMap<K, V> {\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractOrderedBidiMapDecorator(final OrderedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected OrderedBidiMap<K, V> decorated() {\n+        return (OrderedBidiMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    public K nextKey(final K key) {\n+        return decorated().nextKey(key);\n+    }\n+\n+    public K previousKey(final K key) {\n+        return decorated().previousKey(key);\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        return decorated().inverseBidiMap();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.SortedBidiMap;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a SortedBidiMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the inverse from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedBidiMapDecorator<K, V>\n+        extends AbstractOrderedBidiMapDecorator<K, V> implements SortedBidiMap<K, V> {\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractSortedBidiMapDecorator(final SortedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected SortedBidiMap<K, V> decorated() {\n+        return (SortedBidiMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        return decorated().inverseBidiMap();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    public Comparator<? super V> valueComparator() {\n+        return decorated().valueComparator();\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return decorated().subMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return decorated().headMap(toKey);\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return decorated().tailMap(fromKey);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/DualHashBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.BidiMap;\n+\n+/**\n+ * Implementation of {@link BidiMap} that uses two {@link HashMap} instances.\n+ * <p>\n+ * Two {@link HashMap} instances are used in this class.\n+ * This provides fast lookups at the expense of storing two sets of map entries.\n+ * Commons Collections would welcome the addition of a direct hash-based\n+ * implementation of the {@link BidiMap} interface.\n+ * <p>\n+ * NOTE: From Commons Collections 3.1, all subclasses will use {@link HashMap}\n+ * and the flawed <code>createMap</code> method is ignored.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DualHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 721969328361808L;\n+\n+    /**\n+     * Creates an empty <code>HashBidiMap</code>.\n+     */\n+    public DualHashBidiMap() {\n+        super(new HashMap<K, V>(), new HashMap<V, K>());\n+    }\n+\n+    /** \n+     * Constructs a <code>HashBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.  \n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualHashBidiMap(final Map<K, V> map) {\n+        super(new HashMap<K, V>(), new HashMap<V, K>());\n+        putAll(map);\n+    }\n+    \n+    /** \n+     * Constructs a <code>HashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                              final BidiMap<V, K> inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     * \n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    @Override\n+    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n+                                          final BidiMap<K, V> inverseBidiMap) {\n+        return new DualHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(normalMap);\n+    }\n+\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        normalMap = new HashMap<K, V>();\n+        reverseMap = new HashMap<V, K>();\n+        @SuppressWarnings(\"unchecked\") // will fail at runtime if stream is incorrect\n+        final Map<K, V> map = (Map<K, V>) in.readObject();\n+        putAll(map);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import org.apache.commons.collections4.BidiMap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Implementation of <code>BidiMap</code> that uses two <code>LinkedHashMap</code> instances.\n+ * <p>\n+ * Two <code>LinkedHashMap</code> instances are used in this class.\n+ * This provides fast lookups at the expense of storing two sets of map entries and two linked lists.\n+ *\n+ * @version $Id $\n+ * @since 4.0\n+ */\n+public class DualLinkedHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 721969328361810L;\n+\n+    /**\n+     * Creates an empty <code>HashBidiMap</code>.\n+     */\n+    public DualLinkedHashBidiMap() {\n+        super(new LinkedHashMap<K, V>(), new LinkedHashMap<V, K>());\n+    }\n+\n+    /**\n+     * Constructs a <code>LinkedHashBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.\n+     *\n+     * @param map the map whose mappings are to be placed in this map\n+     */\n+    public DualLinkedHashBidiMap(final Map<K, V> map) {\n+        super(new LinkedHashMap<K, V>(), new LinkedHashMap<V, K>());\n+        putAll(map);\n+    }\n+\n+    /**\n+     * Constructs a <code>LinkedHashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap      the normal direction map\n+     * @param reverseMap     the reverse direction map\n+     * @param inverseBidiMap the inverse BidiMap\n+     */\n+    protected DualLinkedHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                                    final BidiMap<V, K> inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     *\n+     * @param normalMap      the normal direction map\n+     * @param reverseMap     the reverse direction map\n+     * @param inverseBidiMap the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    @Override\n+    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n+            final BidiMap<K, V> inverseBidiMap) {\n+        return new DualLinkedHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n+    }\n+    \n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(normalMap);\n+    }\n+\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        normalMap = new LinkedHashMap<K, V>();\n+        reverseMap = new LinkedHashMap<V, K>();\n+        @SuppressWarnings(\"unchecked\") // will fail at runtime if stream is incorrect\n+        final Map<K, V> map = (Map<K, V>) in.readObject();\n+        putAll(map);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.SortedBidiMap;\n+import org.apache.commons.collections4.map.AbstractSortedMapDecorator;\n+\n+/**\n+ * Implementation of {@link BidiMap} that uses two {@link TreeMap} instances.\n+ * <p>\n+ * The setValue() method on iterators will succeed only if the new value being set is\n+ * not already in the bidimap.\n+ * <p>\n+ * When considering whether to use this class, the {@link TreeBidiMap} class should\n+ * also be considered. It implements the interface using a dedicated design, and does\n+ * not store each object twice, which can save on memory use.\n+ * <p>\n+ * NOTE: From Commons Collections 3.1, all subclasses will use {@link TreeMap}\n+ * and the flawed <code>createMap</code> method is ignored.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DualTreeBidiMap<K, V> extends AbstractDualBidiMap<K, V>\n+        implements SortedBidiMap<K, V>, Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 721969328361809L;\n+\n+    /** The key comparator to use */\n+    protected final Comparator<? super K> comparator;\n+\n+    /** The value comparator to use */\n+    protected final Comparator<? super V> valueComparator;\n+    \n+    /**\n+     * Creates an empty <code>DualTreeBidiMap</code>\n+     */\n+    public DualTreeBidiMap() {\n+        super(new TreeMap<K, V>(), new TreeMap<V, K>());\n+        this.comparator = null;\n+        this.valueComparator = null;\n+    }\n+\n+    /**\n+     * Constructs a <code>DualTreeBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.\n+     *\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public DualTreeBidiMap(final Map<K, V> map) {\n+        super(new TreeMap<K, V>(), new TreeMap<V, K>());\n+        putAll(map);\n+        this.comparator = null;\n+        this.valueComparator = null;\n+    }\n+\n+    /**\n+     * Constructs a {@link DualTreeBidiMap} using the specified {@link Comparator}.\n+     *\n+     * @param keyComparator  the comparator\n+     * @param valueComparator  the values comparator to use\n+     */\n+    public DualTreeBidiMap(final Comparator<? super K> keyComparator, final Comparator<? super V> valueComparator) {\n+        super(new TreeMap<K, V>(keyComparator), new TreeMap<V, K>(valueComparator));\n+        this.comparator = keyComparator;\n+        this.valueComparator = valueComparator;\n+    }\n+\n+    /**\n+     * Constructs a {@link DualTreeBidiMap} that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected DualTreeBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                              final BidiMap<V, K> inverseBidiMap) {\n+        super(normalMap, reverseMap, inverseBidiMap);\n+        this.comparator = ((SortedMap<K, V>) normalMap).comparator();\n+        this.valueComparator = ((SortedMap<V, K>) reverseMap).comparator();\n+    }\n+\n+    /**\n+     * Creates a new instance of this object.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseMap  the inverse BidiMap\n+     * @return new bidi map\n+     */\n+    @Override\n+    protected DualTreeBidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n+                                                  final BidiMap<K, V> inverseMap) {\n+        return new DualTreeBidiMap<V, K>(normalMap, reverseMap, inverseMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public Comparator<? super K> comparator() {\n+        return ((SortedMap<K, V>) normalMap).comparator();\n+    }\n+\n+    public Comparator<? super V> valueComparator() {\n+        return ((SortedMap<V, K>) reverseMap).comparator();\n+        \n+    }\n+\n+    public K firstKey() {\n+        return ((SortedMap<K, V>) normalMap).firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return ((SortedMap<K, V>) normalMap).lastKey();\n+    }\n+\n+    public K nextKey(final K key) {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        if (normalMap instanceof OrderedMap) {\n+            return ((OrderedMap<K, ?>) normalMap).nextKey(key);\n+        }\n+        final SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        final Iterator<K> it = sm.tailMap(key).keySet().iterator();\n+        it.next();\n+        if (it.hasNext()) {\n+            return it.next();\n+        }\n+        return null;\n+    }\n+\n+    public K previousKey(final K key) {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        if (normalMap instanceof OrderedMap) {\n+            return ((OrderedMap<K, V>) normalMap).previousKey(key);\n+        }\n+        final SortedMap<K, V> sm = (SortedMap<K, V>) normalMap;\n+        final SortedMap<K, V> hm = sm.headMap(key);\n+        if (hm.isEmpty()) {\n+            return null;\n+        }\n+        return hm.lastKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Obtains an ordered map iterator.\n+     * <p>\n+     * This implementation copies the elements to an ArrayList in order to\n+     * provide the forward/backward behaviour.\n+     *\n+     * @return a new ordered map iterator\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new BidiOrderedMapIterator<K, V>(this);\n+    }\n+\n+    public SortedBidiMap<V, K> inverseSortedBidiMap() {\n+        return inverseBidiMap();\n+    }\n+\n+    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n+        return inverseBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n+        return new ViewMap<K, V>(this, sub);\n+    }\n+\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        return (SortedBidiMap<V, K>) super.inverseBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Internal sorted map view.\n+     */\n+    protected static class ViewMap<K, V> extends AbstractSortedMapDecorator<K, V> {\n+        /** The parent bidi map. */\n+        final DualTreeBidiMap<K, V> bidi;\n+\n+        /**\n+         * Constructor.\n+         * @param bidi  the parent bidi map\n+         * @param sm  the subMap sorted map\n+         */\n+        protected ViewMap(final DualTreeBidiMap<K, V> bidi, final SortedMap<K, V> sm) {\n+            // the implementation is not great here...\n+            // use the normalMap as the filtered map, but reverseMap as the full map\n+            // this forces containsValue and clear to be overridden\n+            super(new DualTreeBidiMap<K, V>(sm, bidi.reverseMap, bidi.inverseBidiMap));\n+            this.bidi = decorated();\n+        }\n+\n+        @Override\n+        public boolean containsValue(final Object value) {\n+            // override as default implementation uses reverseMap\n+            return decorated().normalMap.containsValue(value);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            // override as default implementation uses reverseMap\n+            for (final Iterator<K> it = keySet().iterator(); it.hasNext();) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> headMap(final K toKey) {\n+            return new ViewMap<K, V>(decorated(), super.headMap(toKey));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> tailMap(final K fromKey) {\n+            return new ViewMap<K, V>(decorated(), super.tailMap(fromKey));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+            return new ViewMap<K, V>(decorated(), super.subMap(fromKey, toKey));\n+        }\n+\n+        @Override\n+        protected DualTreeBidiMap<K, V> decorated() {\n+            return (DualTreeBidiMap<K, V>) super.decorated();\n+        }\n+\n+        @Override\n+        public K previousKey(final K key) {\n+            return decorated().previousKey(key);\n+        }\n+\n+        @Override\n+        public K nextKey(final K key) {\n+            return decorated().nextKey(key);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class MapIterator.\n+     */\n+    protected static class BidiOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+        /** The parent map */\n+        protected final AbstractDualBidiMap<K, V> parent;\n+\n+        /** The iterator being decorated */\n+        protected ListIterator<Map.Entry<K, V>> iterator;\n+\n+        /** The last returned entry */\n+        private Map.Entry<K, V> last = null;\n+\n+        /**\n+         * Constructor.\n+         * @param parent  the parent map\n+         */\n+        protected BidiOrderedMapIterator(final AbstractDualBidiMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public K next() {\n+            last = iterator.next();\n+            return last.getKey();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+\n+        public K previous() {\n+            last = iterator.previous();\n+            return last.getKey();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            parent.remove(last.getKey());\n+            last = null;\n+        }\n+\n+        public K getKey() {\n+            if (last == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return last.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (last == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return last.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            if (last == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator setValue() can only be called after next() and before remove()\");\n+            }\n+            if (parent.reverseMap.containsKey(value) &&\n+                parent.reverseMap.get(value) != last.getKey()) {\n+                throw new IllegalArgumentException(\n+                        \"Cannot use setValue() when the object being set is already in the map\");\n+            }\n+            final V oldValue = parent.put(last.getKey(), value);\n+            // Map.Entry specifies that the behavior is undefined when the backing map\n+            // has been modified (as we did with the put), so we also set the value\n+            // (especially needed for IBM JDK)\n+            last.setValue(value);\n+            return oldValue;\n+        }\n+\n+        public void reset() {\n+            iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n+            last = null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"MapIterator[]\";\n+        }\n+    }\n+\n+    // Serialization\n+    //-----------------------------------------------------------------------\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(normalMap);\n+    }\n+\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        normalMap = new TreeMap<K, V>(comparator);\n+        reverseMap = new TreeMap<V, K>(valueComparator);\n+        @SuppressWarnings(\"unchecked\") // will fail at runtime if the stream is incorrect\n+        final Map<K, V> map = (Map<K, V>) in.readObject();\n+        putAll(map);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/TreeBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.OrderedIterator;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\n+import org.apache.commons.collections4.keyvalue.UnmodifiableMapEntry;\n+\n+import static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.KEY;\n+import static org.apache.commons.collections4.bidimap.TreeBidiMap.DataElement.VALUE;\n+\n+/**\n+ * Red-Black tree-based implementation of BidiMap where all objects added\n+ * implement the <code>Comparable</code> interface.\n+ * <p>\n+ * This class guarantees that the map will be in both ascending key order\n+ * and ascending value order, sorted according to the natural order for\n+ * the key's and value's classes.\n+ * <p>\n+ * This Map is intended for applications that need to be able to look\n+ * up a key-value pairing by either key or value, and need to do so\n+ * with equal efficiency.\n+ * <p>\n+ * While that goal could be accomplished by taking a pair of TreeMaps\n+ * and redirecting requests to the appropriate TreeMap (e.g.,\n+ * containsKey would be directed to the TreeMap that maps values to\n+ * keys, containsValue would be directed to the TreeMap that maps keys\n+ * to values), there are problems with that implementation.\n+ * If the data contained in the TreeMaps is large, the cost of redundant\n+ * storage becomes significant. The {@link DualTreeBidiMap} and\n+ * {@link DualHashBidiMap} implementations use this approach.\n+ * <p>\n+ * This solution keeps minimizes the data storage by holding data only once.\n+ * The red-black algorithm is based on {@link java.util.TreeMap}, but has been modified\n+ * to simultaneously map a tree node by key and by value. This doubles the\n+ * cost of put operations (but so does using two TreeMaps), and nearly doubles\n+ * the cost of remove operations (there is a savings in that the lookup of the\n+ * node to be removed only has to be performed once). And since only one node\n+ * contains the key and value, storage is significantly less than that\n+ * required by two TreeMaps.\n+ * <p>\n+ * The Map.Entry instances returned by the appropriate methods will\n+ * not allow setValue() and will throw an\n+ * UnsupportedOperationException on attempts to call that method.\n+ *\n+ * TODO: serialization does not work anymore\n+ *\n+ * @since 3.0 (previously DoubleOrderedMap v2.0)\n+ * @version $Id$\n+ */\n+public class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> implements OrderedBidiMap<K, V> {\n+\n+    static enum DataElement {\n+        KEY(\"key\"), VALUE(\"value\");\n+\n+        private final String description;\n+\n+        /**\n+         * Create a new TreeBidiMap.DataElement.\n+         * \n+         * @param description  the description for the element\n+         */\n+        private DataElement(final String description) {\n+            this.description = description;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return description;\n+        }\n+    }\n+\n+    private Node<K, V>[] rootNode;\n+    private int nodeCount = 0;\n+    private int modifications = 0;\n+    private Set<K> keySet;\n+    private Set<V> valuesSet;\n+    private Set<Map.Entry<K, V>> entrySet;\n+    private Inverse inverse = null;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty TreeBidiMap.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public TreeBidiMap() {\n+        super();\n+        rootNode = new Node[2];\n+    }\n+\n+    /**\n+     * Constructs a new TreeBidiMap by copying an existing Map.\n+     *\n+     * @param map  the map to copy\n+     * @throws ClassCastException if the keys/values in the map are\n+     *  not Comparable or are not mutually comparable\n+     * @throws NullPointerException if any key or value in the map is null\n+     */\n+    public TreeBidiMap(final Map<K, V> map) {\n+        this();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of key-value mappings in this map.\n+     *\n+     * @return the number of key-value mappings in this map\n+     */\n+    public int size() {\n+        return nodeCount;\n+    }\n+\n+    /**\n+     * Checks whether the map is empty or not.\n+     *\n+     * @return true if the map is empty\n+     */\n+    public boolean isEmpty() {\n+        return nodeCount == 0;\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified key.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key  key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public boolean containsKey(final Object key) {\n+        checkKey(key);\n+        return lookupKey(key) != null;\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified value.\n+     * <p>\n+     * The value must implement <code>Comparable</code>.\n+     *\n+     * @param value  value whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified value\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public boolean containsValue(final Object value) {\n+        checkValue(value);\n+        return lookupValue(value) != null;\n+    }\n+\n+    /**\n+     * Gets the value to which this map maps the specified key.\n+     * Returns null if the map contains no mapping for this key.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key  key whose associated value is to be returned\n+     * @return the value to which this map maps the specified key,\n+     *  or null if the map contains no mapping for this key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public V get(final Object key) {\n+        checkKey(key);\n+        final Node<K, V> node = lookupKey(key);\n+        return node == null ? null : node.getValue();\n+    }\n+\n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     *\n+     *  BidiMap map2 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     * <p>\n+     * Both key and value must implement <code>Comparable</code>.\n+     *\n+     * @param key  key with which the specified value is to be  associated\n+     * @param value  value to be associated with the specified key\n+     * @return the previous value for the key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public V put(final K key, final V value) {\n+        final V result = get(key);\n+        doPut(key, value);\n+        return result;\n+    }\n+\n+    /**\n+     * Puts all the mappings from the specified map into this map.\n+     * <p>\n+     * All keys and values must implement <code>Comparable</code>.\n+     *\n+     * @param map  the map to copy from\n+     */\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> e : map.entrySet()) {\n+            put(e.getKey(), e.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the mapping for this key from this map if present.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key  key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key,\n+     *  or null if there was no mapping for key.\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public V remove(final Object key) {\n+        return doRemoveKey(key);\n+    }\n+\n+    /**\n+     * Removes all mappings from this map.\n+     */\n+    public void clear() {\n+        modify();\n+\n+        nodeCount = 0;\n+        rootNode[KEY.ordinal()] = null;\n+        rootNode[VALUE.ordinal()] = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the key to which this map maps the specified value.\n+     * Returns null if the map contains no mapping for this value.\n+     * <p>\n+     * The value must implement <code>Comparable</code>.\n+     *\n+     * @param value  value whose associated key is to be returned.\n+     * @return the key to which this map maps the specified value,\n+     *  or null if the map contains no mapping for this value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public K getKey(final Object value) {\n+        checkValue(value);\n+        final Node<K, V> node = lookupValue(value);\n+        return node == null ? null : node.getKey();\n+    }\n+\n+    /**\n+     * Removes the mapping for this value from this map if present.\n+     * <p>\n+     * The value must implement <code>Comparable</code>.\n+     *\n+     * @param value  value whose mapping is to be removed from the map\n+     * @return previous key associated with specified value,\n+     *  or null if there was no mapping for value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public K removeValue(final Object value) {\n+        return doRemoveValue(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first (lowest) key currently in this map.\n+     *\n+     * @return the first (lowest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K firstKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return leastNode(rootNode[KEY.ordinal()], KEY).getKey();\n+    }\n+\n+    /**\n+     * Gets the last (highest) key currently in this map.\n+     *\n+     * @return the last (highest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K lastKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return greatestNode(rootNode[KEY.ordinal()], KEY).getKey();\n+    }\n+\n+    /**\n+     * Gets the next key after the one specified.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public K nextKey(final K key) {\n+        checkKey(key);\n+        final Node<K, V> node = nextGreater(lookupKey(key), KEY);\n+        return node == null ? null : node.getKey();\n+    }\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     * <p>\n+     * The key must implement <code>Comparable</code>.\n+     *\n+     * @param key the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public K previousKey(final K key) {\n+        checkKey(key);\n+        final Node<K, V> node = nextSmaller(lookupKey(key), KEY);\n+        return node == null ? null : node.getKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the keys contained in this map in key order.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeyView(KEY);\n+        }\n+        return keySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the values contained in this map in key order.\n+     * The returned object can be cast to a Set.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Collection<V> values() {\n+        if (valuesSet == null) {\n+            valuesSet = new ValueView(KEY);\n+        }\n+        return valuesSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the entries contained in this map in key order.\n+     * For simple iteration through the map, the MapIterator is quicker.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     * The returned MapEntry objects do not support setValue.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntryView();\n+        }\n+        return entrySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        if (isEmpty()) {\n+            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n+        }\n+        return new ViewMapIterator(KEY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the inverse map for comparison.\n+     *\n+     * @return the inverse map\n+     */\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new Inverse();\n+        }\n+        return inverse;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return this.doEquals(obj, KEY);\n+    }\n+\n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @return the hash code value for this map\n+     */\n+    @Override\n+    public int hashCode() {\n+        return this.doHashCode(KEY);\n+    }\n+\n+    /**\n+     * Returns a string version of this Map in standard format.\n+     *\n+     * @return a standard format string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        return this.doToString(KEY);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Put logic.\n+     *\n+     * @param key  the key, always the main map key\n+     * @param value  the value, always the main map value\n+     */\n+    private void doPut(final K key, final V value) {\n+        checkKeyAndValue(key, value);\n+\n+        // store previous and remove previous mappings\n+        doRemoveKey(key);\n+        doRemoveValue(value);\n+\n+        Node<K, V> node = rootNode[KEY.ordinal()];\n+        if (node == null) {\n+            // map is empty\n+            final Node<K, V> root = new Node<K, V>(key, value);\n+            rootNode[KEY.ordinal()] = root;\n+            rootNode[VALUE.ordinal()] = root;\n+            grow();\n+\n+        } else {\n+            // add new mapping\n+            while (true) {\n+                final int cmp = compare(key, node.getKey());\n+\n+                if (cmp == 0) {\n+                    // shouldn't happen\n+                    throw new IllegalArgumentException(\"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\");\n+                } else if (cmp < 0) {\n+                    if (node.getLeft(KEY) != null) {\n+                        node = node.getLeft(KEY);\n+                    } else {\n+                        final Node<K, V> newNode = new Node<K, V>(key, value);\n+\n+                        insertValue(newNode);\n+                        node.setLeft(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+\n+                        break;\n+                    }\n+                } else { // cmp > 0\n+                    if (node.getRight(KEY) != null) {\n+                        node = node.getRight(KEY);\n+                    } else {\n+                        final Node<K, V> newNode = new Node<K, V>(key, value);\n+\n+                        insertValue(newNode);\n+                        node.setRight(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private V doRemoveKey(final Object key) {\n+        final Node<K, V> node = lookupKey(key);\n+        if (node == null) {\n+            return null;\n+        }\n+        doRedBlackDelete(node);\n+        return node.getValue();\n+    }\n+\n+    private K doRemoveValue(final Object value) {\n+        final Node<K, V> node = lookupValue(value);\n+        if (node == null) {\n+            return null;\n+        }\n+        doRedBlackDelete(node);\n+        return node.getKey();\n+    }\n+\n+    /**\n+     * do the actual lookup of a piece of data\n+     *\n+     * @param data the key or value to be looked up\n+     * @param index  the KEY or VALUE int\n+     * @return the desired Node, or null if there is no mapping of the\n+     *         specified data\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private <T extends Comparable<T>> Node<K, V> lookup(final Object data, final DataElement dataElement) {\n+        Node<K, V> rval = null;\n+        Node<K, V> node = rootNode[dataElement.ordinal()];\n+\n+        while (node != null) {\n+            final int cmp = compare((T) data, (T) node.getData(dataElement));\n+            if (cmp == 0) {\n+                rval = node;\n+                break;\n+            } else {\n+                node = cmp < 0 ? node.getLeft(dataElement) : node.getRight(dataElement);\n+            }\n+        }\n+\n+        return rval;\n+    }\n+\n+    private Node<K, V> lookupKey(final Object key) {\n+        return this.<K>lookup(key, KEY);\n+    }\n+\n+    private Node<K, V> lookupValue(final Object value) {\n+        return this.<V>lookup(value, VALUE);\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node<K, V> nextGreater(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getRight(dataElement) != null) {\n+            // everything to the node's right is larger. The least of\n+            // the right node's descendants is the next larger node\n+            rval = leastNode(node.getRight(dataElement), dataElement);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose left child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's left\n+            // ... and that ancestor is the next greatest node\n+            Node<K, V> parent = node.getParent(dataElement);\n+            Node<K, V> child = node;\n+\n+            while (parent != null && child == parent.getRight(dataElement)) {\n+                child = parent;\n+                parent = parent.getParent(dataElement);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node<K, V> nextSmaller(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getLeft(dataElement) != null) {\n+            // everything to the node's left is smaller. The greatest of\n+            // the left node's descendants is the next smaller node\n+            rval = greatestNode(node.getLeft(dataElement), dataElement);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose right child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's right\n+            // ... and that ancestor is the next greatest node\n+            Node<K, V> parent = node.getParent(dataElement);\n+            Node<K, V> child = node;\n+\n+            while (parent != null && child == parent.getLeft(dataElement)) {\n+                child = parent;\n+                parent = parent.getParent(dataElement);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Compare two objects\n+     *\n+     * @param o1  the first object\n+     * @param o2  the second object\n+     *\n+     * @return negative value if o1 &lt; o2; 0 if o1 == o2; positive\n+     *         value if o1 &gt; o2\n+     */\n+    private static <T extends Comparable<T>> int compare(final T o1, final T o2) {\n+        return o1.compareTo(o2);\n+    }\n+\n+    /**\n+     * Find the least node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the smallest node, from the specified node, in the\n+     *         specified mapping\n+     */\n+    private Node<K, V> leastNode(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = node;\n+        if (rval != null) {\n+            while (rval.getLeft(dataElement) != null) {\n+                rval = rval.getLeft(dataElement);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * Find the greatest node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the greatest node, from the specified node\n+     */\n+    private Node<K, V> greatestNode(final Node<K, V> node, final DataElement dataElement) {\n+        Node<K, V> rval = node;\n+        if (rval != null) {\n+            while (rval.getRight(dataElement) != null) {\n+                rval = rval.getRight(dataElement);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * copy the color from one node to another, dealing with the fact\n+     * that one or both nodes may, in fact, be null\n+     *\n+     * @param from the node whose color we're copying; may be null\n+     * @param to the node whose color we're changing; may be null\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void copyColor(final Node<K, V> from, final Node<K, V> to, final DataElement dataElement) {\n+        if (to != null) {\n+            if (from == null) {\n+                // by default, make it black\n+                to.setBlack(dataElement);\n+            } else {\n+                to.copyColor(from, dataElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * is the specified node red? if the node does not exist, no, it's\n+     * black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isRed(final Node<?, ?> node, final DataElement dataElement) {\n+        return node != null && node.isRed(dataElement);\n+    }\n+\n+    /**\n+     * is the specified black red? if the node does not exist, sure,\n+     * it's black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isBlack(final Node<?, ?> node, final DataElement dataElement) {\n+        return node == null || node.isBlack(dataElement);\n+    }\n+\n+    /**\n+     * force a node (if it exists) red\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeRed(final Node<?, ?> node, final DataElement dataElement) {\n+        if (node != null) {\n+            node.setRed(dataElement);\n+        }\n+    }\n+\n+    /**\n+     * force a node (if it exists) black\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeBlack(final Node<?, ?> node, final DataElement dataElement) {\n+        if (node != null) {\n+            node.setBlack(dataElement);\n+        }\n+    }\n+\n+    /**\n+     * get a node's grandparent. mind you, the node, its parent, or\n+     * its grandparent may not exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getGrandParent(final Node<K, V> node, final DataElement dataElement) {\n+        return getParent(getParent(node, dataElement), dataElement);\n+    }\n+\n+    /**\n+     * get a node's parent. mind you, the node, or its parent, may not\n+     * exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getParent(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getParent(dataElement);\n+    }\n+\n+    /**\n+     * get a node's right child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getRightChild(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getRight(dataElement);\n+    }\n+\n+    /**\n+     * get a node's left child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private Node<K, V> getLeftChild(final Node<K, V> node, final DataElement dataElement) {\n+        return node == null ? null : node.getLeft(dataElement);\n+    }\n+\n+    /**\n+     * do a rotate left. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateLeft(final Node<K, V> node, final DataElement dataElement) {\n+        final Node<K, V> rightChild = node.getRight(dataElement);\n+        node.setRight(rightChild.getLeft(dataElement), dataElement);\n+\n+        if (rightChild.getLeft(dataElement) != null) {\n+            rightChild.getLeft(dataElement).setParent(node, dataElement);\n+        }\n+        rightChild.setParent(node.getParent(dataElement), dataElement);\n+\n+        if (node.getParent(dataElement) == null) {\n+            // node was the root ... now its right child is the root\n+            rootNode[dataElement.ordinal()] = rightChild;\n+        } else if (node.getParent(dataElement).getLeft(dataElement) == node) {\n+            node.getParent(dataElement).setLeft(rightChild, dataElement);\n+        } else {\n+            node.getParent(dataElement).setRight(rightChild, dataElement);\n+        }\n+\n+        rightChild.setLeft(node, dataElement);\n+        node.setParent(rightChild, dataElement);\n+    }\n+\n+    /**\n+     * do a rotate right. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateRight(final Node<K, V> node, final DataElement dataElement) {\n+        final Node<K, V> leftChild = node.getLeft(dataElement);\n+        node.setLeft(leftChild.getRight(dataElement), dataElement);\n+        if (leftChild.getRight(dataElement) != null) {\n+            leftChild.getRight(dataElement).setParent(node, dataElement);\n+        }\n+        leftChild.setParent(node.getParent(dataElement), dataElement);\n+\n+        if (node.getParent(dataElement) == null) {\n+            // node was the root ... now its left child is the root\n+            rootNode[dataElement.ordinal()] = leftChild;\n+        } else if (node.getParent(dataElement).getRight(dataElement) == node) {\n+            node.getParent(dataElement).setRight(leftChild, dataElement);\n+        } else {\n+            node.getParent(dataElement).setLeft(leftChild, dataElement);\n+        }\n+\n+        leftChild.setRight(node, dataElement);\n+        node.setParent(leftChild, dataElement);\n+    }\n+\n+    /**\n+     * complicated red-black insert stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param insertedNode the node to be inserted\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void doRedBlackInsert(final Node<K, V> insertedNode, final DataElement dataElement) {\n+        Node<K, V> currentNode = insertedNode;\n+        makeRed(currentNode, dataElement);\n+\n+        while (currentNode != null\n+            && currentNode != rootNode[dataElement.ordinal()]\n+            && isRed(currentNode.getParent(dataElement), dataElement)) {\n+            if (currentNode.isLeftChild(dataElement)) {\n+                final Node<K, V> y = getRightChild(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(y, dataElement)) {\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(y, dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = getGrandParent(currentNode, dataElement);\n+                } else {\n+                    //dead code?\n+                    if (currentNode.isRightChild(dataElement)) {\n+                        currentNode = getParent(currentNode, dataElement);\n+\n+                        rotateLeft(currentNode, dataElement);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    if (getGrandParent(currentNode, dataElement) != null) {\n+                        rotateRight(getGrandParent(currentNode, dataElement), dataElement);\n+                    }\n+                }\n+            } else {\n+\n+                // just like clause above, except swap left for right\n+                final Node<K, V> y = getLeftChild(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(y, dataElement)) {\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(y, dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = getGrandParent(currentNode, dataElement);\n+                } else {\n+                    //dead code?\n+                    if (currentNode.isLeftChild(dataElement)) {\n+                        currentNode = getParent(currentNode, dataElement);\n+\n+                        rotateRight(currentNode, dataElement);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeRed(getGrandParent(currentNode, dataElement), dataElement);\n+\n+                    if (getGrandParent(currentNode, dataElement) != null) {\n+                        rotateLeft(getGrandParent(currentNode, dataElement), dataElement);\n+                    }\n+                }\n+            }\n+        }\n+\n+        makeBlack(rootNode[dataElement.ordinal()], dataElement);\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param deletedNode the node to be deleted\n+     */\n+    private void doRedBlackDelete(final Node<K, V> deletedNode) {\n+        for (final DataElement dataElement : DataElement.values()) {\n+            // if deleted node has both left and children, swap with\n+            // the next greater node\n+            if (deletedNode.getLeft(dataElement) != null && deletedNode.getRight(dataElement) != null) {\n+                swapPosition(nextGreater(deletedNode, dataElement), deletedNode, dataElement);\n+            }\n+\n+            final Node<K, V> replacement = deletedNode.getLeft(dataElement) != null ?\n+                    deletedNode.getLeft(dataElement) : deletedNode.getRight(dataElement);\n+\n+            if (replacement != null) {\n+                replacement.setParent(deletedNode.getParent(dataElement), dataElement);\n+\n+                if (deletedNode.getParent(dataElement) == null) {\n+                    rootNode[dataElement.ordinal()] = replacement;\n+                } else if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n+                    deletedNode.getParent(dataElement).setLeft(replacement, dataElement);\n+                } else {\n+                    deletedNode.getParent(dataElement).setRight(replacement, dataElement);\n+                }\n+\n+                deletedNode.setLeft(null, dataElement);\n+                deletedNode.setRight(null, dataElement);\n+                deletedNode.setParent(null, dataElement);\n+\n+                if (isBlack(deletedNode, dataElement)) {\n+                    doRedBlackDeleteFixup(replacement, dataElement);\n+                }\n+            } else {\n+\n+                // replacement is null\n+                if (deletedNode.getParent(dataElement) == null) {\n+\n+                    // empty tree\n+                    rootNode[dataElement.ordinal()] = null;\n+                } else {\n+\n+                    // deleted node had no children\n+                    if (isBlack(deletedNode, dataElement)) {\n+                        doRedBlackDeleteFixup(deletedNode, dataElement);\n+                    }\n+\n+                    if (deletedNode.getParent(dataElement) != null) {\n+                        if (deletedNode == deletedNode.getParent(dataElement).getLeft(dataElement)) {\n+                            deletedNode.getParent(dataElement).setLeft(null, dataElement);\n+                        } else {\n+                            deletedNode.getParent(dataElement).setRight(null, dataElement);\n+                        }\n+\n+                        deletedNode.setParent(null, dataElement);\n+                    }\n+                }\n+            }\n+        }\n+        shrink();\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more. This\n+     * rebalances the tree (somewhat, as red-black trees are not\n+     * perfectly balanced -- perfect balancing takes longer)\n+     *\n+     * @param replacementNode the node being replaced\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void doRedBlackDeleteFixup(final Node<K, V> replacementNode, final DataElement dataElement) {\n+        Node<K, V> currentNode = replacementNode;\n+\n+        while (currentNode != rootNode[dataElement.ordinal()] && isBlack(currentNode, dataElement)) {\n+            if (currentNode.isLeftChild(dataElement)) {\n+                Node<K, V> siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(siblingNode, dataElement)) {\n+                    makeBlack(siblingNode, dataElement);\n+                    makeRed(getParent(currentNode, dataElement), dataElement);\n+                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n+\n+                    siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+                }\n+\n+                if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)\n+                    && isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n+                    makeRed(siblingNode, dataElement);\n+\n+                    currentNode = getParent(currentNode, dataElement);\n+                } else {\n+                    if (isBlack(getRightChild(siblingNode, dataElement), dataElement)) {\n+                        makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n+                        makeRed(siblingNode, dataElement);\n+                        rotateRight(siblingNode, dataElement);\n+\n+                        siblingNode = getRightChild(getParent(currentNode, dataElement), dataElement);\n+                    }\n+\n+                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n+                    rotateLeft(getParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = rootNode[dataElement.ordinal()];\n+                }\n+            } else {\n+                Node<K, V> siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+\n+                if (isRed(siblingNode, dataElement)) {\n+                    makeBlack(siblingNode, dataElement);\n+                    makeRed(getParent(currentNode, dataElement), dataElement);\n+                    rotateRight(getParent(currentNode, dataElement), dataElement);\n+\n+                    siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+                }\n+\n+                if (isBlack(getRightChild(siblingNode, dataElement), dataElement)\n+                    && isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n+                    makeRed(siblingNode, dataElement);\n+\n+                    currentNode = getParent(currentNode, dataElement);\n+                } else {\n+                    if (isBlack(getLeftChild(siblingNode, dataElement), dataElement)) {\n+                        makeBlack(getRightChild(siblingNode, dataElement), dataElement);\n+                        makeRed(siblingNode, dataElement);\n+                        rotateLeft(siblingNode, dataElement);\n+\n+                        siblingNode = getLeftChild(getParent(currentNode, dataElement), dataElement);\n+                    }\n+\n+                    copyColor(getParent(currentNode, dataElement), siblingNode, dataElement);\n+                    makeBlack(getParent(currentNode, dataElement), dataElement);\n+                    makeBlack(getLeftChild(siblingNode, dataElement), dataElement);\n+                    rotateRight(getParent(currentNode, dataElement), dataElement);\n+\n+                    currentNode = rootNode[dataElement.ordinal()];\n+                }\n+            }\n+        }\n+\n+        makeBlack(currentNode, dataElement);\n+    }\n+\n+    /**\n+     * swap two nodes (except for their content), taking care of\n+     * special cases where one is the other's parent ... hey, it\n+     * happens.\n+     *\n+     * @param x one node\n+     * @param y another node\n+     * @param dataElement  the KEY or VALUE int\n+     */\n+    private void swapPosition(final Node<K, V> x, final Node<K, V> y, final DataElement dataElement) {\n+        // Save initial values.\n+        final Node<K, V> xFormerParent = x.getParent(dataElement);\n+        final Node<K, V> xFormerLeftChild = x.getLeft(dataElement);\n+        final Node<K, V> xFormerRightChild = x.getRight(dataElement);\n+        final Node<K, V> yFormerParent = y.getParent(dataElement);\n+        final Node<K, V> yFormerLeftChild = y.getLeft(dataElement);\n+        final Node<K, V> yFormerRightChild = y.getRight(dataElement);\n+        final boolean xWasLeftChild =\n+                x.getParent(dataElement) != null && x == x.getParent(dataElement).getLeft(dataElement);\n+        final boolean yWasLeftChild =\n+                y.getParent(dataElement) != null && y == y.getParent(dataElement).getLeft(dataElement);\n+\n+        // Swap, handling special cases of one being the other's parent.\n+        if (x == yFormerParent) { // x was y's parent\n+            x.setParent(y, dataElement);\n+\n+            if (yWasLeftChild) {\n+                y.setLeft(x, dataElement);\n+                y.setRight(xFormerRightChild, dataElement);\n+            } else {\n+                y.setRight(x, dataElement);\n+                y.setLeft(xFormerLeftChild, dataElement);\n+            }\n+        } else {\n+            x.setParent(yFormerParent, dataElement);\n+\n+            if (yFormerParent != null) {\n+                if (yWasLeftChild) {\n+                    yFormerParent.setLeft(x, dataElement);\n+                } else {\n+                    yFormerParent.setRight(x, dataElement);\n+                }\n+            }\n+\n+            y.setLeft(xFormerLeftChild, dataElement);\n+            y.setRight(xFormerRightChild, dataElement);\n+        }\n+\n+        if (y == xFormerParent) { // y was x's parent\n+            y.setParent(x, dataElement);\n+\n+            if (xWasLeftChild) {\n+                x.setLeft(y, dataElement);\n+                x.setRight(yFormerRightChild, dataElement);\n+            } else {\n+                x.setRight(y, dataElement);\n+                x.setLeft(yFormerLeftChild, dataElement);\n+            }\n+        } else {\n+            y.setParent(xFormerParent, dataElement);\n+\n+            if (xFormerParent != null) {\n+                if (xWasLeftChild) {\n+                    xFormerParent.setLeft(y, dataElement);\n+                } else {\n+                    xFormerParent.setRight(y, dataElement);\n+                }\n+            }\n+\n+            x.setLeft(yFormerLeftChild, dataElement);\n+            x.setRight(yFormerRightChild, dataElement);\n+        }\n+\n+        // Fix children's parent pointers\n+        if (x.getLeft(dataElement) != null) {\n+            x.getLeft(dataElement).setParent(x, dataElement);\n+        }\n+\n+        if (x.getRight(dataElement) != null) {\n+            x.getRight(dataElement).setParent(x, dataElement);\n+        }\n+\n+        if (y.getLeft(dataElement) != null) {\n+            y.getLeft(dataElement).setParent(y, dataElement);\n+        }\n+\n+        if (y.getRight(dataElement) != null) {\n+            y.getRight(dataElement).setParent(y, dataElement);\n+        }\n+\n+        x.swapColors(y, dataElement);\n+\n+        // Check if root changed\n+        if (rootNode[dataElement.ordinal()] == x) {\n+            rootNode[dataElement.ordinal()] = y;\n+        } else if (rootNode[dataElement.ordinal()] == y) {\n+            rootNode[dataElement.ordinal()] = x;\n+        }\n+    }\n+\n+    /**\n+     * check if an object is fit to be proper input ... has to be\n+     * Comparable and non-null\n+     *\n+     * @param o the object being checked\n+     * @param index  the KEY or VALUE int (used to put the right word in the\n+     *              exception message)\n+     *\n+     * @throws NullPointerException if o is null\n+     * @throws ClassCastException if o is not Comparable\n+     */\n+    private static void checkNonNullComparable(final Object o, final DataElement dataElement) {\n+        if (o == null) {\n+            throw new NullPointerException(dataElement + \" cannot be null\");\n+        }\n+        if (!(o instanceof Comparable)) {\n+            throw new ClassCastException(dataElement + \" must be Comparable\");\n+        }\n+    }\n+\n+    /**\n+     * check a key for validity (non-null and implements Comparable)\n+     *\n+     * @param key the key to be checked\n+     *\n+     * @throws NullPointerException if key is null\n+     * @throws ClassCastException if key is not Comparable\n+     */\n+    private static void checkKey(final Object key) {\n+        checkNonNullComparable(key, KEY);\n+    }\n+\n+    /**\n+     * check a value for validity (non-null and implements Comparable)\n+     *\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if value is null\n+     * @throws ClassCastException if value is not Comparable\n+     */\n+    private static void checkValue(final Object value) {\n+        checkNonNullComparable(value, VALUE);\n+    }\n+\n+    /**\n+     * check a key and a value for validity (non-null and implements\n+     * Comparable)\n+     *\n+     * @param key the key to be checked\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if key or value is null\n+     * @throws ClassCastException if key or value is not Comparable\n+     */\n+    private static void checkKeyAndValue(final Object key, final Object value) {\n+        checkKey(key);\n+        checkValue(value);\n+    }\n+\n+    /**\n+     * increment the modification count -- used to check for\n+     * concurrent modification of the map through the map and through\n+     * an Iterator from one of its Set or Collection views\n+     */\n+    private void modify() {\n+        modifications++;\n+    }\n+\n+    /**\n+     * bump up the size and note that the map has changed\n+     */\n+    private void grow() {\n+        modify();\n+        nodeCount++;\n+    }\n+\n+    /**\n+     * decrement the size and note that the map has changed\n+     */\n+    private void shrink() {\n+        modify();\n+        nodeCount--;\n+    }\n+\n+    /**\n+     * insert a node by its value\n+     *\n+     * @param newNode the node to be inserted\n+     *\n+     * @throws IllegalArgumentException if the node already exists\n+     *                                     in the value mapping\n+     */\n+    private void insertValue(final Node<K, V> newNode) throws IllegalArgumentException {\n+        Node<K, V> node = rootNode[VALUE.ordinal()];\n+\n+        while (true) {\n+            final int cmp = compare(newNode.getValue(), node.getValue());\n+\n+            if (cmp == 0) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot store a duplicate value (\\\"\" + newNode.getData(VALUE) + \"\\\") in this Map\");\n+            } else if (cmp < 0) {\n+                if (node.getLeft(VALUE) != null) {\n+                    node = node.getLeft(VALUE);\n+                } else {\n+                    node.setLeft(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            } else { // cmp > 0\n+                if (node.getRight(VALUE) != null) {\n+                    node = node.getRight(VALUE);\n+                } else {\n+                    node.setRight(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @param type  the KEY or VALUE int\n+     * @return true if equal\n+     */\n+    private boolean doEquals(final Object obj, final DataElement dataElement) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        final Map<?, ?> other = (Map<?, ?>) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+\n+        if (nodeCount > 0) {\n+            try {\n+                for (final MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n+                    final Object key = it.next();\n+                    final Object value = it.getValue();\n+                    if (value.equals(other.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            } catch (final ClassCastException ex) {\n+                return false;\n+            } catch (final NullPointerException ex) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @param type  the KEY or VALUE int\n+     * @return the hash code value for this map\n+     */\n+    private int doHashCode(final DataElement dataElement) {\n+        int total = 0;\n+        if (nodeCount > 0) {\n+            for (final MapIterator<?, ?> it = getMapIterator(dataElement); it.hasNext(); ) {\n+                final Object key = it.next();\n+                final Object value = it.getValue();\n+                total += key.hashCode() ^ value.hashCode();\n+            }\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the string form of this map as per AbstractMap.\n+     *\n+     * @param type  the KEY or VALUE int\n+     * @return the string form of this map\n+     */\n+    private String doToString(final DataElement dataElement) {\n+        if (nodeCount == 0) {\n+            return \"{}\";\n+        }\n+        final StringBuilder buf = new StringBuilder(nodeCount * 32);\n+        buf.append('{');\n+        final MapIterator<?, ?> it = getMapIterator(dataElement);\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            final Object key = it.next();\n+            final Object value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    private MapIterator<?, ?> getMapIterator(final DataElement dataElement) {\n+        switch (dataElement) {\n+        case KEY:\n+            return new ViewMapIterator(KEY);\n+        case VALUE:\n+            return new InverseViewMapIterator(VALUE);\n+        default:\n+            throw new IllegalArgumentException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A view of this map.\n+     */\n+    abstract class View<E> extends AbstractSet<E> {\n+\n+        /** Whether to return KEY or VALUE order. */\n+        protected final DataElement orderType;\n+\n+        /**\n+         * Constructor.\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param main  the main map\n+         */\n+        View(final DataElement orderType) {\n+            super();\n+            this.orderType = orderType;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return TreeBidiMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            TreeBidiMap.this.clear();\n+        }\n+    }\n+\n+    class KeyView extends View<K> {\n+\n+        /**\n+         * Create a new TreeBidiMap.KeyView.\n+         */\n+        public KeyView(final DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new ViewMapIterator(orderType);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, KEY);\n+            return lookupKey(obj) != null;\n+        }\n+\n+        @Override\n+        public boolean remove(final Object o) {\n+            return doRemoveKey(o) != null;\n+        }\n+\n+    }\n+\n+    class ValueView extends View<V> {\n+\n+        /**\n+         * Create a new TreeBidiMap.ValueView.\n+         */\n+        public ValueView(final DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new InverseViewMapIterator(orderType);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, VALUE);\n+            return lookupValue(obj) != null;\n+        }\n+\n+        @Override\n+        public boolean remove(final Object o) {\n+            return doRemoveValue(o) != null;\n+        }\n+\n+    }\n+\n+    /**\n+     * A view of this map.\n+     */\n+    class EntryView extends View<Map.Entry<K, V>> {\n+\n+        EntryView() {\n+            super(KEY);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupKey(entry.getKey());\n+            return node != null && node.getValue().equals(value);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupKey(entry.getKey());\n+            if (node != null && node.getValue().equals(value)) {\n+                doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<java.util.Map.Entry<K, V>> iterator() {\n+            return new ViewMapEntryIterator();\n+        }\n+    }\n+\n+    /**\n+     * A view of this map.\n+     */\n+    class InverseEntryView extends View<Map.Entry<V, K>> {\n+\n+        InverseEntryView() {\n+            super(VALUE);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupValue(entry.getKey());\n+            return node != null && node.getKey().equals(value);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object value = entry.getValue();\n+            final Node<K, V> node = lookupValue(entry.getKey());\n+            if (node != null && node.getKey().equals(value)) {\n+                doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Iterator<java.util.Map.Entry<V, K>> iterator() {\n+            return new InverseViewMapEntryIterator();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    abstract class ViewIterator {\n+\n+        /** Whether to return KEY or VALUE order. */\n+        protected final DataElement orderType;\n+        /** The last node returned by the iterator. */\n+        protected Node<K, V> lastReturnedNode;\n+        /** The next node to be returned by the iterator. */\n+        protected Node<K, V> nextNode;\n+        /** The previous node in the sequence returned by the iterator. */\n+        protected Node<K, V> previousNode;\n+        /** The modification count. */\n+        private int expectedModifications;\n+\n+        /**\n+         * Constructor.\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param main  the main map\n+         */\n+        ViewIterator(final DataElement orderType) {\n+            super();\n+            this.orderType = orderType;\n+            expectedModifications = modifications;\n+            nextNode = leastNode(rootNode[orderType.ordinal()], orderType);\n+            lastReturnedNode = null;\n+            previousNode = null;\n+        }\n+\n+        public final boolean hasNext() {\n+            return nextNode != null;\n+        }\n+\n+        protected Node<K, V> navigateNext() {\n+            if (nextNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            lastReturnedNode = nextNode;\n+            previousNode = nextNode;\n+            nextNode = nextGreater(nextNode, orderType);\n+            return lastReturnedNode;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return previousNode != null;\n+        }\n+\n+        protected Node<K, V> navigatePrevious() {\n+            if (previousNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            nextNode = lastReturnedNode;\n+            if (nextNode == null) {\n+                nextNode = nextGreater(previousNode, orderType);\n+            }\n+            lastReturnedNode = previousNode;\n+            previousNode = nextSmaller(previousNode, orderType);\n+            return lastReturnedNode;\n+        }\n+\n+        public final void remove() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException();\n+            }\n+            if (modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            doRedBlackDelete(lastReturnedNode);\n+            expectedModifications++;\n+            lastReturnedNode = null;\n+            if (nextNode == null) {\n+                previousNode = greatestNode(rootNode[orderType.ordinal()], orderType);\n+            } else {\n+                previousNode = nextSmaller(nextNode, orderType);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    class ViewMapIterator extends ViewIterator implements OrderedMapIterator<K, V> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        ViewMapIterator(final DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        public K getKey() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getValue();\n+        }\n+\n+        public V setValue(final V obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public K next() {\n+            return navigateNext().getKey();\n+        }\n+\n+        public K previous() {\n+            return navigatePrevious().getKey();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the map.\n+     */\n+    class InverseViewMapIterator extends ViewIterator implements OrderedMapIterator<V, K> {\n+\n+        /**\n+         * Create a new TreeBidiMap.InverseViewMapIterator.\n+         */\n+        public InverseViewMapIterator(final DataElement orderType) {\n+            super(orderType);\n+        }\n+\n+        public V getKey() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getKey() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getValue();\n+        }\n+\n+        public K getValue() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException(\n+                        \"Iterator getValue() can only be called after next() and before remove()\");\n+            }\n+            return lastReturnedNode.getKey();\n+        }\n+\n+        public K setValue(final K obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public V next() {\n+            return navigateNext().getValue();\n+        }\n+\n+        public V previous() {\n+            return navigatePrevious().getValue();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the map entries.\n+     */\n+    class ViewMapEntryIterator extends ViewIterator implements OrderedIterator<Map.Entry<K, V>> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        ViewMapEntryIterator() {\n+            super(KEY);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return navigateNext();\n+        }\n+\n+        public Map.Entry<K, V> previous() {\n+            return navigatePrevious();\n+        }\n+    }\n+\n+    /**\n+     * An iterator over the inverse map entries.\n+     */\n+    class InverseViewMapEntryIterator extends ViewIterator implements OrderedIterator<Map.Entry<V, K>> {\n+\n+        /**\n+         * Constructor.\n+         */\n+        InverseViewMapEntryIterator() {\n+            super(VALUE);\n+        }\n+\n+        public Map.Entry<V, K> next() {\n+            return createEntry(navigateNext());\n+        }\n+\n+        public Map.Entry<V, K> previous() {\n+            return createEntry(navigatePrevious());\n+        }\n+\n+        private Map.Entry<V, K> createEntry(final Node<K, V> node) {\n+            return new UnmodifiableMapEntry<V, K>(node.getValue(), node.getKey());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node used to store the data.\n+     */\n+    static class Node<K extends Comparable<K>, V extends Comparable<V>> implements Map.Entry<K, V>, KeyValue<K, V> {\n+\n+        private final K key;\n+        private final V value;\n+        private final Node<K, V>[] leftNode;\n+        private final Node<K, V>[] rightNode;\n+        private final Node<K, V>[] parentNode;\n+        private final boolean[] blackColor;\n+        private int hashcodeValue;\n+        private boolean calculatedHashCode;\n+\n+        /**\n+         * Make a new cell with given key and value, and with null\n+         * links, and black (true) colors.\n+         *\n+         * @param key\n+         * @param value\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        Node(final K key, final V value) {\n+            super();\n+            this.key = key;\n+            this.value = value;\n+            leftNode = new Node[2];\n+            rightNode = new Node[2];\n+            parentNode = new Node[2];\n+            blackColor = new boolean[] { true, true };\n+            calculatedHashCode = false;\n+        }\n+\n+        private Object getData(final DataElement dataElement) {\n+            switch (dataElement) {\n+            case KEY:\n+                return getKey();\n+            case VALUE:\n+                return getValue();\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private void setLeft(final Node<K, V> node, final DataElement dataElement) {\n+            leftNode[dataElement.ordinal()] = node;\n+        }\n+\n+        private Node<K, V> getLeft(final DataElement dataElement) {\n+            return leftNode[dataElement.ordinal()];\n+        }\n+\n+        private void setRight(final Node<K, V> node, final DataElement dataElement) {\n+            rightNode[dataElement.ordinal()] = node;\n+        }\n+\n+        private Node<K, V> getRight(final DataElement dataElement) {\n+            return rightNode[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Set this node's parent node.\n+         *\n+         * @param node  the new parent node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setParent(final Node<K, V> node, final DataElement dataElement) {\n+            parentNode[dataElement.ordinal()] = node;\n+        }\n+\n+        /**\n+         * Get the parent node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the parent node, may be null\n+         */\n+        private Node<K, V> getParent(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Exchange colors with another node.\n+         *\n+         * @param node  the node to swap with\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void swapColors(final Node<K, V> node, final DataElement dataElement) {\n+            // Swap colors -- old hacker's trick\n+            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n+            node.blackColor[dataElement.ordinal()] ^= blackColor[dataElement.ordinal()];\n+            blackColor[dataElement.ordinal()]      ^= node.blackColor[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Is this node black?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if black (which is represented as a true boolean)\n+         */\n+        private boolean isBlack(final DataElement dataElement) {\n+            return blackColor[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Is this node red?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if non-black\n+         */\n+        private boolean isRed(final DataElement dataElement) {\n+            return !blackColor[dataElement.ordinal()];\n+        }\n+\n+        /**\n+         * Make this node black.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setBlack(final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = true;\n+        }\n+\n+        /**\n+         * Make this node red.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setRed(final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = false;\n+        }\n+\n+        /**\n+         * Make this node the same color as another\n+         *\n+         * @param node  the node whose color we're adopting\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void copyColor(final Node<K, V> node, final DataElement dataElement) {\n+            blackColor[dataElement.ordinal()] = node.blackColor[dataElement.ordinal()];\n+        }\n+\n+        private boolean isLeftChild(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()] != null\n+                    && parentNode[dataElement.ordinal()].leftNode[dataElement.ordinal()] == this;\n+        }\n+\n+        private boolean isRightChild(final DataElement dataElement) {\n+            return parentNode[dataElement.ordinal()] != null\n+                    && parentNode[dataElement.ordinal()].rightNode[dataElement.ordinal()] == this;\n+        }\n+\n+        //-------------------------------------------------------------------\n+        /**\n+         * Gets the key.\n+         *\n+         * @return the key corresponding to this entry.\n+         */\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        /**\n+         * Gets the value.\n+         *\n+         * @return the value corresponding to this entry.\n+         */\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Optional operation that is not permitted in this implementation\n+         *\n+         * @param ignored\n+         * @return does not return\n+         * @throws UnsupportedOperationException always\n+         */\n+        public V setValue(final V ignored) throws UnsupportedOperationException {\n+            throw new UnsupportedOperationException(\"Map.Entry.setValue is not supported\");\n+        }\n+\n+        /**\n+         * Compares the specified object with this entry for equality.\n+         * Returns true if the given object is also a map entry and\n+         * the two entries represent the same mapping.\n+         *\n+         * @param obj  the object to be compared for equality with this entry.\n+         * @return true if the specified object is equal to this entry.\n+         */\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (!(obj instanceof Map.Entry)) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> e = (Map.Entry<?, ?>) obj;\n+            return getKey().equals(e.getKey()) && getValue().equals(e.getValue());\n+        }\n+\n+        /**\n+         * @return the hash code value for this map entry.\n+         */\n+        @Override\n+        public int hashCode() {\n+            if (!calculatedHashCode) {\n+                hashcodeValue = getKey().hashCode() ^ getValue().hashCode();\n+                calculatedHashCode = true;\n+            }\n+            return hashcodeValue;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The inverse map implementation.\n+     */\n+    class Inverse implements OrderedBidiMap<V, K> {\n+\n+        /** Store the keySet once created. */\n+        private Set<V> inverseKeySet;\n+        /** Store the valuesSet once created. */\n+        private Set<K> inverseValuesSet;\n+        /** Store the entrySet once created. */\n+        private Set<Map.Entry<V, K>> inverseEntrySet;\n+\n+        public int size() {\n+            return TreeBidiMap.this.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return TreeBidiMap.this.isEmpty();\n+        }\n+\n+        public K get(final Object key) {\n+            return TreeBidiMap.this.getKey(key);\n+        }\n+\n+        public V getKey(final Object value) {\n+            return TreeBidiMap.this.get(value);\n+        }\n+\n+        public boolean containsKey(final Object key) {\n+            return TreeBidiMap.this.containsValue(key);\n+        }\n+\n+        public boolean containsValue(final Object value) {\n+            return TreeBidiMap.this.containsKey(value);\n+        }\n+\n+        public V firstKey() {\n+            if (TreeBidiMap.this.nodeCount == 0) {\n+                throw new NoSuchElementException(\"Map is empty\");\n+            }\n+            return leastNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n+        }\n+\n+        public V lastKey() {\n+            if (TreeBidiMap.this.nodeCount == 0) {\n+                throw new NoSuchElementException(\"Map is empty\");\n+            }\n+            return greatestNode(TreeBidiMap.this.rootNode[VALUE.ordinal()], VALUE).getValue();\n+        }\n+\n+        public V nextKey(final V key) {\n+            checkKey(key);\n+            final Node<K, V> node = nextGreater(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            return node == null ? null : node.getValue();\n+        }\n+\n+        public V previousKey(final V key) {\n+            checkKey(key);\n+            final Node<K, V> node = TreeBidiMap.this.nextSmaller(TreeBidiMap.this.<V>lookup(key, VALUE), VALUE);\n+            return node == null ? null : node.getValue();\n+        }\n+\n+        public K put(final V key, final K value) {\n+            final K result = get(key);\n+            TreeBidiMap.this.doPut(value, key);\n+            return result;\n+        }\n+\n+        public void putAll(final Map<? extends V, ? extends K> map) {\n+            for (final Map.Entry<? extends V, ? extends K> e : map.entrySet()) {\n+                put(e.getKey(), e.getValue());\n+            }\n+        }\n+\n+        public K remove(final Object key) {\n+            return TreeBidiMap.this.removeValue(key);\n+        }\n+\n+        public V removeValue(final Object value) {\n+            return TreeBidiMap.this.remove(value);\n+        }\n+\n+        public void clear() {\n+            TreeBidiMap.this.clear();\n+        }\n+\n+        public Set<V> keySet() {\n+            if (inverseKeySet == null) {\n+                inverseKeySet = new ValueView(VALUE);\n+            }\n+            return inverseKeySet;\n+        }\n+\n+        public Collection<K> values() {\n+            if (inverseValuesSet == null) {\n+                inverseValuesSet = new KeyView(VALUE);\n+            }\n+            return inverseValuesSet;\n+        }\n+\n+        public Set<Map.Entry<V, K>> entrySet() {\n+            if (inverseEntrySet == null) {\n+                inverseEntrySet = new InverseEntryView();\n+            }\n+            return inverseEntrySet;\n+        }\n+\n+        public OrderedMapIterator<V, K> mapIterator() {\n+            if (isEmpty()) {\n+                return EmptyOrderedMapIterator.<V, K>emptyOrderedMapIterator();\n+            }\n+            return new InverseViewMapIterator(VALUE);\n+        }\n+\n+        public OrderedBidiMap<K, V> inverseBidiMap() {\n+            return TreeBidiMap.this;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return TreeBidiMap.this.doHashCode(DataElement.VALUE);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return TreeBidiMap.this.doToString(DataElement.VALUE);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+\n+/**\n+ * Decorates another {@link BidiMap} to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableBidiMap<K, V>\n+        extends AbstractBidiMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** The inverse unmodifiable map */\n+    private UnmodifiableBidiMap<V, K> inverse;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return an unmodifiable BidiMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableBidiMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableBidiMap(final BidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        final Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        final Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K removeValue(final Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        final MapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+    }\n+\n+    @Override\n+    public synchronized BidiMap<V, K> inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new UnmodifiableBidiMap<V, K>(decorated().inverseBidiMap());\n+            inverse.inverse = this;\n+        }\n+        return inverse;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+\n+/**\n+ * Decorates another {@link OrderedBidiMap} to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableOrderedBidiMap<K, V>\n+        extends AbstractOrderedBidiMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** The inverse unmodifiable map */\n+    private UnmodifiableOrderedBidiMap<V, K> inverse;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return an unmodifiable OrderedBidiMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableOrderedBidiMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        final Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        final Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K removeValue(final Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<V, K> inverseBidiMap() {\n+        return inverseOrderedBidiMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n+    }\n+\n+    /**\n+     * Gets an unmodifiable view of this map where the keys and values are reversed.\n+     *\n+     * @return an inverted unmodifiable bidirectional map\n+     */\n+    public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n+        if (inverse == null) {\n+            inverse = new UnmodifiableOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n+            inverse.inverse = this;\n+        }\n+        return inverse;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.SortedBidiMap;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections4.map.UnmodifiableSortedMap;\n+\n+/**\n+ * Decorates another {@link SortedBidiMap} to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an {@link UnsupportedOperationException}. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableSortedBidiMap<K, V>\n+        extends AbstractSortedBidiMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** The inverse unmodifiable map */\n+    private UnmodifiableSortedBidiMap<V, K> inverse;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return an unmodifiable SortedBidiMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableSortedBidiMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableSortedBidiMap(final SortedBidiMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        final Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        final Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K removeValue(final Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<V, K> inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new UnmodifiableSortedBidiMap<V, K>(decorated().inverseBidiMap());\n+            inverse.inverse = this;\n+        }\n+        return inverse;\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> sm = decorated().subMap(fromKey, toKey);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> sm = decorated().headMap(toKey);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> sm = decorated().tailMap(fromKey);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(sm);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link org.apache.commons.collections4.BidiMap BidiMap},\n+ * {@link org.apache.commons.collections4.OrderedBidiMap OrderedBidiMap} and \n+ * {@link org.apache.commons.collections4.SortedBidiMap SortedBidiMap} interfaces.\n+ * A BidiMap is an extension to Map that allows keys and values to be looked up with equal ease.\n+ * One example usage is a system communicating to a legacy datasource that must convert codes\n+ * from the new format to the old format and vice versa.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>DualHashBidiMap - uses two HashMaps to implement BidiMap\n+ *   <li>DualLinkedHashBidiMap - uses two LinkedHashMaps to implement BidiMap\n+ *   <li>DualTreeBidiMap - uses two TreeMaps to implement SortedBidiMap\n+ *   <li>TreeBidiMap - red-black tree implementation of OrderedBidiMap\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Unmodifiable - ensures the map cannot be altered\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.bidimap;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Decorates another <code>Collection</code> to provide additional behaviour.\n+ * <p>\n+ * Each method call made on this <code>Collection</code> is forwarded to the\n+ * decorated <code>Collection</code>. This class is used as a framework on which\n+ * to build to extensions such as synchronized and unmodifiable behaviour. The\n+ * main advantage of decoration is that one decorator can wrap any implementation\n+ * of <code>Collection</code>, whereas sub-classing requires a new class to be\n+ * written for each implementation.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #iterator()}. Instead it simply returns the value from the \n+ * wrapped collection. This may be undesirable, for example if you are trying\n+ * to write an unmodifiable implementation it might provide a loophole.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractCollectionDecorator<E>\n+        implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6249888059822088500L;\n+\n+    /** The collection being decorated */\n+    protected Collection<E> collection;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractCollectionDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractCollectionDecorator(final Collection<E> coll) {\n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.collection = coll;\n+    }\n+\n+    /**\n+     * Gets the collection being decorated.\n+     * All access to the decorated collection goes via this method.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<E> decorated() {\n+        return collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public boolean add(final E object) {\n+        return decorated().add(object);\n+    }\n+\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        return decorated().addAll(coll);\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean contains(final Object object) {\n+        return decorated().contains(object);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return decorated().iterator();\n+    }\n+\n+    public boolean remove(final Object object) {\n+        return decorated().remove(object);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Object[] toArray() {\n+        return decorated().toArray();\n+    }\n+\n+    public <T> T[] toArray(final T[] object) {\n+        return decorated().toArray(object);\n+    }\n+\n+    public boolean containsAll(final Collection<?> coll) {\n+        return decorated().containsAll(coll);\n+    }\n+\n+    public boolean removeAll(final Collection<?> coll) {\n+        return decorated().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(final Collection<?> coll) {\n+        return decorated().retainAll(coll);\n+    }\n+\n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/AbstractUntypedCollectionDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * Decorates another <code>Collection</code> to provide additional behaviour\n+ * without guaranteeing that the provided <code>Collection</code> type is the\n+ * same as that of the decorated <code>Collection</code>.\n+ * <p>\n+ * Each untyped method call made on this <code>Collection</code> is forwarded to the\n+ * decorated <code>Collection</code>. This class is used as a framework on which\n+ * to build to extensions such as synchronized and unmodifiable behaviour. The\n+ * main advantage of decoration is that one decorator can wrap any\n+ * implementation of <code>Collection</code>, whereas sub-classing requires a\n+ * new class to be written for each implementation.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #iterator()}. Instead it simply returns the value from the wrapped\n+ * collection. This may be undesirable, for example if you are trying to write\n+ * an unmodifiable implementation it might provide a loophole.\n+ *\n+ * @param <D> the type of the elements in the decorated collection\n+ * @param <E> the element type of the Collection implementation\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractUntypedCollectionDecorator<E, D> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8016691444524268856L;\n+\n+    /** The collection being decorated */\n+    protected Collection<D> collection;\n+\n+    /**\n+     * Create a new AbstractUntypedCollectionDecorator.\n+     */\n+    public AbstractUntypedCollectionDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the collection being decorated. All access to the decorated\n+     * collection goes via this method.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<D> decorated() {\n+        return collection;\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean contains(final Object object) {\n+        return decorated().contains(object);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public boolean remove(final Object object) {\n+        return decorated().remove(object);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Object[] toArray() {\n+        return decorated().toArray();\n+    }\n+\n+    public <T> T[] toArray(final T[] object) {\n+        return decorated().toArray(object);\n+    }\n+\n+    public boolean containsAll(final Collection<?> coll) {\n+        return decorated().containsAll(coll);\n+    }\n+\n+    public boolean removeAll(final Collection<?> coll) {\n+        return decorated().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(final Collection<?> coll) {\n+        return decorated().retainAll(coll);\n+    }\n+\n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/CompositeCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.IteratorChain;\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * Decorates a collection of other collections to provide a single unified view.\n+ * <p>\n+ * Changes made to this collection will actually be made on the decorated collection.\n+ * Add and remove operations require the use of a pluggable strategy. If no\n+ * strategy is provided then add and remove are unsupported.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CompositeCollection<E> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8417515734108306801L;\n+\n+    /** CollectionMutator to handle changes to the collection */\n+    protected CollectionMutator<E> mutator;\n+\n+    /** Collections in the composite */\n+    protected List<Collection<E>> all = new ArrayList<Collection<E>>();\n+\n+    /**\n+     * Create an empty CompositeCollection.\n+     */\n+    public CompositeCollection() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a Composite Collection with one collection.\n+     *\n+     * @param compositeCollection  the Collection to be appended to the composite\n+     */\n+    public CompositeCollection(final Collection<E> compositeCollection) {\n+        super();\n+        addComposited(compositeCollection);\n+    }\n+\n+    /**\n+     * Create a Composite Collection with two collections.\n+     *\n+     * @param compositeCollection1  the Collection to be appended to the composite\n+     * @param compositeCollection2  the Collection to be appended to the composite\n+     */\n+    public CompositeCollection(final Collection<E> compositeCollection1,\n+                               final Collection<E> compositeCollection2) {\n+        super();\n+        addComposited(compositeCollection1, compositeCollection2);\n+    }\n+\n+    /**\n+     * Create a Composite Collection with an array of collections.\n+     *\n+     * @param compositeCollections  the collections to composite\n+     */\n+    public CompositeCollection(final Collection<E>[] compositeCollections) {\n+        super();\n+        addComposited(compositeCollections);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of this composite collection.\n+     * <p>\n+     * This implementation calls <code>size()</code> on each collection.\n+     *\n+     * @return total number of elements in all contained containers\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (final Collection<E> item : all) {\n+            size += item.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether this composite collection is empty.\n+     * <p>\n+     * This implementation calls <code>isEmpty()</code> on each collection.\n+     *\n+     * @return true if all of the contained collections are empty\n+     */\n+    public boolean isEmpty() {\n+        for (final Collection<E> item : all) {\n+            if (item.isEmpty() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this composite collection contains the object.\n+     * <p>\n+     * This implementation calls <code>contains()</code> on each collection.\n+     *\n+     * @param obj  the object to search for\n+     * @return true if obj is contained in any of the contained collections\n+     */\n+    public boolean contains(final Object obj) {\n+        for (final Collection<E> item : all) {\n+            if (item.contains(obj)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets an iterator over all the collections in this composite.\n+     * <p>\n+     * This implementation uses an <code>IteratorChain</code>.\n+     *\n+     * @return an <code>IteratorChain</code> instance which supports\n+     *  <code>remove()</code>. Iteration occurs over contained collections in\n+     *  the order they were added, but this behavior should not be relied upon.\n+     * @see IteratorChain\n+     */\n+    public Iterator<E> iterator() {\n+        if (all.isEmpty()) {\n+            return EmptyIterator.<E>emptyIterator();\n+        }\n+        final IteratorChain<E> chain = new IteratorChain<E>();\n+        for (final Collection<E> item : all) {\n+            chain.addIterator(item.iterator());\n+        }\n+        return chain;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this composite.\n+     *\n+     * @return an object array of all the elements in the collection\n+     */\n+    public Object[] toArray() {\n+        final Object[] result = new Object[size()];\n+        int i = 0;\n+        for (final Iterator<E> it = iterator(); it.hasNext(); i++) {\n+            result[i] = it.next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an object array, populating the supplied array if possible.\n+     * See <code>Collection</code> interface for full details.\n+     *\n+     * @param <T>  the type of the elements in the collection\n+     * @param array  the array to use, populating if possible\n+     * @return an array of all the elements in the collection\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(final T[] array) {\n+        final int size = size();\n+        Object[] result = null;\n+        if (array.length >= size) {\n+            result = array;\n+        } else {\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n+        }\n+\n+        int offset = 0;\n+        for (final Collection<E> item : all) {\n+            for (final E e : item) {\n+                result[offset++] = e;\n+            }\n+        }\n+        if (result.length > size) {\n+            result[size] = null;\n+        }\n+        return (T[]) result;\n+    }\n+\n+    /**\n+     * Adds an object to the collection, throwing UnsupportedOperationException\n+     * unless a CollectionMutator strategy is specified.\n+     *\n+     * @param obj  the object to add\n+     * @return {@code true} if the collection was modified\n+     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n+     * @throws UnsupportedOperationException if add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean add(final E obj) {\n+        if (mutator == null) {\n+           throw new UnsupportedOperationException(\n+               \"add() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.add(this, all, obj);\n+    }\n+\n+    /**\n+     * Removes an object from the collection, throwing UnsupportedOperationException\n+     * unless a CollectionMutator strategy is specified.\n+     *\n+     * @param obj  the object being removed\n+     * @return true if the collection is changed\n+     * @throws UnsupportedOperationException if removed is unsupported\n+     * @throws ClassCastException if the object cannot be removed due to its type\n+     * @throws NullPointerException if the object cannot be removed because its null\n+     * @throws IllegalArgumentException if the object cannot be removed\n+     */\n+    public boolean remove(final Object obj) {\n+        if (mutator == null) {\n+            throw new UnsupportedOperationException(\n+                \"remove() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.remove(this, all, obj);\n+    }\n+\n+    /**\n+     * Checks whether this composite contains all the elements in the specified collection.\n+     * <p>\n+     * This implementation calls <code>contains()</code> for each element in the\n+     * specified collection.\n+     *\n+     * @param coll  the collection to check for\n+     * @return true if all elements contained\n+     */\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object item : coll) {\n+            if (contains(item) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Adds a collection of elements to this collection, throwing\n+     * UnsupportedOperationException unless a CollectionMutator strategy is specified.\n+     *\n+     * @param coll  the collection to add\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if CollectionMutator hasn't been set\n+     * @throws UnsupportedOperationException if add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        if (mutator == null) {\n+            throw new UnsupportedOperationException(\n+                \"addAll() is not supported on CompositeCollection without a CollectionMutator strategy\");\n+        }\n+        return mutator.addAll(this, all, coll);\n+    }\n+\n+    /**\n+     * Removes the elements in the specified collection from this composite collection.\n+     * <p>\n+     * This implementation calls <code>removeAll</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if removeAll is unsupported\n+     */\n+    public boolean removeAll(final Collection<?> coll) {\n+        if (coll.size() == 0) {\n+            return false;\n+        }\n+        boolean changed = false;\n+        for (final Collection<E> item : all) {\n+            changed |= item.removeAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Retains all the elements in the specified collection in this composite collection,\n+     * removing all others.\n+     * <p>\n+     * This implementation calls <code>retainAll()</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the collection was modified\n+     * @throws UnsupportedOperationException if retainAll is unsupported\n+     */\n+    public boolean retainAll(final Collection<?> coll) {\n+        boolean changed = false;\n+        for (final Collection<E> item : all) {\n+            changed |= item.retainAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Removes all of the elements from this collection .\n+     * <p>\n+     * This implementation calls <code>clear()</code> on each collection.\n+     *\n+     * @throws UnsupportedOperationException if clear is unsupported\n+     */\n+    public void clear() {\n+        for (final Collection<E> coll : all) {\n+            coll.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify a CollectionMutator strategy instance to handle changes.\n+     *\n+     * @param mutator  the mutator to use\n+     */\n+    public void setMutator(final CollectionMutator<E> mutator) {\n+        this.mutator = mutator;\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollection  the Collection to be appended to the composite\n+     */\n+    public void addComposited(final Collection<E> compositeCollection) {\n+        all.add(compositeCollection);\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollection1  the Collection to be appended to the composite\n+     * @param compositeCollection2  the Collection to be appended to the composite\n+     */\n+    public void addComposited(final Collection<E> compositeCollection1,\n+                              final Collection<E> compositeCollection2) {\n+        all.add(compositeCollection1);\n+        all.add(compositeCollection2);\n+    }\n+\n+    /**\n+     * Add these Collections to the list of collections in this composite\n+     *\n+     * @param compositeCollections  the Collections to be appended to the composite\n+     */\n+    public void addComposited(final Collection<E>[] compositeCollections) {\n+        all.addAll(Arrays.asList(compositeCollections));\n+    }\n+\n+    /**\n+     * Removes a collection from the those being decorated in this composite.\n+     *\n+     * @param coll  collection to be removed\n+     */\n+    public void removeComposited(final Collection<E> coll) {\n+        all.remove(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new collection containing all of the elements\n+     *\n+     * @return A new ArrayList containing all of the elements in this composite.\n+     *         The new collection is <i>not</i> backed by this composite.\n+     */\n+    public Collection<E> toCollection() {\n+        return new ArrayList<E>(this);\n+    }\n+\n+    /**\n+     * Gets the collections being decorated.\n+     *\n+     * @return Unmodifiable list of all collections in this composite.\n+     */\n+    public List<Collection<E>> getCollections() {\n+        return UnmodifiableList.unmodifiableList(all);\n+    }\n+\n+    /**\n+     * Get the collection mutator to be used for this CompositeCollection.\n+     * @return CollectionMutator<E>\n+     */\n+    protected CollectionMutator<E> getMutator() {\n+        return mutator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Pluggable strategy to handle changes to the composite.\n+     *\n+     * @param <E> the element being held in the collection\n+     */\n+    public interface CollectionMutator<E> extends Serializable {\n+\n+        /**\n+         * Called when an object is to be added to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param obj  the object being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean add(CompositeCollection<E> composite, List<Collection<E>> collections, E obj);\n+\n+        /**\n+         * Called when a collection is to be added to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param coll  the collection being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean addAll(CompositeCollection<E> composite,\n+                              List<Collection<E>> collections,\n+                              Collection<? extends E> coll);\n+\n+        /**\n+         * Called when an object is to be removed to the composite.\n+         *\n+         * @param composite  the CompositeCollection being changed\n+         * @param collections  all of the Collection instances in this CompositeCollection\n+         * @param obj  the object being removed\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if removed is unsupported\n+         * @throws ClassCastException if the object cannot be removed due to its type\n+         * @throws NullPointerException if the object cannot be removed because its null\n+         * @throws IllegalArgumentException if the object cannot be removed\n+         */\n+        public boolean remove(CompositeCollection<E> composite,\n+                              List<Collection<E>> collections,\n+                              Object obj);\n+\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/IndexedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections4.MultiMap;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.map.MultiValueMap;\n+\n+/**\n+ * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n+ * keyTransformer to define how the keys are converted from the values.\n+ * <p>\n+ * Modifications made to this decorator modify the index as well as the\n+ * decorated {@link Collection}. However, modifications to the underlying\n+ * {@link Collection} will not updated the index and it will get out of sync.\n+ * <p>\n+ * If modification to the decorated {@link Collection} is unavoidable, then a\n+ * call to {@link #reindex()} will update the index to the current contents of\n+ * the {@link Collection}.\n+ *\n+ * @param <K> the type of object in the index.\n+ * @param <C> the type of object in the collection.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5512610452568370038L;\n+\n+    /** The {@link Transformer} for generating index keys. */\n+    private final Transformer<C, K> keyTransformer;\n+\n+    /** The map of indexes to collected objects. */\n+    private final MultiMap<K, C> index;\n+    \n+    /** The uniqueness constraint for the index. */\n+    private final boolean uniqueIndex;\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a unique index.\n+     * <p>\n+     * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n+     * will be thrown.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll,\n+                                                                         final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer,\n+                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n+                                           true);\n+    }\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a non-unique index.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll,\n+                                                                            final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer,\n+                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n+                                           false);\n+    }\n+\n+    /**\n+     * Create a {@link IndexedCollection}.\n+     *\n+     * @param coll  decorated {@link Collection}\n+     * @param keyTransformer  {@link Transformer} for generating index keys\n+     * @param map  map to use as index\n+     * @param uniqueIndex  if the index shall enforce uniqueness of index keys\n+     */\n+    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer,\n+                             final MultiMap<K, C> map, final boolean uniqueIndex) {\n+        super(coll);\n+        this.keyTransformer = keyTransformer;\n+        this.index = map;\n+        this.uniqueIndex = uniqueIndex;\n+        reindex();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IllegalArgumentException if the object maps to an existing key and the index\n+     *   enforces a uniqueness constraint\n+     */\n+    @Override\n+    public boolean add(final C object) {\n+        final boolean added = super.add(object);\n+        if (added) {\n+            addToIndex(object);\n+        }\n+        return added;\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends C> coll) {\n+        boolean changed = false;\n+        for (final C c: coll) {\n+            changed |= add(c);\n+        }\n+        return changed;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        index.clear();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * Note: uses the index for fast lookup\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean contains(final Object object) {\n+        return index.containsKey(keyTransformer.transform((C) object));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * Note: uses the index for fast lookup\n+     */\n+    @Override\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object o : coll) {\n+            if (!contains(o)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the element associated with the given key.\n+     * <p>\n+     * In case of a non-unique index, this method will return the first\n+     * value associated with the given key. To retrieve all elements associated\n+     * with a key, use {@link #values(Object)}.\n+     *\n+     * @param key  key to look up\n+     * @return element found\n+     * @see #values(Object)\n+     */\n+    public C get(final K key) {\n+        @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n+        final Collection<C> coll = (Collection<C>) index.get(key);\n+        return coll == null ? null : coll.iterator().next();\n+    }\n+\n+    /**\n+     * Get all elements associated with the given key.\n+     *\n+     * @param key  key to look up\n+     * @return a collection of elements found, or null if {@code contains(key) == false}\n+     */\n+    @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n+    public Collection<C> values(final K key) {\n+        return (Collection<C>) index.get(key);\n+    }\n+\n+    /**\n+     * Clears the index and re-indexes the entire decorated {@link Collection}.\n+     */\n+    public void reindex() {\n+        index.clear();\n+        for (final C c : decorated()) {\n+            addToIndex(c);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean remove(final Object object) {\n+        final boolean removed = super.remove(object);\n+        if (removed) {\n+            removeFromIndex((C) object);\n+        }\n+        return removed;\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean changed = false;\n+        for (final Object o : coll) {\n+            changed |= remove(o);\n+        }\n+        return changed;\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        final boolean changed = super.retainAll(coll);\n+        if (changed) {\n+            reindex();\n+        }\n+        return changed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Provides checking for adding the index.\n+     *\n+     * @param object the object to index\n+     * @throws IllegalArgumentException if the object maps to an existing key and the index\n+     *   enforces a uniqueness constraint\n+     */\n+    private void addToIndex(final C object) {\n+        final K key = keyTransformer.transform(object);\n+        if (uniqueIndex && index.containsKey(key)) {\n+            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n+        }\n+        index.put(key, object);\n+    }\n+\n+    /**\n+     * Removes an object from the index.\n+     *\n+     * @param object the object to remove\n+     */\n+    private void removeFromIndex(final C object) {\n+        index.remove(keyTransformer.transform(object));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Decorates another {@link Collection} to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This collection exists to provide validation for the decorated collection.\n+ * It is normally created to decorate an empty collection.\n+ * If an object cannot be added to the collection, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the collection.\n+ * <pre>Collection coll = PredicatedCollection.decorate(new ArrayList(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedCollection<E> extends AbstractCollectionDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5259182142076705162L;\n+\n+    /** The predicate to use */\n+    protected final Predicate<? super E> predicate;\n+\n+    /**\n+     * Factory method to create a predicated (validating) collection.\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param <T> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated collection\n+     * @throws IllegalArgumentException if collection or predicate is null\n+     * @throws IllegalArgumentException if the collection contains invalid elements\n+     */\n+    public static <T> PredicatedCollection<T> predicatedCollection(final Collection<T> coll,\n+                                                                   final Predicate<? super T> predicate) {\n+        return new PredicatedCollection<T>(coll, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if collection or predicate is null\n+     * @throws IllegalArgumentException if the collection contains invalid elements\n+     */\n+    protected PredicatedCollection(final Collection<E> coll, final Predicate<? super E> predicate) {\n+        super(coll);\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        this.predicate = predicate;\n+        for (final E item : coll) {\n+            validate(item);\n+        }\n+    }\n+\n+    /**\n+     * Validates the object being added to ensure it matches the predicate.\n+     * <p>\n+     * The predicate itself should not throw an exception, but return false to\n+     * indicate that the object cannot be added.\n+     * \n+     * @param object  the object being added\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    protected void validate(final E object) {\n+        if (predicate.evaluate(object) == false) {\n+            throw new IllegalArgumentException(\"Cannot add Object '\" + object + \"' - Predicate '\" +\n+                                               predicate + \"' rejected it\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to validate the object being added to ensure it matches\n+     * the predicate.\n+     * \n+     * @param object  the object being added\n+     * @return the result of adding to the underlying collection\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    @Override\n+    public boolean add(final E object) {\n+        validate(object);\n+        return decorated().add(object);\n+    }\n+\n+    /**\n+     * Override to validate the objects being added to ensure they match\n+     * the predicate. If any one fails, no update is made to the underlying\n+     * collection.\n+     * \n+     * @param coll  the collection being added\n+     * @return the result of adding to the underlying collection\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        for (final E item : coll) {\n+            validate(item);\n+        }\n+        return decorated().addAll(coll);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * Decorates another {@link Collection} to synchronize its behaviour\n+ * for a multi-threaded environment.\n+ * <p>\n+ * Iterators must be manually synchronized:\n+ * <pre>\n+ * synchronized (coll) {\n+ *   Iterator it = coll.iterator();\n+ *   // do stuff with iterator\n+ * }\n+ * </pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SynchronizedCollection<E> implements Collection<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2412805092710877986L;\n+\n+    /** The collection to decorate */\n+    protected final Collection<E> collection;\n+    /** The object to lock on, needed for List/SortedSet views */\n+    protected final Object lock;\n+\n+    /**\n+     * Factory method to create a synchronized collection.\n+     * \n+     * @param <T> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @return a new synchronized collection\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    public static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n+        return new SynchronizedCollection<T>(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param collection  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected SynchronizedCollection(final Collection<E> collection) {\n+        if (collection == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.collection = collection;\n+        this.lock = this;\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param collection  the collection to decorate, must not be null\n+     * @param lock  the lock object to use, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected SynchronizedCollection(final Collection<E> collection, final Object lock) {\n+        if (collection == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.collection = collection;\n+        this.lock = lock;\n+    }\n+\n+    /**\n+     * Gets the collection being decorated.\n+     * \n+     * @return the decorated collection\n+     */\n+    protected Collection<E> decorated() {\n+        return collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public boolean add(final E object) {\n+        synchronized (lock) {\n+            return decorated().add(object);\n+        }\n+    }\n+\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        synchronized (lock) {\n+            return decorated().addAll(coll);\n+        }\n+    }\n+\n+    public void clear() {\n+        synchronized (lock) {\n+            decorated().clear();\n+        }\n+    }\n+\n+    public boolean contains(final Object object) {\n+        synchronized (lock) {\n+            return decorated().contains(object);\n+        }\n+    }\n+\n+    public boolean containsAll(final Collection<?> coll) {\n+        synchronized (lock) {\n+            return decorated().containsAll(coll);\n+        }\n+    }\n+\n+    public boolean isEmpty() {\n+        synchronized (lock) {\n+            return decorated().isEmpty();\n+        }\n+    }\n+\n+    /**\n+     * Iterators must be manually synchronized.\n+     * <pre>\n+     * synchronized (coll) {\n+     *   Iterator it = coll.iterator();\n+     *   // do stuff with iterator\n+     * }\n+     * \n+     * @return an iterator that must be manually synchronized on the collection\n+     */\n+    public Iterator<E> iterator() {\n+        return decorated().iterator();\n+    }\n+\n+    public Object[] toArray() {\n+        synchronized (lock) {\n+            return decorated().toArray();\n+        }\n+    }\n+\n+    public <T> T[] toArray(final T[] object) {\n+        synchronized (lock) {\n+            return decorated().toArray(object);\n+        }\n+    }\n+\n+    public boolean remove(final Object object) {\n+        synchronized (lock) {\n+            return decorated().remove(object);\n+        }\n+    }\n+\n+    public boolean removeAll(final Collection<?> coll) {\n+        synchronized (lock) {\n+            return decorated().removeAll(coll);\n+        }\n+    }\n+\n+    public boolean retainAll(final Collection<?> coll) {\n+        synchronized (lock) {\n+            return decorated().retainAll(coll);\n+        }\n+    }\n+\n+    public int size() {\n+        synchronized (lock) {\n+            return decorated().size();\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(final Object object) {\n+        synchronized (lock) {\n+            if (object == this) {\n+                return true;\n+            }\n+            return object == this || decorated().equals(object);\n+        }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        synchronized (lock) {\n+            return decorated().hashCode();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        synchronized (lock) {\n+            return decorated().toString();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another {@link Collection} to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedCollection<E> extends AbstractCollectionDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8692300188161871514L;\n+\n+    /** The transformer to use */\n+    protected final Transformer<? super E, ? extends E> transformer;\n+\n+    /**\n+     * Factory method to create a transforming collection.\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedCollection(Collection, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed collection\n+     * @throws IllegalArgumentException if collection or transformer is null\n+     */\n+    public static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedCollection<E>(coll, transformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming collection that will transform\n+     * existing contents of the specified collection.\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingCollection(Collection, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the collection\n+     * @param collection  the collection to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Collection\n+     * @throws IllegalArgumentException if collection or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection,\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n+        final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n+        // null collection & transformer are disallowed by the constructor call above \n+        if (collection.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // collection is of type E\n+            final E[] values = (E[]) collection.toArray();\n+            collection.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if collection or transformer is null\n+     */\n+    protected TransformedCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n+        super(coll);\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"Transformer must not be null\");\n+        }\n+        this.transformer = transformer;\n+    }\n+\n+    /**\n+     * Transforms an object.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     * \n+     * @param object  the object to transform\n+     * @return a transformed object\n+     */\n+    protected E transform(final E object) {\n+        return transformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a collection.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     * \n+     * @param coll  the collection to transform\n+     * @return a transformed object\n+     */\n+    protected Collection<E> transform(final Collection<? extends E> coll) {\n+        final List<E> list = new ArrayList<E>(coll.size());\n+        for (final E item : coll) {\n+            list.add(transform(item));\n+        }\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(final E object) {\n+        return decorated().add(transform(object));\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        return decorated().addAll(transform(coll));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.BoundedCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * {@link UnmodifiableBoundedCollection} decorates another\n+ * {@link BoundedCollection} to ensure it can't be altered.\n+ * <p>\n+ * If a BoundedCollection is first wrapped in some other collection decorator,\n+ * such as synchronized or predicated, the BoundedCollection methods are no\n+ * longer accessible.\n+ * The factory on this class will attempt to retrieve the bounded nature by\n+ * examining the package scope variables.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>\n+        implements BoundedCollection<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -7112672385450340330L;\n+\n+    /**\n+     * Factory method to create an unmodifiable bounded collection.\n+     *\n+     * @param <E> the type of the elements in the collection\n+     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n+     * @return a new unmodifiable bounded collection\n+     * @throws IllegalArgumentException if {@code coll} is {@code null}\n+     */\n+    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<E> coll) {\n+        return new UnmodifiableBoundedCollection<E>(coll);\n+    }\n+\n+    /**\n+     * Factory method to create an unmodifiable bounded collection.\n+     * <p>\n+     * This method is capable of drilling down through up to 1000 other decorators\n+     * to find a suitable BoundedCollection.\n+     *\n+     * @param <E> the type of the elements in the collection\n+     * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n+     * @return a new unmodifiable bounded collection\n+     * @throws IllegalArgumentException if {@code coll} is {@code null}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"The collection must not be null\");\n+        }\n+\n+        // handle decorators\n+        for (int i = 0; i < 1000; i++) {  // counter to prevent infinite looping\n+            if (coll instanceof BoundedCollection) {\n+                break;  // normal loop exit\n+            }\n+            if (coll instanceof AbstractCollectionDecorator) {\n+                coll = ((AbstractCollectionDecorator<E>) coll).collection;\n+            } else if (coll instanceof SynchronizedCollection) {\n+                coll = ((SynchronizedCollection<E>) coll).collection;\n+            }\n+        }\n+\n+        if (coll instanceof BoundedCollection == false) {\n+            throw new IllegalArgumentException(\"The collection is not a bounded collection\");\n+        }\n+        return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if coll is null\n+     */\n+    private UnmodifiableBoundedCollection(final BoundedCollection<E> coll) {\n+        super(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean isFull() {\n+        return decorated().isFull();\n+    }\n+\n+    public int maxSize() {\n+        return decorated().maxSize();\n+    }\n+\n+    @Override\n+    protected BoundedCollection<E> decorated() {\n+        return (BoundedCollection<E>) super.decorated();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another {@link Collection} to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @param <E> the type of the elements in the collection\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableCollection<E>\n+        extends AbstractCollectionDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -239892006883819945L;\n+\n+    /**\n+     * Factory method to create an unmodifiable collection.\n+     * <p>\n+     * If the collection passed in is already unmodifiable, it is returned.\n+     * \n+     * @param <T> the type of the elements in the collection\n+     * @param coll  the collection to decorate, must not be null\n+     * @return an unmodifiable collection\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    public static <T> Collection<T> unmodifiableCollection(final Collection<T> coll) {\n+        if (coll instanceof Unmodifiable) {\n+            return coll;\n+        }\n+        return new UnmodifiableCollection<T>(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param coll  the collection to decorate, must not be null\n+     * @throws IllegalArgumentException if collection is null\n+     */\n+    private UnmodifiableCollection(final Collection<E> coll) {\n+        super(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/collection/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link java.util.Collection Collection} interface.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>CompositeCollection - a collection that combines multiple collections into one\n+ * </ul>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms elements as they are added\n+ *   <li>Indexed - provides a map-like view onto another collection\n+ * </ul>\n+ * \n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.collection;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/BooleanComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * A {@link Comparator} for {@link Boolean} objects that can sort either\n+ * true or false first.\n+ * <p>\n+ * @see #getTrueFirstComparator()\n+ * @see #getFalseFirstComparator()\n+ * @see #booleanComparator(boolean)\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class BooleanComparator implements Comparator<Boolean>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 1830042991606340609L;\n+\n+    /** Constant \"true first\" reference. */\n+    private static final BooleanComparator TRUE_FIRST = new BooleanComparator(true);\n+\n+    /** Constant \"false first\" reference. */\n+    private static final BooleanComparator FALSE_FIRST = new BooleanComparator(false);\n+\n+    /** <code>true</code> iff <code>true</code> values sort before <code>false</code> values. */\n+    private boolean trueFirst = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a BooleanComparator instance that sorts \n+     * <code>true</code> values before <code>false</code> values.\n+     * <p />\n+     * Clients are encouraged to use the value returned from \n+     * this method instead of constructing a new instance \n+     * to reduce allocation and garbage collection overhead when\n+     * multiple BooleanComparators may be used in the same \n+     * virtual machine.\n+     * \n+     * @return the true first singleton BooleanComparator\n+     */\n+    public static BooleanComparator getTrueFirstComparator() {\n+        return TRUE_FIRST;\n+    }\n+    \n+    /**\n+     * Returns a BooleanComparator instance that sorts \n+     * <code>false</code> values before <code>true</code> values.\n+     * <p />\n+     * Clients are encouraged to use the value returned from \n+     * this method instead of constructing a new instance \n+     * to reduce allocation and garbage collection overhead when\n+     * multiple BooleanComparators may be used in the same \n+     * virtual machine.\n+     * \n+     * @return the false first singleton BooleanComparator\n+     */\n+    public static BooleanComparator getFalseFirstComparator() {\n+        return FALSE_FIRST;\n+    }\n+        \n+    /**\n+     * Returns a BooleanComparator instance that sorts \n+     * <code><i>trueFirst</i></code> values before \n+     * <code>&#x21;<i>trueFirst</i></code> values.\n+     * <p />\n+     * Clients are encouraged to use the value returned from \n+     * this method instead of constructing a new instance \n+     * to reduce allocation and garbage collection overhead when\n+     * multiple BooleanComparators may be used in the same \n+     * virtual machine.\n+     * \n+     * @param trueFirst when <code>true</code>, sort \n+     * <code>true</code> <code>Boolean</code>s before <code>false</code>\n+     * @return a singleton BooleanComparator instance\n+     */\n+    public static BooleanComparator booleanComparator(final boolean trueFirst) {\n+        return trueFirst ? TRUE_FIRST : FALSE_FIRST;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a <code>BooleanComparator</code> that sorts\n+     * <code>false</code> values before <code>true</code> values.\n+     * <p>\n+     * Equivalent to {@link #BooleanComparator(boolean) BooleanComparator(false)}.\n+     * <p>\n+     * Please use the static factory instead whenever possible.\n+     */\n+    public BooleanComparator() {\n+        this(false);\n+    }\n+\n+    /**\n+     * Creates a <code>BooleanComparator</code> that sorts\n+     * <code><i>trueFirst</i></code> values before \n+     * <code>&#x21;<i>trueFirst</i></code> values.\n+     * <p>\n+     * Please use the static factories instead whenever possible.\n+     * \n+     * @param trueFirst when <code>true</code>, sort \n+     *  <code>true</code> boolean values before <code>false</code>\n+     */\n+    public BooleanComparator(final boolean trueFirst) {\n+        this.trueFirst = trueFirst;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two non-<code>null</code> <code>Boolean</code> objects\n+     * according to the value of {@link #sortsTrueFirst()}.\n+     * \n+     * @param b1  the first boolean to compare\n+     * @param b2  the second boolean to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     * @throws NullPointerException when either argument <code>null</code>\n+     */\n+    public int compare(final Boolean b1, final Boolean b2) {\n+        final boolean v1 = b1.booleanValue();\n+        final boolean v2 = b2.booleanValue();\n+\n+        return (v1 ^ v2) ? ( (v1 ^ trueFirst) ? 1 : -1 ) : 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int hash = \"BooleanComparator\".hashCode();\n+        return trueFirst ? -1 * hash : hash;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>that</i></code> is a {@link BooleanComparator} \n+     * whose value of {@link #sortsTrueFirst()} is equal to mine.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        return (this == object) || \n+               ((object instanceof BooleanComparator) && \n+                (this.trueFirst == ((BooleanComparator)object).trueFirst));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns <code>true</code> iff\n+     * I sort <code>true</code> values before \n+     * <code>false</code> values.  In other words,\n+     * returns <code>true</code> iff\n+     * {@link #compare(Boolean,Boolean) compare(Boolean.FALSE,Boolean.TRUE)}\n+     * returns a positive value.\n+     * \n+     * @return the trueFirst flag\n+     */\n+    public boolean sortsTrueFirst() {\n+        return trueFirst;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ComparableComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/**\n+ * A {@link Comparator Comparator} that compares {@link Comparable Comparable}\n+ * objects.\n+ * <p>\n+ * This Comparator is useful, for example, for enforcing the natural order in\n+ * custom implementations of {@link java.util.SortedSet SortedSet} and {@link java.util.SortedMap SortedMap}.\n+ * <p>\n+ * Note: In the 2.0 and 2.1 releases of Commons Collections, this class would\n+ * throw a {@link ClassCastException} if either of the arguments to\n+ * {@link #compare(Object, Object) compare} were <code>null</code>, not\n+ * {@link Comparable Comparable}, or for which\n+ * {@link Comparable#compareTo(Object) compareTo} gave inconsistent results.\n+ * This is no longer the case. See {@link #compare(Object, Object) compare} for\n+ * details.\n+ * \n+ * @since 2.0\n+ * @version $Id$\n+ * \n+ * @see java.util.Collections#reverseOrder()\n+ */\n+public class ComparableComparator<E extends Comparable<? super E>> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID=-291439688585137865L;\n+\n+    /** The singleton instance. */\n+    @SuppressWarnings(\"rawtypes\")\n+    public static final ComparableComparator<?> INSTANCE = new ComparableComparator();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the singleton instance of a ComparableComparator.\n+     * <p>\n+     * Developers are encouraged to use the comparator returned from this method\n+     * instead of constructing a new instance to reduce allocation and GC overhead\n+     * when multiple comparable comparators may be used in the same VM.\n+     * \n+     * @param <E>  the element type\n+     * @return the singleton ComparableComparator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E extends Comparable<? super E>> ComparableComparator<E> comparableComparator() {\n+        return (ComparableComparator<E>) INSTANCE;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor whose use should be avoided.\n+     * <p>\n+     * Please use the {@link #comparableComparator()} method whenever possible.\n+     */\n+    public ComparableComparator() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compare the two {@link Comparable Comparable} arguments.\n+     * This method is equivalent to:\n+     * <pre>((Comparable)obj1).compareTo(obj2)</pre>\n+     * \n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     * @throws NullPointerException if <i>obj1</i> is <code>null</code>, \n+     *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n+     * @throws ClassCastException if <i>obj1</i> is not a <code>Comparable</code>,\n+     *         or when <code>((Comparable)obj1).compareTo(obj2)</code> does\n+     */\n+    public int compare(final E obj1, final E obj2) {\n+        return obj1.compareTo(obj2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     * @since 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        return \"ComparableComparator\".hashCode();\n+    }\n+\n+    /**\n+     * Returns {@code true} iff <i>that</i> Object is is a {@link Comparator Comparator}\n+     * whose ordering is known to be equivalent to mine.\n+     * <p>\n+     * This implementation returns {@code true} iff\n+     * <code><i>object</i>.{@link Object#getClass() getClass()}</code> equals\n+     * <code>this.getClass()</code>. Subclasses may want to override this behavior to remain\n+     * consistent with the {@link Comparator#equals(Object)} contract.\n+     * \n+     * @param object  the object to compare with\n+     * @return {@code true} if equal\n+     * @since 3.0\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        return this == object || \n+               null != object && object.getClass().equals(this.getClass());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ComparatorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * A ComparatorChain is a Comparator that wraps one or more Comparators in\n+ * sequence. The ComparatorChain calls each Comparator in sequence until either\n+ * 1) any single Comparator returns a non-zero result (and that result is then\n+ * returned), or 2) the ComparatorChain is exhausted (and zero is returned).\n+ * This type of sorting is very similar to multi-column sorting in SQL, and this\n+ * class allows Java classes to emulate that kind of behaviour when sorting a\n+ * List.\n+ * <p>\n+ * To further facilitate SQL-like sorting, the order of any single Comparator in\n+ * the list can be reversed.\n+ * <p>\n+ * Calling a method that adds new Comparators or changes the ascend/descend sort\n+ * <i>after compare(Object, Object) has been called</i> will result in an\n+ * UnsupportedOperationException. However, <i>take care</i> to not alter the\n+ * underlying List of Comparators or the BitSet that defines the sort order.\n+ * <p>\n+ * Instances of ComparatorChain are not synchronized. The class is not\n+ * thread-safe at construction time, but it <i>is</i> thread-safe to perform\n+ * multiple comparisons after all the setup operations are complete.\n+ * \n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class ComparatorChain<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version from Collections 2.0. */\n+    private static final long serialVersionUID = -721644942746081630L;\n+\n+    /** The list of comparators in the chain. */\n+    protected List<Comparator<E>> comparatorChain = null;\n+    /** Order - false (clear) = ascend; true (set) = descend. */\n+    protected BitSet orderingBits = null;\n+   /** Whether the chain has been \"locked\". */\n+    protected boolean isLocked = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Construct a ComparatorChain with no Comparators.\n+     * You must add at least one Comparator before calling\n+     * the compare(Object,Object) method, or an\n+     * UnsupportedOperationException is thrown\n+     */\n+    public ComparatorChain() {\n+        this(new ArrayList<Comparator<E>>(), new BitSet());\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain with a single Comparator,\n+     * sorting in the forward order\n+     *\n+     * @param comparator First comparator in the Comparator chain\n+     */\n+    public ComparatorChain(final Comparator<E> comparator) {\n+        this(comparator, false);\n+    }\n+\n+    /**\n+     * Construct a Comparator chain with a single Comparator,\n+     * sorting in the given order\n+     *\n+     * @param comparator First Comparator in the ComparatorChain\n+     * @param reverse    false = forward sort; true = reverse sort\n+     */\n+    public ComparatorChain(final Comparator<E> comparator, final boolean reverse) {\n+        comparatorChain = new ArrayList<Comparator<E>>(1);\n+        comparatorChain.add(comparator);\n+        orderingBits = new BitSet(1);\n+        if (reverse == true) {\n+            orderingBits.set(0);\n+        }\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain from the Comparators in the\n+     * List.  All Comparators will default to the forward\n+     * sort order.\n+     *\n+     * @param list   List of Comparators\n+     * @see #ComparatorChain(List,BitSet)\n+     */\n+    public ComparatorChain(final List<Comparator<E>> list) {\n+        this(list, new BitSet(list.size()));\n+    }\n+\n+    /**\n+     * Construct a ComparatorChain from the Comparators in the\n+     * given List.  The sort order of each column will be\n+     * drawn from the given BitSet.  When determining the sort\n+     * order for Comparator at index <i>i</i> in the List,\n+     * the ComparatorChain will call BitSet.get(<i>i</i>).\n+     * If that method returns <i>false</i>, the forward\n+     * sort order is used; a return value of <i>true</i>\n+     * indicates reverse sort order.\n+     *\n+     * @param list   List of Comparators.  NOTE: This constructor does not perform a\n+     *               defensive copy of the list\n+     * @param bits   Sort order for each Comparator.  Extra bits are ignored,\n+     *               unless extra Comparators are added by another method.\n+     */\n+    public ComparatorChain(final List<Comparator<E>> list, final BitSet bits) {\n+        comparatorChain = list;\n+        orderingBits = bits;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * forward sort order\n+     *\n+     * @param comparator Comparator with the forward sort order\n+     */\n+    public void addComparator(final Comparator<E> comparator) {\n+        addComparator(comparator, false);\n+    }\n+\n+    /**\n+     * Add a Comparator to the end of the chain using the\n+     * given sort order\n+     *\n+     * @param comparator Comparator to add to the end of the chain\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n+    public void addComparator(final Comparator<E> comparator, final boolean reverse) {\n+        checkLocked();\n+\n+        comparatorChain.add(comparator);\n+        if (reverse == true) {\n+            orderingBits.set(comparatorChain.size() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Replace the Comparator at the given index, maintaining\n+     * the existing sort order.\n+     *\n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to place at the given index\n+     * @exception IndexOutOfBoundsException\n+     *                   if index &lt; 0 or index &gt;= size()\n+     */\n+    public void setComparator(final int index, final Comparator<E> comparator) throws IndexOutOfBoundsException {\n+        setComparator(index, comparator, false);\n+    }\n+\n+    /**\n+     * Replace the Comparator at the given index in the\n+     * ComparatorChain, using the given sort order\n+     *\n+     * @param index      index of the Comparator to replace\n+     * @param comparator Comparator to set\n+     * @param reverse    false = forward sort order; true = reverse sort order\n+     */\n+    public void setComparator(final int index, final Comparator<E> comparator, final boolean reverse) {\n+        checkLocked();\n+\n+        comparatorChain.set(index,comparator);\n+        if (reverse == true) {\n+            orderingBits.set(index);\n+        } else {\n+            orderingBits.clear(index);\n+        }\n+    }\n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a forward sort.\n+     *\n+     * @param index  Index of the ComparatorChain\n+     */\n+    public void setForwardSort(final int index) {\n+        checkLocked();\n+        orderingBits.clear(index);\n+    }\n+\n+    /**\n+     * Change the sort order at the given index in the\n+     * ComparatorChain to a reverse sort.\n+     *\n+     * @param index  Index of the ComparatorChain\n+     */\n+    public void setReverseSort(final int index) {\n+        checkLocked();\n+        orderingBits.set(index);\n+    }\n+\n+    /**\n+     * Number of Comparators in the current ComparatorChain.\n+     *\n+     * @return Comparator count\n+     */\n+    public int size() {\n+        return comparatorChain.size();\n+    }\n+\n+    /**\n+     * Determine if modifications can still be made to the\n+     * ComparatorChain.  ComparatorChains cannot be modified\n+     * once they have performed a comparison.\n+     *\n+     * @return true = ComparatorChain cannot be modified; false =\n+     *         ComparatorChain can still be modified.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    /**\n+     * Throws an exception if the {@link ComparatorChain} is locked.\n+     * \n+     * @throws UnsupportedOperationException if the {@link ComparatorChain} is locked\n+     */\n+    private void checkLocked() {\n+        if (isLocked == true) {\n+            throw new UnsupportedOperationException(\n+                    \"Comparator ordering cannot be changed after the first comparison is performed\");\n+        }\n+    }\n+\n+    /**\n+     * Throws an exception if the {@link ComparatorChain} is empty.\n+     * \n+     * @throws UnsupportedOperationException if the {@link ComparatorChain} is empty\n+     */\n+    private void checkChainIntegrity() {\n+        if (comparatorChain.size() == 0) {\n+            throw new UnsupportedOperationException(\"ComparatorChains must contain at least one Comparator\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Perform comparisons on the Objects as per\n+     * Comparator.compare(o1,o2).\n+     *\n+     * @param o1  the first object to compare\n+     * @param o2  the second object to compare\n+     * @return -1, 0, or 1\n+     * @throws UnsupportedOperationException if the ComparatorChain does not contain at least one Comparator\n+     */\n+    public int compare(final E o1, final E o2) throws UnsupportedOperationException {\n+        if (isLocked == false) {\n+            checkChainIntegrity();\n+            isLocked = true;\n+        }\n+\n+        // iterate over all comparators in the chain\n+        final Iterator<Comparator<E>> comparators = comparatorChain.iterator();\n+        for (int comparatorIndex = 0; comparators.hasNext(); ++comparatorIndex) {\n+\n+            final Comparator<E> comparator = comparators.next();\n+            int retval = comparator.compare(o1,o2);\n+            if (retval != 0) {\n+                // invert the order if it is a reverse sort\n+                if (orderingBits.get(comparatorIndex) == true) {\n+                    if (Integer.MIN_VALUE == retval) {\n+                        retval = Integer.MAX_VALUE;\n+                    } else {\n+                        retval *= -1;\n+                    }\n+                }\n+                return retval;\n+            }\n+        }\n+\n+        // if comparators are exhausted, return 0\n+        return 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a suitable hash code\n+     * @since 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        if (null != comparatorChain) {\n+            hash ^= comparatorChain.hashCode();\n+        }\n+        if (null != orderingBits) {\n+            hash ^= orderingBits.hashCode();\n+        }\n+        return hash;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is\n+     * is a {@link Comparator} whose ordering is known to be\n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n+     * equals <code>this.getClass()</code>, and the underlying\n+     * comparators and order bits are equal.\n+     * Subclasses may want to override this behavior to remain consistent\n+     * with the {@link Comparator#equals(Object)} contract.\n+     *\n+     * @param object  the object to compare with\n+     * @return true if equal\n+     * @since 3.0\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            final ComparatorChain<?> chain = (ComparatorChain<?>) object;\n+            return (null == orderingBits ? null == chain.orderingBits : orderingBits.equals(chain.orderingBits)) &&\n+                   (null == comparatorChain ? null == chain.comparatorChain :\n+                                              comparatorChain.equals(chain.comparatorChain));\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A Comparator which imposes a specific order on a specific set of Objects.\n+ * Objects are presented to the FixedOrderComparator in a specified order and\n+ * subsequent calls to {@link #compare(Object, Object) compare} yield that order.\n+ * For example:\n+ * <pre>\n+ * String[] planets = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"};\n+ * FixedOrderComparator distanceFromSun = new FixedOrderComparator(planets);\n+ * Arrays.sort(planets);                     // Sort to alphabetical order\n+ * Arrays.sort(planets, distanceFromSun);    // Back to original order\n+ * </pre>\n+ * <p>\n+ * Once <code>compare</code> has been called, the FixedOrderComparator is locked\n+ * and attempts to modify it yield an UnsupportedOperationException.\n+ * <p>\n+ * Instances of FixedOrderComparator are not synchronized.  The class is not\n+ * thread-safe at construction time, but it is thread-safe to perform\n+ * multiple comparisons  after all the setup operations are complete.\n+ * <p>\n+ * This class is Serializable from Commons Collections 4.0.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedOrderComparator<T> implements Comparator<T>, Serializable {\n+\n+    /** Serialization version from Collections 4.0. */\n+    private static final long serialVersionUID = 82794675842863201L;\n+\n+    /**\n+     * Unknown object behavior enum.\n+     * @since 4.0\n+     */\n+    public static enum UnknownObjectBehavior {\n+        BEFORE, AFTER, EXCEPTION;\n+    }\n+\n+    /** Internal map of object to position */\n+    private final Map<T, Integer> map = new HashMap<T, Integer>();\n+\n+    /** Counter used in determining the position in the map */\n+    private int counter = 0;\n+\n+    /** Is the comparator locked against further change */\n+    private boolean isLocked = false;\n+\n+    /** The behaviour in the case of an unknown object */\n+    private UnknownObjectBehavior unknownObjectBehavior = UnknownObjectBehavior.EXCEPTION;\n+\n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an empty FixedOrderComparator.\n+     */\n+    public FixedOrderComparator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a FixedOrderComparator which uses the order of the given array\n+     * to compare the objects.\n+     * <p>\n+     * The array is copied, so later changes will not affect the comparator.\n+     *\n+     * @param items  the items that the comparator can compare in order\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public FixedOrderComparator(final T[] items) {\n+        super();\n+        if (items == null) {\n+            throw new IllegalArgumentException(\"The list of items must not be null\");\n+        }\n+        for (final T item : items) {\n+            add(item);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a FixedOrderComparator which uses the order of the given list\n+     * to compare the objects.\n+     * <p>\n+     * The list is copied, so later changes will not affect the comparator.\n+     *\n+     * @param items  the items that the comparator can compare in order\n+     * @throws IllegalArgumentException if the list is null\n+     */\n+    public FixedOrderComparator(final List<T> items) {\n+        super();\n+        if (items == null) {\n+            throw new IllegalArgumentException(\"The list of items must not be null\");\n+        }\n+        for (final T t : items) {\n+            add(t);\n+        }\n+    }\n+\n+    // Bean methods / state querying methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if modifications cannot be made to the FixedOrderComparator.\n+     * FixedOrderComparators cannot be modified once they have performed a comparison.\n+     *\n+     * @return true if attempts to change the FixedOrderComparator yield an\n+     *  UnsupportedOperationException, false if it can be changed.\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    /**\n+     * Checks to see whether the comparator is now locked against further changes.\n+     *\n+     * @throws UnsupportedOperationException if the comparator is locked\n+     */\n+    protected void checkLocked() {\n+        if (isLocked()) {\n+            throw new UnsupportedOperationException(\"Cannot modify a FixedOrderComparator after a comparison\");\n+        }\n+    }\n+\n+    /**\n+     * Gets the behavior for comparing unknown objects.\n+     *\n+     * @return {@link UnknownObjectBehavior}\n+     */\n+    public UnknownObjectBehavior getUnknownObjectBehavior() {\n+        return unknownObjectBehavior;\n+    }\n+\n+    /**\n+     * Sets the behavior for comparing unknown objects.\n+     *\n+     * @param unknownObjectBehavior  the flag for unknown behaviour -\n+     * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n+     * @throws UnsupportedOperationException if a comparison has been performed\n+     * @throws IllegalArgumentException if the unknown flag is not valid\n+     */\n+    public void setUnknownObjectBehavior(final UnknownObjectBehavior unknownObjectBehavior) {\n+        checkLocked();\n+        if (unknownObjectBehavior == null) {\n+            throw new IllegalArgumentException(\"Unknown object behavior must not be null\");\n+        }\n+        this.unknownObjectBehavior = unknownObjectBehavior;\n+    }\n+\n+    // Methods for adding items\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds an item, which compares as after all items known to the Comparator.\n+     * If the item is already known to the Comparator, its old position is\n+     * replaced with the new position.\n+     *\n+     * @param obj  the item to be added to the Comparator.\n+     * @return true if obj has been added for the first time, false if\n+     *  it was already known to the Comparator.\n+     * @throws UnsupportedOperationException if a comparison has already been made\n+     */\n+    public boolean add(final T obj) {\n+        checkLocked();\n+        final Integer position = map.put(obj, Integer.valueOf(counter++));\n+        return position == null;\n+    }\n+\n+    /**\n+     * Adds a new item, which compares as equal to the given existing item.\n+     *\n+     * @param existingObj  an item already in the Comparator's set of\n+     *  known objects\n+     * @param newObj  an item to be added to the Comparator's set of\n+     *  known objects\n+     * @return true if newObj has been added for the first time, false if\n+     *  it was already known to the Comparator.\n+     * @throws IllegalArgumentException if existingObject is not in the\n+     *  Comparator's set of known objects.\n+     * @throws UnsupportedOperationException if a comparison has already been made\n+     */\n+    public boolean addAsEqual(final T existingObj, final T newObj) {\n+        checkLocked();\n+        final Integer position = map.get(existingObj);\n+        if (position == null) {\n+            throw new IllegalArgumentException(existingObj + \" not known to \" + this);\n+        }\n+        final Integer result = map.put(newObj, position);\n+        return result == null;\n+    }\n+\n+    // Comparator methods\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two objects according to the order of this Comparator.\n+     * <p>\n+     * It is important to note that this class will throw an IllegalArgumentException\n+     * in the case of an unrecognised object. This is not specified in the\n+     * Comparator interface, but is the most appropriate exception.\n+     *\n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     * @throws IllegalArgumentException if obj1 or obj2 are not known\n+     *  to this Comparator and an alternative behavior has not been set\n+     *  via {@link #setUnknownObjectBehavior(UnknownObjectBehavior)}.\n+     */\n+    public int compare(final T obj1, final T obj2) {\n+        isLocked = true;\n+        final Integer position1 = map.get(obj1);\n+        final Integer position2 = map.get(obj2);\n+        if (position1 == null || position2 == null) {\n+            switch (unknownObjectBehavior) {\n+            case BEFORE:\n+                return position1 == null ? position2 == null ? 0 : -1 : 1;\n+            case AFTER:\n+                return position1 == null ? position2 == null ? 0 : 1 : -1;\n+            case EXCEPTION:\n+                final Object unknownObj = position1 == null ? obj1 : obj2;\n+                throw new IllegalArgumentException(\"Attempting to compare unknown object \"\n+                        + unknownObj);\n+            default: //could be null\n+                throw new UnsupportedOperationException(\"Unknown unknownObjectBehavior: \"\n+                        + unknownObjectBehavior);\n+            }\n+        }\n+        return position1.compareTo(position2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 17;\n+        total = total*37 + (map == null ? 0 : map.hashCode());\n+        total = total*37 + (unknownObjectBehavior == null ? 0 : unknownObjectBehavior.hashCode());\n+        total = total*37 + counter;\n+        total = total*37 + (isLocked ? 0 : 1);\n+        return total;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>that</i></code> is a {@link FixedOrderComparator} \n+     * whose attributes are equal to mine.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            final FixedOrderComparator<?> comp = (FixedOrderComparator<?>) object;\n+            return null == map ? null == comp.map : map.equals(comp.map) &&\n+                    null == unknownObjectBehavior ? null == comp.unknownObjectBehavior :\n+                        unknownObjectBehavior == comp.unknownObjectBehavior &&\n+                    counter == comp.counter &&\n+                    isLocked == comp.isLocked &&\n+                    unknownObjectBehavior == comp.unknownObjectBehavior;\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/NullComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.ComparatorUtils;\n+\n+/**\n+ * A Comparator that will compare nulls to be either lower or higher than\n+ * other objects.\n+ *\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class NullComparator<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -5820772575483504339L;\n+\n+    /**\n+     *  The comparator to use when comparing two non-<code>null</code> objects.\n+     **/\n+    private final Comparator<E> nonNullComparator;\n+\n+    /**\n+     *  Specifies whether a <code>null</code> are compared as higher than\n+     *  non-<code>null</code> objects.\n+     **/\n+    private final boolean nullsAreHigh;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher than any\n+     *  non-<code>null</code> object it is compared with. When comparing two\n+     *  non-<code>null</code> objects, the {@link ComparableComparator} is\n+     *  used.\n+     **/\n+    @SuppressWarnings(\"unchecked\")\n+    public NullComparator() {\n+        this(ComparatorUtils.NATURAL_COMPARATOR, true);\n+    }\n+\n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher than any\n+     *  non-<code>null</code> object it is compared with.  When comparing two\n+     *  non-<code>null</code> objects, the specified {@link Comparator} is\n+     *  used.\n+     *\n+     *  @param nonNullComparator the comparator to use when comparing two\n+     *  non-<code>null</code> objects.  This argument cannot be\n+     *  <code>null</code>\n+     *\n+     *  @exception NullPointerException if <code>nonNullComparator</code> is\n+     *  <code>null</code>\n+     **/\n+    public NullComparator(final Comparator<E> nonNullComparator) {\n+        this(nonNullComparator, true);\n+    }\n+\n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher or lower than\n+     *  any non-<code>null</code> object it is compared with.  When comparing\n+     *  two non-<code>null</code> objects, the {@link ComparableComparator} is\n+     *  used.\n+     *\n+     *  @param nullsAreHigh a <code>true</code> value indicates that\n+     *  <code>null</code> should be compared as higher than a\n+     *  non-<code>null</code> object.  A <code>false</code> value indicates\n+     *  that <code>null</code> should be compared as lower than a\n+     *  non-<code>null</code> object.\n+     **/\n+    @SuppressWarnings(\"unchecked\")\n+    public NullComparator(final boolean nullsAreHigh) {\n+        this(ComparatorUtils.NATURAL_COMPARATOR, nullsAreHigh);\n+    }\n+    \n+    /**\n+     *  Construct an instance that sorts <code>null</code> higher or lower than\n+     *  any non-<code>null</code> object it is compared with.  When comparing\n+     *  two non-<code>null</code> objects, the specified {@link Comparator} is\n+     *  used.\n+     *\n+     *  @param nonNullComparator the comparator to use when comparing two\n+     *  non-<code>null</code> objects. This argument cannot be\n+     *  <code>null</code>\n+     *\n+     *  @param nullsAreHigh a <code>true</code> value indicates that\n+     *  <code>null</code> should be compared as higher than a\n+     *  non-<code>null</code> object.  A <code>false</code> value indicates\n+     *  that <code>null</code> should be compared as lower than a\n+     *  non-<code>null</code> object.\n+     *\n+     *  @exception NullPointerException if <code>nonNullComparator</code> is\n+     *  <code>null</code>\n+     **/\n+    public NullComparator(final Comparator<E> nonNullComparator, final boolean nullsAreHigh) {\n+        this.nonNullComparator = nonNullComparator;\n+        this.nullsAreHigh = nullsAreHigh;\n+        \n+        if (nonNullComparator == null) {\n+            throw new NullPointerException(\"null nonNullComparator\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Perform a comparison between two objects.  If both objects are\n+     *  <code>null</code>, a <code>0</code> value is returned.  If one object\n+     *  is <code>null</code> and the other is not, the result is determined on\n+     *  whether the Comparator was constructed to have nulls as higher or lower\n+     *  than other objects.  If neither object is <code>null</code>, an\n+     *  underlying comparator specified in the constructor (or the default) is\n+     *  used to compare the non-<code>null</code> objects.\n+     *\n+     *  @param o1  the first object to compare\n+     *  @param o2  the object to compare it to.\n+     *  @return <code>-1</code> if <code>o1</code> is \"lower\" than (less than,\n+     *  before, etc.) <code>o2</code>; <code>1</code> if <code>o1</code> is\n+     *  \"higher\" than (greater than, after, etc.) <code>o2</code>; or\n+     *  <code>0</code> if <code>o1</code> and <code>o2</code> are equal.\n+     **/\n+    public int compare(final E o1, final E o2) {\n+        if(o1 == o2) { return 0; }\n+        if(o1 == null) { return this.nullsAreHigh ? 1 : -1; }\n+        if(o2 == null) { return this.nullsAreHigh ? -1 : 1; }\n+        return this.nonNullComparator.compare(o1, o2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Implement a hash code for this comparator that is consistent with\n+     *  {@link #equals(Object)}.\n+     *\n+     *  @return a hash code for this comparator.\n+     **/\n+    @Override\n+    public int hashCode() {\n+        return (nullsAreHigh ? -1 : 1) * nonNullComparator.hashCode();\n+    }\n+\n+    /**\n+     *  Determines whether the specified object represents a comparator that is\n+     *  equal to this comparator.\n+     *\n+     *  @param obj  the object to compare this comparator with.\n+     *\n+     *  @return <code>true</code> if the specified object is a NullComparator\n+     *  with equivalent <code>null</code> comparison behavior\n+     *  (i.e. <code>null</code> high or low) and with equivalent underlying\n+     *  non-<code>null</code> object comparators.\n+     **/\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if(obj == null) { return false; }\n+        if(obj == this) { return true; }\n+        if(!obj.getClass().equals(this.getClass())) { return false; }\n+\n+        final NullComparator<?> other = (NullComparator<?>) obj;\n+\n+        return this.nullsAreHigh == other.nullsAreHigh &&\n+                this.nonNullComparator.equals(other.nonNullComparator);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/ReverseComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.ComparatorUtils;\n+\n+/**\n+ * Reverses the order of another comparator by reversing the arguments\n+ * to its {@link #compare(Object, Object) compare} method.\n+ *\n+ * @since 2.0\n+ * @version $Id$\n+ *\n+ * @see java.util.Collections#reverseOrder()\n+ */\n+public class ReverseComparator<E> implements Comparator<E>, Serializable {\n+\n+    /** Serialization version from Collections 2.0. */\n+    private static final long serialVersionUID = 2858887242028539265L;\n+\n+    /** The comparator being decorated. */\n+    private final Comparator<E> comparator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a comparator that compares objects based on the inverse of their\n+     * natural ordering.  Using this Constructor will create a ReverseComparator\n+     * that is functionally identical to the Comparator returned by\n+     * java.util.Collections.<b>reverseOrder()</b>.\n+     * \n+     * @see java.util.Collections#reverseOrder()\n+     */\n+    public ReverseComparator() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Creates a comparator that inverts the comparison\n+     * of the given comparator.  If you pass in <code>null</code>,\n+     * the ReverseComparator defaults to reversing the\n+     * natural order, as per \n+     * {@link java.util.Collections#reverseOrder()}</b>.\n+     * \n+     * @param comparator Comparator to reverse\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ReverseComparator(final Comparator<E> comparator) {\n+        this.comparator = comparator == null ? ComparatorUtils.NATURAL_COMPARATOR : comparator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two objects in reverse order.\n+     * \n+     * @param obj1  the first object to compare\n+     * @param obj2  the second object to compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     */\n+    public int compare(final E obj1, final E obj2) {\n+        return comparator.compare(obj2, obj1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     * \n+     * @return a suitable hash code\n+     * @since 3.0\n+     */\n+    @Override\n+    public int hashCode() {\n+        return \"ReverseComparator\".hashCode() ^ comparator.hashCode();\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>object</i>.{@link Object#getClass() getClass()}</code>\n+     * equals <code>this.getClass()</code>, and the underlying \n+     * comparators are equal.\n+     * Subclasses may want to override this behavior to remain consistent\n+     * with the {@link Comparator#equals(Object) equals} contract.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     * @since 3.0\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            final ReverseComparator<?> thatrc = (ReverseComparator<?>) object;\n+            return comparator.equals(thatrc.comparator);\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/TransformingComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.ComparatorUtils;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another Comparator with transformation behavior. That is, the\n+ * return value from the transform operation will be passed to the decorated\n+ * {@link Comparator#compare(Object,Object) compare} method.\n+ * <p>\n+ * This class is Serializable from Commons Collections 4.0.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ *\n+ * @see org.apache.commons.collections4.Transformer\n+ * @see org.apache.commons.collections4.comparators.ComparableComparator\n+ */\n+public class TransformingComparator<I, O> implements Comparator<I>, Serializable {\n+    \n+    /** Serialization version from Collections 4.0. */\n+    private static final long serialVersionUID = 3456940356043606220L;\n+\n+    /** The decorated comparator. */\n+    protected final Comparator<O> decorated;\n+    /** The transformer being used. */    \n+    protected final Transformer<? super I, ? extends O> transformer;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an instance with the given Transformer and a \n+     * {@link ComparableComparator ComparableComparator}.\n+     * \n+     * @param transformer what will transform the arguments to <code>compare</code>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public TransformingComparator(final Transformer<? super I, ? extends O> transformer) {\n+        this(transformer, ComparatorUtils.NATURAL_COMPARATOR);\n+    }\n+\n+    /**\n+     * Constructs an instance with the given Transformer and Comparator.\n+     * \n+     * @param transformer  what will transform the arguments to <code>compare</code>\n+     * @param decorated  the decorated Comparator\n+     */\n+    public TransformingComparator(final Transformer<? super I, ? extends O> transformer,\n+                                  final Comparator<O> decorated) {\n+        this.decorated = decorated;\n+        this.transformer = transformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the result of comparing the values from the transform operation.\n+     * \n+     * @param obj1  the first object to transform then compare\n+     * @param obj2  the second object to transform then compare\n+     * @return negative if obj1 is less, positive if greater, zero if equal\n+     */\n+    public int compare(final I obj1, final I obj2) {\n+        final O value1 = this.transformer.transform(obj1);\n+        final O value2 = this.transformer.transform(obj2);\n+        return this.decorated.compare(value1, value2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement a hash code for this comparator that is consistent with\n+     * {@link #equals(Object) equals}.\n+     *\n+     * @return a hash code for this comparator.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 17;\n+        total = total*37 + (decorated == null ? 0 : decorated.hashCode());\n+        total = total*37 + (transformer == null ? 0 : transformer.hashCode());\n+        return total;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <i>that</i> Object is \n+     * is a {@link Comparator} whose ordering is known to be \n+     * equivalent to mine.\n+     * <p>\n+     * This implementation returns <code>true</code>\n+     * iff <code><i>that</i></code> is a {@link TransformingComparator} \n+     * whose attributes are equal to mine.\n+     * \n+     * @param object  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (this == object) {\n+            return true;\n+        }\n+        if (null == object) {\n+            return false;\n+        }\n+        if (object.getClass().equals(this.getClass())) {\n+            final TransformingComparator<?, ?> comp = (TransformingComparator<?, ?>) object;\n+            return null == decorated ? null == comp.decorated : decorated.equals(comp.decorated) &&\n+                    null == transformer ? null == comp.transformer : transformer.equals(comp.transformer);\n+        }\n+        return false;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link java.util.Comparator Comparator} interface.\n+ * <p>\n+ * You may also consider using \n+ * {@link org.apache.commons.collections4.ComparatorUtils ComparatorUtils},\n+ * which is a single class that uses static methods to construct instances\n+ * of the classes in this package.\n+ * \n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.comparators;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/CommandVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+/** \n+ * This interface should be implemented by user object to walk\n+ * through {@link EditScript EditScript} objects.\n+ * <p>\n+ * Users should implement this interface in order to walk through\n+ * the {@link EditScript EditScript} object created by the comparison\n+ * of two sequences. This is a direct application of the visitor\n+ * design pattern. The {@link EditScript#visit EditScript.visit}\n+ * method takes an object implementing this interface as an argument,\n+ * it will perform the loop over all commands in the script and the\n+ * proper methods of the user class will be called as the commands are\n+ * encountered.\n+ * <p>\n+ * The implementation of the user visitor class will depend on the\n+ * need. Here are two examples.\n+ * <p>\n+ * The first example is a visitor that build the longest common\n+ * subsequence:\n+ * <pre>\n+ * import org.apache.commons.collections.list.difference.CommandVisitor;\n+ * \n+ * import java.util.ArrayList;\n+ *\n+ * public class LongestCommonSubSequence implements CommandVisitor {\n+ * \n+ *   public LongestCommonSubSequence() {\n+ *     a = new ArrayList();\n+ *   }\n+ * \n+ *   public void visitInsertCommand(Object object) {\n+ *   }\n+ * \n+ *   public void visitKeepCommand(Object object) {\n+ *     a.add(object);\n+ *   }\n+ * \n+ *   public void visitDeleteCommand(Object object) {\n+ *   }\n+ * \n+ *   public Object[] getSubSequence() {\n+ *     return a.toArray();\n+ *   }\n+ * \n+ *   private arrayList a;\n+ * \n+ * }\n+ * </pre>\n+ * <p>\n+ * The second example is a visitor that shows the commands and the way\n+ * they transform the first sequence into the second one:\n+ * <pre>\n+ * import org.apache.commons.collections.list.difference.CommandVisitor;\n+ * \n+ * import java.util.Arrays;\n+ * import java.util.ArrayList;\n+ * import java.util.Iterator;\n+ *\n+ * public class ShowVisitor implements CommandVisitor {\n+ * \n+ *   public ShowVisitor(Object[] sequence1) {\n+ *     v = new ArrayList();\n+ *     v.addAll(Arrays.asList(sequence1));\n+ *     index = 0;\n+ *   }\n+ * \n+ *   public void visitInsertCommand(Object object) {\n+ *     v.insertElementAt(object, index++);\n+ *     display(\"insert\", object);\n+ *   }\n+ * \n+ *   public void visitKeepCommand(Object object) {\n+ *     ++index;\n+ *     display(\"keep  \", object);\n+ *   }\n+ * \n+ *   public void visitDeleteCommand(Object object) {\n+ *     v.remove(index);\n+ *     display(\"delete\", object);\n+ *   }\n+ * \n+ *   private void display(String commandName, Object object) {\n+ *     System.out.println(commandName + \" \" + object + \" ->\" + this);\n+ *   }\n+ * \n+ *   public String toString() {\n+ *     StringBuffer buffer = new StringBuffer();\n+ *     for (Iterator iter = v.iterator(); iter.hasNext();) {\n+ *       buffer.append(' ').append(iter.next());\n+ *     }\n+ *     return buffer.toString();\n+ *   }\n+ * \n+ *   private ArrayList v;\n+ *   private int index;\n+ * \n+ * }\n+ * </pre>\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface CommandVisitor<T> {\n+\n+    /** \n+     * Method called when an insert command is encountered.\n+     *\n+     * @param object object to insert (this object comes from the second sequence)\n+     */\n+    void visitInsertCommand(T object);\n+\n+    /** \n+     * Method called when a keep command is encountered.\n+     *\n+     * @param object object to keep (this object comes from the first sequence)\n+     */\n+    void visitKeepCommand(T object);\n+\n+    /** \n+     * Method called when a delete command is encountered.\n+     *\n+     * @param object object to delete (this object comes from the first sequence)\n+     */\n+    void visitDeleteCommand(T object);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/DeleteCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+/**\n+ * Command representing the deletion of one object of the first sequence.\n+ * <p>\n+ * When one object of the first sequence has no corresponding object in the\n+ * second sequence at the right place, the {@link EditScript edit script}\n+ * transforming the first sequence into the second sequence uses an instance of\n+ * this class to represent the deletion of this object. The objects embedded in\n+ * these type of commands always come from the first sequence.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class DeleteCommand<T> extends EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of {@link DeleteCommand}.\n+     *\n+     * @param object  the object of the first sequence that should be deleted\n+     */\n+    public DeleteCommand(final T object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * Accept a visitor. When a <code>DeleteCommand</code> accepts a visitor, it calls\n+     * its {@link CommandVisitor#visitDeleteCommand visitDeleteCommand} method.\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */    \n+    @Override\n+    public void accept(final CommandVisitor<T> visitor) {\n+        visitor.visitDeleteCommand(object);\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/EditCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+/**\n+ * Abstract base class for all commands used to transform an objects sequence\n+ * into another one.\n+ * <p>\n+ * When two objects sequences are compared through the\n+ * {@link SequencesComparator#getScript SequencesComparator.getScript} method,\n+ * the result is provided has a {@link EditScript script} containing the commands\n+ * that progressively transform the first sequence into the second one.\n+ * <p>\n+ * There are only three types of commands, all of which are subclasses of this\n+ * abstract class. Each command is associated with one object belonging to at\n+ * least one of the sequences. These commands are {@link InsertCommand\n+ * InsertCommand} which correspond to an object of the second sequence being\n+ * inserted into the first sequence, {@link DeleteCommand DeleteCommand} which\n+ * correspond to an object of the first sequence being removed and\n+ * {@link KeepCommand KeepCommand} which correspond to an object of the first\n+ * sequence which <code>equals</code> an object in the second sequence. It is\n+ * guaranteed that comparison is always performed this way (i.e. the\n+ * <code>equals</code> method of the object from the first sequence is used and\n+ * the object passed as an argument comes from the second sequence) ; this can\n+ * be important if subclassing is used for some elements in the first sequence\n+ * and the <code>equals</code> method is specialized.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of EditCommand\n+     * \n+     * @param object  reference to the object associated with this command, this\n+     *   refers to an element of one of the sequences being compared\n+     */\n+    protected EditCommand(final T object) {\n+        this.object = object;\n+    }\n+\n+    /**\n+     * Accept a visitor.\n+     * <p>\n+     * This method is invoked for each commands belonging to\n+     * an {@link EditScript EditScript}, in order to implement the visitor design pattern\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */\n+    public abstract void accept(CommandVisitor<T> visitor);\n+\n+    /** Object on which the command should be applied. */\n+    protected T object;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/EditScript.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class gathers all the {@link EditCommand commands} needed to transform\n+ * one objects sequence into another objects sequence.\n+ * <p>\n+ * An edit script is the most general view of the differences between two\n+ * sequences. It is built as the result of the comparison between two sequences\n+ * by the {@link SequencesComparator SequencesComparator} class. The user can\n+ * walk through it using the <em>visitor</em> design pattern.\n+ * <p>\n+ * It is guaranteed that the objects embedded in the {@link InsertCommand insert\n+ * commands} come from the second sequence and that the objects embedded in\n+ * either the {@link DeleteCommand delete commands} or {@link KeepCommand keep\n+ * commands} come from the first sequence. This can be important if subclassing\n+ * is used for some elements in the first sequence and the <code>equals</code>\n+ * method is specialized.\n+ * \n+ * @see SequencesComparator\n+ * @see EditCommand\n+ * @see CommandVisitor\n+ * @see ReplacementsHandler\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class EditScript<T> {\n+\n+    /** Container for the commands. */\n+    private final List<EditCommand<T>> commands;\n+\n+    /** Length of the longest common subsequence. */\n+    private int lcsLength;\n+\n+    /** Number of modifications. */\n+    private int modifications;\n+\n+    /**\n+     * Simple constructor. Creates a new empty script.\n+     */\n+    public EditScript() {\n+        commands = new ArrayList<EditCommand<T>>();\n+        lcsLength = 0;\n+        modifications = 0;\n+    }\n+\n+    /**\n+     * Add a keep command to the script.\n+     * \n+     * @param command  command to add\n+     */\n+    public void append(final KeepCommand<T> command) {\n+        commands.add(command);\n+        ++lcsLength;\n+    }\n+\n+    /**\n+     * Add an insert command to the script.\n+     * \n+     * @param command  command to add\n+     */\n+    public void append(final InsertCommand<T> command) {\n+        commands.add(command);\n+        ++modifications;\n+    }\n+\n+    /**\n+     * Add a delete command to the script.\n+     * \n+     * @param command  command to add\n+     */\n+    public void append(final DeleteCommand<T> command) {\n+        commands.add(command);\n+        ++modifications;\n+    }\n+\n+    /**\n+     * Visit the script. The script implements the <em>visitor</em> design\n+     * pattern, this method is the entry point to which the user supplies its\n+     * own visitor, the script will be responsible to drive it through the\n+     * commands in order and call the appropriate method as each command is\n+     * encountered.\n+     * \n+     * @param visitor  the visitor that will visit all commands in turn\n+     */\n+    public void visit(final CommandVisitor<T> visitor) {\n+        for (final EditCommand<T> command : commands) {\n+            command.accept(visitor);\n+        }\n+    }\n+\n+    /**\n+     * Get the length of the Longest Common Subsequence (LCS). The length of the\n+     * longest common subsequence is the number of {@link KeepCommand keep\n+     * commands} in the script.\n+     * \n+     * @return length of the Longest Common Subsequence\n+     */\n+    public int getLCSLength() {\n+        return lcsLength;\n+    }\n+\n+    /**\n+     * Get the number of effective modifications. The number of effective\n+     * modification is the number of {@link DeleteCommand delete} and\n+     * {@link InsertCommand insert} commands in the script.\n+     * \n+     * @return number of effective modifications\n+     */\n+    public int getModifications() {\n+        return modifications;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/InsertCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+/**\n+ * Command representing the insertion of one object of the second sequence.\n+ * <p>\n+ * When one object of the second sequence has no corresponding object in the\n+ * first sequence at the right place, the {@link EditScript edit script}\n+ * transforming the first sequence into the second sequence uses an instance of\n+ * this class to represent the insertion of this object. The objects embedded in\n+ * these type of commands always come from the second sequence.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class InsertCommand<T> extends EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of InsertCommand\n+     * \n+     * @param object  the object of the second sequence that should be inserted\n+     */\n+    public InsertCommand(final T object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * Accept a visitor. When an <code>InsertCommand</code> accepts a visitor,\n+     * it calls its {@link CommandVisitor#visitInsertCommand visitInsertCommand}\n+     * method.\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */\n+    @Override\n+    public void accept(final CommandVisitor<T> visitor) {\n+        visitor.visitInsertCommand(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/KeepCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+/**\n+ * Command representing the keeping of one object present in both sequences.\n+ * <p>\n+ * When one object of the first sequence <code>equals</code> another objects in\n+ * the second sequence at the right place, the {@link EditScript edit script}\n+ * transforming the first sequence into the second sequence uses an instance of\n+ * this class to represent the keeping of this object. The objects embedded in\n+ * these type of commands always come from the first sequence.\n+ * \n+ * @see SequencesComparator\n+ * @see EditScript\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class KeepCommand<T> extends EditCommand<T> {\n+\n+    /**\n+     * Simple constructor. Creates a new instance of KeepCommand\n+     * \n+     * @param object  the object belonging to both sequences (the object is a\n+     *   reference to the instance in the first sequence which is known\n+     *   to be equal to an instance in the second sequence)\n+     */\n+    public KeepCommand(final T object) {\n+        super(object);\n+    }\n+\n+    /**\n+     * Accept a visitor. When a <code>KeepCommand</code> accepts a visitor, it\n+     * calls its {@link CommandVisitor#visitKeepCommand visitKeepCommand} method.\n+     * \n+     * @param visitor  the visitor to be accepted\n+     */\n+    @Override\n+    public void accept(final CommandVisitor<T> visitor) {\n+        visitor.visitKeepCommand(object);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/ReplacementsFinder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class handles sequences of replacements resulting from a comparison.\n+ * <p>\n+ * The comparison of two objects sequences leads to the identification of common\n+ * parts and parts which only belong to the first or to the second sequence. The\n+ * common parts appear in the edit script in the form of <em>keep</em> commands,\n+ * they can be considered as synchronization objects between the two sequences.\n+ * These synchronization objects split the two sequences in synchronized\n+ * sub-sequences. The first sequence can be transformed into the second one by\n+ * replacing each synchronized sub-sequence of the first sequence by the\n+ * corresponding sub-sequence of the second sequence. This is a synthetic way to\n+ * see an {@link EditScript edit script}, replacing individual\n+ * {@link DeleteCommand delete}, {@link KeepCommand keep} and\n+ * {@link InsertCommand insert} commands by fewer replacements acting on\n+ * complete sub-sequences.\n+ * <p>\n+ * This class is devoted to perform this interpretation. It visits an\n+ * {@link EditScript edit script} (because it implements the\n+ * {@link CommandVisitor CommandVisitor} interface) and calls a user-supplied\n+ * handler implementing the {@link ReplacementsHandler ReplacementsHandler}\n+ * interface to process the sub-sequences.\n+ * \n+ * @see ReplacementsHandler\n+ * @see EditScript\n+ * @see SequencesComparator\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ReplacementsFinder<T> implements CommandVisitor<T> {\n+\n+    private final List<T> pendingInsertions;\n+    private final List<T> pendingDeletions;\n+    private int     skipped;\n+\n+    /** Handler to call when synchronized sequences are found. */\n+    private final ReplacementsHandler<T> handler;\n+\n+    /**\n+     * Simple constructor. Creates a new instance of {@link ReplacementsFinder}.\n+     *\n+     * @param handler  handler to call when synchronized sequences are found\n+     */\n+    public ReplacementsFinder(final ReplacementsHandler<T> handler) {\n+        pendingInsertions = new ArrayList<T>();\n+        pendingDeletions  = new ArrayList<T>();\n+        skipped           = 0;\n+        this.handler      = handler;\n+    }\n+\n+    /**\n+     * Add an object to the pending insertions set.\n+     *\n+     * @param object  object to insert\n+     */\n+    public void visitInsertCommand(final T object) {\n+        pendingInsertions.add(object);\n+    }\n+\n+    /**\n+     * Handle a synchronization object.\n+     * <p>\n+     * When a synchronization object is identified, the pending insertions and\n+     * pending deletions sets are provided to the user handler as subsequences.\n+     *\n+     * @param object  synchronization object detected\n+     */\n+    public void visitKeepCommand(final T object) {\n+        if (pendingDeletions.isEmpty() && pendingInsertions.isEmpty()) {\n+            ++skipped;\n+        } else {\n+            handler.handleReplacement(skipped, pendingDeletions, pendingInsertions);\n+            pendingDeletions.clear();\n+            pendingInsertions.clear();\n+            skipped = 1;\n+        }\n+    }\n+\n+    /**\n+     * Add an object to the pending deletions set.\n+     *\n+     * @param object  object to delete\n+     */\n+    public void visitDeleteCommand(final T object) {\n+        pendingDeletions.add(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/ReplacementsHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+import java.util.List;\n+\n+/**\n+ * This interface is devoted to handle synchronized replacement sequences.\n+ * \n+ * @see ReplacementsFinder\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface ReplacementsHandler<T> {\n+\n+    /**\n+     * Handle two synchronized sequences.\n+     * <p>\n+     * This method is called by a {@link ReplacementsFinder ReplacementsFinder}\n+     * instance when it has synchronized two sub-sequences of object arrays\n+     * being compared, and at least one of the sequences is non-empty. Since the\n+     * sequences are synchronized, the objects before the two sub-sequences are\n+     * equals (if they exist). This property also holds for the objects after\n+     * the two sub-sequences.\n+     * <p>\n+     * The replacement is defined as replacing the <code>from</code>\n+     * sub-sequence into the <code>to</code> sub-sequence.\n+     * \n+     * @param skipped  number of tokens skipped since the last call (i.e. number of\n+     *   tokens that were in both sequences), this number should be strictly positive\n+     *   except on the very first call where it can be zero (if the first object of\n+     *   the two sequences are different)\n+     * @param from  sub-sequence of objects coming from the first sequence\n+     * @param to  sub-sequence of objects coming from the second sequence\n+     */\n+    public void handleReplacement(int skipped, List<T> from, List<T> to);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/SequencesComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+import java.util.List;\n+\n+/**\n+ * This class allows to compare two objects sequences.\n+ * <p>\n+ * The two sequences can hold any object type, as only the <code>equals</code>\n+ * method is used to compare the elements of the sequences. It is guaranteed\n+ * that the comparisons will always be done as <code>o1.equals(o2)</code> where\n+ * <code>o1</code> belongs to the first sequence and <code>o2</code> belongs to\n+ * the second sequence. This can be important if subclassing is used for some\n+ * elements in the first sequence and the <code>equals</code> method is\n+ * specialized.\n+ * <p>\n+ * Comparison can be seen from two points of view: either as giving the smallest\n+ * modification allowing to transform the first sequence into the second one, or\n+ * as giving the longest sequence which is a subsequence of both initial\n+ * sequences. The <code>equals</code> method is used to compare objects, so any\n+ * object can be put into sequences. Modifications include deleting, inserting\n+ * or keeping one object, starting from the beginning of the first sequence.\n+ * <p>\n+ * This class implements the comparison algorithm, which is the very efficient\n+ * algorithm from Eugene W. Myers\n+ * <a href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">\n+ * An O(ND) Difference Algorithm and Its Variations</a>. This algorithm produces\n+ * the shortest possible\n+ * {@link EditScript edit script}\n+ * containing all the\n+ * {@link EditCommand commands}\n+ * needed to transform the first sequence into the second one.\n+ * \n+ * @see EditScript\n+ * @see EditCommand\n+ * @see CommandVisitor\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class SequencesComparator<T> {\n+\n+    /** First sequence. */\n+    private final List<T> sequence1;\n+\n+    /** Second sequence. */\n+    private final List<T> sequence2;\n+\n+    /** Temporary variables. */\n+    private final int[] vDown;\n+    private final int[] vUp;\n+\n+    /**\n+     * Simple constructor.\n+     * <p>\n+     * Creates a new instance of SequencesComparator.\n+     * <p>\n+     * It is <em>guaranteed</em> that the comparisons will always be done as\n+     * <code>o1.equals(o2)</code> where <code>o1</code> belongs to the first\n+     * sequence and <code>o2</code> belongs to the second sequence. This can be\n+     * important if subclassing is used for some elements in the first sequence\n+     * and the <code>equals</code> method is specialized.\n+     * \n+     * @param sequence1\n+     *            first sequence to be compared\n+     * @param sequence2\n+     *            second sequence to be compared\n+     */\n+    public SequencesComparator(final List<T> sequence1, final List<T> sequence2) {\n+        this.sequence1 = sequence1;\n+        this.sequence2 = sequence2;\n+\n+        final int size = sequence1.size() + sequence2.size() + 2;\n+        vDown = new int[size];\n+        vUp   = new int[size];\n+    }\n+\n+    /**\n+     * Build a snake.\n+     *\n+     * @param start  the value of the start of the snake\n+     * @param diag  the value of the diagonal of the snake\n+     * @param end1  the value of the end of the first sequence to be compared\n+     * @param end2  the value of the end of the second sequence to be compared\n+     * @return the snake built\n+     */\n+    private Snake buildSnake(final int start, final int diag, final int end1, final int end2) {\n+        int end = start;\n+        while (end - diag < end2\n+                && end < end1\n+                && sequence1.get(end).equals(sequence2.get(end - diag))) {\n+            ++end;\n+        }\n+        return new Snake(start, end, diag);\n+    }\n+\n+    /** \n+     * Get the middle snake corresponding to two subsequences of the\n+     * main sequences.\n+     * <p>\n+     * The snake is found using the MYERS Algorithm (this algorithms has\n+     * also been implemented in the GNU diff program). This algorithm is\n+     * explained in Eugene Myers article: \n+     * <a href=\"http://www.cs.arizona.edu/people/gene/PAPERS/diff.ps\">\n+     * An O(ND) Difference Algorithm and Its Variations</a>.\n+     *\n+     * @param start1  the begin of the first sequence to be compared\n+     * @param end1  the end of the first sequence to be compared\n+     * @param start2  the begin of the second sequence to be compared\n+     * @param end2  the end of the second sequence to be compared\n+     * @return the middle snake\n+     */\n+    private Snake getMiddleSnake(final int start1, final int end1, final int start2, final int end2) {\n+        // Myers Algorithm\n+        // Initialisations\n+        final int m = end1 - start1;\n+        final int n = end2 - start2;\n+        if (m == 0 || n == 0) {\n+            return null;\n+        }\n+\n+        final int delta  = m - n;\n+        final int sum    = n + m;\n+        final int offset = (sum % 2 == 0 ? sum : sum + 1) / 2;\n+        vDown[1+offset] = start1;\n+        vUp[1+offset]   = end1 + 1;\n+\n+        for (int d = 0; d <= offset ; ++d) {\n+            // Down\n+            for (int k = -d; k <= d; k += 2) {\n+                // First step\n+\n+                final int i = k + offset;\n+                if (k == -d || k != d && vDown[i-1] < vDown[i+1]) {\n+                    vDown[i] = vDown[i+1];\n+                } else {\n+                    vDown[i] = vDown[i-1] + 1;\n+                }\n+\n+                int x = vDown[i];\n+                int y = x - start1 + start2 - k;\n+\n+                while (x < end1 && y < end2 && sequence1.get(x).equals(sequence2.get(y))) {\n+                    vDown[i] = ++x;\n+                    ++y;\n+                }\n+                // Second step\n+                if (delta % 2 != 0 && delta - d <= k && k <= delta + d) {\n+                    if (vUp[i-delta] <= vDown[i]) {\n+                        return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n+                    }\n+                }\n+            }\n+\n+            // Up\n+            for (int k = delta - d; k <= delta + d; k += 2) {\n+                // First step\n+                final int i = k + offset - delta;\n+                if (k == delta - d\n+                        || k != delta + d && vUp[i+1] <= vUp[i-1]) {\n+                    vUp[i] = vUp[i+1] - 1;\n+                } else {\n+                    vUp[i] = vUp[i-1];\n+                }\n+\n+                int x = vUp[i] - 1;\n+                int y = x - start1 + start2 - k;\n+                while (x >= start1 && y >= start2\n+                        && sequence1.get(x).equals(sequence2.get(y))) {\n+                    vUp[i] = x--;\n+                    y--;\n+                }\n+                // Second step\n+                if (delta % 2 == 0 && -d <= k && k <= d ) {\n+                    if (vUp[i] <= vDown[i + delta]) {\n+                        return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // this should not happen\n+        throw new RuntimeException(\"Internal Error\");\n+    }\n+\n+\n+    /**\n+     * Build an edit script.\n+     *\n+     * @param start1  the begin of the first sequence to be compared\n+     * @param end1  the end of the first sequence to be compared\n+     * @param start2  the begin of the second sequence to be compared\n+     * @param end2  the end of the second sequence to be compared\n+     * @param script the edited script\n+     */\n+    private void buildScript(final int start1, final int end1, final int start2, final int end2,\n+                             final EditScript<T> script) {\n+\n+        final Snake middle = getMiddleSnake(start1, end1, start2, end2);\n+\n+        if (middle == null\n+                || middle.getStart() == end1 && middle.getDiag() == end1 - end2\n+                || middle.getEnd() == start1 && middle.getDiag() == start1 - start2) {\n+\n+            int i = start1;\n+            int j = start2;\n+            while (i < end1 || j < end2) {\n+                if (i < end1 && j < end2 && sequence1.get(i).equals(sequence2.get(j))) {\n+                    script.append(new KeepCommand<T>(sequence1.get(i)));\n+                    ++i;\n+                    ++j;\n+                } else {\n+                    if (end1 - start1 > end2 - start2) {\n+                        script.append(new DeleteCommand<T>(sequence1.get(i)));\n+                        ++i;\n+                    } else {\n+                        script.append(new InsertCommand<T>(sequence2.get(j)));\n+                        ++j;\n+                    }\n+                }\n+            }\n+\n+        } else {\n+\n+            buildScript(start1, middle.getStart(),\n+                        start2, middle.getStart() - middle.getDiag(),\n+                        script);\n+            for (int i = middle.getStart(); i < middle.getEnd(); ++i) {\n+                script.append(new KeepCommand<T>(sequence1.get(i)));\n+            }\n+            buildScript(middle.getEnd(), end1,\n+                        middle.getEnd() - middle.getDiag(), end2,\n+                        script);\n+        }\n+    }\n+\n+    /**\n+     * Get the {@link EditScript} object.\n+     * <p>\n+     * It is guaranteed that the objects embedded in the {@link InsertCommand\n+     * insert commands} come from the second sequence and that the objects\n+     * embedded in either the {@link DeleteCommand delete commands} or\n+     * {@link KeepCommand keep commands} come from the first sequence. This can\n+     * be important if subclassing is used for some elements in the first\n+     * sequence and the <code>equals</code> method is specialized.\n+     * \n+     * @return the edit script resulting from the comparison of the two\n+     *         sequences\n+     */\n+    public EditScript<T> getScript() {\n+        final EditScript<T> script = new EditScript<T>();\n+        buildScript(0, sequence1.size(), 0, sequence2.size(), script);\n+        return script;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/Snake.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+/**\n+ * This class is a simple placeholder to hold the end part of a path\n+ * under construction in a {@link SequencesComparator SequencesComparator}.\n+ * <p>\n+ * A snake is an internal structure used in Eugene W. Myers algorithm\n+ * (<a href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">\n+ * An O(ND) Difference Algorithm and Its Variations</a>).\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class Snake {\n+\n+    /** Start index. */\n+    private final int start;\n+\n+    /** End index. */\n+    private final int end;\n+\n+    /** Diagonal number. */\n+    private final int diag;\n+\n+    /**\n+     * Simple constructor. Creates a new instance of Snake with default indices.\n+     */\n+    public Snake() {\n+        start = -1;\n+        end   = -1;\n+        diag  =  0;\n+    }\n+\n+    /**\n+     * Simple constructor. Creates a new instance of Snake with specified indices.\n+     *\n+     * @param start  start index of the snake\n+     * @param end  end index of the snake\n+     * @param diag  diagonal number\n+     */ \n+    public Snake(final int start, final int end, final int diag) {\n+        this.start = start;\n+        this.end   = end;\n+        this.diag  = diag;\n+    }\n+\n+    /**\n+     * Get the start index of the snake.\n+     *\n+     * @return start index of the snake\n+     */\n+    public int getStart() {\n+        return start;\n+    }\n+\n+    /**\n+     * Get the end index of the snake.\n+     *\n+     * @return end index of the snake\n+     */\n+    public int getEnd() {\n+        return end;\n+    }\n+\n+    /**\n+     * Get the diagonal number of the snake.\n+     *\n+     * @return diagonal number of the snake\n+     */  \n+    public int getDiag() {\n+        return diag;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/comparators/sequence/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package provides classes to compare two objects sequences.\n+ * <p>\n+ * The two sequences can hold any object type, as only the\n+ * <code>equals</code> method is used to compare the elements of the\n+ * sequences. It is guaranteed that the comparisons will always be done\n+ * as <code>o1.equals(o2)</code> where <code>o1</code> belongs to the\n+ * first sequence and <code>o2</code> belongs to the second\n+ * sequence. This can be important if subclassing is used for some\n+ * elements in the first sequence and the <code>equals</code> method is\n+ * specialized.\n+ * <p>\n+ * Comparison can be seen from two points of view: either as giving the\n+ * smallest modification allowing to transform the first sequence into\n+ * the second one, or as giving the longest sequence which is a\n+ * subsequence of both initial sequences. The <code>equals</code> method\n+ * is used to compare objects, so any object can be put into\n+ * sequences. Modifications include deleting, inserting or keeping one\n+ * object, starting from the beginning of the first sequence. Like most\n+ * algorithms of the same type, objects transpositions are not\n+ * supported. This means that if a sequence <code>(A, B)</code> is\n+ * compared to <code>(B, A)</code>, the result will be either the\n+ * sequence of three commands <code>delete A</code>, <code>keep B</code>,\n+ * <code>insert A</code> or the sequence  <code>insert B</code>,\n+ * <code>keep A</code>, <code>delete B</code>.\n+ * <p>\n+ * The package uses a very efficient comparison algorithm designed by\n+ * Eugene W. Myers and described in his paper: <a\n+ * href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">An O(ND)\n+ * Difference Algorithm and Its Variations</a>. This algorithm produces\n+ * the shortest possible {@link\n+ * org.apache.commons.collections.list.difference.EditScript edit script} containing\n+ * all the {@link org.apache.commons.collections.list.difference.EditCommand\n+ * commands} needed to transform the first sequence into the second\n+ * one. The entry point for the user to this algorithm is the {@link\n+ * org.apache.commons.collections.list.difference.SequencesComparator\n+ * SequencesComparator} class.\n+ * <p>\n+ * As explained in Gene Myers paper, the edit script is equivalent to all\n+ * other representations and contains all the needed information either\n+ * to perform the transformation, of course, or to retrieve the longest\n+ * common subsequence for example.\n+ * <p>\n+ * If the user needs a very fine grained access to the comparison result,\n+ * he needs to go through this script by providing a visitor implementing\n+ * the {@link org.apache.commons.collections.list.difference.CommandVisitor\n+ * CommandVisitor} interface.\n+ * <p>\n+ * Sometimes however, a more synthetic approach is needed. If the user\n+ * prefers to see the differences between the two sequences as global\n+ * <code>replacement</code> operations acting on complete subsequences of\n+ * the original sequences, he will provide an object implementing the\n+ * simple {@link org.apache.commons.collections.list.difference.ReplacementsHandler\n+ * ReplacementsHandler} interface, using an instance of the {@link\n+ * org.apache.commons.collections.list.difference.ReplacementsFinder\n+ * ReplacementsFinder} class as a command converting layer between his\n+ * object and the edit script. The number of objects which are common to\n+ * both initial arrays and hence are skipped between each call to the user\n+ * {@link org.apache.commons.collections.list.difference.ReplacementsHandler#handleReplacement\n+ * handleReplacement} method is also provided. This allows the user to keep\n+ * track of the current index in both arrays if he needs so.\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/AbstractQuantifierPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Abstract base class for quantification predicates, e.g. All, Any, None.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractQuantifierPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3094696765038308799L;\n+    \n+    /** The array of predicates to call */\n+    protected final Predicate<? super T>[] iPredicates;\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public AbstractQuantifierPredicate(final Predicate<? super T> ... predicates) {\n+        iPredicates = predicates;\n+    }\n+\n+    /**\n+     * Gets the predicates.\n+     * \n+     * @return a copy of the predicates\n+     * @since 3.1\n+     */\n+    public Predicate<? super T>[] getPredicates() {\n+        return FunctorUtils.<T>copy(iPredicates);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import static org.apache.commons.collections4.functors.FunctorUtils.coerce;\n+import static org.apache.commons.collections4.functors.FunctorUtils.validate;\n+import static org.apache.commons.collections4.functors.TruePredicate.truePredicate;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if all the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns true.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class AllPredicate<T> extends AbstractQuantifierPredicate<T> implements Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3094696765038308799L;\n+    \n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns true.\n+     * If the array is size one, then that predicate is returned.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> allPredicate(final Predicate<? super T> ... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return truePredicate();\n+        }\n+        if (predicates.length == 1) {\n+            return coerce(predicates[0]);\n+        }\n+\n+        return new AllPredicate<T>(FunctorUtils.copy(predicates));\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the collection is size zero, the predicate always returns true.\n+     * If the collection is size one, then that predicate is returned.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<T>[] preds = validate(predicates);\n+        if (preds.length == 0) {\n+            return truePredicate();\n+        }\n+        if (preds.length == 1) {\n+            return preds[0];\n+        }\n+        return new AllPredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public AllPredicate(final Predicate<? super T> ... predicates) {\n+        super(predicates);\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if all predicates return true.\n+     * \n+     * @param object  the input object\n+     * @return true if all decorated predicates return true\n+     */\n+    public boolean evaluate(final T object) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n+            if (!iPredicate.evaluate(object)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if both the predicates return true.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class AndPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 4189014213763186912L;\n+\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate1;\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate2;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n+                                                final Predicate<? super T> predicate2) {\n+        if (predicate1 == null || predicate2 == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new AndPredicate<T>(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     */\n+    public AndPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+        super();\n+        iPredicate1 = predicate1;\n+        iPredicate2 = predicate2;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if both predicates return true.\n+     *\n+     * @param object  the input object\n+     * @return true if both decorated predicates return true\n+     */\n+    public boolean evaluate(final T object) {\n+       return iPredicate1.evaluate(object) && iPredicate2.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the two predicates being decorated as an array.\n+     *\n+     * @return the predicates\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate1, iPredicate2};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if any of the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns false.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class AnyPredicate<T> extends AbstractQuantifierPredicate<T> implements Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7429999530934647542L;\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns false.\n+     * If the array is size one, then that predicate is returned.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return FalsePredicate.<T>falsePredicate();\n+        }\n+        if (predicates.length == 1) {\n+            return (Predicate<T>) predicates[0];\n+        }\n+        return new AnyPredicate<T>(FunctorUtils.copy(predicates));\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the collection is size zero, the predicate always returns false.\n+     * If the collection is size one, then that predicate is returned.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        if (preds.length == 0) {\n+            return FalsePredicate.<T>falsePredicate();\n+        }\n+        if (preds.length == 1) {\n+            return (Predicate<T>) preds[0];\n+        }\n+        return new AnyPredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public AnyPredicate(final Predicate<? super T>[] predicates) {\n+        super(predicates);\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if any predicate returns true.\n+     *\n+     * @param object  the input object\n+     * @return true if any decorated predicate return true\n+     */\n+    public boolean evaluate(final T object) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n+            if (iPredicate.evaluate(object)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/CatchAndRethrowClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.FunctorException;\n+\n+/**\n+ * {@link Closure} that catches any checked exception and re-throws it as a\n+ * {@link FunctorException} runtime exception. Example usage:\n+ * \n+ * <pre>\n+ * // Create a catch and re-throw closure via anonymous subclass\n+ * CatchAndRethrowClosure&lt;String&gt; writer = new ThrowingClosure() {\n+ *     private java.io.Writer out = // some writer\n+ *     \n+ *     protected void executeAndThrow(String input) throws IOException {\n+ *         out.write(input); // throwing of IOException allowed\n+ *     }\n+ * };\n+ * \n+ * // use catch and re-throw closure\n+ * java.util.List<String> strList = // some list\n+ * try {\n+ *     CollctionUtils.forAllDo(strList, writer);\n+ * } catch (FunctorException ex) {\n+ *     Throwable originalError = ex.getCause();\n+ *     // handle error\n+ * }\n+ * </pre>\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class CatchAndRethrowClosure<E> implements Closure<E> {\n+\n+    /**\n+     * Execute this closure on the specified input object.\n+     * \n+     * @param input the input to execute on\n+     * @throws FunctorException (runtime) if the closure execution resulted in a\n+     *             checked exception.\n+     */\n+    public void execute(final E input) {\n+        try {\n+            executeAndThrow(input);\n+        } catch (final RuntimeException ex) {\n+            throw ex;\n+        } catch (final Throwable t) {\n+            throw new FunctorException(t);\n+        }\n+    }\n+\n+    /**\n+     * Execute this closure on the specified input object.\n+     * \n+     * @param input the input to execute on\n+     * @throws Throwable if the closure execution resulted in a checked\n+     *             exception.\n+     */\n+    protected abstract void executeAndThrow(E input) throws Throwable;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Closure;\n+\n+/**\n+ * Closure implementation that chains the specified closures together.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ChainedClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3520677225766901240L;\n+\n+    /** The closures to call in turn */\n+    private final Closure<? super E>[] iClosures;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter array.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param closures  the closures to chain, copied, no nulls\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures array is null\n+     * @throws IllegalArgumentException if any closure in the array is null\n+     */\n+    public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n+        FunctorUtils.validate(closures);\n+        if (closures.length == 0) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        return new ChainedClosure<E>(FunctorUtils.copy(closures));\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param closures  a collection of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws IllegalArgumentException if any closure in the collection is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> chainedClosure(final Collection<Closure<E>> closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"Closure collection must not be null\");\n+        }\n+        if (closures.size() == 0) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        final Closure<? super E>[] cmds = new Closure[closures.size()];\n+        int i = 0;\n+        for (final Closure<? super E> closure : closures) {\n+            cmds[i++] = closure;\n+        }\n+        FunctorUtils.validate(cmds);\n+        return new ChainedClosure<E>(cmds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param closures  the closures to chain, not copied, no nulls\n+     */\n+    public ChainedClosure(final Closure<? super E>[] closures) {\n+        super();\n+        iClosures = closures;\n+    }\n+\n+    /**\n+     * Execute a list of closures.\n+     * \n+     * @param input  the input object passed to each closure\n+     */\n+    public void execute(final E input) {\n+        for (final Closure<? super E> iClosure : iClosures) {\n+            iClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the closures.\n+     *\n+     * @return a copy of the closures\n+     * @since 3.1\n+     */\n+    public Closure<? super E>[] getClosures() {\n+        return FunctorUtils.<E>copy(iClosures);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that chains the specified transformers together.\n+ * <p>\n+ * The input object is passed to the first transformer. The transformed result\n+ * is passed to the second transformer and so on.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ChainedTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3514945074733160196L;\n+\n+    /** The transformers to call in turn */\n+    private final Transformer<? super T, ? extends T>[] iTransformers;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter array.\n+     *\n+     * @param <T>  the object type\n+     * @param transformers  the transformers to chain, copied, no nulls\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if the transformers array is null\n+     * @throws IllegalArgumentException if any transformer in the array is null\n+     */\n+    public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n+        FunctorUtils.validate(transformers);\n+        if (transformers.length == 0) {\n+            return NOPTransformer.<T>nopTransformer();\n+        }\n+        return new ChainedTransformer<T>(FunctorUtils.copy(transformers));\n+    }\n+    \n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     *\n+     * @param <T>  the object type\n+     * @param transformers  a collection of transformers to chain\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if the transformers collection is null\n+     * @throws IllegalArgumentException if any transformer in the collection is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> chainedTransformer(final Collection<? extends Transformer<T, T>> transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"Transformer collection must not be null\");\n+        }\n+        if (transformers.size() == 0) {\n+            return NOPTransformer.<T>nopTransformer();\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        final Transformer<T, T>[] cmds = transformers.toArray(new Transformer[transformers.size()]);\n+        FunctorUtils.validate(cmds);\n+        return new ChainedTransformer<T>(cmds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param transformers  the transformers to chain, not copied, no nulls\n+     */\n+    public ChainedTransformer(final Transformer<? super T, ? extends T>[] transformers) {\n+        super();\n+        iTransformers = transformers;\n+    }\n+\n+    /**\n+     * Transforms the input to result via each decorated transformer\n+     * \n+     * @param object  the input object passed to the first transformer\n+     * @return the transformed result\n+     */\n+    public T transform(T object) {\n+        for (final Transformer<? super T, ? extends T> iTransformer : iTransformers) {\n+            object = iTransformer.transform(object);\n+        }\n+        return object;\n+    }\n+\n+    /**\n+     * Gets the transformers.\n+     *\n+     * @return a copy of the transformers\n+     * @since 3.1\n+     */\n+    public Transformer<? super T, ? extends T>[] getTransformers() {\n+        return FunctorUtils.<T, T>copy(iTransformers);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/CloneTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that returns a clone of the input object.\n+ * <p>\n+ * Clone is performed using <code>PrototypeFactory.getInstance(input).create()</code>.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CloneTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -8188742709499652567L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, Object> INSTANCE = new CloneTransformer<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T>  the type of the objects to be cloned\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> cloneTransformer() {\n+        return (Transformer<T, T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    private CloneTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by cloning it.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public T transform(final T input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        return PrototypeFactory.prototypeFactory(input).create();\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Closure using the input object\n+ * and then returns the input.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ClosureTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 478466901448617286L;\n+\n+    /** The closure to wrap */\n+    private final Closure<? super T> iClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     *\n+     * @param <T>  the type of the object to transform\n+     * @param closure  the closure to call, not null\n+     * @return the <code>closure</code> transformer\n+     * @throws IllegalArgumentException if the closure is null\n+     */\n+    public static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"Closure must not be null\");\n+        }\n+        return new ClosureTransformer<T>(closure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param closure  the closure to call, not null\n+     */\n+    public ClosureTransformer(final Closure<? super T> closure) {\n+        super();\n+        iClosure = closure;\n+    }\n+\n+    /**\n+     * Transforms the input to result by executing a closure.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public T transform(final T input) {\n+        iClosure.execute(input);\n+        return input;\n+    }\n+\n+    /**\n+     * Gets the closure.\n+     * \n+     * @return the closure\n+     * @since 3.1\n+     */\n+    public Closure<? super T> getClosure() {\n+        return iClosure;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate that compares the input object with the one stored in the predicate using a comparator.\n+ * In addition, the comparator result can be evaluated in accordance to a supplied criterion value.\n+ *\n+ * In order to demonstrate the use of the predicate, the following variables are declared:\n+ *\n+ * <pre>\n+ * Integer ONE = new Integer(1);\n+ * Integer TWO = new Integer(2);\n+ *\n+ * Comparator comparator = new Comparator() {\n+ *\n+ *     public int compare(Object first, Object second) {\n+ *         return ((Integer) second) - ((Integer) first);\n+ *     }\n+ *\n+ * };\n+ * </pre>\n+ *\n+ * Using the declared variables, the <code>ComparatorPredicate</code> can be used used in the\n+ * following way:\n+ *\n+ * <pre>\n+ * ComparatorPredicate.getInstance(ONE, comparator).evaluate(TWO);\n+ * </pre>\n+ *\n+ * The input variable <code>TWO</code> in compared to the stored variable <code>ONE</code> using\n+ * the supplied <code>comparator</code>. This is the default usage of the predicate and will return\n+ * <code>true</code> if the underlying comparator returns <code>0</code>. In addition to the default\n+ * usage of the predicate, it is possible to evaluate the comparator's result in several ways. The\n+ * following {@link Criterion} enumeration values are provided by the predicate:\n+ * </p>\n+ *\n+ * <ul>\n+ *     <li>EQUAL</li>\n+ *     <li>GREATER</li>\n+ *     <li>GREATER_OR_EQUAL</li>\n+ *     <li>LESS</li>\n+ *     <li>LESS_OR_EQUAL</li>\n+ * </ul>\n+ *\n+ * The following examples demonstrates how these constants can be used in order to manipulate the\n+ * evaluation of a comparator result.\n+ *\n+ * <pre>\n+ * ComparatorPredicate.getInstance(ONE, comparator, <b>ComparatorPredicate.Criterion.GREATER</b>).evaluate(TWO);\n+ * </pre>\n+ *\n+ * The input variable TWO is compared to the stored variable ONE using the supplied <code>comparator</code>\n+ * using the <code>GREATER</code> evaluation criterion constant. This instructs the predicate to\n+ * return <code>true</code> if the comparator returns a value greater than <code>0</code>.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ComparatorPredicate<T> implements Predicate<T>, Serializable {\n+\n+    private static final long serialVersionUID = -1863209236504077399L;\n+\n+    public enum Criterion {\n+        EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL,\n+    }\n+\n+    // Instance variables:\n+\n+    /** The internal object to compare with */\n+    private final T object;\n+\n+    /** The comparator to use for comparison */\n+    private final Comparator<T> comparator;\n+\n+    /** The comparison evaluation criterion to use */\n+    private final Criterion criterion;\n+\n+    /**\n+     * Factory to create the comparator predicate\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if comparator is null\n+     */\n+    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n+        return comparatorPredicate(object, comparator, Criterion.EQUAL);\n+    }\n+\n+    /**\n+     * Factory to create the comparator predicate\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @param criterion  the criterion to use to evaluate comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if comparator is null of criterion is invalid\n+     */\n+    public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator,\n+                                                       final Criterion criterion) {\n+        if (comparator == null) {\n+            throw new IllegalArgumentException(\"Comparator must not be null.\");\n+        }\n+        if (criterion == null) {\n+            throw new IllegalArgumentException(\"Criterion must not be null.\");\n+        }\n+        return new ComparatorPredicate<T>(object, comparator, criterion);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want.\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @param criterion  the criterion to use to evaluate comparison\n+     */\n+    public ComparatorPredicate(final T object, final Comparator<T> comparator, final Criterion criterion) {\n+        super();\n+        this.object = object;\n+        this.comparator = comparator;\n+        this.criterion = criterion;\n+    }\n+\n+    /**\n+     * Evaluates the predicate. The predicate evaluates to <code>true</code> in the following cases:\n+     *\n+     * <ul>\n+     *     <li><code>comparator.compare(object, input) == 0 && criterion == EQUAL</code></li>\n+     *     <li><code>comparator.compare(object, input) < 0 && criterion == LESS</code></li>\n+     *     <li><code>comparator.compare(object, input) > 0 && criterion == GREATER</code></li>\n+     *     <li><code>comparator.compare(object, input) >= 0 && criterion == GREATER_OR_EQUAL</code></li>\n+     *     <li><code>comparator.compare(object, input) <= 0 && criterion == LESS_OR_EQUAL</code></li>\n+     * </ul>\n+     *\n+     * @see org.apache.commons.collections4.Predicate#evaluate(java.lang.Object)\n+     * @see java.util.Comparator#compare(java.lang.Object first, java.lang.Object second)\n+     * \n+     * @param target  the target object to compare to\n+     * @return {@code true} if the comparison succeeds according to the selected criterion\n+     * @throws IllegalStateException if the criterion is invalid (really not possible)\n+     */\n+    public boolean evaluate(final T target) {\n+\n+        boolean result = false;\n+        final int comparison = comparator.compare(object, target);\n+        switch (criterion) {\n+        case EQUAL:\n+            result = comparison == 0;\n+            break;\n+        case GREATER:\n+            result = comparison > 0;\n+            break;\n+        case LESS:\n+            result = comparison < 0;\n+            break;\n+        case GREATER_OR_EQUAL:\n+            result = comparison >= 0;\n+            break;\n+        case LESS_OR_EQUAL:\n+            result = comparison <= 0;\n+            break;\n+        default:\n+            throw new IllegalStateException(\"The current criterion '\" + criterion + \"' is invalid.\");\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ConstantFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Factory;\n+\n+/**\n+ * Factory implementation that returns the same constant each time.\n+ * <p>\n+ * No check is made that the object is immutable. In general, only immutable\n+ * objects should use the constant factory. Mutable objects should\n+ * use the prototype factory.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ConstantFactory<T> implements Factory<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3520677225766901240L;\n+    \n+    /** Returns null each time */\n+    public static final Factory<Object> NULL_INSTANCE = new ConstantFactory<Object>(null);\n+\n+    /** The closures to call in turn */\n+    private final T iConstant;\n+\n+    /**\n+     * Factory method that performs validation.\n+     *\n+     * @param <T>  the type of the constant\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> constantFactory(final T constantToReturn) {\n+        if (constantToReturn == null) {\n+            return (Factory<T>) NULL_INSTANCE;\n+        }\n+        return new ConstantFactory<T>(constantToReturn);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param constantToReturn  the constant to return each time\n+     */\n+    public ConstantFactory(final T constantToReturn) {\n+        super();\n+        iConstant = constantToReturn;\n+    }\n+\n+    /**\n+     * Always return constant.\n+     * \n+     * @return the stored constant value\n+     */\n+    public T create() {\n+        return iConstant;\n+    }\n+\n+    /**\n+     * Gets the constant.\n+     * \n+     * @return the constant\n+     * @since 3.1\n+     */\n+    public T getConstant() {\n+        return iConstant;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ConstantTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the same constant each time.\n+ * <p>\n+ * No check is made that the object is immutable. In general, only immutable\n+ * objects should use the constant factory. Mutable objects should\n+ * use the prototype factory.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ConstantTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 6374440726369055124L;\n+    \n+    /** Returns null each time */\n+    public static final Transformer<Object, Object> NULL_INSTANCE = new ConstantTransformer<Object, Object>(null);\n+\n+    /** The closures to call in turn */\n+    private final O iConstant;\n+\n+    /**\n+     * Get a typed null instance.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @return Transformer<I, O> that always returns null.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> nullTransformer() {\n+        return (Transformer<I, O>) NULL_INSTANCE;\n+    }\n+\n+    /**\n+     * Transformer method that performs validation.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    public static <I, O> Transformer<I, O> constantTransformer(final O constantToReturn) {\n+        if (constantToReturn == null) {\n+            return nullTransformer();\n+        }\n+        return new ConstantTransformer<I, O>(constantToReturn);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param constantToReturn  the constant to return each time\n+     */\n+    public ConstantTransformer(final O constantToReturn) {\n+        super();\n+        iConstant = constantToReturn;\n+    }\n+\n+    /**\n+     * Transforms the input by ignoring it and returning the stored constant instead.\n+     * \n+     * @param input  the input object which is ignored\n+     * @return the stored constant\n+     */\n+    public O transform(final I input) {\n+        return iConstant;\n+    }\n+\n+    /**\n+     * Gets the constant.\n+     * \n+     * @return the constant\n+     * @since 3.1\n+     */\n+    public O getConstant() {\n+        return iConstant;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof ConstantTransformer == false) {\n+            return false;\n+        }\n+        final Object otherConstant = ((ConstantTransformer<?, ?>) obj).getConstant();\n+        return otherConstant == getConstant() || otherConstant != null && otherConstant.equals(getConstant());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = \"ConstantTransformer\".hashCode() << 2;\n+        if (getConstant() != null) {\n+            result |= getConstant().hashCode();\n+        }\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/DefaultEquator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+/**\n+ * Default {@link Equator} implementation.\n+ * \n+ * @param <T>  the types of object this {@link Equator} can evaluate.\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class DefaultEquator<T> implements Equator<T> {\n+    /** Static instance */\n+    public static final DefaultEquator<Object> INSTANCE = new DefaultEquator<Object>();\n+\n+    /**\n+     * Hashcode used for <code>null</code> objects.\n+     */\n+    public static final int HASHCODE_NULL = -1;\n+\n+    /**\n+     * {@inheritDoc} Delegates to {@link Object#equals(Object)}.\n+     */\n+    public boolean equate(final T o1, final T o2) {\n+        return o1 == o2 || o1 != null && o1.equals(o2);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @return <code>o.hashCode()</code> if <code>o</code> is non-\n+     *         <code>null</code>, else {@link #HASHCODE_NULL}.\n+     */\n+    public int hash(final T o) {\n+        return o == null ? HASHCODE_NULL : o.hashCode();\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed {@link DefaultEquator} instance.\n+     * \n+     * @param <T>  the object type\n+     * @return {@link DefaultEquator#INSTANCE}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> DefaultEquator<T> defaultEquator() {\n+        return (DefaultEquator<T>) DefaultEquator.INSTANCE;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/EqualPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is the same object\n+ * as the one stored in this predicate by equals.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class EqualPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 5633766978029907089L;\n+\n+    /** The value to compare to */\n+    private final T iValue;\n+    \n+    /** The equator to use for comparison */\n+    private final Equator<T> equator;\n+\n+    /**\n+     * Factory to create the predicate.\n+     * \n+     * @param <T> the type that the predicate queries\n+     * @param object  the object to compare to\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> equalPredicate(final T object) {\n+        if (object == null) {\n+            return nullPredicate();\n+        }\n+        return new EqualPredicate<T>(object);\n+    }\n+\n+    /**\n+     * Factory to create the identity predicate.\n+     * \n+     * @param <T> the type that the predicate queries\n+     * @param object  the object to compare to\n+     * @param equator  the equator to use for comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @since 4.0\n+     */\n+    public static <T> Predicate<T> equalPredicate(final T object, final Equator<T> equator) {\n+        if (object == null) {\n+            return nullPredicate();\n+        }\n+        return new EqualPredicate<T>(object, equator);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param object  the object to compare to\n+     */\n+    public EqualPredicate(final T object) {\n+        // do not use the DefaultEquator to keep backwards compatibility\n+        // the DefaultEquator returns also true if the two object references are equal\n+        this(object, null);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param object  the object to compare to\n+     * @param equator  the equator to use for comparison\n+     * @since 4.0\n+     */\n+    public EqualPredicate(final T object, final Equator<T> equator) {\n+        super();\n+        iValue = object;\n+        this.equator = equator;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input equals the stored value.\n+     * \n+     * @param object  the input object\n+     * @return true if input object equals stored value\n+     */\n+    public boolean evaluate(final T object) {\n+        if (equator != null) {\n+            return equator.equate(iValue, object);\n+        } else {\n+            return iValue.equals(object);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value.\n+     * \n+     * @return the value\n+     * @since 3.1\n+     */\n+    public Object getValue() {\n+        return iValue;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/Equator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional information regarding\n+ * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n+ * copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable\n+ * law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\"\n+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License\n+ * for the specific language governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+/**\n+ * <p>\n+ * An equation function, which determines equality between objects of type T.\n+ * </p>\n+ * <p>\n+ * It is the functional sibling of {@link java.util.Comparator}; {@link Equator} is to\n+ * {@link Object} as {@link java.util.Comparator} is to {@link java.lang.Comparable}.\n+ * </p>\n+ * \n+ * @param <T> the types of object this {@link Equator} can evaluate.\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface Equator<T> {\n+    /**\n+     * Evaluates the two arguments for their equality.\n+     * \n+     * @param o1 the first object to be equated.\n+     * @param o2 the second object to be equated.\n+     * @return whether the two objects are equal.\n+     */\n+    boolean equate(T o1, T o2);\n+\n+    /**\n+     * Calculates the hash for the object, based on the method of equality used in the equate\n+     * method. This is used for classes that delegate their {@link Object#equals(Object) equals(Object)} method to an\n+     * Equator (and so must also delegate their {@link Object#hashCode() hashCode()} method), or for implementations\n+     * of {@link org.apache.commons.collections4.map.HashedMap} that use an Equator for the key objects.\n+     * \n+     * @param o the object to calculate the hash for.\n+     * @return the hash of the object.\n+     */\n+    int hash(T o);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ExceptionClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.FunctorException;\n+\n+/**\n+ * Closure implementation that always throws an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class ExceptionClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Closure<Object> INSTANCE = new ExceptionClosure<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> exceptionClosure() {\n+        return (Closure<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionClosure() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throw an exception.\n+     * \n+     * @param input  the input object\n+     * @throws FunctorException always\n+     */\n+    public void execute(final E input) {\n+        throw new FunctorException(\"ExceptionClosure invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ExceptionFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FunctorException;\n+\n+/**\n+ * Factory implementation that always throws an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class ExceptionFactory<T> implements Factory<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Factory<Object> INSTANCE = new ExceptionFactory<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     * \n+     * @param <T>  the type the factory creates\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> exceptionFactory() {\n+        return (Factory<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionFactory() {\n+        super();\n+    }\n+\n+    /**\n+     * Always throws an exception.\n+     * \n+     * @return never\n+     * @throws FunctorException always\n+     */\n+    public T create() {\n+        throw new FunctorException(\"ExceptionFactory invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ExceptionPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that always throws an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class ExceptionPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<Object> INSTANCE = new ExceptionPredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T>  the object type\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> exceptionPredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate always throwing an exception.\n+     *\n+     * @param object  the input object\n+     * @return never\n+     * @throws FunctorException always\n+     */\n+    public boolean evaluate(final T object) {\n+        throw new FunctorException(\"ExceptionPredicate invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ExceptionTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that always throws an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class ExceptionTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7179106032121985545L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, Object> INSTANCE = new ExceptionTransformer<Object, Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> exceptionTransformer() {\n+        return (Transformer<I, O>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private ExceptionTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by cloning it.\n+     *\n+     * @param input  the input object to transform\n+     * @return never\n+     * @throws FunctorException always\n+     */\n+    public O transform(final I input) {\n+        throw new FunctorException(\"ExceptionTransformer invoked\");\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Factory and returns the result.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FactoryTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -6817674502475353160L;\n+\n+    /** The factory to wrap */\n+    private final Factory<? extends O> iFactory;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param factory  the factory to call, not null\n+     * @return the <code>factory</code> transformer\n+     * @throws IllegalArgumentException if the factory is null\n+     */\n+    public static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        return new FactoryTransformer<I, O>(factory);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param factory  the factory to call, not null\n+     */\n+    public FactoryTransformer(final Factory<? extends O> factory) {\n+        super();\n+        iFactory = factory;\n+    }\n+\n+    /**\n+     * Transforms the input by ignoring the input and returning the result of\n+     * calling the decorated factory.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public O transform(final I input) {\n+        return iFactory.create();\n+    }\n+\n+    /**\n+     * Gets the factory.\n+     * \n+     * @return the factory\n+     * @since 3.1\n+     */\n+    public Factory<? extends O> getFactory() {\n+        return iFactory;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/FalsePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that always returns false.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class FalsePredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7533784454832764388L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<Object> INSTANCE = new FalsePredicate<Object>();\n+\n+    /**\n+     * Get a typed instance.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @return the singleton instance\n+     * @since 4.0\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> falsePredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FalsePredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning false always.\n+     *\n+     * @param object  the input object\n+     * @return false always\n+     */\n+    public boolean evaluate(final T object) {\n+        return false;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/ForClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+\n+/**\n+ * Closure implementation that calls another closure n times, like a for loop.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ForClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -1190120533393621674L;\n+\n+    /** The number of times to loop */\n+    private final int iCount;\n+    /** The closure to call */\n+    private final Closure<? super E> iClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * A null closure or zero count returns the <code>NOPClosure</code>.\n+     * A count of one returns the specified closure.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param count  the number of times to execute the closure\n+     * @param closure  the closure to execute, not null\n+     * @return the <code>for</code> closure\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> forClosure(final int count, final Closure<? super E> closure) {\n+        if (count <= 0 || closure == null) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        if (count == 1) {\n+            return (Closure<E>) closure;\n+        }\n+        return new ForClosure<E>(count, closure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param count  the number of times to execute the closure\n+     * @param closure  the closure to execute, not null\n+     */\n+    public ForClosure(final int count, final Closure<? super E> closure) {\n+        super();\n+        iCount = count;\n+        iClosure = closure;\n+    }\n+\n+    /**\n+     * Executes the closure <code>count</code> times.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(final E input) {\n+        for (int i = 0; i < iCount; i++) {\n+            iClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the closure.\n+     * \n+     * @return the closure\n+     * @since 3.1\n+     */\n+    public Closure<? super E> getClosure() {\n+        return iClosure;\n+    }\n+\n+    /**\n+     * Gets the count.\n+     * \n+     * @return the count\n+     * @since 3.1\n+     */\n+    public int getCount() {\n+        return iCount;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Internal utilities for functors.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+class FunctorUtils {\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private FunctorUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Clone the predicates to ensure that the internal reference can't be messed with.\n+     * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n+     * able to be coerced to Predicate<T> without casting issues.\n+     *\n+     * @param predicates  the predicates to copy\n+     * @return the cloned predicates\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T>[] copy(final Predicate<? super T>[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate<T>[]) predicates.clone();\n+    }\n+\n+    /**\n+     * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n+     * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n+     * able to be coerced to Predicate<T> without casting issues.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned predicate should \"accept\"\n+     * @param predicate the predicate to coerce.\n+     * @return the coerced predicate.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T> coerce(final Predicate<? super T> predicate){\n+        return (Predicate<T>) predicate;\n+    }\n+\n+    /**\n+     * Validate the predicates to ensure that all is well.\n+     *\n+     * @param predicates  the predicates to validate\n+     */\n+    static void validate(final Predicate<?>[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\n+                        \"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Validate the predicates to ensure that all is well.\n+     *\n+     * @param predicates  the predicates to validate\n+     * @return predicate array\n+     */\n+    static <T> Predicate<T>[] validate(final Collection<? extends Predicate<T>> predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        @SuppressWarnings(\"unchecked\") // OK\n+        final Predicate<T>[] preds = new Predicate[predicates.size()];\n+        int i = 0;\n+        for (final Predicate<T> predicate : predicates) {\n+            preds[i] = predicate;\n+            if (preds[i] == null) {\n+                throw new IllegalArgumentException(\n+                        \"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+            i++;\n+        }\n+        return preds;\n+    }\n+\n+    /**\n+     * Clone the closures to ensure that the internal reference can't be messed with.\n+     *\n+     * @param closures  the closures to copy\n+     * @return the cloned closures\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> Closure<E>[] copy(final Closure<? super E>[] closures) {\n+        if (closures == null) {\n+            return null;\n+        }\n+        return (Closure<E>[]) closures.clone();\n+    }\n+\n+    /**\n+     * Validate the closures to ensure that all is well.\n+     *\n+     * @param closures  the closures to validate\n+     */\n+    static void validate(final Closure<?>[] closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"The closure array must not be null\");\n+        }\n+        for (int i = 0; i < closures.length; i++) {\n+            if (closures[i] == null) {\n+                throw new IllegalArgumentException(\n+                        \"The closure array must not contain a null closure, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A very simple method that coerces Closure<? super T> to Closure<T>.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned closure should \"accept\"\n+     * @param closure the closure to coerce.\n+     * @return the coerced closure.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Closure<T> coerce(final Closure<? super T> closure){\n+        return (Closure<T>) closure;\n+    }\n+\n+    /**\n+     * Copy method\n+     *\n+     * @param transformers  the transformers to copy\n+     * @return a clone of the transformers\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <I, O> Transformer<I, O>[] copy(final Transformer<? super I, ? extends O>[] transformers) {\n+        if (transformers == null) {\n+            return null;\n+        }\n+        return (Transformer<I, O>[]) transformers.clone();\n+    }\n+\n+    /**\n+     * Validate method\n+     *\n+     * @param transformers  the transformers to validate\n+     */\n+    static void validate(final Transformer<?, ?>[] transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"The transformer array must not be null\");\n+        }\n+        for (int i = 0; i < transformers.length; i++) {\n+            if (transformers[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned transformer should \"accept\"\n+     * @param transformer the transformer to coerce.\n+     * @return the coerced transformer.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <I, O> Transformer<I, O> coerce(final Transformer<? super I, ? extends O> transformer) {\n+        return (Transformer<I, O>) transformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is the same object\n+ * as the one stored in this predicate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class IdentityPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -89901658494523293L;\n+\n+    /** The value to compare to */\n+    private final T iValue;\n+\n+    /**\n+     * Factory to create the identity predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param object  the object to compare to\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> identityPredicate(final T object) {\n+        if (object == null) {\n+            return NullPredicate.<T>nullPredicate();\n+        }\n+        return new IdentityPredicate<T>(object);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param object  the object to compare to\n+     */\n+    public IdentityPredicate(final T object) {\n+        super();\n+        iValue = object;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input object is identical to\n+     * the stored object.\n+     *\n+     * @param object  the input object\n+     * @return true if input is the same object as the stored value\n+     */\n+    public boolean evaluate(final T object) {\n+        return iValue == object;\n+    }\n+\n+    /**\n+     * Gets the value.\n+     *\n+     * @return the value\n+     * @since 3.1\n+     */\n+    public T getValue() {\n+        return iValue;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/IfClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Closure implementation acts as an if statement calling one or other closure\n+ * based on a predicate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class IfClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** The test */\n+    private final Predicate<? super E> iPredicate;\n+    /** The closure to use if true */\n+    private final Closure<? super E> iTrueClosure;\n+    /** The closure to use if false */\n+    private final Closure<? super E> iFalseClosure;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * This factory creates a closure that performs no action when\n+     * the predicate is false.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param predicate  predicate to switch on\n+     * @param trueClosure  closure used if true\n+     * @return the <code>if</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     * @since 3.2\n+     */\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n+        return IfClosure.<E>ifClosure(predicate, trueClosure, NOPClosure.<E>nopClosure());\n+    }\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param predicate  predicate to switch on\n+     * @param trueClosure  closure used if true\n+     * @param falseClosure  closure used if false\n+     * @return the <code>if</code> closure\n+     * @throws IllegalArgumentException if any argument is null\n+     */\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n+                                           final Closure<? super E> trueClosure,\n+                                           final Closure<? super E> falseClosure) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        if (trueClosure == null || falseClosure == null) {\n+            throw new IllegalArgumentException(\"Closures must not be null\");\n+        }\n+        return new IfClosure<E>(predicate, trueClosure, falseClosure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * <p>\n+     * This constructor creates a closure that performs no action when\n+     * the predicate is false.\n+     * \n+     * @param predicate  predicate to switch on, not null\n+     * @param trueClosure  closure used if true, not null\n+     * @since 3.2\n+     */\n+    public IfClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n+        this(predicate, trueClosure, NOPClosure.INSTANCE);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  predicate to switch on, not null\n+     * @param trueClosure  closure used if true, not null\n+     * @param falseClosure  closure used if false, not null\n+     */\n+    public IfClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure,\n+                     final Closure<? super E> falseClosure) {\n+        super();\n+        iPredicate = predicate;\n+        iTrueClosure = trueClosure;\n+        iFalseClosure = falseClosure;\n+    }\n+\n+    /**\n+     * Executes the true or false closure according to the result of the predicate.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(final E input) {\n+        if (iPredicate.evaluate(input)) {\n+            iTrueClosure.execute(input);\n+        } else {\n+            iFalseClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the predicate.\n+     * \n+     * @return the predicate\n+     * @since 3.1\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return iPredicate;\n+    }\n+\n+    /**\n+     * Gets the closure called when true.\n+     * \n+     * @return the closure\n+     * @since 3.1\n+     */\n+    public Closure<? super E> getTrueClosure() {\n+        return iTrueClosure;\n+    }\n+\n+    /**\n+     * Gets the closure called when false.\n+     * \n+     * @return the closure\n+     * @since 3.1\n+     */\n+    public Closure<? super E> getFalseClosure() {\n+        return iFalseClosure;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is an instanceof\n+ * the type stored in this predicate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class InstanceofPredicate implements Predicate<Object>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -6682656911025165584L;\n+\n+    /** The type to compare to */\n+    private final Class<?> iType;\n+\n+    /**\n+     * Factory to create the identity predicate.\n+     *\n+     * @param type  the type to check for, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n+        }\n+        return new InstanceofPredicate(type);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param type  the type to check for\n+     */\n+    public InstanceofPredicate(final Class<?> type) {\n+        super();\n+        iType = type;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input object is of the correct type.\n+     *\n+     * @param object  the input object\n+     * @return true if input is of stored type\n+     */\n+    public boolean evaluate(final Object object) {\n+        return iType.isInstance(object);\n+    }\n+\n+    /**\n+     * Gets the type to compare to.\n+     *\n+     * @return the type\n+     * @since 3.1\n+     */\n+    public Class<?> getType() {\n+        return iType;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FunctorException;\n+\n+/**\n+ * Factory implementation that creates a new object instance by reflection.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class InstantiateFactory<T> implements Factory<T>, Serializable {\n+\n+    /** The serial version */\n+    private static final long serialVersionUID = -7732226881069447957L;\n+\n+    /** The class to create */\n+    private final Class<T> iClassToInstantiate;\n+    /** The constructor parameter types */\n+    private final Class<?>[] iParamTypes;\n+    /** The constructor arguments */\n+    private final Object[] iArgs;\n+    /** The constructor */\n+    private transient Constructor<T> iConstructor = null;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param <T>  the type the factory creates\n+     * @param classToInstantiate  the class to instantiate, not null\n+     * @param paramTypes  the constructor parameter types, cloned\n+     * @param args  the constructor arguments, cloned\n+     * @return a new instantiate factory\n+     */\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate,\n+                                                    final Class<?>[] paramTypes,\n+                                                    final Object[] args) {\n+        if (classToInstantiate == null) {\n+            throw new IllegalArgumentException(\"Class to instantiate must not be null\");\n+        }\n+        if (paramTypes == null && args != null\n+            || paramTypes != null && args == null\n+            || paramTypes != null && args != null && paramTypes.length != args.length) {\n+            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n+        }\n+\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return new InstantiateFactory<T>(classToInstantiate);\n+        }\n+        return new InstantiateFactory<T>(classToInstantiate, paramTypes, args);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param classToInstantiate  the class to instantiate\n+     */\n+    public InstantiateFactory(final Class<T> classToInstantiate) {\n+        super();\n+        iClassToInstantiate = classToInstantiate;\n+        iParamTypes = null;\n+        iArgs = null;\n+        findConstructor();\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param classToInstantiate  the class to instantiate\n+     * @param paramTypes  the constructor parameter types, cloned\n+     * @param args  the constructor arguments, cloned\n+     */\n+    public InstantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n+        super();\n+        iClassToInstantiate = classToInstantiate;\n+        iParamTypes = paramTypes.clone();\n+        iArgs = args.clone();\n+        findConstructor();\n+    }\n+\n+    /**\n+     * Find the Constructor for the class specified.\n+     */\n+    private void findConstructor() {\n+        try {\n+            iConstructor = iClassToInstantiate.getConstructor(iParamTypes);\n+        } catch (final NoSuchMethodException ex) {\n+            throw new IllegalArgumentException(\"InstantiateFactory: The constructor must exist and be public \");\n+        }\n+    }\n+\n+    /**\n+     * Creates an object using the stored constructor.\n+     * \n+     * @return the new object\n+     */\n+    public T create() {\n+        // needed for post-serialization\n+        if (iConstructor == null) {\n+            findConstructor();\n+        }\n+\n+        try {\n+            return iConstructor.newInstance(iArgs);\n+        } catch (final InstantiationException ex) {\n+            throw new FunctorException(\"InstantiateFactory: InstantiationException\", ex);\n+        } catch (final IllegalAccessException ex) {\n+            throw new FunctorException(\"InstantiateFactory: Constructor must be public\", ex);\n+        } catch (final InvocationTargetException ex) {\n+            throw new FunctorException(\"InstantiateFactory: Constructor threw an exception\", ex);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that creates a new object instance by reflection.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class InstantiateTransformer<T> implements Transformer<Class<? extends T>, T>, Serializable {\n+\n+    /** The serial version */\n+    private static final long serialVersionUID = 3786388740793356347L;\n+\n+    /** Singleton instance that uses the no arg constructor */\n+    public static final Transformer<Class<?>, ?> NO_ARG_INSTANCE = new InstantiateTransformer<Object>();\n+\n+    /** The constructor parameter types */\n+    private final Class<?>[] iParamTypes;\n+    /** The constructor arguments */\n+    private final Object[] iArgs;\n+\n+    /**\n+     * Get a typed no-arg instance.\n+     *\n+     * @param <T>  the type of the objects to be created\n+     * @return Transformer<Class<? extends T>, T>\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer() {\n+        return new InstantiateTransformer<T>();\n+    }\n+\n+    /**\n+     * Transformer method that performs validation.\n+     *\n+     * @param <T>  the type of the objects to be created\n+     * @param paramTypes  the constructor parameter types\n+     * @param args  the constructor arguments\n+     * @return an instantiate transformer\n+     */\n+    public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(Class<?>[] paramTypes, Object[] args) {\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"Parameter types must match the arguments\");\n+        }\n+\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return new InstantiateTransformer<T>();\n+        }\n+        paramTypes = paramTypes.clone();\n+        args = args.clone();\n+        return new InstantiateTransformer<T>(paramTypes, args);\n+    }\n+\n+    /**\n+     * Constructor for no arg instance.\n+     */\n+    private InstantiateTransformer() {\n+        super();\n+        iParamTypes = null;\n+        iArgs = null;\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InstantiateTransformer(final Class<?>[] paramTypes, final Object[] args) {\n+        super();\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+    }\n+\n+    /**\n+     * Transforms the input Class object to a result by instantiation.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public T transform(final Class<? extends T> input) {\n+        try {\n+            if (input == null) {\n+                throw new FunctorException(\n+                    \"InstantiateTransformer: Input object was not an instanceof Class, it was a null object\");\n+            }\n+            final Constructor<? extends T> con = input.getConstructor(iParamTypes);\n+            return con.newInstance(iArgs);\n+        } catch (final NoSuchMethodException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: The constructor must exist and be public \");\n+        } catch (final InstantiationException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: InstantiationException\", ex);\n+        } catch (final IllegalAccessException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: Constructor must be public\", ex);\n+        } catch (final InvocationTargetException ex) {\n+            throw new FunctorException(\"InstantiateTransformer: Constructor threw an exception\", ex);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that creates a new object instance by reflection.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class InvokerTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** The serial version */\n+    private static final long serialVersionUID = -8653385846894047688L;\n+    \n+    /** The method name to call */\n+    private final String iMethodName;\n+    /** The array of reflection parameter types */\n+    private final Class<?>[] iParamTypes;\n+    /** The array of reflection arguments */\n+    private final Object[] iArgs;\n+\n+    /**\n+     * Gets an instance of this transformer calling a specific method with no arguments.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param methodName  the method name to call\n+     * @return an invoker transformer\n+     * @since 3.1\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+        }\n+        return new InvokerTransformer<I, O>(methodName);\n+    }\n+\n+    /**\n+     * Gets an instance of this transformer calling a specific method with specific values.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param methodName  the method name to call\n+     * @param paramTypes  the parameter types of the method\n+     * @param args  the arguments to pass to the method\n+     * @return an invoker transformer\n+     */\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, Class<?>[] paramTypes,\n+                                                              Object[] args) {\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+        }\n+        if (((paramTypes == null) && (args != null))\n+            || ((paramTypes != null) && (args == null))\n+            || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+            throw new IllegalArgumentException(\"The parameter types must match the arguments\");\n+        }\n+        if (paramTypes == null || paramTypes.length == 0) {\n+            return new InvokerTransformer<I, O>(methodName);\n+        } else {\n+            paramTypes = paramTypes.clone();\n+            args = args.clone();\n+            return new InvokerTransformer<I, O>(methodName, paramTypes, args);\n+        }\n+    }\n+\n+    /**\n+     * Constructor for no arg instance.\n+     * \n+     * @param methodName  the method to call\n+     */\n+    private InvokerTransformer(final String methodName) {\n+        super();\n+        iMethodName = methodName;\n+        iParamTypes = null;\n+        iArgs = null;\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param methodName  the method to call\n+     * @param paramTypes  the constructor parameter types, not cloned\n+     * @param args  the constructor arguments, not cloned\n+     */\n+    public InvokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n+        super();\n+        iMethodName = methodName;\n+        iParamTypes = paramTypes;\n+        iArgs = args;\n+    }\n+\n+    /**\n+     * Transforms the input to result by invoking a method on the input.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result, null if null input\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public O transform(final Object input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        try {\n+            final Class<?> cls = input.getClass();\n+            final Method method = cls.getMethod(iMethodName, iParamTypes);\n+            return (O) method.invoke(input, iArgs);\n+        } catch (final NoSuchMethodException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n+                                       input.getClass() + \"' does not exist\");\n+        } catch (final IllegalAccessException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n+                                       input.getClass() + \"' cannot be accessed\");\n+        } catch (final InvocationTargetException ex) {\n+            throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" +\n+                                       input.getClass() + \"' threw an exception\", ex);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/MapTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the value held in a specified map\n+ * using the input parameter as a key.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class MapTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 862391807045468939L;\n+\n+    /** The map of data to lookup in */\n+    private final Map<? super I, ? extends O> iMap;\n+\n+    /**\n+     * Factory to create the transformer.\n+     * <p>\n+     * If the map is null, a transformer that always returns null is returned.\n+     *\n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param map the map, not cloned\n+     * @return the transformer\n+     */\n+    public static <I, O> Transformer<I, O> mapTransformer(final Map<? super I, ? extends O> map) {\n+        if (map == null) {\n+            return ConstantTransformer.<I, O>nullTransformer();\n+        }\n+        return new MapTransformer<I, O>(map);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param map  the map to use for lookup, not cloned\n+     */\n+    private MapTransformer(final Map<? super I, ? extends O> map) {\n+        super();\n+        iMap = map;\n+    }\n+\n+    /**\n+     * Transforms the input to result by looking it up in a <code>Map</code>.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public O transform(final I input) {\n+        return iMap.get(input);\n+    }\n+\n+    /**\n+     * Gets the map to lookup in.\n+     *\n+     * @return the map\n+     * @since 3.1\n+     */\n+    public Map<? super I, ? extends O> getMap() {\n+        return iMap;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NOPClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+\n+/**\n+ * Closure implementation that does nothing.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NOPClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** Singleton predicate instance */\n+    public static final Closure<Object> INSTANCE = new NOPClosure<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <E> the type that the closure acts on\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> nopClosure() {\n+        return (Closure<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    private NOPClosure() {\n+        super();\n+    }\n+\n+    /**\n+     * Do nothing.\n+     *\n+     * @param input  the input object\n+     */\n+    public void execute(final E input) {\n+        // do nothing\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NOPTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that does nothing.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class NOPTransformer<T> implements Transformer<T, T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 2133891748318574490L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, Object> INSTANCE = new NOPTransformer<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T>  the input/output type\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, T> nopTransformer() {\n+        return (Transformer<T, T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    private NOPTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by doing nothing.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result which is the input\n+     */\n+    public T transform(final T input) {\n+        return input;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if none of the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns true.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NonePredicate<T> extends AbstractQuantifierPredicate<T> implements Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 2007613066565892961L;\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns true.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return TruePredicate.<T>truePredicate();\n+        }\n+        return new NonePredicate<T>(FunctorUtils.copy(predicates));\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the collection is size zero, the predicate always returns true.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        if (preds.length == 0) {\n+            return TruePredicate.<T>truePredicate();\n+        }\n+        return new NonePredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public NonePredicate(final Predicate<? super T>[] predicates) {\n+        super(predicates);\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning false if any stored predicate returns false.\n+     *\n+     * @param object  the input object\n+     * @return true if none of decorated predicates return true\n+     */\n+    public boolean evaluate(final T object) {\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n+            if (iPredicate.evaluate(object)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NotNullPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is not null.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NotNullPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7533784454832764388L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<Object> INSTANCE = new NotNullPredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> notNullPredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private NotNullPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the object does not equal null.\n+     *\n+     * @param object  the object to evaluate\n+     * @return true if not null\n+     */\n+    public boolean evaluate(final T object) {\n+        return object != null;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns the opposite of the decorated predicate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NotPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -2654603322338049674L;\n+    \n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+    \n+    /**\n+     * Factory to create the not predicate.\n+     * \n+     * @param <T> the type that the predicate queries\n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NotPredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NotPredicate(final Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the opposite to the stored predicate.\n+     * \n+     * @param object  the input object\n+     * @return true if predicate returns false\n+     */\n+    public boolean evaluate(final T object) {\n+        return !iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     * \n+     * @return the predicate as the only element in an array\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that throws an exception if the input is null.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NullIsExceptionPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3243449850504576071L;\n+    \n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+    \n+    /**\n+     * Factory to create the null exception predicate.\n+     * \n+     * @param <T> the type that the predicate queries\n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NullIsExceptionPredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NullIsExceptionPredicate(final Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once a null check is performed.\n+     * \n+     * @param object  the input object\n+     * @return true if decorated predicate returns true\n+     * @throws FunctorException if input is null\n+     */\n+    public boolean evaluate(final T object) {\n+        if (object == null) {\n+            throw new FunctorException(\"Input Object must not be null\");\n+        }\n+        return iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     * \n+     * @return the predicate as the only element in an array\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns false if the input is null.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NullIsFalsePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -2997501534564735525L;\n+\n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+\n+    /**\n+     * Factory to create the null false predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NullIsFalsePredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NullIsFalsePredicate(final Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once a null check is performed.\n+     *\n+     * @param object  the input object\n+     * @return true if decorated predicate returns true, false if input is null\n+     */\n+    public boolean evaluate(final T object) {\n+        if (object == null) {\n+            return false;\n+        }\n+        return iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     *\n+     * @return the predicate as the only element in an array\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is null.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NullIsTruePredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -7625133768987126273L;\n+    \n+    /** The predicate to decorate */\n+    private final Predicate<? super T> iPredicate;\n+    \n+    /**\n+     * Factory to create the null true predicate.\n+     * \n+     * @param <T> the type that the predicate queries\n+     * @param predicate  the predicate to decorate, not null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new NullIsTruePredicate<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call after the null check\n+     */\n+    public NullIsTruePredicate(final Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once a null check is performed.\n+     * \n+     * @param object  the input object\n+     * @return true if decorated predicate returns true or input is null\n+     */\n+    public boolean evaluate(final T object) {\n+        if (object == null) {\n+            return true;\n+        }\n+        return iPredicate.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     * \n+     * @return the predicate as the only element in an array\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] { iPredicate };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if the input is null.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class NullPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7533784454832764388L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<?> INSTANCE = new NullPredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> nullPredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private NullPredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input is null.\n+     *\n+     * @param object  the input object\n+     * @return true if input is null\n+     */\n+    public boolean evaluate(final T object) {\n+        return object == null;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if only one of the\n+ * predicates return true.\n+ * If the array of predicates is empty, then this predicate returns false.\n+ * <p>\n+ * NOTE: In versions prior to 3.2 an array size of zero or one\n+ * threw an exception.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class OnePredicate<T> extends AbstractQuantifierPredicate<T> implements Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -8125389089924745785L;\n+    \n+    /**\n+     * Factory to create the predicate.\n+     * <p>\n+     * If the array is size zero, the predicate always returns false.\n+     * If the array is size one, then that predicate is returned.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n+        FunctorUtils.validate(predicates);\n+        if (predicates.length == 0) {\n+            return FalsePredicate.<T>falsePredicate();\n+        }\n+        if (predicates.length == 1) {\n+            return (Predicate<T>) predicates[0];\n+        }\n+        return new OnePredicate<T>(FunctorUtils.copy(predicates));\n+    }\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicates  the predicates to check, cloned, not null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<T>> predicates) {\n+        final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n+        return new OnePredicate<T>(preds);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicates  the predicates to check, not cloned, not null\n+     */\n+    public OnePredicate(final Predicate<? super T>[] predicates) {\n+        super(predicates);\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if only one decorated predicate\n+     * returns true.\n+     * \n+     * @param object  the input object\n+     * @return true if only one decorated predicate returns true\n+     */\n+    public boolean evaluate(final T object) {\n+        boolean match = false;\n+        for (final Predicate<? super T> iPredicate : iPredicates) {\n+            if (iPredicate.evaluate(object)) {\n+                if (match) {\n+                    return false;\n+                }\n+                match = true;\n+            }\n+        }\n+        return match;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true if either of the predicates return true.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class OrPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -8791518325735182855L;\n+\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate1;\n+    /** The array of predicates to call */\n+    private final Predicate<? super T> iPredicate2;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n+                                               final Predicate<? super T> predicate2) {\n+        if (predicate1 == null || predicate2 == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new OrPredicate<T>(predicate1, predicate2);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicate1  the first predicate to check, not null\n+     * @param predicate2  the second predicate to check, not null\n+     */\n+    public OrPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+        super();\n+        iPredicate1 = predicate1;\n+        iPredicate2 = predicate2;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if either predicate returns true.\n+     *\n+     * @param object  the input object\n+     * @return true if either decorated predicate returns true\n+     */\n+    public boolean evaluate(final T object) {\n+       return iPredicate1.evaluate(object) || iPredicate2.evaluate(object);\n+    }\n+\n+    /**\n+     * Gets the two predicates being decorated as an array.\n+     *\n+     * @return the predicates\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate1, iPredicate2};\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/PredicateDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Defines a predicate that decorates one or more other predicates.\n+ * <p>\n+ * This interface enables tools to access the decorated predicates.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public interface PredicateDecorator<T> extends Predicate<T> {\n+\n+    /**\n+     * Gets the predicates being decorated as an array.\n+     * <p>\n+     * The array may be the internal data structure of the predicate and thus\n+     * should not be altered.\n+     * \n+     * @return the predicates being decorated\n+     */\n+    Predicate<? super T>[] getPredicates();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/PredicateTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that calls a Predicate using the input object\n+ * and then returns the result.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicateTransformer<T> implements Transformer<T, Boolean>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 5278818408044349346L;\n+\n+    /** The closure to wrap */\n+    private final Predicate<? super T> iPredicate;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param <T>  the input type\n+     * @param predicate  the predicate to call, not null\n+     * @return the <code>predicate</code> transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Transformer<T, Boolean> predicateTransformer(final Predicate<? super T> predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        return new PredicateTransformer<T>(predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate to call, not null\n+     */\n+    public PredicateTransformer(final Predicate<? super T> predicate) {\n+        super();\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Transforms the input to result by calling a predicate.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public Boolean transform(final T input) {\n+        return Boolean.valueOf(iPredicate.evaluate(input));\n+    }\n+\n+    /**\n+     * Gets the predicate.\n+     * \n+     * @return the predicate\n+     * @since 3.1\n+     */\n+    public Predicate<? super T> getPredicate() {\n+        return iPredicate;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/PrototypeFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FunctorException;\n+\n+/**\n+ * Factory implementation that creates a new instance each time based on a prototype.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PrototypeFactory {\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * Creates a Factory that will return a clone of the same prototype object\n+     * each time the factory is used. The prototype will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     *\n+     * @param <T>  the type the factory creates\n+     * @param prototype  the object to clone each time in the factory\n+     * @return the <code>prototype</code> factory, or a {@link ConstantFactory#NULL_INSTANCE} if\n+     * the {@code prototype} is {@code null}\n+     * @throws IllegalArgumentException if the prototype cannot be cloned\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Factory<T> prototypeFactory(final T prototype) {\n+        if (prototype == null) {\n+            return ConstantFactory.<T>constantFactory(null);\n+        }\n+        try {\n+            final Method method = prototype.getClass().getMethod(\"clone\", (Class[]) null);\n+            return new PrototypeCloneFactory<T>(prototype, method);\n+\n+        } catch (final NoSuchMethodException ex) {\n+            try {\n+                prototype.getClass().getConstructor(new Class<?>[] { prototype.getClass() });\n+                return new InstantiateFactory<T>(\n+                    (Class<T>) prototype.getClass(),\n+                    new Class<?>[] { prototype.getClass() },\n+                    new Object[] { prototype });\n+            } catch (final NoSuchMethodException ex2) {\n+                if (prototype instanceof Serializable) {\n+                    return (Factory<T>) new PrototypeSerializationFactory<Serializable>((Serializable) prototype);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     */\n+    private PrototypeFactory() {\n+        super();\n+    }\n+\n+    // PrototypeCloneFactory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n+     */\n+    static class PrototypeCloneFactory<T> implements Factory<T>, Serializable {\n+        \n+        /** The serial version */\n+        private static final long serialVersionUID = 5604271422565175555L;\n+        \n+        /** The object to clone each time */\n+        private final T iPrototype;\n+        /** The method used to clone */\n+        private transient Method iCloneMethod;\n+\n+        /**\n+         * Constructor to store prototype.\n+         */\n+        private PrototypeCloneFactory(final T prototype, final Method method) {\n+            super();\n+            iPrototype = prototype;\n+            iCloneMethod = method;\n+        }\n+\n+        /**\n+         * Find the Clone method for the class specified.\n+         */\n+        private void findCloneMethod() {\n+            try {\n+                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", (Class[]) null);\n+            } catch (final NoSuchMethodException ex) {\n+                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n+            }\n+        }\n+\n+        /**\n+         * Creates an object by calling the clone method.\n+         * \n+         * @return the new object\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        public T create() {\n+            // needed for post-serialization\n+            if (iCloneMethod == null) {\n+                findCloneMethod();\n+            }\n+\n+            try {\n+                return (T) iCloneMethod.invoke(iPrototype, (Object[]) null);\n+            } catch (final IllegalAccessException ex) {\n+                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n+            } catch (final InvocationTargetException ex) {\n+                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+    // PrototypeSerializationFactory\n+    //-----------------------------------------------------------------------\n+    /**\n+     * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n+     */\n+    static class PrototypeSerializationFactory<T extends Serializable> implements Factory<T>, Serializable {\n+        \n+        /** The serial version */\n+        private static final long serialVersionUID = -8704966966139178833L;\n+        \n+        /** The object to clone via serialization each time */\n+        private final T iPrototype;\n+\n+        /**\n+         * Constructor to store prototype\n+         */\n+        private PrototypeSerializationFactory(final T prototype) {\n+            super();\n+            iPrototype = prototype;\n+        }\n+\n+        /**\n+         * Creates an object using serialization.\n+         * \n+         * @return the new object\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        public T create() {\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+            ByteArrayInputStream bais = null;\n+            try {\n+                final ObjectOutputStream out = new ObjectOutputStream(baos);\n+                out.writeObject(iPrototype);\n+\n+                bais = new ByteArrayInputStream(baos.toByteArray());\n+                final ObjectInputStream in = new ObjectInputStream(bais);\n+                return (T) in.readObject();\n+\n+            } catch (final ClassNotFoundException ex) {\n+                throw new FunctorException(ex);\n+            } catch (final IOException ex) {\n+                throw new FunctorException(ex);\n+            } finally {\n+                try {\n+                    if (bais != null) {\n+                        bais.close();\n+                    }\n+                } catch (final IOException ex) {\n+                    // ignore\n+                }\n+                try {\n+                    baos.close();\n+                } catch (final IOException ex) {\n+                    // ignore\n+                }\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/StringValueTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation that returns the result of calling\n+ * <code>String.valueOf</code> on the input object.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class StringValueTransformer<T> implements Transformer<T, String>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 7511110693171758606L;\n+\n+    /** Singleton predicate instance */\n+    public static final Transformer<Object, String> INSTANCE = new StringValueTransformer<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T>  the input type\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Transformer<T, String> stringValueTransformer() {\n+        return (Transformer<T, String>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private StringValueTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transforms the input to result by calling <code>String.valueOf</code>.\n+     *\n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public String transform(final T input) {\n+        return String.valueOf(input);\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Closure implementation calls the closure whose predicate returns true,\n+ * like a switch statement.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SwitchClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3518477308466486130L;\n+\n+    /** The tests to consider */\n+    private final Predicate<? super E>[] iPredicates;\n+    /** The matching closures to call */\n+    private final Closure<? super E>[] iClosures;\n+    /** The default closure to call if no tests match */\n+    private final Closure<? super E> iDefault;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter arrays.\n+     *\n+     * @param <E> the type that the closure acts on\n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param closures  matching array of closures, cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n+                                               final Closure<? super E>[] closures,\n+                                               final Closure<? super E> defaultClosure) {\n+        FunctorUtils.validate(predicates);\n+        FunctorUtils.validate(closures);\n+        if (predicates.length != closures.length) {\n+            throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n+        }\n+        if (predicates.length == 0) {\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure(): defaultClosure);\n+        }\n+        return new SwitchClosure<E>(FunctorUtils.copy(predicates), FunctorUtils.copy(closures), defaultClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending\n+     * on the predicates.\n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure\n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called. The default closure is set in the map with a\n+     * null key. The ordering is that of the iterator() method on the entryset\n+     * collection of the map.\n+     *\n+     * @param <E> the type that the closure acts on\n+     * @param predicatesAndClosures  a map of predicates to closures\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n+        if (predicatesAndClosures == null) {\n+            throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n+        final int size = predicatesAndClosures.size();\n+        if (size == 0) {\n+            return (Closure<E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n+        }\n+        final Closure<E>[] closures = new Closure[size];\n+        final Predicate<E>[] preds = new Predicate[size];\n+        int i = 0;\n+        for (final Map.Entry<Predicate<E>, Closure<E>> entry : predicatesAndClosures.entrySet()) {\n+            preds[i] = entry.getKey();\n+            closures[i] = entry.getValue();\n+            i++;\n+        }\n+        return new SwitchClosure<E>(preds, closures, defaultClosure);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param predicates  array of predicates, not cloned, no nulls\n+     * @param closures  matching array of closures, not cloned, no nulls\n+     * @param defaultClosure  the closure to use if no match, null means nop\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public SwitchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures,\n+                         final Closure<? super E> defaultClosure) {\n+        super();\n+        iPredicates = predicates;\n+        iClosures = closures;\n+        iDefault = (Closure<? super E>) (defaultClosure == null ? NOPClosure.<E>nopClosure() : defaultClosure);\n+    }\n+\n+    /**\n+     * Executes the closure whose matching predicate returns true\n+     *\n+     * @param input  the input object\n+     */\n+    public void execute(final E input) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(input) == true) {\n+                iClosures[i].execute(input);\n+                return;\n+            }\n+        }\n+        iDefault.execute(input);\n+    }\n+\n+    /**\n+     * Gets the predicates.\n+     *\n+     * @return a copy of the predicates\n+     * @since 3.1\n+     */\n+    public Predicate<? super E>[] getPredicates() {\n+        return FunctorUtils.<E>copy(iPredicates);\n+    }\n+\n+    /**\n+     * Gets the closures.\n+     *\n+     * @return a copy of the closures\n+     * @since 3.1\n+     */\n+    public Closure<? super E>[] getClosures() {\n+        return FunctorUtils.<E>copy(iClosures);\n+    }\n+\n+    /**\n+     * Gets the default closure.\n+     *\n+     * @return the default closure\n+     * @since 3.1\n+     */\n+    public Closure<? super E> getDefaultClosure() {\n+        return iDefault;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Transformer implementation calls the transformer whose predicate returns true,\n+ * like a switch statement.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SwitchTransformer<I, O> implements Transformer<I, O>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -6404460890903469332L;\n+\n+    /** The tests to consider */\n+    private final Predicate<? super I>[] iPredicates;\n+    /** The matching transformers to call */\n+    private final Transformer<? super I, ? extends O>[] iTransformers;\n+    /** The default transformer to call if no tests match */\n+    private final Transformer<? super I, ? extends O> iDefault;\n+\n+    /**\n+     * Factory method that performs validation and copies the parameter arrays.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param predicates  array of predicates, cloned, no nulls\n+     * @param transformers  matching array of transformers, cloned, no nulls\n+     * @param defaultTransformer  the transformer to use if no match, null means return null\n+     * @return the <code>chained</code> transformer\n+     * @throws IllegalArgumentException if array is null\n+     * @throws IllegalArgumentException if any element in the array is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers,\n+            final Transformer<? super I, ? extends O> defaultTransformer) {\n+        FunctorUtils.validate(predicates);\n+        FunctorUtils.validate(transformers);\n+        if (predicates.length != transformers.length) {\n+            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n+        }\n+        if (predicates.length == 0) {\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() :\n+                                                                     defaultTransformer);\n+        }\n+        return new SwitchTransformer<I, O>(FunctorUtils.copy(predicates),\n+                                           FunctorUtils.copy(transformers),\n+                                           defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param <I>  the input type\n+     * @param <O>  the output type\n+     * @param map  a map of predicates to transformers\n+     * @return the <code>switch</code> transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <I, O> Transformer<I, O> switchTransformer(\n+            final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n+\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n+        }\n+        if (map.size() == 0) {\n+            return ConstantTransformer.<I, O>nullTransformer();\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        final Transformer<? super I, ? extends O> defaultTransformer = map.remove(null);\n+        final int size = map.size();\n+        if (size == 0) {\n+            return (Transformer<I, O>) (defaultTransformer == null ? ConstantTransformer.<I, O>nullTransformer() :\n+                                                                     defaultTransformer);\n+        }\n+        final Transformer<? super I, ? extends O>[] transformers = new Transformer[size];\n+        final Predicate<? super I>[] preds = new Predicate[size];\n+        int i = 0;\n+        for (final Map.Entry<? extends Predicate<? super I>,\n+                             ? extends Transformer<? super I, ? extends O>> entry : map.entrySet()) {\n+            preds[i] = entry.getKey();\n+            transformers[i] = entry.getValue();\n+            i++;\n+        }\n+        return new SwitchTransformer<I, O>(preds, transformers, defaultTransformer);\n+    }\n+    \n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicates  array of predicates, not cloned, no nulls\n+     * @param transformers  matching array of transformers, not cloned, no nulls\n+     * @param defaultTransformer  the transformer to use if no match, null means return null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public SwitchTransformer(final Predicate<? super I>[] predicates,\n+            final Transformer<? super I, ? extends O>[] transformers,\n+            final Transformer<? super I, ? extends O> defaultTransformer) {\n+        super();\n+        iPredicates = predicates;\n+        iTransformers = transformers;\n+        iDefault = (Transformer<? super I, ? extends O>) (defaultTransformer == null ?\n+                ConstantTransformer.<I, O>nullTransformer() : defaultTransformer);\n+    }\n+\n+    /**\n+     * Transforms the input to result by calling the transformer whose matching\n+     * predicate returns true.\n+     * \n+     * @param input  the input object to transform\n+     * @return the transformed result\n+     */\n+    public O transform(final I input) {\n+        for (int i = 0; i < iPredicates.length; i++) {\n+            if (iPredicates[i].evaluate(input) == true) {\n+                return iTransformers[i].transform(input);\n+            }\n+        }\n+        return iDefault.transform(input);\n+    }\n+\n+    /**\n+     * Gets the predicates.\n+     * \n+     * @return a copy of the predicates\n+     * @since 3.1\n+     */\n+    public Predicate<? super I>[] getPredicates() {\n+        return FunctorUtils.<I>copy(iPredicates);\n+    }\n+\n+    /**\n+     * Gets the transformers.\n+     * \n+     * @return a copy of the transformers\n+     * @since 3.1\n+     */\n+    public Transformer<? super I, ? extends O>[] getTransformers() {\n+        return FunctorUtils.<I, O>copy(iTransformers);\n+    }\n+\n+    /**\n+     * Gets the default transformer.\n+     * \n+     * @return the default transformer\n+     * @since 3.1\n+     */\n+    public Transformer<? super I, ? extends O> getDefaultTransformer() {\n+        return iDefault;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Predicate implementation that transforms the given object before invoking\n+ * another <code>Predicate</code>.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public final class TransformedPredicate<T> implements Predicate<T>, PredicateDecorator<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -5596090919668315834L;\n+\n+    /** The transformer to call */\n+    private final Transformer<? super T, ? extends T> iTransformer;\n+\n+    /** The predicate to call */\n+    private final Predicate<? super T> iPredicate;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param transformer  the transformer to call\n+     * @param predicate  the predicate to call with the result of the transform\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer or the predicate is null\n+     */\n+    public static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer,\n+                                                        final Predicate<? super T> predicate) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate to call must not be null\");\n+        }\n+        return new TransformedPredicate<T>(transformer, predicate);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param transformer  the transformer to use\n+     * @param predicate  the predicate to decorate\n+     */\n+    public TransformedPredicate(final Transformer<? super T, ? extends T> transformer,\n+                                final Predicate<? super T> predicate) {\n+        iTransformer = transformer;\n+        iPredicate = predicate;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated predicate\n+     * once the input has been transformed\n+     *\n+     * @param object  the input object which will be transformed\n+     * @return true if decorated predicate returns true\n+     */\n+    public boolean evaluate(final T object) {\n+        final T result = iTransformer.transform(object);\n+        return iPredicate.evaluate(result);\n+    }\n+\n+    /**\n+     * Gets the predicate being decorated.\n+     *\n+     * @return the predicate as the only element in an array\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Predicate<? super T>[] getPredicates() {\n+        return new Predicate[] {iPredicate};\n+    }\n+\n+    /**\n+     * Gets the transformer in use.\n+     *\n+     * @return the transformer\n+     */\n+    public Transformer<? super T, ? extends T> getTransformer() {\n+        return iTransformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/TransformerClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Closure implementation that calls a Transformer using the input object\n+ * and ignore the result.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformerClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -5194992589193388969L;\n+\n+    /** The transformer to wrap */\n+    private final Transformer<? super E, ?> iTransformer;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * <p>\n+     * A null transformer will return the <code>NOPClosure</code>.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param transformer  the transformer to call, null means nop\n+     * @return the <code>transformer</code> closure\n+     */\n+    public static <E> Closure<E> transformerClosure(final Transformer<? super E, ?> transformer) {\n+        if (transformer == null) {\n+            return NOPClosure.<E>nopClosure();\n+        }\n+        return new TransformerClosure<E>(transformer);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param transformer  the transformer to call, not null\n+     */\n+    public TransformerClosure(final Transformer<? super E, ?> transformer) {\n+        super();\n+        iTransformer = transformer;\n+    }\n+\n+    /**\n+     * Executes the closure by calling the decorated transformer.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(final E input) {\n+        iTransformer.transform(input);\n+    }\n+\n+    /**\n+     * Gets the transformer.\n+     * \n+     * @return the transformer\n+     * @since 3.1\n+     */\n+    public Transformer<? super E, ?> getTransformer() {\n+        return iTransformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Predicate implementation that returns the result of a transformer.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class TransformerPredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -2407966402920578741L;\n+\n+    /** The transformer to call */\n+    private final Transformer<? super T, Boolean> iTransformer;\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @param transformer  the transformer to decorate\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the transformer is null\n+     */\n+    public static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+        }\n+        return new TransformerPredicate<T>(transformer);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     *\n+     * @param transformer  the transformer to decorate\n+     */\n+    public TransformerPredicate(final Transformer<? super T, Boolean> transformer) {\n+        super();\n+        iTransformer = transformer;\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning the result of the decorated transformer.\n+     *\n+     * @param object  the input object\n+     * @return true if decorated transformer returns Boolean.TRUE\n+     * @throws FunctorException if the transformer returns an invalid type\n+     */\n+    public boolean evaluate(final T object) {\n+        final Boolean result = iTransformer.transform(object);\n+        if (result == null) {\n+            throw new FunctorException(\n+                    \"Transformer must return an instanceof Boolean, it was a null object\");\n+        }\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * Gets the transformer.\n+     *\n+     * @return the transformer\n+     * @since 3.1\n+     */\n+    public Transformer<? super T, Boolean> getTransformer() {\n+        return iTransformer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/TruePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that always returns true.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class TruePredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = 3374767158756189740L;\n+\n+    /** Singleton predicate instance */\n+    public static final Predicate<?> INSTANCE = new TruePredicate<Object>();\n+\n+    /**\n+     * Factory returning the singleton instance.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @return the singleton instance\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> Predicate<T> truePredicate() {\n+        return (Predicate<T>) INSTANCE;\n+    }\n+\n+    /**\n+     * Restricted constructor.\n+     */\n+    private TruePredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true always.\n+     *\n+     * @param object  the input object\n+     * @return true always\n+     */\n+    public boolean evaluate(final T object) {\n+        return true;\n+    }\n+\n+    private Object readResolve() {\n+        return INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/UniquePredicate.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Predicate implementation that returns true the first time an object is\n+ * passed into the predicate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UniquePredicate<T> implements Predicate<T>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3319417438027438040L;\n+\n+    /** The set of previously seen objects */\n+    private final Set<T> iSet = new HashSet<T>();\n+\n+    /**\n+     * Factory to create the predicate.\n+     *\n+     * @param <T> the type that the predicate queries\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static <T> Predicate<T> uniquePredicate() {\n+        return new UniquePredicate<T>();\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     */\n+    public UniquePredicate() {\n+        super();\n+    }\n+\n+    /**\n+     * Evaluates the predicate returning true if the input object hasn't been\n+     * received yet.\n+     *\n+     * @param object  the input object\n+     * @return true if this is the first time the object is seen\n+     */\n+    public boolean evaluate(final T object) {\n+        return iSet.add(object);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Closure implementation that executes a closure repeatedly until a condition is met,\n+ * like a do-while or while loop.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class WhileClosure<E> implements Closure<E>, Serializable {\n+\n+    /** Serial version UID */\n+    private static final long serialVersionUID = -3110538116913760108L;\n+\n+    /** The test condition */\n+    private final Predicate<? super E> iPredicate;\n+    /** The closure to call */\n+    private final Closure<? super E> iClosure;\n+    /** The flag, true is a do loop, false is a while */\n+    private final boolean iDoLoop;\n+\n+    /**\n+     * Factory method that performs validation.\n+     * \n+     * @param <E> the type that the closure acts on\n+     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n+     * @param closure  the closure the execute, not null\n+     * @param doLoop  true to act as a do-while loop, always executing the closure once\n+     * @return the <code>while</code> closure\n+     * @throws IllegalArgumentException if the predicate or closure is null\n+     */\n+    public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate,\n+                                              final Closure<? super E> closure, final boolean doLoop) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null\");\n+        }\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"Closure must not be null\");\n+        }\n+        return new WhileClosure<E>(predicate, closure, doLoop);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want that.\n+     * \n+     * @param predicate  the predicate used to evaluate when the loop terminates, not null\n+     * @param closure  the closure the execute, not null\n+     * @param doLoop  true to act as a do-while loop, always executing the closure once\n+     */\n+    public WhileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure, final boolean doLoop) {\n+        super();\n+        iPredicate = predicate;\n+        iClosure = closure;\n+        iDoLoop = doLoop;\n+    }\n+\n+    /**\n+     * Executes the closure until the predicate is false.\n+     * \n+     * @param input  the input object\n+     */\n+    public void execute(final E input) {\n+        if (iDoLoop) {\n+            iClosure.execute(input);\n+        }\n+        while (iPredicate.evaluate(input)) {\n+            iClosure.execute(input);\n+        }\n+    }\n+\n+    /**\n+     * Gets the predicate in use.\n+     * \n+     * @return the predicate\n+     * @since 3.1\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return iPredicate;\n+    }\n+\n+    /**\n+     * Gets the closure.\n+     * \n+     * @return the closure\n+     * @since 3.1\n+     */\n+    public Closure<? super E> getClosure() {\n+        return iClosure;\n+    }\n+\n+    /**\n+     * Is the loop a do-while loop.\n+     * \n+     * @return true is do-while, false if while\n+     * @since 3.1\n+     */\n+    public boolean isDoLoop() {\n+        return iDoLoop;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/functors/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link org.apache.commons.collections4.Closure Closure},\n+ * {@link org.apache.commons.collections4.Predicate Predicate},\n+ * {@link org.apache.commons.collections4.Transformer Transformer} and\n+ * {@link org.apache.commons.collections4.Factory Factory} interfaces.\n+ * These provide simple callbacks for processing with collections.\n+ * \n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.functors;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.NoSuchElementException;\n+\n+/** \n+ * Provides an implementation of an empty iterator.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+abstract class AbstractEmptyIterator<E> {\n+ \n+    /**\n+     * Constructor.\n+     */\n+    protected AbstractEmptyIterator() {\n+        super();\n+    }\n+\n+    public boolean hasNext() {\n+        return false;\n+    }\n+\n+    public E next() {\n+        throw new NoSuchElementException(\"Iterator contains no elements\");\n+    }\n+\n+    public boolean hasPrevious() {\n+        return false;\n+    }\n+\n+    public E previous() {\n+        throw new NoSuchElementException(\"Iterator contains no elements\");\n+    }\n+\n+    public int nextIndex() {\n+        return 0;\n+    }\n+\n+    public int previousIndex() {\n+        return -1;\n+    }\n+\n+    public void add(final E obj) {\n+        throw new UnsupportedOperationException(\"add() not supported for empty Iterator\");\n+    }\n+\n+    public void set(final E obj) {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public void remove() {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public void reset() {\n+        // do nothing\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+/** \n+ * Provides an implementation of an empty map iterator.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractEmptyMapIterator<K, V> extends AbstractEmptyIterator<K> {\n+\n+    /**\n+     * Create a new AbstractEmptyMapIterator.\n+     */\n+    public AbstractEmptyMapIterator() {\n+        super();\n+    }\n+\n+    public K getKey() {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public V getValue() {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+    public V setValue(final V value) {\n+        throw new IllegalStateException(\"Iterator contains no elements\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Provides basic behaviour for decorating an iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated iterator.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractIteratorDecorator<E> extends AbstractUntypedIteratorDecorator<E, E> {\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractIteratorDecorator(final Iterator<E> iterator) {\n+        super(iterator);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public E next() {\n+        return getIterator().next();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+\n+/**\n+ * Provides basic behaviour for decorating a list iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated list iterator.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class AbstractListIteratorDecorator<E> implements ListIterator<E> {\n+\n+    /** The iterator being decorated */\n+    protected final ListIterator<E> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractListIteratorDecorator(final ListIterator<E> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"ListIterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected ListIterator<E> getListIterator() {\n+        return iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /** {@inheritDoc} */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public E next() {\n+        return iterator.next();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int nextIndex() {\n+        return iterator.nextIndex();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public E previous() {\n+        return iterator.previous();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int previousIndex() {\n+        return iterator.previousIndex();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(final E obj) {\n+        iterator.set(obj);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void add(final E obj) {\n+        iterator.add(obj);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.MapIterator;\n+\n+/**\n+ * Provides basic behaviour for decorating a map iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated map iterator.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class AbstractMapIteratorDecorator<K, V> implements MapIterator<K, V> {\n+\n+    /** The iterator being decorated */\n+    protected final MapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractMapIteratorDecorator(final MapIterator<K, V> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected MapIterator<K, V> getMapIterator() {\n+        return iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /** {@inheritDoc} */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public V setValue(final V obj) {\n+        return iterator.setValue(obj);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.OrderedMapIterator;\n+\n+/**\n+ * Provides basic behaviour for decorating an ordered map iterator with extra functionality.\n+ * <p>\n+ * All methods are forwarded to the decorated map iterator.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class AbstractOrderedMapIteratorDecorator<K, V> implements OrderedMapIterator<K, V> {\n+\n+    /** The iterator being decorated */\n+    protected final OrderedMapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that decorates the specified iterator.\n+     *\n+     * @param iterator  the iterator to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractOrderedMapIteratorDecorator(final OrderedMapIterator<K, V> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected OrderedMapIterator<K, V> getOrderedMapIterator() {\n+        return iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /** {@inheritDoc} */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public K previous() {\n+        return iterator.previous();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public V setValue(final V obj) {\n+        return iterator.setValue(obj);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Provides basic behaviour for decorating an iterator with extra functionality\n+ * without committing the generic type of the Iterator implementation.\n+ * <p>\n+ * All methods are forwarded to the decorated iterator.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractUntypedIteratorDecorator<I, O> implements Iterator<O> {\n+\n+    /** The iterator being decorated */\n+    protected final Iterator<I> iterator;\n+\n+    /**\n+     * Create a new AbstractUntypedIteratorDecorator.\n+     * \n+     * @param iterator  the iterator to decorate\n+     */\n+    protected AbstractUntypedIteratorDecorator(final Iterator<I> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"Iterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Gets the iterator being decorated.\n+     * \n+     * @return the decorated iterator\n+     */\n+    protected Iterator<I> getIterator() {\n+        return iterator;\n+    }\n+\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ArrayIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.lang.reflect.Array;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * Implements an {@link java.util.Iterator Iterator} over any array.\n+ * <p>\n+ * The array can be either an array of object or of primitives. If you know \n+ * that you have an object array, the \n+ * {@link org.apache.commons.collections4.iterators.ObjectArrayIterator ObjectArrayIterator}\n+ * class is a better choice, as it will perform better.\n+ * <p>\n+ * The iterator implements a {@link #reset} method, allowing the reset of \n+ * the iterator back to the start if required.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class ArrayIterator<E> implements ResettableIterator<E> {\n+\n+    /** The array to iterate over */    \n+    protected Object array;\n+    /** The start index to loop from */\n+    protected int startIndex = 0;\n+    /** The end index to loop to */\n+    protected int endIndex = 0;\n+    /** The current iterator index */\n+    protected int index = 0;\n+    \n+    // Constructors\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray(Object)} is  called to establish the array to iterate over.\n+     */\n+    public ArrayIterator() {\n+        super();\n+    }\n+   \n+    /**\n+     * Constructs an ArrayIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ArrayIterator(final Object array) {\n+        super();\n+        setArray(array);\n+    }\n+\n+    /**\n+     * Constructs an ArrayIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over.\n+     * @param startIndex  the index to start iterating at.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public ArrayIterator(final Object array, final int startIndex) {\n+        super();\n+        setArray(array);\n+        checkBound(startIndex, \"start\");\n+        this.startIndex = startIndex;\n+        this.index = startIndex;\n+    }\n+\n+    /**\n+     * Construct an ArrayIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over.\n+     * @param startIndex  the index to start iterating at.\n+     * @param endIndex  the index to finish iterating at.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if either index is invalid\n+     */\n+    public ArrayIterator(final Object array, final int startIndex, final int endIndex) {\n+        super();\n+        setArray(array);\n+        checkBound(startIndex, \"start\");\n+        checkBound(endIndex, \"end\");\n+        if (endIndex < startIndex) {\n+            throw new IllegalArgumentException(\"End index must not be less than start index.\");\n+        }\n+        this.startIndex = startIndex;\n+        this.endIndex = endIndex;\n+        this.index = startIndex;\n+    }\n+\n+    /**\n+     * Checks whether the index is valid or not.\n+     * \n+     * @param bound  the index to check\n+     * @param type  the index type (for error messages)\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected void checkBound(final int bound, final String type ) {\n+        if (bound > this.endIndex) {\n+            throw new ArrayIndexOutOfBoundsException(\n+              \"Attempt to make an ArrayIterator that \" + type +\n+              \"s beyond the end of the array. \"\n+            );\n+        }\n+        if (bound < 0) {\n+            throw new ArrayIndexOutOfBoundsException(\n+              \"Attempt to make an ArrayIterator that \" + type +\n+              \"s before the start of the array. \"\n+            );\n+        }\n+    }\n+\n+    // Iterator interface\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if there are more elements to return from the array.\n+     *\n+     * @return true if there is a next element to return\n+     */\n+    public boolean hasNext() {\n+        return index < endIndex;\n+    }\n+\n+    /**\n+     * Returns the next element in the array.\n+     *\n+     * @return the next element in the array\n+     * @throws NoSuchElementException if all the elements in the array\n+     *  have already been returned\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        return (E) Array.get(array, index++);\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() method is not supported\");\n+    }\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the array that this iterator is iterating over. \n+     *\n+     * @return the array this iterator iterates over, or <code>null</code> if\n+     *  the no-arg constructor was used and {@link #setArray(Object)} has never\n+     *  been called with a valid array.\n+     */\n+    public Object getArray() {\n+        return array;\n+    }\n+    \n+    /**\n+     * Sets the array that the ArrayIterator should iterate over.\n+     * <p>\n+     * If an array has previously been set (using the single-arg constructor\n+     * or this method) then that array is discarded in favour of this one.\n+     * Iteration is restarted at the start of the new array.\n+     * Although this can be used to reset iteration, the {@link #reset()} method\n+     * is a more effective choice.\n+     *\n+     * @param array the array that the iterator should iterate over.\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public void setArray(final Object array) {\n+        // Array.getLength throws IllegalArgumentException if the object is not\n+        // an array or NullPointerException if the object is null.  This call\n+        // is made before saving the array and resetting the index so that the\n+        // array iterator remains in a consistent state if the argument is not\n+        // an array or is null.\n+        this.endIndex = Array.getLength(array);\n+        this.startIndex = 0;\n+        this.array = array;\n+        this.index = 0;\n+    }\n+    \n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    public void reset() {\n+        this.index = this.startIndex;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ArrayListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.lang.reflect.Array;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * Implements a {@link ListIterator} over an array. \n+ * <p>\n+ * The array can be either an array of object or of primitives. If you know \n+ * that you have an object array, the {@link ObjectArrayListIterator}\n+ * class is a better choice, as it will perform better.\n+ *\n+ * <p>\n+ * This iterator does not support {@link #add(Object)} or {@link #remove()}, as the array \n+ * cannot be changed in size. The {@link #set(Object)} method is supported however.\n+ *\n+ * @see org.apache.commons.collections4.iterators.ArrayIterator\n+ * @see java.util.Iterator\n+ * @see java.util.ListIterator\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ArrayListIterator<E> extends ArrayIterator<E>\n+        implements ListIterator<E>, ResettableListIterator<E> {\n+\n+    /**\n+     * Holds the index of the last item returned by a call to <code>next()</code>\n+     * or <code>previous()</code>. This is set to <code>-1</code> if neither method\n+     * has yet been invoked. <code>lastItemIndex</code> is used to to implement \n+     * the {@link #set} method.\n+     *\n+     */\n+    protected int lastItemIndex = -1;\n+\n+    // Constructors\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray(Object)} is  called to establish the array to iterate over.\n+     */\n+    public ArrayListIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an ArrayListIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ArrayListIterator(final Object array) {\n+        super(array);\n+    }\n+\n+    /**\n+     * Constructs an ArrayListIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over\n+     * @param startIndex  the index to start iterating at\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the start index is out of bounds\n+     */\n+    public ArrayListIterator(final Object array, final int startIndex) {\n+        super(array, startIndex);\n+        this.startIndex = startIndex;\n+    }\n+\n+    /**\n+     * Construct an ArrayListIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over\n+     * @param startIndex  the index to start iterating at\n+     * @param endIndex  the index (exclusive) to finish iterating at\n+     * @throws IllegalArgumentException if <code>array</code> is not an array.\n+     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n+     * @throws IllegalArgumentException if end index is before the start\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ArrayListIterator(final Object array, final int startIndex, final int endIndex) {\n+        super(array, startIndex, endIndex);\n+        this.startIndex = startIndex;\n+    }\n+\n+    // ListIterator interface\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if there are previous elements to return from the array.\n+     *\n+     * @return true if there is a previous element to return\n+     */\n+    public boolean hasPrevious() {\n+        return this.index > this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the previous element from the array.\n+     * \n+     * @return the previous element\n+     * @throws NoSuchElementException if there is no previous element\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E previous() {\n+        if (hasPrevious() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = --this.index;\n+        return (E) Array.get(this.array, this.index);\n+    }\n+\n+    /**\n+     * Gets the next element from the array.\n+     * \n+     * @return the next element\n+     * @throws NoSuchElementException if there is no next element\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = this.index;\n+        return (E) Array.get(this.array, this.index++);\n+    }\n+\n+    /**\n+     * Gets the next index to be retrieved.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int nextIndex() {\n+        return this.index - this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the index of the item to be retrieved if {@link #previous()} is called.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int previousIndex() {\n+        return this.index - this.startIndex - 1;\n+    }\n+\n+    /**\n+     * This iterator does not support modification of its backing collection, and so will\n+     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n+     *\n+     * @param o  the element to add\n+     * @throws UnsupportedOperationException always thrown.\n+     * @see java.util.ListIterator#set\n+     */\n+    public void add(final Object o) {\n+        throw new UnsupportedOperationException(\"add() method is not supported\");\n+    }\n+\n+    /**\n+     * Sets the element under the cursor.\n+     * <p>\n+     * This method sets the element that was returned by the last call \n+     * to {@link #next()} of {@link #previous()}. \n+     * <p>\n+     * <b>Note:</b> {@link ListIterator} implementations that support\n+     * <code>add()</code> and <code>remove()</code> only allow <code>set()</code> to be called\n+     * once per call to <code>next()</code> or <code>previous</code> (see the {@link ListIterator}\n+     * javadoc for more details). Since this implementation does\n+     * not support <code>add()</code> or <code>remove()</code>, <code>set()</code> may be\n+     * called as often as desired.\n+     *\n+     * @param o  the element to set\n+     * @throws IllegalStateException if {@link #next()} or {@link #previous()} has not been called\n+     * before {@link #set(Object)}\n+     * @see java.util.ListIterator#set\n+     */\n+    public void set(final Object o) {\n+        if (this.lastItemIndex == -1) {\n+            throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n+        }\n+\n+        Array.set(this.array, this.lastItemIndex, o);\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    @Override\n+    public void reset() {\n+        super.reset();\n+        this.lastItemIndex = -1;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/CollatingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+\n+/**\n+ * Provides an ordered iteration over the elements contained in a collection of\n+ * ordered Iterators.\n+ * <p>\n+ * Given two ordered {@link Iterator} instances <code>A</code> and\n+ * <code>B</code>, the {@link #next} method on this iterator will return the\n+ * lesser of <code>A.next()</code> and <code>B.next()</code>.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class CollatingIterator<E> implements Iterator<E> {\n+\n+    /** The {@link Comparator} used to evaluate order. */\n+    private Comparator<? super E> comparator = null;\n+\n+    /** The list of {@link Iterator}s to evaluate. */\n+    private ArrayList<Iterator<? extends E>> iterators = null;\n+\n+    /** {@link Iterator#next Next} objects peeked from each iterator. */\n+    private ArrayList<E> values = null;\n+\n+    /** Whether or not each {@link #values} element has been set. */\n+    private BitSet valueSet = null;\n+\n+    /**\n+     * Index of the {@link #iterators iterator} from whom the last returned\n+     * value was obtained.\n+     */\n+    private int lastReturned = -1;\n+\n+    // Constructors\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>CollatingIterator</code>. A comparator must be\n+     * set by calling {@link #setComparator(Comparator)} before invoking\n+     * {@link #hasNext()}, or {@link #next()} for the first time. Child\n+     * iterators will have to be manually added using the\n+     * {@link #addIterator(Iterator)} method.\n+     */\n+    public CollatingIterator() {\n+        this(null, 2);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will used the\n+     * specified comparator for ordering. Child iterators will have to be\n+     * manually added using the {@link #addIterator(Iterator)} method.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp) {\n+        this(comp, 2);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will used the\n+     * specified comparator for ordering and have the specified initial\n+     * capacity. Child iterators will have to be manually added using the\n+     * {@link #addIterator(Iterator)} method.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param initIterCapacity the initial capacity for the internal list of\n+     * child iterators\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final int initIterCapacity) {\n+        iterators = new ArrayList<Iterator<? extends E>>(initIterCapacity);\n+        setComparator(comp);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will use the\n+     * specified comparator to provide ordered iteration over the two given\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param a the first child ordered iterator\n+     * @param b the second child ordered iterator\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E> a,\n+                             final Iterator<? extends E> b) {\n+        this(comp, 2);\n+        addIterator(a);\n+        addIterator(b);\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will use the\n+     * specified comparator to provide ordered iteration over the array of\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param iterators the array of iterators\n+     * @throws NullPointerException if iterators array is or contains null\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Iterator<? extends E>[] iterators) {\n+        this(comp, iterators.length);\n+        for (final Iterator<? extends E> iterator : iterators) {\n+            addIterator(iterator);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>CollatingIterator</code> that will use the\n+     * specified comparator to provide ordered iteration over the collection of\n+     * iterators.\n+     * \n+     * @param comp the comparator to use to sort; must not be null,\n+     *   unless you'll be invoking {@link #setComparator(Comparator)}\n+     *   later on.\n+     * @param iterators the collection of iterators\n+     * @throws NullPointerException if the iterators collection is or contains\n+     * null\n+     * @throws ClassCastException if the iterators collection contains an\n+     * element that's not an {@link Iterator}\n+     */\n+    public CollatingIterator(final Comparator<? super E> comp, final Collection<Iterator<? extends E>> iterators) {\n+        this(comp, iterators.size());\n+        for (final Iterator<? extends E> iterator : iterators) {\n+            addIterator(iterator);\n+        }\n+    }\n+\n+    // Public Methods\n+    // ----------------------------------------------------------------------\n+    /**\n+     * Adds the given {@link Iterator} to the iterators being collated.\n+     * \n+     * @param iterator the iterator to add to the collation, must not be null\n+     * @throws IllegalStateException if iteration has started\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void addIterator(final Iterator<? extends E> iterator) {\n+        checkNotStarted();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iterators.add(iterator);\n+    }\n+\n+    /**\n+     * Sets the iterator at the given index.\n+     * \n+     * @param index index of the Iterator to replace\n+     * @param iterator Iterator to place at the given index\n+     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n+     * @throws IllegalStateException if iteration has started\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void setIterator(final int index, final Iterator<? extends E> iterator) {\n+        checkNotStarted();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iterators.set(index, iterator);\n+    }\n+\n+    /**\n+     * Gets the list of Iterators (unmodifiable).\n+     * \n+     * @return the unmodifiable list of iterators added\n+     */\n+    public List<Iterator<? extends E>> getIterators() {\n+        return UnmodifiableList.unmodifiableList(iterators);\n+    }\n+\n+    /**\n+     * Gets the {@link Comparator} by which collatation occurs.\n+     * \n+     * @return the {@link Comparator}\n+     */\n+    public Comparator<? super E> getComparator() {\n+        return comparator;\n+    }\n+\n+    /**\n+     * Sets the {@link Comparator} by which collation occurs. If you\n+     * would like to use the natural sort order (or, in other words,\n+     * if the elements in the iterators are implementing the\n+     * {@link java.lang.Comparable} interface), then use the\n+     * {@link org.apache.commons.collections4.comparators.ComparableComparator}.\n+     * \n+     * @param comp the {@link Comparator} to set\n+     * @throws IllegalStateException if iteration has started\n+     */\n+    public void setComparator(final Comparator<? super E> comp) {\n+        checkNotStarted();\n+        comparator = comp;\n+    }\n+\n+    // Iterator Methods\n+    // -------------------------------------------------------------------\n+    /**\n+     * Returns <code>true</code> if any child iterator has remaining elements.\n+     * \n+     * @return true if this iterator has remaining elements\n+     */\n+    public boolean hasNext() {\n+        start();\n+        return anyValueSet(valueSet) || anyHasNext(iterators);\n+    }\n+\n+    /**\n+     * Returns the next ordered element from a child iterator.\n+     * \n+     * @return the next ordered element\n+     * @throws NoSuchElementException if no child iterator has any more elements\n+     */\n+    public E next() throws NoSuchElementException {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        final int leastIndex = least();\n+        if (leastIndex == -1) {\n+            throw new NoSuchElementException();\n+        }\n+        final E val = values.get(leastIndex);\n+        clear(leastIndex);\n+        lastReturned = leastIndex;\n+        return val;\n+    }\n+\n+    /**\n+     * Removes the last returned element from the child iterator that produced\n+     * it.\n+     * \n+     * @throws IllegalStateException if there is no last returned element, or if\n+     * the last returned element has already been removed\n+     */\n+    public void remove() {\n+        if (lastReturned == -1) {\n+            throw new IllegalStateException(\"No value can be removed at present\");\n+        }\n+        iterators.get(lastReturned).remove();\n+    }\n+\n+    /**\n+     * Returns the index of the iterator that returned the last element.\n+     * \n+     * @return the index of the iterator that returned the last element\n+     * @throws IllegalStateException if there is no last returned element\n+     */\n+    public int getIteratorIndex() {\n+        if (lastReturned == -1) {\n+            throw new IllegalStateException(\"No value has been returned yet\");\n+        }\n+        \n+        return lastReturned;\n+    }\n+    \n+    // Private Methods\n+    // -------------------------------------------------------------------\n+    /**\n+     * Initializes the collating state if it hasn't been already.\n+     */\n+    private void start() {\n+        if (values == null) {\n+            values = new ArrayList<E>(iterators.size());\n+            valueSet = new BitSet(iterators.size());\n+            for (int i = 0; i < iterators.size(); i++) {\n+                values.add(null);\n+                valueSet.clear(i);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets the {@link #values} and {@link #valueSet} attributes at position\n+     * <i>i</i> to the next value of the {@link #iterators iterator} at position\n+     * <i>i</i>, or clear them if the <i>i</i><sup>th</sup> iterator has no next\n+     * value.\n+     * \n+     * @return <tt>false</tt> iff there was no value to set\n+     */\n+    private boolean set(final int i) {\n+        final Iterator<? extends E> it = iterators.get(i);\n+        if (it.hasNext()) {\n+            values.set(i, it.next());\n+            valueSet.set(i);\n+            return true;\n+        }\n+        values.set(i, null);\n+        valueSet.clear(i);\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the {@link #values} and {@link #valueSet} attributes at position\n+     * <i>i</i>.\n+     */\n+    private void clear(final int i) {\n+        values.set(i, null);\n+        valueSet.clear(i);\n+    }\n+\n+    /**\n+     * Throws {@link IllegalStateException} if iteration has started via\n+     * {@link #start}.\n+     * \n+     * @throws IllegalStateException if iteration started\n+     */\n+    private void checkNotStarted() throws IllegalStateException {\n+        if (values != null) {\n+            throw new IllegalStateException(\"Can't do that after next or hasNext has been called.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the index of the least element in {@link #values},\n+     * {@link #set(int) setting} any uninitialized values.\n+     * \n+     * @throws NullPointerException if no comparator is set\n+     */\n+    private int least() {\n+        int leastIndex = -1;\n+        E leastObject = null;\n+        for (int i = 0; i < values.size(); i++) {\n+            if (valueSet.get(i) == false) {\n+                set(i);\n+            }\n+            if (valueSet.get(i)) {\n+                if (leastIndex == -1) {\n+                    leastIndex = i;\n+                    leastObject = values.get(i);\n+                } else {\n+                    final E curObject = values.get(i);\n+                    if (comparator == null) {\n+                        throw new NullPointerException(\"You must invoke setComparator() to set a comparator first.\");\n+                    }\n+                    if (comparator.compare(curObject, leastObject) < 0) {\n+                        leastObject = curObject;\n+                        leastIndex = i;\n+                    }\n+                }\n+            }\n+        }\n+        return leastIndex;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff any bit in the given set is\n+     * <code>true</code>.\n+     */\n+    private boolean anyValueSet(final BitSet set) {\n+        for (int i = 0; i < set.size(); i++) {\n+            if (set.get(i)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff any {@link Iterator} in the given list has\n+     * a next value.\n+     */\n+    private boolean anyHasNext(final ArrayList<Iterator<? extends E>> iters) {\n+        for (final Iterator<? extends E> iterator : iters) {\n+            if (iterator.hasNext()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EmptyIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty iterator.\n+ * <p>\n+ * This class provides an implementation of an empty iterator.\n+ * This class provides for binary compatibility between Commons Collections\n+ * 2.1.1 and 3.1 due to issues with <code>IteratorUtils</code>.\n+ *\n+ * @since 2.1.1 and 3.1\n+ * @version $Id$\n+ */\n+public class EmptyIterator<E> extends AbstractEmptyIterator<E> implements ResettableIterator<E> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 3.1\n+     */\n+    public static final ResettableIterator<Object> RESETTABLE_INSTANCE = new EmptyIterator<Object>();\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 2.1.1 and 3.1\n+     */\n+    public static final Iterator<Object> INSTANCE = RESETTABLE_INSTANCE;\n+\n+    /**\n+     * Get a typed resettable empty iterator instance.\n+     * @param <E> the element type\n+     * @return ResettableIterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ResettableIterator<E> resettableEmptyIterator() {\n+        return (ResettableIterator<E>) RESETTABLE_INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed empty iterator instance.\n+     * @param <E> the element type\n+     * @return Iterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Iterator<E> emptyIterator() {\n+        return (Iterator<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EmptyListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * Provides an implementation of an empty list iterator.\n+ * <p>\n+ * This class provides an implementation of an empty list iterator. This class\n+ * provides for binary compatibility between Commons Collections 2.1.1 and 3.1\n+ * due to issues with <code>IteratorUtils</code>.\n+ *\n+ * @since 2.1.1 and 3.1\n+ * @version $Id$\n+ */\n+public class EmptyListIterator<E> extends AbstractEmptyIterator<E> implements\n+        ResettableListIterator<E> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 3.1\n+     */\n+    public static final ResettableListIterator<Object> RESETTABLE_INSTANCE = new EmptyListIterator<Object>();\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 2.1.1 and 3.1\n+     */\n+    public static final ListIterator<Object> INSTANCE = RESETTABLE_INSTANCE;\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <E> the element type\n+     * @return {@link ResettableListIterator}<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ResettableListIterator<E> resettableEmptyListIterator() {\n+        return (ResettableListIterator<E>) RESETTABLE_INSTANCE;\n+    }\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <E> the element type\n+     * @return {@link ListIterator}<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> ListIterator<E> emptyListIterator() {\n+        return (ListIterator<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyListIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EmptyMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty map iterator.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class EmptyMapIterator<K, V> extends AbstractEmptyMapIterator<K, V> implements\n+        MapIterator<K, V>, ResettableIterator<K> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 3.1\n+     */\n+    public static final MapIterator<Object, Object> INSTANCE = new EmptyMapIterator<Object, Object>();\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return {@link MapIterator}<K, V>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> MapIterator<K, V> emptyMapIterator() {\n+        return (MapIterator<K, V>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyMapIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.OrderedIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty ordered iterator.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class EmptyOrderedIterator<E> extends AbstractEmptyIterator<E>\n+        implements OrderedIterator<E>, ResettableIterator<E> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 3.1\n+     */\n+    public static final OrderedIterator<Object> INSTANCE = new EmptyOrderedIterator<Object>();\n+\n+    /**\n+     * Typed instance of the iterator.\n+     * @param <E> the element type\n+     * @return OrderedIterator<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> OrderedIterator<E> emptyOrderedIterator() {\n+        return (OrderedIterator<E>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyOrderedIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EmptyOrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * Provides an implementation of an empty ordered map iterator.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class EmptyOrderedMapIterator<K, V> extends AbstractEmptyMapIterator<K, V>\n+        implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+    /**\n+     * Singleton instance of the iterator.\n+     * @since 3.1\n+     */\n+    public static final OrderedMapIterator<Object, Object> INSTANCE = new EmptyOrderedMapIterator<Object, Object>();\n+\n+    /**\n+     * Get a typed instance of the iterator.\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return {@link OrderedMapIterator}<K, V>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> OrderedMapIterator<K, V> emptyOrderedMapIterator() {\n+        return (OrderedMapIterator<K, V>) INSTANCE;\n+    }\n+\n+    /**\n+     * Constructor.\n+     */\n+    protected EmptyOrderedMapIterator() {\n+        super();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EntrySetMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/**\n+ * Implements a <code>MapIterator</code> using a Map entrySet.\n+ * Reverse iteration is not supported.\n+ * <pre>\n+ * MapIterator it = map.mapIterator();\n+ * while (it.hasNext()) {\n+ *   Object key = it.next();\n+ *   Object value = it.getValue();\n+ *   it.setValue(newValue);\n+ * }\n+ * </pre>\n+ *  \n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class EntrySetMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+    \n+    private final Map<K, V> map;\n+    private Iterator<Map.Entry<K, V>> iterator;\n+    private Map.Entry<K, V> last;\n+    private boolean canRemove = false;\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param map  the map to iterate over\n+     */\n+    public EntrySetMapIterator(final Map<K, V> map) {\n+        super();\n+        this.map = map;\n+        this.iterator = map.entrySet().iterator();\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Checks to see if there are more entries still to be iterated.\n+     *\n+     * @return <code>true</code> if the iterator has more elements\n+     */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Gets the next <em>key</em> from the <code>Map</code>.\n+     *\n+     * @return the next key in the iteration\n+     * @throws java.util.NoSuchElementException if the iteration is finished\n+     */\n+    public K next() {\n+        last = iterator.next();\n+        canRemove = true;\n+        return last.getKey();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes the last returned key from the underlying <code>Map</code>.\n+     * <p>\n+     * This method can be called once per call to <code>next()</code>.\n+     *\n+     * @throws UnsupportedOperationException if remove is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has already been called\n+     *  since the last call to <code>next()</code>\n+     */\n+    public void remove() {\n+        if (canRemove == false) {\n+            throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+        }\n+        iterator.remove();\n+        last = null;\n+        canRemove = false;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the current key, which is the key returned by the last call\n+     * to <code>next()</code>.\n+     *\n+     * @return the current key\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    public K getKey() {\n+        if (last == null) {\n+            throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+        }\n+        return last.getKey();\n+    }\n+\n+    /**\n+     * Gets the current value, which is the value associated with the last key\n+     * returned by <code>next()</code>.\n+     *\n+     * @return the current value\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     */\n+    public V getValue() {\n+        if (last == null) {\n+            throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+        }\n+        return last.getValue();\n+    }\n+\n+    /**\n+     * Sets the value associated with the current key.\n+     *\n+     * @param value  the new value\n+     * @return the previous value\n+     * @throws UnsupportedOperationException if setValue is not supported by the map\n+     * @throws IllegalStateException if <code>next()</code> has not yet been called\n+     * @throws IllegalStateException if <code>remove()</code> has been called since the\n+     *  last call to <code>next()</code>\n+     */\n+    public V setValue(final V value) {\n+        if (last == null) {\n+            throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+        }\n+        return last.setValue(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Resets the state of the iterator.\n+     */\n+    public void reset() {\n+        iterator = map.entrySet().iterator();\n+        last = null;\n+        canRemove = false;\n+    }\n+    \n+    /**\n+     * Gets the iterator as a String.\n+     * \n+     * @return a string version of the iterator\n+     */    \n+    @Override\n+    public String toString() {\n+        if (last != null) {\n+            return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+        }\n+        return \"MapIterator[]\";\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/EnumerationIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/** \n+ * Adapter to make {@link Enumeration Enumeration} instances appear\n+ * to be {@link Iterator Iterator} instances.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class EnumerationIterator<E> implements Iterator<E> {\n+    \n+    /** The collection to remove elements from */\n+    private final Collection<? super E> collection;\n+    /** The enumeration being converted */\n+    private Enumeration<? extends E> enumeration;\n+    /** The last object retrieved */\n+    private E last;\n+    \n+    // Constructors\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>EnumerationIterator</code> that will not\n+     * function until {@link #setEnumeration(Enumeration)} is called.\n+     */\n+    public EnumerationIterator() {\n+        this(null, null);\n+    }\n+\n+    /**\n+     * Constructs a new <code>EnumerationIterator</code> that provides\n+     * an iterator view of the given enumeration.\n+     *\n+     * @param enumeration  the enumeration to use\n+     */\n+    public EnumerationIterator(final Enumeration<? extends E> enumeration) {\n+        this(enumeration, null);\n+    }\n+\n+    /**\n+     * Constructs a new <code>EnumerationIterator</code> that will remove\n+     * elements from the specified collection.\n+     *\n+     * @param enumeration  the enumeration to use\n+     * @param collection  the collection to remove elements from\n+     */\n+    public EnumerationIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> collection) {\n+        super();\n+        this.enumeration = enumeration;\n+        this.collection = collection;\n+        this.last = null;\n+    }\n+\n+    // Iterator interface\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if the underlying enumeration has more elements.\n+     *\n+     * @return true if the underlying enumeration has more elements\n+     * @throws NullPointerException  if the underlying enumeration is null\n+     */\n+    public boolean hasNext() {\n+        return enumeration.hasMoreElements();\n+    }\n+\n+    /**\n+     * Returns the next object from the enumeration.\n+     *\n+     * @return the next object from the enumeration\n+     * @throws NullPointerException if the enumeration is null\n+     */\n+    public E next() {\n+        last = enumeration.nextElement();\n+        return last;\n+    }\n+\n+    /**\n+     * Removes the last retrieved element if a collection is attached.\n+     * <p>\n+     * Functions if an associated <code>Collection</code> is known.\n+     * If so, the first occurrence of the last returned object from this\n+     * iterator will be removed from the collection.\n+     *\n+     * @exception IllegalStateException <code>next()</code> not called.\n+     * @exception UnsupportedOperationException if no associated collection\n+     */\n+    public void remove() {\n+        if (collection != null) {\n+            if (last != null) {\n+                collection.remove(last);\n+            } else {\n+                throw new IllegalStateException(\"next() must have been called for remove() to function\");\n+            }\n+        } else {\n+            throw new UnsupportedOperationException(\"No Collection associated with this Iterator\");\n+        }\n+    }\n+\n+    // Properties\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the underlying enumeration.\n+     *\n+     * @return the underlying enumeration\n+     */\n+    public Enumeration<? extends E> getEnumeration() {\n+        return enumeration;\n+    }\n+\n+    /**\n+     * Sets the underlying enumeration.\n+     *\n+     * @param enumeration  the new underlying enumeration\n+     */\n+    public void setEnumeration(final Enumeration<? extends E> enumeration) {\n+        this.enumeration = enumeration;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/FilterIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/** \n+ * Decorates another {@link Iterator} using a predicate to filter elements.\n+ * <p>\n+ * This iterator decorates the underlying iterator, only allowing through\n+ * those elements that match the specified {@link Predicate Predicate}.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class FilterIterator<E> implements Iterator<E> {\n+\n+    /** The iterator being used */\n+    private Iterator<? extends E> iterator;\n+    /** The predicate being used */\n+    private Predicate<? super E> predicate;\n+    /** The next object in the iteration */\n+    private E nextObject;\n+    /** Whether the next object has been calculated yet */\n+    private boolean nextObjectSet = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>FilterIterator</code> that will not function\n+     * until {@link #setIterator(Iterator) setIterator} is invoked.\n+     */\n+    public FilterIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterIterator</code> that will not function\n+     * until {@link #setPredicate(Predicate) setPredicate} is invoked.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public FilterIterator(final Iterator<? extends E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterIterator</code> that will use the\n+     * given iterator and predicate.\n+     *\n+     * @param iterator  the iterator to use\n+     * @param predicate  the predicate to use\n+     */\n+    public FilterIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n+        super();\n+        this.iterator = iterator;\n+        this.predicate = predicate;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Returns true if the underlying iterator contains an object that \n+     * matches the predicate.\n+     *\n+     * @return true if there is another object that matches the predicate\n+     * @throws NullPointerException if either the iterator or predicate are null\n+     */\n+    public boolean hasNext() {\n+        return nextObjectSet || setNextObject();\n+    }\n+\n+    /** \n+     * Returns the next object that matches the predicate.\n+     *\n+     * @return the next object which matches the given predicate\n+     * @throws NullPointerException if either the iterator or predicate are null\n+     * @throws NoSuchElementException if there are no more elements that\n+     *  match the predicate \n+     */\n+    public E next() {\n+        if (!nextObjectSet) {\n+            if (!setNextObject()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        nextObjectSet = false;\n+        return nextObject;\n+    }\n+\n+    /**\n+     * Removes from the underlying collection of the base iterator the last\n+     * element returned by this iterator.\n+     * This method can only be called\n+     * if <code>next()</code> was called, but not after\n+     * <code>hasNext()</code>, because the <code>hasNext()</code> call\n+     * changes the base iterator.\n+     *\n+     * @throws IllegalStateException if <code>hasNext()</code> has already\n+     *  been called.\n+     */\n+    public void remove() {\n+        if (nextObjectSet) {\n+            throw new IllegalStateException(\"remove() cannot be called\");\n+        }\n+        iterator.remove();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the iterator this iterator is using.\n+     *\n+     * @return the iterator\n+     */\n+    public Iterator<? extends E> getIterator() {\n+        return iterator;\n+    }\n+\n+    /** \n+     * Sets the iterator for this iterator to use.\n+     * If iteration has started, this effectively resets the iterator.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public void setIterator(final Iterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+        nextObject = null;\n+        nextObjectSet = false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the predicate this iterator is using.\n+     *\n+     * @return the predicate\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return predicate;\n+    }\n+\n+    /** \n+     * Sets the predicate this the iterator to use.\n+     *\n+     * @param predicate  the predicate to use\n+     */\n+    public void setPredicate(final Predicate<? super E> predicate) {\n+        this.predicate = predicate;\n+        nextObject = null;\n+        nextObjectSet = false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set nextObject to the next object. If there are no more \n+     * objects then return false. Otherwise, return true.\n+     */\n+    private boolean setNextObject() {\n+        while (iterator.hasNext()) {\n+            final E object = iterator.next();\n+            if (predicate.evaluate(object)) {\n+                nextObject = object;\n+                nextObjectSet = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/FilterListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/** \n+ * Decorates another {@link ListIterator} using a predicate to filter elements.\n+ * <p>\n+ * This iterator decorates the underlying iterator, only allowing through\n+ * those elements that match the specified {@link Predicate Predicate}.\n+ *\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class FilterListIterator<E> implements ListIterator<E> {\n+\n+    /** The iterator being used */\n+    private ListIterator<? extends E> iterator;\n+    \n+    /** The predicate being used */\n+    private Predicate<? super E> predicate;\n+\n+    /** \n+     * The value of the next (matching) object, when \n+     * {@link #nextObjectSet} is true. \n+     */\n+    private E nextObject;\n+\n+    /** \n+     * Whether or not the {@link #nextObject} has been set\n+     * (possibly to <code>null</code>). \n+     */\n+    private boolean nextObjectSet = false;   \n+\n+    /** \n+     * The value of the previous (matching) object, when \n+     * {@link #previousObjectSet} is true. \n+     */\n+    private E previousObject;\n+\n+    /** \n+     * Whether or not the {@link #previousObject} has been set\n+     * (possibly to <code>null</code>). \n+     */\n+    private boolean previousObjectSet = false;   \n+\n+    /** \n+     * The index of the element that would be returned by {@link #next}.\n+     */\n+    private int nextIndex = 0;\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>FilterListIterator</code> that will not function\n+     * until {@link #setListIterator(ListIterator) setListIterator}\n+     * and {@link #setPredicate(Predicate) setPredicate} are invoked.\n+     */\n+    public FilterListIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterListIterator</code> that will not \n+     * function until {@link #setPredicate(Predicate) setPredicate} is invoked.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public FilterListIterator(final ListIterator<? extends E> iterator ) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterListIterator</code>.\n+     *\n+     * @param iterator  the iterator to use\n+     * @param predicate  the predicate to use\n+     */\n+    public FilterListIterator(final ListIterator<? extends E> iterator, final Predicate<? super E> predicate) {\n+        super();\n+        this.iterator = iterator;\n+        this.predicate = predicate;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FilterListIterator</code> that will not function\n+     * until {@link #setListIterator(ListIterator) setListIterator} is invoked.\n+     *\n+     * @param predicate  the predicate to use.\n+     */\n+    public FilterListIterator(final Predicate<? super E> predicate) {\n+        super();\n+        this.predicate = predicate;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** Not supported. */\n+    public void add(final E o) {\n+        throw new UnsupportedOperationException(\"FilterListIterator.add(Object) is not supported.\");\n+    }\n+\n+    public boolean hasNext() {\n+        return nextObjectSet || setNextObject();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return previousObjectSet || setPreviousObject();\n+    }\n+\n+    public E next() {\n+        if (!nextObjectSet) {\n+            if (!setNextObject()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        nextIndex++;\n+        final E temp = nextObject;\n+        clearNextObject();\n+        return temp;\n+    }\n+\n+    public int nextIndex() {\n+        return nextIndex;\n+    }\n+\n+    public E previous() {\n+        if (!previousObjectSet) {\n+            if (!setPreviousObject()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        nextIndex--;\n+        final E temp = previousObject;\n+        clearPreviousObject();\n+        return temp;\n+    }\n+\n+    public int previousIndex() {\n+        return nextIndex-1;\n+    }\n+\n+    /** Not supported. */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"FilterListIterator.remove() is not supported.\");\n+    }\n+\n+    /** Not supported. */\n+    public void set(final E o) {\n+        throw new UnsupportedOperationException(\"FilterListIterator.set(Object) is not supported.\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the iterator this iterator is using.\n+     * \n+     * @return the iterator.\n+     */\n+    public ListIterator<? extends E> getListIterator() {\n+        return iterator;\n+    }\n+\n+    /** \n+     * Sets the iterator for this iterator to use.\n+     * If iteration has started, this effectively resets the iterator.\n+     * \n+     * @param iterator  the iterator to use\n+     */\n+    public void setListIterator(final ListIterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the predicate this iterator is using.\n+     * \n+     * @return the predicate.\n+     */\n+    public Predicate<? super E> getPredicate() {\n+        return predicate;\n+    }\n+\n+    /** \n+     * Sets the predicate this the iterator to use.\n+     * \n+     * @param predicate  the transformer to use\n+     */\n+    public void setPredicate(final Predicate<? super E> predicate) {\n+        this.predicate = predicate;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private void clearNextObject() {\n+        nextObject = null;\n+        nextObjectSet = false;\n+    }\n+\n+    private boolean setNextObject() {\n+        // if previousObjectSet,\n+        // then we've walked back one step in the \n+        // underlying list (due to a hasPrevious() call)\n+        // so skip ahead one matching object\n+        if (previousObjectSet) {\n+            clearPreviousObject();\n+            if (!setNextObject()) {\n+                return false;\n+            }\n+            clearNextObject();\n+        }\n+\n+        if (iterator == null) {\n+            return false;\n+        }\n+        while (iterator.hasNext()) {\n+            final E object = iterator.next();\n+            if (predicate.evaluate(object)) {\n+                nextObject = object;\n+                nextObjectSet = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private void clearPreviousObject() {\n+        previousObject = null;\n+        previousObjectSet = false;\n+    }\n+\n+    private boolean setPreviousObject() {\n+        // if nextObjectSet,\n+        // then we've walked back one step in the \n+        // underlying list (due to a hasNext() call)\n+        // so skip ahead one matching object\n+        if (nextObjectSet) {\n+            clearNextObject();\n+            if (!setPreviousObject()) {\n+                return false;\n+            }\n+            clearPreviousObject();\n+        }\n+\n+        if (iterator == null) {\n+            return false;\n+        }\n+        while (iterator.hasPrevious()) {\n+            final E object = iterator.previous();\n+            if (predicate.evaluate(object)) {\n+                previousObject = object;\n+                previousObjectSet = true;\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/IteratorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * An IteratorChain is an Iterator that wraps a number of Iterators.\n+ * <p>\n+ * This class makes multiple iterators look like one to the caller. When any\n+ * method from the Iterator interface is called, the IteratorChain will delegate\n+ * to a single underlying Iterator. The IteratorChain will invoke the Iterators\n+ * in sequence until all Iterators are exhausted.\n+ * <p>\n+ * Under many circumstances, linking Iterators together in this manner is more\n+ * efficient (and convenient) than reading out the contents of each Iterator\n+ * into a List and creating a new Iterator.\n+ * <p>\n+ * Calling a method that adds new Iterator <i>after a method in the Iterator\n+ * interface has been called</i> will result in an UnsupportedOperationException.\n+ * Subclasses should <i>take care</i> to not alter the underlying List of Iterators.\n+ * <p>\n+ * NOTE: As from version 3.0, the IteratorChain may contain no iterators. In\n+ * this case the class will function as an empty iterator.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class IteratorChain<E> implements Iterator<E> {\n+\n+    /** The chain of iterators */\n+    protected final List<Iterator<? extends E>> iteratorChain = new ArrayList<Iterator<? extends E>>();\n+\n+    /** The index of the current iterator */\n+    protected int currentIteratorIndex = 0;\n+\n+    /** The current iterator */\n+    protected Iterator<? extends E> currentIterator = null;\n+\n+    /**\n+     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n+     * was most recently called used for the remove() operation only\n+     */\n+    protected Iterator<? extends E> lastUsedIterator = null;\n+\n+    /**\n+     * ComparatorChain is \"locked\" after the first time compare(Object,Object)\n+     * is called\n+     */\n+    protected boolean isLocked = false;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Construct an IteratorChain with no Iterators.\n+     * <p>\n+     * You will normally use {@link #addIterator(Iterator)} to add some\n+     * iterators after using this constructor.\n+     */\n+    public IteratorChain() {\n+        super();\n+    }\n+\n+    /**\n+     * Construct an IteratorChain with a single Iterator.\n+     * <p>\n+     * This method takes one iterator. The newly constructed iterator will\n+     * iterate through that iterator. Thus calling this constructor on its own\n+     * will have no effect other than decorating the input iterator.\n+     * <p>\n+     * You will normally use {@link #addIterator(Iterator)} to add some more\n+     * iterators after using this constructor.\n+     * \n+     * @param iterator the first child iterator in the IteratorChain, not null\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public IteratorChain(final Iterator<? extends E> iterator) {\n+        super();\n+        addIterator(iterator);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorChain</code> over the two given iterators.\n+     * <p>\n+     * This method takes two iterators. The newly constructed iterator will\n+     * iterate through each one of the input iterators in turn.\n+     * \n+     * @param first the first child iterator in the IteratorChain, not null\n+     * @param second the second child iterator in the IteratorChain, not null\n+     * @throws NullPointerException if either iterator is null\n+     */\n+    public IteratorChain(final Iterator<? extends E> first, final Iterator<? extends E> second) {\n+        super();\n+        addIterator(first);\n+        addIterator(second);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorChain</code> over the array of iterators.\n+     * <p>\n+     * This method takes an array of iterators. The newly constructed iterator\n+     * will iterate through each one of the input iterators in turn.\n+     * \n+     * @param iteratorChain the array of iterators, not null\n+     * @throws NullPointerException if iterators array is or contains null\n+     */\n+    public IteratorChain(final Iterator<? extends E>... iteratorChain) {\n+        super();\n+        for (final Iterator<? extends E> element : iteratorChain) {\n+            addIterator(element);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorChain</code> over the collection of\n+     * iterators.\n+     * <p>\n+     * This method takes a collection of iterators. The newly constructed\n+     * iterator will iterate through each one of the input iterators in turn.\n+     * \n+     * @param iteratorChain the collection of iterators, not null\n+     * @throws NullPointerException if iterators collection is or contains null\n+     * @throws ClassCastException if iterators collection doesn't contain an\n+     * iterator\n+     */\n+    public IteratorChain(final Collection<Iterator<? extends E>> iteratorChain) {\n+        super();\n+        for (final Iterator<? extends E> iterator : iteratorChain) {\n+            addIterator(iterator);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Add an Iterator to the end of the chain\n+     * \n+     * @param iterator Iterator to add\n+     * @throws IllegalStateException if I've already started iterating\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void addIterator(final Iterator<? extends E> iterator) {\n+        checkLocked();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iteratorChain.add(iterator);\n+    }\n+\n+    /**\n+     * Set the Iterator at the given index\n+     * \n+     * @param index index of the Iterator to replace\n+     * @param iterator Iterator to place at the given index\n+     * @throws IndexOutOfBoundsException if index &lt; 0 or index &gt; size()\n+     * @throws IllegalStateException if I've already started iterating\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public void setIterator(final int index, final Iterator<? extends E> iterator)\n+            throws IndexOutOfBoundsException {\n+        checkLocked();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        iteratorChain.set(index, iterator);\n+    }\n+\n+    /**\n+     * Get the list of Iterators (unmodifiable)\n+     * \n+     * @return the unmodifiable list of iterators added\n+     */\n+    public List<Iterator<? extends E>> getIterators() {\n+        return UnmodifiableList.unmodifiableList(iteratorChain);\n+    }\n+\n+    /**\n+     * Number of Iterators in the current IteratorChain.\n+     * \n+     * @return Iterator count\n+     */\n+    public int size() {\n+        return iteratorChain.size();\n+    }\n+\n+    /**\n+     * Determine if modifications can still be made to the IteratorChain.\n+     * IteratorChains cannot be modified once they have executed a method from\n+     * the Iterator interface.\n+     * \n+     * @return true if IteratorChain cannot be modified, false if it can\n+     */\n+    public boolean isLocked() {\n+        return isLocked;\n+    }\n+\n+    /**\n+     * Checks whether the iterator chain is now locked and in use.\n+     */\n+    private void checkLocked() {\n+        if (isLocked == true) {\n+            throw new UnsupportedOperationException(\n+                    \"IteratorChain cannot be changed after the first use of a method from the Iterator interface\");\n+        }\n+    }\n+\n+    /**\n+     * Lock the chain so no more iterators can be added. This must be called\n+     * from all Iterator interface methods.\n+     */\n+    private void lockChain() {\n+        if (isLocked == false) {\n+            isLocked = true;\n+        }\n+    }\n+\n+    /**\n+     * Updates the current iterator field to ensure that the current Iterator is\n+     * not exhausted\n+     */\n+    protected void updateCurrentIterator() {\n+        if (currentIterator == null) {\n+            if (iteratorChain.isEmpty()) {\n+                currentIterator = EmptyIterator.<E> emptyIterator();\n+            } else {\n+                currentIterator = iteratorChain.get(0);\n+            }\n+            // set last used iterator here, in case the user calls remove\n+            // before calling hasNext() or next() (although they shouldn't)\n+            lastUsedIterator = currentIterator;\n+        }\n+\n+        while (currentIterator.hasNext() == false\n+                && currentIteratorIndex < iteratorChain.size() - 1) {\n+            currentIteratorIndex++;\n+            currentIterator = iteratorChain.get(currentIteratorIndex);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return true if any Iterator in the IteratorChain has a remaining element.\n+     * \n+     * @return true if elements remain\n+     */\n+    public boolean hasNext() {\n+        lockChain();\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+\n+        return currentIterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next Object of the current Iterator\n+     * \n+     * @return Object from the current Iterator\n+     * @throws java.util.NoSuchElementException if all the Iterators are\n+     * exhausted\n+     */\n+    public E next() {\n+        lockChain();\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+\n+        return currentIterator.next();\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned by the\n+     * Iterator. As with next() and hasNext(), this method calls remove() on the\n+     * underlying Iterator. Therefore, this method may throw an\n+     * UnsupportedOperationException if the underlying Iterator does not support\n+     * this method.\n+     * \n+     * @throws UnsupportedOperationException if the remove operator is not\n+     * supported by the underlying Iterator\n+     * @throws IllegalStateException if the next method has not yet been called,\n+     * or the remove method has already been called after the last call to the\n+     * next method.\n+     */\n+    public void remove() {\n+        lockChain();\n+        if (currentIterator == null) {\n+            updateCurrentIterator();\n+        }\n+        lastUsedIterator.remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/IteratorEnumeration.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Enumeration;\n+import java.util.Iterator;\n+\n+/**\n+ * Adapter to make an {@link Iterator Iterator} instance appear to be an\n+ * {@link Enumeration Enumeration} instance.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class IteratorEnumeration<E> implements Enumeration<E> {\n+\n+    /** The iterator being decorated. */\n+    private Iterator<? extends E> iterator;\n+\n+    /**\n+     * Constructs a new <code>IteratorEnumeration</code> that will not function\n+     * until {@link #setIterator(Iterator) setIterator} is invoked.\n+     */\n+    public IteratorEnumeration() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorEnumeration</code> that will use the given\n+     * iterator.\n+     * \n+     * @param iterator the iterator to use\n+     */\n+    public IteratorEnumeration(final Iterator<? extends E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true if the underlying iterator has more elements.\n+     * \n+     * @return true if the underlying iterator has more elements\n+     */\n+    public boolean hasMoreElements() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next element from the underlying iterator.\n+     * \n+     * @return the next element from the underlying iterator.\n+     * @throws java.util.NoSuchElementException if the underlying iterator has\n+     * no more elements\n+     */\n+    public E nextElement() {\n+        return iterator.next();\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns the underlying iterator.\n+     * \n+     * @return the underlying iterator\n+     */\n+    public Iterator<? extends E> getIterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Sets the underlying iterator.\n+     * \n+     * @param iterator the new underlying iterator\n+     */\n+    public void setIterator(final Iterator<? extends E> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/IteratorIterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/**\n+ * Adapter to make an {@link Iterator Iterator} instance appear to be an\n+ * {@link Iterable Iterable} instance.  The iterable can be constructed in one\n+ * of two variants:  single use, multiple use.\n+ * \n+ * <p>\n+ * In the single use iterable case, the iterable is only usable for one\n+ * iterative operation over the source iterator.  Subsequent iterative\n+ * operations use the same, exhausted source iterator.  To create a single use\n+ * iterable, construct a new {@link IteratorIterable} using a {@link Iterator}\n+ * that is NOT a {@link ResettableIterator} iterator:\n+ * <pre>\n+ *   Iterator<Integer> iterator = // some non-resettable iterator\n+ *   Iterable<Integer> iterable = new IteratorIterable<Integer>(iterator);\n+ * </pre>\n+ * </p>\n+ * \n+ * <p>\n+ * In the multiple use iterable case, the iterable is usable for any number of\n+ * iterative operations over the source iterator.  Of special note, even though\n+ * the iterable supports multiple iterations, it does not support concurrent\n+ * iterations. To implicitly create a multiple use iterable, construct a new\n+ * {@link IteratorIterable} using a {@link ResettableIterator} iterator:\n+ * <pre>\n+ *   Integer[] array = {Integer.valueOf(1),Integer.valueOf(2),Integer.valueOf(3)};\n+ *   Iterator<Integer> iterator = IteratorUtils.arrayIterator(array); // a resettable iterator\n+ *   Iterable<Integer> iterable = new IteratorIterable<Integer>(iterator);\n+ * </pre>\n+ * </p>\n+ * \n+ * <p>\n+ * A multiple use iterable can also be explicitly constructed using any\n+ * {@link Iterator} and specifying <code>true</code> for the\n+ * <code>multipleUse</code> flag:\n+ * <pre>\n+ *   Iterator<Integer> iterator = // some non-resettable iterator\n+ *   Iterable<Integer> iterable = new IteratorIterable<Integer>(iterator, true);\n+ * </pre>\n+ * </p>\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class IteratorIterable<E> implements Iterable<E> {\n+\n+    /**\n+     * Factory method to create an {@link Iterator Iterator} from another\n+     * iterator over objects of a different subtype.\n+     */\n+    private static <E> Iterator<E> createTypesafeIterator(\n+            final Iterator<? extends E> iterator) {\n+        return new Iterator<E>() {\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            public E next() {\n+                return iterator.next();\n+            }\n+\n+            public void remove() {\n+                iterator.remove();\n+            }\n+        };\n+    }\n+\n+    /** the iterator being adapted into an iterable. */\n+    private final Iterator<? extends E> iterator;\n+    \n+    /** the iterator parameterized as the {@link #iterator()} return type. */ \n+    private final Iterator<E> typeSafeIterator;\n+    \n+    /**\n+     * Constructs a new <code>IteratorIterable</code> that will use the given\n+     * iterator.\n+     * \n+     * @param iterator the iterator to use.\n+     */\n+    public IteratorIterable(final Iterator<? extends E> iterator) {\n+        this(iterator, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>IteratorIterable</code> that will use the given\n+     * iterator.\n+     * \n+     * @param iterator the iterator to use.\n+     * @param multipleUse <code>true</code> if the new iterable can be used in multiple iterations\n+     */\n+    public IteratorIterable(final Iterator<? extends E> iterator, final boolean multipleUse) {\n+        super();\n+        if (multipleUse && !(iterator instanceof ResettableIterator)) {\n+            this.iterator = new ListIteratorWrapper<E>(iterator); \n+        } else {\n+            this.iterator = iterator;\n+        }\n+        this.typeSafeIterator = createTypesafeIterator(this.iterator);\n+    }\n+\n+    /**\n+     * Gets the iterator wrapped by this iterable.\n+     * \n+     * @return the iterator\n+     */\n+    public Iterator<E> iterator() {\n+        if (iterator instanceof ResettableIterator) {\n+            ((ResettableIterator<? extends E>)iterator).reset();\n+        }\n+        return typeSafeIterator;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * An LazyIteratorChain is an Iterator that wraps a number of Iterators in a lazy manner.\n+ * <p>\n+ * This class makes multiple iterators look like one to the caller. When any\n+ * method from the Iterator interface is called, the LazyIteratorChain will delegate\n+ * to a single underlying Iterator. The LazyIteratorChain will invoke the Iterators\n+ * in sequence until all Iterators are exhausted.\n+ * <p>\n+ * The Iterators are provided by {@link #nextIterator(int)} which has to be overridden by\n+ * sub-classes and allows to lazily create the Iterators as they are accessed:\n+ * <pre>\n+ * return new LazyIteratorChain<String>() {\n+ *     protected Iterator<String> nextIterator(int count) {\n+ *         return count == 1 ? Arrays.asList(\"foo\", \"bar\").iterator() : null;\n+ *     }\n+ * };\n+ * </pre>\n+ * <p>\n+ * Once the inner Iterator's {@link Iterator#hasNext()} method returns false,\n+ * {@link #nextIterator(int)} will be called to obtain another iterator, and so on\n+ * until {@link #nextIterator(int)} returns null, indicating that the chain is exhausted.\n+ * <p>\n+ * NOTE: The LazyIteratorChain may contain no iterators. In this case the class will\n+ * function as an empty iterator.\n+ *\n+ * @since 4.0\n+ * @version $Id $\n+ */\n+public abstract class LazyIteratorChain<E> implements Iterator<E> {\n+\n+    /** The number of times {@link #nextIterator()} was already called. */\n+    private int callCounter = 0;\n+\n+    /** Indicates that the Iterator chain has been exhausted. */\n+    private boolean chainExhausted = false;\n+\n+    /** The current iterator. */\n+    private Iterator<? extends E> currentIterator = null;\n+\n+    /**\n+     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n+     * was most recently called used for the remove() operation only.\n+     */\n+    private Iterator<? extends E> lastUsedIterator = null;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Gets the next iterator after the previous one has been exhausted.\n+     * <p>\n+     * This method <b>MUST</b> return null when there are no more iterators.\n+     *\n+     * @param count the number of time this method has been called (starts with 1)\n+     * @return the next iterator, or null if there are no more.\n+     */\n+    protected abstract Iterator<? extends E> nextIterator(int count);\n+\n+    /**\n+     * Updates the current iterator field to ensure that the current Iterator\n+     * is not exhausted.\n+     */\n+    private void updateCurrentIterator() {\n+        if (callCounter == 0) {\n+            currentIterator = nextIterator(++callCounter);\n+            if (currentIterator == null) {\n+                currentIterator = EmptyIterator.<E>emptyIterator();\n+                chainExhausted = true;\n+            }\n+            // set last used iterator here, in case the user calls remove\n+            // before calling hasNext() or next() (although they shouldn't)\n+            lastUsedIterator = currentIterator;\n+        }\n+\n+        while (currentIterator.hasNext() == false && !chainExhausted) {\n+            final Iterator<? extends E> nextIterator = nextIterator(++callCounter);\n+            if (nextIterator != null) {\n+                currentIterator = nextIterator;\n+            } else {\n+                chainExhausted = true;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Return true if any Iterator in the chain has a remaining element.\n+     * \n+     * @return true if elements remain\n+     */\n+    public boolean hasNext() {\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+\n+        return currentIterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next element of the current Iterator\n+     * \n+     * @return element from the current Iterator\n+     * @throws java.util.NoSuchElementException if all the Iterators are exhausted\n+     */\n+    public E next() {\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+        \n+        return currentIterator.next();\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned by the Iterator.\n+     * <p>\n+     * As with next() and hasNext(), this method calls remove() on the underlying Iterator.\n+     * Therefore, this method may throw an UnsupportedOperationException if the underlying\n+     * Iterator does not support this method.\n+     * \n+     * @throws UnsupportedOperationException if the remove operator is not\n+     *   supported by the underlying Iterator\n+     * @throws IllegalStateException if the next method has not yet been called,\n+     *   or the remove method has already been called after the last call to the next method.\n+     */\n+    public void remove() {\n+        if (currentIterator == null) {\n+            updateCurrentIterator();\n+        }\n+        lastUsedIterator.remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ListIteratorWrapper.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * Converts an {@link Iterator} into a {@link ResettableListIterator}.\n+ * For plain <code>Iterator</code>s this is accomplished by caching the returned\n+ * elements.  This class can also be used to simply add \n+ * {@link org.apache.commons.collections4.ResettableIterator ResettableIterator}\n+ * functionality to a given {@link ListIterator}.\n+ * <p>\n+ * The <code>ListIterator</code> interface has additional useful methods\n+ * for navigation - <code>previous()</code> and the index methods.\n+ * This class allows a regular <code>Iterator</code> to behave as a\n+ * <code>ListIterator</code>. It achieves this by building a list internally\n+ * of as the underlying iterator is traversed.\n+ * <p>\n+ * The optional operations of <code>ListIterator</code> are not supported for plain <code>Iterator</code>s.\n+ * <p>\n+ * This class implements ResettableListIterator from Commons Collections 3.2.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class ListIteratorWrapper<E> implements ResettableListIterator<E> {\n+\n+    /** Message used when set or add are called. */\n+    private static final String UNSUPPORTED_OPERATION_MESSAGE =\n+        \"ListIteratorWrapper does not support optional operations of ListIterator.\";\n+\n+    /** Message used when set or add are called. */\n+    private static final String CANNOT_REMOVE_MESSAGE = \"Cannot remove element at index {0}.\";\n+\n+    /** The underlying iterator being decorated. */\n+    private final Iterator<? extends E> iterator;\n+    /** The list being used to cache the iterator. */\n+    private final List<E> list = new ArrayList<E>();\n+\n+    /** The current index of this iterator. */\n+    private int currentIndex = 0;\n+    /** The current index of the wrapped iterator. */\n+    private int wrappedIteratorIndex = 0;\n+    /** recall whether the wrapped iterator's \"cursor\" is in such a state as to allow remove() to be called */\n+    private boolean removeState;\n+\n+    // Constructor\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>ListIteratorWrapper</code> that will wrap\n+     * the given iterator.\n+     *\n+     * @param iterator  the iterator to wrap\n+     * @throws NullPointerException if the iterator is null\n+     */\n+    public ListIteratorWrapper(final Iterator<? extends E> iterator) {\n+        super();\n+        if (iterator == null) {\n+            throw new NullPointerException(\"Iterator must not be null\");\n+        }\n+        this.iterator = iterator;\n+    }\n+\n+    // ListIterator interface\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Throws {@link UnsupportedOperationException}\n+     * unless the underlying <code>Iterator</code> is a <code>ListIterator</code>.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException if the underlying iterator is not of\n+     * type {@link ListIterator}\n+     */\n+    public void add(final E obj) throws UnsupportedOperationException {\n+        if (iterator instanceof ListIterator) {\n+            @SuppressWarnings(\"unchecked\")\n+            final ListIterator<E> li = (ListIterator<E>) iterator;\n+            li.add(obj);\n+            return;\n+        }\n+        throw new UnsupportedOperationException(UNSUPPORTED_OPERATION_MESSAGE);\n+    }\n+\n+    /**\n+     * Returns true if there are more elements in the iterator.\n+     *\n+     * @return true if there are more elements\n+     */\n+    public boolean hasNext() {\n+        if (currentIndex == wrappedIteratorIndex || iterator instanceof ListIterator) {\n+            return iterator.hasNext();\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if there are previous elements in the iterator.\n+     *\n+     * @return true if there are previous elements\n+     */\n+    public boolean hasPrevious() {\n+        if (iterator instanceof ListIterator) {\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n+            return li.hasPrevious();\n+        }\n+        return currentIndex > 0;\n+    }\n+\n+    /**\n+     * Returns the next element from the iterator.\n+     *\n+     * @return the next element from the iterator\n+     * @throws NoSuchElementException if there are no more elements\n+     */\n+    public E next() throws NoSuchElementException {\n+        if (iterator instanceof ListIterator) {\n+            return iterator.next();\n+        }\n+\n+        if (currentIndex < wrappedIteratorIndex) {\n+            ++currentIndex;\n+            return list.get(currentIndex - 1);\n+        }\n+\n+        final E retval = iterator.next();\n+        list.add(retval);\n+        ++currentIndex;\n+        ++wrappedIteratorIndex;\n+        removeState = true;\n+        return retval;\n+    }\n+\n+    /**\n+     * Returns the index of the next element.\n+     *\n+     * @return the index of the next element\n+     */\n+    public int nextIndex() {\n+        if (iterator instanceof ListIterator) {\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n+            return li.nextIndex();\n+        }\n+        return currentIndex;\n+    }\n+\n+    /**\n+     * Returns the the previous element.\n+     *\n+     * @return the previous element\n+     * @throws NoSuchElementException  if there are no previous elements\n+     */\n+    public E previous() throws NoSuchElementException {\n+        if (iterator instanceof ListIterator) {\n+            @SuppressWarnings(\"unchecked\")\n+            final ListIterator<E> li = (ListIterator<E>) iterator;\n+            return li.previous();\n+        }\n+\n+        if (currentIndex == 0) {\n+            throw new NoSuchElementException();\n+        }\n+        removeState = wrappedIteratorIndex == currentIndex;\n+        return list.get(--currentIndex);\n+    }\n+\n+    /**\n+     * Returns the index of the previous element.\n+     *\n+     * @return  the index of the previous element\n+     */\n+    public int previousIndex() {\n+        if (iterator instanceof ListIterator) {\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n+            return li.previousIndex();\n+        }\n+        return currentIndex - 1;\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException} if {@link #previous()} has ever been called.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() throws UnsupportedOperationException {\n+        if (iterator instanceof ListIterator) {\n+            iterator.remove();\n+            return;\n+        }\n+        int removeIndex = currentIndex;\n+        if (currentIndex == wrappedIteratorIndex) {\n+            --removeIndex;\n+        }\n+        if (!removeState || wrappedIteratorIndex - currentIndex > 1) {\n+            throw new IllegalStateException(MessageFormat.format(CANNOT_REMOVE_MESSAGE, removeIndex));\n+        }\n+        iterator.remove();\n+        list.remove(removeIndex);\n+        currentIndex = removeIndex;\n+        wrappedIteratorIndex--;\n+        removeState = false;\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}\n+     * unless the underlying <code>Iterator</code> is a <code>ListIterator</code>.\n+     *\n+     * @param obj  the object to set\n+     * @throws UnsupportedOperationException if the underlying iterator is not of\n+     * type {@link ListIterator}\n+     */\n+    public void set(final E obj) throws UnsupportedOperationException {\n+        if (iterator instanceof ListIterator) {\n+            @SuppressWarnings(\"unchecked\")\n+            final ListIterator<E> li = (ListIterator<E>) iterator;\n+            li.set(obj);\n+            return;\n+        }\n+        throw new UnsupportedOperationException(UNSUPPORTED_OPERATION_MESSAGE);\n+    }\n+\n+    // ResettableIterator interface\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Resets this iterator back to the position at which the iterator\n+     * was created.\n+     *\n+     * @since 3.2\n+     */\n+    public void reset()  {\n+        if (iterator instanceof ListIterator) {\n+            final ListIterator<?> li = (ListIterator<?>) iterator;\n+            while (li.previousIndex() >= 0) {\n+                li.previous();\n+            }\n+            return;\n+        }\n+        currentIndex = 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/LoopingIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/**\n+ * An Iterator that restarts when it reaches the end.\n+ * <p>\n+ * The iterator will loop continuously around the provided elements, unless \n+ * there are no elements in the collection to begin with, or all the elements\n+ * have been {@link #remove removed}.\n+ * <p>\n+ * Concurrent modifications are not directly supported, and for most collection\n+ * implementations will throw a ConcurrentModificationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class LoopingIterator<E> implements ResettableIterator<E> {\n+    \n+    /** The collection to base the iterator on */\n+    private final Collection<? extends E> collection;\n+    /** The current iterator */\n+    private Iterator<? extends E> iterator;\n+\n+    /**\n+     * Constructor that wraps a collection.\n+     * <p>\n+     * There is no way to reset an Iterator instance without recreating it from\n+     * the original source, so the Collection must be passed in.\n+     * \n+     * @param coll  the collection to wrap\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public LoopingIterator(final Collection<? extends E> coll) {\n+        if (coll == null) {\n+            throw new NullPointerException(\"The collection must not be null\");\n+        }\n+        collection = coll;\n+        reset();\n+    }\n+\n+    /** \n+     * Has the iterator any more elements.\n+     * <p>\n+     * Returns false only if the collection originally had zero elements, or\n+     * all the elements have been {@link #remove removed}.\n+     * \n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasNext() {\n+        return collection.size() > 0;\n+    }\n+\n+    /**\n+     * Returns the next object in the collection.\n+     * <p>\n+     * If at the end of the collection, return the first element.\n+     * \n+     * @return the next object\n+     * @throws NoSuchElementException if there are no elements\n+     *         at all.  Use {@link #hasNext} to avoid this error.\n+     */\n+    public E next() {\n+        if (collection.size() == 0) {\n+            throw new NoSuchElementException(\"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            reset();\n+        }\n+        return iterator.next();\n+    }\n+\n+    /**\n+     * Removes the previously retrieved item from the underlying collection.\n+     * <p>\n+     * This feature is only supported if the underlying collection's \n+     * {@link Collection#iterator iterator} method returns an implementation \n+     * that supports it.\n+     * <p>\n+     * This method can only be called after at least one {@link #next} method call.\n+     * After a removal, the remove method may not be called again until another\n+     * next has been performed. If the {@link #reset} is called, then remove may\n+     * not be called until {@link #next} is called again.\n+     */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start of the collection.\n+     */\n+    public void reset() {\n+        iterator = collection.iterator();\n+    }\n+\n+    /**\n+     * Gets the size of the collection underlying the iterator.\n+     * \n+     * @return the current collection size\n+     */\n+    public int size() {\n+        return collection.size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/LoopingListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * A ListIterator that restarts when it reaches the end or when it\n+ * reaches the beginning.\n+ * <p>\n+ * The iterator will loop continuously around the provided list,\n+ * unless there are no elements in the collection to begin with, or\n+ * all of the elements have been {@link #remove removed}.\n+ * <p>\n+ * Concurrent modifications are not directly supported, and for most\n+ * collection implementations will throw a\n+ * ConcurrentModificationException.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class LoopingListIterator<E> implements ResettableListIterator<E> {\n+\n+    /** The list to base the iterator on */\n+    private final List<E> list;\n+    /** The current list iterator */\n+    private ListIterator<E> iterator;\n+\n+    /**\n+     * Constructor that wraps a list.\n+     * <p>\n+     * There is no way to reset a ListIterator instance without\n+     * recreating it from the original source, so the List must be\n+     * passed in and a reference to it held.\n+     *\n+     * @param list the list to wrap\n+     * @throws NullPointerException if the list it null\n+     */\n+    public LoopingListIterator(final List<E> list) {\n+        if (list == null) {\n+            throw new NullPointerException(\"The list must not be null\");\n+        }\n+        this.list = list;\n+        reset();\n+    }\n+\n+    /**\n+     * Returns whether this iterator has any more elements.\n+     * <p>\n+     * Returns false only if the list originally had zero elements, or\n+     * all elements have been {@link #remove removed}.\n+     *\n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasNext() {\n+        return !list.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the next object in the list.\n+     * <p>\n+     * If at the end of the list, returns the first element.\n+     *\n+     * @return the object after the last element returned\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public E next() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            reset();\n+        }\n+        return iterator.next();\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a\n+     * subsequent call to {@link #next}.\n+     * <p>\n+     * As would be expected, if the iterator is at the physical end of\n+     * the underlying list, 0 is returned, signifying the beginning of\n+     * the list.\n+     *\n+     * @return the index of the element that would be returned if next() were called\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public int nextIndex() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasNext() == false) {\n+            return 0;\n+        }\n+        return iterator.nextIndex();\n+    }\n+\n+    /**\n+     * Returns whether this iterator has any more previous elements.\n+     * <p>\n+     * Returns false only if the list originally had zero elements, or\n+     * all elements have been {@link #remove removed}.\n+     *\n+     * @return <code>true</code> if there are more elements\n+     */\n+    public boolean hasPrevious() {\n+        return !list.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the previous object in the list.\n+     * <p>\n+     * If at the beginning of the list, return the last element. Note\n+     * that in this case, traversal to find that element takes linear time.\n+     *\n+     * @return the object before the last element returned\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public E previous() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasPrevious() == false) {\n+            E result = null;\n+            while (iterator.hasNext()) {\n+                result = iterator.next();\n+            }\n+            iterator.previous();\n+            return result;\n+        }\n+        return iterator.previous();\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a\n+     * subsequent call to {@link #previous}.\n+     * <p>\n+     * As would be expected, if at the iterator is at the physical\n+     * beginning of the underlying list, the list's size minus one is\n+     * returned, signifying the end of the list.\n+     *\n+     * @return the index of the element that would be returned if previous() were called\n+     * @throws NoSuchElementException if there are no elements in the list\n+     */\n+    public int previousIndex() {\n+        if (list.isEmpty()) {\n+            throw new NoSuchElementException(\n+                \"There are no elements for this iterator to loop on\");\n+        }\n+        if (iterator.hasPrevious() == false) {\n+            return list.size() - 1;\n+        }\n+        return iterator.previousIndex();\n+    }\n+\n+    /**\n+     * Removes the previously retrieved item from the underlying list.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#iterator iterator} method returns an implementation\n+     * that supports it.\n+     * <p>\n+     * This method can only be called after at least one {@link #next}\n+     * or {@link #previous} method call. After a removal, the remove\n+     * method may not be called again until another {@link #next} or\n+     * {@link #previous} has been performed. If the {@link #reset} is\n+     * called, then remove may not be called until {@link #next} or\n+     * {@link #previous} is called again.\n+     *\n+     * @throws UnsupportedOperationException if the remove method is\n+     * not supported by the iterator implementation of the underlying\n+     * list\n+     */\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Inserts the specified element into the underlying list.\n+     * <p>\n+     * The element is inserted before the next element that would be\n+     * returned by {@link #next}, if any, and after the next element\n+     * that would be returned by {@link #previous}, if any.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#listIterator} method returns an implementation\n+     * that supports it.\n+     *\n+     * @param obj  the element to insert\n+     * @throws UnsupportedOperationException if the add method is not\n+     *  supported by the iterator implementation of the underlying list\n+     */\n+    public void add(final E obj) {\n+        iterator.add(obj);\n+    }\n+\n+    /**\n+     * Replaces the last element that was returned by {@link #next} or\n+     * {@link #previous}.\n+     * <p>\n+     * This feature is only supported if the underlying list's\n+     * {@link List#listIterator} method returns an implementation\n+     * that supports it.\n+     *\n+     * @param obj  the element with which to replace the last element returned\n+     * @throws UnsupportedOperationException if the set method is not\n+     *  supported by the iterator implementation of the underlying list\n+     */\n+    public void set(final E obj) {\n+        iterator.set(obj);\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start of the list.\n+     */\n+    public void reset() {\n+        iterator = list.listIterator();\n+    }\n+\n+    /**\n+     * Gets the size of the list underlying the iterator.\n+     *\n+     * @return the current list size\n+     */\n+    public int size() {\n+        return list.size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java\n+/*\n+ * Copyright 2013 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * An {@link Iterator} over a {@link NodeList}.\n+ * <p>\n+ * This iterator does not support {@link #remove()} as a {@link NodeList} does not support\n+ * removal of items.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ * @see NodeList\n+ */\n+public class NodeListIterator implements Iterator<Node> {\n+\n+    /** the original NodeList instance */\n+    private final NodeList nodeList;\n+    /** The current iterator index */\n+    protected int index = 0;\n+\n+    /**\n+     * Convenience constructor, which creates a new NodeListIterator from \n+     * the specified node's childNodes.\n+     *\n+     * @param node Node, who's child nodes are wrapped by this class. Must not be null\n+     * @throws IllegalArgumentException if node is null\n+     */\n+    public NodeListIterator(final Node node) {\n+        if (node == null) {\n+            throw new IllegalArgumentException(\"node must not be null!\");\n+        }\n+        this.nodeList = node.getChildNodes();\n+    }\n+\n+    /**\n+     * Constructor, that creates a new NodeListIterator from the specified\n+     * <code>org.w3c.NodeList</code>\n+     *\n+     * @param nodeList node list, which is wrapped by this class. Must not be null\n+     * @throws IllegalArgumentException if nodeList is null\n+     */\n+    public NodeListIterator(final NodeList nodeList) {\n+        if (nodeList == null) {\n+            throw new IllegalArgumentException(\"nodeList must not be null!\");\n+        }\n+        this.nodeList = nodeList;\n+    }\n+    \n+    public boolean hasNext() {\n+        return nodeList == null ? false : index < nodeList.getLength();\n+    }\n+\n+    public Node next() {\n+        if (nodeList != null && index < nodeList.getLength()) {\n+            return nodeList.item(index++);\n+        } else {\n+            throw new NoSuchElementException(\"underlying nodeList has no more elements\");\n+        }\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() method not supported for an NodeListIterator.\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ObjectArrayIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * An {@link Iterator} over an array of objects.\n+ * <p>\n+ * This iterator does not support {@link #remove}, as the object array cannot be\n+ * structurally modified.\n+ * <p>\n+ * The iterator implements a {@link #reset} method, allowing the reset of the iterator\n+ * back to the start if required.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ObjectArrayIterator<E>\n+        implements Iterator<E>, ResettableIterator<E> {\n+\n+    /** The array */\n+    protected E[] array = null;\n+    /** The start index to loop from */\n+    protected int startIndex = 0;\n+    /** The end index to loop to */\n+    protected int endIndex = 0;\n+    /** The current iterator index */\n+    protected int index = 0;\n+\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray} is  called to establish the array to iterate over.\n+     */\n+    public ObjectArrayIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayIterator(final E... array) {\n+        this(array, 0, array.length);\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the start index is out of bounds\n+     */\n+    public ObjectArrayIterator(final E array[], final int start) {\n+        this(array, start, array.length);\n+    }\n+\n+    /**\n+     * Construct an ObjectArrayIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @param end  the index (exclusive) to finish iterating at\n+     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n+     * @throws IllegalArgumentException if end index is before the start\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayIterator(final E array[], final int start, final int end) {\n+        super();\n+        if (start < 0) {\n+            throw new ArrayIndexOutOfBoundsException(\"Start index must not be less than zero\");\n+        }\n+        if (end > array.length) {\n+            throw new ArrayIndexOutOfBoundsException(\"End index must not be greater than the array length\");\n+        }\n+        if (start > array.length) {\n+            throw new ArrayIndexOutOfBoundsException(\"Start index must not be greater than the array length\");\n+        }\n+        if (end < start) {\n+            throw new IllegalArgumentException(\"End index must not be less than start index\");\n+        }\n+        this.array = array;\n+        this.startIndex = start;\n+        this.endIndex = end;\n+        this.index = start;\n+    }\n+\n+    // Iterator interface\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true if there are more elements to return from the array.\n+     *\n+     * @return true if there is a next element to return\n+     */\n+    public boolean hasNext() {\n+        return this.index < this.endIndex;\n+    }\n+\n+    /**\n+     * Returns the next element in the array.\n+     *\n+     * @return the next element in the array\n+     * @throws NoSuchElementException if all the elements in the array\n+     *    have already been returned\n+     */\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        return this.array[this.index++];\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() method is not supported for an ObjectArrayIterator\");\n+    }\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Gets the array that this iterator is iterating over. \n+     *\n+     * @return the array this iterator iterates over, or <code>null</code> if\n+     * the no-arg constructor was used and {@link #setArray} has never\n+     * been called with a valid array.\n+     */\n+    public E[] getArray() {\n+        return this.array;\n+    }\n+\n+    /**\n+     * Sets the array that the ArrayIterator should iterate over.\n+     * <p>\n+     * This method may only be called once, otherwise an IllegalStateException\n+     * will occur.\n+     * <p>\n+     * The {@link #reset} method can be used to reset the iterator if required.\n+     *\n+     * @param array  the array that the iterator should iterate over\n+     * @throws IllegalStateException if the <code>array</code> was set in the constructor\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public void setArray(final E[] array) {\n+        if (this.array != null) {\n+            throw new IllegalStateException(\"The array to iterate over has already been set\");\n+        }\n+        this.array = array;\n+        this.startIndex = 0;\n+        this.endIndex = array.length;\n+        this.index = 0;\n+    }\n+\n+    /**\n+     * Gets the start index to loop from.\n+     * \n+     * @return the start index\n+     */\n+    public int getStartIndex() {\n+        return this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the end index to loop to.\n+     * \n+     * @return the end index\n+     */\n+    public int getEndIndex() {\n+        return this.endIndex;\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    public void reset() {\n+        this.index = this.startIndex;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * Implements a {@link ListIterator} over an array of objects.\n+ * <p>\n+ * This iterator does not support {@link #add} or {@link #remove}, as the object array \n+ * cannot be structurally modified. The {@link #set} method is supported however.\n+ * <p>\n+ * The iterator implements a {@link #reset} method, allowing the reset of the iterator\n+ * back to the start if required.\n+ *\n+ * @see org.apache.commons.collections4.iterators.ObjectArrayIterator\n+ * @see java.util.Iterator\n+ * @see java.util.ListIterator\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ObjectArrayListIterator<E> extends ObjectArrayIterator<E>\n+        implements ListIterator<E>, ResettableListIterator<E> {\n+\n+    /**\n+     * Holds the index of the last item returned by a call to <code>next()</code> \n+     * or <code>previous()</code>. This is set to <code>-1</code> if neither method\n+     * has yet been invoked. <code>lastItemIndex</code> is used to to implement the\n+     * {@link #set} method.\n+     */\n+    protected int lastItemIndex = -1;\n+\n+    /**\n+     * Constructor for use with <code>setArray</code>.\n+     * <p>\n+     * Using this constructor, the iterator is equivalent to an empty iterator\n+     * until {@link #setArray} is  called to establish the array to iterate over.\n+     */\n+    public ObjectArrayListIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayListIterator that will iterate over the values in the\n+     * specified array.\n+     *\n+     * @param array the array to iterate over\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayListIterator(final E... array) {\n+        super(array);\n+    }\n+\n+    /**\n+     * Constructs an ObjectArrayListIterator that will iterate over the values in the\n+     * specified array from a specific start index.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     * @throws IndexOutOfBoundsException if the start index is out of bounds\n+     */\n+    public ObjectArrayListIterator(final E[] array, final int start) {\n+        super(array, start);\n+    }\n+    \n+    /**\n+     * Construct an ObjectArrayListIterator that will iterate over a range of values \n+     * in the specified array.\n+     *\n+     * @param array  the array to iterate over\n+     * @param start  the index to start iterating at\n+     * @param end  the index (exclusive) to finish iterating at\n+     * @throws IndexOutOfBoundsException if the start or end index is out of bounds\n+     * @throws IllegalArgumentException if end index is before the start\n+     * @throws NullPointerException if <code>array</code> is <code>null</code>\n+     */\n+    public ObjectArrayListIterator(final E[] array, final int start, final int end) {\n+        super(array, start, end);\n+    }\n+\n+    // ListIterator interface\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     * Returns true if there are previous elements to return from the array.\n+     *\n+     * @return true if there is a previous element to return\n+     */\n+    public boolean hasPrevious() {\n+        return this.index > this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the previous element from the array.\n+     * \n+     * @return the previous element\n+     * @throws NoSuchElementException if there is no previous element\n+     */\n+    public E previous() {\n+        if (hasPrevious() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = --this.index;\n+        return this.array[this.index];\n+    }\n+\n+    /**\n+     * Gets the next element from the array.\n+     * \n+     * @return the next element\n+     * @throws NoSuchElementException if there is no next element\n+     */\n+    @Override\n+    public E next() {\n+        if (hasNext() == false) {\n+            throw new NoSuchElementException();\n+        }\n+        this.lastItemIndex = this.index;\n+        return this.array[this.index++];\n+    }\n+\n+    /**\n+     * Gets the next index to be retrieved.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int nextIndex() {\n+        return this.index - this.startIndex;\n+    }\n+\n+    /**\n+     * Gets the index of the item to be retrieved if {@link #previous()} is called.\n+     * \n+     * @return the index of the item to be retrieved next\n+     */\n+    public int previousIndex() {\n+        return this.index - this.startIndex - 1;\n+    }\n+\n+    /**\n+     * This iterator does not support modification of its backing array's size, and so will\n+     * always throw an {@link UnsupportedOperationException} when this method is invoked.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException always thrown.\n+     */\n+    public void add(final E obj) {\n+        throw new UnsupportedOperationException(\"add() method is not supported\");\n+    }\n+\n+    /**\n+     * Sets the element under the cursor.\n+     * <p>\n+     * This method sets the element that was returned by the last call \n+     * to {@link #next()} of {@link #previous()}. \n+     * \n+     * <b>Note:</b> {@link ListIterator} implementations that support <code>add()</code>\n+     * and <code>remove()</code> only allow <code>set()</code> to be called once per call \n+     * to <code>next()</code> or <code>previous</code> (see the {@link ListIterator}\n+     * javadoc for more details). Since this implementation does not support \n+     * <code>add()</code> or <code>remove()</code>, <code>set()</code> may be\n+     * called as often as desired.\n+     * \n+     * @param obj  the object to set into the array\n+     * @throws IllegalStateException if next() has not yet been called.\n+     * @throws ClassCastException if the object type is unsuitable for the array\n+     */\n+    public void set(final E obj) {\n+        if (this.lastItemIndex == -1) {\n+            throw new IllegalStateException(\"must call next() or previous() before a call to set()\");\n+        }\n+\n+        this.array[this.lastItemIndex] = obj;\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start index.\n+     */\n+    @Override\n+    public void reset() {\n+        super.reset();\n+        this.lastItemIndex = -1;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ObjectGraphIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ArrayStack;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * An Iterator that can traverse multiple iterators down an object graph.\n+ * <p>\n+ * This iterator can extract multiple objects from a complex tree-like object graph.\n+ * The iteration starts from a single root object.\n+ * It uses a <code>Transformer</code> to extract the iterators and elements.\n+ * Its main benefit is that no intermediate <code>List</code> is created.\n+ * <p>\n+ * For example, consider an object graph:\n+ * <pre>\n+ *                 |- Branch -- Leaf\n+ *                 |         \\- Leaf\n+ *         |- Tree |         /- Leaf\n+ *         |       |- Branch -- Leaf\n+ *  Forest |                 \\- Leaf\n+ *         |       |- Branch -- Leaf\n+ *         |       |         \\- Leaf\n+ *         |- Tree |         /- Leaf\n+ *                 |- Branch -- Leaf\n+ *                 |- Branch -- Leaf</pre>\n+ * The following <code>Transformer</code>, used in this class, will extract all\n+ * the Leaf objects without creating a combined intermediate list:\n+ * <pre>\n+ * public Object transform(Object input) {\n+ *   if (input instanceof Forest) {\n+ *     return ((Forest) input).treeIterator();\n+ *   }\n+ *   if (input instanceof Tree) {\n+ *     return ((Tree) input).branchIterator();\n+ *   }\n+ *   if (input instanceof Branch) {\n+ *     return ((Branch) input).leafIterator();\n+ *   }\n+ *   if (input instanceof Leaf) {\n+ *     return input;\n+ *   }\n+ *   throw new ClassCastException();\n+ * }</pre>\n+ * <p>\n+ * Internally, iteration starts from the root object. When next is called,\n+ * the transformer is called to examine the object. The transformer will return\n+ * either an iterator or an object. If the object is an Iterator, the next element\n+ * from that iterator is obtained and the process repeats. If the element is an object\n+ * it is returned.\n+ * <p>\n+ * Under many circumstances, linking Iterators together in this manner is\n+ * more efficient (and convenient) than using nested for loops to extract a list.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"deprecation\") // we use the deprecated ArrayStack - change to ArrayDeque (Java 1.6)\n+public class ObjectGraphIterator<E> implements Iterator<E> {\n+\n+    /** The stack of iterators */\n+    protected final ArrayStack<Iterator<? extends E>> stack = new ArrayStack<Iterator<? extends E>>(8);\n+    /** The root object in the tree */\n+    protected E root;\n+    /** The transformer to use */\n+    protected final Transformer<? super E, ? extends E> transformer;\n+\n+    /** Whether there is another element in the iteration */\n+    protected boolean hasNext = false;\n+    /** The current iterator */\n+    protected Iterator<? extends E> currentIterator;\n+    /** The current value */\n+    protected E currentValue;\n+    /** The last used iterator, needed for remove() */\n+    protected Iterator<? extends E> lastUsedIterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs an ObjectGraphIterator using a root object and transformer.\n+     * <p>\n+     * The root object can be an iterator, in which case it will be immediately\n+     * looped around.\n+     * \n+     * @param root  the root object, null will result in an empty iterator\n+     * @param transformer  the transformer to use, null will use a no effect transformer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n+        super();\n+        if (root instanceof Iterator) {\n+            this.currentIterator = (Iterator<? extends E>) root;\n+        } else {\n+            this.root = root;\n+        }\n+        this.transformer = transformer;\n+    }\n+\n+    /**\n+     * Constructs a ObjectGraphIterator that will handle an iterator of iterators.\n+     * <p>\n+     * This constructor exists for convenience to emphasise that this class can\n+     * be used to iterate over nested iterators. That is to say that the iterator\n+     * passed in here contains other iterators, which may in turn contain further\n+     * iterators.\n+     * \n+     * @param rootIterator  the root iterator, null will result in an empty iterator\n+     */\n+    public ObjectGraphIterator(final Iterator<? extends E> rootIterator) {\n+        super();\n+        this.currentIterator = rootIterator;\n+        this.transformer = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Loops around the iterators to find the next value to return.\n+     */\n+    protected void updateCurrentIterator() {\n+        if (hasNext) {\n+            return;\n+        }\n+        if (currentIterator == null) {\n+            if (root == null) {\n+                // do nothing, hasNext will be false\n+            } else {\n+                if (transformer == null) {\n+                    findNext(root);\n+                } else {\n+                    findNext(transformer.transform(root));\n+                }\n+                root = null;\n+            }\n+        } else {\n+            findNextByIterator(currentIterator);\n+        }\n+    }\n+\n+    /**\n+     * Finds the next object in the iteration given any start object.\n+     * \n+     * @param value  the value to start from\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void findNext(final E value) {\n+        if (value instanceof Iterator) {\n+            // need to examine this iterator\n+            findNextByIterator((Iterator<? extends E>) value);\n+        } else {\n+            // next value found\n+            currentValue = value;\n+            hasNext = true;\n+        }\n+    }\n+    \n+    /**\n+     * Finds the next object in the iteration given an iterator.\n+     * \n+     * @param iterator  the iterator to start from\n+     */\n+    protected void findNextByIterator(final Iterator<? extends E> iterator) {\n+        if (iterator != currentIterator) {\n+            // recurse a level\n+            if (currentIterator != null) {\n+                stack.push(currentIterator);\n+            }\n+            currentIterator = iterator;\n+        }\n+        \n+        while (currentIterator.hasNext() && hasNext == false) {\n+            E next = currentIterator.next();\n+            if (transformer != null) {\n+                next = transformer.transform(next);\n+            }\n+            findNext(next);\n+        }\n+        if (hasNext) {\n+            // next value found\n+        } else if (stack.isEmpty()) {\n+            // all iterators exhausted\n+        } else {\n+            // current iterator exhausted, go up a level\n+            currentIterator = stack.pop();\n+            findNextByIterator(currentIterator);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there are any more elements in the iteration to obtain.\n+     * \n+     * @return true if elements remain in the iteration\n+     */\n+    public boolean hasNext() {\n+        updateCurrentIterator();\n+        return hasNext;\n+    }\n+\n+    /**\n+     * Gets the next element of the iteration.\n+     * \n+     * @return the next element from the iteration\n+     * @throws NoSuchElementException if all the Iterators are exhausted\n+     */\n+    public E next() {\n+        updateCurrentIterator();\n+        if (hasNext == false) {\n+            throw new NoSuchElementException(\"No more elements in the iteration\");\n+        }\n+        lastUsedIterator = currentIterator;\n+        final E result = currentValue;\n+        currentValue = null;\n+        hasNext = false;\n+        return result;\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned.\n+     * <p>\n+     * This method calls remove() on the underlying Iterator and it may\n+     * throw an UnsupportedOperationException if the underlying Iterator\n+     * does not support this method. \n+     * \n+     * @throws UnsupportedOperationException\n+     *   if the remove operator is not supported by the underlying Iterator\n+     * @throws IllegalStateException\n+     *   if the next method has not yet been called, or the remove method has\n+     *   already been called after the last call to the next method.\n+     */\n+    public void remove() {\n+        if (lastUsedIterator == null) {\n+            throw new IllegalStateException(\"Iterator remove() cannot be called at this time\");\n+        }\n+        lastUsedIterator.remove();\n+        lastUsedIterator = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * Iterates backwards through a List, starting with the last element\n+ * and continuing to the first. This is useful for looping around\n+ * a list in reverse order without needing to actually reverse the list.\n+ * <p>\n+ * The first call to <code>next()</code> will return the last element\n+ * from the list, and so on. The <code>hasNext()</code> method works\n+ * in concert with the <code>next()</code> method as expected.\n+ * However, the <code>nextIndex()</code> method returns the correct\n+ * index in the list, thus it starts high and reduces as the iteration\n+ * continues. The previous methods work similarly.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class ReverseListIterator<E> implements ResettableListIterator<E> {\n+\n+    /** The list being wrapped. */\n+    private final List<E> list;\n+    /** The list iterator being wrapped. */\n+    private ListIterator<E> iterator;\n+    /** Flag to indicate if updating is possible at the moment. */\n+    private boolean validForUpdate = true;\n+\n+    /**\n+     * Constructor that wraps a list.\n+     *\n+     * @param list  the list to create a reversed iterator for\n+     * @throws NullPointerException if the list is null\n+     */\n+    public ReverseListIterator(final List<E> list) {\n+        super();\n+        this.list = list;\n+        iterator = list.listIterator(list.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether there is another element.\n+     *\n+     * @return true if there is another element\n+     */\n+    public boolean hasNext() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    /**\n+     * Gets the next element.\n+     * The next element is the previous in the list.\n+     *\n+     * @return the next element in the iterator\n+     */\n+    public E next() {\n+        final E obj = iterator.previous();\n+        validForUpdate = true;\n+        return obj;\n+    }\n+\n+    /**\n+     * Gets the index of the next element.\n+     *\n+     * @return the index of the next element in the iterator\n+     */\n+    public int nextIndex() {\n+        return iterator.previousIndex();\n+    }\n+\n+    /**\n+     * Checks whether there is a previous element.\n+     *\n+     * @return true if there is a previous element\n+     */\n+    public boolean hasPrevious() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Gets the previous element.\n+     * The next element is the previous in the list.\n+     *\n+     * @return the previous element in the iterator\n+     */\n+    public E previous() {\n+        final E obj = iterator.next();\n+        validForUpdate = true;\n+        return obj;\n+    }\n+\n+    /**\n+     * Gets the index of the previous element.\n+     *\n+     * @return the index of the previous element in the iterator\n+     */\n+    public int previousIndex() {\n+        return iterator.nextIndex();\n+    }\n+\n+    /**\n+     * Removes the last returned element.\n+     *\n+     * @throws UnsupportedOperationException if the list is unmodifiable\n+     * @throws IllegalStateException if there is no element to remove\n+     */\n+    public void remove() {\n+        if (validForUpdate == false) {\n+            throw new IllegalStateException(\"Cannot remove from list until next() or previous() called\");\n+        }\n+        iterator.remove();\n+    }\n+\n+    /**\n+     * Replaces the last returned element.\n+     *\n+     * @param obj  the object to set\n+     * @throws UnsupportedOperationException if the list is unmodifiable\n+     * @throws IllegalStateException if the iterator is not in a valid state for set\n+     */\n+    public void set(final E obj) {\n+        if (validForUpdate == false) {\n+            throw new IllegalStateException(\"Cannot set to list until next() or previous() called\");\n+        }\n+        iterator.set(obj);\n+    }\n+\n+    /**\n+     * Adds a new element to the list between the next and previous elements.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException if the list is unmodifiable\n+     * @throws IllegalStateException if the iterator is not in a valid state for set\n+     */\n+    public void add(final E obj) {\n+        // the validForUpdate flag is needed as the necessary previous()\n+        // method call re-enables remove and add\n+        if (validForUpdate == false) {\n+            throw new IllegalStateException(\"Cannot add to list until next() or previous() called\");\n+        }\n+        validForUpdate = false;\n+        iterator.add(obj);\n+        iterator.previous();\n+    }\n+\n+    /**\n+     * Resets the iterator back to the start (which is the\n+     * end of the list as this is a reversed iterator)\n+     */\n+    public void reset() {\n+        iterator = list.listIterator(list.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/SingletonIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/** \n+ * <code>SingletonIterator</code> is an {@link Iterator} over a single \n+ * object instance.\n+ *\n+ * @since 2.0\n+ * @version $Id$\n+ */\n+public class SingletonIterator<E>\n+        implements Iterator<E>, ResettableIterator<E> {\n+\n+    /** Whether remove is allowed */\n+    private final boolean removeAllowed;\n+    /** Is the cursor before the first element */\n+    private boolean beforeFirst = true;\n+    /** Has the element been removed */\n+    private boolean removed = false;\n+    /** The object */\n+    private E object;\n+\n+    /**\n+     * Constructs a new <code>SingletonIterator</code> where <code>remove</code>\n+     * is a permitted operation.\n+     *\n+     * @param object  the single object to return from the iterator\n+     */\n+    public SingletonIterator(final E object) {\n+        this(object, true);\n+    }\n+\n+    /**\n+     * Constructs a new <code>SingletonIterator</code> optionally choosing if\n+     * <code>remove</code> is a permitted operation.\n+     *\n+     * @param object  the single object to return from the iterator\n+     * @param removeAllowed  true if remove is allowed\n+     * @since 3.1\n+     */\n+    public SingletonIterator(final E object, final boolean removeAllowed) {\n+        super();\n+        this.object = object;\n+        this.removeAllowed = removeAllowed;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is another object available from the iterator?\n+     * <p>\n+     * This returns true if the single object hasn't been returned yet.\n+     * \n+     * @return true if the single object hasn't been returned yet\n+     */\n+    public boolean hasNext() {\n+        return beforeFirst && !removed;\n+    }\n+\n+    /**\n+     * Get the next object from the iterator.\n+     * <p>\n+     * This returns the single object if it hasn't been returned yet.\n+     *\n+     * @return the single object\n+     * @throws NoSuchElementException if the single object has already \n+     *    been returned\n+     */\n+    public E next() {\n+        if (!beforeFirst || removed) {\n+            throw new NoSuchElementException();\n+        }\n+        beforeFirst = false;\n+        return object;\n+    }\n+\n+    /**\n+     * Remove the object from this iterator.\n+     * \n+     * @throws IllegalStateException if the <tt>next</tt> method has not\n+     *        yet been called, or the <tt>remove</tt> method has already\n+     *        been called after the last call to the <tt>next</tt>\n+     *        method.\n+     * @throws UnsupportedOperationException if remove is not supported\n+     */\n+    public void remove() {\n+        if (removeAllowed) {\n+            if (removed || beforeFirst) {\n+                throw new IllegalStateException();\n+            } else {\n+                object = null;\n+                removed = true;\n+            }\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n+    /**\n+     * Reset the iterator to the start.\n+     */\n+    public void reset() {\n+        beforeFirst = true;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/SingletonListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+\n+/**\n+ * <code>SingletonIterator</code> is an {@link ListIterator} over a single \n+ * object instance.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class SingletonListIterator<E> implements ListIterator<E>, ResettableListIterator<E> {\n+\n+    private boolean beforeFirst = true;\n+    private boolean nextCalled = false;\n+    private boolean removed = false;\n+    private E object;\n+\n+    /**\n+     * Constructs a new <code>SingletonListIterator</code>.\n+     *\n+     * @param object  the single object to return from the iterator\n+     */\n+    public SingletonListIterator(final E object) {\n+        super();\n+        this.object = object;\n+    }\n+\n+    /**\n+     * Is another object available from the iterator?\n+     * <p>\n+     * This returns true if the single object hasn't been returned yet.\n+     * \n+     * @return true if the single object hasn't been returned yet\n+     */\n+    public boolean hasNext() {\n+        return beforeFirst && !removed;\n+    }\n+\n+    /**\n+     * Is a previous object available from the iterator?\n+     * <p>\n+     * This returns true if the single object has been returned.\n+     * \n+     * @return true if the single object has been returned\n+     */\n+    public boolean hasPrevious() {\n+        return !beforeFirst && !removed;\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a subsequent\n+     * call to <tt>next</tt>.\n+     *\n+     * @return 0 or 1 depending on current state. \n+     */\n+    public int nextIndex() {\n+        return beforeFirst ? 0 : 1;\n+    }\n+\n+    /**\n+     * Returns the index of the element that would be returned by a subsequent\n+     * call to <tt>previous</tt>. A return value of -1 indicates that the iterator is currently at\n+     * the start.\n+     *\n+     * @return 0 or -1 depending on current state. \n+     */\n+    public int previousIndex() {\n+        return beforeFirst ? -1 : 0;\n+    }\n+\n+    /**\n+     * Get the next object from the iterator.\n+     * <p>\n+     * This returns the single object if it hasn't been returned yet.\n+     *\n+     * @return the single object\n+     * @throws NoSuchElementException if the single object has already \n+     *    been returned\n+     */\n+    public E next() {\n+        if (!beforeFirst || removed) {\n+            throw new NoSuchElementException();\n+        }\n+        beforeFirst = false;\n+        nextCalled = true;\n+        return object;\n+    }\n+\n+    /**\n+     * Get the previous object from the iterator.\n+     * <p>\n+     * This returns the single object if it has been returned.\n+     *\n+     * @return the single object\n+     * @throws NoSuchElementException if the single object has not already \n+     *    been returned\n+     */\n+    public E previous() {\n+        if (beforeFirst || removed) {\n+            throw new NoSuchElementException();\n+        }\n+        beforeFirst = true;\n+        return object;\n+    }\n+\n+    /**\n+     * Remove the object from this iterator.\n+     * @throws IllegalStateException if the <tt>next</tt> or <tt>previous</tt> \n+     *        method has not yet been called, or the <tt>remove</tt> method \n+     *        has already been called after the last call to <tt>next</tt>\n+     *        or <tt>previous</tt>.\n+     */\n+    public void remove() {\n+        if(!nextCalled || removed) {\n+            throw new IllegalStateException();\n+        } else {\n+            object = null;\n+            removed = true;\n+        }\n+    }\n+    \n+    /**\n+     * Add always throws {@link UnsupportedOperationException}.\n+     *\n+     * @param obj  the object to add\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void add(final E obj) {\n+        throw new UnsupportedOperationException(\"add() is not supported by this iterator\");\n+    }\n+    \n+    /**\n+     * Set sets the value of the singleton.\n+     *\n+     * @param obj  the object to set\n+     * @throws IllegalStateException if <tt>next</tt> has not been called \n+     *          or the object has been removed\n+     */\n+    public void set(final E obj) {\n+        if (!nextCalled || removed) {\n+            throw new IllegalStateException();\n+        }\n+        this.object = obj;\n+    }\n+    \n+    /**\n+     * Reset the iterator back to the start.\n+     */\n+    public void reset() {\n+        beforeFirst = true;\n+        nextCalled = false;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/TransformIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/** \n+ * Decorates an iterator such that each element returned is transformed.\n+ *\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class TransformIterator<I, O> implements Iterator<O> {\n+\n+    /** The iterator being used */\n+    private Iterator<? extends I> iterator;\n+    /** The transformer being used */\n+    private Transformer<? super I, ? extends O> transformer;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new <code>TransformIterator</code> that will not function\n+     * until the {@link #setIterator(Iterator) setIterator} and \n+     * {@link #setTransformer(Transformer)} methods are invoked.\n+     */\n+    public TransformIterator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformIterator</code> that won't transform\n+     * elements from the given iterator.\n+     *\n+     * @param iterator  the iterator to use\n+     */\n+    public TransformIterator(final Iterator<? extends I> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    /**\n+     * Constructs a new <code>TransformIterator</code> that will use the\n+     * given iterator and transformer.  If the given transformer is null,\n+     * then objects will not be transformed.\n+     *\n+     * @param iterator  the iterator to use\n+     * @param transformer  the transformer to use\n+     */\n+    public TransformIterator(final Iterator<? extends I> iterator,\n+                             final Transformer<? super I, ? extends O> transformer) {\n+        super();\n+        this.iterator = iterator;\n+        this.transformer = transformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Gets the next object from the iteration, transforming it using the\n+     * current transformer. If the transformer is null, no transformation\n+     * occurs and the object from the iterator is returned directly.\n+     * \n+     * @return the next object\n+     * @throws java.util.NoSuchElementException if there are no more elements\n+     */\n+    public O next() {\n+        return transform(iterator.next());\n+    }\n+\n+    public void remove() {\n+        iterator.remove();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the iterator this iterator is using.\n+     * \n+     * @return the iterator.\n+     */\n+    public Iterator<? extends I> getIterator() {\n+        return iterator;\n+    }\n+\n+    /** \n+     * Sets the iterator for this iterator to use.\n+     * If iteration has started, this effectively resets the iterator.\n+     * \n+     * @param iterator  the iterator to use\n+     */\n+    public void setIterator(final Iterator<? extends I> iterator) {\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /** \n+     * Gets the transformer this iterator is using.\n+     * \n+     * @return the transformer.\n+     */\n+    public Transformer<? super I, ? extends O> getTransformer() {\n+        return transformer;\n+    }\n+\n+    /** \n+     * Sets the transformer this the iterator to use.\n+     * A null transformer is a no-op transformer.\n+     * \n+     * @param transformer  the transformer to use\n+     */\n+    public void setTransformer(final Transformer<? super I, ? extends O> transformer) {\n+        this.transformer = transformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms the given object using the transformer.\n+     * If the transformer is null, the original object is returned as-is.\n+     *\n+     * @param source  the object to transform\n+     * @return the transformed object\n+     */\n+    protected O transform(final I source) {\n+        return transformer.transform(source);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UniqueFilterIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.functors.UniquePredicate;\n+\n+/**\n+ * A FilterIterator which only returns \"unique\" Objects.  Internally,\n+ * the Iterator maintains a Set of objects it has already encountered,\n+ * and duplicate Objects are skipped.\n+ *\n+ * @since 2.1\n+ * @version $Id$\n+ */\n+public class UniqueFilterIterator<E> extends FilterIterator<E> {\n+\n+    //-------------------------------------------------------------------------\n+\n+    /**\n+     *  Constructs a new <code>UniqueFilterIterator</code>.\n+     *\n+     *  @param iterator  the iterator to use\n+     */\n+    public UniqueFilterIterator(final Iterator<E> iterator) {\n+        super(iterator, UniquePredicate.uniquePredicate());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/** \n+ * Decorates an iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableIterator<E> implements Iterator<E>, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private final Iterator<E> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     * <p>\n+     * If the iterator is already unmodifiable it is returned directly.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @return a new unmodifiable iterator\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <E> Iterator<E> unmodifiableIterator(final Iterator<E> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"Iterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableIterator<E>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableIterator(final Iterator<E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public E next() {\n+        return iterator.next();\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/** \n+ * Decorates a list iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableListIterator<E> implements ListIterator<E>, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private final ListIterator<E> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @return a new unmodifiable list iterator\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <E> ListIterator<E> umodifiableListIterator(final ListIterator<E> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"ListIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableListIterator<E>(iterator);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableListIterator(final ListIterator<E> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public E next() {\n+        return iterator.next();\n+    }\n+\n+    public int nextIndex() {\n+        return iterator.nextIndex();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    public E previous() {\n+        return iterator.previous();\n+    }\n+\n+    public int previousIndex() {\n+        return iterator.previousIndex();\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+    public void set(final E obj) {\n+        throw new UnsupportedOperationException(\"set() is not supported\");\n+    }\n+\n+    public void add(final E obj) {\n+        throw new UnsupportedOperationException(\"add() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/** \n+ * Decorates a map iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableMapIterator<K, V> implements MapIterator<K, V>, Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private final MapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param iterator  the iterator to decorate\n+     * @return a new unmodifiable map iterator\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <K, V> MapIterator<K, V> unmodifiableMapIterator(final MapIterator<K, V> iterator) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableMapIterator<K, V>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableMapIterator(final MapIterator<K, V> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public V setValue(final V value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/**\n+ * Decorates an ordered map iterator such that it cannot be modified.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>,\n+        Unmodifiable {\n+\n+    /** The iterator being decorated */\n+    private final OrderedMapIterator<K, V> iterator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator such that it cannot be modified.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param iterator  the iterator to decorate\n+     * @return a new unmodifiable ordered map iterator\n+     * @throws IllegalArgumentException if the iterator is null\n+     */\n+    public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(\n+            final OrderedMapIterator<K, V> iterator) {\n+\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n+        }\n+        if (iterator instanceof Unmodifiable) {\n+            return iterator;\n+        }\n+        return new UnmodifiableOrderedMapIterator<K, V>(iterator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor.\n+     *\n+     * @param iterator  the iterator to decorate\n+     */\n+    private UnmodifiableOrderedMapIterator(final OrderedMapIterator<K, V> iterator) {\n+        super();\n+        this.iterator = iterator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    public K next() {\n+        return iterator.next();\n+    }\n+\n+    public boolean hasPrevious() {\n+        return iterator.hasPrevious();\n+    }\n+\n+    public K previous() {\n+        return iterator.previous();\n+    }\n+\n+    public K getKey() {\n+        return iterator.getKey();\n+    }\n+\n+    public V getValue() {\n+        return iterator.getValue();\n+    }\n+\n+    public V setValue(final V value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link java.util.Iterator Iterator} interface.\n+ * <p>\n+ * You may also consider using \n+ * {@link org.apache.commons.collections4.IteratorUtils IteratorUtils},\n+ * which is a single class that uses static methods to construct instances\n+ * of the classes in this package.\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.iterators;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import org.apache.commons.collections4.KeyValue;\n+\n+/**\n+ * Abstract pair class to assist with creating <code>KeyValue</code>\n+ * and {@link java.util.Map.Entry Map.Entry} implementations.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractKeyValue<K, V> implements KeyValue<K, V> {\n+\n+    /** The key */\n+    protected K key;\n+    /** The value */\n+    protected V value;\n+\n+    /**\n+     * Constructs a new pair with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    protected AbstractKeyValue(final K key, final V value) {\n+        super();\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Gets the key from the pair.\n+     *\n+     * @return the key \n+     */\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value from the pair.\n+     *\n+     * @return the value\n+     */\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Gets a debugging String view of the pair.\n+     * \n+     * @return a String view of the entry\n+     */\n+    @Override\n+    public String toString() {\n+        return new StringBuilder()\n+            .append(getKey())\n+            .append('=')\n+            .append(getValue())\n+            .toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+/**\n+ * Abstract Pair class to assist with creating correct\n+ * {@link java.util.Map.Entry Map.Entry} implementations.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapEntry<K, V> extends AbstractKeyValue<K, V> implements Map.Entry<K, V> {\n+\n+    /**\n+     * Constructs a new entry with the given key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    protected AbstractMapEntry(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    // Map.Entry interface\n+    //-------------------------------------------------------------------------\n+    /** \n+     * Sets the value stored in this <code>Map.Entry</code>.\n+     * <p>\n+     * This <code>Map.Entry</code> is not connected to a Map, so only the\n+     * local data is changed.\n+     *\n+     * @param value  the new value\n+     * @return the previous value\n+     */\n+    public V setValue(final V value) {\n+        final V answer = this.value;\n+        this.value = value;\n+        return answer;\n+    }\n+\n+    /**\n+     * Compares this <code>Map.Entry</code> with another <code>Map.Entry</code>.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal key and value\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map.Entry == false) {\n+            return false;\n+        }\n+        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+        return\n+            (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+            (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+    }\n+\n+    /**\n+     * Gets a hashCode compatible with the equals method.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode()); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+\n+/**\n+ * Provides a base decorator that allows additional functionality to be\n+ * added to a {@link java.util.Map.Entry Map.Entry}.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapEntryDecorator<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+    \n+    /** The <code>Map.Entry</code> to decorate */\n+    protected final Map.Entry<K, V> entry;\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param entry  the <code>Map.Entry</code> to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractMapEntryDecorator(final Map.Entry<K, V> entry) {\n+        if (entry == null) {\n+            throw new IllegalArgumentException(\"Map Entry must not be null\");\n+        }\n+        this.entry = entry;\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected Map.Entry<K, V> getMapEntry() {\n+        return entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public K getKey() {\n+        return entry.getKey();\n+    }\n+\n+    public V getValue() {\n+        return entry.getValue();\n+    }\n+\n+    public V setValue(final V object) {\n+        return entry.setValue(object);\n+    }\n+   \n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return entry.equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return entry.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return entry.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/DefaultKeyValue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+\n+/**\n+ * A mutable <code>KeyValue</code> pair that does not implement\n+ * {@link java.util.Map.Entry Map.Entry}.\n+ * <p>\n+ * Note that a <code>DefaultKeyValue</code> instance may not contain\n+ * itself as a key or value.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DefaultKeyValue<K, V> extends AbstractKeyValue<K, V> {\n+\n+    /**\n+     * Constructs a new pair with a null key and null value.\n+     */\n+    public DefaultKeyValue() {\n+        super(null, null);\n+    }\n+\n+    /**\n+     * Constructs a new pair with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    public DefaultKeyValue(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    /**\n+     * Constructs a new pair from the specified <code>KeyValue</code>.\n+     *\n+     * @param pair  the pair to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultKeyValue(final KeyValue<K, V> pair) {\n+        super(pair.getKey(), pair.getValue());\n+    }\n+\n+    /**\n+     * Constructs a new pair from the specified <code>Map.Entry</code>.\n+     *\n+     * @param entry  the entry to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultKeyValue(final Map.Entry<K, V> entry) {\n+        super(entry.getKey(), entry.getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Sets the key.\n+     *\n+     * @param key  the new key\n+     * @return the old key\n+     * @throws IllegalArgumentException if key is this object\n+     */\n+    public K setKey(final K key) {\n+        if (key == this) {\n+            throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a key.\");\n+        }\n+\n+        final K old = this.key;\n+        this.key = key;\n+        return old;\n+    }\n+\n+    /** \n+     * Sets the value.\n+     *\n+     * @return the old value of the value\n+     * @param value the new value\n+     * @throws IllegalArgumentException if value is this object\n+     */\n+    public V setValue(final V value) {\n+        if (value == this) {\n+            throw new IllegalArgumentException(\"DefaultKeyValue may not contain itself as a value.\");\n+        }\n+\n+        final V old = this.value;\n+        this.value = value;\n+        return old;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new <code>Map.Entry</code> object with key and value from this pair.\n+     * \n+     * @return a MapEntry instance\n+     */\n+    public Map.Entry<K, V> toMapEntry() {\n+        return new DefaultMapEntry<K, V>(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this <code>Map.Entry</code> with another <code>Map.Entry</code>.\n+     * <p>\n+     * Returns true if the compared object is also a <code>DefaultKeyValue</code>,\n+     * and its key and value are equal to this object's key and value.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal key and value\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof DefaultKeyValue == false) {\n+            return false;\n+        }\n+\n+        final DefaultKeyValue<?, ?> other = (DefaultKeyValue<?, ?>) obj;\n+        return \n+            (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+            (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+    }\n+\n+    /**\n+     * Gets a hashCode compatible with the equals method.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()},\n+     * however subclasses may override this.\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/DefaultMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+\n+/**\n+ * A restricted implementation of {@link java.util.Map.Entry Map.Entry} that prevents\n+ * the {@link java.util.Map.Entry Map.Entry} contract from being broken.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class DefaultMapEntry<K, V> extends AbstractMapEntry<K, V> {\n+\n+    /**\n+     * Constructs a new entry with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    public DefaultMapEntry(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>KeyValue</code>.\n+     *\n+     * @param pair  the pair to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultMapEntry(final KeyValue<K, V> pair) {\n+        super(pair.getKey(), pair.getValue());\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>Map.Entry</code>.\n+     *\n+     * @param entry  the entry to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public DefaultMapEntry(final Map.Entry<K, V> entry) {\n+        super(entry.getKey(), entry.getValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/** \n+ * A <code>MultiKey</code> allows multiple map keys to be merged together.\n+ * <p>\n+ * The purpose of this class is to avoid the need to write code to handle\n+ * maps of maps. An example might be the need to look up a file name by \n+ * key and locale. The typical solution might be nested maps. This class\n+ * can be used instead by creating an instance passing in the key and locale.\n+ * <p>\n+ * Example usage:\n+ * <pre>\n+ * // populate map with data mapping key+locale to localizedText\n+ * Map map = new HashMap();\n+ * MultiKey multiKey = new MultiKey(key, locale);\n+ * map.put(multiKey, localizedText);\n+ *\n+ * // later retrieve the localized text\n+ * MultiKey multiKey = new MultiKey(key, locale);\n+ * String localizedText = (String) map.get(multiKey);\n+ * </pre>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class MultiKey<K> implements Serializable {\n+    // This class could implement List, but that would confuse it's purpose\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 4465448607415788805L;\n+\n+    /** The individual keys */\n+    private final K[] keys;\n+    /** The cached hashCode */\n+    private transient int hashCode;\n+\n+    /**\n+     * Constructor taking two keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(final K key1, final K key2) {\n+        this((K[]) new Object[] { key1, key2 }, false);\n+    }\n+\n+    /**\n+     * Constructor taking three keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(final K key1, final K key2, final K key3) {\n+        this((K[]) new Object[] {key1, key2, key3}, false);\n+    }\n+\n+    /**\n+     * Constructor taking four keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(final K key1, final K key2, final K key3, final K key4) {\n+        this((K[]) new Object[] {key1, key2, key3, key4}, false);\n+    }\n+\n+    /**\n+     * Constructor taking five keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey(final K key1, final K key2, final K key3, final K key4, final K key5) {\n+        this((K[]) new Object[] {key1, key2, key3, key4, key5}, false);\n+    }\n+\n+    /**\n+     * Constructor taking an array of keys which is cloned.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     * <p>\n+     * This is equivalent to <code>new MultiKey(keys, true)</code>.\n+     *\n+     * @param keys  the array of keys, not null\n+     * @throws IllegalArgumentException if the key array is null\n+     */\n+    public MultiKey(final K[] keys) {\n+        this(keys, true);\n+    }\n+\n+    /**\n+     * Constructor taking an array of keys, optionally choosing whether to clone.\n+     * <p>\n+     * <b>If the array is not cloned, then it must not be modified.</b>\n+     * <p>\n+     * This method is public for performance reasons only, to avoid a clone.\n+     * The hashcode is calculated once here in this method.\n+     * Therefore, changing the array passed in would not change the hashcode but\n+     * would change the equals method, which is a bug.\n+     * <p>\n+     * This is the only fully safe usage of this constructor, as the object array\n+     * is never made available in a variable:\n+     * <pre>\n+     * new MultiKey(new Object[] {...}, false);\n+     * </pre>\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed after adding to the MultiKey.\n+     *\n+     * @param keys  the array of keys, not null\n+     * @param makeClone  true to clone the array, false to assign it\n+     * @throws IllegalArgumentException if the key array is null\n+     * @since 3.1\n+     */\n+    public MultiKey(final K[] keys, final boolean makeClone) {\n+        super();\n+        if (keys == null) {\n+            throw new IllegalArgumentException(\"The array of keys must not be null\");\n+        }\n+        if (makeClone) {\n+            this.keys = keys.clone();\n+        } else {\n+            this.keys = keys;\n+        }\n+\n+        calculateHashCode(keys);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a clone of the array of keys.\n+     * <p>\n+     * The keys should be immutable\n+     * If they are not then they must not be changed.\n+     * \n+     * @return the individual keys\n+     */\n+    public K[] getKeys() {\n+        return keys.clone();\n+    }\n+\n+    /**\n+     * Gets the key at the specified index.\n+     * <p>\n+     * The key should be immutable.\n+     * If it is not then it must not be changed.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since 3.1\n+     */\n+    public K getKey(final int index) {\n+        return keys[index];\n+    }\n+\n+    /**\n+     * Gets the size of the list of keys.\n+     * \n+     * @return the size of the list of keys\n+     * @since 3.1\n+     */\n+    public int size() {\n+        return keys.length;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this object to another.\n+     * <p>\n+     * To be equal, the other object must be a <code>MultiKey</code> with the\n+     * same number of keys which are also equal.\n+     * \n+     * @param other  the other object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object other) {\n+        if (other == this) {\n+            return true;\n+        }\n+        if (other instanceof MultiKey) {\n+            final MultiKey<?> otherMulti = (MultiKey<?>) other;\n+            return Arrays.equals(keys, otherMulti.keys);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets the combined hash code that is computed from all the keys.\n+     * <p>\n+     * This value is computed once and then cached, so elements should not\n+     * change their hash codes once created (note that this is the same \n+     * constraint that would be used if the individual keys elements were\n+     * themselves {@link java.util.Map Map} keys.\n+     * \n+     * @return the hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return hashCode;\n+    }\n+\n+    /**\n+     * Gets a debugging string version of the key.\n+     * \n+     * @return a debugging string\n+     */\n+    @Override\n+    public String toString() {\n+        return \"MultiKey\" + Arrays.asList(keys).toString();\n+    }\n+\n+    /**\n+     * Calculate the hash code of the instance using the provided keys.\n+     * @param keys the keys to calculate the hash code for\n+     */\n+    private void calculateHashCode(final Object[] keys)\n+    {\n+        int total = 0;\n+        for (final Object key : keys) {\n+            if (key != null) {\n+                total ^= key.hashCode();\n+            }\n+        }\n+        hashCode = total;\n+    }\n+    \n+    /**\n+     * Recalculate the hash code after deserialization. The hash code of some\n+     * keys might have change (hash codes based on the system hash code are\n+     * only stable for the same process). \n+     * @return the instance with recalculated hash code\n+     */\n+    private Object readResolve() {\n+        calculateHashCode(keys);\n+        return this;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/TiedMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+\n+/**\n+ * A {@link java.util.Map.Entry Map.Entry} tied to a map underneath.\n+ * <p>\n+ * This can be used to enable a map entry to make changes on the underlying\n+ * map, however this will probably mess up any iterators.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TiedMapEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V>, Serializable {\n+\n+    /** Serialization version */    \n+    private static final long serialVersionUID = -8453869361373831205L;\n+\n+    /** The map underlying the entry/iterator */    \n+    private final Map<K, V> map;\n+\n+    /** The key */\n+    private final K key;\n+\n+    /**\n+     * Constructs a new entry with the given Map and key.\n+     *\n+     * @param map  the map\n+     * @param key  the key\n+     */\n+    public TiedMapEntry(final Map<K, V> map, final K key) {\n+        super();\n+        this.map = map;\n+        this.key = key;\n+    }\n+\n+    // Map.Entry interface\n+    //-------------------------------------------------------------------------\n+    /**\n+     * Gets the key of this entry\n+     * \n+     * @return the key\n+     */\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value of this entry direct from the map.\n+     * \n+     * @return the value\n+     */\n+    public V getValue() {\n+        return map.get(key);\n+    }\n+\n+    /**\n+     * Sets the value associated with the key direct onto the map.\n+     * \n+     * @param value  the new value\n+     * @return the old value\n+     * @throws IllegalArgumentException if the value is set to this map entry\n+     */\n+    public V setValue(final V value) {\n+        if (value == this) {\n+            throw new IllegalArgumentException(\"Cannot set value to this map entry\");\n+        }\n+        return map.put(key, value);\n+    }\n+\n+    /**\n+     * Compares this <code>Map.Entry</code> with another <code>Map.Entry</code>.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal key and value\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map.Entry == false) {\n+            return false;\n+        }\n+        final Map.Entry<?,?> other = (Map.Entry<?,?>) obj;\n+        final Object value = getValue();\n+        return\n+            (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n+            (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+    }\n+\n+    /**\n+     * Gets a hashCode compatible with the equals method.\n+     * <p>\n+     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n+     * \n+     * @return a suitable hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        final Object value = getValue();\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (value == null ? 0 : value.hashCode()); \n+    }\n+\n+    /**\n+     * Gets a string version of the entry.\n+     * \n+     * @return entry as a string\n+     */\n+    @Override\n+    public String toString() {\n+        return getKey() + \"=\" + getValue();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntry.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/**\n+ * A {@link java.util.Map.Entry Map.Entry} that throws\n+ * UnsupportedOperationException when <code>setValue</code> is called.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableMapEntry<K, V> extends AbstractMapEntry<K, V> implements Unmodifiable {\n+\n+    /**\n+     * Constructs a new entry with the specified key and given value.\n+     *\n+     * @param key  the key for the entry, may be null\n+     * @param value  the value for the entry, may be null\n+     */\n+    public UnmodifiableMapEntry(final K key, final V value) {\n+        super(key, value);\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>KeyValue</code>.\n+     *\n+     * @param pair  the pair to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public UnmodifiableMapEntry(final KeyValue<K, V> pair) {\n+        super(pair.getKey(), pair.getValue());\n+    }\n+\n+    /**\n+     * Constructs a new entry from the specified <code>Map.Entry</code>.\n+     *\n+     * @param entry  the entry to copy, must not be null\n+     * @throws NullPointerException if the entry is null\n+     */\n+    public UnmodifiableMapEntry(final Map.Entry<K, V> entry) {\n+        super(entry.getKey(), entry.getValue());\n+    }\n+\n+    /**\n+     * Throws UnsupportedOperationException.\n+     * \n+     * @param value  the new value\n+     * @return the previous value\n+     * @throws UnsupportedOperationException always\n+     */\n+    @Override\n+    public V setValue(final V value) {\n+        throw new UnsupportedOperationException(\"setValue() is not supported\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of collection and map related key/value classes.\n+ * These are usually used in maps, however they can be used as data holders in any collection.\n+ * <p>\n+ * The following key/value designs are included:\n+ * <ul>\n+ *   <li>Map Entry - various map entry implementations\n+ *   <li>KeyValue - a key and value pair, without map entry semantics\n+ *   <li>MultiKey - a holder of multiple keys tied together\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.keyvalue;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.OrderedIterator;\n+\n+/**\n+ * An abstract implementation of a linked list which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * Overridable methods are provided to change the storage node and to change how\n+ * nodes are added to and removed. Hopefully, all you need for unusual subclasses\n+ * is here.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractLinkedList<E> implements List<E> {\n+\n+    /*\n+     * Implementation notes:\n+     * - a standard circular doubly-linked list\n+     * - a marker node is stored to mark the start and the end of the list\n+     * - node creation and removal always occurs through createNode() and\n+     *   removeNode().\n+     * - a modification count is kept, with the same semantics as\n+     * {@link java.util.LinkedList}.\n+     * - respects {@link AbstractList#modCount}\n+     */\n+\n+    /**\n+     * A {@link Node} which indicates the start and end of the list and does not\n+     * hold a value. The value of <code>next</code> is the first item in the\n+     * list. The value of of <code>previous</code> is the last item in the list.\n+     */\n+    protected transient Node<E> header;\n+\n+    /** The size of the list */\n+    protected transient int size;\n+\n+    /** Modification count for iterators */\n+    protected transient int modCount;\n+\n+    /**\n+     * Constructor that does nothing intended for deserialization.\n+     * <p>\n+     * If this constructor is used by a serializable subclass then the init()\n+     * method must be called.\n+     */\n+    protected AbstractLinkedList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a list copying data from the specified collection.\n+     *\n+     * @param coll  the collection to copy\n+     */\n+    protected AbstractLinkedList(final Collection<? extends E> coll) {\n+        super();\n+        init();\n+        addAll(coll);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor, broken out so it can be called\n+     * by any constructor and by <code>readObject</code>.\n+     * Subclasses which override this method should make sure they call super,\n+     * so the list is initialised properly.\n+     */\n+    protected void init() {\n+        header = createHeaderNode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public int size() {\n+        return size;\n+    }\n+\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    public E get(final int index) {\n+        final Node<E> node = getNode(index, false);\n+        return node.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public Iterator<E> iterator() {\n+        return listIterator();\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return new LinkedListIterator<E>(this, 0);\n+    }\n+\n+    public ListIterator<E> listIterator(final int fromIndex) {\n+        return new LinkedListIterator<E>(this, fromIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public int indexOf(final Object value) {\n+        int i = 0;\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                return i;\n+            }\n+            i++;\n+        }\n+        return -1;\n+    }\n+\n+    public int lastIndexOf(final Object value) {\n+        int i = size - 1;\n+        for (Node<E> node = header.previous; node != header; node = node.previous) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                return i;\n+            }\n+            i--;\n+        }\n+        return -1;\n+    }\n+\n+    public boolean contains(final Object value) {\n+        return indexOf(value) != -1;\n+    }\n+\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object o : coll) {\n+            if (!contains(o)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public Object[] toArray() {\n+        return toArray(new Object[size]);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(T[] array) {\n+        // Extend the array if needed\n+        if (array.length < size) {\n+            final Class<?> componentType = array.getClass().getComponentType();\n+            array = (T[]) Array.newInstance(componentType, size);\n+        }\n+        // Copy the values into the array\n+        int i = 0;\n+        for (Node<E> node = header.next; node != header; node = node.next, i++) {\n+            array[i] = (T) node.getValue();\n+        }\n+        // Set the value after the last value to null\n+        if (array.length > size) {\n+            array[size] = null;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Gets a sublist of the main list.\n+     *\n+     * @param fromIndexInclusive  the index to start from\n+     * @param toIndexExclusive  the index to end at\n+     * @return the new sublist\n+     */\n+    public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n+        return new LinkedSubList<E>(this, fromIndexInclusive, toIndexExclusive);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public boolean add(final E value) {\n+        addLast(value);\n+        return true;\n+    }\n+\n+    public void add(final int index, final E value) {\n+        final Node<E> node = getNode(index, true);\n+        addNodeBefore(node, value);\n+    }\n+\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        return addAll(size, coll);\n+    }\n+\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        final Node<E> node = getNode(index, true);\n+        for (final E e : coll) {\n+            addNodeBefore(node, e);\n+        }\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E remove(final int index) {\n+        final Node<E> node = getNode(index, false);\n+        final E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public boolean remove(final Object value) {\n+        for (Node<E> node = header.next; node != header; node = node.next) {\n+            if (isEqualValue(node.getValue(), value)) {\n+                removeNode(node);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p> \n+     * This implementation iterates over the elements of this list, checking each element in\n+     * turn to see if it's contained in <code>coll</code>. If it's contained, it's removed\n+     * from this list. As a consequence, it is advised to use a collection type for\n+     * <code>coll</code> that provides a fast (e.g. O(1)) implementation of\n+     * {@link Collection#contains(Object)}.\n+     */\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean modified = false;\n+        final Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next())) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * {@inheritDoc}\n+     * <p> \n+     * This implementation iterates over the elements of this list, checking each element in\n+     * turn to see if it's contained in <code>coll</code>. If it's not contained, it's removed\n+     * from this list. As a consequence, it is advised to use a collection type for\n+     * <code>coll</code> that provides a fast (e.g. O(1)) implementation of\n+     * {@link Collection#contains(Object)}.\n+     */\n+    public boolean retainAll(final Collection<?> coll) {\n+        boolean modified = false;\n+        final Iterator<E> it = iterator();\n+        while (it.hasNext()) {\n+            if (coll.contains(it.next()) == false) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    public E set(final int index, final E value) {\n+        final Node<E> node = getNode(index, false);\n+        final E oldValue = node.getValue();\n+        updateNode(node, value);\n+        return oldValue;\n+    }\n+\n+    public void clear() {\n+        removeAllNodes();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E getFirst() {\n+        final Node<E> node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.getValue();\n+    }\n+\n+    public E getLast() {\n+        final Node<E> node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        return node.getValue();\n+    }\n+\n+    public boolean addFirst(final E o) {\n+        addNodeAfter(header, o);\n+        return true;\n+    }\n+\n+    public boolean addLast(final E o) {\n+        addNodeBefore(header, o);\n+        return true;\n+    }\n+\n+    public E removeFirst() {\n+        final Node<E> node = header.next;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        final E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    public E removeLast() {\n+        final Node<E> node = header.previous;\n+        if (node == header) {\n+            throw new NoSuchElementException();\n+        }\n+        final E oldValue = node.getValue();\n+        removeNode(node);\n+        return oldValue;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof List == false) {\n+            return false;\n+        }\n+        final List<?> other = (List<?>) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        final ListIterator<?> it1 = listIterator();\n+        final ListIterator<?> it2 = other.listIterator();\n+        while (it1.hasNext() && it2.hasNext()) {\n+            final Object o1 = it1.next();\n+            final Object o2 = it2.next();\n+            if (!(o1 == null ? o2 == null : o1.equals(o2))) {\n+                return false;\n+            }\n+        }\n+        return !(it1.hasNext() || it2.hasNext());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 1;\n+        for (final E e : this) {\n+            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n+        }\n+        return hashCode;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"[]\";\n+        }\n+        final StringBuilder buf = new StringBuilder(16 * size());\n+        buf.append('[');\n+\n+        final Iterator<E> it = iterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            final Object value = it.next();\n+            buf.append(value == this ? \"(this Collection)\" : value);\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses the equals method.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param value1  the first value to compare, may be null\n+     * @param value2  the second value to compare, may be null\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n+        return value1 == value2 || (value1 == null ? false : value1.equals(value2));\n+    }\n+\n+    /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     *\n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    protected void updateNode(final Node<E> node, final E value) {\n+        node.setValue(value);\n+    }\n+\n+    /**\n+     * Creates a new node with previous, next and element all set to null.\n+     * This implementation creates a new empty Node.\n+     * Subclasses can override this to create a different class.\n+     *\n+     * @return  newly created node\n+     */\n+    protected Node<E> createHeaderNode() {\n+        return new Node<E>();\n+    }\n+\n+    /**\n+     * Creates a new node with the specified properties.\n+     * This implementation creates a new Node with data.\n+     * Subclasses can override this to create a different class.\n+     *\n+     * @param value  value of the new node\n+     * @return a new node containing the value\n+     */\n+    protected Node<E> createNode(final E value) {\n+        return new Node<E>(value);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n+     * <code>value</code> and inserts it before <code>node</code>.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and\n+     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n+     *\n+     * @param node  node to insert before\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void addNodeBefore(final Node<E> node, final E value) {\n+        final Node<E> newNode = createNode(value);\n+        addNode(newNode, node);\n+    }\n+\n+    /**\n+     * Creates a new node with the specified object as its\n+     * <code>value</code> and inserts it after <code>node</code>.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and\n+     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n+     *\n+     * @param node  node to insert after\n+     * @param value  value of the newly added node\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void addNodeAfter(final Node<E> node, final E value) {\n+        final Node<E> newNode = createNode(value);\n+        addNode(newNode, node.next);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n+        nodeToInsert.next = insertBeforeNode;\n+        nodeToInsert.previous = insertBeforeNode.previous;\n+        insertBeforeNode.previous.next = nodeToInsert;\n+        insertBeforeNode.previous = nodeToInsert;\n+        size++;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void removeNode(final Node<E> node) {\n+        node.previous.next = node.next;\n+        node.next.previous = node.previous;\n+        size--;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Removes all nodes by resetting the circular list marker.\n+     */\n+    protected void removeAllNodes() {\n+        header.next = header;\n+        header.previous = header;\n+        size = 0;\n+        modCount++;\n+    }\n+\n+    /**\n+     * Gets the node at a particular index.\n+     *\n+     * @param index  the index, starting from 0\n+     * @param endMarkerAllowed  whether or not the end marker can be returned if\n+     * startIndex is set to the list's size\n+     * @return the node at the given index\n+     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n+     * the size of the list and endMakerAllowed is false; or greater than the\n+     * size of the list\n+     */\n+    protected Node<E> getNode(final int index, final boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n+        // Check the index is within the bounds\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") less than zero.\");\n+        }\n+        if (!endMarkerAllowed && index == size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") is the size of the list.\");\n+        }\n+        if (index > size) {\n+            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n+                    \"index (\" + index + \") greater than the size of the \" +\n+                    \"list (\" + size + \").\");\n+        }\n+        // Search the list and get the node\n+        Node<E> node;\n+        if (index < size / 2) {\n+            // Search forwards\n+            node = header.next;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                node = node.next;\n+            }\n+        } else {\n+            // Search backwards\n+            node = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                node = node.previous;\n+            }\n+        }\n+        return node;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates an iterator for the sublist.\n+     *\n+     * @param subList  the sublist to get an iterator for\n+     * @return a new iterator on the given sublist\n+     */\n+    protected Iterator<E> createSubListIterator(final LinkedSubList<E> subList) {\n+        return createSubListListIterator(subList, 0);\n+    }\n+\n+    /**\n+     * Creates a list iterator for the sublist.\n+     *\n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     * @return a new list iterator on the given sublist\n+     */\n+    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n+        return new LinkedSubListIterator<E>(subList, fromIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * <code>writeObject</code>.\n+     * \n+     * @param outputStream  the stream to write the object to\n+     * @throws IOException  if anything goes wrong\n+     */\n+    protected void doWriteObject(final ObjectOutputStream outputStream) throws IOException {\n+        // Write the size so we know how many nodes to read back\n+        outputStream.writeInt(size());\n+        for (final E e : this) {\n+            outputStream.writeObject(e);\n+        }\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     * <p>\n+     * The first serializable subclass must call this method from\n+     * <code>readObject</code>.\n+     * \n+     * @param inputStream  the stream to read the object from\n+     * @throws IOException  if any error occurs while reading from the stream\n+     * @throws ClassNotFoundException  if a class read from the stream can not be loaded\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(final ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n+        init();\n+        final int size = inputStream.readInt();\n+        for (int i = 0; i < size; i++) {\n+            add((E) inputStream.readObject());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node within the linked list.\n+     * <p>\n+     * From Commons Collections 3.1, all access to the <code>value</code> property\n+     * is via the methods on this class.\n+     */\n+    protected static class Node<E> {\n+\n+        /** A pointer to the node before this node */\n+        protected Node<E> previous;\n+        /** A pointer to the node after this node */\n+        protected Node<E> next;\n+        /** The object contained within this node */\n+        protected E value;\n+\n+        /**\n+         * Constructs a new header node.\n+         */\n+        protected Node() {\n+            super();\n+            previous = this;\n+            next = this;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         *\n+         * @param value  the value to store\n+         */\n+        protected Node(final E value) {\n+            super();\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Constructs a new node.\n+         *\n+         * @param previous  the previous node in the list\n+         * @param next  the next node in the list\n+         * @param value  the value to store\n+         */\n+        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n+            super();\n+            this.previous = previous;\n+            this.next = next;\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Gets the value of the node.\n+         *\n+         * @return the value\n+         * @since 3.1\n+         */\n+        protected E getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the value of the node.\n+         *\n+         * @param value  the value\n+         * @since 3.1\n+         */\n+        protected void setValue(final E value) {\n+            this.value = value;\n+        }\n+\n+        /**\n+         * Gets the previous node.\n+         *\n+         * @return the previous node\n+         * @since 3.1\n+         */\n+        protected Node<E> getPreviousNode() {\n+            return previous;\n+        }\n+\n+        /**\n+         * Sets the previous node.\n+         *\n+         * @param previous  the previous node\n+         * @since 3.1\n+         */\n+        protected void setPreviousNode(final Node<E> previous) {\n+            this.previous = previous;\n+        }\n+\n+        /**\n+         * Gets the next node.\n+         *\n+         * @return the next node\n+         * @since 3.1\n+         */\n+        protected Node<E> getNextNode() {\n+            return next;\n+        }\n+\n+        /**\n+         * Sets the next node.\n+         *\n+         * @param next  the next node\n+         * @since 3.1\n+         */\n+        protected void setNextNode(final Node<E> next) {\n+            this.next = next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A list iterator over the linked list.\n+     */\n+    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n+\n+        /** The parent list */\n+        protected final AbstractLinkedList<E> parent;\n+\n+        /**\n+         * The node that will be returned by {@link #next()}. If this is equal\n+         * to {@link AbstractLinkedList#header} then there are no more values to return.\n+         */\n+        protected Node<E> next;\n+\n+        /**\n+         * The index of {@link #next}.\n+         */\n+        protected int nextIndex;\n+\n+        /**\n+         * The last node that was returned by {@link #next()} or {@link\n+         * #previous()}. Set to <code>null</code> if {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n+         * this behaviour.\n+         */\n+        protected Node<E> current;\n+\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         *\n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n+         * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list\n+         */\n+        protected LinkedListIterator(final AbstractLinkedList<E> parent, final int fromIndex)\n+                throws IndexOutOfBoundsException {\n+            super();\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = parent.getNode(fromIndex, true);\n+            this.nextIndex = fromIndex;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         *\n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        /**\n+         * Gets the last node returned.\n+         *\n+         * @return the last node returned\n+         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n+         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         */\n+        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current;\n+        }\n+\n+        public boolean hasNext() {\n+            return next != parent.header;\n+        }\n+\n+        public E next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n+            }\n+            final E value = next.getValue();\n+            current = next;\n+            next = next.next;\n+            nextIndex++;\n+            return value;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return next.previous != parent.header;\n+        }\n+\n+        public E previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            next = next.previous;\n+            final E value = next.getValue();\n+            current = next;\n+            nextIndex--;\n+            return value;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            // not normally overridden, as relative to nextIndex()\n+            return nextIndex() - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            if (current == next) {\n+                // remove() following previous()\n+                next = next.next;\n+                parent.removeNode(getLastNodeReturned());\n+            } else {\n+                // remove() following next()\n+                parent.removeNode(getLastNodeReturned());\n+                nextIndex--;\n+            }\n+            current = null;\n+            expectedModCount++;\n+        }\n+\n+        public void set(final E obj) {\n+            checkModCount();\n+            getLastNodeReturned().setValue(obj);\n+        }\n+\n+        public void add(final E obj) {\n+            checkModCount();\n+            parent.addNodeBefore(next, obj);\n+            current = null;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A list iterator over the linked sub list.\n+     */\n+    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n+\n+        /** The parent list */\n+        protected final LinkedSubList<E> sub;\n+\n+        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n+            super(sub.parent, startIndex + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return nextIndex() < sub.size;\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+            return previousIndex() >= 0;\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+            return super.nextIndex() - sub.offset;\n+        }\n+\n+        @Override\n+        public void add(final E obj) {\n+            super.add(obj);\n+            sub.expectedModCount = parent.modCount;\n+            sub.size++;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = parent.modCount;\n+            sub.size--;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The sublist implementation for AbstractLinkedList.\n+     */\n+    protected static class LinkedSubList<E> extends AbstractList<E> {\n+        /** The main list */\n+        AbstractLinkedList<E> parent;\n+        /** Offset from the main list */\n+        int offset;\n+        /** Sublist size */\n+        int size;\n+        /** Sublist modCount */\n+        int expectedModCount;\n+\n+        protected LinkedSubList(final AbstractLinkedList<E> parent, final int fromIndex, final int toIndex) {\n+            if (fromIndex < 0) {\n+                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n+            }\n+            if (toIndex > parent.size()) {\n+                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n+            }\n+            if (fromIndex > toIndex) {\n+                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n+            }\n+            this.parent = parent;\n+            this.offset = fromIndex;\n+            this.size = toIndex - fromIndex;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        @Override\n+        public int size() {\n+            checkModCount();\n+            return size;\n+        }\n+\n+        @Override\n+        public E get(final int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return parent.get(index + offset);\n+        }\n+\n+        @Override\n+        public void add(final int index, final E obj) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            parent.add(index + offset, obj);\n+            expectedModCount = parent.modCount;\n+            size++;\n+            LinkedSubList.this.modCount++;\n+        }\n+\n+        @Override\n+        public E remove(final int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            final E result = parent.remove(index + offset);\n+            expectedModCount = parent.modCount;\n+            size--;\n+            LinkedSubList.this.modCount++;\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean addAll(final Collection<? extends E> coll) {\n+            return addAll(size, coll);\n+        }\n+\n+        @Override\n+        public boolean addAll(final int index, final Collection<? extends E> coll) {\n+            rangeCheck(index, size + 1);\n+            final int cSize = coll.size();\n+            if (cSize == 0) {\n+                return false;\n+            }\n+\n+            checkModCount();\n+            parent.addAll(offset + index, coll);\n+            expectedModCount = parent.modCount;\n+            size += cSize;\n+            LinkedSubList.this.modCount++;\n+            return true;\n+        }\n+\n+        @Override\n+        public E set(final int index, final E obj) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return parent.set(index + offset, obj);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            checkModCount();\n+            final Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            checkModCount();\n+            return parent.createSubListIterator(this);\n+        }\n+\n+        @Override\n+        public ListIterator<E> listIterator(final int index) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            return parent.createSubListListIterator(this, index);\n+        }\n+\n+        @Override\n+        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n+            return new LinkedSubList<E>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n+        }\n+\n+        protected void rangeCheck(final int index, final int beyond) {\n+            if (index < 0 || index >= beyond) {\n+                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n+            }\n+        }\n+\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another {@link List} to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated list.\n+ *\n+ * @param <E> the type of the elements in the list\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractListDecorator<E> extends AbstractCollectionDecorator<E>\n+        implements List<E> {\n+\n+    /** Serialization version--necessary in an abstract class? */\n+    private static final long serialVersionUID = 4500739654952315623L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractListDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractListDecorator(final List<E> list) {\n+        super(list);\n+    }\n+\n+    /**\n+     * Gets the list being decorated.\n+     * \n+     * @return the decorated list\n+     */\n+    @Override\n+    protected List<E> decorated() {\n+        return (List<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void add(final int index, final E object) {\n+        decorated().add(index, object);\n+    }\n+\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        return decorated().addAll(index, coll);\n+    }\n+\n+    public E get(final int index) {\n+        return decorated().get(index);\n+    }\n+\n+    public int indexOf(final Object object) {\n+        return decorated().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(final Object object) {\n+        return decorated().lastIndexOf(object);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return decorated().listIterator();\n+    }\n+\n+    public ListIterator<E> listIterator(final int index) {\n+        return decorated().listIterator(index);\n+    }\n+\n+    public E remove(final int index) {\n+        return decorated().remove(index);\n+    }\n+\n+    public E set(final int index, final E object) {\n+        return decorated().set(index, object);\n+    }\n+\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        return decorated().subList(fromIndex, toIndex);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * Serializable subclass of AbstractListDecorator.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractSerializableListDecorator<E>\n+        extends AbstractListDecorator<E>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2684959196747496299L;\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractSerializableListDecorator(final List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the list out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the list in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/CursorableLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * A <code>List</code> implementation with a <code>ListIterator</code> that\n+ * allows concurrent modifications to the underlying list.\n+ * <p>\n+ * This implementation supports all of the optional {@link List} operations.\n+ * It extends <code>AbstractLinkedList</code> and thus provides the\n+ * stack/queue/dequeue operations available in {@link java.util.LinkedList}.\n+ * <p>\n+ * The main feature of this class is the ability to modify the list and the\n+ * iterator at the same time. Both the {@link #listIterator()} and {@link #cursor()}\n+ * methods provides access to a <code>Cursor</code> instance which extends\n+ * <code>ListIterator</code>. The cursor allows changes to the list concurrent\n+ * with changes to the iterator. Note that the {@link #iterator()} method and\n+ * sublists do <b>not</b> provide this cursor behaviour.\n+ * <p>\n+ * The <code>Cursor</code> class is provided partly for backwards compatibility\n+ * and partly because it allows the cursor to be directly closed. Closing the\n+ * cursor is optional because references are held via a <code>WeakReference</code>.\n+ * For most purposes, simply modify the iterator and list at will, and then let\n+ * the garbage collector to the rest.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n+ *\n+ * @see java.util.LinkedList\n+ * @since 1.0\n+ * @version $Id$\n+ */\n+public class CursorableLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n+\n+    /** Ensure serialization compatibility */\n+    private static final long serialVersionUID = 8836393098519411393L;\n+\n+    /** A list of the cursor currently open on this list */\n+    protected transient List<WeakReference<Cursor<E>>> cursors;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates.\n+     */\n+    public CursorableLinkedList() {\n+        super();\n+        init(); // must call init() as use super();\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public CursorableLinkedList(final Collection<E> coll) {\n+        super(coll);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor called\n+     * by any constructor and by <code>readObject</code>.\n+     */\n+    @Override\n+    protected void init() {\n+        super.init();\n+        cursors = new ArrayList<WeakReference<Cursor<E>>>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an iterator that does <b>not</b> support concurrent modification.\n+     * <p>\n+     * If the underlying list is modified while iterating using this iterator\n+     * a ConcurrentModificationException will occur.\n+     * The cursor behaviour is available via {@link #listIterator()}.\n+     * \n+     * @return a new iterator that does <b>not</b> support concurrent modification\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return super.listIterator(0);\n+    }\n+\n+    /**\n+     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * \n+     * @return a new cursor iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return cursor(0);\n+    }\n+\n+    /**\n+     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * \n+     * @param fromIndex  the index to start from\n+     * @return a new cursor iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator(final int fromIndex) {\n+        return cursor(fromIndex);\n+    }\n+\n+    /**\n+     * Returns a {@link Cursor} for iterating through the elements of this list.\n+     * <p>\n+     * A <code>Cursor</code> is a <code>ListIterator</code> with an additional\n+     * <code>close()</code> method. Calling this method immediately discards the\n+     * references to the cursor. If it is not called, then the garbage collector\n+     * will still remove the reference as it is held via a <code>WeakReference</code>.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * <p>\n+     * The {@link #listIterator()} method returns the same as this method, and can\n+     * be cast to a <code>Cursor</code> if the <code>close</code> method is required.\n+     *\n+     * @return a new cursor iterator\n+     */\n+    public CursorableLinkedList.Cursor<E> cursor() {\n+        return cursor(0);\n+    }\n+\n+    /**\n+     * Returns a {@link Cursor} for iterating through the elements of this list\n+     * starting from a specified index.\n+     * <p>\n+     * A <code>Cursor</code> is a <code>ListIterator</code> with an additional\n+     * <code>close()</code> method. Calling this method immediately discards the\n+     * references to the cursor. If it is not called, then the garbage collector\n+     * will still remove the reference as it is held via a <code>WeakReference</code>.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * <p>\n+     * The {@link #listIterator(int)} method returns the same as this method, and can\n+     * be cast to a <code>Cursor</code> if the <code>close</code> method is required.\n+     *\n+     * @param fromIndex  the index to start from\n+     * @return a new cursor iterator\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     *      (index &lt; 0 || index &gt; size()).\n+     */\n+    public CursorableLinkedList.Cursor<E> cursor(final int fromIndex) {\n+        final Cursor<E> cursor = new Cursor<E>(this, fromIndex);\n+        registerCursor(cursor);\n+        return cursor;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     * \n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    @Override\n+    protected void updateNode(final Node<E> node, final E value) {\n+        super.updateNode(node, value);\n+        broadcastNodeChanged(node);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    @Override\n+    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n+        super.addNode(nodeToInsert, insertBeforeNode);\n+        broadcastNodeInserted(nodeToInsert);\n+    }\n+    \n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    @Override\n+    protected void removeNode(final Node<E> node) {\n+        super.removeNode(node);\n+        broadcastNodeRemoved(node);\n+    }\n+\n+    /**\n+     * Removes all nodes by iteration.\n+     */\n+    @Override\n+    protected void removeAllNodes() {\n+        if (size() > 0) {\n+            // superclass implementation would break all the iterators\n+            final Iterator<E> it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Registers a cursor to be notified of changes to this list.\n+     * \n+     * @param cursor  the cursor to register\n+     */\n+    protected void registerCursor(final Cursor<E> cursor) {\n+        // We take this opportunity to clean the cursors list\n+        // of WeakReference objects to garbage-collected cursors.\n+        for (final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            if (ref.get() == null) {\n+                it.remove();\n+            }\n+        }\n+        cursors.add(new WeakReference<Cursor<E>>(cursor));\n+    }\n+\n+    /**\n+     * Deregisters a cursor from the list to be notified of changes.\n+     * \n+     * @param cursor  the cursor to deregister\n+     */\n+    protected void unregisterCursor(final Cursor<E> cursor) {\n+        for (final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator(); it.hasNext();) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cur = ref.get();\n+            if (cur == null) {\n+                // some other unrelated cursor object has been \n+                // garbage-collected; let's take the opportunity to\n+                // clean up the cursors list anyway..\n+                it.remove();\n+            } else if (cur == cursor) {\n+                ref.clear();\n+                it.remove();\n+                break;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was changed.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeChanged(final Node<E> node) {\n+        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+        while (it.hasNext()) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cursor = ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeChanged(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was just removed from my list.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeRemoved(final Node<E> node) {\n+        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+        while (it.hasNext()) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cursor = ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeRemoved(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was just added to my list.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeInserted(final Node<E> node) {\n+        final Iterator<WeakReference<Cursor<E>>> it = cursors.iterator();\n+        while (it.hasNext()) {\n+            final WeakReference<Cursor<E>> ref = it.next();\n+            final Cursor<E> cursor = ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeInserted(node);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a list iterator for the sublist.\n+     * \n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     * @return the list iterator for the sublist\n+     */\n+    @Override\n+    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n+        final SubCursor<E> cursor = new SubCursor<E>(subList, fromIndex);\n+        registerCursor(cursor);\n+        return cursor;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An extended <code>ListIterator</code> that allows concurrent changes to\n+     * the underlying list.\n+     */\n+    public static class Cursor<E> extends AbstractLinkedList.LinkedListIterator<E> {\n+        /** Is the cursor valid (not closed) */\n+        boolean valid = true;\n+        /** Is the next index valid */\n+        boolean nextIndexValid = true;\n+        /** Flag to indicate if the current element was removed by another object. */\n+        boolean currentRemovedByAnother = false;\n+        \n+        /**\n+         * Constructs a new cursor.\n+         * \n+         * @param parent  the parent list\n+         * @param index  the index to start from\n+         */\n+        protected Cursor(final CursorableLinkedList<E> parent, final int index) {\n+            super(parent, index);\n+            valid = true;\n+        }\n+\n+        /**\n+         * Removes the item last returned by this iterator.\n+         * <p>\n+         * There may have been subsequent alterations to the list\n+         * since you obtained this item, however you can still remove it.\n+         * You can even remove it if the item is no longer in the main list.\n+         * However, you can't call this method on the same iterator more\n+         * than once without calling next() or previous().\n+         *\n+         * @throws IllegalStateException if there is no item to remove\n+         */\n+        @Override\n+        public void remove() {\n+            // overridden, as the nodeRemoved() method updates the iterator\n+            // state in the parent.removeNode() call below\n+            if (current == null && currentRemovedByAnother) {\n+                // quietly ignore, as the last returned node was removed\n+                // by the list or some other iterator\n+                // by ignoring it, we keep this iterator independent from\n+                // other changes as much as possible\n+            } else {\n+                checkModCount();\n+                parent.removeNode(getLastNodeReturned());\n+            }\n+            currentRemovedByAnother = false;\n+        }\n+\n+        /**\n+         * Adds an object to the list.\n+         * The object added here will be the new 'previous' in the iterator.\n+         * \n+         * @param obj  the object to add\n+         */\n+        @Override\n+        public void add(final E obj) {\n+            // overridden, as the nodeInserted() method updates the iterator state\n+            super.add(obj);\n+            // matches the (next.previous == node) clause in nodeInserted()\n+            // thus next gets changed - reset it again here\n+            next = next.next;\n+        }\n+        \n+        // set is not overridden, as it works ok\n+        // note that we want it to throw an exception if the element being\n+        // set has been removed from the real list (compare this with the\n+        // remove method where we silently ignore this case)\n+\n+        /**\n+         * Gets the index of the next element to be returned.\n+         * \n+         * @return the next index\n+         */\n+        @Override\n+        public int nextIndex() {\n+            if (nextIndexValid == false) {\n+                if (next == parent.header) {\n+                    nextIndex = parent.size();\n+                } else {\n+                    int pos = 0;\n+                    Node<E> temp = parent.header.next;\n+                    while (temp != next) {\n+                        pos++;\n+                        temp = temp.next;\n+                    }\n+                    nextIndex = pos;\n+                }\n+                nextIndexValid = true;\n+            }\n+            return nextIndex;\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has changed.\n+         * \n+         * @param node  the node that changed\n+         */\n+        protected void nodeChanged(final Node<E> node) {\n+            // do nothing\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has been removed.\n+         * \n+         * @param node  the node that was removed\n+         */\n+        protected void nodeRemoved(final Node<E> node) {\n+            if (node == next && node == current) {\n+                // state where next() followed by previous()\n+                next = node.next;\n+                current = null;\n+                currentRemovedByAnother = true;\n+            } else if (node == next) {\n+                // state where next() not followed by previous()\n+                // and we are matching next node\n+                next = node.next;\n+                currentRemovedByAnother = false;\n+            } else if (node == current) {\n+                // state where next() not followed by previous()\n+                // and we are matching current (last returned) node\n+                current = null;\n+                currentRemovedByAnother = true;\n+                nextIndex--;\n+            } else {\n+                nextIndexValid = false;\n+                currentRemovedByAnother = false;\n+            }\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has been added.\n+         * \n+         * @param node  the node that was added\n+         */\n+        protected void nodeInserted(final Node<E> node) {\n+            if (node.previous == current) {\n+                next = node;\n+            } else if (next.previous == node) {\n+                next = node;\n+            } else {\n+                nextIndexValid = false;\n+            }\n+        }\n+\n+        /**\n+         * Override superclass modCount check, and replace it with our valid flag.\n+         */\n+        @Override\n+        protected void checkModCount() {\n+            if (!valid) {\n+                throw new ConcurrentModificationException(\"Cursor closed\");\n+            }\n+        }\n+\n+        /**\n+         * Mark this cursor as no longer being needed. Any resources\n+         * associated with this cursor are immediately released.\n+         * In previous versions of this class, it was mandatory to close\n+         * all cursor objects to avoid memory leaks. It is <i>no longer</i>\n+         * necessary to call this close method; an instance of this class\n+         * can now be treated exactly like a normal iterator.\n+         */\n+        public void close() {\n+            if (valid) {\n+                ((CursorableLinkedList<E>) parent).unregisterCursor(this);\n+                valid = false;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A cursor for the sublist based on LinkedSubListIterator.\n+     *\n+     * @since 3.2\n+     */\n+    protected static class SubCursor<E> extends Cursor<E> {\n+\n+        /** The parent list */\n+        protected final LinkedSubList<E> sub;\n+\n+        /**\n+         * Constructs a new cursor.\n+         * \n+         * @param sub  the sub list\n+         * @param index  the index to start from\n+         */\n+        protected SubCursor(final LinkedSubList<E> sub, final int index) {\n+            super((CursorableLinkedList<E>) sub.parent, index + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return nextIndex() < sub.size;\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+            return previousIndex() >= 0;\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+            return super.nextIndex() - sub.offset;\n+        }\n+\n+        @Override\n+        public void add(final E obj) {\n+            super.add(obj);\n+            sub.expectedModCount = parent.modCount;\n+            sub.size++;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = parent.modCount;\n+            sub.size--;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.BoundedCollection;\n+import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>List</code> to fix the size preventing add/remove.\n+ * <p>\n+ * The add, remove, clear and retain operations are unsupported.\n+ * The set method is allowed (as it doesn't change the list size).\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedSizeList<E>\n+        extends AbstractSerializableListDecorator<E>\n+        implements BoundedCollection<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2218010673611160319L;\n+\n+    /**\n+     * Factory method to create a fixed size list.\n+     * \n+     * @param <E> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @return a new fixed size list\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n+        return new FixedSizeList<E>(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected FixedSizeList(final List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public void add(final int index, final E object) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public E get(final int index) {\n+        return decorated().get(index);\n+    }\n+\n+    @Override\n+    public int indexOf(final Object object) {\n+        return decorated().indexOf(object);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public int lastIndexOf(final Object object) {\n+        return decorated().lastIndexOf(object);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return new FixedSizeListIterator(decorated().listIterator(0));\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(final int index) {\n+        return new FixedSizeListIterator(decorated().listIterator(index));\n+    }\n+\n+    @Override\n+    public E remove(final int index) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException(\"List is fixed size\");\n+    }\n+\n+    @Override\n+    public E set(final int index, final E object) {\n+        return decorated().set(index, object);\n+    }\n+\n+    @Override\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new FixedSizeList<E>(sub);\n+    }\n+\n+    /**\n+     * List iterator that only permits changes via set()\n+     */\n+    private class FixedSizeListIterator extends AbstractListIteratorDecorator<E> {\n+        protected FixedSizeListIterator(final ListIterator<E> iterator) {\n+            super(iterator);\n+        }\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException(\"List is fixed size\");\n+        }\n+        @Override\n+        public void add(final Object object) {\n+            throw new UnsupportedOperationException(\"List is fixed size\");\n+        }\n+    }\n+\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    public int maxSize() {\n+        return size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/GrowthList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Decorates another <code>List</code> to make it seamlessly grow when\n+ * indices larger than the list size are used on add and set,\n+ * avoiding most IndexOutOfBoundsExceptions.\n+ * <p>\n+ * This class avoids errors by growing when a set or add method would\n+ * normally throw an IndexOutOfBoundsException.\n+ * Note that IndexOutOfBoundsException IS returned for invalid negative indices.\n+ * <p>\n+ * Trying to set or add to an index larger than the size will cause the list\n+ * to grow (using <code>null</code> elements). Clearly, care must be taken\n+ * not to use excessively large indices, as the internal list will grow to\n+ * match.\n+ * <p>\n+ * Trying to use any method other than add or set with an invalid index will\n+ * call the underlying list and probably result in an IndexOutOfBoundsException.\n+ * <p>\n+ * Take care when using this list with <code>null</code> values, as\n+ * <code>null</code> is the value added when growing the list.\n+ * <p>\n+ * All sub-lists will access the underlying list directly, and will throw\n+ * IndexOutOfBoundsExceptions.\n+ * <p>\n+ * This class differs from {@link LazyList} because here growth occurs on\n+ * set and add, where <code>LazyList</code> grows on get. However, they\n+ * can be used together by decorating twice.\n+ *\n+ * @see LazyList\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class GrowthList<E> extends AbstractSerializableListDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3620001881672L;\n+\n+    /**\n+     * Factory method to create a growth list.\n+     *\n+     * @param <E> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @return a new growth list\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> GrowthList<E> growthList(final List<E> list) {\n+        return new GrowthList<E>(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that uses an ArrayList internally.\n+     */\n+    public GrowthList() {\n+        super(new ArrayList<E>());\n+    }\n+\n+    /**\n+     * Constructor that uses an ArrayList internally.\n+     *\n+     * @param initialSize  the initial size of the ArrayList\n+     * @throws IllegalArgumentException if initial size is invalid\n+     */\n+    public GrowthList(final int initialSize) {\n+        super(new ArrayList<E>(initialSize));\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected GrowthList(final List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the add method to perform the growth behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will\n+     * grow to the new size. Indices between the old size and the requested\n+     * size will be filled with <code>null</code>.\n+     * <p>\n+     * If the index is less than the current size, the value will be added to\n+     * the underlying list directly.\n+     * If the index is less than zero, the underlying list is called, which\n+     * will probably throw an IndexOutOfBoundsException.\n+     *\n+     * @param index  the index to add at\n+     * @param element  the object to add at the specified index\n+     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n+     * @throws ClassCastException if the underlying list rejects the element\n+     * @throws IllegalArgumentException if the underlying list rejects the element\n+     */\n+    @Override\n+    public void add(final int index, final E element) {\n+        final int size = decorated().size();\n+        if (index > size) {\n+            decorated().addAll(Collections.<E>nCopies(index - size, null));\n+        }\n+        decorated().add(index, element);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the addAll method to perform the growth behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will\n+     * grow to the new size. Indices between the old size and the requested\n+     * size will be filled with <code>null</code>.\n+     * <p>\n+     * If the index is less than the current size, the values will be added to\n+     * the underlying list directly.\n+     * If the index is less than zero, the underlying list is called, which\n+     * will probably throw an IndexOutOfBoundsException.\n+     *\n+     * @param index  the index to add at\n+     * @param coll  the collection to add at the specified index\n+     * @return true if the list changed\n+     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n+     * @throws ClassCastException if the underlying list rejects the element\n+     * @throws IllegalArgumentException if the underlying list rejects the element\n+     */\n+    @Override\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        final int size = decorated().size();\n+        boolean result = false;\n+        if (index > size) {\n+            decorated().addAll(Collections.<E>nCopies(index - size, null));\n+            result = true;\n+        }\n+        return decorated().addAll(index, coll) | result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the set method to perform the growth behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will\n+     * grow to the new size. Indices between the old size and the requested\n+     * size will be filled with <code>null</code>.\n+     * <p>\n+     * If the index is less than the current size, the value will be set onto\n+     * the underlying list directly.\n+     * If the index is less than zero, the underlying list is called, which\n+     * will probably throw an IndexOutOfBoundsException.\n+     *\n+     * @param index  the index to set\n+     * @param element  the object to set at the specified index\n+     * @return the object previously at that index\n+     * @throws UnsupportedOperationException if the underlying list doesn't implement set\n+     * @throws ClassCastException if the underlying list rejects the element\n+     * @throws IllegalArgumentException if the underlying list rejects the element\n+     */\n+    @Override\n+    public E set(final int index, final E element) {\n+        final int size = decorated().size();\n+        if (index >= size) {\n+            decorated().addAll(Collections.<E>nCopies(index - size + 1, null));\n+        }\n+        return decorated().set(index, element);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/LazyList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Factory;\n+\n+/**\n+ * Decorates another <code>List</code> to create objects in the list on demand.\n+ * <p>\n+ * When the {@link #get(int)} method is called with an index greater than\n+ * the size of the list, the list will automatically grow in size and return\n+ * a new object from the specified factory. The gaps will be filled by null.\n+ * If a get method call encounters a null, it will be replaced with a new\n+ * object from the factory. Thus this list is unsuitable for storing null\n+ * objects.\n+ * <p>\n+ * For instance:\n+ *\n+ * <pre>\n+ * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n+ *     public Date create() {\n+ *         return new Date();\n+ *     }\n+ * }\n+ * List&lt;Date&gt; lazy = LazyList.decorate(new ArrayList&lt;Date&gt;(), factory);\n+ * Date date = lazy.get(3);\n+ * </pre>\n+ *\n+ * After the above code is executed, <code>date</code> will contain\n+ * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+ * instance is the fourth element in the list.  The first, second, \n+ * and third element are all set to <code>null</code>.\n+ * <p>\n+ * This class differs from {@link GrowthList} because here growth occurs on\n+ * get, where <code>GrowthList</code> grows on set and add. However, they\n+ * could easily be used together by decorating twice.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @see GrowthList\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class LazyList<E> extends AbstractSerializableListDecorator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1708388017160694542L;\n+\n+    /** The factory to use to lazily instantiate the objects */\n+    protected final Factory<? extends E> factory;\n+\n+    /**\n+     * Factory method to create a lazily instantiating list.\n+     * \n+     * @param <E> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @param factory  the factory to use for creation, must not be null\n+     * @return a new lazy list\n+     * @throws IllegalArgumentException if list or factory is null\n+     */\n+    public static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n+        return new LazyList<E>(list, factory);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param factory  the factory to use for creation, must not be null\n+     * @throws IllegalArgumentException if list or factory is null\n+     */\n+    protected LazyList(final List<E> list, final Factory<? extends E> factory) {\n+        super(list);\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        this.factory = factory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorate the get method to perform the lazy behaviour.\n+     * <p>\n+     * If the requested index is greater than the current size, the list will \n+     * grow to the new size and a new object will be returned from the factory.\n+     * Indexes in-between the old size and the requested size are left with a \n+     * placeholder that is replaced with a factory object when requested.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the element at the given index\n+     */\n+    @Override\n+    public E get(final int index) {\n+        final int size = decorated().size();\n+        if (index < size) {\n+            // within bounds, get the object\n+            E object = decorated().get(index);\n+            if (object == null) {\n+                // item is a place holder, create new one, set and return\n+                object = factory.create();\n+                decorated().set(index, object);\n+                return object;\n+            }\n+            // good and ready to go\n+            return object;\n+        }\n+        // we have to grow the list\n+        for (int i = size; i < index; i++) {\n+            decorated().add(null);\n+        }\n+        // create our last object, set and return\n+        final E object = factory.create();\n+        decorated().add(object);\n+        return object;\n+    }\n+\n+    @Override\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new LazyList<E>(sub, factory);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/NodeCachingLinkedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+/**\n+ * A <code>List</code> implementation that stores a cache of internal Node objects\n+ * in an effort to reduce wasteful object creation.\n+ * <p>\n+ * A linked list creates one Node for each item of data added. This can result in\n+ * a lot of object creation and garbage collection. This implementation seeks to\n+ * avoid that by maintaining a store of cached nodes.\n+ * <p>\n+ * This implementation is suitable for long-lived lists where both add and remove\n+ * are used. Short-lived lists, or lists which only grow will have worse performance\n+ * using this class.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class NodeCachingLinkedList<E> extends AbstractLinkedList<E> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6897789178562232073L;\n+\n+    /**\n+     * The default value for {@link #maximumCacheSize}.\n+     */\n+    protected static final int DEFAULT_MAXIMUM_CACHE_SIZE = 20;\n+\n+    /**\n+     * The first cached node, or <code>null</code> if no nodes are cached.\n+     * Cached nodes are stored in a singly-linked list with\n+     * <code>next</code> pointing to the next element.\n+     */\n+    protected transient Node<E> firstCachedNode;\n+    \n+    /**\n+     * The size of the cache.\n+     */\n+    protected transient int cacheSize;\n+\n+    /**\n+     * The maximum size of the cache.\n+     */\n+    protected int maximumCacheSize;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates.\n+     */\n+    public NodeCachingLinkedList() {\n+        this(DEFAULT_MAXIMUM_CACHE_SIZE);\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public NodeCachingLinkedList(final Collection<E> coll) {\n+        super(coll);\n+        this.maximumCacheSize = DEFAULT_MAXIMUM_CACHE_SIZE;\n+    }\n+    \n+    /**\n+     * Constructor that species the maximum cache size.\n+     *\n+     * @param maximumCacheSize  the maximum cache size\n+     */\n+    public NodeCachingLinkedList(final int maximumCacheSize) {\n+        super();\n+        this.maximumCacheSize = maximumCacheSize;\n+        init();  // must call init() as use super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the maximum size of the cache.\n+     * \n+     * @return the maximum cache size\n+     */\n+    protected int getMaximumCacheSize() {\n+        return maximumCacheSize;\n+    }\n+\n+    /**\n+     * Sets the maximum size of the cache.\n+     * \n+     * @param maximumCacheSize  the new maximum cache size\n+     */\n+    protected void setMaximumCacheSize(final int maximumCacheSize) {\n+        this.maximumCacheSize = maximumCacheSize;\n+        shrinkCacheToMaximumSize();\n+    }\n+\n+    /**\n+     * Reduce the size of the cache to the maximum, if necessary.\n+     */\n+    protected void shrinkCacheToMaximumSize() {\n+        // Rich Dougherty: This could be more efficient.\n+        while (cacheSize > maximumCacheSize) {\n+            getNodeFromCache();\n+        }\n+    }\n+    \n+    /**\n+     * Gets a node from the cache. If a node is returned, then the value of\n+     * {@link #cacheSize} is decreased accordingly. The node that is returned\n+     * will have <code>null</code> values for next, previous and element.\n+     *\n+     * @return a node, or <code>null</code> if there are no nodes in the cache.\n+     */\n+    protected Node<E> getNodeFromCache() {\n+        if (cacheSize == 0) {\n+            return null;\n+        }\n+        final Node<E> cachedNode = firstCachedNode;\n+        firstCachedNode = cachedNode.next;\n+        cachedNode.next = null; // This should be changed anyway, but defensively\n+                                // set it to null.                    \n+        cacheSize--;\n+        return cachedNode;\n+    }\n+    \n+    /**\n+     * Checks whether the cache is full.\n+     * \n+     * @return true if the cache is full\n+     */\n+    protected boolean isCacheFull() {\n+        return cacheSize >= maximumCacheSize;\n+    }\n+    \n+    /**\n+     * Adds a node to the cache, if the cache isn't full.\n+     * The node's contents are cleared to so they can be garbage collected.\n+     * \n+     * @param node  the node to add to the cache\n+     */\n+    protected void addNodeToCache(final Node<E> node) {\n+        if (isCacheFull()) {\n+            // don't cache the node.\n+            return;\n+        }\n+        // clear the node's contents and add it to the cache.\n+        final Node<E> nextCachedNode = firstCachedNode;\n+        node.previous = null;\n+        node.next = nextCachedNode;\n+        node.setValue(null);\n+        firstCachedNode = node;\n+        cacheSize++;\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a new node, either by reusing one from the cache or creating\n+     * a new one.\n+     * \n+     * @param value  value of the new node\n+     * @return the newly created node\n+     */\n+    @Override\n+    protected Node<E> createNode(final E value) {\n+        final Node<E> cachedNode = getNodeFromCache();\n+        if (cachedNode == null) {\n+            return super.createNode(value);\n+        }\n+        cachedNode.setValue(value);\n+        return cachedNode;\n+    }\n+\n+    /**\n+     * Removes the node from the list, storing it in the cache for reuse\n+     * if the cache is not yet full.\n+     * \n+     * @param node  the node to remove\n+     */\n+    @Override\n+    protected void removeNode(final Node<E> node) {\n+        super.removeNode(node);\n+        addNodeToCache(node);\n+    }\n+    \n+    /**\n+     * Removes all the nodes from the list, storing as many as required in the\n+     * cache for reuse.\n+     * \n+     */\n+    @Override\n+    protected void removeAllNodes() {\n+        // Add the removed nodes to the cache, then remove the rest.\n+        // We can add them to the cache before removing them, since\n+        // {@link AbstractLinkedList.removeAllNodes()} removes the\n+        // nodes by removing references directly from {@link #header}.\n+        final int numberOfNodesToCache = Math.min(size, maximumCacheSize - cacheSize);\n+        Node<E> node = header.next;\n+        for (int currentIndex = 0; currentIndex < numberOfNodesToCache; currentIndex++) {\n+            final Node<E> oldNode = node;\n+            node = node.next;\n+            addNodeToCache(oldNode);\n+        }\n+        super.removeAllNodes();        \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * Decorates another <code>List</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This list exists to provide validation for the decorated list.\n+ * It is normally created to decorate an empty list.\n+ * If an object cannot be added to the list, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the list.\n+ * <pre>List list = PredicatedList.decorate(new ArrayList(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedList<E> extends PredicatedCollection<E> implements List<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5722039223898659102L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) list.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param <T> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated list\n+     * @throws IllegalArgumentException if list or predicate is null\n+     * @throws IllegalArgumentException if the list contains invalid elements\n+     */\n+    public static <T> PredicatedList<T> predicatedList(final List<T> list, final Predicate<? super T> predicate) {\n+        return new PredicatedList<T>(list, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if list or predicate is null\n+     * @throws IllegalArgumentException if the list contains invalid elements\n+     */\n+    protected PredicatedList(final List<E> list, final Predicate<? super E> predicate) {\n+        super(list, predicate);\n+    }\n+\n+    /**\n+     * Gets the list being decorated.\n+     * \n+     * @return the decorated list\n+     */\n+    @Override\n+    protected List<E> decorated() {\n+        return (List<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E get(final int index) {\n+        return decorated().get(index);\n+    }\n+\n+    public int indexOf(final Object object) {\n+        return decorated().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(final Object object) {\n+        return decorated().lastIndexOf(object);\n+    }\n+\n+    public E remove(final int index) {\n+        return decorated().remove(index);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void add(final int index, final E object) {\n+        validate(object);\n+        decorated().add(index, object);\n+    }\n+\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        for (final E aColl : coll) {\n+            validate(aColl);\n+        }\n+        return decorated().addAll(index, coll);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return listIterator(0);\n+    }\n+\n+    public ListIterator<E> listIterator(final int i) {\n+        return new PredicatedListIterator(decorated().listIterator(i));\n+    }\n+\n+    public E set(final int index, final E object) {\n+        validate(object);\n+        return decorated().set(index, object);\n+    }\n+\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new PredicatedList<E>(sub, predicate);\n+    }\n+\n+    /**\n+     * Inner class Iterator for the PredicatedList\n+     */\n+    protected class PredicatedListIterator extends AbstractListIteratorDecorator<E> {\n+        \n+        /**\n+         * Create a new predicated list iterator.\n+         * \n+         * @param iterator  the list iterator to decorate\n+         */\n+        protected PredicatedListIterator(final ListIterator<E> iterator) {\n+            super(iterator);\n+        }\n+        \n+        @Override\n+        public void add(final E object) {\n+            validate(object);\n+            iterator.add(object);\n+        }\n+        \n+        @Override\n+        public void set(final E object) {\n+            validate(object);\n+            iterator.set(object);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;\n+\n+/**\n+ * Decorates a <code>List</code> to ensure that no duplicates are present much\n+ * like a <code>Set</code>.\n+ * <p>\n+ * The <code>List</code> interface makes certain assumptions/requirements. This\n+ * implementation breaks these in certain ways, but this is merely the result of\n+ * rejecting duplicates. Each violation is explained in the method, but it\n+ * should not affect you. Bear in mind that Sets require immutable objects to\n+ * function correctly.\n+ * <p>\n+ * The {@link org.apache.commons.collections.set.ListOrderedSet ListOrderedSet}\n+ * class provides an alternative approach, by wrapping an existing Set and\n+ * retaining insertion order in the iterator.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * \n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 7196982186153478694L;\n+\n+    /** Internal Set to maintain uniqueness. */\n+    protected final Set<E> set;\n+\n+    /**\n+     * Factory method to create a SetList using the supplied list to retain\n+     * order.\n+     * <p>\n+     * If the list contains duplicates, these are removed (first indexed one\n+     * kept). A <code>HashSet</code> is used for the set behaviour.\n+     * \n+     * @param <E>\n+     *            the element type\n+     * @param list\n+     *            the list to decorate, must not be null\n+     * @return a new {@link SetUniqueList}\n+     * @throws IllegalArgumentException\n+     *             if list is null\n+     */\n+    public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (list.isEmpty()) {\n+            return new SetUniqueList<E>(list, new HashSet<E>());\n+        }\n+        final List<E> temp = new ArrayList<E>(list);\n+        list.clear();\n+        final SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n+        sl.addAll(temp);\n+        return sl;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) the List and specifies the set to\n+     * use.\n+     * <p>\n+     * The set and list must both be correctly initialised to the same elements.\n+     * \n+     * @param set\n+     *            the set to decorate, must not be null\n+     * @param list\n+     *            the list to decorate, must not be null\n+     * @throws IllegalArgumentException\n+     *             if set or list is null\n+     */\n+    protected SetUniqueList(final List<E> list, final Set<E> set) {\n+        super(list);\n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        this.set = set;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Gets an unmodifiable view as a Set.\n+     * \n+     * @return an unmodifiable set view\n+     */\n+    public Set<E> asSet() {\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Adds an element to the list if it is not already present.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface requires that this\n+     * method returns <code>true</code> always. However this class may return\n+     * <code>false</code> because of the <code>Set</code> behaviour.\n+     * \n+     * @param object\n+     *            the object to add\n+     * @return true if object was added\n+     */\n+    @Override\n+    public boolean add(final E object) {\n+        // gets initial size\n+        final int sizeBefore = size();\n+\n+        // adds element if unique\n+        add(size(), object);\n+\n+        // compares sizes to detect if collection changed\n+        return sizeBefore != size();\n+    }\n+\n+    /**\n+     * Adds an element to a specific index in the list if it is not already\n+     * present.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+     * that the element is always inserted. This may not happen with this\n+     * implementation.\n+     * \n+     * @param index\n+     *            the index to insert at\n+     * @param object\n+     *            the object to add\n+     */\n+    @Override\n+    public void add(final int index, final E object) {\n+        // adds element if it is not contained already\n+        if (set.contains(object) == false) {\n+            super.add(index, object);\n+            set.add(object);\n+        }\n+    }\n+\n+    /**\n+     * Adds a collection of objects to the end of the list avoiding duplicates.\n+     * <p>\n+     * Only elements that are not already in this list will be added, and\n+     * duplicates from the specified collection will be ignored.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+     * that the elements are always inserted. This may not happen with this\n+     * implementation.\n+     * \n+     * @param coll\n+     *            the collection to add in iterator order\n+     * @return true if this collection changed\n+     */\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        return addAll(size(), coll);\n+    }\n+\n+    /**\n+     * Adds a collection of objects a specific index in the list avoiding\n+     * duplicates.\n+     * <p>\n+     * Only elements that are not already in this list will be added, and\n+     * duplicates from the specified collection will be ignored.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+     * that the elements are always inserted. This may not happen with this\n+     * implementation.\n+     * \n+     * @param index\n+     *            the index to insert at\n+     * @param coll\n+     *            the collection to add in iterator order\n+     * @return true if this collection changed\n+     */\n+    @Override\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        final List<E> temp = new ArrayList<E>();\n+        for (final E e : coll) {\n+            if (set.add(e)) {\n+                temp.add(e);\n+            }\n+        }\n+        return super.addAll(index, temp);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Sets the value at the specified index avoiding duplicates.\n+     * <p>\n+     * The object is set into the specified index. Afterwards, any previous\n+     * duplicate is removed If the object is not already in the list then a\n+     * normal set occurs. If it is present, then the old version is removed.\n+     * \n+     * @param index\n+     *            the index to insert at\n+     * @param object\n+     *            the object to set\n+     * @return the previous object\n+     */\n+    @Override\n+    public E set(final int index, final E object) {\n+        final int pos = indexOf(object);\n+        final E removed = super.set(index, object);\n+\n+        if (pos != -1 && pos != index) {\n+            // the object is already in the uniq list\n+            // (and it hasn't been swapped with itself)\n+            super.remove(pos); // remove the duplicate by index\n+            set.remove(removed); // remove the item deleted by the set\n+        } else if (pos == -1) {\n+            set.add(object); // add the new item to the unique set\n+            set.remove(removed); // remove the item deleted by the set\n+        }\n+        \n+        return removed; // return the item deleted by the set\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        final boolean result = set.remove(object);\n+        if (result) {\n+            super.remove(object);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public E remove(final int index) {\n+        final E result = super.remove(index);\n+        set.remove(result);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean result = false;\n+        for (final Object name : coll) {\n+            result |= remove(name);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        final Set<Object> setRetainAll = new HashSet<Object>();\n+        for (final Object next : coll) {\n+            if (set.contains(next)) {\n+                setRetainAll.add(next);\n+            }\n+        }\n+        if (setRetainAll.size() == set.size()) {\n+            return false;\n+        }\n+        if (setRetainAll.size() == 0) {\n+            clear();\n+        } else {\n+            for (final Iterator<E> it = iterator(); it.hasNext();) {\n+                if (!setRetainAll.contains(it.next())) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        set.clear();\n+    }\n+\n+    @Override\n+    public boolean contains(final Object object) {\n+        return set.contains(object);\n+    }\n+\n+    @Override\n+    public boolean containsAll(final Collection<?> coll) {\n+        return set.containsAll(coll);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new SetListIterator<E>(super.iterator(), set);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return new SetListListIterator<E>(super.listIterator(), set);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(final int index) {\n+        return new SetListListIterator<E>(super.listIterator(index), set);\n+    }\n+\n+    @Override\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> superSubList = super.subList(fromIndex, toIndex);\n+        final Set<E> subSet = createSetBasedOnList(set, superSubList);\n+        return new SetUniqueList<E>(superSubList, subSet);\n+    }\n+\n+    /**\n+     * Create a new {@link Set} with the same type as the provided {@code set}\n+     * and populate it with all elements of {@code list}.\n+     * \n+     * @param set\n+     *            the {@link Set} to be used as return type, must not be null\n+     * @param list\n+     *            the {@link List} to populate the {@link Set}\n+     * @return a new {@link Set} populated with all elements of the provided\n+     *         {@link List}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> createSetBasedOnList(final Set<E> set, final List<E> list) {\n+        Set<E> subSet;\n+        if (set.getClass().equals(HashSet.class)) {\n+            subSet = new HashSet<E>(list.size());\n+        } else {\n+            try {\n+                subSet = set.getClass().newInstance();\n+            } catch (final InstantiationException ie) {\n+                subSet = new HashSet<E>();\n+            } catch (final IllegalAccessException iae) {\n+                subSet = new HashSet<E>();\n+            }\n+        }\n+        subSet.addAll(list);\n+        return subSet;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Inner class iterator.\n+     */\n+    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListIterator(final Iterator<E> it, final Set<E> set) {\n+            super(it);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+    }\n+\n+    /**\n+     * Inner class iterator.\n+     */\n+    static class SetListListIterator<E> extends\n+            AbstractListIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListListIterator(final ListIterator<E> it, final Set<E> set) {\n+            super(it);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public E previous() {\n+            last = super.previous();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+\n+        @Override\n+        public void add(final E object) {\n+            if (set.contains(object) == false) {\n+                super.add(object);\n+                set.add(object);\n+            }\n+        }\n+\n+        @Override\n+        public void set(final E object) {\n+            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+import org.apache.commons.collections4.iterators.AbstractListIteratorDecorator;\n+\n+/**\n+ * Decorates another <code>List</code> to transform objects that are added.\n+ * <p>\n+ * The add and set methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedList<E> extends TransformedCollection<E> implements List<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1077193035000013141L;\n+\n+    /**\n+     * Factory method to create a transforming list.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedList(List, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed list\n+     * @throws IllegalArgumentException if list or transformer is null\n+     */\n+    public static <E> TransformedList<E> transformingList(final List<E> list,\n+                                                          final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedList<E>(list, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming list that will transform\n+     * existing contents of the specified list.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingList(List, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed List\n+     * @throws IllegalArgumentException if list or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> TransformedList<E> transformedList(final List<E> list,\n+                                                         final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n+        if (transformer != null && list != null && list.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // list is of type E\n+            final E[] values = (E[]) list.toArray();\n+            list.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if list or transformer is null\n+     */\n+    protected TransformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n+        super(list, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated list.\n+     * \n+     * @return the decorated list\n+     */\n+    protected List<E> getList() {\n+        return (List<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public E get(final int index) {\n+        return getList().get(index);\n+    }\n+\n+    public int indexOf(final Object object) {\n+        return getList().indexOf(object);\n+    }\n+\n+    public int lastIndexOf(final Object object) {\n+        return getList().lastIndexOf(object);\n+    }\n+\n+    public E remove(final int index) {\n+        return getList().remove(index);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void add(final int index, E object) {\n+        object = transform(object);\n+        getList().add(index, object);\n+    }\n+\n+    public boolean addAll(final int index, Collection<? extends E> coll) {\n+        coll = transform(coll);\n+        return getList().addAll(index, coll);\n+    }\n+\n+    public ListIterator<E> listIterator() {\n+        return listIterator(0);\n+    }\n+\n+    public ListIterator<E> listIterator(final int i) {\n+        return new TransformedListIterator(getList().listIterator(i));\n+    }\n+\n+    public E set(final int index, E object) {\n+        object = transform(object);\n+        return getList().set(index, object);\n+    }\n+\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = getList().subList(fromIndex, toIndex);\n+        return new TransformedList<E>(sub, transformer);\n+    }\n+\n+    /**\n+     * Inner class Iterator for the TransformedList\n+     */\n+    protected class TransformedListIterator extends AbstractListIteratorDecorator<E> {\n+\n+        /**\n+         * Create a new transformed list iterator.\n+         * \n+         * @param iterator  the list iterator to decorate\n+         */\n+        protected TransformedListIterator(final ListIterator<E> iterator) {\n+            super(iterator);\n+        }\n+\n+        @Override\n+        public void add(E object) {\n+            object = transform(object);\n+            iterator.add(object);\n+        }\n+\n+        @Override\n+        public void set(E object) {\n+            object = transform(object);\n+            iterator.set(object);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/TreeList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.OrderedIterator;\n+\n+/**\n+ * A <code>List</code> implementation that is optimised for fast insertions and\n+ * removals at any index in the list.\n+ * <p>\n+ * This list implementation utilises a tree structure internally to ensure that\n+ * all insertions and removals are O(log n). This provides much faster performance\n+ * than both an <code>ArrayList</code> and a <code>LinkedList</code> where elements\n+ * are inserted and removed repeatedly from anywhere in the list.\n+ * <p>\n+ * The following relative performance statistics are indicative of this class:\n+ * <pre>\n+ *              get  add  insert  iterate  remove\n+ * TreeList       3    5       1       2       1\n+ * ArrayList      1    1      40       1      40\n+ * LinkedList  5800    1     350       2     325\n+ * </pre>\n+ * <code>ArrayList</code> is a good general purpose list implementation.\n+ * It is faster than <code>TreeList</code> for most operations except inserting\n+ * and removing in the middle of the list. <code>ArrayList</code> also uses less\n+ * memory as <code>TreeList</code> uses one object per entry.\n+ * <p>\n+ * <code>LinkedList</code> is rarely a good choice of implementation.\n+ * <code>TreeList</code> is almost always a good replacement for it, although it\n+ * does use slightly more memory.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class TreeList<E> extends AbstractList<E> {\n+//    add; toArray; iterator; insert; get; indexOf; remove\n+//    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n+//   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n+//  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n+\n+    /** The root node in the AVL tree */\n+    private AVLNode<E> root;\n+\n+    /** The current size of the list */\n+    private int size;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty list.\n+     */\n+    public TreeList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty list that copies the specified list.\n+     *\n+     * @param coll  the collection to copy\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public TreeList(final Collection<E> coll) {\n+        super();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the element at the specified index.\n+     *\n+     * @param index  the index to retrieve\n+     * @return the element at the specified index\n+     */\n+    @Override\n+    public E get(final int index) {\n+        checkInterval(index, 0, size() - 1);\n+        return root.get(index).getValue();\n+    }\n+\n+    /**\n+     * Gets the current size of the list.\n+     *\n+     * @return the current size\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Gets an iterator over the list.\n+     *\n+     * @return an iterator over the list\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        // override to go 75% faster\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Gets a ListIterator over the list.\n+     *\n+     * @return the new iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        // override to go 75% faster\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Gets a ListIterator over the list.\n+     *\n+     * @param fromIndex  the index to start from\n+     * @return the new iterator\n+     */\n+    @Override\n+    public ListIterator<E> listIterator(final int fromIndex) {\n+        // override to go 75% faster\n+        // cannot use EmptyIterator as iterator.add() must work\n+        checkInterval(fromIndex, 0, size());\n+        return new TreeListIterator<E>(this, fromIndex);\n+    }\n+\n+    /**\n+     * Searches for the index of an object in the list.\n+     *\n+     * @param object  the object to search\n+     * @return the index of the object, -1 if not found\n+     */\n+    @Override\n+    public int indexOf(final Object object) {\n+        // override to go 75% faster\n+        if (root == null) {\n+            return -1;\n+        }\n+        return root.indexOf(object, root.relativePosition);\n+    }\n+\n+    /**\n+     * Searches for the presence of an object in the list.\n+     *\n+     * @param object  the object to check\n+     * @return true if the object is found\n+     */\n+    @Override\n+    public boolean contains(final Object object) {\n+        return indexOf(object) >= 0;\n+    }\n+\n+    /**\n+     * Converts the list into an array.\n+     *\n+     * @return the list as an array\n+     */\n+    @Override\n+    public Object[] toArray() {\n+        // override to go 20% faster\n+        final Object[] array = new Object[size()];\n+        if (root != null) {\n+            root.toArray(array, root.relativePosition);\n+        }\n+        return array;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new element to the list.\n+     *\n+     * @param index  the index to add before\n+     * @param obj  the element to add\n+     */\n+    @Override\n+    public void add(final int index, final E obj) {\n+        modCount++;\n+        checkInterval(index, 0, size());\n+        if (root == null) {\n+            root = new AVLNode<E>(index, obj, null, null);\n+        } else {\n+            root = root.insert(index, obj);\n+        }\n+        size++;\n+    }\n+\n+    /**\n+     * Sets the element at the specified index.\n+     *\n+     * @param index  the index to set\n+     * @param obj  the object to store at the specified index\n+     * @return the previous object at that index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    @Override\n+    public E set(final int index, final E obj) {\n+        checkInterval(index, 0, size() - 1);\n+        final AVLNode<E> node = root.get(index);\n+        final E result = node.value;\n+        node.setValue(obj);\n+        return result;\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index to remove\n+     * @return the previous object at that index\n+     */\n+    @Override\n+    public E remove(final int index) {\n+        modCount++;\n+        checkInterval(index, 0, size() - 1);\n+        final E result = get(index);\n+        root = root.remove(index);\n+        size--;\n+        return result;\n+    }\n+\n+    /**\n+     * Clears the list, removing all entries.\n+     */\n+    @Override\n+    public void clear() {\n+        modCount++;\n+        root = null;\n+        size = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the index is valid.\n+     *\n+     * @param index  the index to check\n+     * @param startIndex  the first allowed index\n+     * @param endIndex  the last allowed index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    private void checkInterval(final int index, final int startIndex, final int endIndex) {\n+        if (index < startIndex || index > endIndex) {\n+            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements an AVLNode which keeps the offset updated.\n+     * <p>\n+     * This node contains the real work.\n+     * TreeList is just there to implement {@link java.util.List}.\n+     * The nodes don't know the index of the object they are holding.  They\n+     * do know however their position relative to their parent node.\n+     * This allows to calculate the index of a node while traversing the tree.\n+     * <p>\n+     * The Faedelung calculation stores a flag for both the left and right child\n+     * to indicate if they are a child (false) or a link as in linked list (true).\n+     */\n+    static class AVLNode<E> {\n+        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n+        private AVLNode<E> left;\n+        /** Flag indicating that left reference is not a subtree but the predecessor. */\n+        private boolean leftIsPrevious;\n+        /** The right child node or the successor if {@link #rightIsNext}. */\n+        private AVLNode<E> right;\n+        /** Flag indicating that right reference is not a subtree but the successor. */\n+        private boolean rightIsNext;\n+        /** How many levels of left/right are below this one. */\n+        private int height;\n+        /** The relative position, root holds absolute position. */\n+        private int relativePosition;\n+        /** The stored element. */\n+        private E value;\n+\n+        /**\n+         * Constructs a new node with a relative position.\n+         *\n+         * @param relativePosition  the relative position of the node\n+         * @param obj  the value for the ndoe\n+         * @param rightFollower the node with the value following this one\n+         * @param leftFollower the node with the value leading this one\n+         */\n+        private AVLNode(final int relativePosition, final E obj,\n+                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n+            this.relativePosition = relativePosition;\n+            value = obj;\n+            rightIsNext = true;\n+            leftIsPrevious = true;\n+            right = rightFollower;\n+            left = leftFollower;\n+        }\n+\n+        /**\n+         * Gets the value.\n+         *\n+         * @return the value of this node\n+         */\n+        E getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the value.\n+         *\n+         * @param obj  the value to store\n+         */\n+        void setValue(final E obj) {\n+            this.value = obj;\n+        }\n+\n+        /**\n+         * Locate the element with the given index relative to the\n+         * offset of the parent of this node.\n+         */\n+        AVLNode<E> get(final int index) {\n+            final int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return this;\n+            }\n+\n+            final AVLNode<E> nextNode = indexRelativeToMe < 0 ? getLeftSubTree() : getRightSubTree();\n+            if (nextNode == null) {\n+                return null;\n+            }\n+            return nextNode.get(indexRelativeToMe);\n+        }\n+\n+        /**\n+         * Locate the index that contains the specified object.\n+         */\n+        int indexOf(final Object object, final int index) {\n+            if (getLeftSubTree() != null) {\n+                final int result = left.indexOf(object, index + left.relativePosition);\n+                if (result != -1) {\n+                    return result;\n+                }\n+            }\n+            if (value == null ? value == object : value.equals(object)) {\n+                return index;\n+            }\n+            if (getRightSubTree() != null) {\n+                return right.indexOf(object, index + right.relativePosition);\n+            }\n+            return -1;\n+        }\n+\n+        /**\n+         * Stores the node and its children into the array specified.\n+         *\n+         * @param array the array to be filled\n+         * @param index the index of this node\n+         */\n+        void toArray(final Object[] array, final int index) {\n+            array[index] = value;\n+            if (getLeftSubTree() != null) {\n+                left.toArray(array, index + left.relativePosition);\n+            }\n+            if (getRightSubTree() != null) {\n+                right.toArray(array, index + right.relativePosition);\n+            }\n+        }\n+\n+        /**\n+         * Gets the next node in the list after this one.\n+         *\n+         * @return the next node\n+         */\n+        AVLNode<E> next() {\n+            if (rightIsNext || right == null) {\n+                return right;\n+            }\n+            return right.min();\n+        }\n+\n+        /**\n+         * Gets the node in the list before this one.\n+         *\n+         * @return the previous node\n+         */\n+        AVLNode<E> previous() {\n+            if (leftIsPrevious || left == null) {\n+                return left;\n+            }\n+            return left.max();\n+        }\n+\n+        /**\n+         * Inserts a node at the position index.\n+         *\n+         * @param index is the index of the position relative to the position of\n+         * the parent node.\n+         * @param obj is the object to be stored in the position.\n+         */\n+        AVLNode<E> insert(final int index, final E obj) {\n+            final int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe <= 0) {\n+                return insertOnLeft(indexRelativeToMe, obj);\n+            }\n+            return insertOnRight(indexRelativeToMe, obj);\n+        }\n+\n+        private AVLNode<E> insertOnLeft(final int indexRelativeToMe, final E obj) {\n+            if (getLeftSubTree() == null) {\n+                setLeft(new AVLNode<E>(-1, obj, this, left), null);\n+            } else {\n+                setLeft(left.insert(indexRelativeToMe, obj), null);\n+            }\n+\n+            if (relativePosition >= 0) {\n+                relativePosition++;\n+            }\n+            final AVLNode<E> ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        private AVLNode<E> insertOnRight(final int indexRelativeToMe, final E obj) {\n+            if (getRightSubTree() == null) {\n+                setRight(new AVLNode<E>(+1, obj, right, this), null);\n+            } else {\n+                setRight(right.insert(indexRelativeToMe, obj), null);\n+            }\n+            if (relativePosition < 0) {\n+                relativePosition--;\n+            }\n+            final AVLNode<E> ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the left node, returning null if its a faedelung.\n+         */\n+        private AVLNode<E> getLeftSubTree() {\n+            return leftIsPrevious ? null : left;\n+        }\n+\n+        /**\n+         * Gets the right node, returning null if its a faedelung.\n+         */\n+        private AVLNode<E> getRightSubTree() {\n+            return rightIsNext ? null : right;\n+        }\n+\n+        /**\n+         * Gets the rightmost child of this node.\n+         *\n+         * @return the rightmost child (greatest index)\n+         */\n+        private AVLNode<E> max() {\n+            return getRightSubTree() == null ? this : right.max();\n+        }\n+\n+        /**\n+         * Gets the leftmost child of this node.\n+         *\n+         * @return the leftmost child (smallest index)\n+         */\n+        private AVLNode<E> min() {\n+            return getLeftSubTree() == null ? this : left.min();\n+        }\n+\n+        /**\n+         * Removes the node at a given position.\n+         *\n+         * @param index is the index of the element to be removed relative to the position of\n+         * the parent node of the current node.\n+         */\n+        AVLNode<E> remove(final int index) {\n+            final int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return removeSelf();\n+            }\n+            if (indexRelativeToMe > 0) {\n+                setRight(right.remove(indexRelativeToMe), right.right);\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                setLeft(left.remove(indexRelativeToMe), left.left);\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode<E> removeMax() {\n+            if (getRightSubTree() == null) {\n+                return removeSelf();\n+            }\n+            setRight(right.removeMax(), right.right);\n+            if (relativePosition < 0) {\n+                relativePosition++;\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode<E> removeMin() {\n+            if (getLeftSubTree() == null) {\n+                return removeSelf();\n+            }\n+            setLeft(left.removeMin(), left.left);\n+            if (relativePosition > 0) {\n+                relativePosition--;\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        /**\n+         * Removes this node from the tree.\n+         *\n+         * @return the node that replaces this one in the parent\n+         */\n+        private AVLNode<E> removeSelf() {\n+            if (getRightSubTree() == null && getLeftSubTree() == null) {\n+                return null;\n+            }\n+            if (getRightSubTree() == null) {\n+                if (relativePosition > 0) {\n+                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n+                }\n+                left.max().setRight(null, right);\n+                return left;\n+            }\n+            if (getLeftSubTree() == null) {\n+                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n+                right.min().setLeft(null, left);\n+                return right;\n+            }\n+\n+            if (heightRightMinusLeft() > 0) {\n+                // more on the right, so delete from the right\n+                final AVLNode<E> rightMin = right.min();\n+                value = rightMin.value;\n+                if (leftIsPrevious) {\n+                    left = rightMin.left;\n+                }\n+                right = right.removeMin();\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                // more on the left or equal, so delete from the left\n+                final AVLNode<E> leftMax = left.max();\n+                value = leftMax.value;\n+                if (rightIsNext) {\n+                    right = leftMax.right;\n+                }\n+                final AVLNode<E> leftPrevious = left.left;\n+                left = left.removeMax();\n+                if (left == null) {\n+                    // special case where left that was deleted was a double link\n+                    // only occurs when height difference is equal\n+                    left = leftPrevious;\n+                    leftIsPrevious = true;\n+                }\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return this;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Balances according to the AVL algorithm.\n+         */\n+        private AVLNode<E> balance() {\n+            switch (heightRightMinusLeft()) {\n+                case 1 :\n+                case 0 :\n+                case -1 :\n+                    return this;\n+                case -2 :\n+                    if (left.heightRightMinusLeft() > 0) {\n+                        setLeft(left.rotateLeft(), null);\n+                    }\n+                    return rotateRight();\n+                case 2 :\n+                    if (right.heightRightMinusLeft() < 0) {\n+                        setRight(right.rotateRight(), null);\n+                    }\n+                    return rotateLeft();\n+                default :\n+                    throw new RuntimeException(\"tree inconsistent!\");\n+            }\n+        }\n+\n+        /**\n+         * Gets the relative position.\n+         */\n+        private int getOffset(final AVLNode<E> node) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            return node.relativePosition;\n+        }\n+\n+        /**\n+         * Sets the relative position.\n+         */\n+        private int setOffset(final AVLNode<E> node, final int newOffest) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            final int oldOffset = getOffset(node);\n+            node.relativePosition = newOffest;\n+            return oldOffset;\n+        }\n+\n+        /**\n+         * Sets the height by calculation.\n+         */\n+        private void recalcHeight() {\n+            height = Math.max(\n+                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n+                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n+        }\n+\n+        /**\n+         * Returns the height of the node or -1 if the node is null.\n+         */\n+        private int getHeight(final AVLNode<E> node) {\n+            return node == null ? -1 : node.height;\n+        }\n+\n+        /**\n+         * Returns the height difference right - left\n+         */\n+        private int heightRightMinusLeft() {\n+            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n+        }\n+\n+        private AVLNode<E> rotateLeft() {\n+            final AVLNode<E> newTop = right; // can't be faedelung!\n+            final AVLNode<E> movedNode = getRightSubTree().getLeftSubTree();\n+\n+            final int newTopPosition = relativePosition + getOffset(newTop);\n+            final int myNewPosition = -newTop.relativePosition;\n+            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+\n+            setRight(movedNode, newTop);\n+            newTop.setLeft(this, null);\n+\n+            setOffset(newTop, newTopPosition);\n+            setOffset(this, myNewPosition);\n+            setOffset(movedNode, movedPosition);\n+            return newTop;\n+        }\n+\n+        private AVLNode<E> rotateRight() {\n+            final AVLNode<E> newTop = left; // can't be faedelung\n+            final AVLNode<E> movedNode = getLeftSubTree().getRightSubTree();\n+\n+            final int newTopPosition = relativePosition + getOffset(newTop);\n+            final int myNewPosition = -newTop.relativePosition;\n+            final int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+\n+            setLeft(movedNode, newTop);\n+            newTop.setRight(this, null);\n+\n+            setOffset(newTop, newTopPosition);\n+            setOffset(this, myNewPosition);\n+            setOffset(movedNode, movedPosition);\n+            return newTop;\n+        }\n+\n+        /**\n+         * Sets the left field to the node, or the previous node if that is null\n+         *\n+         * @param node  the new left subtree node\n+         * @param previous  the previous node in the linked list\n+         */\n+        private void setLeft(final AVLNode<E> node, final AVLNode<E> previous) {\n+            leftIsPrevious = node == null;\n+            left = leftIsPrevious ? previous : node;\n+            recalcHeight();\n+        }\n+\n+        /**\n+         * Sets the right field to the node, or the next node if that is null\n+         *\n+         * @param node  the new left subtree node\n+         * @param next  the next node in the linked list\n+         */\n+        private void setRight(final AVLNode<E> node, final AVLNode<E> next) {\n+            rightIsNext = node == null;\n+            right = rightIsNext ? next : node;\n+            recalcHeight();\n+        }\n+\n+//      private void checkFaedelung() {\n+//          AVLNode maxNode = left.max();\n+//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n+//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n+//          }\n+//          AVLNode minNode = right.min();\n+//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n+//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n+//          }\n+//      }\n+//\n+//        private int checkTreeDepth() {\n+//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n+//            //          System.out.print(\"checkTreeDepth\");\n+//            //          System.out.print(this);\n+//            //          System.out.print(\" left: \");\n+//            //          System.out.print(_left);\n+//            //          System.out.print(\" right: \");\n+//            //          System.out.println(_right);\n+//\n+//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n+//            if (height != Math.max(hright, hleft) + 1) {\n+//                throw new RuntimeException(\n+//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n+//            }\n+//            return height;\n+//        }\n+//\n+//        private int checkLeftSubNode() {\n+//            if (getLeftSubTree() == null) {\n+//                return 0;\n+//            }\n+//            int count = 1 + left.checkRightSubNode();\n+//            if (left.relativePosition != -count) {\n+//                throw new RuntimeException();\n+//            }\n+//            return count + left.checkLeftSubNode();\n+//        }\n+//\n+//        private int checkRightSubNode() {\n+//            AVLNode right = getRightSubTree();\n+//            if (right == null) {\n+//                return 0;\n+//            }\n+//            int count = 1;\n+//            count += right.checkLeftSubNode();\n+//            if (right.relativePosition != count) {\n+//                throw new RuntimeException();\n+//            }\n+//            return count + right.checkRightSubNode();\n+//        }\n+\n+        /**\n+         * Used for debugging.\n+         */\n+        @Override\n+        public String toString() {\n+            return new StringBuilder()\n+                .append(\"AVLNode(\")\n+                .append(relativePosition)\n+                .append(',')\n+                .append(left != null)\n+                .append(',')\n+                .append(value)\n+                .append(',')\n+                .append(getRightSubTree() != null)\n+                .append(\", faedelung \")\n+                .append(rightIsNext)\n+                .append(\" )\")\n+                .toString();\n+        }\n+    }\n+\n+    /**\n+     * A list iterator over the linked list.\n+     */\n+    static class TreeListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n+        /** The parent list */\n+        protected final TreeList<E> parent;\n+        /**\n+         * Cache of the next node that will be returned by {@link #next()}.\n+         */\n+        protected AVLNode<E> next;\n+        /**\n+         * The index of the next node to be returned.\n+         */\n+        protected int nextIndex;\n+        /**\n+         * Cache of the last node that was returned by {@link #next()}\n+         * or {@link #previous()}.\n+         */\n+        protected AVLNode<E> current;\n+        /**\n+         * The index of the last node that was returned.\n+         */\n+        protected int currentIndex;\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         *\n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n+         */\n+        protected TreeListIterator(final TreeList<E> parent, final int fromIndex) throws IndexOutOfBoundsException {\n+            super();\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = parent.root == null ? null : parent.root.get(fromIndex);\n+            this.nextIndex = fromIndex;\n+            this.currentIndex = -1;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         *\n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return nextIndex < parent.size();\n+        }\n+\n+        public E next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n+            }\n+            if (next == null) {\n+                next = parent.root.get(nextIndex);\n+            }\n+            final E value = next.getValue();\n+            current = next;\n+            currentIndex = nextIndex++;\n+            next = next.next();\n+            return value;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return nextIndex > 0;\n+        }\n+\n+        public E previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            if (next == null) {\n+                next = parent.root.get(nextIndex - 1);\n+            } else {\n+                next = next.previous();\n+            }\n+            final E value = next.getValue();\n+            current = next;\n+            currentIndex = --nextIndex;\n+            return value;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex() - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            if (currentIndex == -1) {\n+                throw new IllegalStateException();\n+            }\n+            parent.remove(currentIndex);\n+            if (nextIndex != currentIndex) {\n+                // remove() following next()\n+                nextIndex--;\n+            }\n+            // the AVL node referenced by next may have become stale after a remove\n+            // reset it now: will be retrieved by next call to next()/previous() via nextIndex\n+            next = null;\n+            current = null;\n+            currentIndex = -1;\n+            expectedModCount++;\n+        }\n+\n+        public void set(final E obj) {\n+            checkModCount();\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            current.setValue(obj);\n+        }\n+\n+        public void add(final E obj) {\n+            checkModCount();\n+            parent.add(nextIndex, obj);\n+            current = null;\n+            currentIndex = -1;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections4.iterators.UnmodifiableListIterator;\n+\n+/**\n+ * Decorates another <code>List</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableList<E>\n+        extends AbstractSerializableListDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6595182819922443652L;\n+\n+    /**\n+     * Factory method to create an unmodifiable list.\n+     * \n+     * @param <E> the type of the elements in the list\n+     * @param list  the list to decorate, must not be null\n+     * @return a new unmodifiable list\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> List<E> unmodifiableList(final List<E> list) {\n+        if (list instanceof Unmodifiable) {\n+            return list;\n+        }\n+        return new UnmodifiableList<E>(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param list  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     * @since Commons Collection 5\n+     */\n+    public UnmodifiableList(final List<E> list) {\n+        super(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator());\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(final int index) {\n+        return UnmodifiableListIterator.umodifiableListIterator(decorated().listIterator(index));\n+    }\n+\n+    @Override\n+    public void add(final int index, final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public E remove(final int index) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public E set(final int index, final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public List<E> subList(final int fromIndex, final int toIndex) {\n+        final List<E> sub = decorated().subList(fromIndex, toIndex);\n+        return new UnmodifiableList<E>(sub);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/list/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the {@link java.util.List List} interface.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>TreeList - a list that is optimised for insertions and removals at any index in the list</li>\n+ *   <li>CursorableLinkedList - a list that can be modified while the listIterator (cursor) is being used</li>\n+ *   <li>NodeCachingLinkedList - a linked list that caches the storage nodes for a performance gain</li>\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Unmodifiable - ensures the collection cannot be altered</li>\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added</li>\n+ *   <li>Transformed - transforms each element added</li>\n+ *   <li>FixedSize - ensures that the size of the list cannot change</li>\n+ *   <li>Lazy - creates objects in the list on demand</li>\n+ *   <li>Growth - grows the list instead of erroring when set/add used with index beyond the list size</li>\n+ *   <li>SetUnique - a list that avoids duplicate entries like a Set</li>\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.list;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractHashedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.EmptyMapIterator;\n+\n+/**\n+ * An abstract implementation of a hash-based map which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * This class implements all the features necessary for a subclass hash-based map.\n+ * Key-value entries are stored in instances of the <code>HashEntry</code> class,\n+ * which can be overridden and replaced. The iterators can similarly be replaced,\n+ * without the need to replace the KeySet, EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * NOTE: From Commons Collections 3.1 this class extends AbstractMap.\n+ * This is to provide backwards compatibility for ReferenceMap between v3.0 and v3.1.\n+ * This extends clause will be removed in v4.0.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class AbstractHashedMap<K, V> extends AbstractMap<K, V> implements IterableMap<K, V> {\n+\n+    protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n+    protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n+    protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n+    protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n+    protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n+    protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n+\n+    /** The default capacity to use */\n+    protected static final int DEFAULT_CAPACITY = 16;\n+    /** The default threshold to use */\n+    protected static final int DEFAULT_THRESHOLD = 12;\n+    /** The default load factor to use */\n+    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+    /** The maximum capacity allowed */\n+    protected static final int MAXIMUM_CAPACITY = 1 << 30;\n+    /** An object for masking null */\n+    protected static final Object NULL = new Object();\n+\n+    /** Load factor, normally 0.75 */\n+    protected transient float loadFactor;\n+    /** The size of the map */\n+    protected transient int size;\n+    /** Map entries */\n+    protected transient HashEntry<K, V>[] data;\n+    /** Size at which to rehash */\n+    protected transient int threshold;\n+    /** Modification count for iterators */\n+    protected transient int modCount;\n+    /** Entry set */\n+    protected transient EntrySet<K, V> entrySet;\n+    /** Key set */\n+    protected transient KeySet<K> keySet;\n+    /** Values */\n+    protected transient Values<V> values;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractHashedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which performs no validation on the passed in parameters.\n+     *\n+     * @param initialCapacity  the initial capacity, must be a power of two\n+     * @param loadFactor  the load factor, must be &gt; 0.0f and generally &lt; 1.0f\n+     * @param threshold  the threshold, must be sensible\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap(final int initialCapacity, final float loadFactor, final int threshold) {\n+        super();\n+        this.loadFactor = loadFactor;\n+        this.data = new HashEntry[initialCapacity];\n+        this.threshold = threshold;\n+        init();\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * default load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    protected AbstractHashedMap(final int initialCapacity) {\n+        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than or equal to zero \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap(int initialCapacity, final float loadFactor) {\n+        super();\n+        if (initialCapacity < 0) {\n+            throw new IllegalArgumentException(\"Initial capacity must be a non negative number\");  \n+        }\n+        if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n+            throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n+        }\n+        this.loadFactor = loadFactor;\n+        initialCapacity = calculateNewCapacity(initialCapacity);\n+        this.threshold = calculateThreshold(initialCapacity, loadFactor);\n+        this.data = new HashEntry[initialCapacity];\n+        init();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    protected AbstractHashedMap(final Map<K, V> map) {\n+        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n+        _putAll(map);\n+    }\n+\n+    /**\n+     * Initialise subclasses during construction, cloning or deserialization.\n+     */\n+    protected void init() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    @Override\n+    public V get(Object key) {\n+        key = convertKey(key);\n+        final int hashCode = hash(key);\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map.\n+     *\n+     * @return the size\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     *\n+     * @return true if the map is currently size zero\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return size == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     *\n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    @Override\n+    public boolean containsKey(Object key) {\n+        key = convertKey(key);\n+        final int hashCode = hash(key);\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    public boolean containsValue(final Object value) {\n+        if (value == null) {\n+            for (final HashEntry<K, V> element : data) {\n+                HashEntry<K, V> entry = element;\n+                while (entry != null) {\n+                    if (entry.getValue() == null) {\n+                        return true;\n+                    }\n+                    entry = entry.next;\n+                }\n+            }\n+        } else {\n+            for (final HashEntry<K, V> element : data) {\n+                HashEntry<K, V> entry = element;\n+                while (entry != null) {\n+                    if (isEqualValue(value, entry.getValue())) {\n+                        return true;\n+                    }\n+                    entry = entry.next;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map.\n+     *\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    @Override\n+    public V put(final K key, final V value) {\n+        final Object convertedKey = convertKey(key);\n+        final int hashCode = hash(convertedKey);\n+        final int index = hashIndex(hashCode, data.length);\n+        HashEntry<K, V> entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(convertedKey, entry.key)) {\n+                final V oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+\n+        addMapping(index, hashCode, key, value);\n+        return null;\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     * <p>\n+     * This implementation iterates around the specified map and\n+     * uses {@link #put(Object, Object)}.\n+     *\n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        _putAll(map);\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     * <p>\n+     * This implementation iterates around the specified map and\n+     * uses {@link #put(Object, Object)}.\n+     * <p>\n+     * It is private to allow the constructor to still call it \n+     * even when putAll is overriden. \n+     * \n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    private void _putAll(final Map<? extends K, ? extends V> map) {\n+        final int mapSize = map.size();\n+        if (mapSize == 0) {\n+            return;\n+        }\n+        final int newSize = (int) ((size + mapSize) / loadFactor + 1);\n+        ensureCapacity(calculateNewCapacity(newSize));\n+        for (final Map.Entry<? extends K, ? extends V> entry: map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     *\n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    @Override\n+    public V remove(Object key) {\n+        key = convertKey(key);\n+        final int hashCode = hash(key);\n+        final int index = hashIndex(hashCode, data.length);\n+        HashEntry<K, V> entry = data[index];\n+        HashEntry<K, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                final V oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    @Override\n+    public void clear() {\n+        modCount++;\n+        final HashEntry<K, V>[] data = this.data;\n+        for (int i = data.length - 1; i >= 0; i--) {\n+            data[i] = null;\n+        }\n+        size = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts input keys to another object for storage in the map.\n+     * This implementation masks nulls.\n+     * Subclasses can override this to perform alternate key conversions.\n+     * <p>\n+     * The reverse conversion can be changed, if required, by overriding the\n+     * getKey() method in the hash entry.\n+     *\n+     * @param key  the key convert\n+     * @return the converted key\n+     */\n+    protected Object convertKey(final Object key) {\n+        return key == null ? NULL : key;\n+    }\n+\n+    /**\n+     * Gets the hash code for the key specified.\n+     * This implementation uses the additional hashing routine from JDK1.4.\n+     * Subclasses can override this to return alternate hash codes.\n+     *\n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    protected int hash(final Object key) {\n+        // same as JDK 1.4\n+        int h = key.hashCode();\n+        h += ~(h << 9);\n+        h ^=  h >>> 14;\n+        h +=  h << 4;\n+        h ^=  h >>> 10;\n+        return h;\n+    }\n+\n+    /**\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * This implementation uses the equals method and assumes neither key is null.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal\n+     */\n+    protected boolean isEqualKey(final Object key1, final Object key2) {\n+        return key1 == key2 || key1.equals(key2);\n+    }\n+\n+    /**\n+     * Compares two values, in external form, to see if they are equal.\n+     * This implementation uses the equals method and assumes neither value is null.\n+     * Subclasses can override this to match differently.\n+     *\n+     * @param value1  the first value to compare passed in from outside\n+     * @param value2  the second value extracted from the entry via <code>getValue()</code>\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n+        return value1 == value2 || value1.equals(value2);\n+    }\n+\n+    /**\n+     * Gets the index into the data storage for the hashCode specified.\n+     * This implementation uses the least significant bits of the hashCode.\n+     * Subclasses can override this to return alternate bucketing.\n+     *\n+     * @param hashCode  the hash code to use\n+     * @param dataSize  the size of the data to pick a bucket from\n+     * @return the bucket index\n+     */\n+    protected int hashIndex(final int hashCode, final int dataSize) {\n+        return hashCode & dataSize - 1;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     * <p>\n+     * This method exists for subclasses that may need to perform a multi-step\n+     * process accessing the entry. The public methods in this class don't use this\n+     * method to gain a small performance boost.\n+     *\n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    protected HashEntry<K, V> getEntry(Object key) {\n+        key = convertKey(key);\n+        final int hashCode = hash(key);\n+        HashEntry<K, V> entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry;\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates an existing key-value mapping to change the value.\n+     * <p>\n+     * This implementation calls <code>setValue()</code> on the entry.\n+     * Subclasses could override to handle changes to the map.\n+     *\n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     */\n+    protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {\n+        entry.setValue(newValue);\n+    }\n+\n+    /**\n+     * Reuses an existing key-value mapping, storing completely new data.\n+     * <p>\n+     * This implementation sets all the data fields on the entry.\n+     * Subclasses could populate additional entry fields.\n+     *\n+     * @param entry  the entry to update, not null\n+     * @param hashIndex  the index in the data array\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void reuseEntry(final HashEntry<K, V> entry, final int hashIndex, final int hashCode,\n+                              final K key, final V value) {\n+        entry.next = data[hashIndex];\n+        entry.hashCode = hashCode;\n+        entry.key = key;\n+        entry.value = value;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * <p>\n+     * This implementation calls <code>createEntry()</code>, <code>addEntry()</code>\n+     * and <code>checkCapacity()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control adds to the map.\n+     *\n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void addMapping(final int hashIndex, final int hashCode, final K key, final V value) {\n+        modCount++;\n+        final HashEntry<K, V> entry = createEntry(data[hashIndex], hashCode, key, value);\n+        addEntry(entry, hashIndex);\n+        size++;\n+        checkCapacity();\n+    }\n+\n+    /**\n+     * Creates an entry to store the key-value data.\n+     * <p>\n+     * This implementation creates a new HashEntry instance.\n+     * Subclasses can override this to return a different storage class,\n+     * or implement caching.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    protected HashEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+        return new HashEntry<K, V>(next, hashCode, convertKey(key), value);\n+    }\n+\n+    /**\n+     * Adds an entry into this map.\n+     * <p>\n+     * This implementation adds the entry to the data storage table.\n+     * Subclasses could override to handle changes to the map.\n+     *\n+     * @param entry  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {\n+        data[hashIndex] = entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes a mapping from the map.\n+     * <p>\n+     * This implementation calls <code>removeEntry()</code> and <code>destroyEntry()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control removals from the map.\n+     *\n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeMapping(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n+        modCount++;\n+        removeEntry(entry, hashIndex, previous);\n+        size--;\n+        destroyEntry(entry);\n+    }\n+\n+    /**\n+     * Removes an entry from the chain stored in a particular index.\n+     * <p>\n+     * This implementation removes the entry from the data storage table.\n+     * The size is not updated.\n+     * Subclasses could override to handle changes to the map.\n+     *\n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n+        if (previous == null) {\n+            data[hashIndex] = entry.next;\n+        } else {\n+            previous.next = entry.next;\n+        }\n+    }\n+\n+    /**\n+     * Kills an entry ready for the garbage collector.\n+     * <p>\n+     * This implementation prepares the HashEntry for garbage collection.\n+     * Subclasses can override this to implement caching (override clear as well).\n+     *\n+     * @param entry  the entry to destroy\n+     */\n+    protected void destroyEntry(final HashEntry<K, V> entry) {\n+        entry.next = null;\n+        entry.key = null;\n+        entry.value = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the capacity of the map and enlarges it if necessary.\n+     * <p>\n+     * This implementation uses the threshold to check if the map needs enlarging\n+     */\n+    protected void checkCapacity() {\n+        if (size >= threshold) {\n+            final int newCapacity = data.length * 2;\n+            if (newCapacity <= MAXIMUM_CAPACITY) {\n+                ensureCapacity(newCapacity);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Changes the size of the data structure to the capacity proposed.\n+     *\n+     * @param newCapacity  the new capacity of the array (a power of two, less or equal to max)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void ensureCapacity(final int newCapacity) {\n+        final int oldCapacity = data.length;\n+        if (newCapacity <= oldCapacity) {\n+            return;\n+        }\n+        if (size == 0) {\n+            threshold = calculateThreshold(newCapacity, loadFactor);\n+            data = new HashEntry[newCapacity];\n+        } else {\n+            final HashEntry<K, V> oldEntries[] = data;\n+            final HashEntry<K, V> newEntries[] = new HashEntry[newCapacity];\n+\n+            modCount++;\n+            for (int i = oldCapacity - 1; i >= 0; i--) {\n+                HashEntry<K, V> entry = oldEntries[i];\n+                if (entry != null) {\n+                    oldEntries[i] = null;  // gc\n+                    do {\n+                        final HashEntry<K, V> next = entry.next;\n+                        final int index = hashIndex(entry.hashCode, newCapacity);\n+                        entry.next = newEntries[index];\n+                        newEntries[index] = entry;\n+                        entry = next;\n+                    } while (entry != null);\n+                }\n+            }\n+            threshold = calculateThreshold(newCapacity, loadFactor);\n+            data = newEntries;\n+        }\n+    }\n+\n+    /**\n+     * Calculates the new capacity of the map.\n+     * This implementation normalizes the capacity to a power of two.\n+     *\n+     * @param proposedCapacity  the proposed capacity\n+     * @return the normalized new capacity\n+     */\n+    protected int calculateNewCapacity(final int proposedCapacity) {\n+        int newCapacity = 1;\n+        if (proposedCapacity > MAXIMUM_CAPACITY) {\n+            newCapacity = MAXIMUM_CAPACITY;\n+        } else {\n+            while (newCapacity < proposedCapacity) {\n+                newCapacity <<= 1;  // multiply by two\n+            }\n+            if (newCapacity > MAXIMUM_CAPACITY) {\n+                newCapacity = MAXIMUM_CAPACITY;\n+            }\n+        }\n+        return newCapacity;\n+    }\n+\n+    /**\n+     * Calculates the new threshold of the map, where it will be resized.\n+     * This implementation uses the load factor.\n+     *\n+     * @param newCapacity  the new capacity\n+     * @param factor  the load factor\n+     * @return the new resize threshold\n+     */\n+    protected int calculateThreshold(final int newCapacity, final float factor) {\n+        return (int) (newCapacity * factor);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the <code>next</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>next</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since 3.1\n+     */\n+    protected HashEntry<K, V> entryNext(final HashEntry<K, V> entry) {\n+        return entry.next;\n+    }\n+\n+    /**\n+     * Gets the <code>hashCode</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>hashCode</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since 3.1\n+     */\n+    protected int entryHashCode(final HashEntry<K, V> entry) {\n+        return entry.hashCode;\n+    }\n+\n+    /**\n+     * Gets the <code>key</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>key</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since 3.1\n+     */\n+    protected K entryKey(final HashEntry<K, V> entry) {\n+        return entry.getKey();\n+    }\n+\n+    /**\n+     * Gets the <code>value</code> field from a <code>HashEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     *\n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>value</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since 3.1\n+     */\n+    protected V entryValue(final HashEntry<K, V> entry) {\n+        return entry.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Map.Entry object.\n+     *\n+     * @return the map iterator\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        if (size == 0) {\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n+        }\n+        return new HashMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * MapIterator implementation.\n+     */\n+    protected static class HashMapIterator<K, V> extends HashIterator<K, V> implements MapIterator<K, V> {\n+\n+        protected HashMapIterator(final AbstractHashedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            final HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            final HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            final HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     *\n+     * @return the entrySet view\n+     */\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet<K, V>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @return the entrySet iterator\n+     */\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        if (size() == 0) {\n+            return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n+        }\n+        return new EntrySetIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * EntrySet implementation.\n+     */\n+    protected static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        /** The parent map */\n+        protected final AbstractHashedMap<K, V> parent;\n+\n+        protected EntrySet(final AbstractHashedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object entry) {\n+            if (entry instanceof Map.Entry) {\n+                final Map.Entry<?, ?> e = (Map.Entry<?, ?>) entry;\n+                final Entry<K, V> match = parent.getEntry(e.getKey());\n+                return match != null && match.equals(e);\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            if (contains(obj) == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            parent.remove(entry.getKey());\n+            return true;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return parent.createEntrySetIterator();\n+        }\n+    }\n+\n+    /**\n+     * EntrySet iterator.\n+     */\n+    protected static class EntrySetIterator<K, V> extends HashIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        protected EntrySetIterator(final AbstractHashedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return super.nextEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     *\n+     * @return the keySet view\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet<K>(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @return the keySet iterator\n+     */\n+    protected Iterator<K> createKeySetIterator() {\n+        if (size() == 0) {\n+            return EmptyIterator.<K>emptyIterator();\n+        }\n+        return new KeySetIterator<K>(this);\n+    }\n+\n+    /**\n+     * KeySet implementation.\n+     */\n+    protected static class KeySet<K> extends AbstractSet<K> {\n+        /** The parent map */\n+        protected final AbstractHashedMap<K, ?> parent;\n+\n+        protected KeySet(final AbstractHashedMap<K, ?> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object key) {\n+            return parent.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object key) {\n+            final boolean result = parent.containsKey(key);\n+            parent.remove(key);\n+            return result;\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return parent.createKeySetIterator();\n+        }\n+    }\n+\n+    /**\n+     * KeySet iterator.\n+     */\n+    protected static class KeySetIterator<K> extends HashIterator<K, Object> implements Iterator<K> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySetIterator(final AbstractHashedMap<K, ?> parent) {\n+            super((AbstractHashedMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     *\n+     * @return the values view\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values<V>(this);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @return the values iterator\n+     */\n+    protected Iterator<V> createValuesIterator() {\n+        if (size() == 0) {\n+            return EmptyIterator.<V>emptyIterator();\n+        }\n+        return new ValuesIterator<V>(this);\n+    }\n+\n+    /**\n+     * Values implementation.\n+     */\n+    protected static class Values<V> extends AbstractCollection<V> {\n+        /** The parent map */\n+        protected final AbstractHashedMap<?, V> parent;\n+\n+        protected Values(final AbstractHashedMap<?, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object value) {\n+            return parent.containsValue(value);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return parent.createValuesIterator();\n+        }\n+    }\n+\n+    /**\n+     * Values iterator.\n+     */\n+    protected static class ValuesIterator<V> extends HashIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(final AbstractHashedMap<?, V> parent) {\n+            super((AbstractHashedMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return super.nextEntry().getValue();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * HashEntry used to store the data.\n+     * <p>\n+     * If you subclass <code>AbstractHashedMap</code> but not <code>HashEntry</code>\n+     * then you will not be able to access the protected fields.\n+     * The <code>entryXxx()</code> methods on <code>AbstractHashedMap</code> exist\n+     * to provide the necessary access.\n+     */\n+    protected static class HashEntry<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+        /** The next entry in the hash chain */\n+        protected HashEntry<K, V> next;\n+        /** The hash code of the key */\n+        protected int hashCode;\n+        /** The key */\n+        protected Object key;\n+        /** The value */\n+        protected Object value;\n+\n+        protected HashEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n+            super();\n+            this.next = next;\n+            this.hashCode = hashCode;\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public K getKey() {\n+            if (key == NULL) {\n+                return null;\n+            }\n+            return (K) key;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V getValue() {\n+            return (V) value;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public V setValue(final V value) {\n+            final Object old = this.value;\n+            this.value = value;\n+            return (V) old;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return\n+                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (getKey() == null ? 0 : getKey().hashCode()) ^\n+                   (getValue() == null ? 0 : getValue().hashCode());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return new StringBuilder().append(getKey()).append('=').append(getValue()).toString();\n+        }\n+    }\n+\n+    /**\n+     * Base Iterator\n+     */\n+    protected static abstract class HashIterator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractHashedMap<K, V> parent;\n+        /** The current index into the array of buckets */\n+        protected int hashIndex;\n+        /** The last returned entry */\n+        protected HashEntry<K, V> last;\n+        /** The next entry */\n+        protected HashEntry<K, V> next;\n+        /** The modification count expected */\n+        protected int expectedModCount;\n+\n+        protected HashIterator(final AbstractHashedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            final HashEntry<K, V>[] data = parent.data;\n+            int i = data.length;\n+            HashEntry<K, V> next = null;\n+            while (i > 0 && next == null) {\n+                next = data[--i];\n+            }\n+            this.next = next;\n+            this.hashIndex = i;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return next != null;\n+        }\n+\n+        protected HashEntry<K, V> nextEntry() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            final HashEntry<K, V> newCurrent = next;\n+            if (newCurrent == null)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            final HashEntry<K, V>[] data = parent.data;\n+            int i = hashIndex;\n+            HashEntry<K, V> n = newCurrent.next;\n+            while (n == null && i > 0) {\n+                n = data[--i];\n+            }\n+            next = n;\n+            hashIndex = i;\n+            last = newCurrent;\n+            return newCurrent;\n+        }\n+\n+        protected HashEntry<K, V> currentEntry() {\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (last == null) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            parent.remove(last.getKey());\n+            last = null;\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Writes the map data to the stream. This method must be overridden if a\n+     * subclass must be setup before <code>put()</code> is used.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to serialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>writeObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if they have a specific field that must be present\n+     * on read before this implementation will work. Generally, the read determines\n+     * what must be serialized here, if anything.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException if an error occurs while writing tothe stream\n+     */\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n+        out.writeFloat(loadFactor);\n+        out.writeInt(data.length);\n+        out.writeInt(size);\n+        for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+            out.writeObject(it.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Reads the map data from the stream. This method must be overridden if a\n+     * subclass must be setup before <code>put()</code> is used.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to deserialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>readObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if the subclass has a specific field that must be present\n+     * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException if an error occurs while reading from the stream\n+     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        loadFactor = in.readFloat();\n+        final int capacity = in.readInt();\n+        final int size = in.readInt();\n+        init();\n+        threshold = calculateThreshold(capacity, loadFactor);\n+        data = new HashEntry[capacity];\n+        for (int i = 0; i < size; i++) {\n+            final K key = (K) in.readObject();\n+            final V value = (V) in.readObject();\n+            put(key, value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     * <p>\n+     * To implement <code>clone()</code>, a subclass must implement the\n+     * <code>Cloneable</code> interface and make this method public.\n+     *\n+     * @return a shallow clone\n+     * @throws InternalError if {@link AbstractMap#clone()} failed\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected AbstractHashedMap<K, V> clone() {\n+        try {\n+            final AbstractHashedMap<K, V> cloned = (AbstractHashedMap<K, V>) super.clone();\n+            cloned.data = new HashEntry[data.length];\n+            cloned.entrySet = null;\n+            cloned.keySet = null;\n+            cloned.values = null;\n+            cloned.modCount = 0;\n+            cloned.size = 0;\n+            cloned.init();\n+            cloned.putAll(this);\n+            return cloned;\n+        } catch (final CloneNotSupportedException ex) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        final Map<?,?> map = (Map<?,?>) obj;\n+        if (map.size() != size()) {\n+            return false;\n+        }\n+        final MapIterator<?,?> it = mapIterator();\n+        try {\n+            while (it.hasNext()) {\n+                final Object key = it.next();\n+                final Object value = it.getValue();\n+                if (value == null) {\n+                    if (map.get(key) != null || map.containsKey(key) == false) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (value.equals(map.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } catch (final ClassCastException ignored)   {\n+            return false;\n+        } catch (final NullPointerException ignored) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     *\n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        final Iterator<Map.Entry<K, V>> it = createEntrySetIterator();\n+        while (it.hasNext()) {\n+            total += it.next().hashCode();\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     *\n+     * @return a string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"{}\";\n+        }\n+        final StringBuilder buf = new StringBuilder(32 * size());\n+        buf.append('{');\n+\n+        final MapIterator<K, V> it = mapIterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            final K key = it.next();\n+            final V value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(',').append(' ');\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.lang.reflect.Array;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.AbstractSetDecorator;\n+import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;\n+\n+/**\n+ * An abstract base class that simplifies the task of creating map decorators.\n+ * <p>\n+ * The Map API is very difficult to decorate correctly, and involves implementing\n+ * lots of different classes. This class exists to provide a simpler API.\n+ * <p>\n+ * Special hook methods are provided that are called when objects are added to\n+ * the map. By overriding these methods, the input can be validated or manipulated.\n+ * In addition to the main map methods, the entrySet is also affected, which is\n+ * the hardest part of writing map implementations.\n+ * <p>\n+ * This class is package-scoped, and may be withdrawn or replaced in future\n+ * versions of Commons Collections.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+abstract class AbstractInputCheckedMapDecorator<K, V>\n+        extends AbstractMapDecorator<K, V> {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractInputCheckedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected AbstractInputCheckedMapDecorator(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Hook method called when a value is being set using <code>setValue</code>.\n+     * <p>\n+     * An implementation may validate the value and throw an exception\n+     * or it may transform the value into another object.\n+     * <p>\n+     * This implementation returns the input value.\n+     * \n+     * @param value  the value to check\n+     * @throws UnsupportedOperationException if the map may not be changed by setValue\n+     * @throws IllegalArgumentException if the specified value is invalid\n+     * @throws ClassCastException if the class of the specified value is invalid\n+     * @throws NullPointerException if the specified value is null and nulls are invalid\n+     */\n+    protected abstract V checkSetValue(V value);\n+\n+    /**\n+     * Hook method called to determine if <code>checkSetValue</code> has any effect.\n+     * <p>\n+     * An implementation should return false if the <code>checkSetValue</code> method\n+     * has no effect as this optimises the implementation.\n+     * <p>\n+     * This implementation returns <code>true</code>.\n+     * \n+     * @return true always\n+     */\n+    protected boolean isSetValueChecking() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (isSetValueChecking()) {\n+            return new EntrySet(map.entrySet(), this);\n+        }\n+        return map.entrySet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set that checks additions via setValue.\n+     */\n+    private class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>> {\n+        \n+        /** Generated serial version ID. */\n+        private static final long serialVersionUID = 4354731610923110264L;\n+\n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected EntrySet(final Set<Map.Entry<K, V>> set, final AbstractInputCheckedMapDecorator<K, V> parent) {\n+            super(set);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new EntrySetIterator(collection.iterator(), parent);\n+        }\n+        \n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Object[] toArray() {\n+            final Object[] array = collection.toArray();\n+            for (int i = 0; i < array.length; i++) {\n+                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n+            }\n+            return array;\n+        }\n+        \n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T[] toArray(final T[] array) {\n+            Object[] result = array;\n+            if (array.length > 0) {\n+                // we must create a new array to handle multi-threaded situations\n+                // where another thread could access data before we decorate it\n+                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+            }\n+            result = collection.toArray(result);\n+            for (int i = 0; i < result.length; i++) {\n+                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n+            }\n+\n+            // check to see if result should be returned straight\n+            if (result.length > array.length) {\n+                return (T[]) result;\n+            }\n+\n+            // copy back into input array to fulfil the method contract\n+            System.arraycopy(result, 0, array, 0, result.length);\n+            if (array.length > result.length) {\n+                array[result.length] = null;\n+            }\n+            return array;\n+        }\n+    }\n+\n+    /**\n+     * Implementation of an entry set iterator that checks additions via setValue.\n+     */\n+    private class EntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator,\n+                                   final AbstractInputCheckedMapDecorator<K, V> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Map.Entry<K, V> next() {\n+            final Map.Entry<K, V> entry = iterator.next();\n+            return new MapEntry(entry, parent);\n+        }\n+    }\n+\n+    /**\n+     * Implementation of a map entry that checks additions via setValue.\n+     */\n+    private class MapEntry extends AbstractMapEntryDecorator<K, V> {\n+\n+        /** The parent map */\n+        private final AbstractInputCheckedMapDecorator<K, V> parent;\n+\n+        protected MapEntry(final Map.Entry<K, V> entry, final AbstractInputCheckedMapDecorator<K, V> parent) {\n+            super(entry);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public V setValue(V value) {\n+            value = parent.checkSetValue(value);\n+            return entry.setValue(value);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractIterableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+\n+/**\n+ * Provide a basic {@link IterableMap} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractIterableMap<K, V> implements IterableMap<K, V> {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new EntrySetToMapIteratorAdapter<K, V>(entrySet());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.OrderedIterator;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\n+\n+/**\n+ * An abstract implementation of a hash-based map that links entries to create an\n+ * ordered map and which provides numerous points for subclasses to override.\n+ * <p>\n+ * This class implements all the features necessary for a subclass linked\n+ * hash-based map. Key-value entries are stored in instances of the\n+ * <code>LinkEntry</code> class which can be overridden and replaced.\n+ * The iterators can similarly be replaced, without the need to replace the KeySet,\n+ * EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * This implementation maintains order by original insertion, but subclasses\n+ * may work differently. The <code>OrderedMap</code> interface is implemented\n+ * to provide access to bidirectional iteration and extra convenience methods.\n+ * <p>\n+ * The <code>orderedMapIterator()</code> method provides direct access to a\n+ * bidirectional iterator. The iterators from the other views can also be cast\n+ * to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * The implementation is also designed to be subclassed, with lots of useful\n+ * methods exposed.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractLinkedMap<K, V> extends AbstractHashedMap<K, V> implements OrderedMap<K, V> {\n+    \n+    /** Header in the linked list */\n+    protected transient LinkEntry<K, V> header;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractLinkedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which performs no validation on the passed in parameters.\n+     * \n+     * @param initialCapacity  the initial capacity, must be a power of two\n+     * @param loadFactor  the load factor, must be > 0.0f and generally < 1.0f\n+     * @param threshold  the threshold, must be sensible\n+     */\n+    protected AbstractLinkedMap(final int initialCapacity, final float loadFactor, final int threshold) {\n+        super(initialCapacity, loadFactor, threshold);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    protected AbstractLinkedMap(final int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    protected AbstractLinkedMap(final int initialCapacity, final float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    protected AbstractLinkedMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Initialise this subclass during construction.\n+     * <p>\n+     * NOTE: As from v3.2 this method calls\n+     * {@link #createEntry(HashEntry, int, Object, Object)} to create\n+     * the map entry object.\n+     */\n+    @Override\n+    protected void init() {\n+        header = createEntry(null, -1, null, null);\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    public boolean containsValue(final Object value) {\n+        // override uses faster iterator\n+        if (value == null) {\n+            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n+                if (entry.getValue() == null) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n+                if (isEqualValue(value, entry.getValue())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    @Override\n+    public void clear() {\n+        // override to reset the linked list\n+        super.clear();\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first key in the map, which is the first inserted.\n+     * \n+     * @return the eldest key\n+     */\n+    public K firstKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.after.getKey();\n+    }\n+\n+    /**\n+     * Gets the last key in the map, which is the most recently inserted.\n+     * \n+     * @return the most recently inserted key\n+     */\n+    public K lastKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.before.getKey();\n+    }\n+\n+    /**\n+     * Gets the next key in sequence.\n+     * \n+     * @param key  the key to get after\n+     * @return the next key\n+     */\n+    public K nextKey(final Object key) {\n+        final LinkEntry<K, V> entry = getEntry(key);\n+        return entry == null || entry.after == header ? null : entry.after.getKey();\n+    }\n+\n+    @Override\n+    protected LinkEntry<K, V> getEntry(final Object key) {\n+        return (LinkEntry<K, V>) super.getEntry(key);\n+    }\n+\n+    /**\n+     * Gets the previous key in sequence.\n+     * \n+     * @param key  the key to get before\n+     * @return the previous key\n+     */\n+    public K previousKey(final Object key) {\n+        final LinkEntry<K, V> entry = getEntry(key);\n+        return entry == null || entry.before == header ? null : entry.before.getKey();\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    protected LinkEntry<K, V> getEntry(final int index) {\n+        if (index < 0) {\n+            throw new IndexOutOfBoundsException(\"Index \" + index + \" is less than zero\");\n+        }\n+        if (index >= size) {\n+            throw new IndexOutOfBoundsException(\"Index \" + index + \" is invalid for size \" + size);\n+        }\n+        LinkEntry<K, V> entry;\n+        if (index < size / 2) {\n+            // Search forwards\n+            entry = header.after;\n+            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n+                entry = entry.after;\n+            }\n+        } else {\n+            // Search backwards\n+            entry = header;\n+            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n+                entry = entry.before;\n+            }\n+        }\n+        return entry;\n+    }\n+    \n+    /**\n+     * Adds an entry into this map, maintaining insertion order.\n+     * <p>\n+     * This implementation adds the entry to the data storage table and\n+     * to the end of the linked list.\n+     * \n+     * @param entry  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    @Override\n+    protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {\n+        final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n+        link.after  = header;\n+        link.before = header.before;\n+        header.before.after = link;\n+        header.before = link;\n+        data[hashIndex] = link;\n+    }\n+\n+    /**\n+     * Creates an entry to store the data.\n+     * <p>\n+     * This implementation creates a new LinkEntry instance.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected LinkEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+        return new LinkEntry<K, V>(next, hashCode, convertKey(key), value);\n+    }\n+\n+    /**\n+     * Removes an entry from the map and the linked list.\n+     * <p>\n+     * This implementation removes the entry from the linked list chain, then\n+     * calls the superclass implementation.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    @Override\n+    protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n+        final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n+        link.before.after = link.after;\n+        link.after.before = link.before;\n+        link.after = null;\n+        link.before = null;\n+        super.removeEntry(entry, hashIndex, previous);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the <code>before</code> field from a <code>LinkEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     * \n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>before</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since 3.1\n+     */\n+    protected LinkEntry<K, V> entryBefore(final LinkEntry<K, V> entry) {\n+        return entry.before;\n+    }\n+\n+    /**\n+     * Gets the <code>after</code> field from a <code>LinkEntry</code>.\n+     * Used in subclasses that have no visibility of the field.\n+     * \n+     * @param entry  the entry to query, must not be null\n+     * @return the <code>after</code> field of the entry\n+     * @throws NullPointerException if the entry is null\n+     * @since 3.1\n+     */\n+    protected LinkEntry<K, V> entryAfter(final LinkEntry<K, V> entry) {\n+        return entry.after;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        if (size == 0) {\n+            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n+        }\n+        return new LinkMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * MapIterator implementation.\n+     */\n+    protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n+            OrderedMapIterator<K, V>, ResettableIterator<K> {\n+\n+        protected LinkMapIterator(final AbstractLinkedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public K previous() {\n+            return super.previousEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            final LinkEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            final LinkEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            final LinkEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the entrySet iterator\n+     */\n+    @Override\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        if (size() == 0) {\n+            return EmptyOrderedIterator.<Map.Entry<K, V>>emptyOrderedIterator();\n+        }\n+        return new EntrySetIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * EntrySet iterator.\n+     */\n+    protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n+            OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>> {\n+\n+        protected EntrySetIterator(final AbstractLinkedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return super.nextEntry();\n+        }\n+\n+        public Map.Entry<K, V> previous() {\n+            return super.previousEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the keySet iterator\n+     */\n+    @Override\n+    protected Iterator<K> createKeySetIterator() {\n+        if (size() == 0) {\n+            return EmptyOrderedIterator.<K>emptyOrderedIterator();\n+        }\n+        return new KeySetIterator<K>(this);\n+    }\n+\n+    /**\n+     * KeySet iterator.\n+     */\n+    protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n+            OrderedIterator<K>, ResettableIterator<K> {\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        protected KeySetIterator(final AbstractLinkedMap<K, ?> parent) {\n+            super((AbstractLinkedMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public K previous() {\n+            return super.previousEntry().getKey();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the values iterator\n+     */\n+    @Override\n+    protected Iterator<V> createValuesIterator() {\n+        if (size() == 0) {\n+            return EmptyOrderedIterator.<V>emptyOrderedIterator();\n+        }\n+        return new ValuesIterator<V>(this);\n+    }\n+\n+    /**\n+     * Values iterator.\n+     */\n+    protected static class ValuesIterator<V> extends LinkIterator<Object, V> implements\n+            OrderedIterator<V>, ResettableIterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected ValuesIterator(final AbstractLinkedMap<?, V> parent) {\n+            super((AbstractLinkedMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return super.nextEntry().getValue();\n+        }\n+\n+        public V previous() {\n+            return super.previousEntry().getValue();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * LinkEntry that stores the data.\n+     * <p>\n+     * If you subclass <code>AbstractLinkedMap</code> but not <code>LinkEntry</code>\n+     * then you will not be able to access the protected fields.\n+     * The <code>entryXxx()</code> methods on <code>AbstractLinkedMap</code> exist\n+     * to provide the necessary access.\n+     */\n+    protected static class LinkEntry<K, V> extends HashEntry<K, V> {\n+        /** The entry before this one in the order */\n+        protected LinkEntry<K, V> before;\n+        /** The entry after this one in the order */\n+        protected LinkEntry<K, V> after;\n+\n+        /**\n+         * Constructs a new entry.\n+         * \n+         * @param next  the next entry in the hash bucket sequence\n+         * @param hashCode  the hash code\n+         * @param key  the key\n+         * @param value  the value\n+         */\n+        protected LinkEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n+            super(next, hashCode, key, value);\n+        }\n+    }\n+\n+    /**\n+     * Base Iterator that iterates in link order.\n+     */\n+    protected static abstract class LinkIterator<K, V> {\n+\n+        /** The parent map */\n+        protected final AbstractLinkedMap<K, V> parent;\n+        /** The current (last returned) entry */\n+        protected LinkEntry<K, V> last;\n+        /** The next entry */\n+        protected LinkEntry<K, V> next;\n+        /** The modification count expected */\n+        protected int expectedModCount;\n+\n+        protected LinkIterator(final AbstractLinkedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            this.next = parent.header.after;\n+            this.expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return next != parent.header;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return next.before != parent.header;\n+        }\n+\n+        protected LinkEntry<K, V> nextEntry() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (next == parent.header)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            last = next;\n+            next = next.after;\n+            return last;\n+        }\n+\n+        protected LinkEntry<K, V> previousEntry() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            final LinkEntry<K, V> previous = next.before;\n+            if (previous == parent.header)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n+            }\n+            next = previous;\n+            last = previous;\n+            return last;\n+        }\n+\n+        protected LinkEntry<K, V> currentEntry() {\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (last == null) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            parent.remove(last.getKey());\n+            last = null;\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        public void reset() {\n+            last = null;\n+            next = parent.header.after;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (last != null) {\n+                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a Map via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with\n+ * {@link #entrySet()}, {@link #keySet()} or {@link #values()}. Instead\n+ * it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating\n+ * implementation it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapDecorator<K, V> extends AbstractIterableMap<K, V> {\n+\n+    /** The map to decorate */\n+    protected transient Map<K, V> map;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    protected AbstractMapDecorator(final Map<K, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        this.map = map;\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected Map<K, V> decorated() {\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public boolean containsKey(final Object key) {\n+        return decorated().containsKey(key);\n+    }\n+\n+    public boolean containsValue(final Object value) {\n+        return decorated().containsValue(value);\n+    }\n+\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return decorated().entrySet();\n+    }\n+\n+    public V get(final Object key) {\n+        return decorated().get(key);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n+    }\n+\n+    public V put(final K key, final V value) {\n+        return decorated().put(key, value);\n+    }\n+\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        decorated().putAll(mapToCopy);\n+    }\n+\n+    public V remove(final Object key) {\n+        return decorated().remove(key);\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Collection<V> values() {\n+        return decorated().values();\n+    }\n+   \n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to an OrderedMap via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractOrderedMapDecorator<K, V> extends AbstractMapDecorator<K, V>\n+        implements OrderedMap<K, V> {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractOrderedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractOrderedMapDecorator(final OrderedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected OrderedMap<K, V> decorated() {\n+        return (OrderedMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    public K nextKey(final K key) {\n+        return decorated().nextKey(key);\n+    }\n+\n+    public K previousKey(final K key) {\n+        return decorated().previousKey(key);\n+    }\n+\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.keyvalue.DefaultMapEntry;\n+\n+/**\n+ * An abstract implementation of a hash-based map that allows the entries to\n+ * be removed by the garbage collector.\n+ * <p>\n+ * This class implements all the features necessary for a subclass reference\n+ * hash-based map. Key-value entries are stored in instances of the\n+ * <code>ReferenceEntry</code> class which can be overridden and replaced.\n+ * The iterators can similarly be replaced, without the need to replace the KeySet,\n+ * EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * When you construct an <code>AbstractReferenceMap</code>, you can specify what\n+ * kind of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The keys can be configured to be weak but the values hard,\n+ * in which case this class will behave like a\n+ * <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n+ * <code>WeakHashMap</code></a>. However, you can also specify hard keys and\n+ * weak values, or any other combination. The default constructor uses\n+ * hard keys and soft values, providing a memory-sensitive cache.\n+ * <p>\n+ * This {@link Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a\n+ * <code>NullPointerException</code>.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to\n+ * provide synchronized access to a <code>ReferenceMap</code>.\n+ *\n+ * @see java.lang.ref.Reference\n+ * @since 3.1 (extracted from ReferenceMap in 3.0)\n+ * @version $Id$\n+ */\n+public abstract class AbstractReferenceMap<K, V> extends AbstractHashedMap<K, V> {\n+\n+    /**\n+     * Reference type enum.\n+     */\n+    public static enum ReferenceStrength {\n+        HARD(0), SOFT(1), WEAK(2);\n+\n+        /** value */\n+        public final int value;\n+\n+        /**\n+         * Resolve enum from int.\n+         * @param value  the int value\n+         * @return ReferenceType\n+         * @throws IllegalArgumentException if the specified value is invalid.\n+         */\n+        public static ReferenceStrength resolve(final int value) {\n+            switch (value) {\n+            case 0:\n+                return HARD;\n+            case 1:\n+                return SOFT;\n+            case 2:\n+                return WEAK;\n+            default:\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        private ReferenceStrength(final int value) {\n+            this.value = value;\n+        }\n+\n+    }\n+\n+    /**\n+     * The reference type for keys.\n+     */\n+    protected ReferenceStrength keyType;\n+\n+    /**\n+     * The reference type for values.\n+     */\n+    protected ReferenceStrength valueType;\n+\n+    /**\n+     * Should the value be automatically purged when the associated key has been collected?\n+     */\n+    protected boolean purgeValues;\n+\n+    /**\n+     * ReferenceQueue used to eliminate stale mappings.\n+     * See purge.\n+     */\n+    private transient ReferenceQueue<Object> queue;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor used during deserialization.\n+     */\n+    protected AbstractReferenceMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty map with the specified reference types,\n+     * load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link ReferenceStrength#HARD HARD}, \n+     *   {@link ReferenceStrength#SOFT SOFT}, \n+     *   {@link ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link ReferenceStrength#HARD},\n+     *   {@link ReferenceStrength#SOFT SOFT},\n+     *   {@link ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the\n+     *   key is garbage collected\n+     */\n+    protected AbstractReferenceMap(\n+            final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n+            final float loadFactor, final boolean purgeValues) {\n+        super(capacity, loadFactor);\n+        this.keyType = keyType;\n+        this.valueType = valueType;\n+        this.purgeValues = purgeValues;\n+    }\n+\n+    /**\n+     * Initialise this subclass during construction, cloning or deserialization.\n+     */\n+    @Override\n+    protected void init() {\n+        queue = new ReferenceQueue<Object>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of the map.\n+     *\n+     * @return the size\n+     */\n+    @Override\n+    public int size() {\n+        purgeBeforeRead();\n+        return super.size();\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     *\n+     * @return true if the map is currently size zero\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        purgeBeforeRead();\n+        return super.isEmpty();\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified key.\n+     *\n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    @Override\n+    public boolean containsKey(final Object key) {\n+        purgeBeforeRead();\n+        final Entry<K, V> entry = getEntry(key);\n+        if (entry == null) {\n+            return false;\n+        }\n+        return entry.getValue() != null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    public boolean containsValue(final Object value) {\n+        purgeBeforeRead();\n+        if (value == null) {\n+            return false;\n+        }\n+        return super.containsValue(value);\n+    }\n+\n+    /**\n+     * Gets the value mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    @Override\n+    public V get(final Object key) {\n+        purgeBeforeRead();\n+        final Entry<K, V> entry = getEntry(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+\n+\n+    /**\n+     * Puts a key-value mapping into this map.\n+     * Neither the key nor the value may be null.\n+     *\n+     * @param key  the key to add, must not be null\n+     * @param value  the value to add, must not be null\n+     * @return the value previously mapped to this key, null if none\n+     * @throws NullPointerException if either the key or value is null\n+     */\n+    @Override\n+    public V put(final K key, final V value) {\n+        if (key == null) {\n+            throw new NullPointerException(\"null keys not allowed\");\n+        }\n+        if (value == null) {\n+            throw new NullPointerException(\"null values not allowed\");\n+        }\n+\n+        purgeBeforeWrite();\n+        return super.put(key, value);\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     *\n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    @Override\n+    public V remove(final Object key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        purgeBeforeWrite();\n+        return super.remove(key);\n+    }\n+\n+    /**\n+     * Clears this map.\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        while (queue.poll() != null) {} // drain the queue\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a MapIterator over the reference map.\n+     * The iterator only returns valid key/value pairs.\n+     *\n+     * @return a map iterator\n+     */\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        return new ReferenceMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Returns a set view of this map's entries.\n+     * An iterator returned entry is valid until <code>next()</code> is called again.\n+     * The <code>setValue()</code> method on the <code>toArray</code> entries has no effect.\n+     *\n+     * @return a set view of this map's entries\n+     */\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new ReferenceEntrySet<K, V>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Returns a set view of this map's keys.\n+     *\n+     * @return a set view of this map's keys\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new ReferenceKeySet<K>(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Returns a collection view of this map's values.\n+     *\n+     * @return a set view of this map's values\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new ReferenceValues<V>(this);\n+        }\n+        return values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Purges stale mappings from this map before read operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     */\n+    protected void purgeBeforeRead() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map before write operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     */\n+    protected void purgeBeforeWrite() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map.\n+     * <p>\n+     * Note that this method is not synchronized!  Special\n+     * care must be taken if, for instance, you want stale\n+     * mappings to be removed on a periodic basis by some\n+     * background thread.\n+     */\n+    protected void purge() {\n+        Reference<?> ref = queue.poll();\n+        while (ref != null) {\n+            purge(ref);\n+            ref = queue.poll();\n+        }\n+    }\n+\n+    /**\n+     * Purges the specified reference.\n+     *\n+     * @param ref  the reference to purge\n+     */\n+    protected void purge(final Reference<?> ref) {\n+        // The hashCode of the reference is the hashCode of the\n+        // mapping key, even if the reference refers to the\n+        // mapping value...\n+        final int hash = ref.hashCode();\n+        final int index = hashIndex(hash, data.length);\n+        HashEntry<K, V> previous = null;\n+        HashEntry<K, V> entry = data[index];\n+        while (entry != null) {\n+            if (((ReferenceEntry<K, V>) entry).purge(ref)) {\n+                if (previous == null) {\n+                    data[index] = entry.next;\n+                } else {\n+                    previous.next = entry.next;\n+                }\n+                this.size--;\n+                return;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    @Override\n+    protected HashEntry<K, V> getEntry(final Object key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        return super.getEntry(key);\n+    }\n+\n+    /**\n+     * Gets the hash code for a MapEntry.\n+     * Subclasses can override this, for example to use the identityHashCode.\n+     *\n+     * @param key  the key to get a hash code for, may be null\n+     * @param value  the value to get a hash code for, may be null\n+     * @return the hash code, as per the MapEntry specification\n+     */\n+    protected int hashEntry(final Object key, final Object value) {\n+        return (key == null ? 0 : key.hashCode()) ^\n+               (value == null ? 0 : value.hashCode());\n+    }\n+\n+    /**\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison.\n+     *\n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected boolean isEqualKey(final Object key1, Object key2) {\n+        key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<K>) key2).get();\n+        return key1 == key2 || key1.equals(key2);\n+    }\n+\n+    /**\n+     * Creates a ReferenceEntry instead of a HashEntry.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected ReferenceEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n+                                               final K key, final V value) {\n+        return new ReferenceEntry<K, V>(this, next, hashCode, key, value);\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     *\n+     * @return the entrySet iterator\n+     */\n+    @Override\n+    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n+        return new ReferenceEntrySetIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Creates an key set iterator.\n+     *\n+     * @return the keySet iterator\n+     */\n+    @Override\n+    protected Iterator<K> createKeySetIterator() {\n+        return new ReferenceKeySetIterator<K>(this);\n+    }\n+\n+    /**\n+     * Creates an values iterator.\n+     *\n+     * @return the values iterator\n+     */\n+    @Override\n+    protected Iterator<V> createValuesIterator() {\n+        return new ReferenceValuesIterator<V>(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * EntrySet implementation.\n+     */\n+    static class ReferenceEntrySet<K, V> extends EntrySet<K, V> {\n+\n+        protected ReferenceEntrySet(final AbstractHashedMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return toArray(new Object[size()]);\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(final T[] arr) {\n+            // special implementation to handle disappearing entries\n+            final ArrayList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(size());\n+            for (final Map.Entry<K, V> entry : this) {\n+                list.add(new DefaultMapEntry<K, V>(entry));\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * KeySet implementation.\n+     */\n+    static class ReferenceKeySet<K> extends KeySet<K> {\n+\n+        protected ReferenceKeySet(final AbstractHashedMap<K, ?> parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return toArray(new Object[size()]);\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(final T[] arr) {\n+            // special implementation to handle disappearing keys\n+            final List<K> list = new ArrayList<K>(size());\n+            for (final K key : this) {\n+                list.add(key);\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Values implementation.\n+     */\n+    static class ReferenceValues<V> extends Values<V> {\n+\n+        protected ReferenceValues(final AbstractHashedMap<?, V> parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return toArray(new Object[size()]);\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(final T[] arr) {\n+            // special implementation to handle disappearing values\n+            final List<V> list = new ArrayList<V>(size());\n+            for (final V value : this) {\n+                list.add(value);\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A MapEntry implementation for the map.\n+     * <p>\n+     * If getKey() or getValue() returns null, it means\n+     * the mapping is stale and should be removed.\n+     *\n+     * @since 3.1\n+     */\n+    protected static class ReferenceEntry<K, V> extends HashEntry<K, V> {\n+        /** The parent map */\n+        protected final AbstractReferenceMap<K, V> parent;\n+\n+        /**\n+         * Creates a new entry object for the ReferenceMap.\n+         *\n+         * @param parent  the parent map\n+         * @param next  the next entry in the hash bucket\n+         * @param hashCode  the hash code of the key\n+         * @param key  the key\n+         * @param value  the value\n+         */\n+        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next,\n+                              final int hashCode, final K key, final V value) {\n+            super(next, hashCode, null, null);\n+            this.parent = parent;\n+            this.key = toReference(parent.keyType, key, hashCode);\n+            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n+        }\n+\n+        /**\n+         * Gets the key from the entry.\n+         * This method dereferences weak and soft keys and thus may return null.\n+         *\n+         * @return the key, which may be null if it was garbage collected\n+         */\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public K getKey() {\n+            return (K) (parent.keyType == ReferenceStrength.HARD ? key : ((Reference<K>) key).get());\n+        }\n+\n+        /**\n+         * Gets the value from the entry.\n+         * This method dereferences weak and soft value and thus may return null.\n+         *\n+         * @return the value, which may be null if it was garbage collected\n+         */\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V getValue() {\n+            return (V) (parent.valueType == ReferenceStrength.HARD ? value : ((Reference<V>) value).get());\n+        }\n+\n+        /**\n+         * Sets the value of the entry.\n+         *\n+         * @param obj  the object to store\n+         * @return the previous value\n+         */\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V setValue(final V obj) {\n+            final V old = getValue();\n+            if (parent.valueType != ReferenceStrength.HARD) {\n+                ((Reference<V>) value).clear();\n+            }\n+            value = toReference(parent.valueType, obj, hashCode);\n+            return old;\n+        }\n+\n+        /**\n+         * Compares this map entry to another.\n+         * <p>\n+         * This implementation uses <code>isEqualKey</code> and\n+         * <code>isEqualValue</code> on the main map for comparison.\n+         *\n+         * @param obj  the other map entry to compare to\n+         * @return true if equal, false if not\n+         */\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>)obj;\n+            final Object entryKey = entry.getKey();  // convert to hard reference\n+            final Object entryValue = entry.getValue();  // convert to hard reference\n+            if (entryKey == null || entryValue == null) {\n+                return false;\n+            }\n+            // compare using map methods, aiding identity subclass\n+            // note that key is direct access and value is via method\n+            return parent.isEqualKey(entryKey, key) &&\n+                   parent.isEqualValue(entryValue, getValue());\n+        }\n+\n+        /**\n+         * Gets the hashcode of the entry using temporary hard references.\n+         * <p>\n+         * This implementation uses <code>hashEntry</code> on the main map.\n+         *\n+         * @return the hashcode of the entry\n+         */\n+        @Override\n+        public int hashCode() {\n+            return parent.hashEntry(getKey(), getValue());\n+        }\n+\n+        /**\n+         * Constructs a reference of the given type to the given referent.\n+         * The reference is registered with the queue for later purging.\n+         *\n+         * @param <T> the type of the referenced object\n+         * @param type  HARD, SOFT or WEAK\n+         * @param referent  the object to refer to\n+         * @param hash  the hash code of the <i>key</i> of the mapping;\n+         *    this number might be different from referent.hashCode() if\n+         *    the referent represents a value and not a key\n+         * @return the reference to the object\n+         */\n+        protected <T> Object toReference(final ReferenceStrength type, final T referent, final int hash) {\n+            if (type == ReferenceStrength.HARD) {\n+                return referent;\n+            }\n+            if (type == ReferenceStrength.SOFT) {\n+                return new SoftRef<T>(hash, referent, parent.queue);\n+            }\n+            if (type == ReferenceStrength.WEAK) {\n+                return new WeakRef<T>(hash, referent, parent.queue);\n+            }\n+            throw new Error();\n+        }\n+\n+        /**\n+         * Purges the specified reference\n+         * @param ref  the reference to purge\n+         * @return true or false\n+         */\n+        boolean purge(final Reference<?> ref) {\n+            boolean r = parent.keyType != ReferenceStrength.HARD && key == ref;\n+            r = r || parent.valueType != ReferenceStrength.HARD && value == ref;\n+            if (r) {\n+                if (parent.keyType != ReferenceStrength.HARD) {\n+                    ((Reference<?>) key).clear();\n+                }\n+                if (parent.valueType != ReferenceStrength.HARD) {\n+                    ((Reference<?>) value).clear();\n+                } else if (parent.purgeValues) {\n+                    value = null;\n+                }\n+            }\n+            return r;\n+        }\n+\n+        /**\n+         * Gets the next entry in the bucket.\n+         *\n+         * @return the next entry in the bucket\n+         */\n+        protected ReferenceEntry<K, V> next() {\n+            return (ReferenceEntry<K, V>) next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Base iterator class.\n+     */\n+    static class ReferenceBaseIterator<K, V> {\n+        /** The parent map */\n+        final AbstractReferenceMap<K, V> parent;\n+\n+        // These fields keep track of where we are in the table.\n+        int index;\n+        ReferenceEntry<K, V> entry;\n+        ReferenceEntry<K, V> previous;\n+\n+        // These Object fields provide hard references to the\n+        // current and next entry; this assures that if hasNext()\n+        // returns true, next() will actually return a valid element.\n+        K currentKey, nextKey;\n+        V currentValue, nextValue;\n+\n+        int expectedModCount;\n+\n+        public ReferenceBaseIterator(final AbstractReferenceMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            index = parent.size() != 0 ? parent.data.length : 0;\n+            // have to do this here!  size() invocation above\n+            // may have altered the modCount.\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            checkMod();\n+            while (nextNull()) {\n+                ReferenceEntry<K, V> e = entry;\n+                int i = index;\n+                while (e == null && i > 0) {\n+                    i--;\n+                    e = (ReferenceEntry<K, V>) parent.data[i];\n+                }\n+                entry = e;\n+                index = i;\n+                if (e == null) {\n+                    currentKey = null;\n+                    currentValue = null;\n+                    return false;\n+                }\n+                nextKey = e.getKey();\n+                nextValue = e.getValue();\n+                if (nextNull()) {\n+                    entry = entry.next();\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private void checkMod() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        private boolean nextNull() {\n+            return nextKey == null || nextValue == null;\n+        }\n+\n+        protected ReferenceEntry<K, V> nextEntry() {\n+            checkMod();\n+            if (nextNull() && !hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            previous = entry;\n+            entry = entry.next();\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+            nextKey = null;\n+            nextValue = null;\n+            return previous;\n+        }\n+\n+        protected ReferenceEntry<K, V> currentEntry() {\n+            checkMod();\n+            return previous;\n+        }\n+\n+        public void remove() {\n+            checkMod();\n+            if (previous == null) {\n+                throw new IllegalStateException();\n+            }\n+            parent.remove(currentKey);\n+            previous = null;\n+            currentKey = null;\n+            currentValue = null;\n+            expectedModCount = parent.modCount;\n+        }\n+    }\n+\n+    /**\n+     * The EntrySet iterator.\n+     */\n+    static class ReferenceEntrySetIterator<K, V>\n+            extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        public ReferenceEntrySetIterator(final AbstractReferenceMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+    }\n+\n+    /**\n+     * The keySet iterator.\n+     */\n+    static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReferenceKeySetIterator(final AbstractReferenceMap<K, ?> parent) {\n+            super((AbstractReferenceMap<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+    }\n+\n+    /**\n+     * The values iterator.\n+     */\n+    static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ReferenceValuesIterator(final AbstractReferenceMap<?, V> parent) {\n+            super((AbstractReferenceMap<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            return nextEntry().getValue();\n+        }\n+    }\n+\n+    /**\n+     * The MapIterator implementation.\n+     */\n+    static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V> {\n+\n+        protected ReferenceMapIterator(final AbstractReferenceMap<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            final HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            final HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            final HashEntry<K, V> current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // These two classes store the hashCode of the key of\n+    // of the mapping, so that after they're dequeued a quick\n+    // lookup of the bucket in the table can occur.\n+\n+    /**\n+     * A soft reference holder.\n+     */\n+    static class SoftRef<T> extends SoftReference<T> {\n+        /** the hashCode of the key (even if the reference points to a value) */\n+        private final int hash;\n+\n+        public SoftRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    /**\n+     * A weak reference holder.\n+     */\n+    static class WeakRef<T> extends WeakReference<T> {\n+        /** the hashCode of the key (even if the reference points to a value) */\n+        private final int hash;\n+\n+        public WeakRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Replaces the superclass method to store the state of this class.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to serialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>writeObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if they have a specific field that must be present\n+     * on read before this implementation will work. Generally, the read determines\n+     * what must be serialized here, if anything.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException if an error occurs while writing to the stream\n+     */\n+    @Override\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n+        out.writeInt(keyType.value);\n+        out.writeInt(valueType.value);\n+        out.writeBoolean(purgeValues);\n+        out.writeFloat(loadFactor);\n+        out.writeInt(data.length);\n+        for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+            out.writeObject(it.getValue());\n+        }\n+        out.writeObject(null);  // null terminate map\n+        // do not call super.doWriteObject() as code there doesn't work for reference map\n+    }\n+\n+    /**\n+     * Replaces the superclass method to read the state of this class.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to deserialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>readObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if the subclass has a specific field that must be present\n+     * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException if an error occurs while reading from the stream\n+     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        this.keyType = ReferenceStrength.resolve(in.readInt());\n+        this.valueType = ReferenceStrength.resolve(in.readInt());\n+        this.purgeValues = in.readBoolean();\n+        this.loadFactor = in.readFloat();\n+        final int capacity = in.readInt();\n+        init();\n+        data = new HashEntry[capacity];\n+        while (true) {\n+            final K key = (K) in.readObject();\n+            if (key == null) {\n+                break;\n+            }\n+            final V value = (V) in.readObject();\n+            put(key, value);\n+        }\n+        threshold = calculateThreshold(data.length, loadFactor);\n+        // do not call super.doReadObject() as code there doesn't work for reference map\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.IterableSortedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.iterators.ListIteratorWrapper;\n+\n+/** \n+ * Provides a base decorator that enables additional functionality to be added\n+ * to a Map via decoration.\n+ * <p>\n+ * Methods are forwarded directly to the decorated map.\n+ * <p>\n+ * This implementation does not perform any special processing with the map views.\n+ * Instead it simply returns the set/collection from the wrapped map. This may be\n+ * undesirable, for example if you are trying to write a validating implementation\n+ * it would provide a loophole around the validation.\n+ * But, you might want that loophole, so this class is kept simple.\n+ *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedMapDecorator<K, V> extends AbstractMapDecorator<K, V> implements\n+        IterableSortedMap<K, V> {\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractSortedMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the collection is null\n+     */\n+    public AbstractSortedMapDecorator(final SortedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    @Override\n+    protected SortedMap<K, V> decorated() {\n+        return (SortedMap<K, V>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return decorated().subMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return decorated().headMap(toKey);\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return decorated().tailMap(fromKey);\n+    }\n+\n+    public K previousKey(final K key) {\n+        final SortedMap<K, V> headMap = headMap(key);\n+        return headMap.isEmpty() ? null : headMap.lastKey();\n+    }\n+\n+    public K nextKey(final K key) {\n+        final Iterator<K> it = tailMap(key).keySet().iterator();\n+        it.next();\n+        return it.hasNext() ? it.next() : null;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new SortedMapIterator<K, V>(entrySet());\n+    }\n+\n+    /**\n+     * OrderedMapIterator implementation.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     */\n+    protected static class SortedMapIterator<K, V> extends EntrySetToMapIteratorAdapter<K, V>\n+            implements OrderedMapIterator<K, V> {\n+\n+        /**\n+         * Create a new AbstractSortedMapDecorator.SortedMapIterator.\n+         * @param entrySet  the entrySet to iterate\n+         */\n+        protected SortedMapIterator(final Set<Map.Entry<K, V>> entrySet) {\n+            super(entrySet);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public synchronized void reset() {\n+            super.reset();\n+            iterator = new ListIteratorWrapper<Map.Entry<K, V>>(iterator);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean hasPrevious() {\n+            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K previous() {\n+            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n+            return getKey();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/CaseInsensitiveMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * A case-insensitive <code>Map</code>.\n+ * <p>\n+ * Before keys are added to the map or compared to other existing keys, they are converted\n+ * to all lowercase in a locale-independent fashion by using information from the Unicode\n+ * data file.\n+ * <p>\n+ * Null keys are supported.  \n+ * <p>\n+ * The <code>keySet()</code> method returns all lowercase keys, or nulls.\n+ * <p>\n+ * Example:\n+ * <pre><code>\n+ *  Map&lt;String, String&gt; map = new CaseInsensitiveMap&lt;String, String&gt;();\n+ *  map.put(\"One\", \"One\");\n+ *  map.put(\"Two\", \"Two\");\n+ *  map.put(null, \"Three\");\n+ *  map.put(\"one\", \"Four\");\n+ * </code></pre>\n+ * creates a <code>CaseInsensitiveMap</code> with three entries.<br>\n+ * <code>map.get(null)</code> returns <code>\"Three\"</code> and <code>map.get(\"ONE\")</code>\n+ * returns <code>\"Four\".</code>  The <code>Set</code> returned by <code>keySet()</code>\n+ * equals <code>{\"one\", \"two\", null}.</code>\n+ * <p>\n+ * <strong>This map will violate the detail of various Map and map view contracts.</note>\n+ * As a general rule, don't compare this map to other maps. In particular, you can't\n+ * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n+ * contracts are fulfilled.\n+ * <p>\n+ * <strong>Note that CaseInsensitiveMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CaseInsensitiveMap<K, V> extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -7074655917369299456L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public CaseInsensitiveMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public CaseInsensitiveMap(final int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public CaseInsensitiveMap(final int initialCapacity, final float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p>\n+     * Keys will be converted to lower case strings, which may cause\n+     * some entries to be removed (if string representation of keys differ\n+     * only by character case).\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public CaseInsensitiveMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overrides convertKey() from {@link AbstractHashedMap} to convert keys to \n+     * lower case.\n+     * <p>\n+     * Returns {@link AbstractHashedMap#NULL} if key is null.\n+     * \n+     * @param key  the key convert\n+     * @return the converted key\n+     */\n+    @Override\n+    protected Object convertKey(final Object key) {\n+        if (key != null) {\n+            final char[] chars = key.toString().toCharArray();\n+            for (int i = chars.length - 1; i >= 0; i--) {\n+                chars[i] = Character.toLowerCase(Character.toUpperCase(chars[i]));\n+            }\n+            return new String(chars);\n+        }\n+        return AbstractHashedMap.NULL;\n+    }   \n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public CaseInsensitiveMap<K, V> clone() {\n+        return (CaseInsensitiveMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+ \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/CompositeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.Serializable;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.CompositeSet;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.collection.CompositeCollection;\n+\n+/**\n+ * Decorates a map of other maps to provide a single unified view.\n+ * <p>\n+ * Changes made to this map will actually be made on the decorated map.\n+ * Add and remove operations require the use of a pluggable strategy. If no\n+ * strategy is provided then add and remove are unsupported.\n+ * <p>\n+ * <strong>Note that CompositeMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CompositeMap<K, V> extends AbstractIterableMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -6096931280583808322L;\n+\n+    /** Array of all maps in the composite */\n+    private Map<K, V>[] composite;\n+\n+    /** Handle mutation operations */\n+    private MapMutator<K, V> mutator;\n+\n+    /**\n+     * Create a new, empty, CompositeMap.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap() {\n+        this(new Map[] {}, null);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap with two composited Map instances.\n+     *\n+     * @param one  the first Map to be composited\n+     * @param two  the second Map to be composited\n+     * @throws IllegalArgumentException if there is a key collision\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(final Map<K, V> one, final Map<K, V> two) {\n+        this(new Map[] { one, two }, null);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap with two composited Map instances.\n+     *\n+     * @param one  the first Map to be composited\n+     * @param two  the second Map to be composited\n+     * @param mutator  MapMutator to be used for mutation operations\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(final Map<K, V> one, final Map<K, V> two, final MapMutator<K, V> mutator) {\n+        this(new Map[] { one, two }, mutator);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap which composites all of the Map instances in the\n+     * argument. It copies the argument array, it does not use it directly.\n+     *\n+     * @param composite  the Maps to be composited\n+     * @throws IllegalArgumentException if there is a key collision\n+     */\n+    public CompositeMap(final Map<K, V>... composite) {\n+        this(composite, null);\n+    }\n+\n+    /**\n+     * Create a new CompositeMap which composites all of the Map instances in the\n+     * argument. It copies the argument array, it does not use it directly.\n+     *\n+     * @param composite  Maps to be composited\n+     * @param mutator  MapMutator to be used for mutation operations\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(final Map<K, V>[] composite, final MapMutator<K, V> mutator) {\n+        this.mutator = mutator;\n+        this.composite = new Map[0];\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            this.addComposited(composite[i]);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify the MapMutator to be used by mutation operations.\n+     *\n+     * @param mutator  the MapMutator to be used for mutation delegation\n+     */\n+    public void setMutator(final MapMutator<K, V> mutator) {\n+        this.mutator = mutator;\n+    }\n+\n+    /**\n+     * Add an additional Map to the composite.\n+     *\n+     * @param map  the Map to be added to the composite\n+     * @throws IllegalArgumentException if there is a key collision and there is no\n+     *         MapMutator set to handle it.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized void addComposited(final Map<K, V> map) throws IllegalArgumentException {\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            final Collection<K> intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n+            if (intersect.size() != 0) {\n+                if (this.mutator == null) {\n+                    throw new IllegalArgumentException(\"Key collision adding Map to CompositeMap\");\n+                }\n+                this.mutator.resolveCollision(this, this.composite[i], map, intersect);\n+            }\n+        }\n+        final Map<K, V>[] temp = new Map[this.composite.length + 1];\n+        System.arraycopy(this.composite, 0, temp, 0, this.composite.length);\n+        temp[temp.length - 1] = map;\n+        this.composite = temp;\n+    }\n+\n+    /**\n+     * Remove a Map from the composite.\n+     *\n+     * @param map  the Map to be removed from the composite\n+     * @return The removed Map or <code>null</code> if map is not in the composite\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized Map<K, V> removeComposited(final Map<K, V> map) {\n+        final int size = this.composite.length;\n+        for (int i = 0; i < size; ++i) {\n+            if (this.composite[i].equals(map)) {\n+                final Map<K, V>[] temp = new Map[size - 1];\n+                System.arraycopy(this.composite, 0, temp, 0, i);\n+                System.arraycopy(this.composite, i + 1, temp, i, size - i - 1);\n+                this.composite = temp;\n+                return map;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calls <code>clear()</code> on all composited Maps.\n+     *\n+     * @throws UnsupportedOperationException if any of the composited Maps do not support clear()\n+     */\n+    public void clear() {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            this.composite[i].clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains a mapping for the specified\n+     * key.  More formally, returns <tt>true</tt> if and only if\n+     * this map contains at a mapping for a key <tt>k</tt> such that\n+     * <tt>(key==null ? k==null : key.equals(k))</tt>.  (There can be\n+     * at most one such mapping.)\n+     *\n+     * @param key  key whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map contains a mapping for the specified\n+     *         key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     *         this map (optional).\n+     * @throws NullPointerException if the key is <tt>null</tt> and this map\n+     *            does not not permit <tt>null</tt> keys (optional).\n+     */\n+    public boolean containsKey(final Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map maps one or more keys to the\n+     * specified value.  More formally, returns <tt>true</tt> if and only if\n+     * this map contains at least one mapping to a value <tt>v</tt> such that\n+     * <tt>(value==null ? v==null : value.equals(v))</tt>.  This operation\n+     * will probably require time linear in the map size for most\n+     * implementations of the <tt>Map</tt> interface.\n+     *\n+     * @param value value whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map maps one or more keys to the\n+     *         specified value.\n+     * @throws ClassCastException if the value is of an inappropriate type for\n+     *         this map (optional).\n+     * @throws NullPointerException if the value is <tt>null</tt> and this map\n+     *            does not not permit <tt>null</tt> values (optional).\n+     */\n+    public boolean containsValue(final Object value) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsValue(value)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns a set view of the mappings contained in this map.  Each element\n+     * in the returned set is a <code>Map.Entry</code>.  The set is backed by the\n+     * map, so changes to the map are reflected in the set, and vice-versa.\n+     * If the map is modified while an iteration over the set is in progress,\n+     * the results of the iteration are undefined.  The set supports element\n+     * removal, which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n+     * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not support\n+     * the <tt>add</tt> or <tt>addAll</tt> operations.\n+     * <p>\n+     * This implementation returns a <code>CompositeSet</code> which\n+     * composites the entry sets from all of the composited maps.\n+     *\n+     * @see CompositeSet\n+     * @return a set view of the mappings contained in this map.\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final CompositeSet<Map.Entry<K, V>> entries = new CompositeSet<Map.Entry<K,V>>();\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            entries.addComposited(composite[i].entrySet());\n+        }\n+        return entries;\n+    }\n+\n+    /**\n+     * Returns the value to which this map maps the specified key.  Returns\n+     * <tt>null</tt> if the map contains no mapping for this key.  A return\n+     * value of <tt>null</tt> does not <i>necessarily</i> indicate that the\n+     * map contains no mapping for the key; it's also possible that the map\n+     * explicitly maps the key to <tt>null</tt>.  The <tt>containsKey</tt>\n+     * operation may be used to distinguish these two cases.\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * <tt>k</tt> to a value <tt>v</tt> such that <tt>(key==null ? k==null :\n+     * key.equals(k))</tt>, then this method returns <tt>v</tt>; otherwise\n+     * it returns <tt>null</tt>.  (There can be at most one such mapping.)\n+     *\n+     * @param key key whose associated value is to be returned.\n+     * @return the value to which this map maps the specified key, or\n+     *         <tt>null</tt> if the map contains no mapping for this key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     *         this map (optional).\n+     * @throws NullPointerException key is <tt>null</tt> and this map does not\n+     *         not permit <tt>null</tt> keys (optional).\n+     *\n+     * @see #containsKey(Object)\n+     */\n+    public V get(final Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) {\n+                return this.composite[i].get(key);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains no key-value mappings.\n+     *\n+     * @return <tt>true</tt> if this map contains no key-value mappings.\n+     */\n+    public boolean isEmpty() {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (!this.composite[i].isEmpty()) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns a set view of the keys contained in this map.  The set is\n+     * backed by the map, so changes to the map are reflected in the set, and\n+     * vice-versa.  If the map is modified while an iteration over the set is\n+     * in progress, the results of the iteration are undefined.  The set\n+     * supports element removal, which removes the corresponding mapping from\n+     * the map, via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,\n+     * <tt>removeAll</tt> <tt>retainAll</tt>, and <tt>clear</tt> operations.\n+     * It does not support the add or <tt>addAll</tt> operations.\n+     * <p>\n+     * This implementation returns a <code>CompositeSet</code> which\n+     * composites the key sets from all of the composited maps.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set<K> keySet() {\n+        final CompositeSet<K> keys = new CompositeSet<K>();\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            keys.addComposited(this.composite[i].keySet());\n+        }\n+        return keys;\n+    }\n+\n+    /**\n+     * Associates the specified value with the specified key in this map\n+     * (optional operation).  If the map previously contained a mapping for\n+     * this key, the old value is replaced by the specified value.  (A map\n+     * <tt>m</tt> is said to contain a mapping for a key <tt>k</tt> if and only\n+     * if {@link #containsKey(Object) m.containsKey(k)} would return\n+     * <tt>true</tt>.))\n+     *\n+     * @param key key with which the specified value is to be associated.\n+     * @param value value to be associated with the specified key.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     *         if there was no mapping for key.  A <tt>null</tt> return can\n+     *         also indicate that the map previously associated <tt>null</tt>\n+     *         with the specified key, if the implementation supports\n+     *         <tt>null</tt> values.\n+     *\n+     * @throws UnsupportedOperationException if no MapMutator has been specified\n+     * @throws ClassCastException if the class of the specified key or value\n+     *            prevents it from being stored in this map.\n+     * @throws IllegalArgumentException if some aspect of this key or value\n+     *            prevents it from being stored in this map.\n+     * @throws NullPointerException this map does not permit <tt>null</tt>\n+     *            keys or values, and the specified key or value is\n+     *            <tt>null</tt>.\n+     */\n+    public V put(final K key, final V value) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\"No mutator specified\");\n+        }\n+        return this.mutator.put(this, this.composite, key, value);\n+    }\n+\n+    /**\n+     * Copies all of the mappings from the specified map to this map\n+     * (optional operation).  The effect of this call is equivalent to that\n+     * of calling {@link #put(Object,Object) put(k, v)} on this map once\n+     * for each mapping from key <tt>k</tt> to value <tt>v</tt> in the\n+     * specified map.  The behavior of this operation is unspecified if the\n+     * specified map is modified while the operation is in progress.\n+     *\n+     * @param map Mappings to be stored in this map.\n+     *\n+     * @throws UnsupportedOperationException if the <tt>putAll</tt> method is\n+     *         not supported by this map.\n+     *\n+     * @throws ClassCastException if the class of a key or value in the\n+     *         specified map prevents it from being stored in this map.\n+     *\n+     * @throws IllegalArgumentException some aspect of a key or value in the\n+     *         specified map prevents it from being stored in this map.\n+     * @throws NullPointerException the specified map is <tt>null</tt>, or if\n+     *         this map does not permit <tt>null</tt> keys or values, and the\n+     *         specified map contains <tt>null</tt> keys or values.\n+     */\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        if (this.mutator == null) {\n+            throw new UnsupportedOperationException(\"No mutator specified\");\n+        }\n+        this.mutator.putAll(this, this.composite, map);\n+    }\n+\n+    /**\n+     * Removes the mapping for this key from this map if it is present\n+     * (optional operation).   More formally, if this map contains a mapping\n+     * from key <tt>k</tt> to value <tt>v</tt> such that\n+     * <code>(key==null ?  k==null : key.equals(k))</code>, that mapping\n+     * is removed.  (The map can contain at most one such mapping.)\n+     *\n+     * <p>Returns the value to which the map previously associated the key, or\n+     * <tt>null</tt> if the map contained no mapping for this key.  (A\n+     * <tt>null</tt> return can also indicate that the map previously\n+     * associated <tt>null</tt> with the specified key if the implementation\n+     * supports <tt>null</tt> values.)  The map will not contain a mapping for\n+     * the specified  key once the call returns.\n+     *\n+     * @param key key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     *         if there was no mapping for key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     *         the composited map (optional).\n+     * @throws NullPointerException if the key is <tt>null</tt> and the composited map\n+     *            does not not permit <tt>null</tt> keys (optional).\n+     * @throws UnsupportedOperationException if the <tt>remove</tt> method is\n+     *         not supported by the composited map containing the key\n+     */\n+    public V remove(final Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) {\n+                return this.composite[i].remove(key);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the number of key-value mappings in this map.  If the\n+     * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns\n+     * <tt>Integer.MAX_VALUE</tt>.\n+     *\n+     * @return the number of key-value mappings in this map.\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            size += this.composite[i].size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Returns a collection view of the values contained in this map.  The\n+     * collection is backed by the map, so changes to the map are reflected in\n+     * the collection, and vice-versa.  If the map is modified while an\n+     * iteration over the collection is in progress, the results of the\n+     * iteration are undefined.  The collection supports element removal,\n+     * which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\n+     * <tt>removeAll</tt>, <tt>retainAll</tt> and <tt>clear</tt> operations.\n+     * It does not support the add or <tt>addAll</tt> operations.\n+     *\n+     * @return a collection view of the values contained in this map.\n+     */\n+    public Collection<V> values() {\n+        final CompositeCollection<V> values = new CompositeCollection<V>();\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            values.addComposited(composite[i].values());\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Checks if this Map equals another as per the Map specification.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if the maps are equal\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj instanceof Map) {\n+            final Map<?, ?> map = (Map<?, ?>) obj;\n+            return this.entrySet().equals(map.entrySet());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets a hash code for the Map as per the Map specification.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        int code = 0;\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n+            code += entry.hashCode();\n+        }\n+        return code;\n+    }\n+\n+    /**\n+     * This interface allows definition for all of the indeterminate\n+     * mutators in a CompositeMap, as well as providing a hook for\n+     * callbacks on key collisions.\n+     */\n+    public static interface MapMutator<K, V> extends Serializable {\n+        /**\n+         * Called when adding a new Composited Map results in a\n+         * key collision.\n+         *\n+         * @param composite  the CompositeMap with the collision\n+         * @param existing  the Map already in the composite which contains the\n+         *        offending key\n+         * @param added  the Map being added\n+         * @param intersect  the intersection of the keysets of the existing and added maps\n+         */\n+        public void resolveCollision(CompositeMap<K, V> composite, Map<K, V> existing,\n+                Map<K, V> added, Collection<K> intersect);\n+\n+        /**\n+         * Called when the CompositeMap.put() method is invoked.\n+         *\n+         * @param map  the CompositeMap which is being modified\n+         * @param composited  array of Maps in the CompositeMap being modified\n+         * @param key  key with which the specified value is to be associated.\n+         * @param value  value to be associated with the specified key.\n+         * @return previous value associated with specified key, or <tt>null</tt>\n+         *         if there was no mapping for key.  A <tt>null</tt> return can\n+         *         also indicate that the map previously associated <tt>null</tt>\n+         *         with the specified key, if the implementation supports\n+         *         <tt>null</tt> values.\n+         *\n+         * @throws UnsupportedOperationException if not defined\n+         * @throws ClassCastException if the class of the specified key or value\n+         *            prevents it from being stored in this map.\n+         * @throws IllegalArgumentException if some aspect of this key or value\n+         *            prevents it from being stored in this map.\n+         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         *            keys or values, and the specified key or value is\n+         *            <tt>null</tt>.\n+         */\n+        public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value);\n+\n+        /**\n+         * Called when the CompositeMap.putAll() method is invoked.\n+         *\n+         * @param map  the CompositeMap which is being modified\n+         * @param composited  array of Maps in the CompositeMap being modified\n+         * @param mapToAdd  Mappings to be stored in this CompositeMap\n+         *\n+         * @throws UnsupportedOperationException if not defined\n+         * @throws ClassCastException if the class of the specified key or value\n+         *            prevents it from being stored in this map.\n+         * @throws IllegalArgumentException if some aspect of this key or value\n+         *            prevents it from being stored in this map.\n+         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         *            keys or values, and the specified key or value is\n+         *            <tt>null</tt>.\n+         */\n+        public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited,\n+                Map<? extends K, ? extends V> mapToAdd);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.functors.ConstantTransformer;\n+import org.apache.commons.collections4.functors.FactoryTransformer;\n+\n+/**\n+ * Decorates another <code>Map</code> returning a default value if the map\n+ * does not contain the requested key.\n+ * <p>\n+ * When the {@link #get(Object)} method is called with a key that does not\n+ * exist in the map, this map will return the default value specified in\n+ * the constructor/factory. Only the get method is altered, so the\n+ * {@link Map#containsKey(Object)} can be used to determine if a key really\n+ * is in the map or not.\n+ * <p>\n+ * The defaulted value is not added to the map.\n+ * Compare this behaviour with {@link LazyMap}, which does add the value\n+ * to the map (via a Transformer).\n+ * <p>\n+ * For instance:\n+ * <pre>\n+ * Map map = new DefaultedMap(\"NULL\");\n+ * Object obj = map.get(\"Surname\");\n+ * // obj == \"NULL\"\n+ * </pre>\n+ * After the above code is executed the map is still empty.\n+ * <p>\n+ * <strong>Note that DefaultedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ *\n+ * @see LazyMap\n+ */\n+public class DefaultedMap<K, V> extends AbstractMapDecorator<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 19698628745827L;\n+\n+    /** The transformer to use if the map does not contain a key */\n+    private final Transformer<? super K, ? extends V> value;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Factory method to create a defaulting map.\n+     * <p>\n+     * The value specified is returned when a missing key is found.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param defaultValue  the default value to return when the key is not found\n+     * @return a new defaulting map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n+        return new DefaultedMap<K, V>(map, ConstantTransformer.constantTransformer(defaultValue));\n+    }\n+\n+    /**\n+     * Factory method to create a defaulting map.\n+     * <p>\n+     * The factory specified is called when a missing key is found.\n+     * The result will be returned as the result of the map get(key) method.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use to create entries, must not be null\n+     * @return a new defaulting map\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        return new DefaultedMap<K, V>(map, FactoryTransformer.factoryTransformer(factory));\n+    }\n+\n+    /**\n+     * Factory method to create a defaulting map.\n+     * <p>\n+     * The transformer specified is called when a missing key is found.\n+     * The key is passed to the transformer as the input, and the result\n+     * will be returned as the result of the map get(key) method.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param transformer  the transformer to use as a factory to create entries, must not be null\n+     * @return a new defaulting map\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map,\n+                                                final Transformer<? super K, ? extends V> transformer) {\n+        if (transformer == null) {\n+           throw new IllegalArgumentException(\"Transformer must not be null\");\n+       }\n+       return new DefaultedMap<K, V>(map, transformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty <code>DefaultedMap</code> that decorates\n+     * a <code>HashMap</code>.\n+     * <p>\n+     * The object passed in will be returned by the map whenever an\n+     * unknown key is requested.\n+     * \n+     * @param defaultValue  the default value to return when the key is not found\n+     */\n+    public DefaultedMap(final V defaultValue) {\n+        this(ConstantTransformer.constantTransformer(defaultValue));\n+    }\n+\n+    /**\n+     * Constructs a new empty <code>DefaultedMap</code> that decorates a <code>HashMap</code>.\n+     *\n+     * @param defaultValueTransformer transformer to use to generate missing values.\n+     */\n+    public DefaultedMap(final Transformer<? super K, ? extends V> defaultValueTransformer) {\n+        this(new HashMap<K, V>(), defaultValueTransformer);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param defaultValueTransformer  the value transformer to use\n+     * @throws IllegalArgumentException if map or transformer is null\n+     */\n+    protected DefaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> defaultValueTransformer) {\n+        super(map);\n+        if (defaultValueTransformer == null) {\n+            throw new IllegalArgumentException(\"transformer must not be null\");\n+        }\n+        this.value = defaultValueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V get(final Object key) {\n+        // create value for key if key is not currently in the map\n+        if (map.containsKey(key) == false) {\n+            return value.transform((K) key);\n+        }\n+        return map.get(key);\n+    }\n+\n+    // no need to wrap keySet, entrySet or values as they are views of\n+    // existing map entries - you can't do a map-style get on them.\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/EntrySetToMapIteratorAdapter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+\n+/**\n+ * Adapts a Map entrySet to the MapIterator interface.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class EntrySetToMapIteratorAdapter<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+    /** The adapted Map entry Set. */\n+    protected Set<Map.Entry<K, V>> entrySet;\n+\n+    /** The resettable iterator in use. */\n+    protected transient Iterator<Map.Entry<K, V>> iterator;\n+\n+    /** The currently positioned Map entry. */\n+    protected transient Map.Entry<K, V> entry;\n+\n+    /**\n+     * Create a new EntrySetToMapIteratorAdapter.\n+     * @param entrySet  the entrySet to adapt\n+     */\n+    public EntrySetToMapIteratorAdapter(final Set<Map.Entry<K, V>> entrySet) {\n+        this.entrySet = entrySet;\n+        reset();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K getKey() {\n+        return current().getKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V getValue() {\n+        return current().getValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V setValue(final V value) {\n+        return current().setValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean hasNext() {\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K next() {\n+        entry = iterator.next();\n+        return getKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized void reset() {\n+        iterator = entrySet.iterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void remove() {\n+        iterator.remove();\n+        entry = null;\n+    }\n+\n+    /**\n+     * Get the currently active entry.\n+     * @return Map.Entry<K, V>\n+     */\n+    protected synchronized Map.Entry<K, V> current() { \n+        if (entry == null) {\n+            throw new IllegalStateException();\n+        }\n+        return entry;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.BoundedMap;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+\n+/**\n+ * Decorates another <code>Map</code> to fix the size, preventing add/remove.\n+ * <p>\n+ * Any action that would change the size of the map is disallowed.\n+ * The put method is allowed to change the value associated with an existing\n+ * key however.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is\n+ * thrown. If trying to put a new mapping into the map, an \n+ * IllegalArgumentException is thrown. This is because the put method can \n+ * succeed if the mapping's key already exists in the map, so the put method\n+ * is not always unsupported.\n+ * <p>\n+ * <strong>Note that FixedSizeMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedSizeMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements Map<K, V>, BoundedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7450927208116179316L;\n+\n+    /**\n+     * Factory method to create a fixed size map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return a new fixed size map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n+        return new FixedSizeMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected FixedSizeMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(final K key, final V value) {\n+        if (map.containsKey(key) == false) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+        }\n+        return map.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        for (final K key : mapToCopy.keySet()) {\n+            if (!containsKey(key)) {\n+                throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+            }\n+        }\n+        map.putAll(mapToCopy);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Set<Map.Entry<K, V>> set = map.entrySet();\n+        // unmodifiable set will still allow modification via Map.Entry objects\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        final Set<K> set = map.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        final Collection<V> coll = map.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    public int maxSize() {\n+        return size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.BoundedMap;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+\n+/**\n+ * Decorates another <code>SortedMap</code> to fix the size blocking add/remove.\n+ * <p>\n+ * Any action that would change the size of the map is disallowed.\n+ * The put method is allowed to change the value associated with an existing\n+ * key however.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is\n+ * thrown. If trying to put a new mapping into the map, an \n+ * IllegalArgumentException is thrown. This is because the put method can \n+ * succeed if the mapping's key already exists in the map, so the put method\n+ * is not always unsupported.\n+ * <p>\n+ * <strong>Note that FixedSizeSortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedSizeSortedMap<K, V>\n+        extends AbstractSortedMapDecorator<K, V>\n+        implements SortedMap<K, V>, BoundedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3126019624511683653L;\n+\n+    /**\n+     * Factory method to create a fixed size sorted map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return a new fixed size sorted map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n+        return new FixedSizeSortedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected FixedSizeSortedMap(final SortedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(final K key, final V value) {\n+        if (map.containsKey(key) == false) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+        }\n+        return map.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        if (CollectionUtils.isSubCollection(mapToCopy.keySet(), keySet())) {\n+            throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size\");\n+        }\n+        map.putAll(mapToCopy);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException(\"Map is fixed size\");\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return UnmodifiableSet.unmodifiableSet(map.entrySet());\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return UnmodifiableSet.unmodifiableSet(map.keySet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        return UnmodifiableCollection.unmodifiableCollection(map.values());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().subMap(fromKey, toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().headMap(toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return new FixedSizeSortedMap<K, V>(getSortedMap().tailMap(fromKey));\n+    }\n+\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    public int maxSize() {\n+        return size();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/Flat3Map.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.EmptyMapIterator;\n+\n+/**\n+ * A <code>Map</code> implementation that stores data in simple fields until\n+ * the size is greater than 3.\n+ * <p>\n+ * This map is designed for performance and can outstrip HashMap.\n+ * It also has good garbage collection characteristics.\n+ * <ul>\n+ * <li>Optimised for operation at size 3 or less.\n+ * <li>Still works well once size 3 exceeded.\n+ * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n+ * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n+ * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n+ * </ul>\n+ * The design uses two distinct modes of operation - flat and delegate.\n+ * While the map is size 3 or less, operations map straight onto fields using\n+ * switch statements. Once size 4 is reached, the map switches to delegate mode\n+ * and only switches back when cleared. In delegate mode, all operations are\n+ * forwarded straight to a HashMap resulting in the 5% performance loss.\n+ * <p>\n+ * The performance gains on puts are due to not needing to create a Map Entry\n+ * object. This is a large saving not only in performance but in garbage collection.\n+ * <p>\n+ * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n+ * This is because it contains no complex objects or arrays which slow the progress.\n+ * <p>\n+ * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n+ * <p>\n+ * <strong>Note that Flat3Map is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class Flat3Map<K, V> implements IterableMap<K, V>, Serializable, Cloneable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -6701087419741928296L;\n+\n+    /** The size of the map, used while in flat mode */\n+    private transient int size;\n+    /** Hash, used while in flat mode */\n+    private transient int hash1;\n+    /** Hash, used while in flat mode */\n+    private transient int hash2;\n+    /** Hash, used while in flat mode */\n+    private transient int hash3;\n+    /** Key, used while in flat mode */\n+    private transient K key1;\n+    /** Key, used while in flat mode */\n+    private transient K key2;\n+    /** Key, used while in flat mode */\n+    private transient K key3;\n+    /** Value, used while in flat mode */\n+    private transient V value1;\n+    /** Value, used while in flat mode */\n+    private transient V value2;\n+    /** Value, used while in flat mode */\n+    private transient V value3;\n+    /** Map, used while in delegate mode */\n+    private transient AbstractHashedMap<K, V> delegateMap;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public Flat3Map() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public Flat3Map(final Map<? extends K, ? extends V> map) {\n+        super();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(final Object key) {\n+        if (delegateMap != null) {\n+            return delegateMap.get(key);\n+        }\n+        if (key == null) {\n+            switch (size) {\n+                // drop through\n+                case 3:\n+                    if (key3 == null) {\n+                        return value3;\n+                    }\n+                case 2:\n+                    if (key2 == null) {\n+                        return value2;\n+                    }\n+                case 1:\n+                    if (key1 == null) {\n+                        return value1;\n+                    }\n+            }\n+        } else {\n+            if (size > 0) {\n+                final int hashCode = key.hashCode();\n+                switch (size) {\n+                    // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            return value3;\n+                        }\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            return value2;\n+                        }\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            return value1;\n+                        }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map.\n+     *\n+     * @return the size\n+     */\n+    public int size() {\n+        if (delegateMap != null) {\n+            return delegateMap.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     *\n+     * @return true if the map is currently size zero\n+     */\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     *\n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(final Object key) {\n+        if (delegateMap != null) {\n+            return delegateMap.containsKey(key);\n+        }\n+        if (key == null) {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (key3 == null) {\n+                        return true;\n+                    }\n+                case 2:\n+                    if (key2 == null) {\n+                        return true;\n+                    }\n+                case 1:\n+                    if (key1 == null) {\n+                        return true;\n+                    }\n+            }\n+        } else {\n+            if (size > 0) {\n+                final int hashCode = key.hashCode();\n+                switch (size) {  // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            return true;\n+                        }\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            return true;\n+                        }\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            return true;\n+                        }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsValue(final Object value) {\n+        if (delegateMap != null) {\n+            return delegateMap.containsValue(value);\n+        }\n+        if (value == null) {  // drop through\n+            switch (size) {\n+                case 3:\n+                    if (value3 == null) {\n+                        return true;\n+                    }\n+                case 2:\n+                    if (value2 == null) {\n+                        return true;\n+                    }\n+                case 1:\n+                    if (value1 == null) {\n+                        return true;\n+                    }\n+            }\n+        } else {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (value.equals(value3)) {\n+                        return true;\n+                    }\n+                case 2:\n+                    if (value.equals(value2)) {\n+                        return true;\n+                    }\n+                case 1:\n+                    if (value.equals(value1)) {\n+                        return true;\n+                    }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map.\n+     *\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    public V put(final K key, final V value) {\n+        if (delegateMap != null) {\n+            return delegateMap.put(key, value);\n+        }\n+        // change existing mapping\n+        if (key == null) {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (key3 == null) {\n+                        final V old = value3;\n+                        value3 = value;\n+                        return old;\n+                    }\n+                case 2:\n+                    if (key2 == null) {\n+                        final V old = value2;\n+                        value2 = value;\n+                        return old;\n+                    }\n+                case 1:\n+                    if (key1 == null) {\n+                        final V old = value1;\n+                        value1 = value;\n+                        return old;\n+                    }\n+            }\n+        } else {\n+            if (size > 0) {\n+                final int hashCode = key.hashCode();\n+                switch (size) {  // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            final V old = value3;\n+                            value3 = value;\n+                            return old;\n+                        }\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            final V old = value2;\n+                            value2 = value;\n+                            return old;\n+                        }\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            final V old = value1;\n+                            value1 = value;\n+                            return old;\n+                        }\n+                }\n+            }\n+        }\n+\n+        // add new mapping\n+        switch (size) {\n+            default:\n+                convertToMap();\n+                delegateMap.put(key, value);\n+                return null;\n+            case 2:\n+                hash3 = key == null ? 0 : key.hashCode();\n+                key3 = key;\n+                value3 = value;\n+                break;\n+            case 1:\n+                hash2 = key == null ? 0 : key.hashCode();\n+                key2 = key;\n+                value2 = value;\n+                break;\n+            case 0:\n+                hash1 = key == null ? 0 : key.hashCode();\n+                key1 = key;\n+                value1 = value;\n+                break;\n+        }\n+        size++;\n+        return null;\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     *\n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        final int size = map.size();\n+        if (size == 0) {\n+            return;\n+        }\n+        if (delegateMap != null) {\n+            delegateMap.putAll(map);\n+            return;\n+        }\n+        if (size < 4) {\n+            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        } else {\n+            convertToMap();\n+            delegateMap.putAll(map);\n+        }\n+    }\n+\n+    /**\n+     * Converts the flat map data to a map.\n+     */\n+    private void convertToMap() {\n+        delegateMap = createDelegateMap();\n+        switch (size) {  // drop through\n+            case 3:\n+                delegateMap.put(key3, value3);\n+            case 2:\n+                delegateMap.put(key2, value2);\n+            case 1:\n+                delegateMap.put(key1, value1);\n+        }\n+\n+        size = 0;\n+        hash1 = hash2 = hash3 = 0;\n+        key1 = key2 = key3 = null;\n+        value1 = value2 = value3 = null;\n+    }\n+\n+    /**\n+     * Create an instance of the map used for storage when in delegation mode.\n+     * <p>\n+     * This can be overridden by subclasses to provide a different map implementation.\n+     * Not every AbstractHashedMap is suitable, identity and reference based maps\n+     * would be poor choices.\n+     *\n+     * @return a new AbstractHashedMap or subclass\n+     * @since 3.1\n+     */\n+    protected AbstractHashedMap<K, V> createDelegateMap() {\n+        return new HashedMap<K, V>();\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     *\n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(final Object key) {\n+        if (delegateMap != null) {\n+            return delegateMap.remove(key);\n+        }\n+        if (size == 0) {\n+            return null;\n+        }\n+        if (key == null) {\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (key3 == null) {\n+                        final V old = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n+                        return old;\n+                    }\n+                    if (key2 == null) {\n+                        final V old = value2;\n+                        hash2 = hash3;\n+                        key2 = key3;\n+                        value2 = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n+                        return old;\n+                    }\n+                    if (key1 == null) {\n+                        final V old = value1;\n+                        hash1 = hash3;\n+                        key1 = key3;\n+                        value1 = value3;\n+                        hash3 = 0;\n+                        key3 = null;\n+                        value3 = null;\n+                        size = 2;\n+                        return old;\n+                    }\n+                    return null;\n+                case 2:\n+                    if (key2 == null) {\n+                        final V old = value2;\n+                        hash2 = 0;\n+                        key2 = null;\n+                        value2 = null;\n+                        size = 1;\n+                        return old;\n+                    }\n+                    if (key1 == null) {\n+                        final V old = value1;\n+                        hash1 = hash2;\n+                        key1 = key2;\n+                        value1 = value2;\n+                        hash2 = 0;\n+                        key2 = null;\n+                        value2 = null;\n+                        size = 1;\n+                        return old;\n+                    }\n+                    return null;\n+                case 1:\n+                    if (key1 == null) {\n+                        final V old = value1;\n+                        hash1 = 0;\n+                        key1 = null;\n+                        value1 = null;\n+                        size = 0;\n+                        return old;\n+                    }\n+            }\n+        } else {\n+            if (size > 0) {\n+                final int hashCode = key.hashCode();\n+                switch (size) {  // drop through\n+                    case 3:\n+                        if (hash3 == hashCode && key.equals(key3)) {\n+                            final V old = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n+                            return old;\n+                        }\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            final V old = value2;\n+                            hash2 = hash3;\n+                            key2 = key3;\n+                            value2 = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n+                            return old;\n+                        }\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            final V old = value1;\n+                            hash1 = hash3;\n+                            key1 = key3;\n+                            value1 = value3;\n+                            hash3 = 0;\n+                            key3 = null;\n+                            value3 = null;\n+                            size = 2;\n+                            return old;\n+                        }\n+                        return null;\n+                    case 2:\n+                        if (hash2 == hashCode && key.equals(key2)) {\n+                            final V old = value2;\n+                            hash2 = 0;\n+                            key2 = null;\n+                            value2 = null;\n+                            size = 1;\n+                            return old;\n+                        }\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            final V old = value1;\n+                            hash1 = hash2;\n+                            key1 = key2;\n+                            value1 = value2;\n+                            hash2 = 0;\n+                            key2 = null;\n+                            value2 = null;\n+                            size = 1;\n+                            return old;\n+                        }\n+                        return null;\n+                    case 1:\n+                        if (hash1 == hashCode && key.equals(key1)) {\n+                            final V old = value1;\n+                            hash1 = 0;\n+                            key1 = null;\n+                            value1 = null;\n+                            size = 0;\n+                            return old;\n+                        }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    public void clear() {\n+        if (delegateMap != null) {\n+            delegateMap.clear();  // should aid gc\n+            delegateMap = null;  // switch back to flat mode\n+        } else {\n+            size = 0;\n+            hash1 = hash2 = hash3 = 0;\n+            key1 = key2 = key3 = null;\n+            value1 = value2 = value3 = null;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Map Entry object.\n+     *\n+     * @return the map iterator\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        if (delegateMap != null) {\n+            return delegateMap.mapIterator();\n+        }\n+        if (size == 0) {\n+            return EmptyMapIterator.<K, V>emptyMapIterator();\n+        }\n+        return new FlatMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * FlatMapIterator\n+     */\n+    static class FlatMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n+        private final Flat3Map<K, V> parent;\n+        private int nextIndex = 0;\n+        private boolean canRemove = false;\n+\n+        FlatMapIterator(final Flat3Map<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return nextIndex < parent.size;\n+        }\n+\n+        public K next() {\n+            if (hasNext() == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            canRemove = true;\n+            nextIndex++;\n+            return getKey();\n+        }\n+\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            parent.remove(getKey());\n+            nextIndex--;\n+            canRemove = false;\n+        }\n+\n+        public K getKey() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.key3;\n+                case 2:\n+                    return parent.key2;\n+                case 1:\n+                    return parent.key1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V getValue() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.value3;\n+                case 2:\n+                    return parent.value2;\n+                case 1:\n+                    return parent.value1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V setValue(final V value) {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            final V old = getValue();\n+            switch (nextIndex) {\n+                case 3:\n+                    parent.value3 = value;\n+                    break;\n+                case 2:\n+                    parent.value2 = value;\n+                    break;\n+                case 1:\n+                    parent.value1 = value;\n+                    break;\n+            }\n+            return old;\n+        }\n+\n+        public void reset() {\n+            nextIndex = 0;\n+            canRemove = false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (canRemove) {\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made to the view affect this map.\n+     * The Map Entry is not an independent object and changes as the\n+     * iterator progresses.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     *\n+     * @return the entrySet view\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (delegateMap != null) {\n+            return delegateMap.entrySet();\n+        }\n+        return new EntrySet<K, V>(this);\n+    }\n+\n+    /**\n+     * EntrySet\n+     */\n+    static class EntrySet<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        private final Flat3Map<K, V> parent;\n+\n+        EntrySet(final Flat3Map<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final Object key = entry.getKey();\n+            final boolean result = parent.containsKey(key);\n+            parent.remove(key);\n+            return result;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.entrySet().iterator();\n+            }\n+            if (parent.size() == 0) {\n+                return EmptyIterator.<Map.Entry<K, V>>emptyIterator();\n+            }\n+            return new EntrySetIterator<K, V>(parent);\n+        }\n+    }\n+\n+    static abstract class EntryIterator<K, V> implements Map.Entry<K, V> {\n+        private final Flat3Map<K, V> parent;\n+        private int nextIndex = 0;\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Create a new Flat3Map.EntryIterator.\n+         */\n+        public EntryIterator(final Flat3Map<K, V> parent) {\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return nextIndex < parent.size;\n+        }\n+\n+        public Map.Entry<K, V> nextEntry() {\n+            if (hasNext() == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            canRemove = true;\n+            nextIndex++;\n+            return this;\n+        }\n+\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            parent.remove(getKey());\n+            nextIndex--;\n+            canRemove = false;\n+        }\n+\n+        public K getKey() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.key3;\n+                case 2:\n+                    return parent.key2;\n+                case 1:\n+                    return parent.key1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V getValue() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            switch (nextIndex) {\n+                case 3:\n+                    return parent.value3;\n+                case 2:\n+                    return parent.value2;\n+                case 1:\n+                    return parent.value1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public V setValue(final V value) {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            final V old = getValue();\n+            switch (nextIndex) {\n+                case 3:\n+                    parent.value3 = value;\n+                    break;\n+                case 2:\n+                    parent.value2 = value;\n+                    break;\n+                case 1:\n+                    parent.value1 = value;\n+                    break;\n+            }\n+            return old;\n+        }\n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator<K, V> extends EntryIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+        EntrySetIterator(final Flat3Map<K, V> parent) {\n+            super(parent);\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (canRemove == false) {\n+                return false;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            final Object key = getKey();\n+            final Object value = getValue();\n+            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n+                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            if (canRemove == false) {\n+                return 0;\n+            }\n+            final Object key = getKey();\n+            final Object value = getValue();\n+            return (key == null ? 0 : key.hashCode()) ^\n+                   (value == null ? 0 : value.hashCode());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (canRemove) {\n+                return getKey() + \"=\" + getValue();\n+            }\n+            return \"\";\n+        }\n+    }\n+\n+    /**\n+     * Gets the keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     *\n+     * @return the keySet view\n+     */\n+    public Set<K> keySet() {\n+        if (delegateMap != null) {\n+            return delegateMap.keySet();\n+        }\n+        return new KeySet<K>(this);\n+    }\n+\n+    /**\n+     * KeySet\n+     */\n+    static class KeySet<K> extends AbstractSet<K> {\n+        private final Flat3Map<K, ?> parent;\n+\n+        KeySet(final Flat3Map<K, ?> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object key) {\n+            return parent.containsKey(key);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object key) {\n+            final boolean result = parent.containsKey(key);\n+            parent.remove(key);\n+            return result;\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.keySet().iterator();\n+            }\n+            if (parent.size() == 0) {\n+                return EmptyIterator.<K>emptyIterator();\n+            }\n+            return new KeySetIterator<K>(parent);\n+        }\n+    }\n+\n+    /**\n+     * KeySetIterator\n+     */\n+    static class KeySetIterator<K> extends EntryIterator<K, Object> implements Iterator<K>{\n+\n+        @SuppressWarnings(\"unchecked\")\n+        KeySetIterator(final Flat3Map<K, ?> parent) {\n+            super((Flat3Map<K, Object>) parent);\n+        }\n+\n+        public K next() {\n+            nextEntry();\n+            return getKey();\n+        }\n+    }\n+\n+    /**\n+     * Gets the values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     *\n+     * @return the values view\n+     */\n+    public Collection<V> values() {\n+        if (delegateMap != null) {\n+            return delegateMap.values();\n+        }\n+        return new Values<V>(this);\n+    }\n+\n+    /**\n+     * Values\n+     */\n+    static class Values<V> extends AbstractCollection<V> {\n+        private final Flat3Map<?, V> parent;\n+\n+        Values(final Flat3Map<?, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object value) {\n+            return parent.containsValue(value);\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            if (parent.delegateMap != null) {\n+                return parent.delegateMap.values().iterator();\n+            }\n+            if (parent.size() == 0) {\n+                return EmptyIterator.<V>emptyIterator();\n+            }\n+            return new ValuesIterator<V>(parent);\n+        }\n+    }\n+\n+    /**\n+     * ValuesIterator\n+     */\n+    static class ValuesIterator<V> extends EntryIterator<Object, V> implements Iterator<V> {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ValuesIterator(final Flat3Map<?, V> parent) {\n+            super((Flat3Map<Object, V>) parent);\n+        }\n+\n+        public V next() {\n+            nextEntry();\n+            return getValue();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(size());\n+        for (final MapIterator<?, ?> it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());  // key\n+            out.writeObject(it.getValue());  // value\n+        }\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        final int count = in.readInt();\n+        if (count > 3) {\n+            delegateMap = createDelegateMap();\n+        }\n+        for (int i = count; i > 0; i--) {\n+            put((K) in.readObject(), (V) in.readObject());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     * @since 3.1\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Flat3Map<K, V> clone() {\n+        try {\n+            final Flat3Map<K, V> cloned = (Flat3Map<K, V>) super.clone();\n+            if (cloned.delegateMap != null) {\n+                cloned.delegateMap = cloned.delegateMap.clone();\n+            }\n+            return cloned;\n+        } catch (final CloneNotSupportedException ex) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (delegateMap != null) {\n+            return delegateMap.equals(obj);\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        final Map<?, ?> other = (Map<?, ?>) obj;\n+        if (size != other.size()) {\n+            return false;\n+        }\n+        if (size > 0) {\n+            Object otherValue = null;\n+            switch (size) {  // drop through\n+                case 3:\n+                    if (other.containsKey(key3) == false) {\n+                        return false;\n+                    }\n+                    otherValue = other.get(key3);\n+                    if (value3 == null ? otherValue != null : !value3.equals(otherValue)) {\n+                        return false;\n+                    }\n+                case 2:\n+                    if (other.containsKey(key2) == false) {\n+                        return false;\n+                    }\n+                    otherValue = other.get(key2);\n+                    if (value2 == null ? otherValue != null : !value2.equals(otherValue)) {\n+                        return false;\n+                    }\n+                case 1:\n+                    if (other.containsKey(key1) == false) {\n+                        return false;\n+                    }\n+                    otherValue = other.get(key1);\n+                    if (value1 == null ? otherValue != null : !value1.equals(otherValue)) {\n+                        return false;\n+                    }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     *\n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (delegateMap != null) {\n+            return delegateMap.hashCode();\n+        }\n+        int total = 0;\n+        switch (size) {  // drop through\n+            case 3:\n+                total += hash3 ^ (value3 == null ? 0 : value3.hashCode());\n+            case 2:\n+                total += hash2 ^ (value2 == null ? 0 : value2.hashCode());\n+            case 1:\n+                total += hash1 ^ (value1 == null ? 0 : value1.hashCode());\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     *\n+     * @return a string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        if (delegateMap != null) {\n+            return delegateMap.toString();\n+        }\n+        if (size == 0) {\n+            return \"{}\";\n+        }\n+        final StringBuilder buf = new StringBuilder(128);\n+        buf.append('{');\n+        switch (size) {  // drop through\n+            case 3:\n+                buf.append(key3 == this ? \"(this Map)\" : key3);\n+                buf.append('=');\n+                buf.append(value3 == this ? \"(this Map)\" : value3);\n+                buf.append(',');\n+            case 2:\n+                buf.append(key2 == this ? \"(this Map)\" : key2);\n+                buf.append('=');\n+                buf.append(value2 == this ? \"(this Map)\" : value2);\n+                buf.append(',');\n+            case 1:\n+                buf.append(key1 == this ? \"(this Map)\" : key1);\n+                buf.append('=');\n+                buf.append(value1 == this ? \"(this Map)\" : value1);\n+        }\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/HashedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+/**\n+ * A <code>Map</code> implementation that is a general purpose alternative\n+ * to <code>HashMap</code>.\n+ * <p>\n+ * This implementation improves on the JDK1.4 HashMap by adding the\n+ * {@link org.apache.commons.collections4.MapIterator MapIterator}\n+ * functionality and many methods for subclassing.\n+ * <p>\n+ * <strong>Note that HashedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class HashedMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -1788199231038721040L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public HashedMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public HashedMap(final int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public HashedMap(final int initialCapacity, final float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public HashedMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public HashedMap<K, V> clone() {\n+        return (HashedMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/LRUMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.BoundedMap;\n+\n+/**\n+ * A <code>Map</code> implementation with a fixed maximum size which removes\n+ * the least recently used entry if an entry is added when full.\n+ * <p>\n+ * The least recently used algorithm works on the get and put operations only.\n+ * Iteration of any kind, including setting the value by iteration, does not\n+ * change the order. Queries such as containsKey and containsValue or access\n+ * via views also do not change the order.\n+ * <p>\n+ * A somewhat subtle ramification of the least recently used\n+ * algorithm is that calls to {@link #get(Object)} stand a very good chance\n+ * of modifying the map's iteration order and thus invalidating any\n+ * iterators currently in use.  It is therefore suggested that iterations\n+ * over an {@link LRUMap} instance access entry values only through a\n+ * {@link org.apache.commons.collections4.MapIterator MapIterator} or {@link #entrySet()} iterator.\n+ * <p>\n+ * The map implements <code>OrderedMap</code> and entries may be queried using\n+ * the bidirectional <code>OrderedMapIterator</code>. The order returned is\n+ * least recently used to most recently used. Iterators from map views can\n+ * also be cast to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * <strong>Note that LRUMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * <code>NullPointerException</code>'s when accessed by concurrent threads.\n+ *\n+ * @since 3.0 (previously in main package v1.0)\n+ * @version $Id$\n+ */\n+public class LRUMap<K, V>\n+        extends AbstractLinkedMap<K, V> implements BoundedMap<K, V>, Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -612114643488955218L;\n+    /** Default maximum size */\n+    protected static final int DEFAULT_MAX_SIZE = 100;\n+\n+    /** Maximum size */\n+    private transient int maxSize;\n+    /** Scan behaviour */\n+    private boolean scanUntilRemovable;\n+\n+    /**\n+     * Constructs a new empty map with a maximum size of 100.\n+     */\n+    public LRUMap() {\n+        this(DEFAULT_MAX_SIZE, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified maximum size.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     */\n+    public LRUMap(final int maxSize) {\n+        this(maxSize, DEFAULT_LOAD_FACTOR);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified maximum size.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @since 3.1\n+     */\n+    public LRUMap(final int maxSize, final boolean scanUntilRemovable) {\n+        this(maxSize, DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param maxSize  the maximum size of the map\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public LRUMap(final int maxSize, final float loadFactor) {\n+        this(maxSize, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param maxSize  the maximum size of the ma\n+     * @param loadFactor  the load factor\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws IllegalArgumentException if the maximum size is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     * @since 3.1\n+     */\n+    public LRUMap(final int maxSize, final float loadFactor, final boolean scanUntilRemovable) {\n+        super(maxSize < 1 ? DEFAULT_CAPACITY : maxSize, loadFactor);\n+        if (maxSize < 1) {\n+            throw new IllegalArgumentException(\"LRUMap max size must be greater than 0\");\n+        }\n+        this.maxSize = maxSize;\n+        this.scanUntilRemovable = scanUntilRemovable;\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p>\n+     * The maximum size is set from the map's size.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     */\n+    public LRUMap(final Map<K, V> map) {\n+        this(map, false);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     * <p/>\n+     * The maximum size is set from the map's size.\n+     *\n+     * @param map  the map to copy\n+     * @param scanUntilRemovable  scan until a removeable entry is found, default false\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @since 3.1\n+     */\n+    public LRUMap(final Map<K, V> map, final boolean scanUntilRemovable) {\n+        this(map.size(), DEFAULT_LOAD_FACTOR, scanUntilRemovable);\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * <p>\n+     * This operation changes the position of the key in the map to the\n+     * most recently used position (first).\n+     *\n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    @Override\n+    public V get(final Object key) {\n+        final LinkEntry<K, V> entry = getEntry(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        moveToMRU(entry);\n+        return entry.getValue();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Moves an entry to the MRU position at the end of the list.\n+     * <p>\n+     * This implementation moves the updated entry to the end of the list.\n+     *\n+     * @param entry  the entry to update\n+     */\n+    protected void moveToMRU(final LinkEntry<K, V> entry) {\n+        if (entry.after != header) {\n+            modCount++;\n+            // remove\n+            if(entry.before == null) {\n+                throw new IllegalStateException(\"Entry.before is null.\" + \n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+            }\n+            entry.before.after = entry.after;\n+            entry.after.before = entry.before;\n+            // add first\n+            entry.after = header;\n+            entry.before = header.before;\n+            header.before.after = entry;\n+            header.before = entry;\n+        } else if (entry == header) {\n+            throw new IllegalStateException(\"Can't move header to MRU\" +\n+                \" (please report this to dev@commons.apache.org)\");\n+        }\n+    }\n+\n+    /**\n+     * Updates an existing key-value mapping.\n+     * <p>\n+     * This implementation moves the updated entry to the top of the list\n+     * using {@link #moveToMRU(AbstractLinkedMap.LinkEntry)}.\n+     *\n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     */\n+    @Override\n+    protected void updateEntry(final HashEntry<K, V> entry, final V newValue) {\n+        moveToMRU((LinkEntry<K, V>) entry);  // handles modCount\n+        entry.setValue(newValue);\n+    }\n+\n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * <p>\n+     * This implementation checks the LRU size and determines whether to\n+     * discard an entry or not using {@link #removeLRU(AbstractLinkedMap.LinkEntry)}.\n+     * <p>\n+     * From Commons Collections 3.1 this method uses {@link #isFull()} rather\n+     * than accessing <code>size</code> and <code>maxSize</code> directly.\n+     * It also handles the scanUntilRemovable functionality.\n+     *\n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    @Override\n+    protected void addMapping(final int hashIndex, final int hashCode, final K key, final V value) {\n+        if (isFull()) {\n+            LinkEntry<K, V> reuse = header.after;\n+            boolean removeLRUEntry = false;\n+            if (scanUntilRemovable) {\n+                while (reuse != header && reuse != null) {\n+                    if (removeLRU(reuse)) {\n+                        removeLRUEntry = true;\n+                        break;\n+                    }\n+                    reuse = reuse.after;\n+                }\n+                if (reuse == null) {\n+                    throw new IllegalStateException(\n+                        \"Entry.after=null, header.after\" + header.after + \" header.before\" + header.before +\n+                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                        \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                        \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+                }\n+            } else {\n+                removeLRUEntry = removeLRU(reuse);\n+            }\n+\n+            if (removeLRUEntry) {\n+                if (reuse == null) {\n+                    throw new IllegalStateException(\n+                        \"reuse=null, header.after=\" + header.after + \" header.before\" + header.before +\n+                        \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                        \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                        \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+                }\n+                reuseMapping(reuse, hashIndex, hashCode, key, value);\n+            } else {\n+                super.addMapping(hashIndex, hashCode, key, value);\n+            }\n+        } else {\n+            super.addMapping(hashIndex, hashCode, key, value);\n+        }\n+    }\n+\n+    /**\n+     * Reuses an entry by removing it and moving it to a new place in the map.\n+     * <p>\n+     * This method uses {@link #removeEntry}, {@link #reuseEntry} and {@link #addEntry}.\n+     *\n+     * @param entry  the entry to reuse\n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void reuseMapping(final LinkEntry<K, V> entry, final int hashIndex, final int hashCode,\n+                                final K key, final V value) {\n+        // find the entry before the entry specified in the hash table\n+        // remember that the parameters (except the first) refer to the new entry,\n+        // not the old one\n+        try {\n+            final int removeIndex = hashIndex(entry.hashCode, data.length);\n+            final HashEntry<K, V>[] tmp = data;  // may protect against some sync issues\n+            HashEntry<K, V> loop = tmp[removeIndex];\n+            HashEntry<K, V> previous = null;\n+            while (loop != entry && loop != null) {\n+                previous = loop;\n+                loop = loop.next;\n+            }\n+            if (loop == null) {\n+                throw new IllegalStateException(\n+                    \"Entry.next=null, data[removeIndex]=\" + data[removeIndex] + \" previous=\" + previous +\n+                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+            }\n+\n+            // reuse the entry\n+            modCount++;\n+            removeEntry(entry, removeIndex, previous);\n+            reuseEntry(entry, hashIndex, hashCode, key, value);\n+            addEntry(entry, hashIndex);\n+        } catch (final NullPointerException ex) {\n+            throw new IllegalStateException(\n+                    \"NPE, entry=\" + entry + \" entryIsHeader=\" + (entry==header) +\n+                    \" key=\" + key + \" value=\" + value + \" size=\" + size + \" maxSize=\" + maxSize +\n+                    \" Please check that your keys are immutable, and that you have used synchronization properly.\" +\n+                    \" If so, then please report this to dev@commons.apache.org as a bug.\");\n+        }\n+    }\n+\n+    /**\n+     * Subclass method to control removal of the least recently used entry from the map.\n+     * <p>\n+     * This method exists for subclasses to override. A subclass may wish to\n+     * provide cleanup of resources when an entry is removed. For example:\n+     * <pre>\n+     * protected boolean removeLRU(LinkEntry entry) {\n+     *   releaseResources(entry.getValue());  // release resources held by entry\n+     *   return true;  // actually delete entry\n+     * }\n+     * </pre>\n+     * <p>\n+     * Alternatively, a subclass may choose to not remove the entry or selectively\n+     * keep certain LRU entries. For example:\n+     * <pre>\n+     * protected boolean removeLRU(LinkEntry entry) {\n+     *   if (entry.getKey().toString().startsWith(\"System.\")) {\n+     *     return false;  // entry not removed from LRUMap\n+     *   } else {\n+     *     return true;  // actually delete entry\n+     *   }\n+     * }\n+     * </pre>\n+     * The effect of returning false is dependent on the scanUntilRemovable flag.\n+     * If the flag is true, the next LRU entry will be passed to this method and so on\n+     * until one returns false and is removed, or every entry in the map has been passed.\n+     * If the scanUntilRemovable flag is false, the map will exceed the maximum size.\n+     * <p>\n+     * NOTE: Commons Collections 3.0 passed the wrong entry to this method.\n+     * This is fixed in version 3.1 onwards.\n+     *\n+     * @param entry  the entry to be removed\n+     * @return {@code true}\n+     */\n+    protected boolean removeLRU(final LinkEntry<K, V> entry) {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns true if this map is full and no new mappings can be added.\n+     *\n+     * @return <code>true</code> if the map is full\n+     */\n+    public boolean isFull() {\n+        return size >= maxSize;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the map (the bound).\n+     *\n+     * @return the maximum number of elements the map can hold\n+     */\n+    public int maxSize() {\n+        return maxSize;\n+    }\n+\n+    /**\n+     * Whether this LRUMap will scan until a removable entry is found when the\n+     * map is full.\n+     *\n+     * @return true if this map scans\n+     * @since 3.1\n+     */\n+    public boolean isScanUntilRemovable() {\n+        return scanUntilRemovable;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public LRUMap<K, V> clone() {\n+        return (LRUMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+    /**\n+     * Writes the data necessary for <code>put()</code> to work in deserialization.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException if an error occurs while writing to the stream\n+     */\n+    @Override\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n+        out.writeInt(maxSize);\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Reads the data necessary for <code>put()</code> to work in the superclass.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException if an error occurs while reading from the stream\n+     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n+     */\n+    @Override\n+    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        maxSize = in.readInt();\n+        super.doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/LazyMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.functors.FactoryTransformer;\n+\n+/**\n+ * Decorates another <code>Map</code> to create objects in the map on demand.\n+ * <p>\n+ * When the {@link #get(Object)} method is called with a key that does not\n+ * exist in the map, the factory is used to create the object. The created\n+ * object will be added to the map using the requested key.\n+ * <p>\n+ * For instance:\n+ * <pre>\n+ * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n+ *     public Date create() {\n+ *         return new Date();\n+ *     }\n+ * }\n+ * Map&lt;String, Date&gt; lazy = LazyMap.lazyMap(new HashMap&lt;String, Date&gt;(), factory);\n+ * Date date = lazy.get(\"NOW\");\n+ * </pre>\n+ *\n+ * After the above code is executed, <code>date</code> will refer to\n+ * a new <code>Date</code> instance. Furthermore, that <code>Date</code>\n+ * instance is mapped to the \"NOW\" key in the map.\n+ * <p>\n+ * <strong>Note that LazyMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class LazyMap<K, V> extends AbstractMapDecorator<K, V> implements Map<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7990956402564206740L;\n+\n+    /** The factory to use to construct elements */\n+    protected final Transformer<? super K, ? extends V> factory;\n+\n+    /**\n+     * Factory method to create a lazily instantiated map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @return a new lazy map\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory< ? extends V> factory) {\n+        return new LazyMap<K,V>(map, factory);\n+    }\n+\n+    /**\n+     * Factory method to create a lazily instantiated map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @return a new lazy map\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n+        return new LazyMap<K,V>(map, factory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazyMap(final Map<K,V> map, final Factory<? extends V> factory) {\n+        super(map);\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        this.factory = FactoryTransformer.factoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazyMap(final Map<K,V> map, final Transformer<? super K, ? extends V> factory) {\n+        super(map);\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"Factory must not be null\");\n+        }\n+        this.factory = factory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V get(final Object key) {\n+        // create value for key if key is not currently in the map\n+        if (map.containsKey(key) == false) {\n+            @SuppressWarnings(\"unchecked\")\n+            final K castKey = (K) key;\n+            final V value = factory.transform(castKey);\n+            map.put(castKey, value);\n+            return value;\n+        }\n+        return map.get(key);\n+    }\n+\n+    // no need to wrap keySet, entrySet or values as they are views of\n+    // existing map entries - you can't do a map-style get on them.\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedMap</code> to create objects in the map on demand.\n+ * <p>\n+ * When the {@link #get(Object)} method is called with a key that does not\n+ * exist in the map, the factory is used to create the object. The created\n+ * object will be added to the map using the requested key.\n+ * <p>\n+ * For instance:\n+ * <pre>\n+ * Factory&lt;Date&gt; factory = new Factory&lt;Date&gt;() {\n+ *     public Date create() {\n+ *         return new Date();\n+ *     }\n+ * }\n+ * SortedMap&lt;String, Date&gt; lazy =\n+ *     LazySortedMap.lazySortedMap(new HashMap&lt;String, Date&gt;(), factory);\n+ * Date date = lazy.get(\"NOW\");\n+ * </pre>\n+ *\n+ * After the above code is executed, <code>date</code> will refer to\n+ * a new <code>Date</code> instance. Furthermore, that <code>Date</code>\n+ * instance is mapped to the \"NOW\" key in the map.\n+ * <p>\n+ * <strong>Note that LazySortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class LazySortedMap<K,V> extends LazyMap<K,V> implements SortedMap<K,V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2715322183617658933L;\n+\n+    /**\n+     * Factory method to create a lazily instantiated sorted map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @return a new lazy sorted map\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+                                                           final Factory<? extends V> factory) {\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    /**\n+     * Factory method to create a lazily instantiated sorted map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @return a new lazy sorted map\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+                                                           final Transformer<? super K, ? extends V> factory) {\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazySortedMap(final SortedMap<K,V> map, final Factory<? extends V> factory) {\n+        super(map, factory);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param factory  the factory to use, must not be null\n+     * @throws IllegalArgumentException if map or factory is null\n+     */\n+    protected LazySortedMap(final SortedMap<K,V> map, final Transformer<? super K, ? extends V> factory) {\n+        super(map, factory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K,V> getSortedMap() {\n+        return (SortedMap<K,V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return getSortedMap().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return getSortedMap().lastKey();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return getSortedMap().comparator();\n+    }\n+\n+    public SortedMap<K,V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K,V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    public SortedMap<K,V> headMap(final K toKey) {\n+        final SortedMap<K,V> map = getSortedMap().headMap(toKey);\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+    public SortedMap<K,V> tailMap(final K fromKey) {\n+        final SortedMap<K,V> map = getSortedMap().tailMap(fromKey);\n+        return new LazySortedMap<K,V>(map, factory);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/LinkedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+import org.apache.commons.collections4.iterators.UnmodifiableListIterator;\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * A <code>Map</code> implementation that maintains the order of the entries.\n+ * In this implementation order is maintained by original insertion.\n+ * <p>\n+ * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n+ * {@link org.apache.commons.collections4.MapIterator MapIterator}\n+ * functionality, additional convenience methods and allowing\n+ * bidirectional iteration. It also implements <code>OrderedMap</code>.\n+ * In addition, non-interface methods are provided to access the map by index.\n+ * <p>\n+ * The <code>orderedMapIterator()</code> method provides direct access to a\n+ * bidirectional iterator. The iterators from the other views can also be cast\n+ * to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * The implementation is also designed to be subclassed, with lots of useful\n+ * methods exposed.\n+ * <p>\n+ * <strong>Note that LinkedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class LinkedMap<K, V> extends AbstractLinkedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 9077234323521161066L;\n+    \n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public LinkedMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public LinkedMap(final int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public LinkedMap(final int initialCapacity, final float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public LinkedMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public LinkedMap<K, V> clone() {\n+        return (LinkedMap<K, V>) super.clone();\n+    }\n+    \n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public K get(final int index) {\n+        return getEntry(index).getKey();\n+    }\n+    \n+    /**\n+     * Gets the value at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the value at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V getValue(final int index) {\n+        return getEntry(index).getValue();\n+    }\n+    \n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(Object key) {\n+        key = convertKey(key);\n+        int i = 0;\n+        for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after, i++) {\n+            if (isEqualKey(key, entry.key)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index of the object to remove\n+     * @return the previous value corresponding the <code>key</code>,\n+     *  or <code>null</code> if none existed\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V remove(final int index) {\n+        return remove(get(index));\n+    }\n+\n+    /**\n+     * Gets an unmodifiable List view of the keys.\n+     * <p>\n+     * The returned list is unmodifiable because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     * <p>\n+     * An alternative to this method is to use {@link #keySet()}.\n+     *\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List<K> asList() {\n+        return new LinkedMapList<K>(this);\n+    }\n+\n+    /**\n+     * List view of map.\n+     */\n+    static class LinkedMapList<K> extends AbstractList<K> {\n+\n+        final LinkedMap<K, ?> parent;\n+\n+        LinkedMapList(final LinkedMap<K, ?> parent) {\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.size();\n+        }\n+\n+        @Override\n+        public K get(final int index) {\n+            return parent.get(index);\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            return parent.containsKey(obj);\n+        }\n+\n+        @Override\n+        public int indexOf(final Object obj) {\n+            return parent.indexOf(obj);\n+        }\n+\n+        @Override\n+        public int lastIndexOf(final Object obj) {\n+            return parent.indexOf(obj);\n+        }\n+\n+        @Override\n+        public boolean containsAll(final Collection<?> coll) {\n+            return parent.keySet().containsAll(coll);\n+        }\n+\n+        @Override\n+        public K remove(final int index) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean removeAll(final Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public boolean retainAll(final Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Object[] toArray() {\n+            return parent.keySet().toArray();\n+        }\n+\n+        @Override\n+        public <T> T[] toArray(final T[] array) {\n+            return parent.keySet().toArray(array);\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return UnmodifiableIterator.unmodifiableIterator(parent.keySet().iterator());\n+        }\n+\n+        @Override\n+        public ListIterator<K> listIterator() {\n+            return UnmodifiableListIterator.umodifiableListIterator(super.listIterator());\n+        }\n+\n+        @Override\n+        public ListIterator<K> listIterator(final int fromIndex) {\n+            return UnmodifiableListIterator.umodifiableListIterator(super.listIterator(fromIndex));\n+        }\n+\n+        @Override\n+        public List<K> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n+            return UnmodifiableList.unmodifiableList(super.subList(fromIndexInclusive, toIndexExclusive));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractList;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.iterators.AbstractUntypedIteratorDecorator;\n+import org.apache.commons.collections4.keyvalue.AbstractMapEntry;\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * Decorates a <code>Map</code> to ensure that the order of addition is retained\n+ * using a <code>List</code> to maintain order.\n+ * <p>\n+ * The order will be used via the iterators and toArray methods on the views.\n+ * The order is also returned by the <code>MapIterator</code>.\n+ * The <code>orderedMapIterator()</code> method accesses an iterator that can\n+ * iterate both forwards and backwards through the map.\n+ * In addition, non-interface methods are provided to access the map by index.\n+ * <p>\n+ * If an object is added to the Map for a second time, it will remain in the\n+ * original position in the iteration.\n+ * <p>\n+ * <strong>Note that ListOrderedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * <strong>Note that ListOrderedMap doesn't work with {@link IdentityMap},\n+ * {@link CaseInsensitiveMap}, or similar maps that violate the general\n+ * contract of {@link java.util.Map}.</strong> The <code>ListOrderedMap</code>\n+ * (or, more precisely, the underlying <code>List</code>) is relying on\n+ * {@link Object#equals(Object) equals()}. This is fine, as long as the\n+ * decorated <code>Map</code> is also based on {@link Object#equals(Object) equals()},\n+ * and {@link Object#hashCode() hashCode()}, which {@link IdentityMap}, and\n+ * {@link CaseInsensitiveMap} don't: The former uses <code>==</code>, and\n+ * the latter uses {@link Object#equals(Object) equals()} on a lower-cased\n+ * key.\n+ * <p>\n+ * This class is {@link Serializable} starting with Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ListOrderedMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements OrderedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2728177751851003750L;\n+\n+    /** Internal list to hold the sequence of objects */\n+    protected final List<K> insertOrder = new ArrayList<K>();\n+\n+    /**\n+     * Factory method to create an ordered map.\n+     * <p>\n+     * An <code>ArrayList</code> is used to retain order.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return a new list ordered map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n+        return new ListOrderedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty <code>ListOrderedMap</code> that decorates\n+     * a <code>HashMap</code>.\n+     * \n+     * @since 3.1\n+     */\n+    public ListOrderedMap() {\n+        this(new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected ListOrderedMap(final Map<K, V> map) {\n+        super(map);\n+        insertOrder.addAll(decorated().keySet());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    // Implement OrderedMap\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new ListOrderedMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Gets the first key in this map by insert order.\n+     *\n+     * @return the first key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K firstKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return insertOrder.get(0);\n+    }\n+\n+    /**\n+     * Gets the last key in this map by insert order.\n+     *\n+     * @return the last key currently in this map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public K lastKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return insertOrder.get(size() - 1);\n+    }\n+    \n+    /**\n+     * Gets the next key to the one specified using insert order.\n+     * This method performs a list search to find the key and is O(n).\n+     * \n+     * @param key  the key to find previous for\n+     * @return the next key, null if no match or at start\n+     */\n+    public K nextKey(final Object key) {\n+        final int index = insertOrder.indexOf(key);\n+        if (index >= 0 && index < size() - 1) {\n+            return insertOrder.get(index + 1);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous key to the one specified using insert order.\n+     * This method performs a list search to find the key and is O(n).\n+     * \n+     * @param key  the key to find previous for\n+     * @return the previous key, null if no match or at start\n+     */\n+    public K previousKey(final Object key) {\n+        final int index = insertOrder.indexOf(key);\n+        if (index > 0) {\n+            return insertOrder.get(index - 1);\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(final K key, final V value) {\n+        if (decorated().containsKey(key)) {\n+            // re-adding doesn't change order\n+            return decorated().put(key, value);\n+        } else {\n+            // first add, so add to both map and list\n+            final V result = decorated().put(key, value);\n+            insertOrder.add(key);\n+            return result;\n+        }\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Puts the values contained in a supplied Map into the Map starting at\n+     * the specified index.\n+     *\n+     * @param index the index in the Map to start at.\n+     * @param map the Map containing the values to be added.\n+     */\n+    public void putAll(int index, final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            final V old = put(index, entry.getKey(), entry.getValue());\n+            if (old == null) {\n+                // if no key was replaced, increment the index\n+                index++;\n+            } else {\n+                // otherwise put the next item after the currently inserted key\n+                index = indexOf(entry.getKey()) + 1;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        V result = null;\n+        if (decorated().containsKey(key)) {\n+            result = decorated().remove(key);\n+            insertOrder.remove(key);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        decorated().clear();\n+        insertOrder.clear();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a view over the keys in the map.\n+     * <p>\n+     * The Collection will be ordered by object insertion into the map.\n+     *\n+     * @see #keyList()\n+     * @return the fully modifiable collection view over the keys\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        return new KeySetView<K>(this);\n+    }\n+\n+    /**\n+     * Gets a view over the keys in the map as a List.\n+     * <p>\n+     * The List will be ordered by object insertion into the map.\n+     * The List is unmodifiable.\n+     *\n+     * @see #keySet()\n+     * @return the unmodifiable list view over the keys\n+     * @since 3.2\n+     */\n+    public List<K> keyList() {\n+        return UnmodifiableList.unmodifiableList(insertOrder);\n+    }\n+\n+    /**\n+     * Gets a view over the values in the map.\n+     * <p>\n+     * The Collection will be ordered by object insertion into the map.\n+     * <p>\n+     * From Commons Collections 3.2, this Collection can be cast\n+     * to a list, see {@link #valueList()}\n+     *\n+     * @see #valueList()\n+     * @return the fully modifiable collection view over the values\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        return new ValuesView<V>(this);\n+    }\n+\n+    /**\n+     * Gets a view over the values in the map as a List.\n+     * <p>\n+     * The List will be ordered by object insertion into the map.\n+     * The List supports remove and set, but does not support add.\n+     *\n+     * @see #values()\n+     * @return the partially modifiable list view over the values\n+     * @since 3.2\n+     */\n+    public List<V> valueList() {\n+        return new ValuesView<V>(this);\n+    }\n+\n+    /**\n+     * Gets a view over the entries in the map.\n+     * <p>\n+     * The Set will be ordered by object insertion into the map.\n+     *\n+     * @return the fully modifiable set view over the entries\n+     */\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return new EntrySetView<K, V>(this, this.insertOrder);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the Map as a string.\n+     * \n+     * @return the Map as a String\n+     */\n+    @Override\n+    public String toString() {\n+        if (isEmpty()) {\n+            return \"{}\";\n+        }\n+        final StringBuilder buf = new StringBuilder();\n+        buf.append('{');\n+        boolean first = true;\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n+            final K key = entry.getKey();\n+            final V value = entry.getValue();\n+            if (first) {\n+                first = false;\n+            } else {\n+                buf.append(\", \");\n+            }\n+            buf.append(key == this ? \"(this Map)\" : key);\n+            buf.append('=');\n+            buf.append(value == this ? \"(this Map)\" : value);\n+        }\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public K get(final int index) {\n+        return insertOrder.get(index);\n+    }\n+    \n+    /**\n+     * Gets the value at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the key at the specified index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V getValue(final int index) {\n+        return get(insertOrder.get(index));\n+    }\n+    \n+    /**\n+     * Gets the index of the specified key.\n+     * \n+     * @param key  the key to find the index of\n+     * @return the index, or -1 if not found\n+     */\n+    public int indexOf(final Object key) {\n+        return insertOrder.indexOf(key);\n+    }\n+\n+    /**\n+     * Sets the value at the specified index.\n+     *\n+     * @param index  the index of the value to set\n+     * @param value  the new value to set\n+     * @return the previous value at that index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     * @since 3.2\n+     */\n+    public V setValue(final int index, final V value) {\n+        final K key = insertOrder.get(index);\n+        return put(key, value);\n+    }\n+\n+    /**\n+     * Puts a key-value mapping into the map at the specified index.\n+     * <p>\n+     * If the map already contains the key, then the original mapping\n+     * is removed and the new mapping added at the specified index.\n+     * The remove may change the effect of the index. The index is\n+     * always calculated relative to the original state of the map.\n+     * <p>\n+     * Thus the steps are: (1) remove the existing key-value mapping,\n+     * then (2) insert the new key-value mapping at the position it\n+     * would have been inserted had the remove not occurred.\n+     *\n+     * @param index  the index at which the mapping should be inserted\n+     * @param key  the key\n+     * @param value  the value\n+     * @return the value previously mapped to the key\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     * @since 3.2\n+     */\n+    public V put(int index, final K key, final V value) {\n+        final Map<K, V> m = decorated();\n+        if (m.containsKey(key)) {\n+            final V result = m.remove(key);\n+            final int pos = insertOrder.indexOf(key);\n+            insertOrder.remove(pos);\n+            if (pos < index) {\n+                index--;\n+            }\n+            insertOrder.add(index, key);\n+            m.put(key, value);\n+            return result;\n+        } else {\n+            insertOrder.add(index, key);\n+            m.put(key, value);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     *\n+     * @param index  the index of the object to remove\n+     * @return the removed value, or <code>null</code> if none existed\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public V remove(final int index) {\n+        return remove(get(index));\n+    }\n+\n+    /**\n+     * Gets an unmodifiable List view of the keys which changes as the map changes.\n+     * <p>\n+     * The returned list is unmodifiable because changes to the values of\n+     * the list (using {@link java.util.ListIterator#set(Object)}) will\n+     * effectively remove the value from the list and reinsert that value at\n+     * the end of the list, which is an unexpected side effect of changing the\n+     * value of a list.  This occurs because changing the key, changes when the\n+     * mapping is added to the map and thus where it appears in the list.\n+     * <p>\n+     * An alternative to this method is to use the better named\n+     * {@link #keyList()} or {@link #keySet()}.\n+     *\n+     * @see #keyList()\n+     * @see #keySet()\n+     * @return The ordered list of keys.  \n+     */\n+    public List<K> asList() {\n+        return keyList();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ValuesView<V> extends AbstractList<V> {\n+        private final ListOrderedMap<Object, V> parent;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ValuesView(final ListOrderedMap<?, V> parent) {\n+            super();\n+            this.parent = (ListOrderedMap<Object, V>) parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return this.parent.size();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object value) {\n+            return this.parent.containsValue(value);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new AbstractUntypedIteratorDecorator<Map.Entry<Object, V>, V>(parent.entrySet().iterator()) {\n+                public V next() {\n+                    return getIterator().next().getValue();\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public V get(final int index) {\n+            return this.parent.getValue(index);\n+        }\n+\n+        @Override\n+        public V set(final int index, final V value) {\n+            return this.parent.setValue(index, value);\n+        }\n+\n+        @Override\n+        public V remove(final int index) {\n+            return this.parent.remove(index);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class KeySetView<K> extends AbstractSet<K> {\n+        private final ListOrderedMap<K, Object> parent;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        KeySetView(final ListOrderedMap<K, ?> parent) {\n+            super();\n+            this.parent = (ListOrderedMap<K, Object>) parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return this.parent.size();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object value) {\n+            return this.parent.containsKey(value);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new AbstractUntypedIteratorDecorator<Map.Entry<K, Object>, K>(parent.entrySet().iterator()) {\n+                public K next() {\n+                    return getIterator().next().getKey();\n+                }\n+            };\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    static class EntrySetView<K, V> extends AbstractSet<Map.Entry<K, V>> {\n+        private final ListOrderedMap<K, V> parent;\n+        private final List<K> insertOrder;\n+        private Set<Map.Entry<K, V>> entrySet;\n+\n+        public EntrySetView(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n+            super();\n+            this.parent = parent;\n+            this.insertOrder = insertOrder;\n+        }\n+\n+        private Set<Map.Entry<K, V>> getEntrySet() {\n+            if (entrySet == null) {\n+                entrySet = parent.decorated().entrySet();\n+            }\n+            return entrySet;\n+        }\n+        \n+        @Override\n+        public int size() {\n+            return this.parent.size();\n+        }\n+        @Override\n+        public boolean isEmpty() {\n+            return this.parent.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            return getEntrySet().contains(obj);\n+        }\n+\n+        @Override\n+        public boolean containsAll(final Collection<?> coll) {\n+            return getEntrySet().containsAll(coll);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            if (getEntrySet().contains(obj)) {\n+                final Object key = ((Map.Entry<K, V>) obj).getKey();\n+                parent.remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void clear() {\n+            this.parent.clear();\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            return getEntrySet().equals(obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return getEntrySet().hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getEntrySet().toString();\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new ListOrderedIterator<K, V>(parent, insertOrder);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedIterator<K, V> extends AbstractUntypedIteratorDecorator<K, Map.Entry<K, V>> {\n+        private final ListOrderedMap<K, V> parent;\n+        private K last = null;\n+        \n+        ListOrderedIterator(final ListOrderedMap<K, V> parent, final List<K> insertOrder) {\n+            super(insertOrder.iterator());\n+            this.parent = parent;\n+        }\n+\n+        public Map.Entry<K, V> next() {\n+            last = getIterator().next();\n+            return new ListOrderedMapEntry<K, V>(parent, last);\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            parent.decorated().remove(last);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapEntry<K, V> extends AbstractMapEntry<K, V> {\n+        private final ListOrderedMap<K, V> parent;\n+\n+        ListOrderedMapEntry(final ListOrderedMap<K, V> parent, final K key) {\n+            super(key, null);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public V getValue() {\n+            return parent.get(key);\n+        }\n+\n+        @Override\n+        public V setValue(final V value) {\n+            return parent.decorated().put(key, value);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class ListOrderedMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+        private final ListOrderedMap<K, V> parent;\n+        private ListIterator<K> iterator;\n+        private K last = null;\n+        private boolean readable = false;\n+\n+        ListOrderedMapIterator(final ListOrderedMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+            this.iterator = parent.insertOrder.listIterator();\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public K next() {\n+            last = iterator.next();\n+            readable = true;\n+            return last;\n+        }\n+        \n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+\n+        public K previous() {\n+            last = iterator.previous();\n+            readable = true;\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            iterator.remove();\n+            parent.map.remove(last);\n+            readable = false;\n+        }\n+\n+        public K getKey() {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return last;\n+        }\n+\n+        public V getValue() {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return parent.get(last);\n+        }\n+\n+        public V setValue(final V value) {\n+            if (readable == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return parent.map.put(last, value);\n+        }\n+\n+        public void reset() {\n+            iterator = parent.insertOrder.listIterator();\n+            last = null;\n+            readable = false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            if (readable == true) {\n+                return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            }\n+            return \"Iterator[]\";\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.keyvalue.MultiKey;\n+\n+/**\n+ * A <code>Map</code> implementation that uses multiple keys to map the value.\n+ * <p>\n+ * This class is the most efficient way to uses multiple keys to map to a value.\n+ * The best way to use this class is via the additional map-style methods.\n+ * These provide <code>get</code>, <code>containsKey</code>, <code>put</code> and\n+ * <code>remove</code> for individual keys which operate without extra object creation.\n+ * <p>\n+ * The additional methods are the main interface of this map.\n+ * As such, you will not normally hold this map in a variable of type <code>Map</code>.\n+ * <p>\n+ * The normal map methods take in and return a {@link MultiKey}.\n+ * If you try to use <code>put()</code> with any other object type a\n+ * <code>ClassCastException</code> is thrown. If you try to use <code>null</code> as\n+ * the key in <code>put()</code> a <code>NullPointerException</code> is thrown.\n+ * <p>\n+ * This map is implemented as a decorator of a <code>AbstractHashedMap</code> which\n+ * enables extra behaviour to be added easily.\n+ * <ul>\n+ * <li><code>MultiKeyMap.decorate(new LinkedMap())</code> creates an ordered map.\n+ * <li><code>MultiKeyMap.decorate(new LRUMap())</code> creates an least recently used map.\n+ * <li><code>MultiKeyMap.decorate(new ReferenceMap())</code> creates a garbage collector sensitive map.\n+ * </ul>\n+ * Note that <code>IdentityMap</code> and <code>ReferenceIdentityMap</code> are unsuitable\n+ * for use as the key comparison would work on the whole MultiKey, not the elements within.\n+ * <p>\n+ * As an example, consider a least recently used cache that uses a String airline code\n+ * and a Locale to lookup the airline's name:\n+ * <pre>\n+ * private MultiKeyMap cache = MultiKeyMap.multiKeyMap(new LRUMap(50));\n+ *\n+ * public String getAirlineName(String code, String locale) {\n+ *   String name = (String) cache.get(code, locale);\n+ *   if (name == null) {\n+ *     name = getAirlineNameFromDB(code, locale);\n+ *     cache.put(code, locale, name);\n+ *   }\n+ *   return name;\n+ * }\n+ * </pre>\n+ * <p>\n+ * <strong>Note that MultiKeyMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. This class may throw exceptions when accessed\n+ * by concurrent threads without synchronization.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class MultiKeyMap<K, V> extends AbstractMapDecorator<MultiKey<? extends K>, V>\n+        implements IterableMap<MultiKey<? extends K>, V>, Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -1788199231038721040L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified map to add the MultiKeyMap API and fast query.\n+     * The map must not be null and must be empty.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, not null\n+     * @return a new multi key map\n+     * @throws IllegalArgumentException if the map is null or not empty\n+     */\n+    public static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        if (map.size() > 0) {\n+            throw new IllegalArgumentException(\"Map must be empty\");\n+        }\n+        return new MultiKeyMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Constructs a new MultiKeyMap that decorates a <code>HashedMap</code>.\n+     */\n+    public MultiKeyMap() {\n+        this(new HashedMap<MultiKey<? extends K>, V>());\n+    }\n+\n+    /**\n+     * Constructor that decorates the specified map and is called from\n+     * {@link #multiKeyMap(AbstractHashedMap)}.\n+     * The map must not be null and should be empty or only contain valid keys.\n+     * This constructor performs no validation.\n+     *\n+     * @param map  the map to decorate\n+     */\n+    protected MultiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n+        super(map);\n+        this.map = map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(final Object key1, final Object key2) {\n+        final int hashCode = hash(key1, key2);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(final Object key1, final Object key2) {\n+        final int hashCode = hash(key1, key2);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(final K key1, final K key2, final V value) {\n+        final int hashCode = hash(key1, key2);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                final V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(final Object key1, final Object key2) {\n+        final int hashCode = hash(key1, key2);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                final V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the hash code\n+     */\n+    protected int hash(final Object key1, final Object key2) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  h >>> 14;\n+        h +=  h << 4;\n+        h ^=  h >>> 10;\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            final Object key1, final Object key2) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 2 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key1 != null && key2.equals(multi.getKey(1)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(final Object key1, final Object key2, final Object key3) {\n+        final int hashCode = hash(key1, key2, key3);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3) {\n+        final int hashCode = hash(key1, key2, key3);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(final K key1, final K key2, final K key3, final V value) {\n+        final int hashCode = hash(key1, key2, key3);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                final V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(final Object key1, final Object key2, final Object key3) {\n+        final int hashCode = hash(key1, key2, key3);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                final V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the hash code\n+     */\n+    protected int hash(final Object key1, final Object key2, final Object key3) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  h >>> 14;\n+        h +=  h << 4;\n+        h ^=  h >>> 10;\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+                                 final Object key1, final Object key2, final Object key3) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 3 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(final K key1, final K key2, final K key3, final K key4, final V value) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                final V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3, key4), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final int hashCode = hash(key1, key2, key3, key4);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                final V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the hash code\n+     */\n+    protected int hash(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        if (key4 != null) {\n+            h ^= key4.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  h >>> 14;\n+        h +=  h << 4;\n+        h ^=  h >>> 10;\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+                                 final Object key1, final Object key2, final Object key3, final Object key4) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 4 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n+            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3,\n+                               final Object key4, final Object key5) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n+                decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public V put(final K key1, final K key2, final K key3, final K key4, final K key5, final V value) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                final V oldValue = entry.getValue();\n+                decorated().updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        decorated().addMapping(index, hashCode, new MultiKey<K>(key1, key2, key3, key4, key5), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public V remove(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final int hashCode = hash(key1, key2, key3, key4, key5);\n+        final int index = decorated().hashIndex(hashCode, decorated().data.length);\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry = decorated().data[index];\n+        AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                final V oldValue = entry.getValue();\n+                decorated().removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the hash code\n+     */\n+    protected int hash(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        if (key4 != null) {\n+            h ^= key4.hashCode();\n+        }\n+        if (key5 != null) {\n+            h ^= key5.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  h >>> 14;\n+        h +=  h << 4;\n+        h ^=  h >>> 10;\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(final AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry,\n+            final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+        final MultiKey<? extends K> multi = entry.getKey();\n+        return\n+            multi.size() == 5 &&\n+            (key1 == multi.getKey(0) || key1 != null && key1.equals(multi.getKey(0))) &&\n+            (key2 == multi.getKey(1) || key2 != null && key2.equals(multi.getKey(1))) &&\n+            (key3 == multi.getKey(2) || key3 != null && key3.equals(multi.getKey(2))) &&\n+            (key4 == multi.getKey(3) || key4 != null && key4.equals(multi.getKey(3))) &&\n+            (key5 == multi.getKey(4) || key5 != null && key5.equals(multi.getKey(4)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes all mappings where the first key is that specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has one or more keys, and the first matches that specified.\n+     * \n+     * @param key1  the first key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(final Object key1) {\n+        boolean modified = false;\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            final MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 1 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first two keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has two or more keys, and the first two match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(final Object key1, final Object key2) {\n+        boolean modified = false;\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            final MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 2 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first three keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has three or more keys, and the first three match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(final Object key1, final Object key2, final Object key3) {\n+        boolean modified = false;\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            final MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 3 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first four keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has four or more keys, and the first four match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(final Object key1, final Object key2, final Object key3, final Object key4) {\n+        boolean modified = false;\n+        final MapIterator<MultiKey<? extends K>, V> it = mapIterator();\n+        while (it.hasNext()) {\n+            final MultiKey<? extends K> multi = it.next();\n+            if (multi.size() >= 4 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n+                (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Check to ensure that input keys are valid MultiKey objects.\n+     * \n+     * @param key  the key to check\n+     */\n+    protected void checkKey(final MultiKey<?> key) {\n+        if (key == null) {\n+            throw new NullPointerException(\"Key must not be null\");\n+        }\n+    }\n+\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public MultiKeyMap<K, V> clone() {\n+        try {\n+            return (MultiKeyMap<K, V>) super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Puts the key and value into the map, where the key must be a non-null\n+     * MultiKey object.\n+     * \n+     * @param key  the non-null MultiKey object\n+     * @param value  the value to store\n+     * @return the previous value for the key\n+     * @throws NullPointerException if the key is null\n+     * @throws ClassCastException if the key is not a MultiKey\n+     */\n+    @Override\n+    public V put(final MultiKey<? extends K> key, final V value) {\n+        checkKey(key);\n+        return super.put(key, value);\n+    }\n+\n+    /**\n+     * Copies all of the keys and values from the specified map to this map.\n+     * Each key must be non-null and a MultiKey object.\n+     * \n+     * @param mapToCopy  to this map\n+     * @throws NullPointerException if the mapToCopy or any key within is null\n+     * @throws ClassCastException if any key in mapToCopy is not a MultiKey\n+     */\n+    @Override\n+    public void putAll(final Map<? extends MultiKey<? extends K>, ? extends V> mapToCopy) {\n+        for (final MultiKey<? extends K> key : mapToCopy.keySet()) {\n+            checkKey(key);\n+        }\n+        super.putAll(mapToCopy);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public MapIterator<MultiKey<? extends K>, V> mapIterator() {\n+        return decorated().mapIterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected AbstractHashedMap<MultiKey<? extends K>, V> decorated() {\n+        return (AbstractHashedMap<MultiKey<? extends K>, V>) super.decorated();\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<MultiKey<? extends K>, V>) in.readObject();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/MultiValueMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.MultiMap;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.IteratorChain;\n+\n+/**\n+ * A MultiValueMap decorates another map, allowing it to have\n+ * more than one value for a key.\n+ * <p>\n+ * A <code>MultiMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that key.\n+ * <p>\n+ * This implementation is a decorator, allowing any Map implementation\n+ * to be used as the base.\n+ * <p>\n+ * In addition, this implementation allows the type of collection used\n+ * for the values to be controlled. By default, an <code>ArrayList</code>\n+ * is used, however a <code>Class</code> to instantiate may be specified,\n+ * or a factory that returns a <code>Collection</code> instance.\n+ * <p>\n+ * <strong>Note that MultiValueMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. This class may throw exceptions when accessed\n+ * by concurrent threads without synchronization.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2214159910087182007L;\n+\n+    /** The factory for creating value collections. */\n+    private final Factory<? extends Collection<V>> collectionFactory;\n+    /** The cached values. */\n+    private transient Collection<V> valuesView;\n+\n+    /**\n+     * Creates a map which wraps the given map and\n+     * maps keys to ArrayLists.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to wrap\n+     * @return a new multi-value map\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> MultiValueMap<K, V> multiValueMap(final Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V, ArrayList> multiValueMap((Map<K, ? super Collection>) map, ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * maps keys to collections of type <code>collectionClass</code>.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <C>  the collection class type\n+     * @param map  the map to wrap\n+     * @param collectionClass  the type of the collection class\n+     * @return a new multi-value map\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n+                                                                                    final Class<C> collectionClass) {\n+        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n+    }\n+\n+    /**\n+     * Creates a map which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param <C>  the collection class type\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory (must return a Collection object).\n+     * @return a new multi-value map\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n+            final Factory<C> collectionFactory) {\n+        return new MultiValueMap<K, V>(map, collectionFactory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> and\n+     * storing the multiple values in an <code>ArrayList</code>.\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public MultiValueMap() {\n+        this(new HashMap<K, V>(), new ReflectionFactory(ArrayList.class));\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap which decorates the given <code>map</code> and\n+     * creates the value collections using the supplied <code>collectionFactory</code>.\n+     *\n+     * @param <C>  the collection class type\n+     * @param map  the map to decorate\n+     * @param collectionFactory  the collection factory which must return a Collection instance\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n+                                                      final Factory<C> collectionFactory) {\n+        super((Map<K, Object>) map);\n+        if (collectionFactory == null) {\n+            throw new IllegalArgumentException(\"The factory must not be null\");\n+        }\n+        this.collectionFactory = collectionFactory;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 4.0\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 4.0\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, Object>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clear the map.\n+     */\n+    @Override\n+    public void clear() {\n+        // If you believe that you have GC issues here, try uncommenting this code\n+//        Set pairs = getMap().entrySet();\n+//        Iterator pairsIterator = pairs.iterator();\n+//        while (pairsIterator.hasNext()) {\n+//            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n+//            Collection coll = (Collection) keyValuePair.getValue();\n+//            coll.clear();\n+//        }\n+        decorated().clear();\n+    }\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, <code>null</code> will be returned\n+     * from a subsequant <code>get(key)</code>.\n+     *\n+     * @param key  the key to remove from\n+     * @param value the value to remove\n+     * @return the value removed (which was passed in), null if nothing removed\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V remove(final Object key, final Object value) {\n+        final Collection<V> valuesForKey = getCollection(key);\n+        if (valuesForKey == null) {\n+            return null;\n+        }\n+        final boolean removed = valuesForKey.remove(value);\n+        if (removed == false) {\n+            return null;\n+        }\n+        if (valuesForKey.isEmpty()) {\n+            remove(key);\n+        }\n+        return (V) value;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the value specified.\n+     * <p>\n+     * This checks all collections against all keys for the value, and thus could be slow.\n+     *\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean containsValue(final Object value) {\n+        final Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n+        if (pairs != null) {\n+            for (final Map.Entry<K, Object> entry : pairs) {\n+                if (((Collection<V>) entry.getValue()).contains(value)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     *\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return the value added if the map changed and null if the map did not change\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Object put(final K key, final Object value) {\n+        boolean result = false;\n+        Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(1);  // might produce a non-empty collection\n+            coll.add((V) value);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                decorated().put(key, coll);\n+                result = true;  // map definitely changed\n+            }\n+        } else {\n+            result = coll.add((V) value);\n+        }\n+        return result ? value : null;\n+    }\n+\n+    /**\n+     * Override superclass to ensure that MultiMap instances are\n+     * correctly handled.\n+     * <p>\n+     * If you call this method with a normal map, each entry is\n+     * added using <code>put(Object,Object)</code>.\n+     * If you call this method with a multi map, each entry is\n+     * added using <code>putAll(Object,Collection)</code>.\n+     *\n+     * @param map  the map to copy (either a normal or multi map)\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void putAll(final Map<? extends K, ?> map) {\n+        if (map instanceof MultiMap) {\n+            for (final Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n+                putAll(entry.getKey(), (Collection<V>) entry.getValue());\n+            }\n+        } else {\n+            for (final Map.Entry<? extends K, ?> entry : map.entrySet()) {\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * This returns a collection containing the combination of values from all keys.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<Object> values() {\n+        final Collection<V> vs = valuesView;\n+        return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n+    }\n+\n+    /**\n+     * Checks whether the collection at the specified key contains the value.\n+     *\n+     * @param key  the key to search for\n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(final Object key, final Object value) {\n+        final Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            return false;\n+        }\n+        return coll.contains(value);\n+    }\n+\n+    /**\n+     * Gets the collection mapped to the specified key.\n+     * This method is a convenience method to typecast the result of <code>get(key)</code>.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the collection mapped to the key, null if no mapping\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<V> getCollection(final Object key) {\n+        return (Collection<V>) decorated().get(key);\n+    }\n+\n+    /**\n+     * Gets the size of the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get size for\n+     * @return the size of the collection at the key, zero if key not in map\n+     */\n+    public int size(final Object key) {\n+        final Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            return 0;\n+        }\n+        return coll.size();\n+    }\n+\n+    /**\n+     * Adds a collection of values to the collection associated with\n+     * the specified key.\n+     *\n+     * @param key  the key to store against\n+     * @param values  the values to add to the collection at the key, null ignored\n+     * @return true if this map changed\n+     */\n+    public boolean putAll(final K key, final Collection<V> values) {\n+        if (values == null || values.size() == 0) {\n+            return false;\n+        }\n+        boolean result = false;\n+        Collection<V> coll = getCollection(key);\n+        if (coll == null) {\n+            coll = createCollection(values.size());  // might produce a non-empty collection\n+            coll.addAll(values);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                decorated().put(key, coll);\n+                result = true;  // map definitely changed\n+            }\n+        } else {\n+            result = coll.addAll(values);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an iterator for the collection mapped to the specified key.\n+     *\n+     * @param key  the key to get an iterator for\n+     * @return the iterator of the collection at the key, empty iterator if key not in map\n+     */\n+    public Iterator<V> iterator(final Object key) {\n+        if (!containsKey(key)) {\n+            return EmptyIterator.<V>emptyIterator();\n+        }\n+        return new ValuesIterator(key);\n+    }\n+\n+    /**\n+     * Gets the total size of the map by counting all the values.\n+     *\n+     * @return the total size of the map counting all values\n+     */\n+    public int totalSize() {\n+        int total = 0;\n+        for (final Object v : decorated().values()) {\n+            total += CollectionUtils.size(v);\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Creates a new instance of the map value Collection container\n+     * using the factory.\n+     * <p>\n+     * This method can be overridden to perform your own processing\n+     * instead of using the factory.\n+     *\n+     * @param size  the collection size that is about to be added\n+     * @return the new collection\n+     */\n+    protected Collection<V> createCollection(final int size) {\n+        return collectionFactory.create();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class that provides the values view.\n+     */\n+    private class Values extends AbstractCollection<V> {\n+        @Override\n+        public Iterator<V> iterator() {\n+            final IteratorChain<V> chain = new IteratorChain<V>();\n+            for (final K k : keySet()) {\n+                chain.addIterator(new ValuesIterator(k));\n+            }\n+            return chain;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return totalSize();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            MultiValueMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides the values iterator.\n+     */\n+    private class ValuesIterator implements Iterator<V> {\n+        private final Object key;\n+        private final Collection<V> values;\n+        private final Iterator<V> iterator;\n+\n+        public ValuesIterator(final Object key) {\n+            this.key = key;\n+            this.values = getCollection(key);\n+            this.iterator = values.iterator();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            if (values.isEmpty()) {\n+                MultiValueMap.this.remove(key);\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public V next() {\n+            return iterator.next();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides a simple reflection factory.\n+     */\n+    private static class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 2986114157496788874L;\n+\n+        private final Class<T> clazz;\n+\n+        public ReflectionFactory(final Class<T> clazz) {\n+            this.clazz = clazz;\n+        }\n+\n+        public T create() {\n+            try {\n+                return clazz.newInstance();\n+            } catch (final Exception ex) {\n+                throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Decorates a <code>Map</code> to evict expired entries once their expiration\n+ * time has been reached.\n+ * <p>\n+ * When putting a key-value pair in the map this decorator uses a\n+ * {@link ExpirationPolicy} to determine how long the entry should remain alive\n+ * as defined by an expiration time value.\n+ * </p>\n+ * <p>\n+ * When accessing the mapped value for a key, its expiration time is checked,\n+ * and if it is a negative value or if it is greater than the current time, the\n+ * mapped value is returned. Otherwise, the key is removed from the decorated\n+ * map, and <code>null</code> is returned.\n+ * </p>\n+ * <p>\n+ * When invoking methods that involve accessing the entire map contents (i.e\n+ * {@link #containsKey(Object)}, {@link #entrySet()}, etc.) this decorator\n+ * removes all expired entries prior to actually completing the invocation.\n+ * </p>\n+ * <p>\n+ * <strong>Note that {@link PassiveExpiringMap} is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. The simplest approach\n+ * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n+ * This class may throw exceptions when accessed by concurrent threads without\n+ * synchronization.\n+ * </p>\n+ * \n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PassiveExpiringMap<K, V>\n+    extends AbstractMapDecorator<K, V>\n+    implements Serializable {\n+\n+    /**\n+     * A {@link org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy ExpirationPolicy}\n+     * that returns a expiration time that is a\n+     * constant about of time in the future from the current time.\n+     * \n+     * @param <K> the type of the keys in the map\n+     * @param <V> the type of the values in the map\n+     * @since 4.0\n+     * @version $Id$\n+     */\n+    public static class ConstantTimeToLiveExpirationPolicy<K, V>\n+        implements ExpirationPolicy<K, V> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 1L;\n+\n+        /** the constant time-to-live value measured in milliseconds. */\n+        private final long timeToLiveMillis;\n+\n+        /**\n+         * Default constructor. Constructs a policy using a negative\n+         * time-to-live value that results in entries never expiring.\n+         */\n+        public ConstantTimeToLiveExpirationPolicy() {\n+            this(-1L);\n+        }\n+\n+        /**\n+         * Construct a policy with the given time-to-live constant measured in\n+         * milliseconds. A negative time-to-live value indicates entries never\n+         * expire. A zero time-to-live value indicates entries expire (nearly)\n+         * immediately.\n+         * \n+         * @param timeToLiveMillis the constant amount of time (in milliseconds)\n+         *        an entry is available before it expires. A negative value\n+         *        results in entries that NEVER expire. A zero value results in\n+         *        entries that ALWAYS expire.\n+         */\n+        public ConstantTimeToLiveExpirationPolicy(final long timeToLiveMillis) {\n+            super();\n+            this.timeToLiveMillis = timeToLiveMillis;\n+        }\n+\n+        /**\n+         * Construct a policy with the given time-to-live constant measured in\n+         * the given time unit of measure.\n+         * \n+         * @param timeToLive the constant amount of time an entry is available\n+         *        before it expires. A negative value results in entries that\n+         *        NEVER expire. A zero value results in entries that ALWAYS\n+         *        expire.\n+         * @param timeUnit the unit of time for the <code>timeToLive</code>\n+         *        parameter, must not be null.\n+         * @throws IllegalArgumentException if the time unit is null.\n+         */\n+        public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n+                                                  final TimeUnit timeUnit) {\n+            this(validateAndConvertToMillis(timeToLive, TimeUnit.MILLISECONDS));\n+        }\n+\n+        /**\n+         * Determine the expiration time for the given key-value entry.\n+         * \n+         * @param key the key for the entry (ignored).\n+         * @param value the value for the entry (ignored).\n+         * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n+         *         {@link #timeToLiveMillis} +\n+         *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n+         *         is returned indicating the entry never expires.\n+         */\n+        public long expirationTime(final K key, final V value) {\n+            if (timeToLiveMillis >= 0L) {\n+                // avoid numerical overflow\n+                final long now = System.currentTimeMillis();\n+                if (now > Long.MAX_VALUE - timeToLiveMillis) {\n+                    // expiration would be greater than Long.MAX_VALUE\n+                    // never expire\n+                    return -1;\n+                }\n+\n+                // timeToLiveMillis in the future\n+                return now + timeToLiveMillis;\n+            }\n+\n+            // never expire\n+            return -1L;\n+        }\n+    }\n+\n+    /**\n+     * A policy to determine the expiration time for key-value entries.\n+     * \n+     * @param <K> the key object type.\n+     * @param <V> the value object type\n+     * @since 4.0\n+     * @version $Id$\n+     */\n+    public static interface ExpirationPolicy<K, V>\n+        extends Serializable {\n+\n+        /**\n+         * Determine the expiration time for the given key-value entry.\n+         * \n+         * @param key the key for the entry.\n+         * @param value the value for the entry.\n+         * @return the expiration time value measured in milliseconds. A\n+         *         negative return value indicates the entry never expires.\n+         */\n+        long expirationTime(K key, V value);\n+    }\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * First validate the input parameters. If the parameters are valid, convert\n+     * the given time measured in the given units to the same time measured in\n+     * milliseconds. If the parameters are invalid, an\n+     * {@link IllegalArgumentException} is thrown.\n+     * \n+     * @param timeToLive the constant amount of time an entry is available\n+     *        before it expires. A negative value results in entries that NEVER\n+     *        expire. A zero value results in entries that ALWAYS expire.\n+     * @param timeUnit the unit of time for the <code>timeToLive</code>\n+     *        parameter, must not be null.\n+     * @throws IllegalArgumentException if the time unit is null.\n+     */\n+    private static long validateAndConvertToMillis(final long timeToLive,\n+                                                   final TimeUnit timeUnit) {\n+        if (timeUnit == null) {\n+            throw new IllegalArgumentException(\"Time unit must not be null\");\n+        }\n+        return timeUnit.convert(timeToLive, TimeUnit.MILLISECONDS);\n+    }\n+\n+    /** map used to manage expiration times for the actual map entries. */\n+    private final Map<Object, Long> expirationMap = new HashMap<Object, Long>();\n+\n+    /** the policy used to determine time-to-live values for map entries. */\n+    private final ExpirationPolicy<K, V> expiringPolicy;\n+\n+    /**\n+     * Default constructor. Constructs a map decorator that results in entries\n+     * NEVER expiring.\n+     */\n+    public PassiveExpiringMap() {\n+        this(-1L);\n+    }\n+\n+    /**\n+     * Construct a map decorator using the given expiration policy to determine\n+     * expiration times.\n+     * \n+     * @param expiringPolicy the policy used to determine expiration times of\n+     *        entries as they are added.\n+     */\n+    public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy) {\n+        this(expiringPolicy, new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * Construct a map decorator that decorates the given map and uses the given\n+     * expiration policy to determine expiration times. If there are any\n+     * elements already in the map being decorated, they will NEVER expire\n+     * unless they are replaced.\n+     * \n+     * @param expiringPolicy the policy used to determine expiration times of\n+     *        entries as they are added.\n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy,\n+                              final Map<K, V> map) {\n+        super(map);\n+        if (expiringPolicy == null) {\n+            throw new IllegalArgumentException(\"Policy must not be null.\");\n+        }\n+        this.expiringPolicy = expiringPolicy;\n+    }\n+\n+    /**\n+     * Construct a map decorator that decorates the given map using the given\n+     * time-to-live value measured in milliseconds to create and use a\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n+     * \n+     * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n+     *        entry is available before it expires. A negative value results in\n+     *        entries that NEVER expire. A zero value results in entries that\n+     *        ALWAYS expire.\n+     */\n+    public PassiveExpiringMap(final long timeToLiveMillis) {\n+        this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n+             new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * Construct a map decorator using the given time-to-live value measured in\n+     * milliseconds to create and use a\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. If there\n+     * are any elements already in the map being decorated, they will NEVER\n+     * expire unless they are replaced.\n+     * \n+     * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n+     *        entry is available before it expires. A negative value results in\n+     *        entries that NEVER expire. A zero value results in entries that\n+     *        ALWAYS expire.\n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(final long timeToLiveMillis, final Map<K, V> map) {\n+        this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n+             map);\n+    }\n+\n+    /**\n+     * Construct a map decorator using the given time-to-live value measured in\n+     * the given time units of measure to create and use a\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n+     * \n+     * @param timeToLive the constant amount of time an entry is available\n+     *        before it expires. A negative value results in entries that NEVER\n+     *        expire. A zero value results in entries that ALWAYS expire.\n+     * @param timeUnit the unit of time for the <code>timeToLive</code>\n+     *        parameter, must not be null.\n+     * @throws IllegalArgumentException if the time unit is null.\n+     */\n+    public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit) {\n+        this(validateAndConvertToMillis(timeToLive, timeUnit));\n+    }\n+\n+    /**\n+     * Construct a map decorator that decorates the given map using the given\n+     * time-to-live value measured in the given time units of measure to create\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. This policy\n+     * is used to determine expiration times. If there are any elements already\n+     * in the map being decorated, they will NEVER expire unless they are\n+     * replaced.\n+     * \n+     * @param timeToLive the constant amount of time an entry is available\n+     *        before it expires. A negative value results in entries that NEVER\n+     *        expire. A zero value results in entries that ALWAYS expire.\n+     * @param timeUnit the unit of time for the <code>timeToLive</code>\n+     *        parameter, must not be null.\n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the time unit is null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit, final Map<K, V> map) {\n+        this(validateAndConvertToMillis(timeToLive, timeUnit), map);\n+    }\n+\n+    /**\n+     * Constructs a map decorator that decorates the given map and results in\n+     * entries NEVER expiring. If there are any elements already in the map\n+     * being decorated, they also will NEVER expire.\n+     * \n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(final Map<K, V> map) {\n+        this(-1L, map);\n+    }\n+\n+    /**\n+     * Normal {@link Map#clear()} behavior with the addition of clearing all\n+     * expiration entries as well.\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        expirationMap.clear();\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to determining the\n+     * contains result.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean containsKey(final Object key) {\n+        removeIfExpired(key, now());\n+        return super.containsKey(key);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to determining the\n+     * contains result.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean containsValue(final Object value) {\n+        removeAllExpired(now());\n+        return super.containsValue(value);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the entry set.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+        removeAllExpired(now());\n+        return super.entrySet();\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the entry value.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V get(final Object key) {\n+        removeIfExpired(key, now());\n+        return super.get(key);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to determining if it is empty.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        removeAllExpired(now());\n+        return super.isEmpty();\n+    }\n+\n+    /**\n+     * Determines if the given expiration time is less than <code>now</code>.\n+     * \n+     * @param now the time in milliseconds used to compare against the\n+     *        expiration time.\n+     * @param expirationTimeObject the expiration time value retrieved from\n+     *        {@link #expirationMap}, can be null.\n+     * @return <code>true</code> if <code>expirationTimeObject</code> is &ge; 0\n+     *         and <code>expirationTimeObject</code> &lt; <code>now</code>.\n+     *         <code>false</code> otherwise.\n+     */\n+    private boolean isExpired(final long now, final Long expirationTimeObject) {\n+        if (expirationTimeObject != null) {\n+            final long expirationTime = expirationTimeObject.longValue();\n+            return expirationTime >= 0 && now >= expirationTime;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the key set.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        removeAllExpired(now());\n+        return super.keySet();\n+    }\n+\n+    /**\n+     * The current time in milliseconds.\n+     */\n+    private long now() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        return put(key, value, now());\n+    }\n+\n+    /**\n+     * Add the given key-value pair to this map as well as recording the entry's expiration time based on\n+     * the current time in milliseconds, <code>now</code> and this map's {@link #expiringPolicy}.\n+     */\n+    private V put(final K key, final V value, final long now) {\n+        // record expiration time of new entry\n+        final long expirationTime = expiringPolicy.expirationTime(key, value);\n+        expirationMap.put(key, Long.valueOf(expirationTime));\n+\n+        return super.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Normal {@link Map#remove(Object)} behavior with the addition of removing\n+     * any expiration entry as well.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V remove(final Object key) {\n+        expirationMap.remove(key);\n+        return super.remove(key);\n+    }\n+\n+    /**\n+     * Removes all entries in the map whose expiration time is less than\n+     * <code>now</code>. The exceptions are entries with negative expiration\n+     * times; those entries are never removed.\n+     * \n+     * @see #isExpired(long, Long)\n+     */\n+    private void removeAllExpired(final long now) {\n+        final Iterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet()\n+            .iterator();\n+        while (iter.hasNext()) {\n+            final Map.Entry<Object, Long> expirationEntry = iter.next();\n+            if (isExpired(now, expirationEntry.getValue())) {\n+                // remove entry from collection\n+                super.remove(expirationEntry.getKey());\n+                // remove entry from expiration map\n+                iter.remove();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Removes the entry with the given key if the entry's expiration time is\n+     * less than <code>now</code>. If the entry has a negative expiration time,\n+     * the entry is never removed.\n+     */\n+    private void removeIfExpired(final Object key, final long now) {\n+        final Long expirationTimeObject = expirationMap.get(key);\n+        if (isExpired(now, expirationTimeObject)) {\n+            remove(key);\n+        }\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the size.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int size() {\n+        removeAllExpired(now());\n+        return super.size();\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    // (1) should only fail if input stream is incorrect\n+    private void readObject(final ObjectInputStream in)\n+        throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out)\n+        throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the value collection.\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        removeAllExpired(now());\n+        return super.values();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Decorates another <code>Map</code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This map exists to provide validation for the decorated map.\n+ * It is normally created to decorate an empty map.\n+ * If an object cannot be added to the map, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null keys are added to the map.\n+ * <pre>Map map = PredicatedSet.decorate(new HashMap(), NotNullPredicate.INSTANCE, null);</pre>\n+ * <p>\n+ * <strong>Note that PredicatedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedMap<K, V>\n+        extends AbstractInputCheckedMapDecorator<K, V>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7412622456128415156L;\n+\n+    /** The key predicate to use */\n+    protected final Predicate<? super K> keyPredicate;\n+\n+    /** The value predicate to use */\n+    protected final Predicate<? super V> valuePredicate;\n+\n+    /**\n+     * Factory method to create a predicated (validating) map.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @return a new predicated map\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map,\n+                                                           final Predicate<? super K> keyPredicate,\n+                                                           final Predicate<? super V> valuePredicate) {\n+        return new PredicatedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n+                            final Predicate<? super V> valuePredicate) {\n+        super(map);\n+        this.keyPredicate = keyPredicate;\n+        this.valuePredicate = valuePredicate;\n+        \n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            final Map.Entry<K, V> entry = it.next();\n+            validate(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Validates a key value pair.\n+     * \n+     * @param key  the key to validate\n+     * @param value  the value to validate\n+     * @throws IllegalArgumentException if invalid\n+     */\n+    protected void validate(final K key, final V value) {\n+        if (keyPredicate != null && keyPredicate.evaluate(key) == false) {\n+            throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n+        }\n+        if (valuePredicate != null && valuePredicate.evaluate(value) == false) {\n+            throw new IllegalArgumentException(\"Cannot add value - Predicate rejected it\");\n+        }\n+    }\n+\n+    /**\n+     * Override to validate an object set into the map via <code>setValue</code>.\n+     * \n+     * @param value  the value to validate\n+     * @return the value itself\n+     * @throws IllegalArgumentException if invalid\n+     * @since 3.1\n+     */\n+    @Override\n+    protected V checkSetValue(final V value) {\n+        if (valuePredicate.evaluate(value) == false) {\n+            throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n+        }\n+        return value;\n+    }\n+\n+    /**\n+     * Override to only return true when there is a value transformer.\n+     * \n+     * @return true if a value predicate is in use\n+     * @since 3.1\n+     */\n+    @Override\n+    protected boolean isSetValueChecking() {\n+        return valuePredicate != null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(final K key, final V value) {\n+        validate(key, value);\n+        return map.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+            validate(entry.getKey(), entry.getValue());\n+        }\n+        super.putAll(mapToCopy);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Comparator;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Decorates another <code>SortedMap </code> to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This map exists to provide validation for the decorated map.\n+ * It is normally created to decorate an empty map.\n+ * If an object cannot be added to the map, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null keys are added to the map.\n+ * <pre>SortedMap map = PredicatedSortedSet.decorate(new TreeMap(), NotNullPredicate.INSTANCE, null);</pre>\n+ * <p>\n+ * <strong>Note that PredicatedSortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSortedMap<K, V> extends PredicatedMap<K, V> implements SortedMap<K, V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3359846175935304332L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) sorted map.\n+     * <p>\n+     * If there are any elements already in the list being decorated, they\n+     * are validated.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @return a new predicated sorted map\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n+            final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyPredicate  the predicate to validate the keys, null means no check\n+     * @param valuePredicate  the predicate to validate to values, null means no check\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected PredicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n+            final Predicate<? super V> valuePredicate) {\n+        super(map, keyPredicate, valuePredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return getSortedMap().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return getSortedMap().lastKey();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return getSortedMap().comparator();\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+        return new PredicatedSortedMap<K, V>(map, keyPredicate, valuePredicate);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/ReferenceIdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.Reference;\n+\n+/**\n+ * A <code>Map</code> implementation that allows mappings to be\n+ * removed by the garbage collector and matches keys and values based\n+ * on <code>==</code> not <code>equals()</code>.\n+ * <p>\n+ * <p>\n+ * When you construct a <code>ReferenceIdentityMap</code>, you can specify what kind\n+ * of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The default constructor uses hard keys and soft values, providing a\n+ * memory-sensitive cache.\n+ * <p>\n+ * This map is similar to\n+ * {@link org.apache.commons.collections4.map.ReferenceMap ReferenceMap}.\n+ * It differs in that keys and values in this class are compared using <code>==</code>.\n+ * <p>\n+ * This map will violate the detail of various Map and map view contracts.\n+ * As a general rule, don't compare this map to other maps.\n+ * <p>\n+ * This {@link java.util.Map Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceIdentityMap</code>.\n+ * Remember that synchronization will not stop the garbage collecter removing entries.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * <strong>Note that ReferenceIdentityMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @see java.lang.ref.Reference\n+ *\n+ * @since 3.0 (previously in main package v2.1)\n+ * @version $Id$\n+ */\n+public class ReferenceIdentityMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1266190134568365852L;\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use hard references to keys and soft references to values.\n+     */\n+    public ReferenceIdentityMap() {\n+        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n+                DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     */\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param purgeValues should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n+            final boolean purgeValues) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> with the\n+     * specified reference types, load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     */\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n+            final int capacity, final float loadFactor) {\n+        super(keyType, valueType, capacity, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> with the\n+     * specified reference types, load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceIdentityMap(final ReferenceStrength keyType, final ReferenceStrength valueType,\n+            final int capacity, final float loadFactor, final boolean purgeValues) {\n+        super(keyType, valueType, capacity, loadFactor, purgeValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hash code for the key specified.\n+     * <p>\n+     * This implementation uses the identity hash code.\n+     * \n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    @Override\n+    protected int hash(final Object key) {\n+        return System.identityHashCode(key);\n+    }\n+\n+    /**\n+     * Gets the hash code for a MapEntry.\n+     * <p>\n+     * This implementation uses the identity hash code.\n+     * \n+     * @param key  the key to get a hash code for, may be null\n+     * @param value  the value to get a hash code for, may be null\n+     * @return the hash code, as per the MapEntry specification\n+     */\n+    @Override\n+    protected int hashEntry(final Object key, final Object value) {\n+        return System.identityHashCode(key) ^\n+               System.identityHashCode(value);\n+    }\n+\n+    /**\n+     * Compares two keys for equals.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison and uses <code>==</code>.\n+     * \n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualKey(final Object key1, Object key2) {\n+        key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<?>) key2).get();\n+        return key1 == key2;\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * <p>\n+     * This implementation uses <code>==</code>.\n+     * \n+     * @param value1  the first value to compare passed in from outside\n+     * @param value2  the second value extracted from the entry via <code>getValue()</code>\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n+        return value1 == value2;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/ReferenceMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * A <code>Map</code> implementation that allows mappings to be\n+ * removed by the garbage collector.\n+ * <p>\n+ * When you construct a <code>ReferenceMap</code>, you can specify what kind\n+ * of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link java.lang.ref.Reference Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The keys can be configured to be weak but the values hard,\n+ * in which case this class will behave like a\n+ * <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n+ * <code>WeakHashMap</code></a>. However, you can also specify hard keys and\n+ * weak values, or any other combination. The default constructor uses\n+ * hard keys and soft values, providing a memory-sensitive cache.\n+ * <p>\n+ * This map is similar to\n+ * {@link org.apache.commons.collections4.map.ReferenceIdentityMap ReferenceIdentityMap}.\n+ * It differs in that keys and values in this class are compared using <code>equals()</code>.\n+ * <p>\n+ * This {@link java.util.Map Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceMap</code>.\n+ * Remember that synchronization will not stop the garbage collecter removing entries.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * <strong>Note that ReferenceMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * NOTE: As from Commons Collections 3.1 this map extends <code>AbstractReferenceMap</code>\n+ * (previously it extended AbstractMap). As a result, the implementation is now\n+ * extensible and provides a <code>MapIterator</code>.\n+ *\n+ * @see java.lang.ref.Reference\n+ *\n+ * @since 3.0 (previously in main package v2.1)\n+ * @version $Id$\n+ */\n+public class ReferenceMap<K, V> extends AbstractReferenceMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1555089888138299607L;\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use hard references to keys and soft references to values.\n+     */\n+    public ReferenceMap() {\n+        super(ReferenceStrength.HARD, ReferenceStrength.SOFT, DEFAULT_CAPACITY,\n+                DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     */\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param purgeValues should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final boolean purgeValues) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> with the\n+     * specified reference types, load factor and initial\n+     * capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     */\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n+            final float loadFactor) {\n+        super(keyType, valueType, capacity, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> with the\n+     * specified reference types, load factor and initial\n+     * capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT}, \n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link AbstractReferenceMap.ReferenceStrength#HARD HARD},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#SOFT SOFT},\n+     *   {@link AbstractReferenceMap.ReferenceStrength#WEAK WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceMap(final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n+            final float loadFactor, final boolean purgeValues) {\n+        super(keyType, valueType, capacity, loadFactor, purgeValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/SingletonMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.Serializable;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.BoundedMap;\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.iterators.SingletonIterator;\n+import org.apache.commons.collections4.keyvalue.TiedMapEntry;\n+\n+/**\n+ * A <code>Map</code> implementation that holds a single item and is fixed size.\n+ * <p>\n+ * The single key/value pair is specified at creation.\n+ * The map is fixed size so any action that would change the size is disallowed.\n+ * However, the <code>put</code> or <code>setValue</code> methods can <i>change</i>\n+ * the value associated with the key.\n+ * <p>\n+ * If trying to remove or clear the map, an UnsupportedOperationException is thrown.\n+ * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\n+ * The put method will only suceed if the key specified is the same as the \n+ * singleton key.\n+ * <p>\n+ * The key and value can be obtained by:\n+ * <ul>\n+ * <li>normal Map methods and views\n+ * <li>the <code>MapIterator</code>, see {@link #mapIterator()}\n+ * <li>the <code>KeyValue</code> interface (just cast - no object creation)\n+ * </ul>\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class SingletonMap<K, V>\n+        implements OrderedMap<K, V>, BoundedMap<K, V>, KeyValue<K, V>, Serializable, Cloneable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8931271118676803261L;\n+\n+    /** Singleton key */\n+    private final K key;\n+    /** Singleton value */\n+    private V value;\n+\n+    /**\n+     * Constructor that creates a map of <code>null</code> to <code>null</code>.\n+     */\n+    public SingletonMap() {\n+        super();\n+        this.key = null;\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value.\n+     *\n+     * @param key  the key to use\n+     * @param value  the value to use\n+     */\n+    public SingletonMap(final K key, final V value) {\n+        super();\n+        this.key = key;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value as a <code>KeyValue</code>.\n+     *\n+     * @param keyValue  the key value pair to use\n+     */\n+    public SingletonMap(final KeyValue<K, V> keyValue) {\n+        super();\n+        this.key = keyValue.getKey();\n+        this.value = keyValue.getValue();\n+    }\n+\n+    /**\n+     * Constructor specifying the key and value as a <code>MapEntry</code>.\n+     *\n+     * @param mapEntry  the mapEntry to use\n+     */\n+    public SingletonMap(final Map.Entry<K, V> mapEntry) {\n+        super();\n+        this.key = mapEntry.getKey();\n+        this.value = mapEntry.getValue();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy, must be size 1\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the size is not 1\n+     */\n+    public SingletonMap(final Map<K, V> map) {\n+        super();\n+        if (map.size() != 1) {\n+            throw new IllegalArgumentException(\"The map size must be 1\");\n+        }\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        this.key = entry.getKey();\n+        this.value = entry.getValue();\n+    }\n+\n+    // KeyValue\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key.\n+     *\n+     * @return the key \n+     */\n+    public K getKey() {\n+        return key;\n+    }\n+\n+    /**\n+     * Gets the value.\n+     *\n+     * @return the value\n+     */\n+    public V getValue() {\n+        return value;\n+    }\n+\n+    /**\n+     * Sets the value.\n+     *\n+     * @param value  the new value to set\n+     * @return the old value\n+     */\n+    public V setValue(final V value) {\n+        final V old = this.value;\n+        this.value = value;\n+        return old;\n+    }\n+\n+    // BoundedMap\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is the map currently full, always true.\n+     *\n+     * @return true always\n+     */\n+    public boolean isFull() {\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the map, always 1.\n+     * \n+     * @return 1 always\n+     */\n+    public int maxSize() {\n+        return 1;\n+    }\n+\n+    // Map\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public V get(final Object key) {\n+        if (isEqualKey(key)) {\n+            return value;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map, always 1.\n+     * \n+     * @return the size of 1\n+     */\n+    public int size() {\n+        return 1;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty, which it never is.\n+     * \n+     * @return false always\n+     */\n+    public boolean isEmpty() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(final Object key) {\n+        return isEqualKey(key);\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsValue(final Object value) {\n+        return isEqualValue(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map where the key must match the existing key.\n+     * <p>\n+     * An IllegalArgumentException is thrown if the key does not match as the map\n+     * is fixed size.\n+     * \n+     * @param key  the key to set, must be the key of the map\n+     * @param value  the value to set\n+     * @return the value previously mapped to this key, null if none\n+     * @throws IllegalArgumentException if the key does not match\n+     */\n+    public V put(final K key, final V value) {\n+        if (isEqualKey(key)) {\n+            return setValue(value);\n+        }\n+        throw new IllegalArgumentException(\"Cannot put new key/value pair - Map is fixed size singleton\");\n+    }\n+\n+    /**\n+     * Puts the values from the specified map into this map.\n+     * <p>\n+     * The map must be of size 0 or size 1.\n+     * If it is size 1, the key must match the key of this map otherwise an\n+     * IllegalArgumentException is thrown.\n+     * \n+     * @param map  the map to add, must be size 0 or 1, and the key must match\n+     * @throws NullPointerException if the map is null\n+     * @throws IllegalArgumentException if the key does not match\n+     */\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        switch (map.size()) {\n+            case 0:\n+                return;\n+\n+            case 1:\n+                final Map.Entry<? extends K, ? extends V> entry = map.entrySet().iterator().next();\n+                put(entry.getKey(), entry.getValue());\n+                return;\n+\n+            default:\n+                throw new IllegalArgumentException(\"The map size must be 0 or 1\");\n+        }\n+    }\n+    \n+    /**\n+     * Unsupported operation.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     * @throws UnsupportedOperationException always\n+     */\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Unsupported operation.\n+     */\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made via <code>setValue</code> affect this map.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     * \n+     * @return the entrySet view\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Map.Entry<K, V> entry = new TiedMapEntry<K, V>(this, getKey());\n+        return Collections.singleton(entry);\n+    }\n+    \n+    /**\n+     * Gets the unmodifiable keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     * \n+     * @return the keySet view\n+     */\n+    public Set<K> keySet() {\n+        return Collections.singleton(key);\n+    }\n+\n+    /**\n+     * Gets the unmodifiable values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     * \n+     * @return the values view\n+     */\n+    public Collection<V> values() {\n+        return new SingletonValues<V>(this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new SingletonMapIterator<K, V>(this);\n+    }\n+\n+    /**\n+     * Gets the first (and only) key in the map.\n+     * \n+     * @return the key\n+     */\n+    public K firstKey() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the last (and only) key in the map.\n+     * \n+     * @return the key\n+     */\n+    public K lastKey() {\n+        return getKey();\n+    }\n+\n+    /**\n+     * Gets the next key after the key specified, always null.\n+     * \n+     * @param key  the next key\n+     * @return null always\n+     */\n+    public K nextKey(final K key) {\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the previous key before the key specified, always null.\n+     * \n+     * @param key  the next key\n+     * @return null always\n+     */\n+    public K previousKey(final K key) {\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares the specified key to the stored key.\n+     * \n+     * @param key  the key to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualKey(final Object key) {\n+        return key == null ? getKey() == null : key.equals(getKey());\n+    }\n+\n+    /**\n+     * Compares the specified value to the stored value.\n+     * \n+     * @param value  the value to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(final Object value) {\n+        return value == null ? getValue() == null : value.equals(getValue());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * SingletonMapIterator.\n+     */\n+    static class SingletonMapIterator<K, V> implements OrderedMapIterator<K, V>, ResettableIterator<K> {\n+        private final SingletonMap<K, V> parent;\n+        private boolean hasNext = true;\n+        private boolean canGetSet = false;\n+        \n+        SingletonMapIterator(final SingletonMap<K, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        public boolean hasNext() {\n+            return hasNext;\n+        }\n+\n+        public K next() {\n+            if (hasNext == false) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            hasNext = false;\n+            canGetSet = true;\n+            return parent.getKey();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return hasNext == false;\n+        }\n+\n+        public K previous() {\n+            if (hasNext == true) {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n+            }\n+            hasNext = true;\n+            return parent.getKey();\n+        }\n+\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public K getKey() {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return parent.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return parent.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            if (canGetSet == false) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return parent.setValue(value);\n+        }\n+        \n+        public void reset() {\n+            hasNext = true;\n+        }\n+        \n+        @Override\n+        public String toString() {\n+            if (hasNext) {\n+                return \"Iterator[]\";\n+            }\n+            return \"Iterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+        }\n+    }\n+    \n+    /**\n+     * Values implementation for the SingletonMap.\n+     * This class is needed as values is a view that must update as the map updates.\n+     */\n+    static class SingletonValues<V> extends AbstractSet<V> implements Serializable {\n+        private static final long serialVersionUID = -3689524741863047872L;\n+        private final SingletonMap<?, V> parent;\n+\n+        SingletonValues(final SingletonMap<?, V> parent) {\n+            super();\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return 1;\n+        }\n+        @Override\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+        @Override\n+        public boolean contains(final Object object) {\n+            return parent.containsValue(object);\n+        }\n+        @Override\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new SingletonIterator<V>(parent.getValue(), false);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the key or value.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> clone() {\n+        try {\n+            return (SingletonMap<K, V>) super.clone();\n+        } catch (final CloneNotSupportedException ex) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    /**\n+     * Compares this map with another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        final Map<?,?> other = (Map<?,?>) obj;\n+        if (other.size() != 1) {\n+            return false;\n+        }\n+        final Map.Entry<?,?> entry = other.entrySet().iterator().next();\n+        return isEqualKey(entry.getKey()) && isEqualValue(entry.getValue());\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     * \n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (getKey() == null ? 0 : getKey().hashCode()) ^\n+               (getValue() == null ? 0 : getValue().hashCode()); \n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     * \n+     * @return a string version of the map\n+     */\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(128)\n+            .append('{')\n+            .append(getKey() == this ? \"(this Map)\" : getKey())\n+            .append('=')\n+            .append(getValue() == this ? \"(this Map)\" : getValue())\n+            .append('}')\n+            .toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/StaticBucketMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.KeyValue;\n+\n+/**\n+ * A StaticBucketMap is an efficient, thread-safe implementation of\n+ * <code>java.util.Map</code> that performs well in in a highly\n+ * thread-contentious environment.  The map supports very efficient\n+ * {@link #get(Object) get}, {@link #put(Object,Object) put}, \n+ * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\n+ * operations, assuming (approximate) uniform hashing and\n+ * that the number of entries does not exceed the number of buckets.  If the\n+ * number of entries exceeds the number of buckets or if the hash codes of the\n+ * objects are not uniformly distributed, these operations have a worst case\n+ * scenario that is proportional to the number of elements in the map\n+ * (<i>O(n)</i>).<p>\n+ *\n+ * Each bucket in the hash table has its own monitor, so two threads can \n+ * safely operate on the map at the same time, often without incurring any \n+ * monitor contention.  This means that you don't have to wrap instances\n+ * of this class with {@link java.util.Collections#synchronizedMap(Map)};\n+ * instances are already thread-safe.  Unfortunately, however, this means \n+ * that this map implementation behaves in ways you may find disconcerting.  \n+ * Bulk operations, such as {@link #putAll(Map) putAll} or the\n+ * {@link Collection#retainAll(Collection) retainAll} operation in collection \n+ * views, are <i>not</i> atomic.  If two threads are simultaneously \n+ * executing \n+ *\n+ * <pre>\n+ *   staticBucketMapInstance.putAll(map);\n+ * </pre>\n+ *\n+ * and\n+ *\n+ * <pre>\n+ *   staticBucketMapInstance.entrySet().removeAll(map.entrySet());\n+ * </pre>\n+ *\n+ * then the results are generally random.  Those two statement could cancel\n+ * each other out, leaving <code>staticBucketMapInstance</code> essentially \n+ * unchanged, or they could leave some random subset of <code>map</code> in \n+ * <code>staticBucketMapInstance</code>.<p>\n+ *\n+ * Also, much like an encyclopedia, the results of {@link #size()} and \n+ * {@link #isEmpty()} are out-of-date as soon as they are produced.<p>\n+ *\n+ * The iterators returned by the collection views of this class are <i>not</i>\n+ * fail-fast.  They will <i>never</i> raise a \n+ * {@link java.util.ConcurrentModificationException}.  Keys and values \n+ * added to the map after the iterator is created do not necessarily appear\n+ * during iteration.  Similarly, the iterator does not necessarily fail to \n+ * return keys and values that were removed after the iterator was created.<p>\n+ *\n+ * Finally, unlike {@link java.util.HashMap}-style implementations, this\n+ * class <i>never</i> rehashes the map.  The number of buckets is fixed \n+ * at construction time and never altered.  Performance may degrade if \n+ * you do not allocate enough buckets upfront.<p>\n+ *\n+ * The {@link #atomic(Runnable)} method is provided to allow atomic iterations\n+ * and bulk operations; however, overuse of {@link #atomic(Runnable) atomic}\n+ * will basically result in a map that's slower than an ordinary synchronized\n+ * {@link java.util.HashMap}.\n+ *\n+ * Use this class if you do not require reliable bulk operations and \n+ * iterations, or if you can make your own guarantees about how bulk \n+ * operations will affect the map.<p>\n+ *\n+ * @since 3.0 (previously in main package v2.1)\n+ * @version $Id$\n+ */\n+public final class StaticBucketMap<K, V> extends AbstractIterableMap<K, V> {\n+\n+    /** The default number of buckets to use */\n+    private static final int DEFAULT_BUCKETS = 255;\n+    /** The array of buckets, where the actual data is held */\n+    private final Node<K, V>[] buckets;\n+    /** The matching array of locks */\n+    private final Lock[] locks;\n+\n+    /**\n+     * Initializes the map with the default number of buckets (255).\n+     */\n+    public StaticBucketMap() {\n+        this(DEFAULT_BUCKETS);\n+    }\n+\n+    /**\n+     * Initializes the map with a specified number of buckets.  The number\n+     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n+     * ensures this). The number of buckets is inversely proportional to the\n+     * chances for thread contention.  The fewer buckets, the more chances for\n+     * thread contention.  The more buckets the fewer chances for thread\n+     * contention.\n+     *\n+     * @param numBuckets  the number of buckets for this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public StaticBucketMap(final int numBuckets) {\n+        int size = Math.max(17, numBuckets);\n+\n+        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n+        if (size % 2 == 0) {\n+            size--;\n+        }\n+\n+        buckets = new Node[size];\n+        locks = new Lock[size];\n+\n+        for (int i = 0; i < size; i++) {\n+            locks[i] = new Lock();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determine the exact hash entry for the key.  The hash algorithm\n+     * is rather simplistic, but it does the job:\n+     *\n+     * <pre>\n+     *   He = |Hk mod n|\n+     * </pre>\n+     *\n+     * <p>\n+     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n+     *   the number of buckets.\n+     * </p>\n+     */\n+    private final int getHash(final Object key) {\n+        if (key == null) {\n+            return 0;\n+        }\n+        int hash = key.hashCode();\n+        hash += ~(hash << 15);\n+        hash ^= (hash >>> 10);\n+        hash += (hash << 3);\n+        hash ^= (hash >>> 6);\n+        hash += ~(hash << 11);\n+        hash ^= (hash >>> 16);\n+        hash %= buckets.length;\n+        return (hash < 0) ? hash * -1 : hash;\n+    }\n+\n+    /**\n+     * Gets the current size of the map.\n+     * The value is computed fresh each time the method is called.\n+     * \n+     * @return the current size\n+     */\n+    public int size() {\n+        int cnt = 0;\n+\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized(locks[i]) {\n+                cnt += locks[i].size;\n+            }\n+        }\n+        return cnt;\n+    }\n+\n+    /**\n+     * Checks if the size is currently zero.\n+     * \n+     * @return true if empty\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    /**\n+     * Gets the value associated with the key.\n+     * \n+     * @param key  the key to retrieve\n+     * @return the associated value\n+     */\n+    public V get(final Object key) {\n+        final int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    return n.value;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks if the map contains the specified key.\n+     * \n+     * @param key  the key to check\n+     * @return true if found\n+     */\n+    public boolean containsKey(final Object key) {\n+        final int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    return true;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the map contains the specified value.\n+     * \n+     * @param value  the value to check\n+     * @return true if found\n+     */\n+    public boolean containsValue(final Object value) {\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized (locks[i]) {\n+                Node<K, V> n = buckets[i];\n+\n+                while (n != null) {\n+                    if (n.value == value || (n.value != null && n.value.equals(value))) {\n+                        return true;\n+                    }\n+\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a new key value mapping into the map.\n+     * \n+     * @param key  the key to use\n+     * @param value  the value to use\n+     * @return the previous mapping for the key\n+     */\n+    public V put(final K key, final V value) {\n+        final int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+\n+            if (n == null) {\n+                n = new Node<K, V>();\n+                n.key = key;\n+                n.value = value;\n+                buckets[hash] = n;\n+                locks[hash].size++;\n+                return null;\n+            }\n+\n+            // Set n to the last node in the linked list.  Check each key along the way\n+            //  If the key is found, then change the value of that node and return\n+            //  the old value.\n+            for (Node<K, V> next = n; next != null; next = next.next) {\n+                n = next;\n+\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    final V returnVal = n.value;\n+                    n.value = value;\n+                    return returnVal;\n+                }\n+            }\n+\n+            // The key was not found in the current list of nodes, add it to the end\n+            //  in a new node.\n+            final Node<K, V> newNode = new Node<K, V>();\n+            newNode.key = key;\n+            newNode.value = value;\n+            n.next = newNode;\n+            locks[hash].size++;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified key from the map.\n+     * \n+     * @param key  the key to remove\n+     * @return the previous value at this key\n+     */\n+    public V remove(final Object key) {\n+        final int hash = getHash(key);\n+\n+        synchronized (locks[hash]) {\n+            Node<K, V> n = buckets[hash];\n+            Node<K, V> prev = null;\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    // Remove this node from the linked list of nodes.\n+                    if (null == prev) {\n+                        // This node was the head, set the next node to be the new head.\n+                        buckets[hash] = n.next;\n+                    } else {\n+                        // Set the next node of the previous node to be the node after this one.\n+                        prev.next = n.next;\n+                    }\n+                    locks[hash].size--;\n+                    return n.value;\n+                }\n+\n+                prev = n;\n+                n = n.next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key set.\n+     * \n+     * @return the key set\n+     */\n+    public Set<K> keySet() {\n+        return new KeySet();\n+    }\n+\n+    /**\n+     * Gets the values.\n+     * \n+     * @return the values\n+     */\n+    public Collection<V> values() {\n+        return new Values();\n+    }\n+\n+    /**\n+     * Gets the entry set.\n+     * \n+     * @return the entry set\n+     */\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return new EntrySet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts all the entries from the specified map into this map.\n+     * This operation is <b>not atomic</b> and may have undesired effects.\n+     * \n+     * @param map  the map of entries to add\n+     */\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Clears the map of all entries.\n+     */\n+    public void clear() {\n+        for (int i = 0; i < buckets.length; i++) {\n+            final Lock lock = locks[i];\n+            synchronized (lock) {\n+                buckets[i] = null;\n+                lock.size = 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compares this map to another, as per the Map specification.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map<?, ?> == false) {\n+            return false;\n+        }\n+        final Map<?, ?> other = (Map<?, ?>) obj;\n+        return entrySet().equals(other.entrySet());\n+    }\n+\n+    /**\n+     * Gets the hash code, as per the Map specification.\n+     * \n+     * @return the hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 0;\n+\n+        for (int i = 0; i < buckets.length; i++) {\n+            synchronized (locks[i]) {\n+                Node<K, V> n = buckets[i];\n+\n+                while (n != null) {\n+                    hashCode += n.hashCode();\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return hashCode;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The Map.Entry for the StaticBucketMap.\n+     */\n+    private static final class Node<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n+        protected K key;\n+        protected V value;\n+        protected Node<K, V> next;\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return ((key == null ? 0 : key.hashCode()) ^\n+                    (value == null ? 0 : value.hashCode()));\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry<?, ?> == false) {\n+                return false;\n+            }\n+\n+            final Map.Entry<?, ?> e2 = (Map.Entry<?, ?>) obj;\n+            return (\n+                (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n+                (value == null ? e2.getValue() == null : value.equals(e2.getValue())));\n+        }\n+\n+        public V setValue(final V obj) {\n+            final V retVal = value;\n+            value = obj;\n+            return retVal;\n+        }\n+    }\n+\n+    /**\n+     * The lock object, which also includes a count of the nodes in this lock.\n+     */\n+    private final static class Lock {\n+        public int size;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    private class BaseIterator {\n+        private final ArrayList<Map.Entry<K, V>> current = new ArrayList<Map.Entry<K,V>>();\n+        private int bucket;\n+        private Map.Entry<K, V> last;\n+\n+        public boolean hasNext() {\n+            if (current.size() > 0) {\n+                return true;\n+            }\n+            while (bucket < buckets.length) {\n+                synchronized (locks[bucket]) {\n+                    Node<K, V> n = buckets[bucket];\n+                    while (n != null) {\n+                        current.add(n);\n+                        n = n.next;\n+                    }\n+                    bucket++;\n+                    if (current.size() > 0) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        protected Map.Entry<K, V> nextEntry() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            last = current.remove(current.size() - 1);\n+            return last;\n+        }\n+\n+        public void remove() {\n+            if (last == null) {\n+                throw new IllegalStateException();\n+            }\n+            StaticBucketMap.this.remove(last.getKey());\n+            last = null;\n+        }\n+    }\n+\n+    private class EntryIterator extends BaseIterator implements Iterator<Map.Entry<K, V>> {\n+\n+        public Map.Entry<K, V> next() {\n+            return nextEntry();\n+        }\n+\n+    }\n+\n+    private class ValueIterator extends BaseIterator implements Iterator<V> {\n+\n+        public V next() {\n+            return nextEntry().getValue();\n+        }\n+\n+    }\n+\n+    private class KeyIterator extends BaseIterator implements Iterator<K> {\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+\n+    }\n+\n+    private class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n+\n+        @Override\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            return new EntryIterator();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final int hash = getHash(entry.getKey());\n+            synchronized (locks[hash]) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry<?, ?> == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            final int hash = getHash(entry.getKey());\n+            synchronized (locks[hash]) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) {\n+                        StaticBucketMap.this.remove(n.getKey());\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+    private class KeySet extends AbstractSet<K> {\n+\n+        @Override\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new KeyIterator();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            return StaticBucketMap.this.containsKey(obj);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            final int hash = getHash(obj);\n+            synchronized (locks[hash]) {\n+                for (Node<K, V> n = buckets[hash]; n != null; n = n.next) {\n+                    final Object k = n.getKey();\n+                    if ((k == obj) || ((k != null) && k.equals(obj))) {\n+                        StaticBucketMap.this.remove(k);\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    private class Values extends AbstractCollection<V> {\n+\n+        @Override\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new ValueIterator();\n+        }\n+\n+    }\n+\n+    /**\n+     *  Prevents any operations from occurring on this map while the\n+     *  given {@link Runnable} executes.  This method can be used, for\n+     *  instance, to execute a bulk operation atomically: \n+     *\n+     *  <pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            staticBucketMapInstance.putAll(map);\n+     *        }\n+     *    });\n+     *  </pre>\n+     *\n+     *  It can also be used if you need a reliable iterator:\n+     *\n+     *  <pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            Iterator iterator = staticBucketMapInstance.iterator();\n+     *            while (iterator.hasNext()) {\n+     *                foo(iterator.next();\n+     *            }\n+     *        }\n+     *    });\n+     *  </pre>\n+     *\n+     *  <b>Implementation note:</b> This method requires a lot of time\n+     *  and a ton of stack space.  Essentially a recursive algorithm is used\n+     *  to enter each bucket's monitor.  If you have twenty thousand buckets\n+     *  in your map, then the recursive method will be invoked twenty thousand\n+     *  times.  You have been warned.\n+     *\n+     *  @param r  the code to execute atomically\n+     */\n+    public void atomic(final Runnable r) {\n+        if (r == null) {\n+            throw new NullPointerException();\n+        }\n+        atomic(r, 0);\n+    }\n+\n+    private void atomic(final Runnable r, final int bucket) {\n+        if (bucket >= buckets.length) {\n+            r.run();\n+            return;\n+        }\n+        synchronized (locks[bucket]) {\n+            atomic(r, bucket + 1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another <code>Map</code> to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * @see org.apache.commons.collections.splitmap.TransformedMap\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedMap<K, V>\n+        extends AbstractInputCheckedMapDecorator<K, V>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 7023152376788900464L;\n+\n+    /** The transformer to use for the key */\n+    protected final Transformer<? super K, ? extends K> keyTransformer;\n+    /** The transformer to use for the value */\n+    protected final Transformer<? super V, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedMap(Map, Transformer, Transformer)}.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n+     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @return a new transformed map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming map that will transform\n+     * existing contents of the specified map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingMap(Map, Transformer, Transformer)}.\n+     *\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n+     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @return a new transformed map\n+     * @throws IllegalArgumentException if map is null\n+     * @since 3.2\n+     */\n+    public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        final TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n+        if (map.size() > 0) {\n+            final Map<K, V> transformed = decorated.transformMap(map);\n+            decorated.clear();\n+            decorated.decorated().putAll(transformed);  // avoids double transformation\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n+     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        super(map);\n+        this.keyTransformer = keyTransformer;\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object  the object to transform\n+     * @return the transformed object\n+     */\n+    protected K transformKey(final K object) {\n+        if (keyTransformer == null) {\n+            return object;\n+        }\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object  the object to transform\n+     * @return the transformed object\n+     */\n+    protected V transformValue(final V object) {\n+        if (valueTransformer == null) {\n+            return object;\n+        }\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map  the map to transform\n+     * @return the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     *\n+     * @param value  the value to transform\n+     * @return the transformed value\n+     * @since 3.1\n+     */\n+    @Override\n+    protected V checkSetValue(final V value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    /**\n+     * Override to only return true when there is a value transformer.\n+     *\n+     * @return true if a value transformer is in use\n+     * @since 3.1\n+     */\n+    @Override\n+    protected boolean isSetValueChecking() {\n+        return valueTransformer != null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public V put(K key, V value) {\n+        key = transformKey(key);\n+        value = transformValue(value);\n+        return decorated().put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        mapToCopy = transformMap(mapToCopy);\n+        decorated().putAll(mapToCopy);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedMap </code> to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedSortedMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedSortedMap}. This class may throw \n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSortedMap<K, V>\n+        extends TransformedMap<K, V>\n+        implements SortedMap<K, V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -8751771676410385778L;\n+    \n+    /**\n+     * Factory method to create a transforming sorted map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are NOT transformed.\n+     * Contrast this with {@link #transformedSortedMap(SortedMap, Transformer, Transformer)}.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n+     * @param valueTransformer  the predicate to validate to values, null means no transformation\n+     * @return a new transformed sorted map\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming sorted map that will transform\n+     * existing contents of the specified map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSortedMap(SortedMap, Transformer, Transformer)}.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n+     * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n+     * @return a new transformed sorted map\n+     * @throws IllegalArgumentException if map is null\n+     * @since 3.2\n+     */\n+    public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+\n+        final TransformedSortedMap<K, V> decorated =\n+                new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+        if (map.size() > 0) {\n+            final Map<K, V> transformed = decorated.transformMap(map);\n+            decorated.clear();\n+            decorated.decorated().putAll(transformed);  // avoids double transformation\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.</p>\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param keyTransformer  the predicate to validate the keys, null means no transformation\n+     * @param valueTransformer  the predicate to validate to values, null means no transformation\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected TransformedSortedMap(final SortedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        super(map, keyTransformer, valueTransformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the map being decorated.\n+     * \n+     * @return the decorated map\n+     */\n+    protected SortedMap<K, V> getSortedMap() {\n+        return (SortedMap<K, V>) map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public K firstKey() {\n+        return getSortedMap().firstKey();\n+    }\n+\n+    public K lastKey() {\n+        return getSortedMap().lastKey();\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return getSortedMap().comparator();\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().subMap(fromKey, toKey);\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        final SortedMap<K, V> map = getSortedMap().headMap(toKey);\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        final SortedMap<K, V> map = getSortedMap().tailMap(fromKey);\n+        return new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.AbstractSetDecorator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;\n+\n+/**\n+ * Decorates a map entry <code>Set</code> to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableEntrySet<K, V>\n+        extends AbstractSetDecorator<Map.Entry<K, V>> implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1678353579659253473L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set of Map Entry objects.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param set  the set to decorate, must not be null\n+     * @return a new unmodifiable entry set\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableEntrySet<K, V>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(final Map.Entry<K, V> object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends Map.Entry<K, V>> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<Map.Entry<K, V>> iterator() {\n+        return new UnmodifiableEntrySetIterator(collection.iterator());\n+    }\n+    \n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Object[] toArray() {\n+        final Object[] array = collection.toArray();\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = new UnmodifiableEntry((Map.Entry<K, V>) array[i]);\n+        }\n+        return array;\n+    }\n+    \n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(final T[] array) {\n+        Object[] result = array;\n+        if (array.length > 0) {\n+            // we must create a new array to handle multi-threaded situations\n+            // where another thread could access data before we decorate it\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n+        }\n+        result = collection.toArray(result);\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = new UnmodifiableEntry((Map.Entry<K, V>) result[i]);\n+        }\n+\n+        // check to see if result should be returned straight\n+        if (result.length > array.length) {\n+            return (T[]) result;\n+        }\n+\n+        // copy back into input array to fulfill the method contract\n+        System.arraycopy(result, 0, array, 0, result.length);\n+        if (array.length > result.length) {\n+            array[result.length] = null;\n+        }\n+        return array;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of an entry set iterator.\n+     */\n+    private class UnmodifiableEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n+\n+        protected UnmodifiableEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n+            super(iterator);\n+        }\n+\n+        @Override\n+        public Map.Entry<K, V> next() {\n+            return new UnmodifiableEntry(iterator.next());\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implementation of a map entry that is unmodifiable.\n+     */\n+    private class UnmodifiableEntry extends AbstractMapEntryDecorator<K, V> {\n+\n+        protected UnmodifiableEntry(final Map.Entry<K, V> entry) {\n+            super(entry);\n+        }\n+\n+        @Override\n+        public V setValue(final V obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.EntrySetMapIterator;\n+import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+\n+/**\n+ * Decorates another <code>Map</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableMap<K, V>\n+        extends AbstractMapDecorator<K, V>\n+        implements IterableMap<K, V>, Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2737023427269031941L;\n+\n+    /**\n+     * Factory method to create an unmodifiable map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return a new unmodifiable map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> Map<K, V> unmodifiableMap(final Map<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> mapIterator() {\n+        if (map instanceof IterableMap) {\n+            final MapIterator<K, V> it = ((IterableMap<K, V>) map).mapIterator();\n+            return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+        }\n+        final MapIterator<K, V> it = new EntrySetMapIterator<K, V>(map);\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(it);\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        final Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        final Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n+\n+/**\n+ * Decorates another <code>OrderedMap</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableOrderedMap<K, V> extends AbstractOrderedMapDecorator<K, V> implements\n+        Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 8136428161720526266L;\n+\n+    /**\n+     * Factory method to create an unmodifiable sorted map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return a new ordered map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableOrderedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableOrderedMap(final OrderedMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        final OrderedMapIterator<K, V> it = decorated().mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        final Set<Map.Entry<K, V>> set = super.entrySet();\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(set);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        final Set<K> set = super.keySet();\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        final Collection<V> coll = super.values();\n+        return UnmodifiableCollection.unmodifiableCollection(coll);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+\n+/**\n+ * Decorates another <code>SortedMap</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableSortedMap<K, V>\n+        extends AbstractSortedMapDecorator<K, V>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5805344239827376360L;\n+\n+    /**\n+     * Factory method to create an unmodifiable sorted map.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the map to decorate, must not be null\n+     * @return a new unmodifiable sorted map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return map;\n+        }\n+        return new UnmodifiableSortedMap<K, V>(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private UnmodifiableSortedMap(final SortedMap<K, V> map) {\n+        super(map);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     * @since 3.1\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return UnmodifiableEntrySet.unmodifiableEntrySet(super.entrySet());\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return UnmodifiableSet.unmodifiableSet(super.keySet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        return UnmodifiableCollection.unmodifiableCollection(super.values());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public K firstKey() {\n+        return decorated().firstKey();\n+    }\n+\n+    @Override\n+    public K lastKey() {\n+        return decorated().lastKey();\n+    }\n+\n+    @Override\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return new UnmodifiableSortedMap<K, V>(decorated().subMap(fromKey, toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return new UnmodifiableSortedMap<K, V>(decorated().headMap(toKey));\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return new UnmodifiableSortedMap<K, V>(decorated().tailMap(fromKey));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/map/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the {@link java.util.Map Map},\n+ * {@link org.apache.commons.collections4.IterableMap IterableMap},\n+ * {@link org.apache.commons.collections4.OrderedMap OrderedMap} and\n+ * {@link java.util.SortedMap SortedMap} interfaces.\n+ * A Map provides a lookup from a key to a value.\n+ * A number of implementations also support the new MapIterator interface that enables\n+ * simple iteration of map keys and values.\n+ * <p>\n+ * The following implementations are provided:\n+ * <ul>\n+ *   <li>CaseInsensitiveMap - map that compares keys in a case insensitive way\n+ *   <li>CompositeMap - map that combines multiple maps into a single view\n+ *   <li>HashedMap - general purpose HashMap replacement supporting MapIterator\n+ *   <li>Flat3Map - designed for good performance at size 3 or less\n+ *   <li>LinkedMap - a hash map that maintains insertion order, supporting OrderedMapIterator\n+ *   <li>LRUMap - a hash map that maintains a maximum size by removing the least recently used entries\n+ *   <li>MultiKeyMap - map that provides special methods for using more than one key to access the value\n+ *   <li>ReferenceMap - allows the garbage collector to collect keys and values using equals() for comparison\n+ *   <li>ReferenceIdentityMap - allows the garbage collector to collect keys and values using == for comparison\n+ *   <li>SingletonMap - a fully featured map to hold one key-value pair\n+ *   <li>StaticBucketMap - internally synchronized and designed for thread-contentious environments\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided:\n+ * <ul>\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms each element added\n+ *   <li>FixedSize - ensures that the size of the map cannot change\n+ *   <li>Defaulted - provides default values for non-existing keys\n+ *   <li>Lazy - creates objects in the map on demand\n+ *   <li>ListOrdered - ensures that insertion order is retained\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.map;\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains the interfaces and utilities shared across all the subpackages of this component.\n+ * <p>\n+ * The following collection implementations are provided in the package:\n+ * <ul>\n+ *   <li>ArrayStack - a non synchronized Stack that follows the same API as {@code java.util Stack}\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another {@link Queue} to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated queue.\n+ *\n+ * @param <E> the type of the elements in the queue\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractQueueDecorator<E> extends AbstractCollectionDecorator<E>\n+        implements Queue<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2629815475789577029L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractQueueDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    protected AbstractQueueDecorator(final Queue<E> queue) {\n+        super(queue);\n+    }\n+\n+    /**\n+     * Gets the queue being decorated.\n+     * \n+     * @return the decorated queue\n+     */\n+    @Override\n+    protected Queue<E> decorated() {\n+        return (Queue<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public boolean offer(final E obj) {\n+        return decorated().offer(obj);\n+    }\n+\n+    public E poll() {\n+        return decorated().poll();\n+    }\n+\n+    public E peek() {\n+        return decorated().peek();\n+    }\n+\n+    public E element() {\n+        return decorated().element();\n+    }\n+    \n+    public E remove() {\n+        return decorated().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/queue/CircularFifoQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.BoundedCollection;\n+\n+/**\n+ * CircularFifoQueue is a first-in first-out queue with a fixed size that\n+ * replaces its oldest element if full.\n+ * <p>\n+ * The removal order of a {@link CircularFifoQueue} is based on the\n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ * <p>\n+ * This queue prevents null objects from being added.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CircularFifoQueue<E> extends AbstractCollection<E>\n+    implements Queue<E>, BoundedCollection<E>, Serializable {\n+\n+    /** Serialization version. */\n+    private static final long serialVersionUID = -8423413834657610406L;\n+\n+    /** Underlying storage array. */\n+    private transient E[] elements;\n+\n+    /** Array index of first (oldest) queue element. */\n+    private transient int start = 0;\n+\n+    /**\n+     * Index mod maxElements of the array position following the last queue\n+     * element.  Queue elements start at elements[start] and \"wrap around\"\n+     * elements[maxElements-1], ending at elements[decrement(end)].\n+     * For example, elements = {c,a,b}, start=1, end=1 corresponds to\n+     * the queue [a,b,c].\n+     */\n+    private transient int end = 0;\n+\n+    /** Flag to indicate if the queue is currently full. */\n+    private transient boolean full = false;\n+\n+    /** Capacity of the queue. */\n+    private final int maxElements;\n+\n+    /**\n+     * Constructor that creates a queue with the default size of 32.\n+     */\n+    public CircularFifoQueue() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructor that creates a queue with the specified size.\n+     *\n+     * @param size  the size of the queue (cannot be changed)\n+     * @throws IllegalArgumentException  if the size is &lt; 1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public CircularFifoQueue(final int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        elements = (E[]) new Object[size];\n+        maxElements = elements.length;\n+    }\n+\n+    /**\n+     * Constructor that creates a queue from the specified collection.\n+     * The collection size also sets the queue size.\n+     *\n+     * @param coll  the collection to copy into the queue, may not be null\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public CircularFifoQueue(final Collection<E> coll) {\n+        this(coll.size());\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the queue out using a custom routine.\n+     *\n+     * @param out  the output stream\n+     * @throws IOException if an I/O error occurs while writing to the output stream\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeInt(size());\n+        for (final E e : this) {\n+            out.writeObject(e);\n+        }\n+    }\n+\n+    /**\n+     * Read the queue in using a custom routine.\n+     *\n+     * @param in  the input stream\n+     * @throws IOException if an I/O error occurs while writing to the output stream\n+     * @throws ClassNotFoundException if the class of a serialized object can not be found\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        elements = (E[]) new Object[maxElements];\n+        final int size = in.readInt();\n+        for (int i = 0; i < size; i++) {\n+            elements[i] = (E) in.readObject();\n+        }\n+        start = 0;\n+        full = size == maxElements;\n+        if (full) {\n+            end = 0;\n+        } else {\n+            end = size;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements stored in the queue.\n+     *\n+     * @return this queue's size\n+     */\n+    @Override\n+    public int size() {\n+        int size = 0;\n+\n+        if (end < start) {\n+            size = maxElements - start + end;\n+        } else if (end == start) {\n+            size = full ? maxElements : 0;\n+        } else {\n+            size = end - start;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if this queue is empty; false otherwise.\n+     *\n+     * @return true if this queue is empty\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * A {@code CircularFifoQueue} can never be full, thus this returns always\n+     * {@code false}.\n+     *\n+     * @return always returns {@code false}\n+     */\n+    public boolean isFull() {\n+        return false;\n+    }\n+\n+    private boolean isAtFullCapacity() {\n+        return size() == maxElements;\n+    }\n+\n+    /**\n+     * Gets the maximum size of the collection (the bound).\n+     *\n+     * @return the maximum number of elements the collection can hold\n+     */\n+    public int maxSize() {\n+        return maxElements;\n+    }\n+\n+    /**\n+     * Clears this queue.\n+     */\n+    @Override\n+    public void clear() {\n+        full = false;\n+        start = 0;\n+        end = 0;\n+        Arrays.fill(elements, null);\n+    }\n+\n+    /**\n+     * Adds the given element to this queue. If the queue is full, the least recently added\n+     * element is discarded so that a new element can be inserted.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     */\n+    @Override\n+    public boolean add(final E element) {\n+        if (null == element) {\n+            throw new NullPointerException(\"Attempted to add null object to queue\");\n+        }\n+\n+        if (isAtFullCapacity()) {\n+            remove();\n+        }\n+\n+        elements[end++] = element;\n+\n+        if (end >= maxElements) {\n+            end = 0;\n+        }\n+\n+        if (end == start) {\n+            full = true;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the element at the specified position in this queue.\n+     *\n+     * @param index the position of the element in the queue\n+     * @return the element at position {@code index}\n+     * @throws NoSuchElementException if the requested position is outside the range [0, size)\n+     */\n+    public E get(final int index) {\n+        final int sz = size();\n+        if (index < 0 || index >= sz) {\n+            throw new NoSuchElementException(\n+                    String.format(\"The specified index (%1$d) is outside the available range [0, %2$d)\",\n+                                  index, sz));\n+        }\n+        \n+        final int idx = (start + index) % maxElements;\n+        return elements[idx];\n+    }\n+ \n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Adds the given element to this queue. If the queue is full, the least recently added\n+     * element is discarded so that a new element can be inserted.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     */\n+    public boolean offer(E element) {\n+        return add(element);\n+    }\n+\n+    public E poll() {\n+        if (isEmpty()) {\n+            return null;\n+        } else {\n+            return remove();\n+        }\n+    }\n+\n+    public E element() {\n+        if (isEmpty()) {\n+            throw new NoSuchElementException(\"queue is empty\");\n+        } else {\n+            return peek();\n+        }\n+    }\n+\n+    public E peek() {\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        return elements[start];\n+    }\n+\n+    public E remove() {\n+        if (isEmpty()) {\n+            throw new NoSuchElementException(\"queue is empty\");\n+        }\n+\n+        final E element = elements[start];\n+        if (null != element) {\n+            elements[start++] = null;\n+\n+            if (start >= maxElements) {\n+                start = 0;\n+            }\n+            full = false;\n+        }\n+        return element;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Increments the internal index.\n+     *\n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n+    private int increment(int index) {\n+        index++;\n+        if (index >= maxElements) {\n+            index = 0;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Decrements the internal index.\n+     *\n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) {\n+            index = maxElements - 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Returns an iterator over this queue's elements.\n+     *\n+     * @return an iterator over this queue's elements\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new Iterator<E>() {\n+\n+            private int index = start;\n+            private int lastReturnedIndex = -1;\n+            private boolean isFirst = full;\n+\n+            public boolean hasNext() {\n+                return isFirst || index != end;\n+            }\n+\n+            public E next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                isFirst = false;\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == start) {\n+                    CircularFifoQueue.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                int pos = lastReturnedIndex + 1;\n+                if (start < lastReturnedIndex && pos < end) {\n+                    // shift in one part\n+                    System.arraycopy(elements, pos, elements, lastReturnedIndex, end - pos);\n+                } else {\n+                    // Other elements require us to shift the subsequent elements\n+                    while (pos != end) {\n+                        if (pos >= maxElements) {\n+                            elements[pos - 1] = elements[0];\n+                            pos = 0;\n+                        } else {\n+                            elements[decrement(pos)] = elements[pos];\n+                            pos = increment(pos);\n+                        }\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                end = decrement(end);\n+                elements[end] = null;\n+                full = false;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another {@link Queue} to validate that additions\n+ * match a specified predicate.\n+ * <p>\n+ * This queue exists to provide validation for the decorated queue.\n+ * It is normally created to decorate an empty queue.\n+ * If an object cannot be added to the queue, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the queue.\n+ * <pre>Queue queue = PredicatedQueue.predicatedQueue(new UnboundedFifoQueue(), NotNullPredicate.INSTANCE);</pre>\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PredicatedQueue<E> extends PredicatedCollection<E> implements Queue<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 2307609000539943581L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) queue.\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * are validated.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param Queue  the queue to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated queue\n+     * @throws IllegalArgumentException if queue or predicate is null\n+     * @throws IllegalArgumentException if the queue contains invalid elements\n+     */\n+    public static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue,\n+                                                          final Predicate<? super E> predicate) {\n+        return new PredicatedQueue<E>(Queue, predicate);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are validated.\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if Queue or predicate is null\n+     * @throws IllegalArgumentException if the Queue contains invalid elements\n+     */\n+    protected PredicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n+        super(queue, predicate);\n+    }\n+\n+    /**\n+     * Gets the queue being decorated.\n+     * \n+     * @return the decorated queue\n+     */\n+    @Override\n+    protected Queue<E> decorated() {\n+        return (Queue<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Override to validate the object being added to ensure it matches\n+     * the predicate.\n+     * \n+     * @param object  the object being added\n+     * @return the result of adding to the underlying queue\n+     * @throws IllegalArgumentException if the add is invalid\n+     */\n+    public boolean offer(final E object) {\n+        validate(object);\n+        return decorated().offer(object);\n+    }\n+\n+    public E poll() {\n+        return decorated().poll();\n+    }\n+\n+    public E peek() {\n+        return decorated().peek();\n+    }\n+\n+    public E element() {\n+        return decorated().element();\n+    }\n+\n+    public E remove() {\n+        return decorated().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+\n+/**\n+ * Decorates another {@link Queue} to transform objects that are added.\n+ * <p>\n+ * The add/offer methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class TransformedQueue<E> extends TransformedCollection<E> implements Queue<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -7901091318986132033L;\n+\n+    /**\n+     * Factory method to create a transforming queue.\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedQueue(Queue, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Queue\n+     * @throws IllegalArgumentException if queue or transformer is null\n+     */\n+    public static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue,\n+                                                            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedQueue<E>(queue, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming queue that will transform\n+     * existing contents of the specified queue.\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingQueue(Queue, Transformer)}.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed Queue\n+     * @throws IllegalArgumentException if queue or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue,\n+                                                           final Transformer<? super E, ? extends E> transformer) {\n+        // throws IAE if queue or transformer is null\n+        final TransformedQueue<E> decorated = new TransformedQueue<E>(queue, transformer); \n+        if (queue.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // queue is type <E>\n+            final E[] values = (E[]) queue.toArray();\n+            queue.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the queue being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if queue or transformer is null\n+     */\n+    protected TransformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n+        super(queue, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated queue.\n+     * \n+     * @return the decorated queue\n+     */\n+    protected Queue<E> getQueue() {\n+        return (Queue<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public boolean offer(final E obj) {\n+        return getQueue().offer(transform(obj));\n+    }\n+\n+    public E poll() {\n+        return getQueue().poll();\n+    }\n+\n+    public E peek() {\n+        return getQueue().peek();\n+    }\n+\n+    public E element() {\n+        return getQueue().element();\n+    }\n+    \n+    public E remove() {\n+        return getQueue().remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another {@link Queue} to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableQueue<E>\n+        extends AbstractQueueDecorator<E>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1832948656215393357L;\n+\n+    /**\n+     * Factory method to create an unmodifiable queue.\n+     * <p>\n+     * If the queue passed in is already unmodifiable, it is returned.\n+     * \n+     * @param <E> the type of the elements in the queue\n+     * @param queue  the queue to decorate, must not be null\n+     * @return an unmodifiable Queue\n+     * @throws IllegalArgumentException if queue is null\n+     */\n+    public static <E> Queue<E> unmodifiableQueue(final Queue<E> queue) {\n+        if (queue instanceof Unmodifiable) {\n+            return queue;\n+        }\n+        return new UnmodifiableQueue<E>(queue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param queue  the queue to decorate, must not be null\n+     * @throws IllegalArgumentException if queue is null\n+     */\n+    private UnmodifiableQueue(final Queue<E> queue) {\n+        super(queue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException if an I/O error occurs while writing to the output stream\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException if an I/O error occurs while reading from the input stream\n+     * @throws ClassNotFoundException if the class of a serialized object can not be found\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    @Override\n+    public boolean offer(final E obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public E poll() {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    @Override\n+    public E remove() {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/queue/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations for the {@link java.util.Queue Queue} interface.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>CircularFifoQueue - implements a queue with a fixed size that discards oldest when full\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms elements added to the queue\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ * </ul>\n+ * \n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.queue;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Set;\n+\n+/**\n+ * Serializable subclass of AbstractSetDecorator.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractSerializableSetDecorator<E>\n+        extends AbstractSetDecorator<E>\n+        implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1229469966212206107L;\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param set  the list to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected AbstractSerializableSetDecorator(final Set<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the set out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the set in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>Set</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated set.\n+ *\n+ * @param <E> the type of the elements in the set\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSetDecorator<E> extends AbstractCollectionDecorator<E> implements\n+        Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -4678668309576958546L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractSetDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected AbstractSetDecorator(final Set<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     * \n+     * @return the decorated set\n+     */\n+    @Override\n+    protected Set<E> decorated() {\n+        return (Set<E>) super.decorated();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated set.\n+ *\n+ * @param <E> the type of the elements in the sorted set\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedSetDecorator<E>\n+        extends AbstractSetDecorator<E>\n+        implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -3462240946294214398L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     * @since 3.1\n+     */\n+    protected AbstractSortedSetDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected AbstractSortedSetDecorator(final Set<E> set) {\n+        super(set);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     * \n+     * @return the decorated set\n+     */\n+    @Override\n+    protected SortedSet<E> decorated() {\n+        return (SortedSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        return decorated().subSet(fromElement, toElement);\n+    }\n+\n+    public SortedSet<E> headSet(final E toElement) {\n+        return decorated().headSet(toElement);\n+    }\n+\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        return decorated().tailSet(fromElement);\n+    }\n+\n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/CompositeSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.IteratorChain;\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * Decorates a set of other sets to provide a single unified view.\n+ * <p>\n+ * Changes made to this set will actually be made on the decorated set.\n+ * Add operations require the use of a pluggable strategy.\n+ * If no strategy is provided then add is unsupported.\n+ * <p>\n+ * From version 4.0, this class does not extend\n+ * {@link org.apache.commons.collections4.collection.CompositeCollection CompositeCollection}\n+ * anymore due to its input restrictions (only accepts Sets).\n+ * See <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-424\">COLLECTIONS-424</a>\n+ * for more details.\n+ * \n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CompositeSet<E> implements Set<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5185069727540378940L;\n+\n+    /** SetMutator to handle changes to the collection */\n+    protected SetMutator<E> mutator;\n+\n+    /** Sets in the composite */\n+    protected List<Set<E>> all = new ArrayList<Set<E>>();\n+\n+    /**\n+     * Create an empty CompositeSet.\n+     */\n+    public CompositeSet() {\n+        super();\n+    }\n+\n+    /**\n+     * Create a CompositeSet with just <code>set</code> composited.\n+     *\n+     * @param set  the initial set in the composite\n+     */\n+    public CompositeSet(final Set<E> set) {\n+        super();\n+        addComposited(set);\n+    }\n+\n+    /**\n+     * Create a composite set with sets as the initial set of composited Sets.\n+     * \n+     * @param sets  the initial sets in the composite\n+     */\n+    public CompositeSet(final Set<E>... sets) {\n+        super();\n+        addComposited(sets);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of this composite set.\n+     * <p>\n+     * This implementation calls <code>size()</code> on each set.\n+     *\n+     * @return total number of elements in all contained containers\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (final Set<E> item : all) {\n+            size += item.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether this composite set is empty.\n+     * <p>\n+     * This implementation calls <code>isEmpty()</code> on each set.\n+     *\n+     * @return true if all of the contained sets are empty\n+     */\n+    public boolean isEmpty() {\n+        for (final Set<E> item : all) {\n+            if (item.isEmpty() == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Checks whether this composite set contains the object.\n+     * <p>\n+     * This implementation calls <code>contains()</code> on each set.\n+     *\n+     * @param obj  the object to search for\n+     * @return true if obj is contained in any of the contained sets\n+     */\n+    public boolean contains(final Object obj) {\n+        for (final Set<E> item : all) {\n+            if (item.contains(obj)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Gets an iterator over all the sets in this composite.\n+     * <p>\n+     * This implementation uses an <code>IteratorChain</code>.\n+     *\n+     * @return an <code>IteratorChain</code> instance which supports\n+     *  <code>remove()</code>. Iteration occurs over contained collections in\n+     *  the order they were added, but this behavior should not be relied upon.\n+     * @see IteratorChain\n+     */\n+    public Iterator<E> iterator() {\n+        if (all.isEmpty()) {\n+            return EmptyIterator.<E>emptyIterator();\n+        }\n+        final IteratorChain<E> chain = new IteratorChain<E>();\n+        for (final Set<E> item : all) {\n+            chain.addIterator(item.iterator());\n+        }\n+        return chain;\n+    }\n+\n+    /**\n+     * Returns an array containing all of the elements in this composite.\n+     *\n+     * @return an object array of all the elements in the collection\n+     */\n+    public Object[] toArray() {\n+        final Object[] result = new Object[size()];\n+        int i = 0;\n+        for (final Iterator<E> it = iterator(); it.hasNext(); i++) {\n+            result[i] = it.next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an object array, populating the supplied array if possible.\n+     * See <code>Collection</code> interface for full details.\n+     *\n+     * @param <T>  the type of the elements in the collection\n+     * @param array  the array to use, populating if possible\n+     * @return an array of all the elements in the collection\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T[] toArray(final T[] array) {\n+        final int size = size();\n+        Object[] result = null;\n+        if (array.length >= size) {\n+            result = array;\n+        } else {\n+            result = (Object[]) Array.newInstance(array.getClass().getComponentType(), size);\n+        }\n+\n+        int offset = 0;\n+        for (final Collection<E> item : all) {\n+            for (final E e : item) {\n+                result[offset++] = e;\n+            }\n+        }\n+        if (result.length > size) {\n+            result[size] = null;\n+        }\n+        return (T[]) result;\n+    }\n+\n+    /**\n+     * Adds an object to the collection, throwing UnsupportedOperationException\n+     * unless a SetMutator strategy is specified.\n+     *\n+     * @param obj  the object to add\n+     * @return {@code true} if the collection was modified\n+     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean add(final E obj) {\n+        if (mutator == null) {\n+           throw new UnsupportedOperationException(\n+               \"add() is not supported on CompositeSet without a SetMutator strategy\");\n+        }\n+        return mutator.add(this, all, obj);\n+    }\n+\n+    /**\n+     * If a <code>CollectionMutator</code> is defined for this CompositeSet then this\n+     * method will be called anyway.\n+     *\n+     * @param obj  object to be removed\n+     * @return true if the object is removed, false otherwise\n+     */\n+    public boolean remove(final Object obj) {\n+        for (final Set<E> set : getSets()) {\n+            if (set.contains(obj)) {\n+                return set.remove(obj);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether this composite contains all the elements in the specified collection.\n+     * <p>\n+     * This implementation calls <code>contains()</code> for each element in the\n+     * specified collection.\n+     *\n+     * @param coll  the collection to check for\n+     * @return true if all elements contained\n+     */\n+    public boolean containsAll(final Collection<?> coll) {\n+        for (final Object item : coll) {\n+            if (contains(item) == false) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Adds a collection of elements to this composite, throwing\n+     * UnsupportedOperationException unless a SetMutator strategy is specified.\n+     *\n+     * @param coll  the collection to add\n+     * @return true if the composite was modified\n+     * @throws UnsupportedOperationException if SetMutator hasn't been set or add is unsupported\n+     * @throws ClassCastException if the object cannot be added due to its type\n+     * @throws NullPointerException if the object cannot be added because its null\n+     * @throws IllegalArgumentException if the object cannot be added\n+     */\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        if (mutator == null) {\n+            throw new UnsupportedOperationException(\n+                \"addAll() is not supported on CompositeSet without a SetMutator strategy\");\n+        }\n+        return mutator.addAll(this, all, coll);\n+    }\n+\n+    /**\n+     * Removes the elements in the specified collection from this composite set.\n+     * <p>\n+     * This implementation calls <code>removeAll</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the composite was modified\n+     * @throws UnsupportedOperationException if removeAll is unsupported\n+     */\n+    public boolean removeAll(final Collection<?> coll) {\n+        if (coll.size() == 0) {\n+            return false;\n+        }\n+        boolean changed = false;\n+        for (final Collection<E> item : all) {\n+            changed |= item.removeAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Retains all the elements in the specified collection in this composite set,\n+     * removing all others.\n+     * <p>\n+     * This implementation calls <code>retainAll()</code> on each collection.\n+     *\n+     * @param coll  the collection to remove\n+     * @return true if the composite was modified\n+     * @throws UnsupportedOperationException if retainAll is unsupported\n+     */\n+    public boolean retainAll(final Collection<?> coll) {\n+        boolean changed = false;\n+        for (final Collection<E> item : all) {\n+            changed |= item.retainAll(coll);\n+        }\n+        return changed;\n+    }\n+\n+    /**\n+     * Removes all of the elements from this composite set.\n+     * <p>\n+     * This implementation calls <code>clear()</code> on each set.\n+     *\n+     * @throws UnsupportedOperationException if clear is unsupported\n+     */\n+    public void clear() {\n+        for (final Collection<E> coll : all) {\n+            coll.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Specify a SetMutator strategy instance to handle changes.\n+     *\n+     * @param mutator  the mutator to use\n+     */\n+    public void setMutator(final SetMutator<E> mutator) {\n+        this.mutator = mutator;\n+    }\n+\n+    /**\n+     * Add a Set to this composite.\n+     *\n+     * @param set  the set to add\n+     * @throws IllegalArgumentException if a SetMutator is set, but fails to resolve a collision\n+     * @throws UnsupportedOperationException if there is no SetMutator set\n+     * @see SetMutator\n+     */\n+    public synchronized void addComposited(final Set<E> set) {\n+        for (final Set<E> existingSet : getSets()) {\n+            final Collection<E> intersects = CollectionUtils.intersection(existingSet, set);\n+            if (intersects.size() > 0) {\n+                if (this.mutator == null) {\n+                    throw new UnsupportedOperationException(\n+                        \"Collision adding composited set with no SetMutator set\");\n+                }\n+                getMutator().resolveCollision(this, existingSet, set, intersects);\n+                if (CollectionUtils.intersection(existingSet, set).size() > 0) {\n+                    throw new IllegalArgumentException(\n+                        \"Attempt to add illegal entry unresolved by SetMutator.resolveCollision()\");\n+                }\n+            }\n+        }\n+        all.add(set);\n+    }\n+\n+    /**\n+     * Add these Sets to the list of sets in this composite.\n+     *\n+     * @param set1  the first Set to be appended to the composite\n+     * @param set2  the second Set to be appended to the composite\n+     */\n+    public void addComposited(final Set<E> set1, final Set<E> set2) {\n+        all.add(set1);\n+        all.add(set2);\n+    }\n+\n+    /**\n+     * Add these Sets to the list of sets in this composite\n+     *\n+     * @param sets  the Sets to be appended to the composite\n+     */\n+    public void addComposited(final Set<E>[] sets) {\n+        all.addAll(Arrays.asList(sets));\n+    }\n+\n+    /**\n+     * Removes a set from those being decorated in this composite.\n+     *\n+     * @param set  set to be removed\n+     */\n+    public void removeComposited(final Set<E> set) {\n+        all.remove(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a new Set containing all of the elements.\n+     *\n+     * @return A new HashSet containing all of the elements in this composite.\n+     *   The new collection is <i>not</i> backed by this composite.\n+     */\n+    public Set<E> toSet() {\n+        return new HashSet<E>(this);\n+    }\n+\n+    /**\n+     * Gets the sets being decorated.\n+     *\n+     * @return Unmodifiable list of all sets in this composite.\n+     */\n+    public List<Set<E>> getSets() {\n+        return UnmodifiableList.unmodifiableList(all);\n+    }\n+\n+    /**\n+     * Get the set mutator to be used for this CompositeSet.\n+     * @return the set mutator\n+     */\n+    protected SetMutator<E> getMutator() {\n+        return mutator;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @see java.util.Set#equals\n+     */\n+    @Override\n+    public boolean equals(final Object obj) {\n+        if (obj instanceof Set) {\n+            final Set<?> set = (Set<?>) obj;\n+            return set.size() == this.size() && set.containsAll(this);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @see java.util.Set#hashCode\n+     */\n+    @Override\n+    public int hashCode() {\n+        int code = 0;\n+        for (final E e : this) {\n+            code += e == null ? 0 : e.hashCode();\n+        }\n+        return code;\n+    }\n+\n+    /**\n+     * Define callbacks for mutation operations.\n+     */\n+    public static interface SetMutator<E> extends Serializable {\n+\n+        /**\n+         * Called when an object is to be added to the composite.\n+         *\n+         * @param composite  the CompositeSet being changed\n+         * @param sets  all of the Set instances in this CompositeSet\n+         * @param obj  the object being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean add(CompositeSet<E> composite, List<Set<E>> sets, E obj);\n+\n+        /**\n+         * Called when a collection is to be added to the composite.\n+         *\n+         * @param composite  the CompositeSet being changed\n+         * @param sets  all of the Set instances in this CompositeSet\n+         * @param coll  the collection being added\n+         * @return true if the collection is changed\n+         * @throws UnsupportedOperationException if add is unsupported\n+         * @throws ClassCastException if the object cannot be added due to its type\n+         * @throws NullPointerException if the object cannot be added because its null\n+         * @throws IllegalArgumentException if the object cannot be added\n+         */\n+        public boolean addAll(CompositeSet<E> composite,\n+                              List<Set<E>> sets,\n+                              Collection<? extends E> coll);\n+\n+        /**\n+         * Called when a Set is added to the CompositeSet and there is a\n+         * collision between existing and added sets.\n+         * <p>\n+         * If <code>added</code> and <code>existing</code> still have any intersects\n+         * after this method returns an IllegalArgumentException will be thrown.\n+         *\n+         * @param comp  the CompositeSet being modified\n+         * @param existing  the Set already existing in the composite\n+         * @param added  the Set being added to the composite\n+         * @param intersects  the intersection of the existing and added sets\n+         */\n+        public void resolveCollision(CompositeSet<E> comp,\n+                                     Set<E> existing,\n+                                     Set<E> added,\n+                                     Collection<E> intersects);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.OrderedIterator;\n+import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * Decorates another <code>Set</code> to ensure that the order of addition is\n+ * retained and used by the iterator.\n+ * <p>\n+ * If an object is added to the set for a second time, it will remain in the\n+ * original position in the iteration. The order can be observed from the set\n+ * via the iterator or toArray methods.\n+ * <p>\n+ * The ListOrderedSet also has various useful direct methods. These include many\n+ * from <code>List</code>, such as <code>get(int)</code>,\n+ * <code>remove(int)</code> and <code>indexOf(int)</code>. An unmodifiable\n+ * <code>List</code> view of the set can be obtained via <code>asList()</code>.\n+ * <p>\n+ * This class cannot implement the <code>List</code> interface directly as\n+ * various interface methods (notably equals/hashCode) are incompatible with a\n+ * set.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * \n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ListOrderedSet<E>\n+    extends AbstractSerializableSetDecorator<E>\n+    implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -228664372470420141L;\n+\n+    /** Internal list to hold the sequence of objects */\n+    protected final List<E> setOrder;\n+\n+    /**\n+     * Factory method to create an ordered set specifying the list and set to\n+     * use.\n+     * <p>\n+     * The list and set must both be empty.\n+     * \n+     * @param <E> the element type\n+     * @param set the set to decorate, must be empty and not null\n+     * @param list the list to decorate, must be empty and not null\n+     * @return a new ordered set\n+     * @throws IllegalArgumentException if set or list is null\n+     * @throws IllegalArgumentException if either the set or list is not empty\n+     * @since 3.1\n+     */\n+    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (set.size() > 0 || list.size() > 0) {\n+            throw new IllegalArgumentException(\"Set and List must be empty\");\n+        }\n+        return new ListOrderedSet<E>(set, list);\n+    }\n+\n+    /**\n+     * Factory method to create an ordered set.\n+     * <p>\n+     * An <code>ArrayList</code> is used to retain order.\n+     * \n+     * @param <E> the element type\n+     * @param set the set to decorate, must not be null\n+     * @return a new ordered set\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n+        return new ListOrderedSet<E>(set);\n+    }\n+\n+    /**\n+     * Factory method to create an ordered set using the supplied list to retain\n+     * order.\n+     * <p>\n+     * A <code>HashSet</code> is used for the set behaviour.\n+     * <p>\n+     * NOTE: If the list contains duplicates, the duplicates are removed,\n+     * altering the specified list.\n+     * \n+     * @param <E> the element type\n+     * @param list the list to decorate, must not be null\n+     * @return a new ordered set\n+     * @throws IllegalArgumentException if list is null\n+     */\n+    public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        final Set<E> set = new HashSet<E>(list);\n+        list.retainAll(set);\n+\n+        return new ListOrderedSet<E>(set, list);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty <code>ListOrderedSet</code> using a\n+     * <code>HashSet</code> and an <code>ArrayList</code> internally.\n+     * \n+     * @since 3.1\n+     */\n+    public ListOrderedSet() {\n+        super(new HashSet<E>());\n+        setOrder = new ArrayList<E>();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    protected ListOrderedSet(final Set<E> set) {\n+        super(set);\n+        setOrder = new ArrayList<E>(set);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies) the Set and specifies the list to\n+     * use.\n+     * <p>\n+     * The set and list must both be correctly initialised to the same elements.\n+     * \n+     * @param set the set to decorate, must not be null\n+     * @param list the list to decorate, must not be null\n+     * @throws IllegalArgumentException if set or list is null\n+     */\n+    protected ListOrderedSet(final Set<E> set, final List<E> list) {\n+        super(set);\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        setOrder = list;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Gets an unmodifiable view of the order of the Set.\n+     * \n+     * @return an unmodifiable list view\n+     */\n+    public List<E> asList() {\n+        return UnmodifiableList.unmodifiableList(setOrder);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        collection.clear();\n+        setOrder.clear();\n+    }\n+\n+    @Override\n+    public OrderedIterator<E> iterator() {\n+        return new OrderedSetIterator<E>(setOrder.listIterator(), collection);\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        if (collection.add(object)) {\n+            setOrder.add(object);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        boolean result = false;\n+        for (final E e : coll) {\n+            result |= add(e);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        final boolean result = collection.remove(object);\n+        if (result) {\n+            setOrder.remove(object);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean result = false;\n+        for (final Object name : coll) {\n+            result |= remove(name);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        final Set<Object> collectionRetainAll = new HashSet<Object>();\n+        for (final Object next : coll) {\n+            if (collection.contains(next)) {\n+                collectionRetainAll.add(next);\n+            }\n+        }\n+        if (collectionRetainAll.size() == collection.size()) {\n+            return false;\n+        }\n+        if (collectionRetainAll.size() == 0) {\n+            clear();\n+        } else {\n+            for (final Iterator<E> it = iterator(); it.hasNext();) {\n+                if (!collectionRetainAll.contains(it.next())) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public Object[] toArray() {\n+        return setOrder.toArray();\n+    }\n+\n+    @Override\n+    public <T> T[] toArray(final T a[]) {\n+        return setOrder.toArray(a);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    // Additional methods that comply to the {@link List} interface\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Returns the element at the specified position in this ordered set.\n+     * \n+     * @param index the position of the element in the ordered {@link Set}.\n+     * @return the element at position {@code index}\n+     * @see List#get(int)\n+     */\n+    public E get(final int index) {\n+        return setOrder.get(index);\n+    }\n+\n+    /**\n+     * Returns the index of the first occurrence of the specified element in\n+     * ordered set.\n+     * \n+     * @param object the element to search for\n+     * @return the index of the first occurrence of the object, or {@code -1} if\n+     *         this ordered set does not contain this object\n+     * @see List#indexOf(Object)\n+     */\n+    public int indexOf(final Object object) {\n+        return setOrder.indexOf(object);\n+    }\n+\n+    /**\n+     * Inserts the specified element at the specified position if it is not yet\n+     * contained in this ordered set (optional operation). Shifts the element\n+     * currently at this position and any subsequent elements to the right.\n+     * \n+     * @param index the index at which the element is to be inserted\n+     * @param object the element to be inserted\n+     * @see List#add(int, Object)\n+     */\n+    public void add(final int index, final E object) {\n+        if (!contains(object)) {\n+            collection.add(object);\n+            setOrder.add(index, object);\n+        }\n+    }\n+\n+    /**\n+     * Inserts all elements in the specified collection not yet contained in the\n+     * ordered set at the specified position (optional operation). Shifts the\n+     * element currently at the position and all subsequent elements to the\n+     * right.\n+     * \n+     * @param index the position to insert the elements\n+     * @param coll the collection containing the elements to be inserted\n+     * @return {@code true} if this ordered set changed as a result of the call\n+     * @see List#addAll(int, Collection)\n+     */\n+    public boolean addAll(final int index, final Collection<? extends E> coll) {\n+        boolean changed = false;\n+        // collect all elements to be added for performance reasons\n+        final List<E> toAdd = new ArrayList<E>();\n+        for (final E e : coll) {\n+            if (contains(e)) {\n+                continue;\n+            }\n+            collection.add(e);\n+            toAdd.add(e);\n+            changed = true;\n+        }\n+\n+        if (changed) {\n+            setOrder.addAll(index, toAdd);\n+        }\n+\n+        return changed;\n+    }\n+\n+    /**\n+     * Removes the element at the specified position from the ordered set.\n+     * Shifts any subsequent elements to the left.\n+     * \n+     * @param index the index of the element to be removed\n+     * @return the element that has been remove from the ordered set\n+     * @see List#remove(int)\n+     */\n+    public Object remove(final int index) {\n+        final Object obj = setOrder.remove(index);\n+        remove(obj);\n+        return obj;\n+    }\n+\n+    /**\n+     * Uses the underlying List's toString so that order is achieved. This means\n+     * that the decorated Set's toString is not used, so any custom toStrings\n+     * will be ignored.\n+     * \n+     * @return a string representation of the ordered set\n+     */\n+    // Fortunately List.toString and Set.toString look the same\n+    @Override\n+    public String toString() {\n+        return setOrder.toString();\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Internal iterator handle remove.\n+     */\n+    static class OrderedSetIterator<E>\n+        extends AbstractIteratorDecorator<E>\n+        implements OrderedIterator<E> {\n+\n+        /** Object we iterate on */\n+        protected final Collection<E> set;\n+\n+        /** Last object retrieved */\n+        protected E last;\n+\n+        private OrderedSetIterator(final ListIterator<E> iterator, final Collection<E> set) {\n+            super(iterator);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = iterator.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            set.remove(last);\n+            iterator.remove();\n+            last = null;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return ((ListIterator<E>) iterator).hasPrevious();\n+        }\n+\n+        public E previous() {\n+            last = ((ListIterator<E>) iterator).previous();\n+            return last;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Decorates a <code>Map</code> to obtain <code>Set</code> behaviour.\n+ * <p>\n+ * This class is used to create a <code>Set</code> with the same properties as\n+ * the key set of any map. Thus, a ReferenceSet can be created by wrapping a\n+ * <code>ReferenceMap</code> in an instance of this class.\n+ * <p>\n+ * Most map implementation can be used to create a set by passing in dummy values.\n+ * Exceptions include <code>BidiMap</code> implementations, as they require unique values.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public final class MapBackedSet<E, V> implements Set<E>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6723912213766056587L;\n+\n+    /** The map being used as the backing store */\n+    protected final Map<E, ? super V> map;\n+\n+    /** The dummyValue to use */\n+    protected final V dummyValue;\n+\n+    /**\n+     * Factory method to create a set from a map.\n+     * \n+     * @param <E> the element type\n+     * @param <V> the dummy value type in the map\n+     * @param map  the map to decorate, must not be null\n+     * @return a new map backed set\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n+        return mapBackedSet(map, null);\n+    }\n+\n+    /**\n+     * Factory method to create a set from a map.\n+     * \n+     * @param <E> the element type\n+     * @param <V> the dummy value type in the map\n+     * @param map  the map to decorate, must not be null\n+     * @param dummyValue  the dummy value to use\n+     * @return a new map backed set\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"The map must not be null\");\n+        }\n+        return new MapBackedSet<E, V>(map, dummyValue);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param map  the map to decorate, must not be null\n+     * @param dummyValue  the dummy value to use\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    private MapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n+        super();\n+        this.map = map;\n+        this.dummyValue = dummyValue;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    public Iterator<E> iterator() {\n+        return map.keySet().iterator();\n+    }\n+\n+    public boolean contains(final Object obj) {\n+        return map.containsKey(obj);\n+    }\n+\n+    public boolean containsAll(final Collection<?> coll) {\n+        return map.keySet().containsAll(coll);\n+    }\n+\n+    public boolean add(final E obj) {\n+        final int size = map.size();\n+        map.put(obj, dummyValue);\n+        return map.size() != size;\n+    }\n+\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        final int size = map.size();\n+        for (final E e : coll) {\n+            map.put(e, dummyValue);\n+        }\n+        return map.size() != size;\n+    }\n+\n+    public boolean remove(final Object obj) {\n+        final int size = map.size();\n+        map.remove(obj);\n+        return map.size() != size;\n+    }\n+\n+    public boolean removeAll(final Collection<?> coll) {\n+        return map.keySet().removeAll(coll);\n+    }\n+\n+    public boolean retainAll(final Collection<?> coll) {\n+        return map.keySet().retainAll(coll);\n+    }\n+\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    public Object[] toArray() {\n+        return map.keySet().toArray();\n+    }\n+\n+    public <T> T[] toArray(final T[] array) {\n+        return map.keySet().toArray(array);\n+    }\n+\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return map.keySet().equals(obj);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return map.keySet().hashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+\n+/**\n+ * Decorates another <code>Set</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This set exists to provide validation for the decorated set.\n+ * It is normally created to decorate an empty set.\n+ * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the set.\n+ * <pre>Set set = PredicatedSet.decorate(new HashSet(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSet<E> extends PredicatedCollection<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -684521469108685117L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a decorated set\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    public static <E> PredicatedSet<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n+        return new PredicatedSet<E>(set, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    protected PredicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n+        super(set, predicate);\n+    }\n+\n+    /**\n+     * Gets the set being decorated.\n+     * \n+     * @return the decorated set\n+     */\n+    @Override\n+    protected Set<E> decorated() {\n+        return (Set<E>) super.decorated();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Comparator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to validate that all additions\n+ * match a specified predicate.\n+ * <p>\n+ * This set exists to provide validation for the decorated set.\n+ * It is normally created to decorate an empty set.\n+ * If an object cannot be added to the set, an IllegalArgumentException is thrown.\n+ * <p>\n+ * One usage would be to ensure that no null entries are added to the set.\n+ * <pre>SortedSet set = PredicatedSortedSet.decorate(new TreeSet(), NotNullPredicate.INSTANCE);</pre>\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSortedSet<E> extends PredicatedSet<E> implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -9110948148132275052L;\n+\n+    /**\n+     * Factory method to create a predicated (validating) sorted set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @return a new predicated sorted set.\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    public static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set,\n+                                                                 final Predicate<? super E> predicate) {\n+        return new PredicatedSortedSet<E>(set, predicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are validated.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param predicate  the predicate to use for validation, must not be null\n+     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws IllegalArgumentException if the set contains invalid elements\n+     */\n+    protected PredicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n+        super(set, predicate);\n+    }\n+\n+    /**\n+     * Gets the sorted set being decorated.\n+     * \n+     * @return the decorated sorted set\n+     */\n+    @Override\n+    protected SortedSet<E> decorated() {\n+        return (SortedSet<E>) super.decorated();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public Comparator<? super E> comparator() {\n+        return decorated().comparator();\n+    }\n+\n+    public E first() {\n+        return decorated().first();\n+    }\n+\n+    public E last() {\n+        return decorated().last();\n+    }\n+\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+        return new PredicatedSortedSet<E>(sub, predicate);\n+    }\n+\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> sub = decorated().headSet(toElement);\n+        return new PredicatedSortedSet<E>(sub, predicate);\n+    }\n+\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> sub = decorated().tailSet(fromElement);\n+        return new PredicatedSortedSet<E>(sub, predicate);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+\n+/**\n+ * Decorates another <code>Set</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSet<E> extends TransformedCollection<E> implements Set<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 306127383500410386L;\n+\n+    /**\n+     * Factory method to create a transforming set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedSet(Set, Transformer)}.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed set\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    public static <E> TransformedSet<E> transformingSet(final Set<E> set,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSet<E>(set, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming set that will transform\n+     * existing contents of the specified set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSet(Set, Transformer)}.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed set\n+     * @throws IllegalArgumentException if set or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n+        final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n+        if (transformer != null && set != null && set.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // set is type E\n+            final E[] values = (E[]) set.toArray();\n+            set.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n+        super(set, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Comparator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections4.Transformer;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to transform objects that are added.\n+ * <p>\n+ * The add methods are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must\n+ * use the Integer form to remove objects.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSortedSet<E> extends TransformedSet<E> implements SortedSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1675486811351124386L;\n+\n+    /**\n+     * Factory method to create a transforming sorted set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * Contrast this with {@link #transformedSortedSet(SortedSet, Transformer)}.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed {@link SortedSet}\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    public static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set,\n+            final Transformer<? super E, ? extends E> transformer) {\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+    \n+    /**\n+     * Factory method to create a transforming sorted set that will transform\n+     * existing contents of the specified sorted set.\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * will be transformed by this method.\n+     * Contrast this with {@link #transformingSortedSet(SortedSet, Transformer)}.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @return a new transformed {@link SortedSet}\n+     * @throws IllegalArgumentException if set or transformer is null\n+     * @since 4.0\n+     */\n+    public static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set,\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n+        final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n+        if (transformer != null && set != null && set.size() > 0) {\n+            @SuppressWarnings(\"unchecked\") // set is type E\n+            final E[] values = (E[]) set.toArray();\n+            set.clear();\n+            for (final E value : values) {\n+                decorated.decorated().add(transformer.transform(value));\n+            }\n+        }\n+        return decorated;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the set being decorated, they\n+     * are NOT transformed.\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @param transformer  the transformer to use for conversion, must not be null\n+     * @throws IllegalArgumentException if set or transformer is null\n+     */\n+    protected TransformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n+        super(set, transformer);\n+    }\n+\n+    /**\n+     * Gets the decorated set.\n+     * \n+     * @return the decorated set\n+     */\n+    protected SortedSet<E> getSortedSet() {\n+        return (SortedSet<E>) collection;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public E first() {\n+        return getSortedSet().first();\n+    }\n+\n+    public E last() {\n+        return getSortedSet().last();\n+    }\n+\n+    public Comparator<? super E> comparator() {\n+        return getSortedSet().comparator();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> set = getSortedSet().subSet(fromElement, toElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> set = getSortedSet().headSet(toElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> set = getSortedSet().tailSet(fromElement);\n+        return new TransformedSortedSet<E>(set, transformer);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>Set</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableSet<E>\n+        extends AbstractSerializableSetDecorator<E>\n+        implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 6499119872185240161L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @return a new unmodifiable set\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E> Set<E> unmodifiableSet(final Set<E> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableSet<E>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableSet(final Set<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.<E>unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Decorates another <code>SortedSet</code> to ensure it can't be altered.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException. \n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public final class UnmodifiableSortedSet<E>\n+        extends AbstractSortedSetDecorator<E>\n+        implements Unmodifiable, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -725356885467962424L;\n+\n+    /**\n+     * Factory method to create an unmodifiable set.\n+     * \n+     * @param <E> the element type\n+     * @param set  the set to decorate, must not be null\n+     * @return a new unmodifiable {@link SortedSet}\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n+        if (set instanceof Unmodifiable) {\n+            return set;\n+        }\n+        return new UnmodifiableSortedSet<E>(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the collection out using a custom routine.\n+     * \n+     * @param out  the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(collection);\n+    }\n+\n+    /**\n+     * Read the collection in using a custom routine.\n+     * \n+     * @param in  the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        collection = (Collection<E>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param set  the set to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    private UnmodifiableSortedSet(final SortedSet<E> set) {\n+        super(set);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(decorated().iterator());\n+    }\n+\n+    @Override\n+    public boolean add(final E object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(final Collection<? extends E> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(final Collection<?> coll) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n+        final SortedSet<E> sub = decorated().subSet(fromElement, toElement);\n+        return new UnmodifiableSortedSet<E>(sub);\n+    }\n+\n+    @Override\n+    public SortedSet<E> headSet(final E toElement) {\n+        final SortedSet<E> sub = decorated().headSet(toElement);\n+        return new UnmodifiableSortedSet<E>(sub);\n+    }\n+\n+    @Override\n+    public SortedSet<E> tailSet(final E fromElement) {\n+        final SortedSet<E> sub = decorated().tailSet(fromElement);\n+        return new UnmodifiableSortedSet<E>(sub);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/set/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the {@link java.util.Set Set} and\n+ * {@link java.util.SortedSet SortedSet} interfaces.\n+ * <p>\n+ * The implementations are in the form of direct implementations and decorators.\n+ * A decorator wraps another implementation of the interface to add some\n+ * specific additional functionality.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>CompositeSet - a set that combines multiple sets into one\n+ * </ul>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms each element added\n+ *   <li>ListOrdered - ensures that insertion order is retained\n+ *   <li>MapBackedSet - a set formed by decorating a Map\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.set;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.splitmap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.IterableGet;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter;\n+\n+/**\n+ * {@link IterableGet} that uses a {@link Map}<K, V> for the\n+ * {@link org.apache.commons.collections4.Get Get}<K, V> implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class AbstractIterableGetMapDecorator<K, V> implements IterableGet<K, V> {\n+\n+    /** The map to decorate */\n+    protected transient Map<K, V> map;\n+\n+    /**\n+     * Create a new AbstractSplitMapDecorator.\n+     * @param decorated the Map to decorate\n+     */\n+    public AbstractIterableGetMapDecorator(final Map<K, V> decorated) {\n+        this.map = decorated;\n+    }\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractIterableGetMapDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets the map being decorated.\n+     *\n+     * @return the decorated map\n+     */\n+    protected Map<K, V> decorated() {\n+        return map;\n+    }\n+\n+    public boolean containsKey(final Object key) {\n+        return decorated().containsKey(key);\n+    }\n+\n+    public boolean containsValue(final Object value) {\n+        return decorated().containsValue(value);\n+    }\n+\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        return decorated().entrySet();\n+    }\n+\n+    public V get(final Object key) {\n+        return decorated().get(key);\n+    }\n+\n+    public V remove(final Object key) {\n+        return decorated().remove(key);\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public Collection<V> values() {\n+        return decorated().values();\n+    }\n+\n+    /**\n+     * Get a MapIterator over this Get.\n+     * @return MapIterator<K, V>\n+     */\n+    public MapIterator<K, V> mapIterator() {\n+        return new EntrySetToMapIteratorAdapter<K, V>(entrySet());\n+    }\n+\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/TransformedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.splitmap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Put;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.map.LinkedMap;\n+\n+/**\n+ * Decorates another {@link Map} to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must use\n+ * the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. The simplest approach\n+ * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n+ * This class may throw exceptions when accessed by concurrent threads without\n+ * synchronization.\n+ * <p>\n+ * The \"put\" and \"get\" type constraints of this class are mutually independent;\n+ * contrast with {@link org.apache.commons.collections4.map.TransformedMap} which,\n+ * by virtue of its implementing {@link Map}&lt;K, V&gt;, must be constructed in such\n+ * a way that its read and write parameters are generalized to a common (super-)type.\n+ * In practice this would often mean <code>&gt;Object, Object&gt;</code>, defeating\n+ * much of the usefulness of having parameterized types.\n+ * <p>\n+ * On the downside, this class is not drop-in compatible with {@link java.util.Map}\n+ * but is intended to be worked with either directly or by {@link Put} and\n+ * {@link org.apache.commons.collections4.Get Get} generalizations.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ *\n+ * @see org.apache.commons.collections4.SplitMapUtils#readableMap(Get)\n+ * @see org.apache.commons.collections4.SplitMapUtils#writableMap(Put)\n+ */\n+public class TransformedMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V>\n+        implements Put<J, U>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5966875321133456994L;\n+\n+    /** The transformer to use for the key */\n+    private final Transformer<? super J, ? extends K> keyTransformer;\n+    /** The transformer to use for the value */\n+    private final Transformer<? super U, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are\n+     * NOT transformed.\n+     *\n+     * @param <J>  the input key type\n+     * @param <K>  the output key type\n+     * @param <U>  the input value type\n+     * @param <V>  the output value type\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     *   means no transformation\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     *   means no transformation\n+     * @return a new transformed map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <J, K, U, V> TransformedMap<J, K, U, V> transformingMap(final Map<K, V> map,\n+            final Transformer<? super J, ? extends K> keyTransformer,\n+            final Transformer<? super U, ? extends V> valueTransformer) {\n+        return new TransformedMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     * means no conversion\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     * means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer,\n+            final Transformer<? super U, ? extends V> valueTransformer) {\n+        super(map);\n+        if (keyTransformer == null) {\n+            throw new IllegalArgumentException(\"keyTransformer cannot be null\");\n+        }\n+        this.keyTransformer = keyTransformer;\n+        if (valueTransformer == null) {\n+            throw new IllegalArgumentException(\"valueTransformer cannot be null\");\n+        }\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     *\n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     *\n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect \n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @return the transformed object\n+     */\n+    protected K transformKey(final J object) {\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @return the transformed object\n+     */\n+    protected V transformValue(final U object) {\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map the map to transform\n+     * @return the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(final Map<? extends J, ? extends U> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (final Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     *\n+     * @param value the value to transform\n+     * @return the transformed value\n+     */\n+    protected V checkSetValue(final U value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public V put(final J key, final U value) {\n+        return decorated().put(transformKey(key), transformValue(value));\n+    }\n+\n+    public void putAll(final Map<? extends J, ? extends U> mapToCopy) {\n+        decorated().putAll(transformMap(mapToCopy));\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * The \"split map\" concept is that of an object that implements\n+ * the {@link org.apache.commons.collections4.Put Put} and\n+ * {@link org.apache.commons.collections4.Get Get} interfaces,\n+ * with <i>differing</i> generic types. This is like a pre-generics\n+ * {@link java.util.Map Map} whose input key/value constraints are\n+ * different than its output key/value constraints.  While it would\n+ * be possible to declare a \"split map\" with matching input/output\n+ * key/value constraints, this would be a {@link java.util.Map Map}\n+ * and would therefore make little sense (any Commons Collections\n+ * {@link java.util.Map Map} implementation will also implement\n+ * {@link org.apache.commons.collections4.Put Put} and\n+ * {@link org.apache.commons.collections4.Get Get} with matching\n+ * generic parameters).\n+ * <p>\n+ * The following decorators are provided:\n+ * <ul>\n+ *   <li>Transformed - transforms each element added\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.splitmap;\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * TODO: add javadoc\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractKeyAnalyzer<K> implements KeyAnalyzer<K> {\n+    \n+    private static final long serialVersionUID = -20497563720380683L;\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public int compare(final K o1, final K o2) {\n+        if (o1 == null) {\n+            return o2 == null ? 0 : -1;\n+        } else if (o2 == null) {\n+            return 1;\n+        }\n+        \n+        return ((Comparable<K>)o1).compareTo(o2);\n+    }\n+    \n+    /** \n+     * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}\n+     */\n+    static boolean isOutOfBoundsIndex(final int bitIndex) {\n+        return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n+    }\n+\n+    /** \n+     * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}\n+     */\n+    static boolean isEqualBitKey(final int bitIndex) {\n+        return bitIndex == EQUAL_BIT_KEY;\n+    }\n+\n+    /** \n+     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY} \n+     */\n+    static boolean isNullBitKey(final int bitIndex) {\n+        return bitIndex == NULL_BIT_KEY;\n+    }\n+\n+    /** \n+     * Returns true if the given bitIndex is valid. Indices \n+     * are considered valid if they're between 0 and \n+     * {@link Integer#MAX_VALUE}\n+     */\n+    static boolean isValidBitIndex(final int bitIndex) {\n+        return 0 <= bitIndex && bitIndex <= Integer.MAX_VALUE;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Trie;\n+\n+/**\n+ * This class provides some basic {@link Trie} functionality and \n+ * utility methods for actual {@link Trie} implementations.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+abstract class AbstractTrie<K, V> extends AbstractMap<K, V> \n+        implements Trie<K, V>, Serializable {\n+    \n+    private static final long serialVersionUID = 5826987063535505652L;\n+    \n+    /**\n+     * The {@link KeyAnalyzer} that's being used to build the \n+     * PATRICIA {@link Trie}.\n+     */\n+    protected final KeyAnalyzer<? super K> keyAnalyzer;\n+    \n+    /** \n+     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n+     */\n+    public AbstractTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n+        if (keyAnalyzer == null) {\n+            throw new NullPointerException(\"keyAnalyzer\");\n+        }\n+        \n+        this.keyAnalyzer = keyAnalyzer;\n+    }\n+    \n+    /**\n+     * Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n+     */\n+    public KeyAnalyzer<? super K> getKeyAnalyzer() {\n+        return keyAnalyzer;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K selectKey(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getKey();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V selectValue(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        final StringBuilder buffer = new StringBuilder();\n+        buffer.append(\"Trie[\").append(size()).append(\"]={\\n\");\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n+            buffer.append(\"  \").append(entry).append(\"\\n\");\n+        }\n+        buffer.append(\"}\\n\");\n+        return buffer.toString();\n+    }\n+    \n+    /**\n+     * A utility method to cast keys. It actually doesn't\n+     * cast anything. It's just fooling the compiler!\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    final K castKey(final Object key) {\n+        return (K)key;\n+    }\n+    \n+    /**\n+     * Returns the length of the given key in bits\n+     * \n+     * @see KeyAnalyzer#lengthInBits(Object)\n+     */\n+    final int lengthInBits(final K key) {\n+        if (key == null) {\n+            return 0;\n+        }\n+        \n+        return keyAnalyzer.lengthInBits(key);\n+    }\n+    \n+    /**\n+     * Returns the number of bits per element in the key\n+     * \n+     * @see KeyAnalyzer#bitsPerElement()\n+     */\n+    final int bitsPerElement() {\n+        return keyAnalyzer.bitsPerElement();\n+    }\n+    \n+    /**\n+     * Returns whether or not the given bit on the \n+     * key is set or false if the key is null.\n+     * \n+     * @see KeyAnalyzer#isBitSet(Object, int, int)\n+     */\n+    final boolean isBitSet(final K key, final int bitIndex, final int lengthInBits) {\n+        if (key == null) { // root's might be null!\n+            return false;\n+        }\n+        return keyAnalyzer.isBitSet(key, bitIndex, lengthInBits);\n+    }\n+    \n+    /**\n+     * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}\n+     */\n+    final int bitIndex(final K key, final K foundKey) {\n+        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), \n+                foundKey, 0, lengthInBits(foundKey));\n+    }\n+    \n+    /**\n+     * An utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n+     */\n+    final boolean compareKeys(final K key, final K other) {\n+        if (key == null) {\n+            return other == null;\n+        } else if (other == null) {\n+            return false;\n+        }\n+        \n+        return keyAnalyzer.compare(key, other) == 0;\n+    }\n+    \n+    /**\n+     * Returns true if both values are either null or equal\n+     */\n+    static boolean compare(final Object a, final Object b) {\n+        return a == null ? b == null : a.equals(b);\n+    }\n+    \n+    /**\n+     * A basic implementation of {@link Entry}\n+     */\n+    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n+        \n+        private static final long serialVersionUID = -944364551314110330L;\n+\n+        protected K key;\n+        \n+        protected V value;\n+        \n+        private final int hashCode;\n+        \n+        public BasicEntry(final K key) {\n+            this.key = key;\n+            this.hashCode = key != null ? key.hashCode() : 0;\n+        }\n+        \n+        public BasicEntry(final K key, final V value) {\n+            this.key = key;\n+            this.value = value;\n+            \n+            this.hashCode = (key != null ? key.hashCode() : 0)\n+                    ^ (value != null ? value.hashCode() : 0);\n+        }\n+        \n+        /**\n+         * Replaces the current key and value with the provided\n+         * key &amp; value\n+         */\n+        public V setKeyValue(final K key, final V value) {\n+            this.key = key;\n+            return setValue(value);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K getKey() {\n+            return key;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public V setValue(final V value) {\n+            final V previous = this.value;\n+            this.value = value;\n+            return previous;\n+        }\n+        \n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+        \n+        @Override\n+        public boolean equals(final Object o) {\n+            if (o == this) {\n+                return true;\n+            } else if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+            \n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>)o;\n+            if (compare(key, other.getKey()) \n+                    && compare(value, other.getValue())) {\n+                return true;\n+            }\n+            return false;\n+        }\n+        \n+        @Override\n+        public String toString() {\n+            return key + \"=\" + value;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/ByteArrayKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for byte[]s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ByteArrayKeyAnalyzer extends AbstractKeyAnalyzer<byte[]> {\n+    \n+    private static final long serialVersionUID = 7382825097492285877L;\n+\n+    /**\n+     * A singleton instance of {@link ByteArrayKeyAnalyzer}\n+     */\n+    public static final ByteArrayKeyAnalyzer INSTANCE \n+        = new ByteArrayKeyAnalyzer(Integer.MAX_VALUE);\n+    \n+    /**\n+     * The length of an {@link Byte} in bits\n+     */\n+    public static final int LENGTH = Byte.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x80;\n+    \n+    /**\n+     * A place holder for null\n+     */\n+    private static final byte[] NULL = new byte[0];\n+    \n+    /**\n+     * The maximum length of a key in bits\n+     */\n+    private final int maxLengthInBits;\n+    \n+    public ByteArrayKeyAnalyzer(final int maxLengthInBits) {\n+        if (maxLengthInBits < 0) {\n+            throw new IllegalArgumentException(\n+                    \"maxLengthInBits=\" + maxLengthInBits);\n+        }\n+        \n+        this.maxLengthInBits = maxLengthInBits;\n+    }\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * Returns the maximum length of a key in bits\n+     * @return the maximum key length in bits\n+     */\n+    public int getMaxLengthInBits() {\n+        return maxLengthInBits;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final byte[] key) {\n+        return key != null ? key.length * bitsPerElement() : 0;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final byte[] key, final int bitIndex, final int lengthInBits) {\n+        if (key == null) {     \n+            return false;\n+        }\n+        \n+        final int prefix = maxLengthInBits - lengthInBits;\n+        final int keyBitIndex = bitIndex - prefix;\n+        \n+        if (keyBitIndex >= lengthInBits || keyBitIndex < 0) {\n+            return false;\n+        }\n+        \n+        final int index = keyBitIndex / LENGTH;\n+        final int bit = keyBitIndex % LENGTH;\n+        return (key[index] & mask(bit)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final byte[] key, final int offsetInBits, final int lengthInBits, \n+            byte[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        \n+        if (other == null) {\n+            other = NULL;\n+        }\n+        \n+        boolean allNull = true;\n+        final int length = Math.max(lengthInBits, otherLengthInBits);\n+        final int prefix = maxLengthInBits - length;\n+        \n+        if (prefix < 0) {\n+            return KeyAnalyzer.OUT_OF_BOUNDS_BIT_KEY;\n+        }\n+        \n+        for (int i = 0; i < length; i++) {\n+            final int index = prefix + offsetInBits + i;\n+            final boolean value = isBitSet(key, index, lengthInBits);\n+                \n+            if (value) {\n+                allNull = false;\n+            }\n+            \n+            final int otherIndex = prefix + otherOffsetInBits + i;\n+            final boolean otherValue = isBitSet(other, otherIndex, otherLengthInBits);\n+            \n+            if (value != otherValue) {\n+                return index;\n+            }\n+        }\n+        \n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final byte[] prefix, final int offsetInBits, \n+            final int lengthInBits, final byte[] key) {\n+        \n+        final int keyLength = lengthInBits(key);\n+        if (lengthInBits > keyLength) {\n+            return false;\n+        }\n+        \n+        final int elements = lengthInBits - offsetInBits;\n+        for (int i = 0; i < elements; i++) {\n+            if (isBitSet(prefix, i+offsetInBits, lengthInBits) \n+                    != isBitSet(key, i, keyLength)) {\n+                return false;\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int compare(final byte[] o1, final byte[] o2) {\n+        if (o1 == null) {\n+            return o2 == null ? 0 : -1;\n+        } else if (o2 == null) {\n+            return 1;\n+        }\n+        \n+        if (o1.length != o2.length) {\n+            return o1.length - o2.length;\n+        }\n+        \n+        for (int i = 0; i < o1.length; i++) {\n+            final int diff = (o1[i] & 0xFF) - (o2[i] & 0xFF);\n+            if (diff != 0) {\n+                return diff;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/ByteKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Byte}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ByteKeyAnalyzer extends AbstractKeyAnalyzer<Byte> {\n+    \n+    private static final long serialVersionUID = 3395803342983289829L;\n+\n+    /**\n+     * A singleton instance of {@link ByteKeyAnalyzer}\n+     */\n+    public static final ByteKeyAnalyzer INSTANCE = new ByteKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Byte} in bits\n+     */\n+    public static final int LENGTH = Byte.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x80;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final Byte key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final Byte key, final int bitIndex, final int lengthInBits) {\n+        return (key.intValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final Byte key, final int offsetInBits, final int lengthInBits, \n+            final Byte other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        final byte keyValue = key.byteValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final byte otherValue = other != null ? other.byteValue() : 0;\n+        \n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final Byte prefix, final int offsetInBits, \n+            final int lengthInBits, final Byte key) {\n+        \n+        final int value1 = prefix.byteValue() << offsetInBits;\n+        final int value2 = key.byteValue();\n+        \n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/CharArrayKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * An {@link KeyAnalyzer} for {@code char[]}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CharArrayKeyAnalyzer extends AbstractKeyAnalyzer<char[]> {\n+    \n+    private static final long serialVersionUID = -8167897361549463457L;\n+\n+    /**\n+     * A singleton instance of {@link CharArrayKeyAnalyzer}\n+     */\n+    public static final CharArrayKeyAnalyzer INSTANCE = new CharArrayKeyAnalyzer();\n+\n+    /**\n+     * The number of bits per {@link Character}\n+     */\n+    public static final int LENGTH = Character.SIZE;\n+\n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+\n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final char[] key) {\n+        return key != null ? key.length * LENGTH : 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final char[] key, final int offsetInBits, final int lengthInBits,\n+            final char[] other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        boolean allNull = true;\n+\n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n+                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"The offsets and lengths must be at Character boundaries\");\n+        }\n+\n+\n+        final int beginIndex1 = offsetInBits / LENGTH;\n+        final int beginIndex2 = otherOffsetInBits / LENGTH;\n+\n+        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+\n+        final int length = Math.max(endIndex1, endIndex2);\n+\n+        // Look at each character, and if they're different\n+        // then figure out which bit makes the difference\n+        // and return it.\n+        char k = 0, f = 0;\n+        for(int i = 0; i < length; i++) {\n+            final int index1 = beginIndex1 + i;\n+            final int index2 = beginIndex2 + i;\n+\n+            if (index1 >= endIndex1) {\n+                k = 0;\n+            } else {\n+                k = key[index1];\n+            }\n+\n+            if (other == null || index2 >= endIndex2) {\n+                f = 0;\n+            } else {\n+                f = other[index2];\n+            }\n+\n+            if (k != f) {\n+               final int x = k ^ f;\n+               return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n+            }\n+\n+            if (k != 0) {\n+                allNull = false;\n+            }\n+        }\n+\n+        // All bits are 0\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+\n+        // Both keys are equal\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final char[] key, final int bitIndex, final int lengthInBits) {\n+        if (key == null || bitIndex >= lengthInBits) {\n+            return false;\n+        }\n+\n+        final int index = bitIndex / LENGTH;\n+        final int bit = bitIndex % LENGTH;\n+\n+        return (key[index] & mask(bit)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final char[] prefix, final int offsetInBits,\n+            final int lengthInBits, final char[] key) {\n+        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"Cannot determine prefix outside of Character boundaries\");\n+        }\n+\n+        final int off = offsetInBits / LENGTH;\n+        final int len = lengthInBits / LENGTH;\n+        for (int i = 0; i < len; i ++) {\n+            if (prefix[i + off] != key[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/CharacterKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Character}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CharacterKeyAnalyzer extends AbstractKeyAnalyzer<Character> {\n+    \n+    private static final long serialVersionUID = 3928565962744720753L;\n+    \n+    /**\n+     * A singleton instance of the {@link CharacterKeyAnalyzer}.\n+     */\n+    public static final CharacterKeyAnalyzer INSTANCE \n+        = new CharacterKeyAnalyzer();\n+    \n+    /**\n+     * The length of a {@link Character} in bits\n+     */\n+    public static final int LENGTH = Character.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final Character key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final Character key, final int bitIndex, final int lengthInBits) {\n+        return (key & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final Character key, final int offsetInBits, final int lengthInBits, \n+            Character other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        final char keyValue = key.charValue();\n+        if (keyValue == Character.MIN_VALUE) {\n+            return NULL_BIT_KEY;\n+        }\n+        \n+        if (other == null) {\n+            other = Character.MIN_VALUE;\n+        }\n+        \n+        final char otherValue = other != null ? other.charValue() : Character.MIN_VALUE;\n+        \n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final Character prefix, final int offsetInBits, \n+            final int lengthInBits, final Character key) {\n+        \n+        final int value1 = prefix.charValue() << offsetInBits;\n+        final int value2 = key.charValue();\n+        \n+        int mask = 0;\n+        for(int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/IntegerKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Integer}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class IntegerKeyAnalyzer extends AbstractKeyAnalyzer<Integer> {\n+    \n+    private static final long serialVersionUID = 4928508653722068982L;\n+    \n+    /**\n+     * A singleton instance of {@link IntegerKeyAnalyzer}\n+     */\n+    public static final IntegerKeyAnalyzer INSTANCE = new IntegerKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Integer} in bits\n+     */\n+    public static final int LENGTH = Integer.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x80000000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final Integer key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final Integer key, final int bitIndex, final int lengthInBits) {\n+        return (key.intValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final Integer key, final int offsetInBits, final int lengthInBits, \n+            final Integer other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        final int keyValue = key.intValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final int otherValue = other != null ? other.intValue() : 0;\n+        \n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final Integer prefix, final int offsetInBits, \n+            final int lengthInBits, final Integer key) {\n+        \n+        final int value1 = prefix.intValue() << offsetInBits;\n+        final int value2 = key.intValue();\n+        \n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/** \n+ * Defines the interface to analyze {@link org.apache.commons.collections4.Trie Trie} keys on a bit level. \n+ * {@link KeyAnalyzer}'s methods return the length of the key in bits, \n+ * whether or not a bit is set, and bits per element in the key. \n+ * <p>\n+ * Additionally, a method determines if a key is a prefix of another \n+ * key and returns the bit index where one key is different from another \n+ * key (if the key and found key are equal than the return value is \n+ * {@link #EQUAL_BIT_KEY}).\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface KeyAnalyzer<K> extends Comparator<K>, Serializable {\n+    \n+    /** \n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} \n+     * if key's bits are all 0 \n+     */\n+    public static final int NULL_BIT_KEY = -1;\n+    \n+    /** \n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} \n+     * if key and found key are equal. This is a very very specific case \n+     * and shouldn't happen on a regular basis\n+     */\n+    public static final int EQUAL_BIT_KEY = -2;\n+    \n+    public static final int OUT_OF_BOUNDS_BIT_KEY = -3;\n+    \n+    /**\n+     * Returns the number of bits per element in the key.\n+     * This is only useful for variable-length keys, such as Strings.\n+     * \n+     * @return the number of bits per element\n+     */\n+    public int bitsPerElement();\n+    \n+    /** \n+     * Returns the length of the Key in bits.\n+     * \n+     * @param key  the key\n+     * @return the bit length of the key\n+     */\n+    public int lengthInBits(K key);\n+    \n+    /** \n+     * Returns whether or not a bit is set.\n+     */\n+    public boolean isBitSet(K key, int bitIndex, int lengthInBits);\n+    \n+    /**\n+     * Returns the n-th different bit between key and found. This starts the comparison in\n+     * key at 'keyStart' and goes for 'keyLength' bits, and compares to the found key starting\n+     * at 'foundStart' and going for 'foundLength' bits.\n+     */\n+    public int bitIndex(K key, int offsetInBits, int lengthInBits,\n+                        K other, int otherOffsetInBits, int otherLengthInBits);\n+    \n+    /**\n+     * Determines whether or not the given prefix (from offset to length) is a prefix of the given key.\n+     */\n+    public boolean isPrefix(K prefix, int offsetInBits, int lengthInBits, K key);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/LongKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Long}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class LongKeyAnalyzer extends AbstractKeyAnalyzer<Long> {\n+    \n+    private static final long serialVersionUID = -4119639247588227409L;\n+\n+    /**\n+     * A singleton instance of {@link LongKeyAnalyzer}\n+     */\n+    public static final LongKeyAnalyzer INSTANCE = new LongKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Long} in bits\n+     */\n+    public static final int LENGTH = Long.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final long MSB = 0x8000000000000000L;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static long mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final Long key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final Long key, final int bitIndex, final int lengthInBits) {\n+        return (key.longValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final Long key, final int offsetInBits, final int lengthInBits, \n+            final Long other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        final long keyValue = key.longValue();\n+        if (keyValue == 0L) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final long otherValue = other != null ? other.longValue() : 0L;\n+        \n+        if (keyValue != otherValue) {\n+            final long xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0L) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final Long prefix, final int offsetInBits, \n+            final int lengthInBits, final Long key) {\n+        \n+        final long value1 = prefix.longValue() << offsetInBits;\n+        final long value2 = key.longValue();\n+        \n+        long mask = 0L;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1L << i;\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.Trie;\n+\n+/**\n+ * <h3>PATRICIA {@link Trie}</h3>\n+ *  \n+ * <i>Practical Algorithm to Retrieve Information Coded in Alphanumeric</i>\n+ * \n+ * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing \n+ * all data at the edges of the {@link Trie} (and having empty internal nodes), \n+ * PATRICIA stores data in every node. This allows for very efficient traversal, \n+ * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)} \n+ * operations. All operations are performed at worst in O(K) time, where K \n+ * is the number of bits in the largest item in the tree. In practice, \n+ * operations actually take O(A(K)) time, where A(K) is the average number of \n+ * bits of all items in the tree.\n+ * \n+ * <p>Most importantly, PATRICIA requires very few comparisons to keys while\n+ * doing any operation. While performing a lookup, each comparison (at most \n+ * K of them, described above) will perform a single bit comparison against \n+ * the given key, instead of comparing the entire key to another key.\n+ * \n+ * <p>The {@link Trie} can return operations in lexicographical order using the \n+ * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The \n+ * {@link Trie} can also scan for items that are 'bitwise' (using an XOR \n+ * metric) by the 'select' method. Bitwise closeness is determined by the \n+ * {@link KeyAnalyzer} returning true or false for a bit being set or not in \n+ * a given key.\n+ * \n+ * <p>This PATRICIA {@link Trie} supports both variable length & fixed length \n+ * keys. Some methods, such as {@link #getPrefixedBy(Object)} are suited only \n+ * to variable length keys, whereas {@link #getPrefixedByBits(Object, int)} is \n+ * suited to fixed-size keys.\n+ * \n+ * <p>Any methods here that take an {@link Object} argument may throw a \n+ * {@link ClassCastException} if the method is expecting an instance of K \n+ * and it isn't K.\n+ * \n+ * @see <a href=\"http://en.wikipedia.org/wiki/Radix_tree\">Radix Tree</a>\n+ * @see <a href=\"http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA\">PATRICIA</a>\n+ * @see <a href=\"http://www.imperialviolet.org/binary/critbit.pdf\">Crit-Bit Tree</a>\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PatriciaTrie<K, V> extends PatriciaTrieBase<K, V> implements Trie<K, V> {\n+    \n+    private static final long serialVersionUID = 4446367780901817838L;\n+\n+    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n+        super(keyAnalyzer);\n+    }\n+\n+    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer,\n+            final Map<? extends K, ? extends V> m) {\n+        super(keyAnalyzer, m);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Comparator<? super K> comparator() {\n+        return keyAnalyzer;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(final K key) {\n+        return getPrefixedByBits(key, 0, lengthInBits(key));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n+        return getPrefixedByBits(key, 0, length * bitsPerElement());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n+        final int bitsPerElement = bitsPerElement();\n+        return getPrefixedByBits(key, offset*bitsPerElement, length*bitsPerElement);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n+        return getPrefixedByBits(key, 0, lengthInBits);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K firstKey() {\n+        return firstEntry().getKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K lastKey() {\n+        final TrieEntry<K, V> entry = lastEntry();\n+        if (entry != null) {\n+            return entry.getKey();\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The view that this returns is optimized to have a very efficient\n+     * {@link Iterator}. The {@link SortedMap#firstKey()}, \n+     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must \n+     * iterate over all possible values in order to determine the results. \n+     * This information is cached until the PATRICIA {@link Trie} changes. \n+     * All other methods (except {@link Iterator}) must compare the given \n+     * key to the prefix to ensure that it is within the range of the view.  \n+     * The {@link Iterator}'s remove method must also relocate the subtree \n+     * that contains the prefixes if the entry holding the subtree is \n+     * removed or changes. Changing the subtree takes O(K) time.\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n+        \n+        final int offsetLength = offsetInBits + lengthInBits;\n+        if (offsetLength > lengthInBits(key)) {\n+            throw new IllegalArgumentException(offsetInBits + \" + \" \n+                    + lengthInBits + \" > \" + lengthInBits(key));\n+        }\n+        \n+        if (offsetLength == 0) {\n+            return this;\n+        }\n+        \n+        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return new RangeEntryMap(null, toKey);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return new RangeEntryMap(fromKey, toKey);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return new RangeEntryMap(fromKey, null);\n+    } \n+    \n+    /**\n+     * Returns an entry strictly higher than the given key,\n+     * or null if no such entry exists.\n+     */\n+    TrieEntry<K,V> higherEntry(final K key) {\n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                // If data in root, and more after -- return it.\n+                if (size() > 1) {\n+                    return nextEntry(root);\n+                } else { // If no more after, no higher entry.\n+                    return null;\n+                }\n+            } else {\n+                // Root is empty & we want something after empty, return first.\n+                return firstEntry();\n+            }\n+        }\n+        \n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return nextEntry(found);\n+        }\n+        \n+        final int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> ceil = nextEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return ceil;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return firstEntry();\n+            } else if (size() > 1) {\n+                return nextEntry(firstEntry());\n+            } else {\n+                return null;\n+            }\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return nextEntry(found);\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Returns a key-value mapping associated with the least key greater\n+     * than or equal to the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> ceilingEntry(final K key) {\n+        // Basically:\n+        // Follow the steps of adding an entry, but instead...\n+        //\n+        // - If we ever encounter a situation where we found an equal\n+        //   key, we return it immediately.\n+        //\n+        // - If we hit an empty root, return the first iterable item.\n+        //\n+        // - If we have to add a new item, we temporarily add it,\n+        //   find the successor to it, then remove the added item.\n+        //\n+        // These steps ensure that the returned value is either the\n+        // entry for the key itself, or the first entry directly after\n+        // the key.\n+        \n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return firstEntry();\n+            }\n+        }\n+        \n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return found;\n+        }\n+        \n+        final int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> ceil = nextEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return ceil;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return firstEntry();\n+            }\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return found;\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Returns a key-value mapping associated with the greatest key\n+     * strictly less than the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> lowerEntry(final K key) {\n+        // Basically:\n+        // Follow the steps of adding an entry, but instead...\n+        //\n+        // - If we ever encounter a situation where we found an equal\n+        //   key, we return it's previousEntry immediately.\n+        //\n+        // - If we hit root (empty or not), return null.\n+        //\n+        // - If we have to add a new item, we temporarily add it,\n+        //   find the previousEntry to it, then remove the added item.\n+        //\n+        // These steps ensure that the returned value is always just before\n+        // the key or null (if there was nothing before it).\n+        \n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            return null; // there can never be anything before root.\n+        }\n+        \n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return previousEntry(found);\n+        }\n+        \n+        final int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> prior = previousEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return prior;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            return null;\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return previousEntry(found);\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Returns a key-value mapping associated with the greatest key\n+     * less than or equal to the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> floorEntry(final K key) {        \n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return null;\n+            }\n+        }\n+        \n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return found;\n+        }\n+        \n+        final int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> floor = previousEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return floor;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return null;\n+            }\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return found;\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Finds the subtree that contains the prefix.\n+     * \n+     * This is very similar to getR but with the difference that\n+     * we stop the lookup if h.bitIndex > lengthInBits.\n+     */\n+    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex <= path.bitIndex \n+                    || lengthInBits < current.bitIndex) {\n+                break;\n+            }\n+            \n+            path = current;\n+            if (!isBitSet(prefix, offsetInBits + current.bitIndex, \n+                    offsetInBits + lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }        \n+\n+        // Make sure the entry is valid for a subtree.\n+        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n+        \n+        // If entry is root, it can't be empty.\n+        if (entry.isEmpty()) {\n+            return null;\n+        }\n+        \n+        final int endIndexInBits = offsetInBits + lengthInBits;\n+        \n+        // if root && length of root is less than length of lookup,\n+        // there's nothing.\n+        // (this prevents returning the whole subtree if root has an empty\n+        //  string and we want to lookup things with \"\\0\")\n+        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n+            return null;\n+        }\n+        \n+        // Found key's length-th bit differs from our key\n+        // which means it cannot be the prefix...\n+        if (isBitSet(prefix, endIndexInBits, endIndexInBits) \n+                != isBitSet(entry.key, lengthInBits, lengthInBits(entry.key))) {\n+            return null;\n+        }\n+        \n+        // ... or there are less than 'length' equal bits\n+        final int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits, \n+                lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));\n+        \n+        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n+            return null;\n+        }\n+        \n+        return entry;\n+    }\n+    \n+    /**\n+     * Returns the last entry the {@link Trie} is storing.\n+     * \n+     * <p>This is implemented by going always to the right until\n+     * we encounter a valid uplink. That uplink is the last key.\n+     */\n+    TrieEntry<K, V> lastEntry() {\n+        return followRight(root.left);\n+    }\n+    \n+    /**\n+     * Traverses down the right path until it finds an uplink.\n+     */\n+    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n+        // if Trie is empty, no last entry.\n+        if (node.right == null) {\n+            return null;\n+        }\n+        \n+        // Go as far right as possible, until we encounter an uplink.\n+        while (node.right.bitIndex > node.bitIndex) {\n+            node = node.right;\n+        }\n+        \n+        return node.right;\n+    }\n+    \n+    /**\n+     * Returns the node lexicographically before the given node (or null if none).\n+     * \n+     * This follows four simple branches:\n+     *  - If the uplink that returned us was a right uplink:\n+     *      - If predecessor's left is a valid uplink from predecessor, return it.\n+     *      - Else, follow the right path from the predecessor's left.\n+     *  - If the uplink that returned us was a left uplink:\n+     *      - Loop back through parents until we encounter a node where \n+     *        node != node.parent.left.\n+     *          - If node.parent.left is uplink from node.parent:\n+     *              - If node.parent.left is not root, return it.\n+     *              - If it is root & root isEmpty, return null.\n+     *              - If it is root & root !isEmpty, return root.\n+     *          - If node.parent.left is not uplink from node.parent:\n+     *              - Follow right path for first right child from node.parent.left   \n+     * \n+     * @param start\n+     */\n+    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n+        if (start.predecessor == null) {\n+            throw new IllegalArgumentException(\"must have come from somewhere!\");\n+        }\n+        \n+        if (start.predecessor.right == start) {\n+            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n+                return start.predecessor.left;\n+            } else {\n+                return followRight(start.predecessor.left);\n+            }\n+        } else {\n+            TrieEntry<K, V> node = start.predecessor;\n+            while (node.parent != null && node == node.parent.left) {\n+                node = node.parent;\n+            }\n+            \n+            if (node.parent == null) { // can be null if we're looking up root.\n+                return null;\n+            }\n+            \n+            if (isValidUplink(node.parent.left, node.parent)) {\n+                if (node.parent.left == root) {\n+                    if (root.isEmpty()) {\n+                        return null;\n+                    } else {\n+                        return root;\n+                    }\n+                    \n+                } else {\n+                    return node.parent.left;\n+                }\n+            } else {\n+                return followRight(node.parent.left);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Returns the entry lexicographically after the given entry.\n+     * If the given entry is null, returns the first node.\n+     * \n+     * This will traverse only within the subtree.  If the given node\n+     * is not within the subtree, this will have undefined results.\n+     */\n+    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node, \n+            final TrieEntry<K, V> parentOfSubtree) {\n+        if (node == null) {\n+            return firstEntry();\n+        } else {\n+            return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n+        }\n+    }\n+    \n+    /**\n+     * A range view of the {@link Trie}\n+     */\n+    private abstract class RangeMap extends AbstractMap<K, V> \n+            implements SortedMap<K, V> {\n+\n+        /**\n+         * The {@link #entrySet()} view\n+         */\n+        private transient volatile Set<Map.Entry<K, V>> entrySet;\n+\n+        /**\n+         * Creates and returns an {@link #entrySet()} \n+         * view of the {@link RangeMap}\n+         */\n+        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n+\n+        /**\n+         * Returns the FROM Key\n+         */\n+        protected abstract K getFromKey();\n+        \n+        /**\n+         * Whether or not the {@link #getFromKey()} is in the range\n+         */\n+        protected abstract boolean isFromInclusive();\n+        \n+        /**\n+         * Returns the TO Key\n+         */\n+        protected abstract K getToKey();\n+        \n+        /**\n+         * Whether or not the {@link #getToKey()} is in the range\n+         */\n+        protected abstract boolean isToInclusive();\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public Comparator<? super K> comparator() {\n+            return PatriciaTrie.this.comparator();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean containsKey(final Object key) {\n+            if (!inRange(castKey(key))) {\n+                return false;\n+            }\n+\n+            return PatriciaTrie.this.containsKey(key);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public V remove(final Object key) {\n+            if (!inRange(castKey(key))) {\n+                return null;\n+            }\n+\n+            return PatriciaTrie.this.remove(key);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public V get(final Object key) {\n+            if (!inRange(castKey(key))) {\n+                return null;\n+            }\n+\n+            return PatriciaTrie.this.get(key);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public V put(final K key, final V value) {\n+            if (!inRange(key)) {\n+                throw new IllegalArgumentException(\n+                        \"Key is out of range: \" + key);\n+            }\n+\n+            return PatriciaTrie.this.put(key, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Set<Map.Entry<K, V>> entrySet() {\n+            if (entrySet == null) {\n+                entrySet = createEntrySet();\n+            }\n+            return entrySet;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+            if (!inRange2(fromKey)) {\n+                throw new IllegalArgumentException(\n+                        \"FromKey is out of range: \" + fromKey);\n+            }\n+\n+            if (!inRange2(toKey)) {\n+                throw new IllegalArgumentException(\n+                        \"ToKey is out of range: \" + toKey);\n+            }\n+\n+            return createRangeMap(fromKey, isFromInclusive(), \n+                    toKey, isToInclusive());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public SortedMap<K, V> headMap(final K toKey) {\n+            if (!inRange2(toKey)) {\n+                throw new IllegalArgumentException(\n+                        \"ToKey is out of range: \" + toKey);\n+            }\n+\n+            return createRangeMap(getFromKey(), isFromInclusive(), \n+                    toKey, isToInclusive());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public SortedMap<K, V> tailMap(final K fromKey) {\n+            if (!inRange2(fromKey)) {\n+                throw new IllegalArgumentException(\n+                        \"FromKey is out of range: \" + fromKey);\n+            }\n+\n+            return createRangeMap(fromKey, isFromInclusive(), \n+                    getToKey(), isToInclusive());\n+        }\n+\n+        /**\n+         * Returns true if the provided key is greater than TO and\n+         * less than FROM\n+         */\n+        protected boolean inRange(final K key) {\n+\n+            final K fromKey = getFromKey();\n+            final K toKey = getToKey();\n+\n+            return (fromKey == null || inFromRange(key, false))\n+                    && (toKey == null || inToRange(key, false));\n+        }\n+\n+        /**\n+         * This form allows the high endpoint (as well as all legit keys)\n+         */\n+        protected boolean inRange2(final K key) {\n+\n+            final K fromKey = getFromKey();\n+            final K toKey = getToKey();\n+\n+            return (fromKey == null || inFromRange(key, false))\n+                    && (toKey == null || inToRange(key, true));\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the FROM range \n+         * of the {@link RangeMap}\n+         */\n+        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n+\n+            final K fromKey = getFromKey();\n+            final boolean fromInclusive = isFromInclusive();\n+\n+            final int ret = keyAnalyzer.compare(key, fromKey);\n+            if (fromInclusive || forceInclusive) {\n+                return ret >= 0;\n+            } else {\n+                return ret > 0;\n+            }\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the TO range \n+         * of the {@link RangeMap}\n+         */\n+        protected boolean inToRange(final K key, final boolean forceInclusive) {\n+\n+            final K toKey = getToKey();\n+            final boolean toInclusive = isToInclusive();\n+\n+            final int ret = keyAnalyzer.compare(key, toKey);\n+            if (toInclusive || forceInclusive) {\n+                return ret <= 0;\n+            } else {\n+                return ret < 0;\n+            }\n+        }\n+\n+        /**\n+         * Creates and returns a sub-range view of the current {@link RangeMap}\n+         */\n+        protected abstract SortedMap<K, V> createRangeMap(K fromKey,\n+                boolean fromInclusive, K toKey, boolean toInclusive);\n+    }\n+   \n+   /**\n+    * A {@link RangeMap} that deals with {@link Entry}s\n+    */\n+   private class RangeEntryMap extends RangeMap {\n+       \n+       /** \n+        * The key to start from, null if the beginning. \n+        */\n+       protected final K fromKey;\n+       \n+       /** \n+        * The key to end at, null if till the end. \n+        */\n+       protected final K toKey;\n+       \n+       /** \n+        * Whether or not the 'from' is inclusive. \n+        */\n+       protected final boolean fromInclusive;\n+       \n+       /** \n+        * Whether or not the 'to' is inclusive. \n+        */\n+       protected final boolean toInclusive;\n+       \n+       /**\n+        * Creates a {@link RangeEntryMap} with the fromKey included and\n+        * the toKey excluded from the range\n+        */\n+       protected RangeEntryMap(final K fromKey, final K toKey) {\n+           this(fromKey, true, toKey, false);\n+       }\n+       \n+       /**\n+        * Creates a {@link RangeEntryMap}\n+        */\n+       protected RangeEntryMap(final K fromKey, final boolean fromInclusive, \n+               final K toKey, final boolean toInclusive) {\n+           \n+           if (fromKey == null && toKey == null) {\n+               throw new IllegalArgumentException(\"must have a from or to!\");\n+           }\n+           \n+           if (fromKey != null && toKey != null \n+                   && keyAnalyzer.compare(fromKey, toKey) > 0) {\n+               throw new IllegalArgumentException(\"fromKey > toKey\");\n+           }\n+           \n+           this.fromKey = fromKey;\n+           this.fromInclusive = fromInclusive;\n+           this.toKey = toKey;\n+           this.toInclusive = toInclusive;\n+       }\n+       \n+       /**\n+        * {@inheritDoc}\n+        */\n+       public K firstKey() {\n+           Map.Entry<K,V> e = null;\n+           if (fromKey == null) {\n+               e = firstEntry();\n+           } else {\n+               if (fromInclusive) {\n+                   e = ceilingEntry(fromKey);\n+               } else {\n+                   e = higherEntry(fromKey);\n+               }\n+           }\n+           \n+           final K first = e != null ? e.getKey() : null;\n+           if (e == null || toKey != null && !inToRange(first, false)) {\n+               throw new NoSuchElementException();\n+           }\n+           return first;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       public K lastKey() {\n+           Map.Entry<K,V> e;\n+           if (toKey == null) {\n+               e = lastEntry();\n+           } else {\n+               if (toInclusive) {\n+                   e = floorEntry(toKey);\n+               } else {\n+                   e = lowerEntry(toKey);\n+               }\n+           }\n+           \n+           final K last = e != null ? e.getKey() : null;\n+           if (e == null || fromKey != null && !inFromRange(last, false)) {\n+               throw new NoSuchElementException();\n+           }\n+           return last;\n+       }\n+       \n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       protected Set<Entry<K, V>> createEntrySet() {\n+           return new RangeEntrySet(this);\n+       }\n+       \n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public K getFromKey() {\n+           return fromKey;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public K getToKey() {\n+           return toKey;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public boolean isFromInclusive() {\n+           return fromInclusive;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public boolean isToInclusive() {\n+           return toInclusive;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n+               final K toKey, final boolean toInclusive) {\n+           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n+       }\n+   }\n+   \n+    /**\n+     * A {@link Set} view of a {@link RangeMap}\n+     */\n+    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n+\n+        private final RangeMap delegate;\n+\n+        private transient int size = -1;\n+\n+        private transient int expectedModCount;\n+\n+        /**\n+         * Creates a {@link RangeEntrySet}\n+         */\n+        public RangeEntrySet(final RangeMap delegate) {\n+            if (delegate == null) {\n+                throw new NullPointerException(\"delegate\");\n+            }\n+\n+            this.delegate = delegate;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            final K fromKey = delegate.getFromKey();\n+            final K toKey = delegate.getToKey();\n+\n+            TrieEntry<K, V> first = null;\n+            if (fromKey == null) {\n+                first = firstEntry();\n+            } else {\n+                first = ceilingEntry(fromKey);\n+            }\n+\n+            TrieEntry<K, V> last = null;\n+            if (toKey != null) {\n+                last = ceilingEntry(toKey);\n+            }\n+\n+            return new EntryIterator(first, last);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            if (size == -1 || expectedModCount != PatriciaTrie.this.modCount) {\n+                size = 0;\n+\n+                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n+                    ++size;\n+                }\n+\n+                expectedModCount = PatriciaTrie.this.modCount;\n+            }\n+            return size;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean isEmpty() {\n+            return !iterator().hasNext();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public boolean contains(final Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            final K key = entry.getKey();\n+            if (!delegate.inRange(key)) {\n+                return false;\n+            }\n+\n+            final TrieEntry<K, V> node = getEntry(key);\n+            return node != null && compare(node.getValue(), entry.getValue());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public boolean remove(final Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            final K key = entry.getKey();\n+            if (!delegate.inRange(key)) {\n+                return false;\n+            }\n+\n+            final TrieEntry<K, V> node = getEntry(key);\n+            if (node != null && compare(node.getValue(), entry.getValue())) {\n+                removeEntry(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+        \n+        /** \n+         * An {@link Iterator} for {@link RangeEntrySet}s. \n+         */\n+        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+            \n+            private final K excludedKey;\n+\n+            /**\n+             * Creates a {@link EntryIterator}\n+             */\n+            private EntryIterator(\n+                    final TrieEntry<K,V> first, \n+                    final TrieEntry<K,V> last) {\n+                super(first);\n+                \n+                this.excludedKey = last != null ? last.getKey() : null;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            @Override\n+            public boolean hasNext() {\n+                return next != null && !compare(next.key, excludedKey);\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public Map.Entry<K,V> next() {\n+                if (next == null || compare(next.key, excludedKey)) {\n+                    throw new NoSuchElementException();\n+                }\n+                \n+                return nextEntry();\n+            }\n+        }\n+    }   \n+   \n+    /** \n+     * A submap used for prefix views over the {@link Trie}. \n+     */\n+    private class PrefixRangeMap extends RangeMap {\n+        \n+        private final K prefix;\n+        \n+        private final int offsetInBits;\n+        \n+        private final int lengthInBits;\n+        \n+        private K fromKey = null;\n+        \n+        private K toKey = null;\n+        \n+        private transient int expectedModCount = 0;\n+        \n+        private int size = -1;\n+        \n+        /**\n+         * Creates a {@link PrefixRangeMap}\n+         */\n+        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n+            this.prefix = prefix;\n+            this.offsetInBits = offsetInBits;\n+            this.lengthInBits = lengthInBits;\n+        }\n+        \n+        /**\n+         * This method does two things. It determinates the FROM\n+         * and TO range of the {@link PrefixRangeMap} and the number\n+         * of elements in the range. This method must be called every \n+         * time the {@link Trie} has changed.\n+         */\n+        private int fixup() {\n+            // The trie has changed since we last\n+            // found our toKey / fromKey\n+            if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount) {\n+                final Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n+                size = 0;\n+                \n+                Map.Entry<K, V> entry = null;\n+                if (it.hasNext()) {\n+                    entry = it.next();\n+                    size = 1;\n+                }\n+                \n+                fromKey = entry == null ? null : entry.getKey();\n+                if (fromKey != null) {\n+                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n+                    fromKey = prior == null ? null : prior.getKey();\n+                }\n+                \n+                toKey = fromKey;\n+                \n+                while (it.hasNext()) {\n+                    ++size;\n+                    entry = it.next();\n+                }\n+                \n+                toKey = entry == null ? null : entry.getKey();\n+                \n+                if (toKey != null) {\n+                    entry = nextEntry((TrieEntry<K, V>)entry);\n+                    toKey = entry == null ? null : entry.getKey();\n+                }\n+                \n+                expectedModCount = PatriciaTrie.this.modCount;\n+            }\n+            \n+            return size;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K firstKey() {\n+            fixup();\n+            \n+            Map.Entry<K,V> e = null;\n+            if (fromKey == null) {\n+                e = firstEntry();\n+            } else {\n+                e = higherEntry(fromKey);\n+            }\n+            \n+            final K first = e != null ? e.getKey() : null;\n+            if (e == null || !keyAnalyzer.isPrefix(prefix, \n+                    offsetInBits, lengthInBits, first)) {\n+                throw new NoSuchElementException();\n+            }\n+            \n+            return first;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K lastKey() {\n+            fixup();\n+            \n+            Map.Entry<K,V> e = null;\n+            if (toKey == null) {\n+                e = lastEntry();\n+            } else {\n+                e = lowerEntry(toKey);\n+            }\n+            \n+            final K last = e != null ? e.getKey() : null;\n+            if (e == null || !keyAnalyzer.isPrefix(prefix, \n+                    offsetInBits, lengthInBits, last)) {\n+                throw new NoSuchElementException();\n+            }\n+            \n+            return last;\n+        }\n+        \n+        /**\n+         * Returns true if this {@link PrefixRangeMap}'s key is a prefix\n+         * of the provided key.\n+         */\n+        @Override\n+        protected boolean inRange(final K key) {\n+            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+\n+        /**\n+         * Same as {@link #inRange(Object)}\n+         */\n+        @Override\n+        protected boolean inRange2(final K key) {\n+            return inRange(key);\n+        }\n+        \n+        /**\n+         * Returns true if the provided Key is in the FROM range\n+         * of the {@link PrefixRangeMap}\n+         */\n+        @Override\n+        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n+            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+        \n+        /**\n+         * Returns true if the provided Key is in the TO range\n+         * of the {@link PrefixRangeMap}\n+         */\n+        @Override\n+        protected boolean inToRange(final K key, final boolean forceInclusive) {\n+            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        protected Set<Map.Entry<K, V>> createEntrySet() {\n+            return new PrefixRangeEntrySet(this);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public K getFromKey() {\n+            return fromKey;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public K getToKey() {\n+            return toKey;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean isFromInclusive() {\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean isToInclusive() {\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        protected SortedMap<K, V> createRangeMap(\n+                final K fromKey, final boolean fromInclusive,\n+                final K toKey, final boolean toInclusive) {\n+            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n+        }\n+    }\n+    \n+    /**\n+     * A prefix {@link RangeEntrySet} view of the {@link Trie}\n+     */\n+    private final class PrefixRangeEntrySet extends RangeEntrySet {\n+        \n+        private final PrefixRangeMap delegate;\n+        \n+        private TrieEntry<K, V> prefixStart;\n+        \n+        private int expectedModCount = 0;\n+        \n+        /**\n+         * Creates a {@link PrefixRangeEntrySet}\n+         */\n+        public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n+            super(delegate);\n+            this.delegate = delegate;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return delegate.fixup();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            if (PatriciaTrie.this.modCount != expectedModCount) {\n+                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n+                expectedModCount = PatriciaTrie.this.modCount;\n+            }\n+            \n+            if (prefixStart == null) {\n+                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n+                return empty.iterator();\n+            } else if (delegate.lengthInBits >= prefixStart.bitIndex) {\n+                return new SingletonIterator(prefixStart);\n+            } else {\n+                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n+            }\n+        }\n+        \n+        /** \n+         * An {@link Iterator} that holds a single {@link TrieEntry}. \n+         */\n+        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n+            \n+            private final TrieEntry<K, V> entry;\n+            \n+            private int hit = 0;\n+            \n+            public SingletonIterator(final TrieEntry<K, V> entry) {\n+                this.entry = entry;\n+            }\n+            \n+            /**\n+             * {@inheritDoc}\n+             */\n+            public boolean hasNext() {\n+                return hit == 0;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public Map.Entry<K, V> next() {\n+                if (hit != 0) {\n+                    throw new NoSuchElementException();\n+                }\n+                \n+                ++hit;\n+                return entry;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public void remove() {\n+                if (hit != 1) {\n+                    throw new IllegalStateException();\n+                }\n+                \n+                ++hit;\n+                PatriciaTrie.this.removeEntry(entry);\n+            }\n+        }\n+        \n+        /** \n+         * An {@link Iterator} for iterating over a prefix search. \n+         */\n+        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n+            \n+            // values to reset the subtree if we remove it.\n+            protected final K prefix; \n+            protected final int offset;\n+            protected final int lengthInBits;\n+            protected boolean lastOne;\n+            \n+            protected TrieEntry<K, V> subtree; // the subtree to search within\n+            \n+            /**\n+             * Starts iteration at the given entry & search only \n+             * within the given subtree.\n+             */\n+            EntryIterator(final TrieEntry<K, V> startScan, final K prefix, \n+                    final int offset, final int lengthInBits) {\n+                subtree = startScan;\n+                next = PatriciaTrie.this.followLeft(startScan);\n+                this.prefix = prefix;\n+                this.offset = offset;\n+                this.lengthInBits = lengthInBits;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public Map.Entry<K,V> next() {\n+                final Map.Entry<K, V> entry = nextEntry();\n+                if (lastOne) {\n+                    next = null;\n+                }\n+                return entry;\n+            }\n+            \n+            /**\n+             * {@inheritDoc}\n+             */\n+            @Override\n+            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n+                return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n+            }\n+            \n+            /**\n+             * {@inheritDoc}\n+             */\n+            @Override\n+            public void remove() {\n+                // If the current entry we're removing is the subtree\n+                // then we need to find a new subtree parent.\n+                boolean needsFixing = false;\n+                final int bitIdx = subtree.bitIndex;\n+                if (current == subtree) {\n+                    needsFixing = true;\n+                }\n+                \n+                super.remove();\n+                \n+                // If the subtree changed its bitIndex or we\n+                // removed the old subtree, get a new one.\n+                if (bitIdx != subtree.bitIndex || needsFixing) {\n+                    subtree = subtree(prefix, offset, lengthInBits);\n+                }\n+                \n+                // If the subtree's bitIndex is less than the\n+                // length of our prefix, it's the last item\n+                // in the prefix tree.\n+                if (lengthInBits >= subtree.bitIndex) {\n+                    lastOne = true;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Trie.Cursor.Decision;\n+\n+/**\n+ * This class implements the base PATRICIA algorithm and everything that\n+ * is related to the {@link Map} interface.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+abstract class PatriciaTrieBase<K, V> extends AbstractTrie<K, V> {\n+    \n+    private static final long serialVersionUID = 5155253417231339498L;\n+\n+    /**\n+     * The root node of the {@link Trie}. \n+     */\n+    final TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n+    \n+    /**\n+     * Each of these fields are initialized to contain an instance of the\n+     * appropriate view the first time this view is requested. The views are\n+     * stateless, so there's no reason to create more than one of each.\n+     */\n+    private transient volatile Set<K> keySet;\n+    private transient volatile Collection<V> values;\n+    private transient volatile Set<Map.Entry<K,V>> entrySet;\n+    \n+    /**\n+     * The current size of the {@link Trie}\n+     */\n+    private int size = 0;\n+    \n+    /**\n+     * The number of times this {@link Trie} has been modified.\n+     * It's used to detect concurrent modifications and fail-fast\n+     * the {@link Iterator}s.\n+     */\n+    transient int modCount = 0;\n+    \n+    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer) {\n+        super(keyAnalyzer);\n+    }\n+    \n+    /**\n+     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given {@link KeyAnalyzer} \n+     * and initializes the {@link org.apache.commons.collections4.Trie Trie} with the values from the \n+     * provided {@link Map}.\n+     */\n+    public PatriciaTrieBase(final KeyAnalyzer<? super K> keyAnalyzer, \n+            final Map<? extends K, ? extends V> m) {\n+        super(keyAnalyzer);\n+        \n+        if (m == null) {\n+            throw new NullPointerException(\"m\");\n+        }\n+        \n+        putAll(m);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        root.key = null;\n+        root.bitIndex = -1;\n+        root.value = null;\n+        \n+        root.parent = null;\n+        root.left = root;\n+        root.right = null;\n+        root.predecessor = root;\n+        \n+        size = 0;\n+        incrementModCount();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+   \n+    /**\n+     * A helper method to increment the {@link Trie} size\n+     * and the modification counter.\n+     */\n+    void incrementSize() {\n+        size++;\n+        incrementModCount();\n+    }\n+    \n+    /**\n+     * A helper method to decrement the {@link Trie} size\n+     * and increment the modification counter.\n+     */\n+    void decrementSize() {\n+        size--;\n+        incrementModCount();\n+    }\n+    \n+    /**\n+     * A helper method to increment the modification counter.\n+     */\n+    private void incrementModCount() {\n+        ++modCount;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V put(final K key, final V value) {\n+        if (key == null) {\n+            throw new NullPointerException(\"Key cannot be null\");\n+        }\n+        \n+        final int lengthInBits = lengthInBits(key);\n+        \n+        // The only place to store a key with a length\n+        // of zero bits is the root node\n+        if (lengthInBits == 0) {\n+            if (root.isEmpty()) {\n+                incrementSize();\n+            } else {\n+                incrementModCount();\n+            }\n+            return root.setKeyValue(key, value);\n+        }\n+        \n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            if (found.isEmpty()) { // <- must be the root\n+                incrementSize();\n+            } else {\n+                incrementModCount();\n+            }\n+            return found.setKeyValue(key, value);\n+        }\n+        \n+        final int bitIndex = bitIndex(key, found.key);\n+        if (!AbstractKeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n+            if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n+                /* NEW KEY+VALUE TUPLE */\n+                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n+                addEntry(t, lengthInBits);\n+                incrementSize();\n+                return null;\n+            } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+                // A bits of the Key are zero. The only place to\n+                // store such a Key is the root Node!\n+                \n+                /* NULL BIT KEY */\n+                if (root.isEmpty()) {\n+                    incrementSize();\n+                } else {\n+                    incrementModCount();\n+                }\n+                return root.setKeyValue(key, value);\n+                \n+            } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+                // This is a very special and rare case.\n+                \n+                /* REPLACE OLD KEY+VALUE */\n+                if (found != root) {\n+                    incrementModCount();\n+                    return found.setKeyValue(key, value);\n+                }\n+            }\n+        }\n+        \n+        throw new IndexOutOfBoundsException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n+    }\n+    \n+    /**\n+     * Adds the given {@link TrieEntry} to the {@link Trie}\n+     */\n+    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex >= entry.bitIndex \n+                    || current.bitIndex <= path.bitIndex) {\n+                entry.predecessor = entry;\n+                \n+                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n+                    entry.left = entry;\n+                    entry.right = current;\n+                } else {\n+                    entry.left = current;\n+                    entry.right = entry;\n+                }\n+               \n+                entry.parent = path;\n+                if (current.bitIndex >= entry.bitIndex) {\n+                    current.parent = entry;\n+                }\n+                \n+                // if we inserted an uplink, set the predecessor on it\n+                if (current.bitIndex <= path.bitIndex) {\n+                    current.predecessor = entry;\n+                }\n+         \n+                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n+                    path.left = entry;\n+                } else {\n+                    path.right = entry;\n+                }\n+                \n+                return entry;\n+            }\n+                \n+            path = current;\n+            \n+            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V get(final Object k) {\n+        final TrieEntry<K, V> entry = getEntry(k);\n+        return entry != null ? entry.getValue() : null;\n+    }\n+\n+    /**\n+     * Returns the entry associated with the specified key in the\n+     * PatriciaTrieBase.  Returns null if the map contains no mapping\n+     * for this key.\n+     * \n+     * This may throw ClassCastException if the object is not of type K.\n+     */\n+    TrieEntry<K,V> getEntry(final Object k) {\n+        final K key = castKey(k);\n+        if (key == null) {\n+            return null;\n+        }\n+        \n+        final int lengthInBits = lengthInBits(key);\n+        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n+        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Map.Entry<K, V> select(final K key) {\n+        final int lengthInBits = lengthInBits(key);\n+        final Reference<Map.Entry<K, V>> reference \n+            = new Reference<Map.Entry<K,V>>();\n+        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n+            return reference.get();\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Map.Entry<K,V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n+        final int lengthInBits = lengthInBits(key);\n+        final Reference<Map.Entry<K, V>> reference \n+            = new Reference<Map.Entry<K,V>>();\n+        selectR(root.left, -1, key, lengthInBits, cursor, reference);\n+        return reference.get();\n+    }\n+\n+    /**\n+     * This is equivalent to the other {@link #selectR(TrieEntry, int, \n+     * Object, int, Cursor, Reference)} method but without its overhead \n+     * because we're selecting only one best matching Entry from the \n+     * {@link Trie}.\n+     */\n+    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex, \n+            final K key, final int lengthInBits, \n+            final Reference<Map.Entry<K, V>> reference) {\n+        \n+        if (h.bitIndex <= bitIndex) {\n+            // If we hit the root Node and it is empty\n+            // we have to look for an alternative best\n+            // matching node.\n+            if (!h.isEmpty()) {\n+                reference.set(h);\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n+            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n+                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n+            }\n+        } else {\n+            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n+                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * \n+     */\n+    private boolean selectR(final TrieEntry<K,V> h, final int bitIndex, \n+            final K key, \n+            final int lengthInBits,\n+            final Cursor<? super K, ? super V> cursor,\n+            final Reference<Map.Entry<K, V>> reference) {\n+\n+        if (h.bitIndex <= bitIndex) {\n+            if (!h.isEmpty()) {\n+                final Decision decision = cursor.select(h);\n+                switch(decision) {\n+                    case REMOVE:\n+                        throw new UnsupportedOperationException(\"Cannot remove during select\");\n+                    case EXIT:\n+                        reference.set(h);\n+                        return false; // exit\n+                    case REMOVE_AND_EXIT:\n+                        final TrieEntry<K, V> entry = new TrieEntry<K, V>(\n+                                h.getKey(), h.getValue(), -1);\n+                        reference.set(entry);\n+                        removeEntry(h);\n+                        return false;\n+                    case CONTINUE:\n+                        // fall through.\n+                    default:\n+                        break;\n+                }\n+            }\n+            return true; // continue\n+        }\n+\n+        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n+            if (selectR(h.left, h.bitIndex, key, lengthInBits, cursor, reference)) {\n+                return selectR(h.right, h.bitIndex, key, lengthInBits, cursor, reference);\n+            }\n+        } else {\n+            if (selectR(h.right, h.bitIndex, key, lengthInBits, cursor, reference)) {\n+                return selectR(h.left, h.bitIndex, key, lengthInBits, cursor, reference);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Map.Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n+        TrieEntry<K, V> entry = nextEntry(null);\n+        while (entry != null) {\n+            final TrieEntry<K, V> current = entry;\n+            \n+            final Decision decision = cursor.select(current);\n+            entry = nextEntry(current);\n+            \n+            switch(decision) {\n+                case EXIT:\n+                    return current;\n+                case REMOVE:\n+                    removeEntry(current);\n+                    break; // out of switch, stay in while loop\n+                case REMOVE_AND_EXIT:\n+                    final Map.Entry<K, V> value = new TrieEntry<K, V>(\n+                            current.getKey(), current.getValue(), -1);\n+                    removeEntry(current);\n+                    return value;\n+                case CONTINUE: // do nothing.\n+                default:\n+                    break;\n+            }\n+        }\n+        \n+        return null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean containsKey(final Object k) {\n+        if (k == null) {\n+            return false;\n+        }\n+        \n+        final K key = castKey(k);\n+        final int lengthInBits = lengthInBits(key);\n+        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n+        return !entry.isEmpty() && compareKeys(key, entry.key);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Set<Map.Entry<K,V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet();\n+        }\n+        return entrySet;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet();\n+        }\n+        return keySet;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values();\n+        }\n+        return values;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @throws ClassCastException if provided key is of an incompatible type \n+     */\n+    @Override\n+    public V remove(final Object k) {\n+        if (k == null) {\n+            return null;\n+        }\n+        \n+        final K key = castKey(k);\n+        final int lengthInBits = lengthInBits(key);        \n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while (true) {\n+            if (current.bitIndex <= path.bitIndex) {\n+                if (!current.isEmpty() && compareKeys(key, current.key)) {\n+                    return removeEntry(current);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            \n+            path = current;\n+            \n+            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Returns the nearest entry for a given key.  This is useful\n+     * for finding knowing if a given key exists (and finding the value\n+     * for it), or for inserting the key.\n+     * \n+     * The actual get implementation. This is very similar to\n+     * selectR but with the exception that it might return the\n+     * root Entry even if it's empty.\n+     */\n+    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex <= path.bitIndex) {\n+                return current;\n+            }\n+            \n+            path = current;\n+            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Removes a single entry from the {@link Trie}.\n+     * \n+     * If we found a Key (Entry h) then figure out if it's\n+     * an internal (hard to remove) or external Entry (easy \n+     * to remove)\n+     */\n+    V removeEntry(final TrieEntry<K, V> h) {\n+        if (h != root) {\n+            if (h.isInternalNode()) {\n+                removeInternalEntry(h);\n+            } else {\n+                removeExternalEntry(h);\n+            }\n+        }\n+        \n+        decrementSize();\n+        return h.setKeyValue(null, null);\n+    }\n+    \n+    /**\n+     * Removes an external entry from the {@link Trie}.\n+     * \n+     * If it's an external Entry then just remove it.\n+     * This is very easy and straight forward.\n+     */\n+    private void removeExternalEntry(final TrieEntry<K, V> h) {\n+        if (h == root) {\n+            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n+        } else if (!h.isExternalNode()) {\n+            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n+        } \n+        \n+        final TrieEntry<K, V> parent = h.parent;\n+        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n+        \n+        if (parent.left == h) {\n+            parent.left = child;\n+        } else {\n+            parent.right = child;\n+        }\n+        \n+        // either the parent is changing, or the predecessor is changing.\n+        if (child.bitIndex > parent.bitIndex) {\n+            child.parent = parent;\n+        } else {\n+            child.predecessor = parent;\n+        }\n+        \n+    }\n+    \n+    /**\n+     * Removes an internal entry from the {@link Trie}.\n+     * \n+     * If it's an internal Entry then \"good luck\" with understanding\n+     * this code. The Idea is essentially that Entry p takes Entry h's\n+     * place in the trie which requires some re-wiring.\n+     */\n+    private void removeInternalEntry(final TrieEntry<K, V> h) {\n+        if (h == root) {\n+            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n+        } else if (!h.isInternalNode()) {\n+            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n+        } \n+        \n+        final TrieEntry<K, V> p = h.predecessor;\n+        \n+        // Set P's bitIndex\n+        p.bitIndex = h.bitIndex;\n+        \n+        // Fix P's parent, predecessor and child Nodes\n+        {\n+            final TrieEntry<K, V> parent = p.parent;\n+            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n+            \n+            // if it was looping to itself previously,\n+            // it will now be pointed from it's parent\n+            // (if we aren't removing it's parent --\n+            //  in that case, it remains looping to itself).\n+            // otherwise, it will continue to have the same\n+            // predecessor.\n+            if (p.predecessor == p && p.parent != h) {\n+                p.predecessor = p.parent;\n+            }\n+            \n+            if (parent.left == p) {\n+                parent.left = child;\n+            } else {\n+                parent.right = child;\n+            }\n+            \n+            if (child.bitIndex > parent.bitIndex) {\n+                child.parent = parent;\n+            }\n+        }\n+        \n+        // Fix H's parent and child Nodes\n+        {         \n+            // If H is a parent of its left and right child \n+            // then change them to P\n+            if (h.left.parent == h) {\n+                h.left.parent = p;\n+            }\n+            \n+            if (h.right.parent == h) {\n+                h.right.parent = p;\n+            }\n+            \n+            // Change H's parent\n+            if (h.parent.left == h) {\n+                h.parent.left = p;\n+            } else {\n+                h.parent.right = p;\n+            }\n+        }\n+        \n+        // Copy the remaining fields from H to P\n+        //p.bitIndex = h.bitIndex;\n+        p.parent = h.parent;\n+        p.left = h.left;\n+        p.right = h.right;\n+        \n+        // Make sure that if h was pointing to any uplinks,\n+        // p now points to them.\n+        if (isValidUplink(p.left, p)) {\n+            p.left.predecessor = p;\n+        }\n+        \n+        if (isValidUplink(p.right, p)) {\n+            p.right.predecessor = p;\n+        }   \n+    }\n+    \n+    /**\n+     * Returns the entry lexicographically after the given entry.\n+     * If the given entry is null, returns the first node.\n+     */\n+    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n+        if (node == null) {\n+            return firstEntry();\n+        } else {\n+            return nextEntryImpl(node.predecessor, node, null);\n+        }\n+    }\n+    \n+    /**\n+     * Scans for the next node, starting at the specified point, and using 'previous'\n+     * as a hint that the last node we returned was 'previous' (so we know not to return\n+     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n+     * \n+     * The basic premise is that each iteration can follow the following steps:\n+     * \n+     * 1) Scan all the way to the left.\n+     *   a) If we already started from this node last time, proceed to Step 2.\n+     *   b) If a valid uplink is found, use it.\n+     *   c) If the result is an empty node (root not set), break the scan.\n+     *   d) If we already returned the left node, break the scan.\n+     *   \n+     * 2) Check the right.\n+     *   a) If we already returned the right node, proceed to Step 3.\n+     *   b) If it is a valid uplink, use it.\n+     *   c) Do Step 1 from the right node.\n+     *   \n+     * 3) Back up through the parents until we encounter find a parent\n+     *    that we're not the right child of.\n+     *    \n+     * 4) If there's no right child of that parent, the iteration is finished.\n+     *    Otherwise continue to Step 5.\n+     * \n+     * 5) Check to see if the right child is a valid uplink.\n+     *    a) If we already returned that child, proceed to Step 6.\n+     *       Otherwise, use it.\n+     *    \n+     * 6) If the right child of the parent is the parent itself, we've\n+     *    already found & returned the end of the Trie, so exit.\n+     *    \n+     * 7) Do Step 1 on the parent's right child.\n+     */\n+    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start, \n+            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n+        \n+        TrieEntry<K, V> current = start;\n+\n+        // Only look at the left if this was a recursive or\n+        // the first check, otherwise we know we've already looked\n+        // at the left.\n+        if (previous == null || start != previous.predecessor) {\n+            while (!current.left.isEmpty()) {\n+                // stop traversing if we've already\n+                // returned the left of this node.\n+                if (previous == current.left) {\n+                    break;\n+                }\n+                \n+                if (isValidUplink(current.left, current)) {\n+                    return current.left;\n+                }\n+                \n+                current = current.left;\n+            }\n+        }\n+        \n+        // If there's no data at all, exit.\n+        if (current.isEmpty()) {\n+            return null;\n+        }\n+        \n+        // If we've already returned the left,\n+        // and the immediate right is null,\n+        // there's only one entry in the Trie\n+        // which is stored at the root.\n+        //\n+        //  / (\"\")   <-- root\n+        //  \\_/  \\\n+        //       null <-- 'current'\n+        //\n+        if (current.right == null) {\n+            return null;\n+        }\n+        \n+        // If nothing valid on the left, try the right.\n+        if (previous != current.right) {\n+            // See if it immediately is valid.\n+            if (isValidUplink(current.right, current)) {\n+                return current.right;\n+            }\n+            \n+            // Must search on the right's side if it wasn't initially valid.\n+            return nextEntryImpl(current.right, previous, tree);\n+        }\n+        \n+        // Neither left nor right are valid, find the first parent\n+        // whose child did not come from the right & traverse it.\n+        while (current == current.parent.right) {\n+            // If we're going to traverse to above the subtree, stop.\n+            if (current == tree) {\n+                return null;\n+            }\n+            \n+            current = current.parent;\n+        }\n+\n+        // If we're on the top of the subtree, we can't go any higher.\n+        if (current == tree) {\n+            return null;\n+        }\n+        \n+        // If there's no right, the parent must be root, so we're done.\n+        if (current.parent.right == null) {\n+            return null;\n+        }\n+        \n+        // If the parent's right points to itself, we've found one.\n+        if (previous != current.parent.right \n+                && isValidUplink(current.parent.right, current.parent)) {\n+            return current.parent.right;\n+        }\n+        \n+        // If the parent's right is itself, there can't be any more nodes.\n+        if (current.parent.right == current.parent) {\n+            return null;\n+        }\n+        \n+        // We need to traverse down the parent's right's path.\n+        return nextEntryImpl(current.parent.right, previous, tree);\n+    }\n+    \n+    /**\n+     * Returns the first entry the {@link Trie} is storing.\n+     * \n+     * This is implemented by going always to the left until\n+     * we encounter a valid uplink. That uplink is the first key.\n+     */\n+    TrieEntry<K, V> firstEntry() {\n+        // if Trie is empty, no first node.\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        \n+        return followLeft(root);\n+    }\n+    \n+    /** \n+     * Goes left through the tree until it finds a valid node. \n+     */\n+    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n+        while(true) {\n+            TrieEntry<K, V> child = node.left;\n+            // if we hit root and it didn't have a node, go right instead.\n+            if (child.isEmpty()) {\n+                child = node.right;\n+            }\n+            \n+            if (child.bitIndex <= node.bitIndex) {\n+                return child;\n+            }\n+            \n+            node = child;\n+        }\n+    }\n+    \n+    /** \n+     * Returns true if 'next' is a valid uplink coming from 'from'. \n+     */\n+    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) { \n+        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n+    }\n+    \n+    /**\n+     * A {@link Reference} allows us to return something through a Method's \n+     * argument list. An alternative would be to an Array with a length of \n+     * one (1) but that leads to compiler warnings. Computationally and memory\n+     * wise there's no difference (except for the need to load the \n+     * {@link Reference} Class but that happens only once).\n+     */\n+    private static class Reference<E> {\n+        \n+        private E item;\n+        \n+        public void set(final E item) {\n+            this.item = item;\n+        }\n+        \n+        public E get() {\n+            return item;\n+        }\n+    }\n+    \n+    /**\n+     *  A {@link Trie} is a set of {@link TrieEntry} nodes\n+     */\n+    static class TrieEntry<K,V> extends BasicEntry<K, V> {\n+        \n+        private static final long serialVersionUID = 4596023148184140013L;\n+        \n+        /** The index this entry is comparing. */\n+        protected int bitIndex;\n+        \n+        /** The parent of this entry. */\n+        protected TrieEntry<K,V> parent;\n+        \n+        /** The left child of this entry. */\n+        protected TrieEntry<K,V> left;\n+        \n+        /** The right child of this entry. */\n+        protected TrieEntry<K,V> right;\n+        \n+        /** The entry who uplinks to this entry. */ \n+        protected TrieEntry<K,V> predecessor;\n+        \n+        public TrieEntry(final K key, final V value, final int bitIndex) {\n+            super(key, value);\n+            \n+            this.bitIndex = bitIndex;\n+            \n+            this.parent = null;\n+            this.left = this;\n+            this.right = null;\n+            this.predecessor = this;\n+        }\n+        \n+        /**\n+         * Whether or not the entry is storing a key.\n+         * Only the root can potentially be empty, all other\n+         * nodes must have a key.\n+         */\n+        public boolean isEmpty() {\n+            return key == null;\n+        }\n+        \n+        /** \n+         * Neither the left nor right child is a loopback \n+         */\n+        public boolean isInternalNode() {\n+            return left != this && right != this;\n+        }\n+        \n+        /** \n+         * Either the left or right child is a loopback \n+         */\n+        public boolean isExternalNode() {\n+            return !isInternalNode();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            final StringBuilder buffer = new StringBuilder();\n+            \n+            if (bitIndex == -1) {\n+                buffer.append(\"RootEntry(\");\n+            } else {\n+                buffer.append(\"Entry(\");\n+            }\n+            \n+            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n+            buffer.append(\"value=\").append(getValue()).append(\", \");\n+            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n+            \n+            if (parent != null) {\n+                if (parent.bitIndex == -1) {\n+                    buffer.append(\"parent=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"parent=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+            \n+            if (left != null) {\n+                if (left.bitIndex == -1) {\n+                    buffer.append(\"left=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"left=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+            \n+            if (right != null) {\n+                if (right.bitIndex == -1) {\n+                    buffer.append(\"right=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"right=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+            \n+            if (predecessor != null) {\n+                if(predecessor.bitIndex == -1) {\n+                    buffer.append(\"predecessor=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n+                           append(predecessor.bitIndex).append(\"]\");\n+                }\n+            }\n+            \n+            buffer.append(\")\");\n+            return buffer.toString();\n+        }\n+    }\n+    \n+\n+    /**\n+     * This is a entry set view of the {@link Trie} as returned \n+     * by {@link Map#entrySet()}\n+     */\n+    private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            return new EntryIterator();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean contains(final Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+            \n+            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n+            return candidate != null && candidate.equals(o);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean remove(final Object o) {\n+            final int size = size();\n+            PatriciaTrieBase.this.remove(o);\n+            return size != size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return PatriciaTrieBase.this.size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void clear() {\n+            PatriciaTrieBase.this.clear();\n+        }\n+        \n+        /**\n+         * An {@link Iterator} that returns {@link Entry} Objects\n+         */\n+        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+            public Map.Entry<K,V> next() {\n+                return nextEntry();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * This is a key set view of the {@link Trie} as returned \n+     * by {@link Map#keySet()}\n+     */\n+    private class KeySet extends AbstractSet<K> {\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new KeyIterator();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return PatriciaTrieBase.this.size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean contains(final Object o) {\n+            return containsKey(o);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean remove(final Object o) {\n+            final int size = size();\n+            PatriciaTrieBase.this.remove(o);\n+            return size != size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void clear() {\n+            PatriciaTrieBase.this.clear();\n+        }\n+        \n+        /**\n+         * An {@link Iterator} that returns Key Objects\n+         */\n+        private class KeyIterator extends TrieIterator<K> {\n+            public K next() {\n+                return nextEntry().getKey();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * This is a value view of the {@link Trie} as returned \n+     * by {@link Map#values()}\n+     */\n+    private class Values extends AbstractCollection<V> {\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new ValueIterator();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return PatriciaTrieBase.this.size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean contains(final Object o) {\n+            return containsValue(o);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void clear() {\n+            PatriciaTrieBase.this.clear();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean remove(final Object o) {\n+            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n+                final V value = it.next();\n+                if (compare(value, o)) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        \n+        /**\n+         * An {@link Iterator} that returns Value Objects\n+         */\n+        private class ValueIterator extends TrieIterator<V> {\n+            public V next() {\n+                return nextEntry().getValue();\n+            }\n+        }\n+    }\n+    \n+    /** \n+     * An iterator for the entries. \n+     */\n+    abstract class TrieIterator<E> implements Iterator<E> {\n+        \n+        /**\n+         * For fast-fail\n+         */\n+        protected int expectedModCount = PatriciaTrieBase.this.modCount;\n+        \n+        protected TrieEntry<K, V> next; // the next node to return\n+        protected TrieEntry<K, V> current; // the current entry we're on\n+        \n+        /**\n+         * Starts iteration from the root\n+         */\n+        protected TrieIterator() {\n+            next = PatriciaTrieBase.this.nextEntry(null);\n+        }\n+        \n+        /**\n+         * Starts iteration at the given entry\n+         */\n+        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n+            next = firstEntry;\n+        }\n+        \n+        /**\n+         * Returns the next {@link TrieEntry}\n+         */\n+        protected TrieEntry<K,V> nextEntry() { \n+            if (expectedModCount != PatriciaTrieBase.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            \n+            final TrieEntry<K,V> e = next;\n+            if (e == null) {\n+                throw new NoSuchElementException();\n+            }\n+            \n+            next = findNext(e);\n+            current = e;\n+            return e;\n+        }\n+        \n+        /**\n+         * @see PatriciaTrie#nextEntry(TrieEntry)\n+         */\n+        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n+            return PatriciaTrieBase.this.nextEntry(prior);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean hasNext() {\n+            return next != null;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void remove() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            \n+            if (expectedModCount != PatriciaTrieBase.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            \n+            final TrieEntry<K, V> node = current;\n+            current = null;\n+            PatriciaTrieBase.this.removeEntry(node);\n+            \n+            expectedModCount = PatriciaTrieBase.this.modCount;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/ShortKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Short}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ShortKeyAnalyzer implements KeyAnalyzer<Short> {\n+    \n+    private static final long serialVersionUID = -8631376733513512017L;\n+\n+    /**\n+     * A singleton instance of {@link ShortKeyAnalyzer}\n+     */\n+    public static final ShortKeyAnalyzer INSTANCE = new ShortKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Short} in bits\n+     */\n+    public static final int LENGTH = Short.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final Short key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final Short key, final int bitIndex, final int lengthInBits) {\n+        return (key.intValue() & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final Short key, final int offsetInBits, final int lengthInBits, \n+            final Short other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        final int keyValue = key.shortValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        final int otherValue = other != null ? other.shortValue() : 0;\n+        \n+        if (keyValue != otherValue) {\n+            final int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int compare(final Short o1, final Short o2) {\n+        return o1.compareTo(o2);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final Short prefix, final int offsetInBits, \n+            final int lengthInBits, final Short key) {\n+        \n+        final int value1 = prefix.shortValue() << offsetInBits;\n+        final int value2 = key.shortValue();\n+        \n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= 0x1 << i;\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/StringKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+/**\n+ * An {@link KeyAnalyzer} for {@link String}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class StringKeyAnalyzer extends AbstractKeyAnalyzer<String> {\n+    \n+    private static final long serialVersionUID = -7032449491269434877L;\n+    \n+    /**\n+     * A singleton instance of {@link StringKeyAnalyzer}\n+     */\n+    public static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();\n+    \n+    /**\n+     * The number of bits per {@link Character}\n+     */\n+    public static final int LENGTH = Character.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(final int bit) {\n+        return MSB >>> bit;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(final String key) {\n+        return key != null ? key.length() * LENGTH : 0;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(final String key, final int offsetInBits, final int lengthInBits,\n+            final String other, final int otherOffsetInBits, final int otherLengthInBits) {\n+        boolean allNull = true;\n+        \n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 \n+                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"The offsets and lengths must be at Character boundaries\");\n+        }\n+        \n+        \n+        final int beginIndex1 = offsetInBits / LENGTH;\n+        final int beginIndex2 = otherOffsetInBits / LENGTH;\n+        \n+        final int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        final int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+        \n+        final int length = Math.max(endIndex1, endIndex2);\n+        \n+        // Look at each character, and if they're different\n+        // then figure out which bit makes the difference\n+        // and return it.\n+        char k = 0, f = 0;\n+        for(int i = 0; i < length; i++) {\n+            final int index1 = beginIndex1 + i;\n+            final int index2 = beginIndex2 + i;\n+            \n+            if (index1 >= endIndex1) {\n+                k = 0;\n+            } else {\n+                k = key.charAt(index1);\n+            }\n+            \n+            if (other == null || index2 >= endIndex2) {\n+                f = 0;\n+            } else {\n+                f = other.charAt(index2);\n+            }\n+            \n+            if (k != f) {\n+               final int x = k ^ f;\n+               return i * LENGTH + Integer.numberOfLeadingZeros(x) - LENGTH;\n+            }\n+            \n+            if (k != 0) {\n+                allNull = false;\n+            }\n+        }\n+        \n+        // All bits are 0\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+        \n+        // Both keys are equal\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(final String key, final int bitIndex, final int lengthInBits) {\n+        if (key == null || bitIndex >= lengthInBits) {\n+            return false;\n+        }\n+        \n+        final int index = bitIndex / LENGTH;\n+        final int bit = bitIndex % LENGTH;\n+        \n+        return (key.charAt(index) & mask(bit)) != 0;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(final String prefix, final int offsetInBits, \n+            final int lengthInBits, final String key) {\n+        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"Cannot determine prefix outside of Character boundaries\");\n+        }\n+    \n+        final String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n+        return key.startsWith(s1);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.Trie;\n+import org.apache.commons.collections4.collection.SynchronizedCollection;\n+\n+/**\n+ * A synchronized {@link Trie}.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class SynchronizedTrie<K, V> implements Trie<K, V>, Serializable {\n+    \n+    private static final long serialVersionUID = 3121878833178676939L;\n+    \n+    private final Trie<K, V> delegate;\n+    \n+    /**\n+     * Factory method to create a synchronized trie.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param trie  the trie to decorate, must not be null\n+     * @return a new synchronized trie\n+     * @throws IllegalArgumentException if trie is null\n+     */\n+    public static <K, V> SynchronizedTrie<K, V> synchronizedTrie(final Trie<K, V> trie) {\n+        return new SynchronizedTrie<K, V>(trie);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param trie  the trie to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public SynchronizedTrie(final Trie<K, V> trie) {\n+        if (trie == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.delegate = trie;\n+    }\n+\n+    public synchronized Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n+        return delegate.select(key, cursor);\n+    }\n+\n+    public synchronized Entry<K, V> select(final K key) {\n+        return delegate.select(key);\n+    }\n+\n+    public synchronized K selectKey(final K key) {\n+        return delegate.selectKey(key);\n+    }\n+\n+    public synchronized V selectValue(final K key) {\n+        return delegate.selectValue(key);\n+    }\n+\n+    public synchronized Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n+        return delegate.traverse(cursor);\n+    }\n+    \n+    public synchronized Set<Entry<K, V>> entrySet() {\n+        return Collections.synchronizedSet(delegate.entrySet());\n+    }\n+\n+    public synchronized Set<K> keySet() {\n+        return Collections.synchronizedSet(delegate.keySet());\n+    }\n+\n+    public synchronized Collection<V> values() {\n+        return SynchronizedCollection.synchronizedCollection(delegate.values());\n+    }\n+\n+    public synchronized void clear() {\n+        delegate.clear();\n+    }\n+\n+    public synchronized boolean containsKey(final Object key) {\n+        return delegate.containsKey(key);\n+    }\n+\n+    public synchronized boolean containsValue(final Object value) {\n+        return delegate.containsValue(value);\n+    }\n+\n+    public synchronized V get(final Object key) {\n+        return delegate.get(key);\n+    }\n+\n+    public synchronized boolean isEmpty() {\n+        return delegate.isEmpty();\n+    }\n+\n+    public synchronized V put(final K key, final V value) {\n+        return delegate.put(key, value);\n+    }\n+\n+    public synchronized void putAll(final Map<? extends K, ? extends V> m) {\n+        delegate.putAll(m);\n+    }\n+\n+    public synchronized V remove(final Object key) {\n+        return delegate.remove(key);\n+    }\n+    \n+    public synchronized K lastKey() {\n+        return delegate.lastKey();\n+    }\n+\n+    public synchronized SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return Collections.synchronizedSortedMap(delegate.subMap(fromKey, toKey));\n+    }\n+\n+    public synchronized SortedMap<K, V> tailMap(final K fromKey) {\n+        return Collections.synchronizedSortedMap(delegate.tailMap(fromKey));\n+    }\n+    \n+    public synchronized Comparator<? super K> comparator() {\n+        return delegate.comparator();\n+    }\n+\n+    public synchronized K firstKey() {\n+        return delegate.firstKey();\n+    }\n+\n+    public synchronized SortedMap<K, V> headMap(final K toKey) {\n+        return Collections.synchronizedSortedMap(delegate.headMap(toKey));\n+    }\n+    \n+    public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, offset, length));\n+    }\n+\n+    public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, length));\n+    }\n+\n+    public synchronized SortedMap<K, V> getPrefixedBy(final K key) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key));\n+    }\n+\n+    public synchronized SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n+    }\n+\n+    public synchronized SortedMap<K, V> getPrefixedByBits(final K key, \n+            final int offsetInBits, final int lengthInBits) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n+    }\n+\n+    public synchronized int size() {\n+        return delegate.size();\n+    }\n+\n+    @Override\n+    public synchronized int hashCode() {\n+        return delegate.hashCode();\n+    }\n+    \n+    @Override\n+    public synchronized boolean equals(final Object obj) {\n+        return delegate.equals(obj);\n+    }\n+    \n+    @Override\n+    public synchronized String toString() {\n+        return delegate.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections4.Trie;\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/**\n+ * An unmodifiable {@link Trie}.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodifiable {\n+    \n+    private static final long serialVersionUID = -7156426030315945159L;\n+    \n+    private final Trie<K, V> delegate;\n+    \n+    /**\n+     * Factory method to create a unmodifiable trie.\n+     * \n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param trie  the trie to decorate, must not be null\n+     * @return a new unmodifiable trie\n+     * @throws IllegalArgumentException if trie is null\n+     */\n+    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(final Trie<K, V> trie) {\n+        return new UnmodifiableTrie<K, V>(trie);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param trie  the trie to decorate, must not be null\n+     * @throws IllegalArgumentException if trie is null\n+     */\n+    public UnmodifiableTrie(final Trie<K, V> trie) {\n+        if (trie == null) {\n+            throw new IllegalArgumentException(\"Trie must not be null\");\n+        }\n+        this.delegate = trie;\n+    }\n+    \n+    public Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n+        final Cursor<K, V> c = new Cursor<K, V>() {\n+            public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n+                final Decision decision = cursor.select(entry);\n+                switch (decision) {\n+                    case REMOVE:\n+                    case REMOVE_AND_EXIT:\n+                        throw new UnsupportedOperationException();\n+                    default:\n+                        // other decisions are fine\n+                        break;\n+                }\n+                \n+                return decision;\n+            }\n+        };\n+        \n+        return delegate.select(key, c);\n+    }\n+\n+    public Entry<K, V> select(final K key) {\n+        return delegate.select(key);\n+    }\n+\n+    public K selectKey(final K key) {\n+        return delegate.selectKey(key);\n+    }\n+\n+    public V selectValue(final K key) {\n+        return delegate.selectValue(key);\n+    }\n+\n+    public Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n+        final Cursor<K, V> c = new Cursor<K, V>() {\n+            public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n+                final Decision decision = cursor.select(entry);\n+                switch (decision) {\n+                    case REMOVE:\n+                    case REMOVE_AND_EXIT:\n+                        throw new UnsupportedOperationException();\n+                    default:\n+                        // other decisions are fine\n+                        break;\n+                }\n+                \n+                return decision;\n+            }\n+        };\n+        \n+        return delegate.traverse(c);\n+    }\n+\n+    public Set<Entry<K, V>> entrySet() {\n+        return Collections.unmodifiableSet(delegate.entrySet());\n+    }\n+    \n+    public Set<K> keySet() {\n+        return Collections.unmodifiableSet(delegate.keySet());\n+    }\n+\n+    public Collection<V> values() {\n+        return Collections.unmodifiableCollection(delegate.values());\n+    }\n+\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public boolean containsKey(final Object key) {\n+        return delegate.containsKey(key);\n+    }\n+\n+    public boolean containsValue(final Object value) {\n+        return delegate.containsValue(value);\n+    }\n+\n+    public V get(final Object key) {\n+        return delegate.get(key);\n+    }\n+\n+    public boolean isEmpty() {\n+        return delegate.isEmpty();\n+    }\n+\n+    public V put(final K key, final V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void putAll(final Map<? extends K, ? extends V> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public V remove(final Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public K firstKey() {\n+        return delegate.firstKey();\n+    }\n+\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n+    }\n+\n+    public K lastKey() {\n+        return delegate.lastKey();\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.subMap(fromKey, toKey));\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n+    }\n+    \n+    public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedBy(key, offset, length));\n+    }\n+\n+    public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedBy(key, length));\n+    }\n+\n+    public SortedMap<K, V> getPrefixedBy(final K key) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedBy(key));\n+    }\n+\n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedByBits(key, lengthInBits));\n+    }\n+    \n+    public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n+        return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n+    }\n+\n+    public Comparator<? super K> comparator() {\n+        return delegate.comparator();\n+    }\n+    \n+    public int size() {\n+        return delegate.size();\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        return delegate.hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(final Object obj) {\n+        return delegate.equals(obj);\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return delegate.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link org.apache.commons.collections4.Trie Trie} interface.\n+ * <p>\n+ * The implementations are in the form of direct implementations and decorators.\n+ * A decorator wraps another implementation of the interface to add some\n+ * specific additional functionality.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>PatriciaTrie - an implementation of a PATRICIA trie\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided:\n+ * <ul>\n+ *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.trie;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/AbstractArrayListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.collections4.list.AbstractListTest;\n+\n+/**\n+ * Abstract test class for ArrayList.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractArrayListTest<E> extends AbstractListTest<E> {\n+\n+    public AbstractArrayListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract ArrayList<E> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    public void testNewArrayList() {\n+        final ArrayList<E> list = makeObject();\n+        assertTrue(\"New list is empty\", list.isEmpty());\n+        assertEquals(\"New list has size zero\", 0, list.size());\n+\n+        try {\n+            list.get(1);\n+            fail(\"get(int i) should have thrown IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // Expected result\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        final ArrayList<E> list = makeObject();\n+        list.add((E) \"First Item\");\n+        list.add((E) \"Last Item\");\n+        assertEquals(\"First item is 'First Item'\", \"First Item\", list.get(0));\n+        assertEquals(\"Last Item is 'Last Item'\", \"Last Item\", list.get(1));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.list.AbstractListTest;\n+\n+/**\n+ * Tests base {@link java.util.LinkedList} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link LinkedList} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link List} fails.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Rich Dougherty\n+ */\n+public abstract class AbstractLinkedListTest<T> extends AbstractListTest<T> {\n+\n+    public AbstractLinkedListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public abstract LinkedList<T> makeObject();\n+\n+    /**\n+     *  Returns the {@link #collection} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the collection field as a List\n+     */\n+    @Override\n+    public LinkedList<T> getCollection() {\n+        return (LinkedList<T>) super.getCollection();\n+    }\n+\n+    /**\n+     *  Returns the {@link #confirmed} field cast to a {@link LinkedList}.\n+     *\n+     *  @return the confirmed field as a List\n+     */\n+    protected LinkedList<T> getConfirmedLinkedList() {\n+        return (LinkedList<T>) getConfirmed();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addFirst(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLinkedListAddFirst() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        final T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+\n+        resetFull();\n+        getCollection().addFirst(o);\n+        getConfirmedLinkedList().addFirst(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#addLast(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLinkedListAddLast() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        final T o = (T) \"hello\";\n+\n+        resetEmpty();\n+        getCollection().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+\n+        resetFull();\n+        getCollection().addLast(o);\n+        getConfirmedLinkedList().addLast(o);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getFirst()}.\n+     */\n+    public void testLinkedListGetFirst() {\n+        resetEmpty();\n+        try {\n+            getCollection().getFirst();\n+            fail(\"getFirst() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (final NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        final Object first = getCollection().getFirst();\n+        final Object confirmedFirst = getConfirmedLinkedList().getFirst();\n+        assertEquals(\"Result returned by getFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#getLast()}.\n+     */\n+    public void testLinkedListGetLast() {\n+        resetEmpty();\n+        try {\n+            getCollection().getLast();\n+            fail(\"getLast() should throw a NoSuchElementException for an \" +\n+                    \"empty list.\");\n+        } catch (final NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        final Object last = getCollection().getLast();\n+        final Object confirmedLast = getConfirmedLinkedList().getLast();\n+        assertEquals(\"Result returned by getLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeFirst()}.\n+     */\n+    public void testLinkedListRemoveFirst() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        try {\n+            getCollection().removeFirst();\n+            fail(\"removeFirst() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (final NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+        \n+        resetFull();\n+        final Object first = getCollection().removeFirst();\n+        final Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n+        assertEquals(\"Result returned by removeFirst() was wrong.\",\n+                confirmedFirst, first);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link LinkedList#removeLast()}.\n+     */\n+    public void testLinkedListRemoveLast() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        try {\n+            getCollection().removeLast();\n+            fail(\"removeLast() should throw a NoSuchElementException for \" +\n+                    \"an empty list.\");\n+        } catch (final NoSuchElementException e) {\n+            // This is correct\n+        }\n+        verify();\n+\n+        resetFull();\n+        final Object last = getCollection().removeLast();\n+        final Object confirmedLast = getConfirmedLinkedList().removeLast();\n+        assertEquals(\"Result returned by removeLast() was wrong.\",\n+                confirmedLast, last);\n+        verify();\n+    }\n+\n+    /**\n+     *  Returns an empty {@link LinkedList}.\n+     */\n+    @Override\n+    public Collection<T> makeConfirmedCollection() {\n+        return new LinkedList<T>();\n+    }\n+\n+    /**\n+     *  Returns a full {@link LinkedList}.\n+     */\n+    @Override\n+    public Collection<T> makeConfirmedFullCollection() {\n+        final List<T> list = new LinkedList<T>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Abstract test class for {@link java.lang.Object} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject()} method.\n+ * <p>\n+ * If your {@link Object} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Object} fails.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractObjectTest extends BulkTest {\n+\n+    /** Current major release for Collections */\n+    public static final int COLLECTIONS_MAJOR_VERSION = 4;\n+    \n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractObjectTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return the object to test.\n+     * \n+     * @return the object to test\n+     */\n+    public abstract Object makeObject();\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize an \"empty\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsEmptyCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Override this method if a subclass is testing an object\n+     * that cannot serialize a \"full\" Collection.\n+     * (e.g. Comparators have no contents)\n+     * \n+     * @return true\n+     */\n+    public boolean supportsFullCollections() {\n+        return true;\n+    }\n+\n+    /**\n+     * Is serialization testing supported.\n+     * Default is true.\n+     */\n+    public boolean isTestSerialization() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns true;\n+     */\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testObjectEqualsSelf() {\n+        final Object obj = makeObject();\n+        assertEquals(\"A Object should equal itself\", obj, obj);\n+    }\n+\n+    public void testEqualsNull() {\n+        final Object obj = makeObject();\n+        assertEquals(false, obj.equals(null)); // make sure this doesn't throw NPE either\n+    }\n+\n+    public void testObjectHashCodeEqualsSelfHashCode() {\n+        final Object obj = makeObject();\n+        assertEquals(\"hashCode should be repeatable\", obj.hashCode(), obj.hashCode());\n+    }\n+\n+    public void testObjectHashCodeEqualsContract() {\n+        final Object obj1 = makeObject();\n+        if (obj1.equals(obj1)) {\n+            assertEquals(\n+                \"[1] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj1.hashCode());\n+        }\n+        final Object obj2 = makeObject();\n+        if (obj1.equals(obj2)) {\n+            assertEquals(\n+                \"[2] When two objects are equal, their hashCodes should be also.\",\n+                obj1.hashCode(), obj2.hashCode());\n+            assertTrue(\n+                \"When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true\",\n+                obj2.equals(obj1));\n+        }\n+    }\n+\n+    protected Object serializeDeserialize(final Object obj) throws Exception {\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(obj);\n+        out.close();\n+\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final Object dest = in.readObject();\n+        in.close();\n+\n+        return dest;\n+    }\n+\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        final Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            final Object dest = serializeDeserialize(obj);\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj))\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sanity check method, makes sure that any Serializable\n+     * class can be serialized and de-serialized in memory, \n+     * using the handy makeObject() method\n+     * \n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    public void testSimpleSerialization() throws Exception {\n+        final Object o = makeObject();\n+        if (o instanceof Serializable && isTestSerialization()) {\n+            final byte[] objekt = writeExternalFormToBytes((Serializable) o);\n+            readExternalFormFromBytes(objekt);\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalEmptyCollectionExists() {\n+        if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            final Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                final String name = getCanonicalEmptyCollectionName(object);\n+                assertTrue(\n+                    \"Canonical empty collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests serialization by comparing against a previously stored version in SVN.\n+     * If the test object is serializable, confirm that a canonical form exists.\n+     */\n+    public void testCanonicalFullCollectionExists() {\n+        if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n+            final Object object = makeObject();\n+            if (object instanceof Serializable) {\n+                final String name = getCanonicalFullCollectionName(object);\n+                assertTrue(\n+                    \"Canonical full collection (\" + name + \") is not in SVN\",\n+                    new File(name).exists());\n+            }\n+        }\n+    }\n+\n+    // protected implementation\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the version of Collections that this object tries to\n+     * maintain serialization compatibility with. Defaults to 4, due to\n+     * the package change to collections4 introduced in version 4.\n+     * \n+     * This constant makes it possible for TestMap (and other subclasses,\n+     * if necessary) to automatically check SVN for a versionX copy of a\n+     * Serialized object, so we can make sure that compatibility is maintained.\n+     * See, for example, TestMap.getCanonicalFullMapName(Map map).\n+     * Subclasses can override this variable, indicating compatibility\n+     * with earlier Collections versions.\n+     * \n+     * @return The version, or <code>null</code> if this object shouldn't be\n+     * tested for compatibility with previous versions.\n+     */\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    protected String getCanonicalEmptyCollectionName(final Object object) {\n+        final StringBuilder retval = new StringBuilder();\n+        retval.append(TEST_DATA_PATH);\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".emptyCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    protected String getCanonicalFullCollectionName(final Object object) {\n+        final StringBuilder retval = new StringBuilder();\n+        retval.append(TEST_DATA_PATH);\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\") + 1, colName.length());\n+        retval.append(colName);\n+        retval.append(\".fullCollection.version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Write a Serializable or Externalizable object as\n+     * a file at the given path.  NOT USEFUL as part\n+     * of a unit test; this is just a utility method\n+     * for creating disk-based objects in SVN that can become\n+     * the basis for compatibility tests using\n+     * readExternalFormFromDisk(String path)\n+     * \n+     * @param o Object to serialize\n+     * @param path path to write the serialized Object\n+     * @exception IOException\n+     */\n+    protected void writeExternalFormToDisk(final Serializable o, final String path) throws IOException {\n+        final FileOutputStream fileStream = new FileOutputStream(path);\n+        writeExternalFormToStream(o, fileStream);\n+    }\n+\n+    /**\n+     * Converts a Serializable or Externalizable object to\n+     * bytes.  Useful for in-memory tests of serialization\n+     * \n+     * @param o Object to convert to bytes\n+     * @return serialized form of the Object\n+     * @exception IOException\n+     */\n+    protected byte[] writeExternalFormToBytes(final Serializable o) throws IOException {\n+        final ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n+        writeExternalFormToStream(o, byteStream);\n+        return byteStream.toByteArray();\n+    }\n+\n+    /**\n+     * Reads a Serialized or Externalized Object from disk.\n+     * Useful for creating compatibility tests between\n+     * different SVN versions of the same class\n+     * \n+     * @param path path to the serialized Object\n+     * @return the Object at the given path\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromDisk(final String path) throws IOException, ClassNotFoundException {\n+        final FileInputStream stream = new FileInputStream(path);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    /**\n+     * Read a Serialized or Externalized Object from bytes.\n+     * Useful for verifying serialization in memory.\n+     * \n+     * @param b byte array containing a serialized Object\n+     * @return Object contained in the bytes\n+     * @exception IOException\n+     * @exception ClassNotFoundException\n+     */\n+    protected Object readExternalFormFromBytes(final byte[] b) throws IOException, ClassNotFoundException {\n+        final ByteArrayInputStream stream = new ByteArrayInputStream(b);\n+        return readExternalFormFromStream(stream);\n+    }\n+\n+    protected boolean skipSerializedCanonicalTests() {\n+        return Boolean.getBoolean(\"org.apache.commons.collections:with-clover\");\n+    }\n+\n+    // private implementation\n+    //-----------------------------------------------------------------------\n+    private Object readExternalFormFromStream(final InputStream stream) throws IOException, ClassNotFoundException {\n+        final ObjectInputStream oStream = new ObjectInputStream(stream);\n+        return oStream.readObject();\n+    }\n+\n+    private void writeExternalFormToStream(final Serializable o, final OutputStream stream) throws IOException {\n+        final ObjectOutputStream oStream = new ObjectOutputStream(stream);\n+        oStream.writeObject(o);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/AbstractTreeMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.map.AbstractMapTest;\n+\n+/**\n+ * Tests TreeMap.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractTreeMapTest<K, V> extends AbstractMapTest<K, V> {\n+\n+    public AbstractTreeMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract TreeMap<K, V> makeObject();\n+\n+    public void testNewMap() {\n+        final TreeMap<K, V> map = makeObject();\n+        assertTrue(\"New map is empty\", map.isEmpty());\n+        assertEquals(\"New map has size zero\", 0, map.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        final TreeMap<K, V> map = makeObject();\n+        map.put((K) \"first\", (V) \"First Item\");\n+        map.put((K) \"second\", (V) \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\",\n+            \"First Item\", map.get(\"first\"));\n+        assertEquals(\"Next Item is 'First Item'\",\n+            \"Second Item\", map.get(\"second\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/ArrayStackTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.EmptyStackException;\n+\n+import org.apache.commons.collections4.ArrayStack;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Tests ArrayStack.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"deprecation\") // we test a deprecated class\n+public class ArrayStackTest<E> extends AbstractArrayListTest<E> {\n+    \n+    public ArrayStackTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ArrayStackTest.class);\n+    }\n+\n+    @Override\n+    public ArrayStack<E> makeObject() {\n+        return new ArrayStack<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNewStack() {\n+        final ArrayStack<E> stack = makeObject();\n+        assertTrue(\"New stack is empty\", stack.empty());\n+        assertEquals(\"New stack has size zero\", 0, stack.size());\n+\n+        try {\n+            stack.peek();\n+            fail(\"peek() should have thrown EmptyStackException\");\n+        } catch (final EmptyStackException e) {\n+            // Expected result\n+        }\n+\n+        try {\n+            stack.pop();\n+            fail(\"pop() should have thrown EmptyStackException\");\n+        } catch (final EmptyStackException e) {\n+            // Expected result\n+        }\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPushPeekPop() {\n+        final ArrayStack<E> stack = makeObject();\n+\n+        stack.push((E) \"First Item\");\n+        assertTrue(\"Stack is not empty\", !stack.empty());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+        assertEquals(\"Top item is 'First Item'\",\n+                     \"First Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+\n+        stack.push((E) \"Second Item\");\n+        assertEquals(\"Stack size is two\", 2, stack.size());\n+        assertEquals(\"Top item is 'Second Item'\",\n+                     \"Second Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is two\", 2, stack.size());\n+\n+        assertEquals(\"Popped item is 'Second Item'\",\n+                     \"Second Item\", (String) stack.pop());\n+        assertEquals(\"Top item is 'First Item'\",\n+                     \"First Item\", (String) stack.peek());\n+        assertEquals(\"Stack size is one\", 1, stack.size());\n+\n+        assertEquals(\"Popped item is 'First Item'\",\n+                     \"First Item\", (String) stack.pop());\n+        assertEquals(\"Stack size is zero\", 0, stack.size());\n+\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSearch() {\n+        final ArrayStack<E> stack = makeObject();\n+\n+        stack.push((E) \"First Item\");\n+        stack.push((E) \"Second Item\");\n+        assertEquals(\"Top item is 'Second Item'\",\n+                     1, stack.search(\"Second Item\"));\n+        assertEquals(\"Next Item is 'First Item'\",\n+                     2, stack.search(\"First Item\"));\n+        assertEquals(\"Cannot find 'Missing Item'\",\n+                     -1, stack.search(\"Missing Item\"));\n+\n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ArrayStack.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ArrayStack.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/BagUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.BagUtils;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.bag.PredicatedBag;\n+import org.apache.commons.collections4.bag.PredicatedSortedBag;\n+import org.apache.commons.collections4.bag.SynchronizedBag;\n+import org.apache.commons.collections4.bag.SynchronizedSortedBag;\n+import org.apache.commons.collections4.bag.TransformedBag;\n+import org.apache.commons.collections4.bag.TransformedSortedBag;\n+import org.apache.commons.collections4.bag.TreeBag;\n+import org.apache.commons.collections4.bag.UnmodifiableBag;\n+import org.apache.commons.collections4.bag.UnmodifiableSortedBag;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Tests for BagUtils factory methods.\n+ *\n+ * @version $Id$\n+ */\n+public class BagUtilsTest extends BulkTest {\n+\n+    public BagUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(BagUtilsTest.class);\n+    }\n+\n+    //----------------------------------------------------------------------\n+\n+    protected Class<?> stringClass = this.getName().getClass();\n+    protected Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+    protected Transformer<Object, Object> nopTransformer = TransformerUtils.nopTransformer();\n+\n+    //----------------------------------------------------------------------\n+\n+    public void testSynchronizedBag() {\n+        Bag<Object> bag = BagUtils.synchronizedBag(new HashBag<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedBag.\",\n+            bag instanceof SynchronizedBag);\n+        try {\n+            bag = BagUtils.synchronizedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testUnmodifiableBag() {\n+        Bag<Object> bag = BagUtils.unmodifiableBag(new HashBag<Object>());\n+        assertTrue(\"Returned object should be an UnmodifiableBag.\",\n+            bag instanceof UnmodifiableBag);\n+        try {\n+            bag = BagUtils.unmodifiableBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPredicatedBag() {\n+        Bag<Object> bag = BagUtils.predicatedBag(new HashBag<Object>(), truePredicate);\n+        assertTrue(\"Returned object should be a PredicatedBag.\",\n+            bag instanceof PredicatedBag);\n+        try {\n+            bag = BagUtils.predicatedBag(null,truePredicate);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.predicatedBag(new HashBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+     public void testTransformedBag() {\n+        Bag<Object> bag = BagUtils.transformingBag(new HashBag<Object>(), nopTransformer);\n+        assertTrue(\"Returned object should be an TransformedBag.\",\n+            bag instanceof TransformedBag);\n+        try {\n+            bag = BagUtils.transformingBag(null, nopTransformer);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.transformingBag(new HashBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testSynchronizedSortedBag() {\n+        Bag<Object> bag = BagUtils.synchronizedSortedBag(new TreeBag<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedSortedBag.\",\n+            bag instanceof SynchronizedSortedBag);\n+        try {\n+            bag = BagUtils.synchronizedSortedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testUnmodifiableSortedBag() {\n+        Bag<Object> bag = BagUtils.unmodifiableSortedBag(new TreeBag<Object>());\n+        assertTrue(\"Returned object should be an UnmodifiableSortedBag.\",\n+            bag instanceof UnmodifiableSortedBag);\n+        try {\n+            bag = BagUtils.unmodifiableSortedBag(null);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testPredicatedSortedBag() {\n+        Bag<Object> bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), truePredicate);\n+        assertTrue(\"Returned object should be a PredicatedSortedBag.\",\n+            bag instanceof PredicatedSortedBag);\n+        try {\n+            bag = BagUtils.predicatedSortedBag(null, truePredicate);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.predicatedSortedBag(new TreeBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testTransformedSortedBag() {\n+        Bag<Object> bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), nopTransformer);\n+        assertTrue(\"Returned object should be an TransformedSortedBag\",\n+            bag instanceof TransformedSortedBag);\n+        try {\n+            bag = BagUtils.transformingSortedBag(null, nopTransformer);\n+            fail(\"Expecting IllegalArgumentException for null bag.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            bag = BagUtils.transformingSortedBag(new TreeBag<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/BulkTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * A {@link TestCase} that can define both simple and bulk test methods.\n+ * <p>\n+ * A <I>simple test method</I> is the type of test traditionally \n+ * supplied by by {@link TestCase}.  To define a simple test, create a public \n+ * no-argument method whose name starts with \"test\".  You can specify the\n+ * the name of simple test in the constructor of <code>BulkTest</code>;\n+ * a subsequent call to {@link TestCase#run} will run that simple test.\n+ * <p>\n+ * A <I>bulk test method</I>, on the other hand, returns a new instance\n+ * of <code>BulkTest</code>, which can itself define new simple and bulk\n+ * test methods.  By using the {@link #makeSuite} method, you can \n+ * automatically create a hierarchal suite of tests and child bulk tests.\n+ * <p>\n+ * For instance, consider the following two classes:\n+ *\n+ * <Pre>\n+ *  public class TestSet extends BulkTest {\n+ *\n+ *      private Set set;\n+ *\n+ *      public TestSet(Set set) {\n+ *          this.set = set;\n+ *      }\n+ *\n+ *      public void testContains() {\n+ *          boolean r = set.contains(set.iterator().next()));\n+ *          assertTrue(\"Set should contain first element, r);\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          set.clear();\n+ *          assertTrue(\"Set should be empty after clear\", set.isEmpty());\n+ *      }\n+ *  }\n+ *\n+ *\n+ *  public class TestHashMap extends BulkTest {\n+ *\n+ *      private Map makeFullMap() {\n+ *          HashMap result = new HashMap();\n+ *          result.put(\"1\", \"One\");\n+ *          result.put(\"2\", \"Two\");\n+ *          return result;\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          Map map = makeFullMap();\n+ *          map.clear();\n+ *          assertTrue(\"Map empty after clear\", map.isEmpty());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestKeySet() {\n+ *          return new TestSet(makeFullMap().keySet());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestEntrySet() {\n+ *          return new TestSet(makeFullMap().entrySet());\n+ *      }\n+ *  }\n+ *  </Pre>\n+ *\n+ *  In the above examples, <code>TestSet</code> defines two\n+ *  simple test methods and no bulk test methods; <code>TestHashMap</code>\n+ *  defines one simple test method and two bulk test methods.  When\n+ *  <code>makeSuite(TestHashMap.class).run</code> is executed, \n+ *  <I>five</I> simple test methods will be run, in this order:<P>\n+ *\n+ *  <Ol>\n+ *  <Li>TestHashMap.testClear()\n+ *  <Li>TestHashMap.bulkTestKeySet().testContains();\n+ *  <Li>TestHashMap.bulkTestKeySet().testClear();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testContains();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testClear();\n+ *  </Ol>\n+ *\n+ *  In the graphical junit test runners, the tests would be displayed in\n+ *  the following tree:<P>\n+ *\n+ *  <UL>\n+ *  <LI>TestHashMap</LI>\n+ *      <UL>\n+ *      <LI>testClear\n+ *      <LI>bulkTestKeySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      <LI>bulkTestEntrySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      </UL>\n+ *  </UL>\n+ *\n+ *  A subclass can override a superclass's bulk test by\n+ *  returning <code>null</code> from the bulk test method.  If you only\n+ *  want to override specific simple tests within a bulk test, use the\n+ *  {@link #ignoredTests} method.<P>\n+ *\n+ *  Note that if you want to use the bulk test methods, you <I>must</I>\n+ *  define your <code>suite()</code> method to use {@link #makeSuite}.\n+ *  The ordinary {@link TestSuite} constructor doesn't know how to \n+ *  interpret bulk test methods.\n+ *\n+ *  @version $Id$\n+ */\n+public class BulkTest extends TestCase implements Cloneable {\n+\n+\n+    // Note:  BulkTest is Cloneable to make it easier to construct \n+    // BulkTest instances for simple test methods that are defined in \n+    // anonymous inner classes.  Basically we don't have to worry about\n+    // finding weird constructors.  (And even if we found them, technically\n+    // it'd be illegal for anyone but the outer class to invoke them).  \n+    // Given one BulkTest instance, we can just clone it and reset the \n+    // method name for every simple test it defines.  \n+\n+\n+    /** Path to test data resources */\n+    protected static final String TEST_DATA_PATH = \"src/test/resources/data/test/\";\n+\n+    /**\n+     *  The full name of this bulk test instance.  This is the full name\n+     *  that is compared to {@link #ignoredTests} to see if this\n+     *  test should be ignored.  It's also displayed in the text runner\n+     *  to ease debugging.\n+     */\n+    String verboseName;\n+\n+\n+    /**\n+     *  Constructs a new <code>BulkTest</code> instance that will run the\n+     *  specified simple test.\n+     *\n+     *  @param name  the name of the simple test method to run\n+     */\n+    public BulkTest(final String name) {\n+        super(name);\n+        this.verboseName = getClass().getName();\n+    }\n+\n+\n+    /**\n+     *  Creates a clone of this <code>BulkTest</code>.<P>\n+     *\n+     *  @return  a clone of this <code>BulkTest</code>\n+     */\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(); // should never happen\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns an array of test names to ignore.<P>\n+     *\n+     *  If a test that's defined by this <code>BulkTest</code> or\n+     *  by one of its bulk test methods has a name that's in the returned\n+     *  array, then that simple test will not be executed.<P>\n+     *\n+     *  A test's name is formed by taking the class name of the\n+     *  root <code>BulkTest</code>, eliminating the package name, then\n+     *  appending the names of any bulk test methods that were invoked\n+     *  to get to the simple test, and then appending the simple test\n+     *  method name.  The method names are delimited by periods:\n+     *\n+     *  <pre>\n+     *  TestHashMap.bulkTestEntrySet.testClear\n+     *  </pre>\n+     *\n+     *  is the name of one of the simple tests defined in the sample classes\n+     *  described above.  If the sample <code>TestHashMap</code> class\n+     *  included this method:\n+     *\n+     *  <pre>\n+     *  public String[] ignoredTests() {\n+     *      return new String[] { \"TestHashMap.bulkTestEntrySet.testClear\" };\n+     *  }\n+     *  </pre>\n+     *\n+     *  then the entry set's clear method wouldn't be tested, but the key\n+     *  set's clear method would.\n+     *\n+     *  @return an array of the names of tests to ignore, or null if\n+     *   no tests should be ignored\n+     */\n+    public String[] ignoredTests() {\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Returns the display name of this <code>BulkTest</code>.\n+     *\n+     *  @return the display name of this <code>BulkTest</code>\n+     */\n+    @Override\n+    public String toString() {\n+        return getName() + \"(\" + verboseName + \") \";\n+    }\n+\n+\n+    /**\n+     *  Returns a {@link TestSuite} for testing all of the simple tests\n+     *  <I>and</I> all the bulk tests defined by the given class.<P>\n+     *\n+     *  The class is examined for simple and bulk test methods; any child\n+     *  bulk tests are also examined recursively; and the results are stored\n+     *  in a hierarchal {@link TestSuite}.<P>\n+     *\n+     *  The given class must be a subclass of <code>BulkTest</code> and must\n+     *  not be abstract.<P>\n+     *\n+     *  @param c  the class to examine for simple and bulk tests\n+     *  @return  a {@link TestSuite} containing all the simple and bulk tests\n+     *    defined by that class\n+     */\n+    public static TestSuite makeSuite(final Class<? extends BulkTest> c) {\n+        if (Modifier.isAbstract(c.getModifiers())) {\n+            throw new IllegalArgumentException(\"Class must not be abstract.\");\n+        }\n+        if (!BulkTest.class.isAssignableFrom(c)) {\n+            throw new IllegalArgumentException(\"Class must extend BulkTest.\");\n+        }\n+        return new BulkTestSuiteMaker(c).make();\n+    }\n+\n+}\n+\n+\n+// It was easier to use a separate class to do all the reflection stuff\n+// for making the TestSuite instances.  Having permanent state around makes\n+// it easier to handle the recursion.\n+class BulkTestSuiteMaker {\n+\n+    /** The class that defines simple and bulk tests methods. */\n+    private final Class<? extends BulkTest> startingClass;\n+\n+    /** List of ignored simple test names. */\n+    private List<String> ignored;\n+   \n+    /** The TestSuite we're currently populating.  Can change over time. */\n+    private TestSuite result;\n+\n+    /** \n+     *  The prefix for simple test methods.  Used to check if a test is in \n+     *  the ignored list.\n+     */ \n+    private String prefix;\n+\n+    /** \n+     *  Constructor.\n+     *\n+     *  @param startingClass  the starting class\n+     */     \n+    public BulkTestSuiteMaker(final Class<? extends BulkTest> startingClass) {\n+        this.startingClass = startingClass;\n+    }\n+\n+    /**\n+     *  Makes a hierarchical TestSuite based on the starting class.\n+     *\n+     *  @return  the hierarchical TestSuite for startingClass\n+     */\n+    public TestSuite make() {\n+         this.result = new TestSuite();\n+         this.prefix = getBaseName(startingClass);\n+         result.setName(prefix);\n+\n+         final BulkTest bulk = makeFirstTestCase(startingClass);\n+         ignored = new ArrayList<String>();\n+         final String[] s = bulk.ignoredTests();\n+         if (s != null) {\n+             ignored.addAll(Arrays.asList(s));\n+         }\n+         make(bulk);\n+         return result;\n+    }\n+\n+    /**\n+     *  Appends all the simple tests and bulk tests defined by the given\n+     *  instance's class to the current TestSuite.\n+     *\n+     *  @param bulk  An instance of the class that defines simple and bulk\n+     *    tests for us to append\n+     */\n+    void make(final BulkTest bulk) {\n+        final Class<? extends BulkTest> c = bulk.getClass();\n+        final Method[] all = c.getMethods();\n+        for (final Method element : all) {\n+            if (isTest(element)) {\n+                addTest(bulk, element);\n+            }\n+            if (isBulk(element)) {\n+                addBulk(bulk, element);\n+            }\n+        }\n+    }\n+\n+    /**\n+     *  Adds the simple test defined by the given method to the TestSuite.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *   (I know it's weird.  But the point is, we can clone the instance\n+     *   and not have to worry about constructors.)\n+     *  @param m  The simple test method\n+     */\n+    void addTest(final BulkTest bulk, final Method m) {\n+        final BulkTest bulk2 = (BulkTest)bulk.clone();\n+        bulk2.setName(m.getName());\n+        bulk2.verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(bulk2.verboseName)) {\n+            return;\n+        }\n+        result.addTest(bulk2);\n+    }\n+\n+    /**\n+     *  Adds a whole new suite of tests that are defined by the result of\n+     *  the given bulk test method.  In other words, the given bulk test\n+     *  method is invoked, and the resulting BulkTest instance is examined\n+     *  for yet more simple and bulk tests.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *  @param m  The bulk test method\n+     */\n+    void addBulk(final BulkTest bulk, final Method m) {\n+        final String verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(verboseName)) {\n+            return;\n+        }\n+        \n+        BulkTest bulk2;\n+        try {\n+            bulk2 = (BulkTest)m.invoke(bulk, (Object[]) null);\n+            if (bulk2 == null) {\n+                return;\n+            }\n+        } catch (final InvocationTargetException ex) {\n+            ex.getTargetException().printStackTrace();\n+            throw new Error(); // FIXME;\n+        } catch (final IllegalAccessException ex) {\n+            ex.printStackTrace();\n+            throw new Error(); // FIXME;\n+        }\n+\n+        // Save current state on the stack.\n+        final String oldPrefix = prefix;\n+        final TestSuite oldResult = result;\n+\n+        prefix = prefix + \".\" + m.getName();\n+        result = new TestSuite();\n+        result.setName(m.getName());\n+\n+        make(bulk2);\n+\n+        oldResult.addTest(result);\n+\n+        // Restore the old state\n+        prefix = oldPrefix;\n+        result = oldResult;\n+    }\n+\n+    /**\n+     *  Returns the base name of the given class.\n+     *\n+     *  @param c  the class\n+     *  @return the name of that class, minus any package names\n+     */\n+    private static String getBaseName(final Class<?> c) {\n+        String name = c.getName();\n+        final int p = name.lastIndexOf('.');\n+        if (p > 0) {\n+            name = name.substring(p + 1);\n+        }\n+        return name;\n+    }\n+\n+\n+    // These three methods are used to create a valid BulkTest instance\n+    // from a class.\n+\n+    private static <T> Constructor<T> getTestCaseConstructor(final Class<T> c) {\n+        try {\n+            return c.getConstructor(new Class[] { String.class });\n+        } catch (final NoSuchMethodException e) {\n+            throw new IllegalArgumentException(c + \" must provide \" +\n+             \"a (String) constructor\");\n+        }\n+    }\n+\n+    private static <T extends BulkTest> BulkTest makeTestCase(final Class<T> c, final Method m) {\n+        final Constructor<T> con = getTestCaseConstructor(c);\n+        try {\n+            return con.newInstance(new Object[] { m.getName() });\n+        } catch (final InvocationTargetException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(); // FIXME;\n+        } catch (final IllegalAccessException e) {\n+            throw new Error(); // should never occur\n+        } catch (final InstantiationException e) {\n+            throw new RuntimeException(); // FIXME;\n+        }\n+    }\n+\n+    private static <T extends BulkTest> BulkTest makeFirstTestCase(final Class<T> c) {\n+        final Method[] all = c.getMethods();\n+        for (final Method element : all) {\n+            if (isTest(element)) {\n+                return makeTestCase(c, element);\n+            }\n+        }\n+        throw new IllegalArgumentException(c.getName() + \" must provide \" \n+          + \" at least one test method.\");\n+    }\n+\n+    /**\n+     *  Returns true if the given method is a simple test method.\n+     */\n+    private static boolean isTest(final Method m) {\n+        if (!m.getName().startsWith(\"test\")) {\n+            return false;\n+        }\n+        if (m.getReturnType() != Void.TYPE) {\n+            return false;\n+        }\n+        if (m.getParameterTypes().length != 0) {\n+            return false;\n+        }\n+        final int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) {\n+            return false;\n+        }\n+        if (Modifier.isAbstract(mods)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the given method is a bulk test method.\n+     */\n+    private static boolean isBulk(final Method m) {\n+        if (!m.getName().startsWith(\"bulkTest\")) {\n+            return false;\n+        }\n+        if (m.getReturnType() != BulkTest.class) {\n+            return false;\n+        }\n+        if (m.getParameterTypes().length != 0) {\n+            return false;\n+        }\n+        final int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) {\n+            return false;\n+        }\n+        if (Modifier.isAbstract(mods)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/ClosureUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.ClosureUtils;\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.PredicateUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.functors.ExceptionClosure;\n+import org.apache.commons.collections4.functors.FalsePredicate;\n+import org.apache.commons.collections4.functors.NOPClosure;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Tests the ClosureUtils class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ClosureUtilsTest extends TestCase {\n+\n+    private static final Object cString = \"Hello\";\n+\n+    /**\n+     * Construct\n+     */\n+    public ClosureUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    static class MockClosure<T> implements Closure<T> {\n+        int count = 0;\n+\n+        public void execute(final T object) {\n+            count++;\n+        }\n+\n+        public void reset() {\n+            count = 0;\n+        }\n+    }\n+\n+    static class MockTransformer<T> implements Transformer<T, T> {\n+        int count = 0;\n+\n+        public T transform(final T object) {\n+            count++;\n+            return object;\n+        }\n+    }\n+\n+    // exceptionClosure\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionClosure() {\n+        assertNotNull(ClosureUtils.exceptionClosure());\n+        assertSame(ClosureUtils.exceptionClosure(), ClosureUtils.exceptionClosure());\n+        try {\n+            ClosureUtils.exceptionClosure().execute(null);\n+        } catch (final FunctorException ex) {\n+            try {\n+                ClosureUtils.exceptionClosure().execute(cString);\n+            } catch (final FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nopClosure\n+    //------------------------------------------------------------------\n+\n+    public void testNopClosure() {\n+        final StringBuilder buf = new StringBuilder(\"Hello\");\n+        ClosureUtils.nopClosure().execute(null);\n+        assertEquals(\"Hello\", buf.toString());\n+        ClosureUtils.nopClosure().execute(\"Hello\");\n+        assertEquals(\"Hello\", buf.toString());\n+    }\n+\n+    // invokeClosure\n+    //------------------------------------------------------------------\n+\n+    public void testInvokeClosure() {\n+        StringBuffer buf = new StringBuffer(\"Hello\"); // Only StringBuffer has setLength() method\n+        ClosureUtils.invokerClosure(\"reverse\").execute(buf);\n+        assertEquals(\"olleH\", buf.toString());\n+        buf = new StringBuffer(\"Hello\");\n+        ClosureUtils.invokerClosure(\"setLength\", new Class[] {Integer.TYPE}, new Object[] {new Integer(2)}).execute(buf);\n+        assertEquals(\"He\", buf.toString());\n+    }\n+\n+    // forClosure\n+    //------------------------------------------------------------------\n+\n+    public void testForClosure() {\n+        final MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.forClosure(5, cmd).execute(null);\n+        assertEquals(5, cmd.count);\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(0, new MockClosure<Object>()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(-1, new MockClosure<Object>()));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(1, null));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.forClosure(3, null));\n+        assertSame(cmd, ClosureUtils.forClosure(1, cmd));\n+    }\n+\n+    // whileClosure\n+    //------------------------------------------------------------------\n+\n+    public void testWhileClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), cmd).execute(null);\n+        assertEquals(0, cmd.count);\n+\n+        cmd = new MockClosure<Object>();\n+        ClosureUtils.whileClosure(PredicateUtils.uniquePredicate(), cmd).execute(null);\n+        assertEquals(1, cmd.count);\n+\n+        try {\n+            ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.whileClosure(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // doWhileClosure\n+    //------------------------------------------------------------------\n+\n+    public void testDoWhileClosure() {\n+        MockClosure<Object> cmd = new MockClosure<Object>();\n+        ClosureUtils.doWhileClosure(cmd, FalsePredicate.falsePredicate()).execute(null);\n+        assertEquals(1, cmd.count);\n+\n+        cmd = new MockClosure<Object>();\n+        ClosureUtils.doWhileClosure(cmd, PredicateUtils.uniquePredicate()).execute(null);\n+        assertEquals(2, cmd.count);\n+\n+        try {\n+            ClosureUtils.doWhileClosure(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // chainedClosure\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testChainedClosure() {\n+        MockClosure<Object> a = new MockClosure<Object>();\n+        MockClosure<Object> b = new MockClosure<Object>();\n+        ClosureUtils.chainedClosure(a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.<Object>chainedClosure(new Closure[] {a, b, a}).execute(null);\n+        assertEquals(2, a.count);\n+        assertEquals(1, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        Collection<Closure<Object>> coll = new ArrayList<Closure<Object>>();\n+        coll.add(b);\n+        coll.add(a);\n+        coll.add(b);\n+        ClosureUtils.<Object>chainedClosure(coll).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(2, b.count);\n+\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(new Closure[0]));\n+        assertSame(NOPClosure.INSTANCE, ClosureUtils.<Object>chainedClosure(Collections.<Closure<Object>>emptyList()));\n+\n+        try {\n+            ClosureUtils.chainedClosure(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure((Closure[]) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<Object>chainedClosure(new Closure[] {null, null});\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList<Closure<Object>>();\n+            coll.add(null);\n+            coll.add(null);\n+            ClosureUtils.chainedClosure(coll);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // ifClosure\n+    //------------------------------------------------------------------\n+\n+    public void testIfClosure() {\n+        MockClosure<Object> a = new MockClosure<Object>();\n+        MockClosure<Object> b = null;\n+        ClosureUtils.ifClosure(TruePredicate.truePredicate(), a).execute(null);\n+        assertEquals(1, a.count);\n+\n+        a = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a).execute(null);\n+        assertEquals(0, a.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(TruePredicate.<Object>truePredicate(), a, b).execute(null);\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+\n+        a = new MockClosure<Object>();\n+        b = new MockClosure<Object>();\n+        ClosureUtils.ifClosure(FalsePredicate.<Object>falsePredicate(), a, b).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+    }\n+\n+    // switchClosure\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSwitchClosure() {\n+        final MockClosure<String> a = new MockClosure<String>();\n+        final MockClosure<String> b = new MockClosure<String>();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }).execute(\"HELLO\");\n+        assertEquals(1, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        final MockClosure<String> c = new MockClosure<String>();\n+        ClosureUtils.<String>switchClosure(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Closure[] { a, b }, c).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        a.reset();\n+        b.reset();\n+        final Map<Predicate<String>, Closure<String>> map = new HashMap<Predicate<String>, Closure<String>>();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        ClosureUtils.<String>switchClosure(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        ClosureUtils.switchClosure(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        c.reset();\n+        map.clear();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        map.put(null, c);\n+        ClosureUtils.switchClosure(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new Predicate[0], new Closure[0]));\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.<String>switchClosure(new HashMap<Predicate<String>, Closure<String>>()));\n+        map.clear();\n+        map.put(null, null);\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchClosure(map));\n+\n+        try {\n+            ClosureUtils.switchClosure(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            ClosureUtils.<String>switchClosure(\n+                    new Predicate[] { TruePredicate.<String>truePredicate() },\n+                    new Closure[] { a, b });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // switchMapClosure\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapClosure() {\n+        final MockClosure<String> a = new MockClosure<String>();\n+        final MockClosure<String> b = new MockClosure<String>();\n+        final Map<String, Closure<String>> map = new HashMap<String, Closure<String>>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ClosureUtils.switchMapClosure(map).execute(null);\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        ClosureUtils.switchMapClosure(map).execute(\"THERE\");\n+        assertEquals(0, a.count);\n+        assertEquals(1, b.count);\n+\n+        a.reset();\n+        b.reset();\n+        map.clear();\n+        final MockClosure<String> c = new MockClosure<String>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        map.put(null, c);\n+        ClosureUtils.switchMapClosure(map).execute(\"WELL\");\n+        assertEquals(0, a.count);\n+        assertEquals(0, b.count);\n+        assertEquals(1, c.count);\n+\n+        assertEquals(NOPClosure.INSTANCE, ClosureUtils.switchMapClosure(new HashMap<String, Closure<String>>()));\n+\n+        try {\n+            ClosureUtils.switchMapClosure(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // asClosure\n+    //------------------------------------------------------------------\n+\n+    public void testTransformerClosure() {\n+        final MockTransformer<Object> mock = new MockTransformer<Object>();\n+        final Closure<Object> closure = ClosureUtils.asClosure(mock);\n+        closure.execute(null);\n+        assertEquals(1, mock.count);\n+        closure.execute(null);\n+        assertEquals(2, mock.count);\n+\n+        assertEquals(ClosureUtils.nopClosure(), ClosureUtils.asClosure(null));\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Closure singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionClosure.INSTANCE,\n+                NOPClosure.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.fail;\n+\n+import java.util.*;\n+\n+import org.apache.commons.collections4.queue.CircularFifoQueue;\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.ClosureUtils;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.PredicateUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+import org.apache.commons.collections4.collection.SynchronizedCollection;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.functors.DefaultEquator;\n+import org.apache.commons.collections4.functors.Equator;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for CollectionUtils.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class CollectionUtilsTest extends MockTestCase {\n+\n+    /**\n+     * Collection of {@link Integer}s\n+     */\n+    private List<Integer> collectionA = null;\n+\n+    /**\n+     * Collection of {@link Long}s\n+     */\n+    private List<Long> collectionB = null;\n+\n+    /**\n+     * Collection of {@link Integer}s that are equivalent to the Longs in\n+     * collectionB.\n+     */\n+    private Collection<Integer> collectionC = null;\n+\n+    /**\n+     * Collection of {@link Integer}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionA2 = null;\n+\n+    /**\n+     * Collection of {@link Long}s, bound as {@link Number}s\n+     */\n+    private Collection<Number> collectionB2 = null;\n+\n+    /**\n+     * Collection of {@link Integer}s (cast as {@link Number}s) that are\n+     * equivalent to the Longs in collectionB.\n+     */\n+    private Collection<Number> collectionC2 = null;\n+\n+    private Iterable<Integer> iterableA = null;\n+\n+    private Iterable<Long> iterableB = null;\n+\n+    private Iterable<Integer> iterableC = null;\n+\n+    private Iterable<Number> iterableA2 = null;\n+\n+    private Iterable<Number> iterableB2 = null;\n+\n+    @Before\n+    public void setUp() {\n+        collectionA = new ArrayList<Integer>();\n+        collectionA.add(1);\n+        collectionA.add(2);\n+        collectionA.add(2);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(3);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionA.add(4);\n+        collectionB = new LinkedList<Long>();\n+        collectionB.add(5L);\n+        collectionB.add(4L);\n+        collectionB.add(4L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(3L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+        collectionB.add(2L);\n+\n+        collectionC = new ArrayList<Integer>();\n+        for (final Long l : collectionB) {\n+            collectionC.add(l.intValue());\n+        }\n+\n+        iterableA = collectionA;\n+        iterableB = collectionB;\n+        iterableC = collectionC;\n+        collectionA2 = new ArrayList<Number>(collectionA);\n+        collectionB2 = new LinkedList<Number>(collectionB);\n+        collectionC2 = new LinkedList<Number>(collectionC);\n+        iterableA2 = collectionA2;\n+        iterableB2 = collectionB2;\n+    }\n+\n+    @Test\n+    public void getCardinalityMap() {\n+        final Map<Number, Integer> freqA = CollectionUtils.<Number>getCardinalityMap(iterableA);\n+        assertEquals(1, (int) freqA.get(1));\n+        assertEquals(2, (int) freqA.get(2));\n+        assertEquals(3, (int) freqA.get(3));\n+        assertEquals(4, (int) freqA.get(4));\n+        assertNull(freqA.get(5));\n+\n+        final Map<Long, Integer> freqB = CollectionUtils.getCardinalityMap(iterableB);\n+        assertNull(freqB.get(1L));\n+        assertEquals(4, (int) freqB.get(2L));\n+        assertEquals(3, (int) freqB.get(3L));\n+        assertEquals(2, (int) freqB.get(4L));\n+        assertEquals(1, (int) freqB.get(5L));\n+    }\n+\n+    @Test\n+    public void cardinality() {\n+        assertEquals(1, CollectionUtils.cardinality(1, iterableA));\n+        assertEquals(2, CollectionUtils.cardinality(2, iterableA));\n+        assertEquals(3, CollectionUtils.cardinality(3, iterableA));\n+        assertEquals(4, CollectionUtils.cardinality(4, iterableA));\n+        assertEquals(0, CollectionUtils.cardinality(5, iterableA));\n+\n+        assertEquals(0, CollectionUtils.cardinality(1L, iterableB));\n+        assertEquals(4, CollectionUtils.cardinality(2L, iterableB));\n+        assertEquals(3, CollectionUtils.cardinality(3L, iterableB));\n+        assertEquals(2, CollectionUtils.cardinality(4L, iterableB));\n+        assertEquals(1, CollectionUtils.cardinality(5L, iterableB));\n+\n+        // Ensure that generic bounds accept valid parameters, but return\n+        // expected results\n+        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n+        assertEquals(0, CollectionUtils.cardinality(2L, iterableA2));\n+        assertEquals(0, CollectionUtils.cardinality(2, iterableB2));\n+\n+        final Set<String> set = new HashSet<String>();\n+        set.add(\"A\");\n+        set.add(\"C\");\n+        set.add(\"E\");\n+        set.add(\"E\");\n+        assertEquals(1, CollectionUtils.cardinality(\"A\", set));\n+        assertEquals(0, CollectionUtils.cardinality(\"B\", set));\n+        assertEquals(1, CollectionUtils.cardinality(\"C\", set));\n+        assertEquals(0, CollectionUtils.cardinality(\"D\", set));\n+        assertEquals(1, CollectionUtils.cardinality(\"E\", set));\n+\n+        final Bag<String> bag = new HashBag<String>();\n+        bag.add(\"A\", 3);\n+        bag.add(\"C\");\n+        bag.add(\"E\");\n+        bag.add(\"E\");\n+        assertEquals(3, CollectionUtils.cardinality(\"A\", bag));\n+        assertEquals(0, CollectionUtils.cardinality(\"B\", bag));\n+        assertEquals(1, CollectionUtils.cardinality(\"C\", bag));\n+        assertEquals(0, CollectionUtils.cardinality(\"D\", bag));\n+        assertEquals(2, CollectionUtils.cardinality(\"E\", bag));\n+    }\n+\n+    @Test\n+    public void cardinalityOfNull() {\n+        final List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertNull(freq.get(null));\n+        }\n+        list.add(\"A\");\n+        assertEquals(0, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertNull(freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(1), freq.get(null));\n+        }\n+        list.add(\"B\");\n+        assertEquals(1, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(1), freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(2), freq.get(null));\n+        }\n+        list.add(\"B\");\n+        assertEquals(2, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(2), freq.get(null));\n+        }\n+        list.add(null);\n+        assertEquals(3, CollectionUtils.cardinality(null, list));\n+        {\n+            final Map<String, Integer> freq = CollectionUtils.getCardinalityMap(list);\n+            assertEquals(Integer.valueOf(3), freq.get(null));\n+        }\n+    }\n+\n+    @Test\n+    public void containsAll() {\n+        final Collection<String> empty = new ArrayList<String>(0);\n+        final Collection<String> one = new ArrayList<String>(1);\n+        one.add(\"1\");\n+        final Collection<String> two = new ArrayList<String>(1);\n+        two.add(\"2\");\n+        final Collection<String> three = new ArrayList<String>(1);\n+        three.add(\"3\");\n+        final Collection<String> odds = new ArrayList<String>(2);\n+        odds.add(\"1\");\n+        odds.add(\"3\");\n+        final Collection<String> multiples = new ArrayList<String>(3);\n+        multiples.add(\"1\");\n+        multiples.add(\"3\");\n+        multiples.add(\"1\");\n+\n+        assertTrue(\"containsAll({1},{1,3}) should return false.\", !CollectionUtils.containsAll(one, odds));\n+        assertTrue(\"containsAll({1,3},{1}) should return true.\", CollectionUtils.containsAll(odds, one));\n+        assertTrue(\"containsAll({3},{1,3}) should return false.\", !CollectionUtils.containsAll(three, odds));\n+        assertTrue(\"containsAll({1,3},{3}) should return true.\", CollectionUtils.containsAll(odds, three));\n+        assertTrue(\"containsAll({2},{2}) should return true.\", CollectionUtils.containsAll(two, two));\n+        assertTrue(\"containsAll({1,3},{1,3}) should return true.\", CollectionUtils.containsAll(odds, odds));\n+\n+        assertTrue(\"containsAll({2},{1,3}) should return false.\", !CollectionUtils.containsAll(two, odds));\n+        assertTrue(\"containsAll({1,3},{2}) should return false.\", !CollectionUtils.containsAll(odds, two));\n+        assertTrue(\"containsAll({1},{3}) should return false.\", !CollectionUtils.containsAll(one, three));\n+        assertTrue(\"containsAll({3},{1}) should return false.\", !CollectionUtils.containsAll(three, one));\n+        assertTrue(\"containsAll({1,3},{}) should return true.\", CollectionUtils.containsAll(odds, empty));\n+        assertTrue(\"containsAll({},{1,3}) should return false.\", !CollectionUtils.containsAll(empty, odds));\n+        assertTrue(\"containsAll({},{}) should return true.\", CollectionUtils.containsAll(empty, empty));\n+\n+        assertTrue(\"containsAll({1,3},{1,3,1}) should return true.\", CollectionUtils.containsAll(odds, multiples));\n+        assertTrue(\"containsAll({1,3,1},{1,3,1}) should return true.\", CollectionUtils.containsAll(odds, odds));\n+    }\n+\n+    @Test\n+    public void containsAny() {\n+        final Collection<String> empty = new ArrayList<String>(0);\n+        final Collection<String> one = new ArrayList<String>(1);\n+        one.add(\"1\");\n+        final Collection<String> two = new ArrayList<String>(1);\n+        two.add(\"2\");\n+        final Collection<String> three = new ArrayList<String>(1);\n+        three.add(\"3\");\n+        final Collection<String> odds = new ArrayList<String>(2);\n+        odds.add(\"1\");\n+        odds.add(\"3\");\n+\n+        assertTrue(\"containsAny({1},{1,3}) should return true.\", CollectionUtils.containsAny(one, odds));\n+        assertTrue(\"containsAny({1,3},{1}) should return true.\", CollectionUtils.containsAny(odds, one));\n+        assertTrue(\"containsAny({3},{1,3}) should return true.\", CollectionUtils.containsAny(three, odds));\n+        assertTrue(\"containsAny({1,3},{3}) should return true.\", CollectionUtils.containsAny(odds, three));\n+        assertTrue(\"containsAny({2},{2}) should return true.\", CollectionUtils.containsAny(two, two));\n+        assertTrue(\"containsAny({1,3},{1,3}) should return true.\", CollectionUtils.containsAny(odds, odds));\n+\n+        assertTrue(\"containsAny({2},{1,3}) should return false.\", !CollectionUtils.containsAny(two, odds));\n+        assertTrue(\"containsAny({1,3},{2}) should return false.\", !CollectionUtils.containsAny(odds, two));\n+        assertTrue(\"containsAny({1},{3}) should return false.\", !CollectionUtils.containsAny(one, three));\n+        assertTrue(\"containsAny({3},{1}) should return false.\", !CollectionUtils.containsAny(three, one));\n+        assertTrue(\"containsAny({1,3},{}) should return false.\", !CollectionUtils.containsAny(odds, empty));\n+        assertTrue(\"containsAny({},{1,3}) should return false.\", !CollectionUtils.containsAny(empty, odds));\n+        assertTrue(\"containsAny({},{}) should return false.\", !CollectionUtils.containsAny(empty, empty));\n+    }\n+\n+    @Test\n+    public void union() {\n+        final Collection<Integer> col = CollectionUtils.union(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertEquals(Integer.valueOf(4), freq.get(2));\n+        assertEquals(Integer.valueOf(3), freq.get(3));\n+        assertEquals(Integer.valueOf(4), freq.get(4));\n+        assertEquals(Integer.valueOf(1), freq.get(5));\n+\n+        final Collection<Number> col2 = CollectionUtils.union(collectionC2, iterableA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(4), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(4), freq2.get(4));\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+    }\n+\n+    @Test\n+    public void intersection() {\n+        final Collection<Integer> col = CollectionUtils.intersection(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertNull(freq.get(1));\n+        assertEquals(Integer.valueOf(2), freq.get(2));\n+        assertEquals(Integer.valueOf(3), freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        final Collection<Number> col2 = CollectionUtils.intersection(collectionC2, collectionA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertNull(freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void disjunction() {\n+        final Collection<Integer> col = CollectionUtils.disjunction(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertEquals(Integer.valueOf(2), freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertEquals(Integer.valueOf(1), freq.get(5));\n+\n+        final Collection<Number> col2 = CollectionUtils.disjunction(collectionC2, collectionA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertNull(freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+    }\n+\n+    @Test\n+    public void testDisjunctionAsUnionMinusIntersection() {\n+        final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        final Collection<Number> un = CollectionUtils.<Number>union(collectionA, collectionC);\n+        final Collection<Number> inter = CollectionUtils.<Number>intersection(collectionA, collectionC);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.subtract(un, inter)));\n+    }\n+\n+    @Test\n+    public void testDisjunctionAsSymmetricDifference() {\n+        final Collection<Number> dis = CollectionUtils.<Number>disjunction(collectionA, collectionC);\n+        final Collection<Number> amb = CollectionUtils.<Number>subtract(collectionA, collectionC);\n+        final Collection<Number> bma = CollectionUtils.<Number>subtract(collectionC, collectionA);\n+        assertTrue(CollectionUtils.isEqualCollection(dis, CollectionUtils.union(amb, bma)));\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        final Collection<Integer> col = CollectionUtils.subtract(iterableA, iterableC);\n+        final Map<Integer, Integer> freq = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq.get(1));\n+        assertNull(freq.get(2));\n+        assertNull(freq.get(3));\n+        assertEquals(Integer.valueOf(2), freq.get(4));\n+        assertNull(freq.get(5));\n+\n+        final Collection<Number> col2 = CollectionUtils.subtract(collectionC2, collectionA);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col2);\n+        assertEquals(Integer.valueOf(1), freq2.get(5));\n+        assertNull(freq2.get(4));\n+        assertNull(freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertNull(freq2.get(1));\n+    }\n+\n+    @Test\n+    public void testSubtractWithPredicate() {\n+        // greater than 3\n+        final Predicate<Number> predicate = new Predicate<Number>() {\n+            public boolean evaluate(final Number n) {\n+                return n.longValue() > 3L;\n+            }\n+        };\n+        \n+        final Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n+        final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n+        assertEquals(Integer.valueOf(1), freq2.get(1));\n+        assertEquals(Integer.valueOf(2), freq2.get(2));\n+        assertEquals(Integer.valueOf(3), freq2.get(3));\n+        assertEquals(Integer.valueOf(2), freq2.get(4));\n+        assertNull(freq2.get(5));\n+    }\n+\n+    @Test\n+    public void testIsSubCollectionOfSelf() {\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n+    public void testIsSubCollection() {\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsSubCollection2() {\n+        final Collection<Integer> c = new ArrayList<Integer>();\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(1);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(2);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(3);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(!CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(4);\n+        assertTrue(CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+        c.add(5);\n+        assertTrue(!CollectionUtils.isSubCollection(c, collectionA));\n+        assertTrue(CollectionUtils.isSubCollection(collectionA, c));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionToSelf() {\n+        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA));\n+        assertTrue(CollectionUtils.isEqualCollection(collectionB, collectionB));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollection() {\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionA, collectionC));\n+        assertTrue(!CollectionUtils.isEqualCollection(collectionC, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionReturnsFalse() {\n+        final List<Integer> b = new ArrayList<Integer>(collectionA);\n+        // remove an extra '2', and add a 5.  This will increase the size of the cardinality\n+        b.remove(1);\n+        b.add(5);\n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, b));\n+        assertFalse(CollectionUtils.isEqualCollection(b, collectionA));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollection2() {\n+        final Collection<String> a = new ArrayList<String>();\n+        final Collection<String> b = new ArrayList<String>();\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"1\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"2\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"2\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+        a.add(\"1\");\n+        assertTrue(!CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(!CollectionUtils.isEqualCollection(b, a));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isEqualCollection(a, b));\n+        assertTrue(CollectionUtils.isEqualCollection(b, a));\n+    }\n+\n+    @Test\n+    public void testIsEqualCollectionEquator() {\n+        final Collection<Integer> collB = CollectionUtils.collect(collectionB, TRANSFORM_TO_INTEGER);\n+\n+        // odd / even equator\n+        final Equator<Integer> e = new Equator<Integer>() {\n+            public boolean equate(final Integer o1, final Integer o2) {\n+                if (o1.intValue() % 2 == 0 ^ o2.intValue() % 2 == 0) {\n+                    return false;\n+                } else {\n+                    return true;\n+                }\n+            }\n+\n+            public int hash(final Integer o) {\n+                return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();\n+            }\n+        };\n+        \n+        assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA, e));\n+        assertTrue(CollectionUtils.isEqualCollection(collectionA, collB, e));\n+        assertTrue(CollectionUtils.isEqualCollection(collB, collectionA, e));\n+        \n+        final Equator<Number> defaultEquator = new DefaultEquator<Number>();\n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionB, defaultEquator));\n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));        \n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testIsEqualCollectionNullEquator() {\n+        CollectionUtils.isEqualCollection(collectionA, collectionA, null);\n+    }\n+\n+    @Test\n+    public void testIsProperSubCollection() {\n+        final Collection<String> a = new ArrayList<String>();\n+        final Collection<String> b = new ArrayList<String>();\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n+        b.add(\"1\");\n+        assertTrue(CollectionUtils.isProperSubCollection(a, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, b));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, a));\n+        a.add(\"1\");\n+        a.add(\"2\");\n+        b.add(\"2\");\n+        assertTrue(!CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, b));\n+        a.add(\"1\");\n+        assertTrue(CollectionUtils.isProperSubCollection(b, a));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.intersection(collectionA, collectionC), collectionA));\n+        assertTrue(CollectionUtils.isProperSubCollection(CollectionUtils.subtract(a, b), a));\n+        assertTrue(!CollectionUtils.isProperSubCollection(a, CollectionUtils.subtract(a, b)));\n+    }\n+\n+    @Test\n+    public void find() {\n+        Predicate<Number> testPredicate = equalPredicate((Number) 4);\n+        Integer test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test.equals(4));\n+        testPredicate = equalPredicate((Number) 45);\n+        test = CollectionUtils.find(collectionA, testPredicate);\n+        assertTrue(test == null);\n+        assertNull(CollectionUtils.find(null,testPredicate));\n+        assertNull(CollectionUtils.find(collectionA, null));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void forAllDoCollection() {\n+        final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        col.add(collectionA);\n+        col.add(collectionB);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col, testClosure);\n+        assertSame(testClosure, resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        // fix for various java 1.6 versions: keep the cast\n+        resultClosure = CollectionUtils.forAllDo(col, (Closure<List<? extends Number>>) null);\n+        assertNull(resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo((Collection) null, testClosure);\n+        col.add(null);\n+        // null should be OK\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    @Test\n+    public void forAllDoIterator() {\n+        final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n+        col.add(collectionA);\n+        col.add(collectionB);\n+        Closure<List<? extends Number>> resultClosure = CollectionUtils.forAllDo(col.iterator(), testClosure);\n+        assertSame(testClosure, resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        // fix for various java 1.6 versions: keep the cast\n+        resultClosure = CollectionUtils.forAllDo(col.iterator(), (Closure<List<? extends Number>>) null);\n+        assertNull(resultClosure);\n+        assertTrue(collectionA.isEmpty() && collectionB.isEmpty());\n+        resultClosure = CollectionUtils.forAllDo((Iterator) null, testClosure);\n+        col.add(null);\n+        // null should be OK\n+        CollectionUtils.forAllDo(col.iterator(), testClosure);\n+    }\n+    \n+    @Test(expected = FunctorException.class)\n+    public void forAllDoFailure() {\n+        final Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<String> col = new ArrayList<String>();\n+        col.add(\"x\");\n+        CollectionUtils.forAllDo(col, testClosure);\n+    }\n+\n+    @Test\n+    public void getFromMap() {\n+        // Unordered map, entries exist\n+        final Map<String, String> expected = new HashMap<String, String>();\n+        expected.put(\"zeroKey\", \"zero\");\n+        expected.put(\"oneKey\", \"one\");\n+\n+        final Map<String, String> found = new HashMap<String, String>();\n+        Map.Entry<String, String> entry = CollectionUtils.get(expected, 0);\n+        found.put(entry.getKey(), entry.getValue());\n+        entry = CollectionUtils.get(expected, 1);\n+        found.put(entry.getKey(), entry.getValue());\n+        assertEquals(expected, found);\n+\n+        // Map index out of range\n+        try {\n+            CollectionUtils.get(expected, 2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        try {\n+            CollectionUtils.get(expected, -2);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        // Sorted map, entries exist, should respect order\n+        final SortedMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"zeroKey\", \"zero\");\n+        map.put(\"oneKey\", \"one\");\n+        Map.Entry<String, String> test = CollectionUtils.get(map, 1);\n+        assertEquals(\"zeroKey\", test.getKey());\n+        assertEquals(\"zero\", test.getValue());\n+        test = CollectionUtils.get(map, 0);\n+        assertEquals(\"oneKey\", test.getKey());\n+        assertEquals(\"one\", test.getValue());\n+    }\n+\n+    /**\n+     * Tests that {@link List}s are handled correctly - e.g. using\n+     * {@link List#get(int)}.\n+     */\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getFromList() throws Exception {\n+        // List, entry exists\n+        final List<String> list = createMock(List.class);\n+        expect(list.get(0)).andReturn(\"zero\");\n+        expect(list.get(1)).andReturn(\"one\");\n+        replay();\n+        final String string = CollectionUtils.get(list, 0);\n+        assertEquals(\"zero\", string);\n+        assertEquals(\"one\", CollectionUtils.get(list, 1));\n+        // list, non-existent entry -- IndexOutOfBoundsException\n+        CollectionUtils.get(new ArrayList<Object>(), 2);\n+    }\n+\n+    @Test\n+    public void getFromIterator() throws Exception {\n+        // Iterator, entry exists\n+        Iterator<Integer> iterator = iterableA.iterator();\n+        assertEquals(1, (int) CollectionUtils.get(iterator, 0));\n+        iterator = iterableA.iterator();\n+        assertEquals(2, (int) CollectionUtils.get(iterator, 1));\n+\n+        // Iterator, non-existent entry\n+        try {\n+            CollectionUtils.get(iterator, 10);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    @Test\n+    public void getFromEnumeration() throws Exception {\n+        // Enumeration, entry exists\n+        final Vector<String> vector = new Vector<String>();\n+        vector.addElement(\"zero\");\n+        vector.addElement(\"one\");\n+        Enumeration<String> en = vector.elements();\n+        assertEquals(\"zero\", CollectionUtils.get(en, 0));\n+        en = vector.elements();\n+        assertEquals(\"one\", CollectionUtils.get(en, 1));\n+\n+        // Enumerator, non-existent entry\n+        try {\n+            CollectionUtils.get(en, 3);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+        assertTrue(!en.hasMoreElements());\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromIterable() throws Exception {\n+        // Collection, entry exists\n+        final Bag<String> bag = new HashBag<String>();\n+        bag.add(\"element\", 1);\n+        assertEquals(\"element\", CollectionUtils.get(bag, 0));\n+\n+        // Collection, non-existent entry\n+        CollectionUtils.get(bag, 1);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromObjectArray() throws Exception {\n+        // Object array, entry exists\n+        final Object[] objArray = new Object[2];\n+        objArray[0] = \"zero\";\n+        objArray[1] = \"one\";\n+        assertEquals(\"zero\", CollectionUtils.get(objArray, 0));\n+        assertEquals(\"one\", CollectionUtils.get(objArray, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(objArray, 2);\n+    }\n+\n+    @Test(expected = IndexOutOfBoundsException.class)\n+    public void getFromPrimativeArray() throws Exception {\n+        // Primitive array, entry exists\n+        final int[] array = new int[2];\n+        array[0] = 10;\n+        array[1] = 20;\n+        assertEquals(10, CollectionUtils.get(array, 0));\n+        assertEquals(20, CollectionUtils.get(array, 1));\n+\n+        // Object array, non-existent entry --\n+        // ArrayIndexOutOfBoundsException\n+        CollectionUtils.get(array, 2);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void getFromObject() throws Exception {\n+        // Invalid object\n+        final Object obj = new Object();\n+        CollectionUtils.get(obj, 0);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testSize_List() {\n+        List<String> list = null;\n+        assertEquals(0, CollectionUtils.size(list));\n+        list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.size(list));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list));\n+    }\n+\n+    @Test\n+    public void testSize_Map() {\n+        final Map<String, String> map = new HashMap<String, String>();\n+        assertEquals(0, CollectionUtils.size(map));\n+        map.put(\"1\", \"a\");\n+        assertEquals(1, CollectionUtils.size(map));\n+        map.put(\"2\", \"b\");\n+        assertEquals(2, CollectionUtils.size(map));\n+    }\n+\n+    @Test\n+    public void testSize_Array() {\n+        final Object[] objectArray = new Object[0];\n+        assertEquals(0, CollectionUtils.size(objectArray));\n+\n+        final String[] stringArray = new String[3];\n+        assertEquals(3, CollectionUtils.size(stringArray));\n+        stringArray[0] = \"a\";\n+        stringArray[1] = \"b\";\n+        stringArray[2] = \"c\";\n+        assertEquals(3, CollectionUtils.size(stringArray));\n+    }\n+\n+    @Test\n+    public void testSize_PrimitiveArray() {\n+        final int[] intArray = new int[0];\n+        assertEquals(0, CollectionUtils.size(intArray));\n+\n+        final double[] doubleArray = new double[3];\n+        assertEquals(3, CollectionUtils.size(doubleArray));\n+        doubleArray[0] = 0.0d;\n+        doubleArray[1] = 1.0d;\n+        doubleArray[2] = 2.5d;\n+        assertEquals(3, CollectionUtils.size(doubleArray));\n+    }\n+\n+    @Test\n+    public void testSize_Enumeration() {\n+        final Vector<String> list = new Vector<String>();\n+        assertEquals(0, CollectionUtils.size(list.elements()));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list.elements()));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list.elements()));\n+    }\n+\n+    @Test\n+    public void testSize_Iterator() {\n+        final List<String> list = new ArrayList<String>();\n+        assertEquals(0, CollectionUtils.size(list.iterator()));\n+        list.add(\"a\");\n+        assertEquals(1, CollectionUtils.size(list.iterator()));\n+        list.add(\"b\");\n+        assertEquals(2, CollectionUtils.size(list.iterator()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testSize_Other() {\n+        CollectionUtils.size(\"not a list\");\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testSizeIsEmpty_Null() {\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(null));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_List() {\n+        final List<String> list = new ArrayList<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Map() {\n+        final Map<String, String> map = new HashMap<String, String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(map));\n+        map.put(\"1\", \"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(map));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Array() {\n+        final Object[] objectArray = new Object[0];\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(objectArray));\n+\n+        final String[] stringArray = new String[3];\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n+        stringArray[0] = \"a\";\n+        stringArray[1] = \"b\";\n+        stringArray[2] = \"c\";\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(stringArray));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_PrimitiveArray() {\n+        final int[] intArray = new int[0];\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(intArray));\n+\n+        final double[] doubleArray = new double[3];\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n+        doubleArray[0] = 0.0d;\n+        doubleArray[1] = 1.0d;\n+        doubleArray[2] = 2.5d;\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(doubleArray));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Enumeration() {\n+        final Vector<String> list = new Vector<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list.elements()));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list.elements()));\n+        final Enumeration<String> en = list.elements();\n+        en.nextElement();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(en));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Iterator() {\n+        final List<String> list = new ArrayList<String>();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(list.iterator()));\n+        list.add(\"a\");\n+        assertEquals(false, CollectionUtils.sizeIsEmpty(list.iterator()));\n+        final Iterator<String> it = list.iterator();\n+        it.next();\n+        assertEquals(true, CollectionUtils.sizeIsEmpty(it));\n+    }\n+\n+    @Test\n+    public void testSizeIsEmpty_Other() {\n+        try {\n+            CollectionUtils.sizeIsEmpty(\"not a list\");\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testIsEmptyWithEmptyCollection() {\n+        final Collection<Object> coll = new ArrayList<Object>();\n+        assertEquals(true, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsEmptyWithNonEmptyCollection() {\n+        final Collection<String> coll = new ArrayList<String>();\n+        coll.add(\"item\");\n+        assertEquals(false, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsEmptyWithNull() {\n+        final Collection<?> coll = null;\n+        assertEquals(true, CollectionUtils.isEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithEmptyCollection() {\n+        final Collection<Object> coll = new ArrayList<Object>();\n+        assertEquals(false, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithNonEmptyCollection() {\n+        final Collection<String> coll = new ArrayList<String>();\n+        coll.add(\"item\");\n+        assertEquals(true, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    @Test\n+    public void testIsNotEmptyWithNull() {\n+        final Collection<?> coll = null;\n+        assertEquals(false, CollectionUtils.isNotEmpty(coll));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n+        public boolean evaluate(final Number input) {\n+            return input.intValue() == 2;\n+        }\n+    };\n+\n+//Up to here\n+    @SuppressWarnings(\"cast\")\n+    @Test\n+    public void filter() {\n+        final List<Integer> ints = new ArrayList<Integer>();\n+        ints.add(1);\n+        ints.add(2);\n+        ints.add(3);\n+        ints.add(3);\n+        final Iterable<Integer> iterable = ints;\n+        assertTrue(CollectionUtils.filter(iterable, EQUALS_TWO));\n+        assertEquals(1, ints.size());\n+        assertEquals(2, (int) ints.get(0));\n+    }\n+\n+    @Test\n+    public void filterNullParameters() throws Exception {\n+        final List<Long> longs = Collections.nCopies(4, 10L);\n+        assertFalse(CollectionUtils.filter(longs, null));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filter(null, EQUALS_TWO));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filter(null, null));\n+        assertEquals(4, longs.size());\n+    }\n+\n+    @Test\n+    public void filterInverse() {\n+        final List<Integer> ints = new ArrayList<Integer>();\n+        ints.add(1);\n+        ints.add(2);\n+        ints.add(3);\n+        ints.add(3);\n+        final Iterable<Integer> iterable = ints;\n+        assertTrue(CollectionUtils.filterInverse(iterable, EQUALS_TWO));\n+        assertEquals(3, ints.size());\n+        assertEquals(1, (int) ints.get(0));\n+        assertEquals(3, (int) ints.get(1));\n+        assertEquals(3, (int) ints.get(2));\n+    }\n+        \n+    @Test\n+    public void filterInverseNullParameters() throws Exception {\n+        final List<Long> longs = Collections.nCopies(4, 10L);\n+        assertFalse(CollectionUtils.filterInverse(longs, null));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filterInverse(null, EQUALS_TWO));\n+        assertEquals(4, longs.size());\n+        assertFalse(CollectionUtils.filterInverse(null, null));\n+        assertEquals(4, longs.size());\n+    }\n+\n+    @Test\n+    public void countMatches() {\n+        assertEquals(4, CollectionUtils.countMatches(iterableB, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(iterableA, null));\n+        assertEquals(0, CollectionUtils.countMatches(null, EQUALS_TWO));\n+        assertEquals(0, CollectionUtils.countMatches(null, null));\n+    }\n+\n+    @Test\n+    public void exists() {\n+        final List<Integer> list = new ArrayList<Integer>();\n+        assertFalse(CollectionUtils.exists(null, null));\n+        assertFalse(CollectionUtils.exists(list, null));\n+        assertFalse(CollectionUtils.exists(null, EQUALS_TWO));\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+        list.add(1);\n+        list.add(3);\n+        list.add(4);\n+        assertFalse(CollectionUtils.exists(list, EQUALS_TWO));\n+\n+        list.add(2);\n+        assertEquals(true, CollectionUtils.exists(list, EQUALS_TWO));\n+    }\n+\n+    @Test\n+    public void select() {\n+        final List<Integer> list = new ArrayList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        // Ensure that the collection is the input type or a super type\n+        final Collection<Integer> output1 = CollectionUtils.select(list, EQUALS_TWO);\n+        final Collection<Number> output2 = CollectionUtils.<Number>select(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(1, output1.size());\n+        assertEquals(2, output2.iterator().next());\n+    }\n+\n+    @Test\n+    public void selectRejected() {\n+        final List<Long> list = new ArrayList<Long>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        list.add(4L);\n+        final Collection<Long> output1 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        final Collection<? extends Number> output2 = CollectionUtils.selectRejected(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(3, output1.size());\n+        assertTrue(output1.contains(1L));\n+        assertTrue(output1.contains(3L));\n+        assertTrue(output1.contains(4L));\n+    }\n+\n+    @Test\n+    public void collect() {\n+        final Transformer<Number, Long> transformer = TransformerUtils.constantTransformer(2L);\n+        Collection<Number> collection = CollectionUtils.<Integer, Number>collect(iterableA, transformer);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertCollectResult(collection);\n+\n+        ArrayList<Number> list;\n+        list = CollectionUtils.collect(collectionA, transformer, new ArrayList<Number>());\n+        assertTrue(list.size() == collectionA.size());\n+        assertCollectResult(list);\n+\n+        Iterator<Integer> iterator = null;\n+        list = CollectionUtils.collect(iterator, transformer, new ArrayList<Number>());\n+\n+        iterator = iterableA.iterator();\n+        list = CollectionUtils.collect(iterator, transformer, list);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertCollectResult(collection);\n+\n+        iterator = collectionA.iterator();\n+        collection = CollectionUtils.<Integer, Number>collect(iterator, transformer);\n+        assertTrue(collection.size() == collectionA.size());\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+        collection = CollectionUtils.collect((Iterator<Integer>) null, (Transformer<Integer, Number>) null);\n+        assertTrue(collection.size() == 0);\n+\n+        final int size = collectionA.size();\n+        collectionB = CollectionUtils.collect((Collection<Integer>) null, transformer, collectionB);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+        CollectionUtils.collect(collectionB, null, collectionA);\n+        assertTrue(collectionA.size() == size && collectionA.contains(1));\n+\n+    }\n+\n+    private void assertCollectResult(final Collection<Number> collection) {\n+        assertTrue(collectionA.contains(1) && !collectionA.contains(2L));\n+        assertTrue(collection.contains(2L) && !collection.contains(1));\n+    }\n+\n+    Transformer<Object, Integer> TRANSFORM_TO_INTEGER = new Transformer<Object, Integer>() {\n+        public Integer transform(final Object input) {\n+            return new Integer(((Long)input).intValue());\n+        }\n+    };\n+\n+    @Test\n+    public void transform1() {\n+        List<Number> list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        CollectionUtils.transform(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(3, list.size());\n+        assertEquals(1, list.get(0));\n+        assertEquals(2, list.get(1));\n+        assertEquals(3, list.get(2));\n+\n+        list = new ArrayList<Number>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        CollectionUtils.transform(null, TRANSFORM_TO_INTEGER);\n+        assertEquals(3, list.size());\n+        CollectionUtils.transform(list, null);\n+        assertEquals(3, list.size());\n+        CollectionUtils.transform(null, null);\n+        assertEquals(3, list.size());\n+    }\n+\n+    @Test\n+    public void transform2() {\n+        final Set<Number> set = new HashSet<Number>();\n+        set.add(1L);\n+        set.add(2L);\n+        set.add(3L);\n+        CollectionUtils.transform(set, new Transformer<Object, Integer>() {\n+            public Integer transform(final Object input) {\n+                return 4;\n+            }\n+        });\n+        assertEquals(1, set.size());\n+        assertEquals(4, set.iterator().next());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void addIgnoreNull() {\n+        final Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        assertFalse(CollectionUtils.addIgnoreNull(set, null));\n+        assertEquals(3, set.size());\n+        assertFalse(CollectionUtils.addIgnoreNull(set, \"1\"));\n+        assertEquals(3, set.size());\n+        assertEquals(true, CollectionUtils.addIgnoreNull(set, \"4\"));\n+        assertEquals(4, set.size());\n+        assertEquals(true, set.contains(\"4\"));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void predicatedCollection() {\n+        final Predicate<Object> predicate = PredicateUtils.instanceofPredicate(Integer.class);\n+        Collection<Number> collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection);\n+        try {\n+            collection = CollectionUtils.predicatedCollection(new ArrayList<Number>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            CollectionUtils.predicatedCollection(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void isFull() {\n+        final Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        try {\n+            CollectionUtils.isFull(null);\n+            fail();\n+        } catch (final NullPointerException ex) {\n+        }\n+        assertFalse(CollectionUtils.isFull(set));\n+\n+        final CircularFifoQueue<String> buf = new CircularFifoQueue<String>(set);\n+        assertEquals(false, CollectionUtils.isFull(buf));\n+        buf.remove(\"2\");\n+        assertFalse(CollectionUtils.isFull(buf));\n+        buf.add(\"2\");\n+        assertEquals(false, CollectionUtils.isFull(buf));\n+    }\n+\n+    @Test\n+    public void isEmpty() {\n+        assertFalse(CollectionUtils.isNotEmpty(null));\n+        assertTrue(CollectionUtils.isNotEmpty(collectionA));\n+    }\n+\n+    @Test\n+    public void maxSize() {\n+        final Set<String> set = new HashSet<String>();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        set.add(\"3\");\n+        try {\n+            CollectionUtils.maxSize(null);\n+            fail();\n+        } catch (final NullPointerException ex) {\n+        }\n+        assertEquals(-1, CollectionUtils.maxSize(set));\n+\n+        final Queue<String> buf = new CircularFifoQueue<String>(set);\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+        buf.remove(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+        buf.add(\"2\");\n+        assertEquals(3, CollectionUtils.maxSize(buf));\n+    }\n+\n+    @Test\n+    public void intersectionUsesMethodEquals() {\n+        // Let elta and eltb be objects...\n+        final Integer elta = new Integer(17);\n+        final Integer eltb = new Integer(17);\n+\n+        // ...which are equal...\n+        assertEquals(elta, eltb);\n+        assertEquals(eltb, elta);\n+\n+        // ...but not the same (==).\n+        assertTrue(elta != eltb);\n+\n+        // Let cola and colb be collections...\n+        final Collection<Number> cola = new ArrayList<Number>();\n+        final Collection<Integer> colb = new ArrayList<Integer>();\n+\n+        // ...which contain elta and eltb,\n+        // respectively.\n+        cola.add(elta);\n+        colb.add(eltb);\n+\n+        // Then the intersection of the two\n+        // should contain one element.\n+        final Collection<Number> intersection = CollectionUtils.intersection(cola, colb);\n+        assertEquals(1, intersection.size());\n+\n+        // In practice, this element will be the same (==) as elta\n+        // or eltb, although this isn't strictly part of the\n+        // contract.\n+        final Object eltc = intersection.iterator().next();\n+        assertTrue(eltc == elta && eltc != eltb || eltc != elta && eltc == eltb);\n+\n+        // In any event, this element remains equal,\n+        // to both elta and eltb.\n+        assertEquals(elta, eltc);\n+        assertEquals(eltc, elta);\n+        assertEquals(eltb, eltc);\n+        assertEquals(eltc, eltb);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    //Up to here\n+    @Test\n+    public void testRetainAll() {\n+        final List<String> base = new ArrayList<String>();\n+        base.add(\"A\");\n+        base.add(\"B\");\n+        base.add(\"C\");\n+        final List<Object> sub = new ArrayList<Object>();\n+        sub.add(\"A\");\n+        sub.add(\"C\");\n+        sub.add(\"X\");\n+\n+        final Collection<String> result = CollectionUtils.retainAll(base, sub);\n+        assertEquals(2, result.size());\n+        assertEquals(true, result.contains(\"A\"));\n+        assertFalse(result.contains(\"B\"));\n+        assertEquals(true, result.contains(\"C\"));\n+        assertEquals(3, base.size());\n+        assertEquals(true, base.contains(\"A\"));\n+        assertEquals(true, base.contains(\"B\"));\n+        assertEquals(true, base.contains(\"C\"));\n+        assertEquals(3, sub.size());\n+        assertEquals(true, sub.contains(\"A\"));\n+        assertEquals(true, sub.contains(\"C\"));\n+        assertEquals(true, sub.contains(\"X\"));\n+\n+        try {\n+            CollectionUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (final NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    @Test\n+    public void testRemoveAll() {\n+        final List<String> base = new ArrayList<String>();\n+        base.add(\"A\");\n+        base.add(\"B\");\n+        base.add(\"C\");\n+        final List<String> sub = new ArrayList<String>();\n+        sub.add(\"A\");\n+        sub.add(\"C\");\n+        sub.add(\"X\");\n+\n+        final Collection<String> result = CollectionUtils.removeAll(base, sub);\n+        assertEquals(1, result.size());\n+        assertFalse(result.contains(\"A\"));\n+        assertEquals(true, result.contains(\"B\"));\n+        assertFalse(result.contains(\"C\"));\n+        assertEquals(3, base.size());\n+        assertEquals(true, base.contains(\"A\"));\n+        assertEquals(true, base.contains(\"B\"));\n+        assertEquals(true, base.contains(\"C\"));\n+        assertEquals(3, sub.size());\n+        assertEquals(true, sub.contains(\"A\"));\n+        assertEquals(true, sub.contains(\"C\"));\n+        assertEquals(true, sub.contains(\"X\"));\n+\n+        try {\n+            CollectionUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (final NullPointerException npe) {\n+        } // this is what we want\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @Test\n+    public void testTransformedCollection() {\n+        final Transformer<Object, Object> transformer = TransformerUtils.nopTransformer();\n+        Collection<Object> collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), transformer);\n+        assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n+        try {\n+            collection = CollectionUtils.transformingCollection(new ArrayList<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null transformer.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            collection = CollectionUtils.transformingCollection(null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testTransformedCollection_2() {\n+        final List<Object> list = new ArrayList<Object>();\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        final Collection<Object> result = CollectionUtils.transformingCollection(list, TRANSFORM_TO_INTEGER);\n+        assertEquals(true, result.contains(\"1\")); // untransformed\n+        assertEquals(true, result.contains(\"2\")); // untransformed\n+        assertEquals(true, result.contains(\"3\")); // untransformed\n+    }\n+\n+    @Test\n+    public void testSynchronizedCollection() {\n+        Collection<Object> col = CollectionUtils.synchronizedCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a SynchronizedCollection.\", col instanceof SynchronizedCollection);\n+        try {\n+            col = CollectionUtils.synchronizedCollection(null);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testUnmodifiableCollection() {\n+        Collection<Object> col = CollectionUtils.unmodifiableCollection(new ArrayList<Object>());\n+        assertTrue(\"Returned object should be a UnmodifiableCollection.\", col instanceof UnmodifiableCollection);\n+        try {\n+            col = CollectionUtils.unmodifiableCollection(null);\n+            fail(\"Expecting IllegalArgumentException for null collection.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void emptyCollection() throws Exception {\n+        final Collection<Number> coll = CollectionUtils.emptyCollection();\n+        assertEquals(CollectionUtils.EMPTY_COLLECTION, coll);\n+    }\n+\n+    @Test\n+    public void emptyIfNull() {\n+        assertTrue(CollectionUtils.emptyIfNull(null).isEmpty());\n+        final Collection<Object> collection = new ArrayList<Object>();\n+        assertSame(collection, CollectionUtils.emptyIfNull(collection));\n+    }\n+    \n+    /**\n+     * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n+     * Specifically, it uses mocks to ensure that if the passed in\n+     * {@link Iterable} is a {@link Collection} then\n+     * {@link Collection#addAll(Collection)} is called instead of iterating.\n+     */\n+    @Test\n+    public void addAllForIterable() {\n+        final Collection<Integer> inputCollection = createMock(Collection.class);\n+        final Iterable<Integer> inputIterable = inputCollection;\n+        final Iterable<Long> iterable = createMock(Iterable.class);\n+        final Iterator<Long> iterator = createMock(Iterator.class);\n+        final Collection<Number> c = createMock(Collection.class);\n+\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        next(iterator, 2L);\n+        next(iterator, 3L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(true);\n+        expect(c.add(2L)).andReturn(true);\n+        expect(c.add(3L)).andReturn(true);\n+        // Check that the collection is added using\n+        // Collection.addAll(Collection)\n+        expect(c.addAll(inputCollection)).andReturn(true);\n+\n+        // Ensure the method returns false if nothing is added\n+        expect(iterable.iterator()).andReturn(iterator);\n+        next(iterator, 1L);\n+        expect(iterator.hasNext()).andReturn(false);\n+        expect(c.add(1L)).andReturn(false);\n+        expect(c.addAll(inputCollection)).andReturn(false);\n+\n+        replay();\n+        assertTrue(CollectionUtils.addAll(c, iterable));\n+        assertTrue(CollectionUtils.addAll(c, inputIterable));\n+\n+        assertFalse(CollectionUtils.addAll(c, iterable));\n+        assertFalse(CollectionUtils.addAll(c, inputIterable));\n+        verify();\n+    }\n+\n+    @Test\n+    public void addAllForEnumeration() {\n+        final Hashtable<Integer, Integer> h = new Hashtable<Integer, Integer>();\n+        h.put(5, 5);\n+        final Enumeration<? extends Integer> enumeration = h.keys();\n+        CollectionUtils.addAll(collectionA, enumeration);\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test\n+    public void addAllForElements() {\n+        CollectionUtils.addAll(collectionA, new Integer[]{5});\n+        assertTrue(collectionA.contains(5));\n+    }\n+\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getNegative() {\n+        CollectionUtils.get((Object)collectionA, -3);\n+    }\n+\n+    @Test(expected=IndexOutOfBoundsException.class)\n+    public void getPositiveOutOfBounds() {\n+        CollectionUtils.get((Object)collectionA.iterator(), 30);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void get1() {\n+        CollectionUtils.get((Object)null, 0);\n+    }\n+\n+    @Test\n+    public void get() {\n+        assertEquals(2, CollectionUtils.get((Object)collectionA, 2));\n+        assertEquals(2, CollectionUtils.get((Object)collectionA.iterator(), 2));\n+        final Map<Integer, Integer> map = CollectionUtils.getCardinalityMap(collectionA);\n+        assertEquals(map.entrySet().iterator().next(), CollectionUtils.get(\n+                (Object)map, 0));\n+    }\n+\n+    @Test\n+    public void reverse() {\n+        CollectionUtils.reverseArray(new Object[] {});\n+        final Integer[] a = collectionA.toArray(new Integer[collectionA.size()]);\n+        CollectionUtils.reverseArray(a);\n+        // assume our implementation is correct if it returns the same order as the Java function\n+        Collections.reverse(collectionA);\n+        assertEquals(collectionA, Arrays.asList(a));\n+    }\n+\n+    @Test\n+    public void extractSingleton() {\n+        ArrayList<String> coll = null;\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(null)\");\n+        } catch (final IllegalArgumentException e) {\n+        }\n+        coll = new ArrayList<String>();\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(empty)\");\n+        } catch (final IllegalArgumentException e) {\n+        }\n+        coll.add(\"foo\");\n+        assertEquals(\"foo\", CollectionUtils.extractSingleton(coll));\n+        coll.add(\"bar\");\n+        try {\n+            CollectionUtils.extractSingleton(coll);\n+            fail(\"expected IllegalArgumentException from extractSingleton(size == 2)\");\n+        } catch (final IllegalArgumentException e) {\n+        }\n+    }\n+\n+    /**\n+     * Records the next object returned for a mock iterator\n+     */\n+    private <T> void next(final Iterator<T> iterator, final T t) {\n+        expect(iterator.hasNext()).andReturn(true);\n+        expect(iterator.next()).andReturn(t);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/EnumerationUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.commons.collections4.EnumerationUtils;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Tests EnumerationUtils.\n+ *\n+ * @version $Id$\n+ */\n+public class EnumerationUtilsTest extends BulkTest {\n+\n+    public EnumerationUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public static final String TO_LIST_FIXTURE = \"this is a test\";\n+    \n+    public void testToListWithStringTokenizer() {\n+        final List<String> expectedList1 = new ArrayList<String>();\n+        final StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n+             while (st.hasMoreTokens()) {\n+                 expectedList1.add(st.nextToken());\n+             }\n+        final List<String> expectedList2 = new ArrayList<String>();\n+        expectedList2.add(\"this\");\n+        expectedList2.add(\"is\");\n+        expectedList2.add(\"a\");\n+        expectedList2.add(\"test\");\n+        final List<String> actualList = EnumerationUtils.toList(new StringTokenizer(TO_LIST_FIXTURE));\n+        assertEquals(expectedList1, expectedList2);\n+        assertEquals(expectedList1, actualList);\n+        assertEquals(expectedList2, actualList);\n+    }\n+\n+    public void testToListWithHashtable() {\n+        final Hashtable<String, Integer> expected = new Hashtable<String, Integer>();\n+        expected.put(\"one\", new Integer(1));\n+        expected.put(\"two\", new Integer(2));\n+        expected.put(\"three\", new Integer(3));\n+        // validate elements.\n+        final List<Integer> actualEltList = EnumerationUtils.toList(expected.elements());\n+        assertEquals(expected.size(), actualEltList.size());\n+        assertTrue(actualEltList.contains(new Integer(1)));\n+        assertTrue(actualEltList.contains(new Integer(2)));\n+        assertTrue(actualEltList.contains(new Integer(3)));\n+        final List<Integer> expectedEltList = new ArrayList<Integer>();\n+        expectedEltList.add(new Integer(1));\n+        expectedEltList.add(new Integer(2));\n+        expectedEltList.add(new Integer(3));\n+        assertTrue(actualEltList.containsAll(expectedEltList));\n+\n+        // validate keys.\n+        final List<String> actualKeyList = EnumerationUtils.toList(expected.keys());\n+        assertEquals(expected.size(), actualEltList.size());\n+        assertTrue(actualKeyList.contains(\"one\"));\n+        assertTrue(actualKeyList.contains(\"two\"));\n+        assertTrue(actualKeyList.contains(\"three\"));\n+        final List<String> expectedKeyList = new ArrayList<String>();\n+        expectedKeyList.add(\"one\");\n+        expectedKeyList.add(\"two\");\n+        expectedKeyList.add(\"three\");\n+        assertTrue(actualKeyList.containsAll(expectedKeyList));\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(EnumerationUtilsTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/FactoryUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.NotSerializableException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FactoryUtils;\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.functors.ConstantFactory;\n+import org.apache.commons.collections4.functors.ExceptionFactory;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the org.apache.commons.collections.FactoryUtils class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FactoryUtilsTest extends junit.framework.TestCase {\n+\n+    /**\n+     * Construct\n+     */\n+    public FactoryUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+\n+    // exceptionFactory\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionFactory() {\n+        assertNotNull(FactoryUtils.exceptionFactory());\n+        assertSame(FactoryUtils.exceptionFactory(), FactoryUtils.exceptionFactory());\n+        try {\n+            FactoryUtils.exceptionFactory().create();\n+        } catch (final FunctorException ex) {\n+            try {\n+                FactoryUtils.exceptionFactory().create();\n+            } catch (final FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nullFactory\n+    //------------------------------------------------------------------\n+\n+    public void testNullFactory() {\n+        final Factory<Object> factory = FactoryUtils.nullFactory();\n+        assertNotNull(factory);\n+        final Object created = factory.create();\n+        assertNull(created);\n+    }\n+\n+    // constantFactory\n+    //------------------------------------------------------------------\n+\n+    public void testConstantFactoryNull() {\n+        final Factory<Object> factory = FactoryUtils.constantFactory(null);\n+        assertNotNull(factory);\n+        final Object created = factory.create();\n+        assertNull(created);\n+    }\n+\n+    public void testConstantFactoryConstant() {\n+        final Integer constant = new Integer(9);\n+        final Factory<Integer> factory = FactoryUtils.constantFactory(constant);\n+        assertNotNull(factory);\n+        final Integer created = factory.create();\n+        assertSame(constant, created);\n+    }\n+\n+    // prototypeFactory\n+    //------------------------------------------------------------------\n+\n+    public void testPrototypeFactoryNull() {\n+        assertSame(ConstantFactory.NULL_INSTANCE, FactoryUtils.prototypeFactory(null));\n+    }\n+\n+    public void testPrototypeFactoryPublicCloneMethod() throws Exception {\n+        final Date proto = new Date();\n+        final Factory<Date> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        final Date created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicCopyConstructor() throws Exception {\n+        final Mock1 proto = new Mock1(6);\n+        Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        assertNotNull(factory);\n+        final Object created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        try {\n+            out.writeObject(factory);\n+        } catch (final NotSerializableException ex) {\n+            out.close();\n+        }\n+        factory = FactoryUtils.<Object>prototypeFactory(new Mock2(\"S\"));\n+        buffer = new ByteArrayOutputStream();\n+        out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicSerialization() throws Exception {\n+        final Integer proto = new Integer(9);\n+        final Factory<Integer> factory = FactoryUtils.prototypeFactory(proto);\n+        assertNotNull(factory);\n+        final Integer created = factory.create();\n+        assertTrue(proto != created);\n+        assertEquals(proto, created);\n+\n+        // check serialisation works\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(factory);\n+        out.close();\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        in.readObject();\n+        in.close();\n+    }\n+\n+    public void testPrototypeFactoryPublicSerializationError() {\n+        final Mock2 proto = new Mock2(new Object());\n+        final Factory<Object> factory = FactoryUtils.<Object>prototypeFactory(proto);\n+        assertNotNull(factory);\n+        try {\n+            factory.create();\n+        } catch (final FunctorException ex) {\n+            assertTrue(ex.getCause() instanceof IOException);\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public void testPrototypeFactoryPublicBad() {\n+        final Object proto = new Object();\n+        try {\n+            FactoryUtils.prototypeFactory(proto);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    public static class Mock1 {\n+        private final int iVal;\n+        public Mock1(final int val) {\n+            iVal = val;\n+        }\n+        public Mock1(final Mock1 mock) {\n+            iVal = mock.iVal;\n+        }\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj instanceof Mock1) {\n+                if (iVal == ((Mock1) obj).iVal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    public static class Mock2 implements Serializable {\n+        /**\n+         * Generated serial version ID.\n+         */\n+        private static final long serialVersionUID = 4899282162482588924L;\n+        private final Object iVal;\n+        public Mock2(final Object val) {\n+            iVal = val;\n+        }\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj instanceof Mock2) {\n+                if (iVal == ((Mock2) obj).iVal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    public static class Mock3 {\n+        private static int cCounter = 0;\n+        private final int iVal;\n+        public Mock3() {\n+            iVal = cCounter++;\n+        }\n+        public int getValue() {\n+            return iVal;\n+        }\n+    }\n+\n+    // instantiateFactory\n+    //------------------------------------------------------------------\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryNull() {\n+        FactoryUtils.instantiateFactory(null);\n+    }\n+\n+    @Test\n+    public void instantiateFactorySimple() {\n+        final Factory<Mock3> factory = FactoryUtils.instantiateFactory(Mock3.class);\n+        assertNotNull(factory);\n+        Mock3 created = factory.create();\n+        assertEquals(0, created.getValue());\n+        created = factory.create();\n+        assertEquals(1, created.getValue());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryMismatch() {\n+        FactoryUtils.instantiateFactory(Date.class, null, new Object[] {null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void instantiateFactoryNoConstructor() {\n+        FactoryUtils.instantiateFactory(Date.class, new Class[] {Long.class}, new Object[] {null});\n+    }\n+\n+    @Test\n+    public void instantiateFactoryComplex() {\n+        TimeZone.setDefault(TimeZone.getTimeZone(\"GMT\"));\n+        // 2nd Jan 1970\n+        final Factory<Date> factory = FactoryUtils.instantiateFactory(Date.class,\n+            new Class[] {Integer.TYPE, Integer.TYPE, Integer.TYPE},\n+            new Object[] {new Integer(70), new Integer(0), new Integer(2)});\n+        assertNotNull(factory);\n+        final Date created = factory.create();\n+        // long time of 1 day (== 2nd Jan 1970)\n+        assertEquals(new Date(1000 * 60 * 60 * 24), created);\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Factory singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionFactory.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.IteratorUtils;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.OrderedIterator;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.ResettableListIterator;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.EmptyListIterator;\n+import org.apache.commons.collections4.iterators.EmptyMapIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedIterator;\n+import org.apache.commons.collections4.iterators.EmptyOrderedMapIterator;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+\n+/**\n+ * Tests for IteratorUtils.\n+ *\n+ * @version $Id$\n+ */\n+public class IteratorUtilsTest extends BulkTest {\n+\n+    public IteratorUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(IteratorUtilsTest.class);\n+    }\n+\n+    public void testAsIterable() {\n+        final List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        final Iterator<Integer> iterator = list.iterator();\n+        \n+        final Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n+        int expected = 0;\n+        for(final Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+\n+        // single use iterator\n+        for(@SuppressWarnings(\"unused\") final Integer actual : iterable) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+    \n+    public void testAsIterableNull() {\n+        try {\n+            IteratorUtils.asIterable(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testAsMultipleIterable() {\n+        final List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        final Iterator<Integer> iterator = list.iterator();\n+        \n+        final Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n+        int expected = 0;\n+        for(final Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+\n+        // multiple use iterator\n+        expected = 0;\n+        for(final Integer actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        // insure iteration occurred\n+        assertTrue(expected > 0);\n+    }\n+\n+    public void testAsMultipleIterableNull() {\n+        try {\n+            IteratorUtils.asMultipleUseIterable(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n+            // success\n+        }\n+    }\n+    \n+    public void testToList() {\n+        final List<Object> list = new ArrayList<Object>();\n+        list.add(new Integer(1));\n+        list.add(\"Two\");\n+        list.add(null);\n+        final List<Object> result = IteratorUtils.toList(list.iterator());\n+        assertEquals(list, result);\n+    }\n+\n+    public void testToArray() {\n+        final List<Object> list = new ArrayList<Object>();\n+        list.add(new Integer(1));\n+        list.add(\"Two\");\n+        list.add(null);\n+        final Object[] result = IteratorUtils.toArray(list.iterator());\n+        assertEquals(list, Arrays.asList(result));\n+    }\n+\n+    public void testToArray2() {\n+        final List<String> list = new ArrayList<String>();\n+        list.add(\"One\");\n+        list.add(\"Two\");\n+        list.add(null);\n+        final String[] result = IteratorUtils.toArray(list.iterator(), String.class);\n+        assertEquals(list, Arrays.asList(result));\n+    }\n+\n+    public void testArrayIterator() {\n+        final Object[] objArray = {\"a\", \"b\", \"c\"};\n+        ResettableIterator<Object> iterator = IteratorUtils.arrayIterator(objArray);\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.next().equals(\"b\"));\n+        iterator.reset();\n+        assertTrue(iterator.next().equals(\"a\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(new Integer(0));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+                // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n+                // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 1);\n+        assertTrue(iterator.next().equals(\"b\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 3);\n+        assertTrue(!iterator.hasNext());\n+        iterator.reset();\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(objArray, 2, 3);\n+        assertTrue(iterator.next().equals(\"c\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(objArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        final int[] intArray = {0, 1, 2};\n+        iterator = IteratorUtils.arrayIterator(intArray);\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        iterator.reset();\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 1);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 3);\n+        assertTrue(!iterator.hasNext());\n+        iterator.reset();\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayIterator(intArray, 2, 3);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayIterator(intArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testArrayListIterator() {\n+        final Object[] objArray = {\"a\", \"b\", \"c\", \"d\"};\n+        ResettableListIterator<Object> iterator = IteratorUtils.arrayListIterator(objArray);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.previous().equals(\"a\"));\n+        assertTrue(iterator.next().equals(\"a\"));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(\"b\"));\n+        assertTrue(iterator.next().equals(\"c\"));\n+        assertTrue(iterator.next().equals(\"d\"));\n+        assertTrue(iterator.nextIndex() == 4); // size of list\n+        assertTrue(iterator.previousIndex() == 3);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(new Integer(0));\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+                // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (final NullPointerException ex) {\n+                // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 1);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(\"b\"));\n+        assertTrue(iterator.previousIndex() == 0);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 3);\n+        assertTrue(iterator.hasNext());\n+        try {\n+            iterator.previous();\n+            fail(\"Expecting NoSuchElementException.\");\n+        } catch (final NoSuchElementException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 5);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(objArray, 2, 3);\n+        assertTrue(iterator.next().equals(\"c\"));\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 2, 5);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(objArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+\n+        final int[] intArray = {0, 1, 2};\n+        iterator = IteratorUtils.arrayListIterator(intArray);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(new Integer(0)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previousIndex() == 1);\n+        assertTrue(iterator.nextIndex() == 2);\n+        assertTrue(iterator.previous().equals(new Integer(1)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 1);\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.nextIndex() == 0);\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previous().equals(new Integer(1)));\n+        assertTrue(iterator.next().equals(new Integer(1)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+        assertTrue(iterator.previousIndex() == 1);\n+        assertTrue(iterator.nextIndex() == 2);\n+        assertTrue(iterator.previous().equals(new Integer(2)));\n+        assertTrue(iterator.previousIndex() == 0);\n+        assertTrue(iterator.nextIndex() == 1);\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, -1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 3);\n+        assertTrue(!iterator.hasNext());\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        iterator = IteratorUtils.arrayListIterator(intArray, 2, 3);\n+        assertTrue(!iterator.hasPrevious());\n+        assertTrue(iterator.previousIndex() == -1);\n+        assertTrue(iterator.next().equals(new Integer(2)));\n+        assertTrue(iterator.hasPrevious());\n+        assertTrue(!iterator.hasNext());\n+\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 2, 4);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, -1, 1);\n+            fail(\"Expecting IndexOutOfBoundsException\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+\n+        try {\n+            iterator = IteratorUtils.arrayListIterator(intArray, 2, 1);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     * Gets an immutable Iterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n+     */\n+    private Iterator<String> getImmutableIterator() {\n+        final List<String> list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        list.add(\"c\");\n+        list.add(\"d\");\n+        return IteratorUtils.unmodifiableIterator(list.iterator());\n+    }\n+\n+    /**\n+     * Gets an immutable ListIterator operating on the elements [\"a\", \"b\", \"c\", \"d\"].\n+     */\n+    private ListIterator<String> getImmutableListIterator() {\n+        final List<String> list = new ArrayList<String>();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        list.add(\"c\");\n+        list.add(\"d\");\n+        return IteratorUtils.unmodifiableListIterator(list.listIterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty iterator\n+     */\n+    public void testEmptyIterator() {\n+        assertSame(EmptyIterator.INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n+        assertSame(EmptyIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof OrderedIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ITERATOR.hasNext());\n+        IteratorUtils.EMPTY_ITERATOR.reset();\n+        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.EMPTY_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ITERATOR, IteratorUtils.emptyIterator());\n+        try {\n+            IteratorUtils.EMPTY_ITERATOR.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ITERATOR.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty list iterator\n+     */\n+    public void testEmptyListIterator() {\n+        assertSame(EmptyListIterator.INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertSame(EmptyListIterator.RESETTABLE_INSTANCE, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ListIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_LIST_ITERATOR instanceof ResettableListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_LIST_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_LIST_ITERATOR.hasNext());\n+        assertEquals(0, IteratorUtils.EMPTY_LIST_ITERATOR.nextIndex());\n+        assertEquals(-1, IteratorUtils.EMPTY_LIST_ITERATOR.previousIndex());\n+        IteratorUtils.EMPTY_LIST_ITERATOR.reset();\n+        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.EMPTY_LIST_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_LIST_ITERATOR, IteratorUtils.emptyListIterator());\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.previous();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.set(null);\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_LIST_ITERATOR.add(null);\n+            fail();\n+        } catch (final UnsupportedOperationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyMapIterator() {\n+        assertSame(EmptyMapIterator.INSTANCE, IteratorUtils.EMPTY_MAP_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof MapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_MAP_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR instanceof OrderedMapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_MAP_ITERATOR.hasNext());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_MAP_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.EMPTY_MAP_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_MAP_ITERATOR, IteratorUtils.emptyMapIterator());\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.getKey();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.getValue();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_MAP_ITERATOR.setValue(null);\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyOrderedIterator() {\n+        assertSame(EmptyOrderedIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof OrderedIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR instanceof MapIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR.hasNext());\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_ITERATOR.hasPrevious());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.EMPTY_ORDERED_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ORDERED_ITERATOR, IteratorUtils.emptyOrderedIterator());\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.previous();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_ITERATOR.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test empty map iterator\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyOrderedMapIterator() {\n+        assertSame(EmptyOrderedMapIterator.INSTANCE, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof Iterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof MapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof OrderedMapIterator);\n+        assertEquals(true, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ResettableIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR instanceof ListIterator);\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasNext());\n+        assertEquals(false, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.hasPrevious());\n+        ((ResettableIterator<Object>) IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR).reset();\n+        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR);\n+        assertSame(IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR, IteratorUtils.emptyOrderedMapIterator());\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.previous();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getKey();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.getValue();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        try {\n+            IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR.setValue(null);\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test next() and hasNext() for an immutable Iterator.\n+     */\n+    public void testUnmodifiableIteratorIteration() {\n+        final Iterator<String> iterator = getImmutableIterator();\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"a\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"b\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"c\", iterator.next());\n+\n+        assertTrue(iterator.hasNext());\n+\n+        assertEquals(\"d\", iterator.next());\n+\n+        assertTrue(!iterator.hasNext());\n+    }\n+\n+    /**\n+     * Test next(), hasNext(), previous() and hasPrevious() for an immutable\n+     * ListIterator.\n+     */\n+    public void testUnmodifiableListIteratorIteration() {\n+        final ListIterator<String> listIterator = getImmutableListIterator();\n+\n+        assertTrue(!listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"a\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"b\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"c\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"d\", listIterator.next());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(!listIterator.hasNext());\n+\n+        assertEquals(\"d\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"c\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"b\", listIterator.previous());\n+\n+        assertTrue(listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+\n+        assertEquals(\"a\", listIterator.previous());\n+\n+        assertTrue(!listIterator.hasPrevious());\n+        assertTrue(listIterator.hasNext());\n+    }\n+\n+    /**\n+     * Test remove() for an immutable Iterator.\n+     */\n+    public void testUnmodifiableIteratorImmutability() {\n+        final Iterator<String> iterator = getImmutableIterator();\n+\n+        try {\n+            iterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        iterator.next();\n+\n+        try {\n+            iterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+    }\n+\n+    /**\n+     * Test remove() for an immutable ListIterator.\n+     */\n+    public void testUnmodifiableListIteratorImmutability() {\n+        final ListIterator<String> listIterator = getImmutableListIterator();\n+\n+        try {\n+            listIterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.set(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"set(Object) should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.add(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"add(Object) should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        listIterator.next();\n+\n+        try {\n+            listIterator.remove();\n+            // We shouldn't get to here.\n+            fail(\"remove() should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.set(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"set(Object) should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+\n+        try {\n+            listIterator.add(\"a\");\n+            // We shouldn't get to here.\n+            fail(\"add(Object) should throw an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // This is correct; ignore the exception.\n+        }\n+    }\n+\n+    /**\n+     * Tests method nodeListIterator(NodeList)\n+     */\n+    public void testNodeListIterator() {\n+        final Node[] nodes = createNodes();\n+        final NodeList nodeList = createNodeList(nodes);\n+        \n+        final Iterator<Node> iterator = IteratorUtils.nodeListIterator(nodeList);\n+        int expectedNodeIndex = 0;\n+        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n+            assertEquals(nodes[expectedNodeIndex], actual);\n+            ++expectedNodeIndex;\n+        }\n+\n+        // insure iteration occurred\n+        assertTrue(expectedNodeIndex > 0);\n+\n+        // single use iterator\n+        for (@SuppressWarnings(\"unused\") final Node actual : IteratorUtils.asIterable(iterator)) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+    /**\n+     * Tests method nodeListIterator(Node)\n+     */\n+    public void testNodeIterator() {\n+        final Node[] nodes = createNodes();\n+        final NodeList nodeList = createNodeList(nodes);\n+        final Node parentNode = createMock(Node.class);\n+        expect(parentNode.getChildNodes()).andStubReturn(nodeList);\n+        replay(parentNode);\n+        \n+        final Iterator<Node> iterator = IteratorUtils.nodeListIterator(parentNode);\n+        int expectedNodeIndex = 0;\n+        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n+            assertEquals(nodes[expectedNodeIndex], actual);\n+            ++expectedNodeIndex;\n+        }\n+\n+        // insure iteration occurred\n+        assertTrue(expectedNodeIndex > 0);\n+\n+        // single use iterator\n+        for (@SuppressWarnings(\"unused\") final Node actual : IteratorUtils.asIterable(iterator)) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+    \n+    /**\n+     * creates an array of four Node instances, mocked by EasyMock.\n+     * @return \n+     */\n+    private Node[] createNodes() {\n+        final Node node1 = createMock(Node.class);\n+        final Node node2 = createMock(Node.class);\n+        final Node node3 = createMock(Node.class);\n+        final Node node4 = createMock(Node.class);\n+        replay(node1);\n+        replay(node2);\n+        replay(node3);\n+        replay(node4);\n+\n+        return new Node[]{node1, node2, node3, node4};\n+}\n+\n+    /**\n+     * Creates a NodeList containing the specified nodes.\n+     */\n+    private NodeList createNodeList(final Node[] nodes) {\n+        return new NodeList() {\n+            public Node item(final int index) {\n+                return nodes[index];\n+            }\n+            public int getLength() {\n+                return nodes.length;\n+            }\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.ListUtils;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.list.PredicatedList;\n+\n+/**\n+ * Tests for ListUtils.\n+ *\n+ * @version $Id$\n+ */\n+public class ListUtilsTest extends BulkTest {\n+\n+    private static final String a = \"a\";\n+    private static final String b = \"b\";\n+    private static final String c = \"c\";\n+    private static final String d = \"d\";\n+    private static final String e = \"e\";\n+    private static final String x = \"x\";\n+\n+    private String[] fullArray;\n+    private List<String> fullList;\n+\n+    public ListUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ListUtilsTest.class);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        fullArray = new String[]{a, b, c, d, e};\n+        fullList = new ArrayList<String>(Arrays.asList(fullArray));\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an empty list.\n+     */\n+    public void testIntersectNonEmptyWithEmptyList() {\n+        final List<String> empty = Collections.<String>emptyList();\n+        assertTrue(\"result not empty\", ListUtils.intersection(empty, fullList).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an empty list.\n+     */\n+    public void testIntersectEmptyWithEmptyList() {\n+        final List<?> empty = Collections.EMPTY_LIST;\n+        assertTrue(\"result not empty\", ListUtils.intersection(empty, empty).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an subset of iteself.\n+     */\n+    public void testIntersectNonEmptySubset() {\n+        // create a copy\n+        final List<String> other = new ArrayList<String>(fullList);\n+\n+        // remove a few items\n+        assertNotNull(other.remove(0));\n+        assertNotNull(other.remove(1));\n+\n+        // make sure the intersection is equal to the copy\n+        assertEquals(other, ListUtils.intersection(fullList, other));\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with an subset of iteself.\n+     */\n+    public void testIntersectListWithNoOverlapAndDifferentTypes() {\n+        @SuppressWarnings(\"boxing\")\n+        final List<Integer> other = Arrays.asList(1, 23);\n+        assertTrue(ListUtils.intersection(fullList, other).isEmpty());\n+    }\n+\n+    /**\n+     * Tests intersecting a non-empty list with iteself.\n+     */\n+    public void testIntersectListWithSelf() {\n+        assertEquals(fullList, ListUtils.intersection(fullList, fullList));\n+    }\n+\n+    /**\n+     * Tests intersecting two lists in different orders.\n+     */\n+    public void testIntersectionOrderInsensitivity() {\n+        final List<String> one = new ArrayList<String>();\n+        final List<String> two = new ArrayList<String>();\n+        one.add(\"a\");\n+        one.add(\"b\");\n+        two.add(\"a\");\n+        two.add(\"a\");\n+        two.add(\"b\");\n+        two.add(\"b\");\n+        assertEquals(ListUtils.intersection(one,two),ListUtils.intersection(two, one));\n+    }\n+\n+    public void testPredicatedList() {\n+        final Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(final Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        List<Object> list = ListUtils.predicatedList(new ArrayList<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedList\", list instanceof PredicatedList);\n+        try {\n+            list = ListUtils.predicatedList(new ArrayList<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            list = ListUtils.predicatedList(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null list.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyList() {\n+        final List<Integer> list = ListUtils.lazyList(new ArrayList<Integer>(), new Factory<Integer>() {\n+\n+            private int index;\n+\n+            public Integer create() {\n+                index++;\n+                return new Integer(index);\n+            }\n+        });\n+\n+        assertNotNull(list.get(5));\n+        assertEquals(6, list.size());\n+\n+        assertNotNull(list.get(5));\n+        assertEquals(6, list.size());\n+    }\n+\n+    public void testEmptyIfNull() {\n+        assertTrue(ListUtils.emptyIfNull(null).isEmpty());\n+        \n+        final List<Long> list = new ArrayList<Long>();\n+        assertSame(list, ListUtils.emptyIfNull(list));\n+    }\n+\n+    public void testDefaultIfNull() {\n+        assertTrue(ListUtils.defaultIfNull(null, Collections.emptyList()).isEmpty());\n+        \n+        final List<Long> list = new ArrayList<Long>();\n+        assertSame(list, ListUtils.defaultIfNull(list, Collections.<Long>emptyList()));\n+    }\n+\n+    public void testEquals() {\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        final List<String> a = new ArrayList<String>( data );\n+        final List<String> b = new ArrayList<String>( data );\n+\n+        assertEquals(true, a.equals(b));\n+        assertEquals(true, ListUtils.isEqualList(a, b));\n+        a.clear();\n+        assertEquals(false, ListUtils.isEqualList(a, b));\n+        assertEquals(false, ListUtils.isEqualList(a, null));\n+        assertEquals(false, ListUtils.isEqualList(null, b));\n+        assertEquals(true, ListUtils.isEqualList(null, null));\n+    }\n+\n+    public void testHashCode() {\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        final List<String> a = new ArrayList<String>(data);\n+        final List<String> b = new ArrayList<String>(data);\n+\n+        assertEquals(true, a.hashCode() == b.hashCode());\n+        assertEquals(true, a.hashCode() == ListUtils.hashCodeForList(a));\n+        assertEquals(true, b.hashCode() == ListUtils.hashCodeForList(b));\n+        assertEquals(true, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n+        a.clear();\n+        assertEquals(false, ListUtils.hashCodeForList(a) == ListUtils.hashCodeForList(b));\n+        assertEquals(0, ListUtils.hashCodeForList(null));\n+    }\n+\n+    public void testRetainAll() {\n+        final List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        final List<String> retained = ListUtils.retainAll(fullList, sub);\n+        assertTrue(retained.size() == 2);\n+        sub.remove(x);\n+        assertTrue(retained.equals(sub));\n+        fullList.retainAll(sub);\n+        assertTrue(retained.equals(fullList));\n+\n+        try {\n+            ListUtils.retainAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(final NullPointerException npe){} // this is what we want\n+    }\n+\n+    public void testRemoveAll() {\n+        final List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+        sub.add(b);\n+        sub.add(x);\n+\n+        final List<String> remainder = ListUtils.removeAll(fullList, sub);\n+        assertTrue(remainder.size() == 3);\n+        fullList.removeAll(sub);\n+        assertTrue(remainder.equals(fullList));\n+\n+        try {\n+            ListUtils.removeAll(null, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(final NullPointerException npe) {} // this is what we want\n+    }\n+\n+    public void testSubtract() {\n+        final List<String> list = new ArrayList<String>();\n+        list.add(a);\n+        list.add(b);\n+        list.add(a);\n+        list.add(x);\n+\n+        final List<String> sub = new ArrayList<String>();\n+        sub.add(a);\n+\n+        final List<String> result = ListUtils.subtract(list, sub);\n+        assertTrue(result.size() == 3);\n+        \n+        final List<String> expected = new ArrayList<String>();\n+        expected.add(b);\n+        expected.add(a);\n+        expected.add(x);\n+\n+        assertEquals(expected, result);\n+        \n+        try {\n+            ListUtils.subtract(list, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch(final NullPointerException npe) {} // this is what we want\n+    }\n+\n+    public void testSubtractNullElement() {\n+        final List<String> list = new ArrayList<String>();\n+        list.add(a);\n+        list.add(null);\n+        list.add(null);\n+        list.add(x);\n+\n+        final List<String> sub = new ArrayList<String>();\n+        sub.add(null);\n+\n+        final List<String> result = ListUtils.subtract(list, sub);\n+        assertTrue(result.size() == 3);\n+        \n+        final List<String> expected = new ArrayList<String>();\n+        expected.add(a);\n+        expected.add(null);\n+        expected.add(x);\n+\n+        assertEquals(expected, result);\n+    }\n+\n+    /**\n+     * Tests the <code>indexOf</code> method in <code>ListUtils</code> class..\n+     */\n+    public void testIndexOf() {\n+        Predicate<String> testPredicate = EqualPredicate.equalPredicate(\"d\");\n+        int index = ListUtils.indexOf(fullList, testPredicate);\n+        assertEquals(d, fullList.get(index));\n+\n+        testPredicate = EqualPredicate.equalPredicate(\"de\");\n+        index = ListUtils.indexOf(fullList, testPredicate);\n+        assertEquals(index, -1);\n+        \n+        assertEquals(ListUtils.indexOf(null,testPredicate), -1);\n+        assertEquals(ListUtils.indexOf(fullList, null), -1);\n+    }\n+    \n+    public void testPartition() {\n+        final List<Integer> strings = new ArrayList<Integer>();\n+        for (int i = 0; i <= 6; i++) {\n+            strings.add(i);\n+        }\n+        \n+        final List<List<Integer>> partition = ListUtils.partition(strings, 3);\n+\n+        assertNotNull(partition);\n+        assertEquals(3, partition.size());\n+        assertEquals(1, partition.get(2).size());\n+        \n+        try {\n+            ListUtils.partition(null, 3);\n+            fail(\"failed to check for null argument\");\n+        } catch (final IllegalArgumentException e) {}\n+        \n+        try {\n+            ListUtils.partition(strings, 0);\n+            fail(\"failed to check for size argument\");\n+        } catch (final IllegalArgumentException e) {}\n+        \n+        try {\n+            ListUtils.partition(strings, -10);\n+            fail(\"failed to check for size argument\");\n+        } catch (final IllegalArgumentException e) {}\n+        \n+    }\n+    \n+    private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n+        public boolean evaluate(final Number input) {\n+            return input.intValue() == 2;\n+        }\n+    };\n+\n+    public void testSelect() {\n+        final List<Integer> list = new ArrayList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        // Ensure that the collection is the input type or a super type\n+        final List<Integer> output1 = ListUtils.select(list, EQUALS_TWO);\n+        final List<Number> output2 = ListUtils.<Number>select(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.select(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(1, output1.size());\n+        assertEquals(2, output2.iterator().next());\n+    }\n+\n+    public void testSelectRejected() {\n+        final List<Long> list = new ArrayList<Long>();\n+        list.add(1L);\n+        list.add(2L);\n+        list.add(3L);\n+        list.add(4L);\n+        final List<Long> output1 = ListUtils.selectRejected(list, EQUALS_TWO);\n+        final List<? extends Number> output2 = ListUtils.selectRejected(list, EQUALS_TWO);\n+        final HashSet<Number> output3 = CollectionUtils.selectRejected(list, EQUALS_TWO, new HashSet<Number>());\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output2));\n+        assertTrue(CollectionUtils.isEqualCollection(output1, output3));\n+        assertEquals(4, list.size());\n+        assertEquals(3, output1.size());\n+        assertTrue(output1.contains(1L));\n+        assertTrue(output1.contains(3L));\n+        assertTrue(output1.contains(4L));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/MapPerformance.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+//import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+//import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.map.Flat3Map;\n+\n+/** \n+ * <code>MapPerformanceTest</code> is designed to perform basic Map performance tests.\n+ * \n+ * @version $Id$\n+ */\n+public class MapPerformance {\n+\n+    /** The total number of runs for each test */    \n+    private static final int RUNS = 20000000;\n+    \n+    /**\n+     * Main method\n+     */\n+    public static void main(final String[] args) {\n+        testAll();\n+    }\n+    \n+    private static void testAll() {\n+        final Map<String, String> dummyMap = new DummyMap<String, String>();\n+        final Map<String, String> hashMap = new HashMap<String, String>();\n+//        hashMap.put(\"Alpha\", \"A\");\n+//        hashMap.put(\"Beta\", \"B\");\n+//        hashMap.put(\"Gamma\", \"C\");\n+//        hashMap.put(\"Delta\", \"D\");\n+        final Map<String, String> flatMap = new Flat3Map<String, String>(hashMap);\n+        System.out.println(flatMap);\n+//        Map<String, String> unmodHashMap = Collections.unmodifiableMap(new HashMap<String, String>(hashMap));\n+//        Map fastHashMap = new FastHashMap(hashMap);\n+//        Map<String, String> treeMap = new TreeMap<String, String>(hashMap);\n+//        Map linkedMap = new LinkedHashMap(hashMap);\n+//        Map syncMap = Collections.unmodifiableMap(new HashMap(hashMap));\n+//        Map bucketMap = new StaticBucketMap();\n+//        bucketMap.putAll(hashMap);\n+//        Map doubleMap = new DoubleOrderedMap(hashMap);\n+        \n+        // dummy is required as the VM seems to hotspot the first call to the\n+        // test method with the given type\n+        test(dummyMap,      \"         Dummy \");\n+        test(dummyMap,      \"         Dummy \");\n+        test(dummyMap,      \"         Dummy \");\n+        test(flatMap,       \"         Flat3 \");\n+        test(hashMap,       \"       HashMap \");\n+        \n+        test(flatMap,       \"         Flat3 \");\n+        test(flatMap,       \"         Flat3 \");\n+        test(flatMap,       \"         Flat3 \");\n+        \n+        test(hashMap,       \"       HashMap \");\n+        test(hashMap,       \"       HashMap \");\n+        test(hashMap,       \"       HashMap \");\n+        \n+//        test(treeMap,       \"       TreeMap \");\n+//        test(treeMap,       \"       TreeMap \");\n+//        test(treeMap,       \"       TreeMap \");\n+        \n+//        test(unmodHashMap,  \"Unmod(HashMap) \");\n+//        test(unmodHashMap,  \"Unmod(HashMap) \");\n+//        test(unmodHashMap,  \"Unmod(HashMap) \");\n+//        \n+//        test(syncMap,       \" Sync(HashMap) \");\n+//        test(syncMap,       \" Sync(HashMap) \");\n+//        test(syncMap,       \" Sync(HashMap) \");\n+//        \n+//        test(fastHashMap,   \"   FastHashMap \");\n+//        test(fastHashMap,   \"   FastHashMap \");\n+//        test(fastHashMap,   \"   FastHashMap \");\n+//        \n+//        test(seqMap,        \"    SeqHashMap \");\n+//        test(seqMap,        \"    SeqHashMap \");\n+//        test(seqMap,        \"    SeqHashMap \");\n+//        \n+//        test(linkedMap,     \" LinkedHashMap \");\n+//        test(linkedMap,     \" LinkedHashMap \");\n+//        test(linkedMap,     \" LinkedHashMap \");\n+//        \n+//        test(bucketMap,     \"     BucketMap \");\n+//        test(bucketMap,     \"     BucketMap \");\n+//        test(bucketMap,     \"     BucketMap \");\n+//        \n+//        test(doubleMap,     \"     DoubleMap \");\n+//        test(doubleMap,     \"     DoubleMap \");\n+//        test(doubleMap,     \"     DoubleMap \");\n+    }\n+\n+    private static void test(final Map<String, String> map, final String name) {\n+        long start = 0, end = 0;\n+//        int total = 0;\n+        start = System.currentTimeMillis();\n+        for (int i = RUNS; i > 0; i--) {\n+//            if (map.get(\"Alpha\") != null) total++;\n+//            if (map.get(\"Beta\") != null) total++;\n+//            if (map.get(\"Gamma\") != null) total++;\n+            map.put(\"Alpha\", \"A\");\n+            map.put(\"Beta\", \"B\");\n+            map.put(\"Beta\", \"C\");\n+            map.put(\"Gamma\", \"D\");\n+//            map.remove(\"Gamma\");\n+//            map.remove(\"Beta\");\n+//            map.remove(\"Alpha\");\n+            map.put(\"Delta\", \"E\");\n+            map.clear();\n+        }\n+        end = System.currentTimeMillis();\n+        System.out.println(name + (end - start));\n+    }\n+\n+    // ----------------------------------------------------------------------\n+\n+    private static class DummyMap<K, V> implements Map<K, V> {\n+        public void clear() {\n+        }\n+        public boolean containsKey(final Object key) {\n+            return false;\n+        }\n+        public boolean containsValue(final Object value) {\n+            return false;\n+        }\n+        public Set<Map.Entry<K, V>> entrySet() {\n+            return null;\n+        }\n+        public V get(final Object key) {\n+            return null;\n+        }\n+        public boolean isEmpty() {\n+            return false;\n+        }\n+        public Set<K> keySet() {\n+            return null;\n+        }\n+        public V put(final K key, final V value) {\n+            return null;\n+        }\n+        public void putAll(final Map<? extends K, ? extends V> t) {\n+        }\n+        public V remove(final Object key) {\n+            return null;\n+        }\n+        public int size() {\n+            return 0;\n+        }\n+        public Collection<V> values() {\n+            return null;\n+        }\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/MapUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.ListResourceBundle;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FactoryUtils;\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.IterableSortedMap;\n+import org.apache.commons.collections4.MapUtils;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+import org.apache.commons.collections4.keyvalue.DefaultKeyValue;\n+import org.apache.commons.collections4.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections4.map.HashedMap;\n+import org.apache.commons.collections4.map.LazyMap;\n+import org.apache.commons.collections4.map.PredicatedMap;\n+\n+/**\n+ * Tests for MapUtils.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class MapUtilsTest extends BulkTest {\n+\n+    public MapUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(MapUtilsTest.class);\n+    }\n+\n+    public Predicate<Object> getPredicate() {\n+        return new Predicate<Object>() {\n+            public boolean evaluate(final Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    public void testPredicatedMap() {\n+        final Predicate<Object> p = getPredicate();\n+        Map<Object, Object> map = MapUtils.predicatedMap(new HashMap<Object, Object>(), p, p);\n+        assertTrue(\"returned object should be a PredicatedMap\", map instanceof PredicatedMap);\n+        try {\n+            map = MapUtils.predicatedMap(null, p, p);\n+            fail(\"Expecting IllegalArgumentException for null map.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyMapFactory() {\n+        final Factory<Integer> factory = FactoryUtils.constantFactory(new Integer(5));\n+        Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), factory);\n+        assertTrue(map instanceof LazyMap);\n+        try {\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Factory<Object>) null);\n+            fail(\"Expecting IllegalArgumentException for null factory\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, factory);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n+        map = MapUtils.lazyMap(new HashMap<Object, Object>(), transformer);\n+        assertTrue(map instanceof LazyMap);\n+        try {\n+            map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Transformer<Object, Object>) null);\n+            fail(\"Expecting IllegalArgumentException for null transformer\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = MapUtils.lazyMap((Map<Object, Object>) null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLazyMapTransformer() {\n+        final Map<Object, Object> map = MapUtils.lazyMap(new HashMap<Object, Object>(), new Transformer<Object, Object>() {\n+            public Object transform(final Object mapKey) {\n+                if (mapKey instanceof String) {\n+                    return new Integer((String) mapKey);\n+                }\n+                return null;\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        final Integer i1 = (Integer) map.get(\"5\");\n+        assertEquals(new Integer(5), i1);\n+        assertEquals(1, map.size());\n+        final Integer i2 = (Integer) map.get(new String(new char[] {'5'}));\n+        assertEquals(new Integer(5), i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+    }\n+\n+    public void testInvertMap() {\n+        final Map<String, String> in = new HashMap<String, String>(5, 1);\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        final Set<String> inKeySet = new HashSet<String>(in.keySet());\n+        final Set<String> inValSet = new HashSet<String>(in.values());\n+\n+        final Map<String, String> out =  MapUtils.invertMap(in);\n+\n+        final Set<String> outKeySet = new HashSet<String>(out.keySet());\n+        final Set<String> outValSet = new HashSet<String>(out.values());\n+\n+        assertTrue( inKeySet.equals( outValSet ));\n+        assertTrue( inValSet.equals( outKeySet ));\n+\n+        assertEquals( \"1\", out.get(\"A\"));\n+        assertEquals( \"2\", out.get(\"B\"));\n+        assertEquals( \"3\", out.get(\"C\"));\n+        assertEquals( \"4\", out.get(\"D\"));\n+        assertEquals( \"5\", out.get(\"E\"));\n+    }\n+\n+    public void testPutAll_Map_array() {\n+        try {\n+            MapUtils.putAll(null, null);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+        try {\n+            MapUtils.putAll(null, new Object[0]);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+\n+        Map<String, String> test = MapUtils.putAll(new HashMap<String, String>(), new String[0]);\n+        assertEquals(0, test.size());\n+\n+        // sub array\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+            {\"RED\", \"#FF0000\"},\n+            {\"GREEN\", \"#00FF00\"},\n+            {\"BLUE\", \"#0000FF\"}\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                null,\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                {\"GREEN\"},\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+\n+        try {\n+            MapUtils.putAll(new HashMap<String, String>(), new String[][] {\n+                {\"RED\", \"#FF0000\"},\n+                {},\n+                {\"BLUE\", \"#0000FF\"}\n+            });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+\n+        // flat array\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n+            \"RED\", \"#FF0000\",\n+            \"GREEN\", \"#00FF00\",\n+            \"BLUE\", \"#0000FF\"\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        test = MapUtils.putAll(new HashMap<String, String>(), new String[] {\n+            \"RED\", \"#FF0000\",\n+            \"GREEN\", \"#00FF00\",\n+            \"BLUE\", \"#0000FF\",\n+            \"PURPLE\" // ignored\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        // map entry\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultMapEntry<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultMapEntry<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultMapEntry<String, String>(\"BLUE\", \"#0000FF\")\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+\n+        // key value\n+        test = MapUtils.putAll(new HashMap<String, String>(), new Object[] {\n+            new DefaultKeyValue<String, String>(\"RED\", \"#FF0000\"),\n+            new DefaultKeyValue<String, String>(\"GREEN\", \"#00FF00\"),\n+            new DefaultKeyValue<String, String>(\"BLUE\", \"#0000FF\")\n+        });\n+        assertEquals(true, test.containsKey(\"RED\"));\n+        assertEquals(\"#FF0000\", test.get(\"RED\"));\n+        assertEquals(true, test.containsKey(\"GREEN\"));\n+        assertEquals(\"#00FF00\", test.get(\"GREEN\"));\n+        assertEquals(true, test.containsKey(\"BLUE\"));\n+        assertEquals(\"#0000FF\", test.get(\"BLUE\"));\n+        assertEquals(3, test.size());\n+    }\n+\n+    public void testConvertResourceBundle() {\n+        final Map<String, String> in = new HashMap<String, String>( 5 , 1 );\n+        in.put(\"1\", \"A\");\n+        in.put(\"2\", \"B\");\n+        in.put(\"3\", \"C\");\n+        in.put(\"4\", \"D\");\n+        in.put(\"5\", \"E\");\n+\n+        final ResourceBundle b = new ListResourceBundle() {\n+            @Override\n+            public Object[][] getContents() {\n+                final Object[][] contents = new Object[ in.size() ][2];\n+                final Iterator<String> i = in.keySet().iterator();\n+                int n = 0;\n+                while ( i.hasNext() ) {\n+                    final Object key = i.next();\n+                    final Object val = in.get( key );\n+                    contents[ n ][ 0 ] = key;\n+                    contents[ n ][ 1 ] = val;\n+                    ++n;\n+                }\n+                return contents;\n+            }\n+        };\n+\n+        final Map<String, Object> out = MapUtils.toMap(b);\n+\n+        assertTrue( in.equals(out));\n+    }\n+\n+    public void testDebugAndVerbosePrintCasting() {\n+        final Map<Integer, String> inner = new HashMap<Integer, String>(2, 1);\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new HashMap<Integer, Object>(2, 1);\n+        outer.put(0, inner);\n+        outer.put(1, \"A\");\n+\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        try {\n+            MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        } catch (final ClassCastException e) {\n+            fail(\"No Casting should be occurring!\");\n+        }\n+    }\n+\n+    public void testDebugAndVerbosePrintNullMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        outPrint.println(LABEL + \" = \" + String.valueOf((Object) null));\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, LABEL, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"4 = null\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabel() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, String> map = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        map.put(2, \"B\");\n+        map.put(3, \"C\");\n+        map.put(4, null);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"4 = null\");\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        outPrint.println(\"null\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullLabelAndMap() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        outPrint.println(\"null\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, null);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullStream() {\n+        try {\n+            MapUtils.verbosePrint(null, \"Map\", new HashMap<Object, Object>());\n+            fail(\"Should generate NullPointerException\");\n+        } catch (final NullPointerException expected) {\n+        }\n+    }\n+\n+    public void testDebugPrintNullStream() {\n+        try {\n+            MapUtils.debugPrint(null, \"Map\", new HashMap<Object, Object>());\n+            fail(\"Should generate NullPointerException\");\n+        } catch (final NullPointerException expected) {\n+        }\n+    }\n+\n+    public void testDebugPrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A \" + String.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKey() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(null, \"A\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = A\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map) \" + HashMap.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKeyToMap1() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Map<?, ?>> map = new HashMap<Object, Map<?, ?>>();\n+        map.put(null, map);\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = (this Map)\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + HashMap.class.getName());\n+        outPrint.println(\"} \" + HashMap.class.getName());\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.debugPrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintNullKeyToMap2() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String INDENT = \"    \";\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        final Map<Object, Object> map2= new HashMap<Object, Object>();\n+        map.put(null, map2);\n+        map2.put(\"2\", \"B\");\n+\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"null = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+        final String EXPECTED_OUT = out.toString();\n+        out.reset();\n+\n+        MapUtils.verbosePrint(outPrint, null, map);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = C\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(INDENT + \"7 = (this Map)\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n+\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrint() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = C \" + String.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"7 = (this Map) \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+\n+        final Map<Integer, String> inner = new TreeMap<Integer, String>();  // treeMap guarantees order across JDKs for test\n+        inner.put(2, \"B\");\n+        inner.put(3, \"C\");\n+\n+        final Map<Integer, Object> outer = new TreeMap<Integer, Object>();\n+        outer.put(1, inner);\n+        outer.put(0, \"A\");\n+        outer.put(7, outer);\n+\n+        MapUtils.debugPrint(outPrint, \"Print Map\", outer);\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testVerbosePrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A\");\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B\");\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map)\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map)\");\n+        outPrint.println(INDENT + INDENT + \"}\");\n+        outPrint.println(INDENT + \"}\");\n+        outPrint.println(\"}\");\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.verbosePrint(outPrint, \"Print Map\", grandfather);\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    public void testDebugPrintSelfReference() {\n+        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        final PrintStream outPrint = new PrintStream(out);\n+\n+        final String LABEL = \"Print Map\";\n+        final String INDENT = \"    \";\n+\n+        final Map<Integer, Object> grandfather = new TreeMap<Integer, Object>();// treeMap guarantees order across JDKs for test\n+        final Map<Integer, Object> father = new TreeMap<Integer, Object>();\n+        final Map<Integer, Object> son    = new TreeMap<Integer, Object>();\n+\n+        grandfather.put(0, \"A\");\n+        grandfather.put(1, father);\n+\n+        father.put(2, \"B\");\n+        father.put(3, grandfather);\n+        father.put(4, son);\n+\n+        son.put(5, \"C\");\n+        son.put(6, grandfather);\n+        son.put(7, father);\n+\n+        outPrint.println(LABEL + \" = \");\n+        outPrint.println(\"{\");\n+        outPrint.println(INDENT + \"0 = A \" + String.class.getName());\n+        outPrint.println(INDENT + \"1 = \");\n+        outPrint.println(INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + \"2 = B \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + \"3 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"4 = \");\n+        outPrint.println(INDENT + INDENT + \"{\");\n+        outPrint.println(INDENT + INDENT + INDENT + \"5 = C \" + String.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"6 = (ancestor[1] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + INDENT + \"7 = (ancestor[0] Map) \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(INDENT + \"} \" + TreeMap.class.getName());\n+        outPrint.println(\"} \" + TreeMap.class.getName());\n+\n+        final String EXPECTED_OUT = out.toString();\n+\n+        out.reset();\n+        MapUtils.debugPrint(outPrint, \"Print Map\", grandfather);\n+\n+        assertEquals(EXPECTED_OUT, out.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    public void testEmptyIfNull() {\n+        assertTrue(MapUtils.emptyIfNull(null).isEmpty());\n+        \n+        final Map<Long, Long> map = new HashMap<Long, Long>();\n+        assertSame(map, MapUtils.emptyIfNull(map));\n+    }\n+    \n+    public void testIsEmptyWithEmptyMap() {\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        assertEquals(true, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNonEmptyMap() {\n+        final Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(false, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNull() {\n+        final Map<Object, Object> map = null;\n+        assertEquals(true, MapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithEmptyMap() {\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        assertEquals(false, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithNonEmptyMap() {\n+        final Map<String, String> map = new HashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(true, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testIsNotEmptyWithNull() {\n+        final Map<Object, Object> map = null;\n+        assertEquals(false, MapUtils.isNotEmpty(map));\n+    }\n+\n+    public void testPopulateMap() {\n+        // Setup Test Data\n+        final List<String> list = new ArrayList<String>();\n+        list.add(\"1\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+        list.add(\"7\");\n+        list.add(\"2\");\n+        list.add(\"4\");\n+        list.add(\"6\");\n+\n+        // Now test key transform population\n+        Map<Object, Object> map = new HashMap<Object, Object>();\n+        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(list.size(), map.size());\n+\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(true, map.containsKey(new Integer(list.get(i))));\n+            assertEquals(false, map.containsKey(list.get(i)));\n+            assertEquals(true, map.containsValue(list.get(i)));\n+            assertEquals(list.get(i), map.get(new Integer(list.get(i))));\n+        }\n+\n+        // Now test both Key-Value transform population\n+        map = new HashMap<Object, Object>();\n+        MapUtils.populateMap(map, list, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+\n+        assertEquals(list.size(), map.size());\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(true, map.containsKey(new Integer(list.get(i))));\n+            assertEquals(false, map.containsKey(list.get(i)));\n+            assertEquals(true, map.containsValue(new Integer(list.get(i))));\n+            assertEquals(new Integer(list.get(i)), map.get(new Integer(list.get(i))));\n+        }\n+    }\n+\n+    public void testIterableMap() {\n+        try {\n+            MapUtils.iterableMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (final IllegalArgumentException e) {\n+        }\n+        final HashMap<String, String> map = new HashMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        final IterableMap<String, String> iMap = MapUtils.iterableMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        final HashedMap<String, String> hMap = new HashedMap<String, String>(map);\n+        assertSame(hMap, MapUtils.iterableMap(hMap));\n+    }\n+\n+    public void testIterableSortedMap() {\n+        try {\n+            MapUtils.iterableSortedMap(null);\n+            fail(\"Should throw IllegalArgumentException\");\n+        } catch (final IllegalArgumentException e) {\n+        }\n+        final TreeMap<String, String> map = new TreeMap<String, String>();\n+        map.put(\"foo\", \"foov\");\n+        map.put(\"bar\", \"barv\");\n+        map.put(\"baz\", \"bazv\");\n+        final IterableSortedMap<String, String> iMap = MapUtils.iterableSortedMap(map);\n+        assertEquals(map, iMap);\n+        assertNotSame(map, iMap);\n+        assertSame(iMap, MapUtils.iterableMap(iMap));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/MockTestCase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.easymock.EasyMock;\n+import org.easymock.IExpectationSetters;\n+\n+/**\n+ * Provides utilities for making mock-based tests.  Most notable is the generic \"type-safe\"\n+ * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods\n+ * that call the respective methods on all created mock objects.\n+ */\n+public abstract class MockTestCase {\n+    private final List<Object> mockObjects = new ArrayList<Object>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T createMock(final Class<?> name) {\n+        final T mock = (T) EasyMock.createMock(name);\n+        return registerMock(mock);\n+    }\n+\n+    private <T> T registerMock(final T mock) {\n+        mockObjects.add(mock);\n+        return mock;\n+    }\n+\n+    protected <T> IExpectationSetters<T> expect(final T t) {\n+        return EasyMock.expect(t);\n+    }\n+\n+    protected final void replay() {\n+        for (final Object o : mockObjects) {\n+            EasyMock.replay(o);\n+        }\n+    }\n+\n+    protected final void verify() {\n+        for (final ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n+            try {\n+                EasyMock.verify(i.next());\n+            } catch (final AssertionError e) {\n+                throw new AssertionError(i.previousIndex() + 1 + \"\"\n+                        + e.getMessage());\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/PredicateUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate;\n+import static org.apache.commons.collections4.functors.TruePredicate.truePredicate;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.PredicateUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.functors.AbstractPredicateTest;\n+import org.apache.commons.collections4.functors.AllPredicate;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.functors.ExceptionPredicate;\n+import org.apache.commons.collections4.functors.FalsePredicate;\n+import org.apache.commons.collections4.functors.NotNullPredicate;\n+import org.apache.commons.collections4.functors.NullPredicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the PredicateUtils class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class PredicateUtilsTest extends AbstractPredicateTest {\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    public void tearDown() {\n+    }\n+\n+    // exceptionPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testExceptionPredicate() {\n+        assertNotNull(PredicateUtils.exceptionPredicate());\n+        assertSame(PredicateUtils.exceptionPredicate(), PredicateUtils.exceptionPredicate());\n+        try {\n+            PredicateUtils.exceptionPredicate().evaluate(null);\n+        } catch (final FunctorException ex) {\n+            try {\n+                PredicateUtils.exceptionPredicate().evaluate(cString);\n+            } catch (final FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // notNullPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testIsNotNullPredicate() {\n+        assertNotNull(PredicateUtils.notNullPredicate());\n+        assertSame(PredicateUtils.notNullPredicate(), PredicateUtils.notNullPredicate());\n+        assertEquals(false, PredicateUtils.notNullPredicate().evaluate(null));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cObject));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cString));\n+        assertEquals(true, PredicateUtils.notNullPredicate().evaluate(cInteger));\n+    }\n+\n+    // identityPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testIdentityPredicate() {\n+        assertSame(nullPredicate(), PredicateUtils.identityPredicate(null));\n+        assertNotNull(PredicateUtils.identityPredicate(new Integer(6)));\n+        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(null));\n+        assertEquals(false, PredicateUtils.<Object>identityPredicate(new Integer(6)).evaluate(cObject));\n+        assertEquals(false, PredicateUtils.<Object>identityPredicate(new Integer(6)).evaluate(cString));\n+        assertEquals(false, PredicateUtils.identityPredicate(new Integer(6)).evaluate(cInteger));\n+        assertEquals(true, PredicateUtils.identityPredicate(cInteger).evaluate(cInteger));\n+    }\n+\n+    // truePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testTruePredicate() {\n+        assertNotNull(TruePredicate.truePredicate());\n+        assertSame(TruePredicate.truePredicate(), TruePredicate.truePredicate());\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(null));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cObject));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cString));\n+        assertEquals(true, TruePredicate.truePredicate().evaluate(cInteger));\n+    }\n+\n+    // falsePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testFalsePredicate() {\n+        assertNotNull(FalsePredicate.falsePredicate());\n+        assertSame(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate());\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(null));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cObject));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cString));\n+        assertEquals(false, FalsePredicate.falsePredicate().evaluate(cInteger));\n+    }\n+\n+    // notPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNotPredicate() {\n+        assertNotNull(PredicateUtils.notPredicate(TruePredicate.truePredicate()));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cObject));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cString));\n+        assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cInteger));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testNotPredicateEx() {\n+        PredicateUtils.notPredicate(null);\n+    }\n+\n+    // andPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testAndPredicate() {\n+        assertEquals(true, PredicateUtils.andPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAndPredicateEx() {\n+        PredicateUtils.andPredicate(null, null);\n+    }\n+\n+    // allPredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testAllPredicate() {\n+        assertTrue(AllPredicate.allPredicate(new Predicate[] {}), null);\n+        assertEquals(true, AllPredicate.allPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, AllPredicate.allPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, AllPredicate.allPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(AllPredicate.allPredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(AllPredicate.allPredicate(coll), null);\n+        coll.clear();\n+        assertTrue(AllPredicate.allPredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx1() {\n+        AllPredicate.allPredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx2() {\n+        AllPredicate.<Object>allPredicate(new Predicate[] { null });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx3() {\n+        AllPredicate.allPredicate(new Predicate[] { null, null });\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx4() {\n+        AllPredicate.allPredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testAllPredicateEx5() {\n+        AllPredicate.allPredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAllPredicateEx6() {\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        AllPredicate.allPredicate(coll);\n+    }\n+\n+    // orPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testOrPredicate() {\n+        assertEquals(true, PredicateUtils.orPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.orPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testOrPredicateEx() {\n+        PredicateUtils.orPredicate(null, null);\n+    }\n+\n+    // anyPredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testAnyPredicate() {\n+        assertFalse(PredicateUtils.anyPredicate(new Predicate[] {}), null);\n+\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.anyPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.anyPredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, PredicateUtils.anyPredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(PredicateUtils.anyPredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(PredicateUtils.anyPredicate(coll), null);\n+        coll.clear();\n+        assertFalse(PredicateUtils.anyPredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx1() {\n+        PredicateUtils.anyPredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx2() {\n+        PredicateUtils.anyPredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx3() {\n+        PredicateUtils.anyPredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx4() {\n+        PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testAnyPredicateEx5() {\n+        PredicateUtils.anyPredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testAnyPredicateEx6() {\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.anyPredicate(coll);\n+    }\n+\n+    // eitherPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testEitherPredicate() {\n+        assertEquals(false, PredicateUtils.eitherPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.eitherPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testEitherPredicateEx() {\n+        PredicateUtils.eitherPredicate(null, null);\n+    }\n+\n+    // onePredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testOnePredicate() {\n+        assertFalse(PredicateUtils.onePredicate((Predicate<Object>[]) new Predicate[] {}), null);\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+            TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), TruePredicate.truePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        assertEquals(true, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate()}).evaluate(null));\n+        assertEquals(false, PredicateUtils.onePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()}).evaluate(null));\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(true, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(false, PredicateUtils.onePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertFalse(PredicateUtils.onePredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertTrue(PredicateUtils.onePredicate(coll), null);\n+        coll.clear();\n+        assertFalse(PredicateUtils.onePredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) \n+    public void testOnePredicateEx1() {\n+        PredicateUtils.onePredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx2() {\n+        PredicateUtils.onePredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx3() {\n+        PredicateUtils.onePredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx4() {\n+        PredicateUtils.onePredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testOnePredicateEx5() {\n+        PredicateUtils.onePredicate(Collections.EMPTY_LIST);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testOnePredicateEx6() {\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.onePredicate(coll);\n+    }\n+\n+    // neitherPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNeitherPredicate() {\n+        assertEquals(false, PredicateUtils.neitherPredicate(TruePredicate.truePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.neitherPredicate(TruePredicate.truePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+        assertEquals(false, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNeitherPredicateEx() {\n+        PredicateUtils.neitherPredicate(null, null);\n+    }\n+\n+    // nonePredicate\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test public void testNonePredicate() {\n+        assertTrue(PredicateUtils.nonePredicate(new Predicate[] {}), null);\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), TruePredicate.truePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                TruePredicate.truePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(false, PredicateUtils.nonePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), TruePredicate.truePredicate() }).evaluate(null));\n+        assertEquals(true, PredicateUtils.nonePredicate(new Predicate[] {\n+                FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate() }).evaluate(null));\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(TruePredicate.truePredicate());\n+        assertEquals(false, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertEquals(true, PredicateUtils.nonePredicate(coll).evaluate(null));\n+        coll.clear();\n+        coll.add(FalsePredicate.falsePredicate());\n+        assertTrue(PredicateUtils.nonePredicate(coll), null);\n+        coll.clear();\n+        coll.add(TruePredicate.truePredicate());\n+        assertFalse(PredicateUtils.nonePredicate(coll), null);\n+        coll.clear();\n+        assertTrue(PredicateUtils.nonePredicate(coll), null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx1() {\n+        PredicateUtils.nonePredicate((Predicate<Object>[]) null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx2() {\n+        PredicateUtils.nonePredicate(new Predicate[] {null});\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx3() {\n+        PredicateUtils.nonePredicate(new Predicate[] {null, null});\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx4() {\n+        PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null);\n+    }\n+\n+    @Test public void testNonePredicateEx5() {\n+        PredicateUtils.nonePredicate(Collections.<Predicate<Object>>emptyList());\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNonePredicateEx6() {\n+        final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n+        coll.add(null);\n+        coll.add(null);\n+        PredicateUtils.nonePredicate(coll);\n+    }\n+\n+    // instanceofPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInstanceOfPredicate() {\n+        assertNotNull(PredicateUtils.instanceofPredicate(String.class));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(null));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cObject));\n+        assertEquals(true, PredicateUtils.instanceofPredicate(String.class).evaluate(cString));\n+        assertEquals(false, PredicateUtils.instanceofPredicate(String.class).evaluate(cInteger));\n+    }\n+\n+    // uniquePredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testUniquePredicate() {\n+        final Predicate<Object> p = PredicateUtils.uniquePredicate();\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(new Object()));\n+        assertEquals(true, p.evaluate(cString));\n+        assertEquals(false, p.evaluate(cString));\n+        assertEquals(false, p.evaluate(cString));\n+    }\n+\n+    // asPredicate(Transformer)\n+    //------------------------------------------------------------------\n+\n+    @Test public void testAsPredicateTransformer() {\n+        assertEquals(false, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(false));\n+        assertEquals(true, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(true));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testAsPredicateTransformerEx1() {\n+        PredicateUtils.asPredicate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testAsPredicateTransformerEx2() {\n+        PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(null);\n+    }\n+\n+    // invokerPredicate\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInvokerPredicate() {\n+        final List<Object> list = new ArrayList<Object>();\n+        assertEquals(true, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n+        list.add(new Object());\n+        assertEquals(false, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testInvokerPredicateEx1() {\n+        PredicateUtils.invokerPredicate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicateEx2() {\n+        PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicateEx3() {\n+        PredicateUtils.invokerPredicate(\"noSuchMethod\").evaluate(new Object());\n+    }\n+\n+    // invokerPredicate2\n+    //------------------------------------------------------------------\n+\n+    @Test public void testInvokerPredicate2() {\n+        final List<String> list = new ArrayList<String>();\n+        assertEquals(false, PredicateUtils.invokerPredicate(\n+            \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n+        list.add(cString);\n+        assertEquals(true, PredicateUtils.invokerPredicate(\n+            \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testInvokerPredicate2Ex1() {\n+        PredicateUtils.invokerPredicate(null, null, null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicate2Ex2() {\n+        PredicateUtils.invokerPredicate(\"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(null);\n+    }\n+\n+    @Test(expected=FunctorException.class)\n+    public void testInvokerPredicate2Ex3() {\n+        PredicateUtils.invokerPredicate(\n+                \"noSuchMethod\", new Class[] {Object.class}, new Object[] {cString}).evaluate(new Object());\n+    }\n+\n+    // nullIsException\n+    //------------------------------------------------------------------\n+\n+    @Test(expected=FunctorException.class)\n+    public void testNullIsExceptionPredicate() {\n+        assertEquals(true, PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsExceptionPredicateEx1() {\n+        PredicateUtils.nullIsExceptionPredicate(null);\n+    }\n+\n+    // nullIsTrue\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNullIsTruePredicate() {\n+        assertEquals(true, PredicateUtils.nullIsTruePredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.nullIsTruePredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        assertEquals(false, PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsTruePredicateEx1() {\n+        PredicateUtils.nullIsTruePredicate(null);\n+    }\n+\n+    // nullIsFalse\n+    //------------------------------------------------------------------\n+\n+    @Test public void testNullIsFalsePredicate() {\n+        assertEquals(false, PredicateUtils.nullIsFalsePredicate(TruePredicate.truePredicate()).evaluate(null));\n+        assertEquals(true, PredicateUtils.nullIsFalsePredicate(TruePredicate.truePredicate()).evaluate(new Object()));\n+        assertEquals(false, PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testNullIsFalsePredicateEx1() {\n+        PredicateUtils.nullIsFalsePredicate(null);\n+    }\n+\n+    // transformed\n+    //------------------------------------------------------------------\n+\n+    @Test public void testTransformedPredicate() {\n+        assertEquals(true, PredicateUtils.transformedPredicate(\n+                TransformerUtils.nopTransformer(),\n+                TruePredicate.truePredicate()).evaluate(new Object()));\n+\n+        final Map<Object, Object> map = new HashMap<Object, Object>();\n+        map.put(Boolean.TRUE, \"Hello\");\n+        final Transformer<Object, Object> t = TransformerUtils.mapTransformer(map);\n+        final Predicate<Object> p = EqualPredicate.<Object>equalPredicate(\"Hello\");\n+        assertEquals(false, PredicateUtils.transformedPredicate(t, p).evaluate(null));\n+        assertEquals(true, PredicateUtils.transformedPredicate(t, p).evaluate(Boolean.TRUE));\n+        try {\n+            PredicateUtils.transformedPredicate(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Predicate singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    @Test public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                ExceptionPredicate.INSTANCE,\n+                FalsePredicate.INSTANCE,\n+                NotNullPredicate.INSTANCE,\n+                NullPredicate.INSTANCE,\n+                TruePredicate.INSTANCE\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return truePredicate();  //Just return something to satisfy super class.\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.SetUtils;\n+import org.apache.commons.collections4.set.PredicatedSet;\n+\n+/**\n+ * Tests for SetUtils.\n+ *\n+ * @version $Id$\n+ */\n+public class SetUtilsTest extends BulkTest {\n+\n+    public SetUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(SetUtilsTest.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public void testpredicatedSet() {\n+        final Predicate<Object> predicate = new Predicate<Object>() {\n+            public boolean evaluate(final Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+        Set<Object> set = SetUtils.predicatedSet(new HashSet<Object>(), predicate);\n+        assertTrue(\"returned object should be a PredicatedSet\", set instanceof PredicatedSet);\n+        try {\n+            set = SetUtils.predicatedSet(new HashSet<Object>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            set = SetUtils.predicatedSet(null, predicate);\n+            fail(\"Expecting IllegalArgumentException for null set.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testEmptyIfNull() {\n+        assertTrue(SetUtils.emptyIfNull(null).isEmpty());\n+        \n+        final Set<Long> set = new HashSet<Long>();\n+        assertSame(set, SetUtils.emptyIfNull(set));\n+    }\n+    \n+    public void testEquals() {\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        final Set<String> a = new HashSet<String>(data);\n+        final Set<String> b = new HashSet<String>(data);\n+\n+        assertEquals(true, a.equals(b));\n+        assertEquals(true, SetUtils.isEqualSet(a, b));\n+        a.clear();\n+        assertEquals(false, SetUtils.isEqualSet(a, b));\n+        assertEquals(false, SetUtils.isEqualSet(a, null));\n+        assertEquals(false, SetUtils.isEqualSet(null, b));\n+        assertEquals(true, SetUtils.isEqualSet(null, null));\n+    }\n+\n+    public void testHashCode() {\n+        final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n+\n+        final Set<String> a = new HashSet<String>(data);\n+        final Set<String> b = new HashSet<String>(data);\n+\n+        assertEquals(true, a.hashCode() == b.hashCode());\n+        assertEquals(true, a.hashCode() == SetUtils.hashCodeForSet(a));\n+        assertEquals(true, b.hashCode() == SetUtils.hashCodeForSet(b));\n+        assertEquals(true, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n+        a.clear();\n+        assertEquals(false, SetUtils.hashCodeForSet(a) == SetUtils.hashCodeForSet(b));\n+        assertEquals(0, SetUtils.hashCodeForSet(null));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Put;\n+import org.apache.commons.collections4.SplitMapUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.functors.NOPTransformer;\n+import org.apache.commons.collections4.map.HashedMap;\n+import org.apache.commons.collections4.splitmap.TransformedMap;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class SplitMapUtilsTest extends BulkTest {\n+    private Map<String, Integer> backingMap;\n+    private TransformedMap<String, String, String, Integer> transformedMap;\n+\n+    private final Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(final String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public SplitMapUtilsTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        backingMap = new HashMap<String, Integer>();\n+        transformedMap = TransformedMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n+                stringToInt);\n+        for (int i = 0; i < 10; i++) {\n+            transformedMap.put(String.valueOf(i), String.valueOf(i));\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testReadableMap() {\n+        final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);\n+\n+        // basic\n+        for (int i = 0; i < 10; i++) {\n+            assertFalse(map.containsValue(String.valueOf(i)));\n+            assertEquals(i, map.get(String.valueOf(i)).intValue());\n+        }\n+\n+        // mapIterator\n+        final MapIterator<String, Integer> it = map.mapIterator();\n+        while (it.hasNext()) {\n+            final String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(Integer.valueOf(k), it.getValue());\n+        }\n+\n+        // unmodifiable\n+        assertTrue(map instanceof Unmodifiable);\n+\n+        // check individual operations\n+        int sz = map.size();\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.clear();\n+            }\n+        });\n+\n+        assertEquals(sz, map.size());\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.put(\"foo\", 100);\n+            }\n+        });\n+\n+        final HashMap<String, Integer> m = new HashMap<String, Integer>();\n+        m.put(\"foo\", 100);\n+        m.put(\"bar\", 200);\n+        m.put(\"baz\", 300);\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.putAll(m);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        final IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // remove\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(i, map.remove(String.valueOf(i)).intValue());\n+            assertEquals(--sz, map.size());\n+        }\n+        assertTrue(map.isEmpty());\n+        assertSame(map, SplitMapUtils.readableMap(map));\n+    }\n+\n+    public void testAlreadyReadableMap() {\n+        final HashedMap<String, Integer> hashedMap = new HashedMap<String, Integer>();\n+        assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testWritableMap() {\n+        final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.get(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.entrySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.keySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.values();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.size();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.isEmpty();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsKey(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsValue(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.remove(null);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        final Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // put\n+        int sz = backingMap.size();\n+        assertFalse(backingMap.containsKey(\"foo\"));\n+        map.put(\"new\", \"66\");\n+        assertEquals(++sz, backingMap.size());\n+\n+        // putall\n+        final Map<String, String> more = new HashMap<String, String>();\n+        more.put(\"foo\", \"77\");\n+        more.put(\"bar\", \"88\");\n+        more.put(\"baz\", \"99\");\n+        map.putAll(more);\n+        assertEquals(sz + more.size(), backingMap.size());\n+\n+        // clear\n+        map.clear();\n+        assertTrue(backingMap.isEmpty());\n+        assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));\n+    }\n+\n+    public void testAlreadyWritableMap() {\n+        final HashedMap<String, String> hashedMap = new HashedMap<String, String>();\n+        assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));\n+    }\n+\n+    private void attemptGetOperation(final Runnable r) {\n+        attemptMapOperation(\"Put exposed as writable Map must not allow Get operations\", r);\n+    }\n+\n+    private void attemptPutOperation(final Runnable r) {\n+        attemptMapOperation(\"Get exposed as writable Map must not allow Put operations\", r);\n+    }\n+\n+    private void attemptMapOperation(final String s, final Runnable r) {\n+        try {\n+            r.run();\n+            fail(s);\n+        } catch (final UnsupportedOperationException e) {\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/TestUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import static org.junit.Assert.assertSame;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+\n+public final class TestUtils {\n+\n+    private TestUtils() {}\n+\n+    /**\n+     * Asserts that deserialization of the object returns the same object as the\n+     * one that was serialized. Object is first serialized, then deserialized\n+     * and finally check is preformed to see if original and deserialized\n+     * object references are the same.\n+     * <p>\n+     * This method is especially good for testing singletone pattern on classes\n+     * that support serialization.\n+     *\n+     * @param msg the identifying message for the <code>AssertionError</code>.\n+     * @param o object that will be tested.\n+     * @see #assertSameAfterSerialization(Object)\n+     */\n+    public static void assertSameAfterSerialization(final String msg, final Object o) {\n+        try {\n+            // write object to byte buffer\n+            final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            final ObjectOutputStream oos = new ObjectOutputStream(baos);\n+            oos.writeObject(o);\n+            oos.close();\n+\n+            // read same object from byte buffer\n+            final InputStream is = new ByteArrayInputStream(baos.toByteArray());\n+            final ObjectInputStream ois = new ObjectInputStream(is);\n+            final Object object = ois.readObject();\n+            ois.close();\n+\n+            // assert that original object and deserialized objects are the same\n+            assertSame(msg, o, object);\n+        } catch (final IOException e) {\n+            // should never happen\n+            throw new RuntimeException(e);\n+        } catch (final ClassNotFoundException e) {\n+            // should never happen\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Asserts that deserialization of the object returns the same object as the\n+     * one that was serialized.\n+     * <p>\n+     * Effect of method call is the same as:\n+     * <code>assertSameAfterSerialization(null, o)</code>.\n+     *\n+     * @param o object that will be tested.\n+     * @see #assertSameAfterSerialization(String, Object)\n+     */\n+    public static void assertSameAfterSerialization(final Object o) {\n+        assertSameAfterSerialization(null, o);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/TransformerUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.ClosureUtils;\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FactoryUtils;\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.functors.CloneTransformer;\n+import org.apache.commons.collections4.functors.ConstantTransformer;\n+import org.apache.commons.collections4.functors.EqualPredicate;\n+import org.apache.commons.collections4.functors.ExceptionTransformer;\n+import org.apache.commons.collections4.functors.FalsePredicate;\n+import org.apache.commons.collections4.functors.NOPTransformer;\n+import org.apache.commons.collections4.functors.StringValueTransformer;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Tests the TransformerUtils class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformerUtilsTest extends junit.framework.TestCase {\n+\n+    private static final Object cObject = new Object();\n+    private static final Object cString = \"Hello\";\n+    private static final Object cInteger = new Integer(6);\n+\n+    /**\n+     * Construct\n+     */\n+    public TransformerUtilsTest(final String name) {\n+        super(name);\n+    }\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() {\n+    }\n+\n+    // exceptionTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testExceptionTransformer() {\n+        assertNotNull(TransformerUtils.exceptionTransformer());\n+        assertSame(TransformerUtils.exceptionTransformer(), TransformerUtils.exceptionTransformer());\n+        try {\n+            TransformerUtils.exceptionTransformer().transform(null);\n+        } catch (final FunctorException ex) {\n+            try {\n+                TransformerUtils.exceptionTransformer().transform(cString);\n+            } catch (final FunctorException ex2) {\n+                return;\n+            }\n+        }\n+        fail();\n+    }\n+\n+    // nullTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testNullTransformer() {\n+        assertNotNull(TransformerUtils.nullTransformer());\n+        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(null));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cObject));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cString));\n+        assertEquals(null, TransformerUtils.nullTransformer().transform(cInteger));\n+    }\n+\n+    // nopTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testNopTransformer() {\n+        assertNotNull(TransformerUtils.nullTransformer());\n+        assertSame(TransformerUtils.nullTransformer(), TransformerUtils.nullTransformer());\n+        assertEquals(null, TransformerUtils.nopTransformer().transform(null));\n+        assertEquals(cObject, TransformerUtils.nopTransformer().transform(cObject));\n+        assertEquals(cString, TransformerUtils.nopTransformer().transform(cString));\n+        assertEquals(cInteger, TransformerUtils.nopTransformer().transform(cInteger));\n+    }\n+\n+    // constantTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testConstantTransformer() {\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(null));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cObject));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cString));\n+        assertEquals(cObject, TransformerUtils.constantTransformer(cObject).transform(cInteger));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.constantTransformer(null));\n+    }\n+\n+    // cloneTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testCloneTransformer() {\n+        assertEquals(null, TransformerUtils.cloneTransformer().transform(null));\n+        assertEquals(cString, TransformerUtils.cloneTransformer().transform(cString));\n+        assertEquals(cInteger, TransformerUtils.cloneTransformer().transform(cInteger));\n+        try {\n+            assertEquals(cObject, TransformerUtils.cloneTransformer().transform(cObject));\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // mapTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testMapTransformer() {\n+        final Map<Object, Integer> map = new HashMap<Object, Integer>();\n+        map.put(null, 0);\n+        map.put(cObject, 1);\n+        map.put(cString, 2);\n+        assertEquals(new Integer(0), TransformerUtils.mapTransformer(map).transform(null));\n+        assertEquals(new Integer(1), TransformerUtils.mapTransformer(map).transform(cObject));\n+        assertEquals(new Integer(2), TransformerUtils.mapTransformer(map).transform(cString));\n+        assertEquals(null, TransformerUtils.mapTransformer(map).transform(cInteger));\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.mapTransformer(null));\n+    }\n+\n+    // commandTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testExecutorTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(null));\n+        assertEquals(cObject, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cObject));\n+        assertEquals(cString, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cString));\n+        assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Closure<Object>) null);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // predicateTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testPredicateTransformer() {\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(null));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cObject));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cString));\n+        assertEquals(Boolean.TRUE, TransformerUtils.asTransformer(TruePredicate.truePredicate()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Predicate<Object>) null);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // factoryTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testFactoryTransformer() {\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(null));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cObject));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cString));\n+        assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));\n+        try {\n+            TransformerUtils.asTransformer((Factory<Object>) null);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    // chainedTransformer\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testChainedTransformer() {\n+        final Transformer<Object, Object> a = TransformerUtils.<Object, Object>constantTransformer(\"A\");\n+        final Transformer<Object, Object> b = TransformerUtils.constantTransformer((Object) \"B\");\n+\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(b, a).transform(null));\n+        assertEquals(\"B\", TransformerUtils.chainedTransformer(a, b).transform(null));\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(new Transformer[] { b, a }).transform(null));\n+        Collection<Transformer<Object, Object>> coll = new ArrayList<Transformer<Object, Object>>();\n+        coll.add(b);\n+        coll.add(a);\n+        assertEquals(\"A\", TransformerUtils.chainedTransformer(coll).transform(null));\n+\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(new Transformer[0]));\n+        assertSame(NOPTransformer.INSTANCE, TransformerUtils.chainedTransformer(Collections.<Transformer<Object, Object>>emptyList()));\n+\n+        try {\n+            TransformerUtils.chainedTransformer(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer((Transformer[]) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.chainedTransformer(new Transformer[] {null, null});\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            coll = new ArrayList<Transformer<Object, Object>>();\n+            coll.add(null);\n+            coll.add(null);\n+            TransformerUtils.chainedTransformer(coll);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // switchTransformer\n+    //------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSwitchTransformer() {\n+        final Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        final Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        final Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(TruePredicate.truePredicate(), a, b).transform(null));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(FalsePredicate.falsePredicate(), a, b).transform(null));\n+\n+        assertEquals(null, TransformerUtils.<Object, String>switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }).transform(\"THERE\"));\n+\n+        assertEquals(\"C\", TransformerUtils.switchTransformer(\n+            new Predicate[] { EqualPredicate.equalPredicate(\"HELLO\"), EqualPredicate.equalPredicate(\"THERE\") },\n+            new Transformer[] { a, b }, c).transform(\"WELL\"));\n+\n+        Map<Predicate<String>, Transformer<String, String>> map = new HashMap<Predicate<String>, Transformer<String,String>>();\n+        map.put(EqualPredicate.equalPredicate(\"HELLO\"), a);\n+        map.put(EqualPredicate.equalPredicate(\"THERE\"), b);\n+        assertEquals(null, TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchTransformer(map).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchTransformer(map).transform(\"THERE\"));\n+        map.put(null, c);\n+        assertEquals(\"C\", TransformerUtils.switchTransformer(map).transform(\"WELL\"));\n+\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new Predicate[0], new Transformer[0]));\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(new HashMap<Predicate<Object>, Transformer<Object, Object>>()));\n+        map = new HashMap<Predicate<String>, Transformer<String, String>>();\n+        map.put(null, null);\n+        assertEquals(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchTransformer(map));\n+\n+        try {\n+            TransformerUtils.switchTransformer(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer((Map<Predicate<Object>, Transformer<Object, Object>>) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.switchTransformer(\n+                    new Predicate[] { TruePredicate.truePredicate() },\n+                    new Transformer[] { a, b });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // switchMapTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testSwitchMapTransformer() {\n+        final Transformer<String, String> a = TransformerUtils.constantTransformer(\"A\");\n+        final Transformer<String, String> b = TransformerUtils.constantTransformer(\"B\");\n+        final Transformer<String, String> c = TransformerUtils.constantTransformer(\"C\");\n+\n+        Map<String, Transformer<String, String>> map = new HashMap<String, Transformer<String,String>>();\n+        map.put(\"HELLO\", a);\n+        map.put(\"THERE\", b);\n+        assertEquals(null, TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n+        assertEquals(\"A\", TransformerUtils.switchMapTransformer(map).transform(\"HELLO\"));\n+        assertEquals(\"B\", TransformerUtils.switchMapTransformer(map).transform(\"THERE\"));\n+        map.put(null, c);\n+        assertEquals(\"C\", TransformerUtils.switchMapTransformer(map).transform(\"WELL\"));\n+\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(new HashMap<Object, Transformer<Object, Object>>()));\n+        map = new HashMap<String, Transformer<String, String>>();\n+        map.put(null, null);\n+        assertSame(ConstantTransformer.NULL_INSTANCE, TransformerUtils.switchMapTransformer(map));\n+\n+        try {\n+            TransformerUtils.switchMapTransformer(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // invokerTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testInvokerTransformer() {\n+        final List<Object> list = new ArrayList<Object>();\n+        assertEquals(new Integer(0), TransformerUtils.invokerTransformer(\"size\").transform(list));\n+        list.add(new Object());\n+        assertEquals(new Integer(1), TransformerUtils.invokerTransformer(\"size\").transform(list));\n+        assertEquals(null, TransformerUtils.invokerTransformer(\"size\").transform(null));\n+\n+        try {\n+            TransformerUtils.invokerTransformer(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object());\n+            fail();\n+        } catch (final FunctorException ex) {}\n+    }\n+\n+    // invokerTransformer2\n+    //------------------------------------------------------------------\n+\n+    public void testInvokerTransformer2() {\n+        final List<Object> list = new ArrayList<Object>();\n+        assertEquals(Boolean.FALSE, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n+        list.add(cString);\n+        assertEquals(Boolean.TRUE, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(list));\n+        assertEquals(null, TransformerUtils.invokerTransformer(\"contains\",\n+                new Class[] { Object.class }, new Object[] { cString }).transform(null));\n+\n+        try {\n+            TransformerUtils.invokerTransformer(null, null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"noSuchMethod\", new Class[] { Object.class },\n+                    new Object[] { cString }).transform(new Object());\n+            fail();\n+        } catch (final FunctorException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", null, new Object[] { cString });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", new Class[] { Object.class }, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.invokerTransformer(\"badArgs\", new Class[] {}, new Object[] { cString });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    // stringValueTransformer\n+    //------------------------------------------------------------------\n+\n+    public void testStringValueTransformer() {\n+        assertNotNull( \"StringValueTransformer should NEVER return a null value.\",\n+           TransformerUtils.stringValueTransformer().transform(null));\n+        assertEquals( \"StringValueTransformer should return \\\"null\\\" when given a null argument.\", \"null\",\n+            TransformerUtils.stringValueTransformer().transform(null));\n+        assertEquals( \"StringValueTransformer should return toString value\", \"6\",\n+            TransformerUtils.stringValueTransformer().transform(new Integer(6)));\n+    }\n+\n+    // instantiateFactory\n+    //------------------------------------------------------------------\n+\n+    public void testInstantiateTransformerNull() {\n+        try {\n+            TransformerUtils.instantiateTransformer(null, new Object[] { \"str\" });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            TransformerUtils.instantiateTransformer(new Class[] {}, new Object[] { \"str\" });\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+\n+        Transformer<Class<?>, Object> trans = TransformerUtils.instantiateTransformer(new Class[] { Long.class }, new Object[] { null });\n+        try {\n+            trans.transform(String.class);\n+            fail();\n+        } catch (final FunctorException ex) {}\n+\n+        trans = TransformerUtils.instantiateTransformer();\n+        assertEquals(\"\", trans.transform(String.class));\n+\n+        trans = TransformerUtils.instantiateTransformer(new Class[] { Long.TYPE }, new Object[] { new Long(1000L) });\n+        assertEquals(new Date(1000L), trans.transform(Date.class));\n+    }\n+\n+    // misc tests\n+    //------------------------------------------------------------------\n+\n+    /**\n+     * Test that all Transformer singletones hold singleton pattern in\n+     * serialization/deserialization process.\n+     */\n+    public void testSingletonPatternInSerialization() {\n+        final Object[] singletones = new Object[] {\n+                CloneTransformer.INSTANCE,\n+                ExceptionTransformer.INSTANCE,\n+                NOPTransformer.INSTANCE,\n+                StringValueTransformer.INSTANCE,\n+        };\n+\n+        for (final Object original : singletones) {\n+            TestUtils.assertSameAfterSerialization(\n+                    \"Singletone patern broken for \" + original.getClass(),\n+                    original\n+            );\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.bag.HashBag;\n+\n+/**\n+ * Abstract test class for {@link org.apache.commons.collections4.Bag Bag} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject} method.\n+ * <p>\n+ * If your bag fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your bag fails.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractBagTest<T> extends AbstractObjectTest {\n+//  TODO: this class should really extend from TestCollection, but the bag\n+//  implementations currently do not conform to the Collection interface.  Once\n+//  those are fixed or at least a strategy is made for resolving the issue, this\n+//  can be changed back to extend TestCollection instead.\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return a new, empty bag to used for testing.\n+     * \n+     * @return the bag to be tested\n+     */\n+    @Override\n+    public abstract Bag<T> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBagAdd() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        assertTrue(\"Should contain 'A'\", bag.contains(\"A\"));\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n+        bag.add((T) \"A\");\n+        assertTrue(\"Should contain 'A'\", bag.contains(\"A\"));\n+        assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n+        bag.add((T) \"B\");\n+        assertTrue(bag.contains(\"A\"));\n+        assertTrue(bag.contains(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBagEqualsSelf() {\n+        final Bag<T> bag = makeObject();\n+        assertTrue(bag.equals(bag));\n+        bag.add((T) \"elt\");\n+        assertTrue(bag.equals(bag));\n+        bag.add((T) \"elt\"); // again\n+        assertTrue(bag.equals(bag));\n+        bag.add((T) \"elt2\");\n+        assertTrue(bag.equals(bag));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n+        bag.remove(\"A\");\n+        assertEquals(\"Should have count of 0\", 0, bag.getCount(\"A\"));\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have count of 4\", 4, bag.getCount(\"A\"));\n+        bag.remove(\"A\", 0);\n+        assertEquals(\"Should have count of 4\", 4, bag.getCount(\"A\"));\n+        bag.remove(\"A\", 2);\n+        assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n+        bag.remove(\"A\");\n+        assertEquals(\"Should have count of 0\", 0, bag.getCount(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\", 2);\n+        assertEquals(\"Should have count of 2\", 2, bag.getCount(\"A\"));\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        assertEquals(\"Should have count of 4\", 4, bag.size());\n+        final List<String> delete = new ArrayList<String>();\n+        delete.add(\"A\");\n+        delete.add(\"B\");\n+        bag.removeAll(delete);\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"A\"));\n+        assertEquals(\"Should have count of 0\", 0, bag.getCount(\"B\"));\n+        assertEquals(\"Should have count of 1\", 1, bag.getCount(\"C\"));\n+        assertEquals(\"Should have count of 2\", 2, bag.size());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testContains() {\n+        final Bag<T> bag = makeObject();\n+        \n+        assertEquals(\"Bag does not have at least 1 'A'\", false, bag.contains(\"A\"));\n+        assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n+        \n+        bag.add((T) \"A\");  // bag 1A\n+        assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n+        assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n+        \n+        bag.add((T) \"A\");  // bag 2A\n+        assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n+        assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n+        \n+        bag.add((T) \"B\");  // bag 2A,1B\n+        assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n+        assertEquals(\"Bag has at least 1 'B'\", true, bag.contains(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        final Bag<T> bag = makeObject();\n+        final List<String> known = new ArrayList<String>();\n+        final List<String> known1A = new ArrayList<String>();\n+        known1A.add(\"A\");\n+        final List<String> known2A = new ArrayList<String>();\n+        known2A.add(\"A\");\n+        known2A.add(\"A\");\n+        final List<String> known1B = new ArrayList<String>();\n+        known1B.add(\"B\");\n+        final List<String> known1A1B = new ArrayList<String>();\n+        known1A1B.add(\"A\");\n+        known1A1B.add(\"B\");\n+        \n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag does not containsAll of 1 'A'\", false, bag.containsAll(known1A));\n+        assertEquals(\"Bag does not containsAll of 2 'A'\", false, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"A\");  // bag 1A\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag does not containsAll of 2 'A'\", false, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"A\");  // bag 2A\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"A\");  // bag 3A\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n+        assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n+        assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n+        \n+        bag.add((T) \"B\");  // bag 3A1B\n+        assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n+        assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n+        assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n+        assertEquals(\"Bag containsAll of 1 'B'\", true, bag.containsAll(known1B));\n+        assertEquals(\"Bag containsAll of 1 'A' 1 'B'\", true, bag.containsAll(known1A1B));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        final Bag<T> bag = makeObject();\n+        assertEquals(\"Should have 0 total items\", 0, bag.size());\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have 1 total items\", 1, bag.size());\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have 2 total items\", 2, bag.size());\n+        bag.add((T) \"A\");\n+        assertEquals(\"Should have 3 total items\", 3, bag.size());\n+        bag.add((T) \"B\");\n+        assertEquals(\"Should have 4 total items\", 4, bag.size());\n+        bag.add((T) \"B\");\n+        assertEquals(\"Should have 5 total items\", 5, bag.size());\n+        bag.remove(\"A\", 2);\n+        assertEquals(\"Should have 1 'A'\", 1, bag.getCount(\"A\"));\n+        assertEquals(\"Should have 3 total items\", 3, bag.size());\n+        bag.remove(\"B\");\n+        assertEquals(\"Should have 1 total item\", 1, bag.size());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final List<String> retains = new ArrayList<String>();\n+        retains.add(\"B\");\n+        retains.add(\"C\");\n+        bag.retainAll(retains);\n+        assertEquals(\"Should have 2 total items\", 2, bag.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        assertEquals(\"Bag should have 3 items\", 3, bag.size());\n+        final Iterator<T> i = bag.iterator();\n+    \n+        boolean foundA = false;\n+        while (i.hasNext()) {\n+            final String element = (String) i.next();\n+            // ignore the first A, remove the second via Iterator.remove()\n+            if (element.equals(\"A\")) {\n+                if (foundA == false) {\n+                    foundA = true;\n+                } else {\n+                    i.remove();\n+                }\n+            }\n+        }\n+    \n+        assertTrue(\"Bag should still contain 'A'\", bag.contains(\"A\"));\n+        assertEquals(\"Bag should have 2 items\", 2, bag.size());\n+        assertEquals(\"Bag should have 1 'A'\", 1, bag.getCount(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorFail() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        final Iterator<T> it = bag.iterator();\n+        it.next();\n+        bag.remove(\"A\");\n+        try {\n+            it.next();\n+            fail(\"Should throw ConcurrentModificationException\");\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorFailNoMore() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        final Iterator<T> it = bag.iterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        try {\n+            it.next();\n+            fail(\"Should throw NoSuchElementException\");\n+        } catch (final NoSuchElementException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorFailDoubleRemove() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        final Iterator<T> it = bag.iterator();\n+        it.next();\n+        it.next();\n+        assertEquals(3, bag.size());\n+        it.remove();\n+        assertEquals(2, bag.size());\n+        try {\n+            it.remove();\n+            fail(\"Should throw IllegalStateException\");\n+        } catch (final IllegalStateException ex) {\n+            // expected\n+        }\n+        assertEquals(2, bag.size());\n+        it.next();\n+        it.remove();\n+        assertEquals(1, bag.size());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testIteratorRemoveProtectsInvariants() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        assertEquals(2, bag.size());\n+        final Iterator<T> it = bag.iterator();\n+        assertEquals(\"A\", it.next());\n+        assertEquals(true, it.hasNext());\n+        it.remove();\n+        assertEquals(1, bag.size());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(\"A\", it.next());\n+        assertEquals(false, it.hasNext());\n+        it.remove();\n+        assertEquals(0, bag.size());\n+        assertEquals(false, it.hasNext());\n+        \n+        final Iterator<T> it2 = bag.iterator();\n+        assertEquals(false, it2.hasNext());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testToArray() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final Object[] array = bag.toArray();\n+        int a = 0, b = 0, c = 0;\n+        for (final Object element : array) {\n+            a += element.equals(\"A\") ? 1 : 0;\n+            b += element.equals(\"B\") ? 1 : 0;\n+            c += element.equals(\"C\") ? 1 : 0;\n+        }\n+        assertEquals(2, a);\n+        assertEquals(2, b);\n+        assertEquals(1, c);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToArrayPopulate() {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final String[] array = bag.toArray(new String[0]);\n+        int a = 0, b = 0, c = 0;\n+        for (final String element : array) {\n+            a += element.equals(\"A\") ? 1 : 0;\n+            b += element.equals(\"B\") ? 1 : 0;\n+            c += element.equals(\"C\") ? 1 : 0;\n+        }\n+        assertEquals(2, a);\n+        assertEquals(2, b);\n+        assertEquals(1, c);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals() {\n+        final Bag<T> bag = makeObject();\n+        final Bag<T> bag2 = makeObject();\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        assertEquals(false, bag.equals(bag2));\n+        bag2.add((T) \"A\");\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"C\");\n+        assertEquals(true, bag.equals(bag2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsHashBag() {\n+        final Bag<T> bag = makeObject();\n+        final Bag<T> bag2 = new HashBag<T>();\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        assertEquals(false, bag.equals(bag2));\n+        bag2.add((T) \"A\");\n+        assertEquals(true, bag.equals(bag2));\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"C\");\n+        assertEquals(true, bag.equals(bag2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashCode() {\n+        final Bag<T> bag = makeObject();\n+        final Bag<T> bag2 = makeObject();\n+        assertEquals(0, bag.hashCode());\n+        assertEquals(0, bag2.hashCode());\n+        assertEquals(bag.hashCode(), bag2.hashCode());\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"A\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"B\");\n+        bag2.add((T) \"C\");\n+        assertEquals(bag.hashCode(), bag2.hashCode());\n+        \n+        int total = 0;\n+        total += \"A\".hashCode() ^ 2;\n+        total += \"B\".hashCode() ^ 2;\n+        total += \"C\".hashCode() ^ 1;\n+        assertEquals(total, bag.hashCode());\n+        assertEquals(total, bag2.hashCode());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEmptyBagSerialization() throws IOException, ClassNotFoundException {\n+        final Bag<T> bag = makeObject();\n+        if (!(bag instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n+        \n+        final byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n+        final Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Bag should be empty\",0, bag.size());\n+        assertEquals(\"Bag should be empty\",0, bag2.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullBagSerialization() throws IOException, ClassNotFoundException {\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        final int size = bag.size();\n+        if (!(bag instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n+        \n+        final byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n+        final Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Bag should be same size\", size, bag.size());\n+        assertEquals(\"Bag should be same size\", size, bag2.size());\n+    }\n+\n+    /**\n+     * Skip the serialized cannonical tests for now.\n+     *\n+     * @return true\n+     *\n+     * TODO: store a new serialized object on the disk.\n+     */\n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Bag\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        final Bag<T> bag = makeObject();\n+        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n+            assertTrue(\"Bag is empty\",bag2.size()  == 0);\n+            assertEquals(bag, bag2);\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Bag\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullBagCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        final Bag<T> bag = makeObject();\n+        bag.add((T) \"A\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"C\");\n+        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n+            assertEquals(\"Bag is the right size\",bag.size(), bag2.size());\n+            assertEquals(bag, bag2);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import org.apache.commons.collections4.SortedBag;\n+\n+/**\n+ * Abstract test class for\n+ * {@link org.apache.commons.collections4.SortedBag SortedBag}\n+ * methods and contracts.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedBagTest<T> extends AbstractBagTest<T> {\n+\n+    public AbstractSortedBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBag<T> makeObject();\n+\n+    // TODO: Add the SortedBag tests!\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/HashBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.bag.HashBag;\n+\n+/**\n+ * Extension of {@link AbstractBagTest} for exercising the {@link HashBag}\n+ * implementation.\n+ *\n+ * @version $Id$\n+ */\n+public class HashBagTest<T> extends AbstractBagTest<T> {\n+    \n+    public HashBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Bag<T> makeObject() {\n+        return new HashBag<T>();\n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeObject();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/HashBag.emptyCollection.version4.obj\");\n+//        bag = makeObject();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/HashBag.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.bag.PredicatedBag;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractBagTest} for exercising the {@link PredicatedBag}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedBagTest<T> extends AbstractBagTest<T> {\n+\n+    public PredicatedBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected Predicate<T> stringPredicate() {\n+        return new Predicate<T>() {\n+            public boolean evaluate(final T o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n+\n+    protected Bag<T> decorateBag(final HashBag<T> bag, final Predicate<T> predicate) {\n+        return PredicatedBag.predicatedBag(bag, predicate);\n+    }\n+\n+    @Override\n+    public Bag<T> makeObject() {\n+        return decorateBag(new HashBag<T>(), truePredicate);\n+    }\n+\n+    protected Bag<T> makeTestBag() {\n+        return decorateBag(new HashBag<T>(), stringPredicate());\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testlegalAddRemove() {\n+        final Bag<T> bag = makeTestBag();\n+        assertEquals(0, bag.size());\n+        final T[] els = (T[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"1\" };\n+        for (int i = 0; i < els.length; i++) {\n+            bag.add(els[i]);\n+            assertEquals(i + 1, bag.size());\n+            assertEquals(true, bag.contains(els[i]));\n+        }\n+        Set<T> set = ((PredicatedBag<T>) bag).uniqueSet();\n+        assertTrue(\"Unique set contains the first element\",set.contains(els[0]));\n+        assertEquals(true, bag.remove(els[0]));\n+        set = ((PredicatedBag<T>) bag).uniqueSet();\n+        assertTrue(\"Unique set now does not contain the first element\",\n+            !set.contains(els[0]));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        final Bag<T> bag = makeTestBag();\n+        final Integer i = new Integer(3);\n+        try {\n+            bag.add((T) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !bag.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalDecorate() {\n+        final HashBag<Object> elements = new HashBag<Object>();\n+        elements.add(\"one\");\n+        elements.add(\"two\");\n+        elements.add(new Integer(3));\n+        elements.add(\"four\");\n+        try {\n+            decorateBag((HashBag<T>) elements, stringPredicate());\n+            fail(\"Bag contains an element that should fail the predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            decorateBag(new HashBag<T>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeObject();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedBag.emptyCollection.version4.obj\");\n+//        bag = makeObject();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedBag.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.SortedBag;\n+import org.apache.commons.collections4.bag.PredicatedSortedBag;\n+import org.apache.commons.collections4.bag.TreeBag;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractSortedBagTest} for exercising the {@link PredicatedSortedBag}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSortedBagTest<T> extends AbstractSortedBagTest<T> {\n+\n+    private final SortedBag<T> nullBag = null;\n+\n+    public PredicatedSortedBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected Predicate<T> stringPredicate() {\n+        return new Predicate<T>() {\n+            public boolean evaluate(final T o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+    protected Predicate<T> truePredicate = TruePredicate.<T>truePredicate();\n+\n+    protected SortedBag<T> decorateBag(final SortedBag<T> bag, final Predicate<T> predicate) {\n+        return PredicatedSortedBag.predicatedSortedBag(bag, predicate);\n+    }\n+\n+    @Override\n+    public SortedBag<T> makeObject() {\n+        return decorateBag(new TreeBag<T>(), truePredicate);\n+    }\n+\n+    protected SortedBag<T> makeTestBag() {\n+        return decorateBag(new TreeBag<T>(), stringPredicate());\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    public void testDecorate() {\n+        final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n+        ((PredicatedSortedBag<T>) bag).decorated();\n+        try {\n+            decorateBag(new TreeBag<T>(), null);\n+            fail(\"Expecting IllegalArgumentException for null predicate\");\n+        } catch (final IllegalArgumentException e) {}\n+        try {\n+            decorateBag(nullBag, stringPredicate());\n+            fail(\"Expecting IllegalArgumentException for null bag\");\n+        } catch (final IllegalArgumentException e) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSortOrder() {\n+        final SortedBag<T> bag = decorateBag(new TreeBag<T>(), stringPredicate());\n+        final String one = \"one\";\n+        final String two = \"two\";\n+        final String three = \"three\";\n+        bag.add((T) one);\n+        bag.add((T) two);\n+        bag.add((T) three);\n+        assertEquals(\"first element\", bag.first(), one);\n+        assertEquals(\"last element\", bag.last(), two);\n+        final Comparator<? super T> c = bag.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        org.apache.commons.collections4.Bag bag = makeObject();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedSortedBag.emptyCollection.version4.obj\");\n+//        bag = makeObject();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/PredicatedSortedBag.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.bag.TransformedBag;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractBagTest} for exercising the {@link TransformedBag}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedBagTest<T> extends AbstractBagTest<T> {\n+\n+    public TransformedBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Bag<T> makeObject() {\n+        return TransformedBag.transformingBag(new HashBag<T>(),\n+                (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedBag() {\n+        //T had better be Object!\n+        final Bag<T> bag = TransformedBag.transformingBag(new HashBag<T>(),\n+                (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, bag.size());\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            bag.add((T) els[i]);\n+            assertEquals(i + 1, bag.size());\n+            assertEquals(true, bag.contains(new Integer((String) els[i])));\n+            assertEquals(false, bag.contains(els[i]));\n+        }\n+\n+        assertEquals(false, bag.remove(els[0]));\n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedBag_decorateTransform() {\n+        final Bag<T> originalBag = new HashBag<T>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalBag.add((T) el);\n+        }\n+        final Bag<T> bag = TransformedBag.transformedBag(originalBag,\n+                (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, bag.size());\n+        for (final Object el : els) {\n+            assertEquals(true, bag.contains(new Integer((String) el)));\n+            assertEquals(false, bag.contains(el));\n+        }\n+        \n+        assertEquals(false, bag.remove(els[0]));\n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeObject();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedBag.emptyCollection.version4.obj\");\n+//        bag = makeObject();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedBag.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.SortedBag;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.bag.TransformedBag;\n+import org.apache.commons.collections4.bag.TransformedSortedBag;\n+import org.apache.commons.collections4.bag.TreeBag;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractSortedBagTest} for exercising the {@link TransformedSortedBag}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSortedBagTest<T> extends AbstractSortedBagTest<T> {\n+\n+    public TransformedSortedBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedBag<T> makeObject() {\n+        return TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedBag() {\n+        final SortedBag<T> bag = TransformedSortedBag.transformingSortedBag(new TreeBag<T>(), (Transformer<T, T>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, bag.size());\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            bag.add((T) els[i]);\n+            assertEquals(i + 1, bag.size());\n+            assertEquals(true, bag.contains(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+\n+    }\n+\n+    public void testTransformedBag_decorateTransform() {\n+        final Bag<Object> originalBag = new TreeBag<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalBag.add(el);\n+        }\n+        final Bag<?> bag = TransformedBag.transformedBag(originalBag, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, bag.size());\n+        for (final Object el : els) {\n+            assertEquals(true, bag.contains(new Integer((String) el)));\n+        }\n+        \n+        assertEquals(true, bag.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeObject();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedSortedBag.emptyCollection.version4.obj\");\n+//        bag = makeObject();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TransformedSortedBag.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bag;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.SortedBag;\n+import org.apache.commons.collections4.bag.TreeBag;\n+\n+/**\n+ * Extension of {@link AbstractBagTest} for exercising the {@link TreeBag}\n+ * implementation.\n+ *\n+ * @version $Id$\n+ */\n+public class TreeBagTest<T> extends AbstractSortedBagTest<T> {\n+\n+    public TreeBagTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public SortedBag<T> makeObject() {\n+        return new TreeBag<T>();\n+    }\n+\n+   // TODO: Generics (for example... is this even needed?)\n+   public void testCollections265() {\n+       final Bag<Object> bag = new TreeBag<Object>();\n+       try {\n+           bag.add(new Object());\n+           fail(\"IllegalArgumentException expected\");\n+       } catch(final IllegalArgumentException iae) {\n+           // expected;\n+       }\n+   }\n+   \n+    @SuppressWarnings(\"unchecked\")\n+    public SortedBag<T> setupBag() {\n+        final SortedBag<T> bag = makeObject();\n+        bag.add((T) \"C\");\n+        bag.add((T) \"A\");\n+        bag.add((T) \"B\");\n+        bag.add((T) \"D\");\n+        return bag;\n+    }\n+\n+    public void testOrdering() {\n+        final Bag<T> bag = setupBag();\n+        assertEquals(\"Should get elements in correct order\", \"A\", bag.toArray()[0]);\n+        assertEquals(\"Should get elements in correct order\", \"B\", bag.toArray()[1]);\n+        assertEquals(\"Should get elements in correct order\", \"C\", bag.toArray()[2]);\n+        assertEquals(\"Should get first key\", \"A\", ((SortedBag<T>) bag).first());\n+        assertEquals(\"Should get last key\", \"D\", ((SortedBag<T>) bag).last());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Bag bag = makeObject();\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TreeBag.emptyCollection.version4.obj\");\n+//        bag = makeObject();\n+//        bag.add(\"A\");\n+//        bag.add(\"A\");\n+//        bag.add(\"B\");\n+//        bag.add(\"B\");\n+//        bag.add(\"C\");\n+//        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/TreeBag.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;\n+import org.apache.commons.collections4.map.AbstractIterableMapTest;\n+\n+/**\n+ * Abstract test class for {@link BidiMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractBidiMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public AbstractBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractBidiMapTest() {\n+        super(\"Inverse\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to create a full <code>BidiMap</code> other than the default.\n+     *\n+     * @return a full <code>BidiMap</code> implementation.\n+     */\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        return (BidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    /**\n+     * Override to return the empty BidiMap.\n+     */\n+    @Override\n+    public abstract BidiMap<K, V> makeObject();\n+\n+    /**\n+     * Override to indicate to AbstractTestMap this is a BidiMap.\n+     */\n+    @Override\n+    public boolean isAllowDuplicateValues() {\n+        return false;\n+    }\n+\n+    /**\n+     * Override as DualHashBidiMap didn't exist until version 3.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    // BidiPut\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBidiPut() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n+\n+        final BidiMap<K, V> map = makeObject();\n+        final BidiMap<V, K> inverse = map.inverseBidiMap();\n+        assertEquals(0, map.size());\n+        assertEquals(map.size(), inverse.size());\n+\n+        map.put((K) \"A\", (V) \"B\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"B\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"B\"));\n+\n+        map.put((K) \"A\", (V) \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"C\"));\n+\n+        map.put((K) \"B\", (V) \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"B\"));\n+        assertEquals(\"B\", inverse.get(\"C\"));\n+\n+        map.put((K) \"E\", (V) \"F\");\n+        assertEquals(2, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"F\", map.get(\"E\"));\n+        assertEquals(\"E\", inverse.get(\"F\"));\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * <p>\n+     * This implementation checks the inverse map as well.\n+     */\n+    @Override\n+    public void verify() {\n+        verifyInverse();\n+        super.verify();\n+    }\n+\n+    public void verifyInverse() {\n+        assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());\n+        final Map<K, V> map1 = new HashMap<K, V>(map);\n+        final Map<V, K> map2 = new HashMap<V, K>(((BidiMap<K, V>) map).inverseBidiMap());\n+        final Set<K> keys1 = map1.keySet();\n+        final Set<V> keys2 = map2.keySet();\n+        final Collection<V> values1 = map1.values();\n+        final Collection<K> values2 = map2.values();\n+        assertEquals(true, keys1.containsAll(values2));\n+        assertEquals(true, values2.containsAll(keys1));\n+        assertEquals(true, values1.containsAll(keys2));\n+        assertEquals(true, keys2.containsAll(values1));\n+    }\n+\n+    // testGetKey\n+    //-----------------------------------------------------------------------\n+    public void testBidiGetKey() {\n+        doTestGetKey(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+    }\n+\n+    public void testBidiGetKeyInverse() {\n+        doTestGetKey(\n+            makeFullMap().inverseBidiMap(),\n+            getSampleValues()[0],\n+            getSampleKeys()[0]);\n+    }\n+\n+    private final void doTestGetKey(final BidiMap<?, ?> map, final Object key, final Object value) {\n+        assertEquals(\"Value not found for key.\", value, map.get(key));\n+        assertEquals(\"Key not found for value.\", key, map.getKey(value));\n+    }\n+\n+    // testInverse\n+    //-----------------------------------------------------------------------\n+    public void testBidiInverse() {\n+        final BidiMap<K, V> map = makeFullMap();\n+        final BidiMap<V, K> inverseMap = map.inverseBidiMap();\n+\n+        assertSame(\n+            \"Inverse of inverse is not equal to original.\",\n+            map,\n+            inverseMap.inverseBidiMap());\n+\n+        assertEquals(\n+            \"Value not found for key.\",\n+            getSampleKeys()[0],\n+            inverseMap.get(getSampleValues()[0]));\n+\n+        assertEquals(\n+            \"Key not found for value.\",\n+            getSampleValues()[0],\n+            inverseMap.getKey(getSampleKeys()[0]));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiModifyEntrySet() {\n+        if (isSetValueSupported() == false) {\n+            return;\n+        }\n+\n+        modifyEntrySet(makeFullMap());\n+        modifyEntrySet(makeFullMap().inverseBidiMap());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private final <T> void modifyEntrySet(final BidiMap<?, T> map) {\n+        // Gets first entry\n+        final Map.Entry<?, T> entry = map.entrySet().iterator().next();\n+\n+        // Gets key and value\n+        final Object key = entry.getKey();\n+        final Object oldValue = entry.getValue();\n+\n+        // Sets new value\n+        final Object newValue = \"newValue\";\n+        entry.setValue((T) newValue);\n+\n+        assertEquals(\n+            \"Modifying entrySet did not affect underlying Map.\",\n+            newValue,\n+            map.get(key));\n+\n+        assertNull(\n+            \"Modifying entrySet did not affect inverse Map.\",\n+            map.getKey(oldValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClear() {\n+        if (isRemoveSupported() == false) {\n+            try {\n+                makeFullMap().clear();\n+                fail();\n+            } catch(final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        BidiMap<?, ?> map = makeFullMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+        // Tests clear on inverse\n+        map = makeFullMap().inverseBidiMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemove() {\n+        if (isRemoveSupported() == false) {\n+            try {\n+                makeFullMap().remove(getSampleKeys()[0]);\n+                fail();\n+            } catch(final UnsupportedOperationException ex) {}\n+            try {\n+                makeFullMap().removeValue(getSampleValues()[0]);\n+                fail();\n+            } catch(final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        remove(makeFullMap(), getSampleKeys()[0]);\n+        remove(makeFullMap().inverseBidiMap(), getSampleValues()[0]);\n+\n+        removeValue(makeFullMap(), getSampleValues()[0]);\n+        removeValue(makeFullMap().inverseBidiMap(), getSampleKeys()[0]);\n+\n+        assertEquals(null, makeFullMap().removeValue(\"NotPresent\"));\n+    }\n+\n+    private final void remove(final BidiMap<?, ?> map, final Object key) {\n+        final Object value = map.remove(key);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    private final void removeValue(final BidiMap<?, ?> map, final Object value) {\n+        final Object key = map.removeValue(value);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiKeySetValuesOrder() {\n+        resetFull();\n+        final Iterator<K> keys = map.keySet().iterator();\n+        final Iterator<V> values = map.values().iterator();\n+        for (; keys.hasNext() && values.hasNext();) {\n+            final K key = keys.next();\n+            final V value = values.next();\n+            assertSame(map.get(key), value);\n+        }\n+        assertEquals(false, keys.hasNext());\n+        assertEquals(false, values.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByKeySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+        removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n+    }\n+\n+    private final void removeByKeySet(final BidiMap<?, ?> map, final Object key, final Object value) {\n+        map.keySet().remove(key);\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByEntrySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+        removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n+    }\n+\n+    private final void removeByEntrySet(final BidiMap<?, ?> map, final Object key, final Object value) {\n+        final Map<Object, Object> temp = new HashMap<Object, Object>();\n+        temp.put(key, value);\n+        map.entrySet().remove(temp.entrySet().iterator().next());\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public BidiMap<K, V> getMap() {\n+        return (BidiMap<K, V>) super.getMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestBidiMapEntrySet();\n+    }\n+\n+    public class TestBidiMapEntrySet extends TestMapEntrySet {\n+        public TestBidiMapEntrySet() {\n+            super();\n+        }\n+        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n+            final K key1 = getSampleKeys()[0];\n+            final K key2 = getSampleKeys()[1];\n+            final V newValue1 = getNewSampleValues()[0];\n+            final V newValue2 = getNewSampleValues()[1];\n+\n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n+            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestBidiMapEntrySet.this.getCollection().iterator();\n+            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n+            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n+            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            TestBidiMapEntrySet.this.verify();\n+\n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (final UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            // these checked in superclass\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+\n+            // at this point\n+            // key1=newValue1, key2=newValue2\n+            try {\n+                entry2.setValue(newValue1);  // should remove key1\n+            } catch (final IllegalArgumentException ex) {\n+                return;  // simplest way of dealing with tricky situation\n+            }\n+            entryConfirmed2.setValue(newValue1);\n+            AbstractBidiMapTest.this.getConfirmed().remove(key1);\n+            assertEquals(newValue1, entry2.getValue());\n+            assertEquals(true, AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractBidiMapTest.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));\n+            assertEquals(false, AbstractBidiMapTest.this.getMap().containsKey(key1));\n+            assertEquals(false, AbstractBidiMapTest.this.getMap().containsValue(newValue2));\n+            TestBidiMapEntrySet.this.verify();\n+\n+            // check for ConcurrentModification\n+            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+            if (isRemoveSupported()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    public BulkTest bulkTestInverseMap() {\n+        return new TestInverseBidiMap(this);\n+    }\n+\n+    public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {\n+        final AbstractBidiMapTest<K, V> main;\n+\n+        public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {\n+            super();\n+            this.main = main;\n+        }\n+\n+        @Override\n+        public BidiMap<V, K> makeObject() {\n+            return main.makeObject().inverseBidiMap();\n+        }\n+\n+        @Override\n+        public BidiMap<V, K> makeFullMap() {\n+            return main.makeFullMap().inverseBidiMap();\n+        }\n+\n+        @Override\n+        public V[] getSampleKeys() {\n+            return main.getSampleValues();\n+        }\n+        @Override\n+        public K[] getSampleValues() {\n+            return main.getSampleKeys();\n+        }\n+\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+\n+        @Override\n+        public boolean isSetValueSupported() {\n+            return main.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestBidiMapIterator() {\n+        return new TestBidiMapIterator();\n+    }\n+\n+    public class TestBidiMapIterator extends AbstractMapIteratorTest<K, V> {\n+        public TestBidiMapIterator() {\n+            super(\"TestBidiMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractBidiMapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractBidiMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractBidiMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public BidiMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractBidiMapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractBidiMapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractBidiMapTest.this.verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiMapIteratorSet() {\n+        final V newValue1 = getOtherValues()[0];\n+        final V newValue2 = getOtherValues()[1];\n+\n+        resetFull();\n+        final BidiMap<K, V> bidi = getMap();\n+        final MapIterator<K, V> it = bidi.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        final K key1 = it.next();\n+\n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+                fail();\n+            } catch (final UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+\n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+\n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+\n+        final K key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, bidi.containsKey(key2));\n+        assertEquals(true, bidi.containsValue(newValue2));\n+        assertEquals(newValue2, bidi.get(key2));\n+        verify();\n+\n+        // at this point\n+        // key1=newValue1, key2=newValue2\n+        try {\n+            it.setValue(newValue1);  // should remove key1\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n+            return;  // simplest way of dealing with tricky situation\n+        }\n+        confirmed.put(key2, newValue1);\n+        AbstractBidiMapTest.this.getConfirmed().remove(key1);\n+        assertEquals(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(it.getKey()));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(it.getKey()));\n+        assertEquals(false, bidi.containsKey(key1));\n+        assertEquals(false, bidi.containsValue(newValue2));\n+        verify();\n+\n+        // check for ConcurrentModification\n+        it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+        if (isRemoveSupported()) {\n+            it.remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecoratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.bidimap.AbstractOrderedBidiMapDecorator;\n+import org.apache.commons.collections4.bidimap.DualTreeBidiMap;\n+\n+/**\n+ * Test class for AbstractOrderedBidiMapDecorator.\n+ *\n+ * @version $Id$\n+ */\n+public class AbstractOrderedBidiMapDecoratorTest<K, V>\n+        extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    public AbstractOrderedBidiMapDecoratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return new TestOrderedBidiMap<K, V>();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSetValueSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Simple class to actually test.\n+     */\n+    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {\n+\n+        private TestOrderedBidiMap<V, K> inverse = null;\n+\n+        public TestOrderedBidiMap() {\n+            super(new DualTreeBidiMap<K, V>());\n+        }\n+\n+        public TestOrderedBidiMap(final OrderedBidiMap<K, V> map) {\n+            super(map);\n+        }\n+\n+        @Override\n+        public OrderedBidiMap<V, K> inverseBidiMap() {\n+            if (inverse == null) {\n+                inverse = new TestOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n+                inverse.inverse = this;\n+            }\n+            return inverse;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;\n+\n+/**\n+ * Abstract test class for {@link OrderedBidiMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractOrderedBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public AbstractOrderedBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractOrderedBidiMapTest() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        try {\n+            bidi.firstKey();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+\n+        resetFull();\n+        bidi = getMap();\n+        final K confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, bidi.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        try {\n+            bidi.lastKey();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedLast = null;\n+        for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, bidi.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;\n+        assertEquals(null, bidi.nextKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.nextKey(null)); // this is allowed too\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+\n+        resetFull();\n+        bidi = (OrderedBidiMap<K, V>) map;\n+        final Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            final K confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.nextKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.nextKey(null);\n+                fail();\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+    }\n+\n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        assertEquals(null, bidi.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.previousKey(null)); // this is allowed too\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+\n+        resetFull();\n+        bidi = getMap();\n+        final List<K> list = new ArrayList<K>(confirmed.keySet());\n+        Collections.reverse(list);\n+        final Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            final K confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.previousKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.previousKey(null);\n+                fail();\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestOrderedMapIterator() {\n+        return new TestBidiOrderedMapIterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> getMap() {\n+        return (OrderedBidiMap<K, V>) super.getMap();\n+    }\n+\n+    public class TestBidiOrderedMapIterator extends AbstractMapIteratorTest<K, V> {\n+        public TestBidiOrderedMapIterator() {\n+            super(\"TestBidiOrderedMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractOrderedBidiMapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractOrderedBidiMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractOrderedBidiMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public Map<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedBidiMapTest.this.map;\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedBidiMapTest.this.confirmed;\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractOrderedBidiMapTest.this.verify();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.SortedBidiMap;\n+import org.apache.commons.collections4.map.AbstractSortedMapTest;\n+\n+/**\n+ * Abstract test class for {@link SortedBidiMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    protected List<K> sortedKeys;\n+    protected List<V> sortedValues = new ArrayList<V>();\n+    protected SortedSet<V> sortedNewValues = new TreeSet<V>();\n+\n+    public AbstractSortedBidiMapTest(final String testName) {\n+        super(testName);\n+        sortedKeys = getAsList(getSampleKeys());\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+\n+        final Map<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+\n+        sortedNewValues.addAll(this.<V> getAsList(getNewSampleValues()));\n+    }\n+\n+//    public AbstractTestSortedBidiMap() {\n+//        super();\n+//        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n+//        Collections.sort(sortedKeys);\n+//        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+//\n+//        Map map = new TreeMap();\n+//        for (int i = 0; i < getSampleKeys().length; i++) {\n+//            map.put(getSampleValues()[i], getSampleKeys()[i]);\n+//        }\n+//        sortedValues.addAll(map.values());\n+//        sortedValues = Collections.unmodifiableList(sortedValues);\n+//\n+//        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBidiMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        return (SortedBidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiHeadMapContains() {\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K toKey = it.next();\n+        final K second = it.next();\n+        final V firstValue = sm.get(first);\n+        final V secondValue = sm.get(second);\n+\n+        final SortedMap<K, V> head = sm.headMap(toKey);\n+        assertEquals(1, head.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, head.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(false, head.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(false, head.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByHeadMap() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final V firstValue = sm.get(first);\n+        final V secondValue = sm.get(second);\n+        final V toKeyValue = sm.get(toKey);\n+\n+        final SortedMap<K, V> sub = sm.headMap(toKey);\n+        final int size = sm.size();\n+        assertEquals(2, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+\n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMap() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.headMap(toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        final V firstValue = sub.remove(first);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        final V secondValue = sub.remove(second);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMapEntrySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.headMap(toKey);\n+        final Set<Map.Entry<K, V>> set = sub.entrySet();\n+        assertEquals(2, sub.size());\n+        assertEquals(2, set.size());\n+\n+        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiTailMapContains() {\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K fromKey = it.next();\n+        final K second = it.next();\n+        final V firstValue = sm.get(first);\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V secondValue = sm.get(second);\n+\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        assertEquals(sm.size() - 1, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByTailMap() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K first = it.next();\n+        final K fromKey = it.next();\n+        final K second = it.next();\n+\n+        final V firstValue = sm.get(first);\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V secondValue = sm.get(second);\n+\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        final int size = sm.size();\n+        assertEquals(size - 3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(3, sm.size());\n+        assertEquals(3, sm.inverseBidiMap().size());\n+\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMap() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        final Object firstValue = sub.remove(first);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        final Object secondValue = sub.remove(second);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMapEntrySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        final Set<Map.Entry<K, V>> set = sub.entrySet();\n+        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiSubMapContains() {\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        final K first = it.next();\n+        final K fromKey = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+        final K third = it.next();\n+        final V firstValue = sm.get(first);\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V secondValue = sm.get(second);\n+        final V thirdValue = sm.get(third);\n+\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+        assertEquals(true, sm.containsKey(third));\n+        assertEquals(false, sub.containsKey(third));\n+        assertEquals(true, sm.containsValue(thirdValue));\n+        assertEquals(false, sub.containsValue(thirdValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearBySubMap() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final V fromKeyValue = sm.get(fromKey);\n+        final V firstValue = sm.get(first);\n+        final V secondValue = sm.get(second);\n+        final V toKeyValue = sm.get(toKey);\n+\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        final int size = sm.size();\n+        assertEquals(3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 3, sm.size());\n+        assertEquals(size - 3, sm.inverseBidiMap().size());\n+\n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+\n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMap() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        final V firstValue = sub.remove(first);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        final V secondValue = sub.remove(second);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMapEntrySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+\n+        // extra test as other tests get complex\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+        final Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        final K fromKey = it.next();\n+        final K first = it.next();\n+        final K second = it.next();\n+        final K toKey = it.next();\n+\n+        final int size = sm.size();\n+        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        final Set<Map.Entry<K, V>> set = sub.entrySet();\n+        assertEquals(3, set.size());\n+        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestHeadMap() {\n+        return new AbstractSortedMapTest.TestHeadMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new AbstractSortedMapTest.TestTailMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new AbstractSortedMapTest.TestSubMap<K, V>(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.bidimap.DualHashBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class DualHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualHashBidiMapTest.class);\n+    }\n+\n+    public DualHashBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualHashBidiMap<K, V> makeObject() {\n+        return new DualHashBidiMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] { \"DualHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualHashBidiMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualHashBidiMap.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.bidimap.DualLinkedHashBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class DualLinkedHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualLinkedHashBidiMapTest.class);\n+    }\n+\n+    public DualLinkedHashBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualLinkedHashBidiMap<K, V> makeObject() {\n+        return new DualLinkedHashBidiMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] { \"DualLinkedHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualLinkedHashBidiMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualLinkedHashBidiMap.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.SortedBidiMap;\n+import org.apache.commons.collections4.bidimap.DualTreeBidiMap;\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+import org.apache.commons.collections4.comparators.ReverseComparator;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class DualTreeBidiMap2Test<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualTreeBidiMap2Test.class);\n+    }\n+\n+    public DualTreeBidiMap2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>(\n+                new ReverseComparator<K>(ComparableComparator.<K> comparableComparator()),\n+                new ReverseComparator<V>(ComparableComparator.<V> comparableComparator()));\n+    }\n+\n+    @Override\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n+    }\n+\n+    public void testComparator() {\n+        resetEmpty();\n+        final SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n+        assertNotNull(bidi.comparator());\n+        assertTrue(bidi.comparator() instanceof ReverseComparator);\n+    }\n+\n+    public void testComparator2() {\n+        final DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<String, Integer>(\n+                String.CASE_INSENSITIVE_ORDER, null);\n+        dtbm.put(\"two\", 0);\n+        dtbm.put(\"one\", 1);\n+        assertEquals(\"one\", dtbm.firstKey());\n+        assertEquals(\"two\", dtbm.lastKey());\n+        \n+    }\n+\n+    public void testSerializeDeserializeCheckComparator() throws Exception {\n+        final SortedBidiMap<?, ?> obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            final Object dest = in.readObject();\n+            in.close();\n+\n+            final SortedBidiMap<?,?> bidi = (SortedBidiMap<?,?>) dest;\n+            assertNotNull(obj.comparator());\n+            assertNotNull(bidi.comparator());\n+            assertTrue(bidi.comparator() instanceof ReverseComparator);\n+        }\n+    }\n+\n+    private static class IntegerComparator implements Comparator<Integer>, java.io.Serializable{\n+        private static final long serialVersionUID = 1L;\n+        public int compare(final Integer o1, final Integer o2) {\n+            return o1.compareTo(o2);\n+        }\n+    }\n+\n+    public void testCollections364() throws Exception {\n+        final DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<String, Integer>(\n+                String.CASE_INSENSITIVE_ORDER, new IntegerComparator());\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(original);\n+        out.close();\n+\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        @SuppressWarnings(\"unchecked\")\n+        final DualTreeBidiMap<String, Integer> deserialised = (DualTreeBidiMap<String, Integer>) in.readObject();\n+        in.close();\n+\n+        assertNotNull(original.comparator());\n+        assertNotNull(deserialised.comparator());\n+        assertEquals(original.comparator().getClass(), deserialised.comparator().getClass());\n+        assertEquals(original.valueComparator().getClass(), deserialised.valueComparator().getClass());\n+    }\n+\n+    public void testSortOrder() throws Exception {\n+        final SortedBidiMap<K, V> sm = makeFullMap();\n+\n+        // Sort by the comparator used in the makeEmptyBidiMap() method\n+        List<K> newSortedKeys = getAsList(getSampleKeys());\n+        Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n+        newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n+\n+        final Iterator<K> mapIter = sm.keySet().iterator();\n+        final Iterator<K> expectedIter = newSortedKeys.iterator();\n+        while (expectedIter.hasNext()) {\n+            final K expectedKey = expectedIter.next();\n+            final K mapKey = mapIter.next();\n+            assertNotNull(\"key in sorted list may not be null\", expectedKey);\n+            assertNotNull(\"key in map may not be null\", mapKey);\n+            assertEquals(\"key from sorted list and map must be equal\", expectedKey, mapKey);\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.Test2\";\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"DualTreeBidiMap2Test.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.Test2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.Test2.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.bidimap.DualTreeBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class DualTreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualTreeBidiMapTest.class);\n+    }\n+\n+    public DualTreeBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"DualTreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualTreeBidiMap.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.bidimap.TreeBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class TreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TreeBidiMapTest.class);\n+    }\n+\n+    public TreeBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeObject() {\n+        return new TreeBidiMap<K, V>();\n+    }\n+    \n+    @Override\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public boolean isSetValueSupported() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/TreeBidiMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/TreeBidiMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.bidimap.DualHashBidiMap;\n+import org.apache.commons.collections4.bidimap.UnmodifiableBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableBidiMapTest.class);\n+    }\n+\n+    public UnmodifiableBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeObject() {\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        final BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"UnmodifiableBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections4.BidiMap;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.OrderedBidiMap;\n+import org.apache.commons.collections4.bidimap.TreeBidiMap;\n+import org.apache.commons.collections4.bidimap.UnmodifiableOrderedBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableOrderedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableOrderedBidiMapTest.class);\n+    }\n+\n+    public UnmodifiableOrderedBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        final OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"UnmodifiableOrderedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.bidimap;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.SortedBidiMap;\n+import org.apache.commons.collections4.bidimap.DualTreeBidiMap;\n+import org.apache.commons.collections4.bidimap.UnmodifiableSortedBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableSortedBidiMapTest.class);\n+    }\n+\n+    public UnmodifiableSortedBidiMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<K, V> makeObject() {\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        final SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        // Override to prevent infinite recursion of tests.\n+        return new String[] {\"UnmodifiableSortedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.Collection} methods and contracts.\n+ * <p>\n+ * You should create a concrete subclass of this class to test any custom\n+ * {@link Collection} implementation.  At minimum, you'll have to\n+ * implement the @{@link #makeObject()}, {@link #makeConfirmedCollection()}\n+ * and {@link #makeConfirmedFullCollection()} methods.\n+ * You might want to override some of the additional public methods as well:\n+ * <p>\n+ * <b>Element Population Methods</b>\n+ * <p>\n+ * Override these if your collection restricts what kind of elements are\n+ * allowed (for instance, if <code>null</code> is not permitted):\n+ * <ul>\n+ * <li>{@link #getFullElements()}\n+ * <li>{@link #getOtherElements()}\n+ * </ul>\n+ * <p>\n+ * <b>Supported Operation Methods</b>\n+ * <p>\n+ * Override these if your collection doesn't support certain operations:\n+ * <ul>\n+ * <li>{@link #isAddSupported()}\n+ * <li>{@link #isRemoveSupported()}\n+ * <li>{@link #areEqualElementsDistinguishable()}\n+ * <li>{@link #isNullSupported()}\n+ * <li>{@link #isFailFastSupported()}\n+ * </ul>\n+ * <p>\n+ * <b>Fixture Methods</b>\n+ * <p>\n+ * Fixtures are used to verify that the the operation results in correct state\n+ * for the collection.  Basically, the operation is performed against your\n+ * collection implementation, and an identical operation is performed against a\n+ * <i>confirmed</i> collection implementation.  A confirmed collection\n+ * implementation is something like <code>java.util.ArrayList</code>, which is\n+ * known to conform exactly to its collection interface's contract.  After the\n+ * operation takes place on both your collection implementation and the\n+ * confirmed collection implementation, the two collections are compared to see\n+ * if their state is identical.  The comparison is usually much more involved\n+ * than a simple <code>equals</code> test.  This verification is used to ensure\n+ * proper modifications are made along with ensuring that the collection does\n+ * not change when read-only modifications are made.\n+ * <p>\n+ * The {@link #collection} field holds an instance of your collection\n+ * implementation; the {@link #confirmed} field holds an instance of the\n+ * confirmed collection implementation.  The {@link #resetEmpty()} and\n+ * {@link #resetFull()} methods set these fields to empty or full collections,\n+ * so that tests can proceed from a known state.\n+ * <p>\n+ * After a modification operation to both {@link #collection} and\n+ * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n+ * the results.  You may want to override {@link #verify()} to perform\n+ * additional verifications.  For instance, when testing the collection\n+ * views of a map, {@link org.apache.commons.collections4.map.AbstractMapTest AbstractTestMap} \n+ * would override {@link #verify()} to make\n+ * sure the map is changed after the collection view is changed.\n+ * <p>\n+ * If you're extending this class directly, you will have to provide\n+ * implementations for the following:\n+ * <ul>\n+ * <li>{@link #makeConfirmedCollection()}\n+ * <li>{@link #makeConfirmedFullCollection()}\n+ * </ul>\n+ * <p>\n+ * Those methods should provide a confirmed collection implementation\n+ * that's compatible with your collection implementation.\n+ * <p>\n+ * If you're extending {@link org.apache.commons.collections4.list.AbstractListTest AbstractListTest},\n+ * {@link org.apache.commons.collections4.set.AbstractSetTest AbstractTestSet},\n+ * or {@link org.apache.commons.collections4.bag.AbstractBagTest AbstractBagTest}, \n+ * you probably don't have to worry about the\n+ * above methods, because those three classes already override the methods\n+ * to provide standard JDK confirmed collections.<P>\n+ * <p>\n+ * <b>Other notes</b>\n+ * <p>\n+ * If your {@link Collection} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link Collection} fails.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractCollectionTest<E> extends AbstractObjectTest {\n+\n+    //\n+    // NOTE:\n+    //\n+    // Collection doesn't define any semantics for equals, and recommends you\n+    // use reference-based default behavior of Object.equals.  (And a test for\n+    // that already exists in AbstractTestObject).  Tests for equality of lists, sets\n+    // and bags will have to be written in test subclasses.  Thus, there is no\n+    // tests on Collection.equals nor any for Collection.hashCode.\n+    //\n+\n+    // These fields are used by reset() and verify(), and any test\n+    // method that tests a modification.\n+\n+    /**\n+     *  A collection instance that will be used for testing.\n+     */\n+    private Collection<E> collection;\n+\n+    /**\n+     *  Confirmed collection.  This is an instance of a collection that is\n+     *  confirmed to conform exactly to the java.util.Collection contract.\n+     *  Modification operations are tested by performing a mod on your\n+     *  collection, performing the exact same mod on an equivalent confirmed\n+     *  collection, and then calling verify() to make sure your collection\n+     *  still matches the confirmed collection.\n+     */\n+    private Collection<E> confirmed;\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractCollectionTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Specifies whether equal elements in the collection are, in fact,\n+     *  distinguishable with information not readily available.  That is, if a\n+     *  particular value is to be removed from the collection, then there is\n+     *  one and only one value that can be removed, even if there are other\n+     *  elements which are equal to it.\n+     *\n+     *  <P>In most collection cases, elements are not distinguishable (equal is\n+     *  equal), thus this method defaults to return false.  In some cases,\n+     *  however, they are.  For example, the collection returned from the map's\n+     *  values() collection view are backed by the map, so while there may be\n+     *  two values that are equal, their associated keys are not.  Since the\n+     *  keys are distinguishable, the values are.\n+     *\n+     *  <P>This flag is used to skip some verifications for iterator.remove()\n+     *  where it is impossible to perform an equivalent modification on the\n+     *  confirmed collection because it is not possible to determine which\n+     *  value in the confirmed collection to actually remove.  Tests that\n+     *  override the default (i.e. where equal elements are distinguishable),\n+     *  should provide additional tests on iterator.remove() to make sure the\n+     *  proper elements are removed when remove() is called on the iterator.\n+     **/\n+    public boolean areEqualElementsDistinguishable() {\n+        return false;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>add</code> and <code>addAll</code>\n+     *  operations.<P>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support add or addAll.\n+     */\n+    public boolean isAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>remove</code>, <code>removeAll</code>,\n+     *  <code>retainAll</code>, <code>clear</code> and\n+     *  <code>iterator().remove()</code> methods.\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports holding null.\n+     * The default implementation returns true;\n+     */\n+    public boolean isNullSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports fail fast iterators.\n+     * The default implementation returns true;\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns true to indicate that the collection supports equals() comparisons.\n+     * This implementation returns false;\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that {@link #collection} and {@link #confirmed} have\n+     *  identical state.\n+     */\n+    public void verify() {\n+        final int confirmedSize = getConfirmed().size();\n+        assertEquals(\"Collection size should match confirmed collection's\", confirmedSize,\n+                getCollection().size());\n+        assertEquals(\"Collection isEmpty() result should match confirmed collection's\",\n+                getConfirmed().isEmpty(), getCollection().isEmpty());\n+\n+        // verify the collections are the same by attempting to match each\n+        // object in the collection and confirmed collection.  To account for\n+        // duplicates and differing orders, each confirmed element is copied\n+        // into an array and a flag is maintained for each element to determine\n+        // whether it has been matched once and only once.  If all elements in\n+        // the confirmed collection are matched once and only once and there\n+        // aren't any elements left to be matched in the collection,\n+        // verification is a success.\n+\n+        // copy each collection value into an array\n+        final Object[] confirmedValues = new Object[confirmedSize];\n+\n+        Iterator<E> iter;\n+\n+        iter = getConfirmed().iterator();\n+        int pos = 0;\n+        while (iter.hasNext()) {\n+            confirmedValues[pos++] = iter.next();\n+        }\n+\n+        // allocate an array of boolean flags for tracking values that have\n+        // been matched once and only once.\n+        final boolean[] matched = new boolean[confirmedSize];\n+\n+        // now iterate through the values of the collection and try to match\n+        // the value with one in the confirmed array.\n+        iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n+            final Object o = iter.next();\n+            boolean match = false;\n+            for (int i = 0; i < confirmedSize; i++) {\n+                if (matched[i]) {\n+                    // skip values already matched\n+                    continue;\n+                }\n+                if (o == confirmedValues[i] || o != null && o.equals(confirmedValues[i])) {\n+                    // values matched\n+                    matched[i] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            // no match found!\n+            if (!match) {\n+                fail(\"Collection should not contain a value that the \"\n+                        + \"confirmed collection does not have: \" + o + \"\\nTest: \" + getCollection()\n+                        + \"\\nReal: \" + getConfirmed());\n+            }\n+        }\n+\n+        // make sure there aren't any unmatched values\n+        for (int i = 0; i < confirmedSize; i++) {\n+            if (!matched[i]) {\n+                // the collection didn't match all the confirmed values\n+                fail(\"Collection should contain all values that are in the confirmed collection\"\n+                        + \"\\nTest: \" + getCollection() + \"\\nReal: \" + getConfirmed());\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    public void resetEmpty() {\n+        this.setCollection(makeObject());\n+        this.setConfirmed(makeConfirmedCollection());\n+    }\n+\n+    /**\n+     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n+     *  collections.  Invoke this method before performing a modification\n+     *  test.\n+     */\n+    public void resetFull() {\n+        this.setCollection(makeFullCollection());\n+        this.setConfirmed(makeConfirmedFullCollection());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a confirmed empty collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.\n+     *\n+     *  @return a confirmed empty collection\n+     */\n+    public abstract Collection<E> makeConfirmedCollection();\n+\n+    /**\n+     *  Returns a confirmed full collection.\n+     *  For instance, an {@link java.util.ArrayList} for lists or a\n+     *  {@link java.util.HashSet} for sets.  The returned collection\n+     *  should contain the elements returned by {@link #getFullElements()}.\n+     *\n+     *  @return a confirmed full collection\n+     */\n+    public abstract Collection<E> makeConfirmedFullCollection();\n+\n+    /**\n+     * Return a new, empty {@link Collection} to be used for testing.\n+     */\n+    @Override\n+    public abstract Collection<E> makeObject();\n+\n+    /**\n+     *  Returns a full collection to be used for testing.  The collection\n+     *  returned by this method should contain every element returned by\n+     *  {@link #getFullElements()}.  The default implementation, in fact,\n+     *  simply invokes <code>addAll</code> on an empty collection with\n+     *  the results of {@link #getFullElements()}.  Override this default\n+     *  if your collection doesn't support addAll.\n+     */\n+    public Collection<E> makeFullCollection() {\n+        final Collection<E> c = makeObject();\n+        c.addAll(Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Creates a new Map Entry that is independent of the first and the map.\n+     */\n+    public Map.Entry<E, E> cloneMapEntry(final Map.Entry<E, E> entry) {\n+        final HashMap<E, E> map = new HashMap<E, E>();\n+        map.put(entry.getKey(), entry.getValue());\n+        return map.entrySet().iterator().next();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an array of objects that are contained in a collection\n+     *  produced by {@link #makeFullCollection()}.  Every element in the\n+     *  returned array <I>must</I> be an element in a full collection.<P>\n+     *  The default implementation returns a heterogenous array of\n+     *  objects with some duplicates. null is added if allowed.\n+     *  Override if you require specific testing elements.  Note that if you\n+     *  override {@link #makeFullCollection()}, you <I>must</I> override\n+     *  this method to reflect the contents of a full collection.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        if (isNullSupported()) {\n+            final ArrayList<E> list = new ArrayList<E>();\n+            list.addAll(Arrays.asList(getFullNonNullElements()));\n+            list.add(4, null);\n+            return (E[]) list.toArray();\n+        }\n+        return getFullNonNullElements().clone();\n+    }\n+\n+    /**\n+     *  Returns an array of elements that are <I>not</I> contained in a\n+     *  full collection.  Every element in the returned array must\n+     *  not exist in a collection returned by {@link #makeFullCollection()}.\n+     *  The default implementation returns a heterogenous array of elements\n+     *  without null.  Note that some of the tests add these elements\n+     *  to an empty or full collection, so if your collection restricts\n+     *  certain kinds of elements, you should override this method.\n+     */\n+    public E[] getOtherElements() {\n+        return getOtherNonNullElements();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a list of elements suitable for return by\n+     *  {@link #getFullElements()}.  The array returned by this method\n+     *  does not include null, but does include a variety of objects\n+     *  of different types.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  the null element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        return (E[]) new Object[] {\n+            new String(\"\"),\n+            new String(\"One\"),\n+            new Integer(2),\n+            \"Three\",\n+            new Integer(4),\n+            \"One\",\n+            new Double(5),\n+            new Float(6),\n+            \"Seven\",\n+            \"Eight\",\n+            new String(\"Nine\"),\n+            new Integer(10),\n+            new Short((short)11),\n+            new Long(12),\n+            \"Thirteen\",\n+            \"14\",\n+            \"15\",\n+            new Byte((byte)16)\n+        };\n+    }\n+\n+    /**\n+     *  Returns the default list of objects returned by\n+     *  {@link #getOtherElements()}.  Includes many objects\n+     *  of different types.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        return (E[]) new Object[] {\n+            new Integer(0),\n+            new Float(0),\n+            new Double(0),\n+            \"Zero\",\n+            new Short((short)0),\n+            new Byte((byte)0),\n+            new Long(0),\n+            new Character('\\u0000'),\n+            \"0\"\n+        };\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link #getFullElements()}.  Override getFullElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public Object[] getFullNonNullStringElements() {\n+        return new Object[] {\n+            \"If\", \"the\", \"dull\", \"substance\", \"of\", \"my\", \"flesh\", \"were\",\n+                \"thought\", \"Injurious\", \"distance\", \"could\", \"not\", \"stop\", \"my\", \"way\",\n+        };\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link #getOtherElements()}.  Override getOtherElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    public Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\", \"then\", \"despite\",/* of */\"space\", \"I\", \"would\", \"be\",\n+                \"brought\", \"From\", \"limits\", \"far\", \"remote\", \"where\", \"thou\", \"dost\", \"stay\"\n+        };\n+    }\n+\n+    // Tests\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link Collection#add(Object)}.\n+     */\n+    public void testCollectionAdd() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        final E[] elements = getFullElements();\n+        for (final E element : elements) {\n+            resetEmpty();\n+            final boolean r = getCollection().add(element);\n+            getConfirmed().add(element);\n+            verify();\n+            assertTrue(\"Empty collection changed after add\", r);\n+            assertEquals(\"Collection size is 1 after first add\", 1, getCollection().size());\n+        }\n+\n+        resetEmpty();\n+        int size = 0;\n+        for (final E element : elements) {\n+            final boolean r = getCollection().add(element);\n+            getConfirmed().add(element);\n+            verify();\n+            if (r) {\n+                size++;\n+            }\n+            assertEquals(\"Collection size should grow after add\", size, getCollection().size());\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(element));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#addAll(Collection)}.\n+     */\n+    public void testCollectionAddAll() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (final E element : elements) {\n+            assertTrue(\"Collection should contain added element\", getCollection().contains(element));\n+        }\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        elements = getOtherElements();\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (final E element : elements) {\n+            assertTrue(\"Full collection should contain added element\",\n+                    getCollection().contains(element));\n+        }\n+        assertEquals(\"Size should increase after addAll\", size + elements.length, getCollection().size());\n+\n+        resetFull();\n+        size = getCollection().size();\n+        r = getCollection().addAll(Arrays.asList(getFullElements()));\n+        getConfirmed().addAll(Arrays.asList(getFullElements()));\n+        verify();\n+        if (r) {\n+            assertTrue(\"Size should increase if addAll returns true\", size < getCollection().size());\n+        } else {\n+            assertEquals(\"Size should not change if addAll returns false\", size, getCollection().size());\n+        }\n+    }\n+\n+    /**\n+     *  If {@link #isAddSupported()} returns false, tests that add operations\n+     *  raise <code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedAdd() {\n+        if (isAddSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Empty collection should not support add.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getFullElements()));\n+            fail(\"Empty collection should not support addAll.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        resetFull();\n+        try {\n+            getCollection().add(getFullNonNullElements()[0]);\n+            fail(\"Full collection should not support add.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+\n+        try {\n+            getCollection().addAll(Arrays.asList(getOtherElements()));\n+            fail(\"Full collection should not support addAll.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+\n+    /**\n+     *  Test {@link Collection#clear()}.\n+     */\n+    public void testCollectionClear() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        getCollection().clear(); // just to make sure it doesn't raise anything\n+        verify();\n+\n+        resetFull();\n+        getCollection().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#contains(Object)}.\n+     */\n+    public void testCollectionContains() {\n+        Object[] elements;\n+\n+        resetEmpty();\n+        elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        elements = getOtherElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Empty collection shouldn't contain element[\" + i + \"]\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain element[\" + i + \"]\",\n+                    getCollection().contains(elements[i]));\n+        }\n+        // make sure calls to \"contains\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        elements = getOtherElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection shouldn't contain element\",\n+                    !getCollection().contains(elements[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#containsAll(Collection)}.\n+     */\n+    public void testCollectionContainsAll() {\n+        resetEmpty();\n+        Collection<E> col = new HashSet<E>();\n+        assertTrue(\"Every Collection should contain all elements of an \" +\n+                \"empty Collection.\", getCollection().containsAll(col));\n+        col.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Empty Collection shouldn't contain all elements of \" +\n+                \"a non-empty Collection.\", !getCollection().containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection shouldn't contain other elements\",\n+                !getCollection().containsAll(col));\n+\n+        col.clear();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll full elements\",\n+                getCollection().containsAll(col));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        final int min = getFullElements().length < 2 ? 0 : 2;\n+        final int max = getFullElements().length == 1 ? 1 :\n+                getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n+        col = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection should containAll partial full elements\",\n+                getCollection().containsAll(col));\n+        assertTrue(\"Full collection should containAll itself\", getCollection().containsAll(getCollection()));\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+\n+        col = new ArrayList<E>();\n+        col.addAll(Arrays.asList(getFullElements()));\n+        col.addAll(Arrays.asList(getFullElements()));\n+        assertTrue(\"Full collection should containAll duplicate full elements\",\n+                getCollection().containsAll(col));\n+\n+        // make sure calls to \"containsAll\" don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#isEmpty()}.\n+     */\n+    public void testCollectionIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"New Collection should be empty.\", true, getCollection().isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Full collection shouldn't be empty\", false, getCollection().isEmpty());\n+        // make sure calls to \"isEmpty() don't change anything\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests the read-only functionality of {@link Collection#iterator()}.\n+     */\n+    public void testCollectionIterator() {\n+        resetEmpty();\n+        Iterator<E> it1 = getCollection().iterator();\n+        assertEquals(\"Iterator for empty Collection shouldn't have next.\", false, it1.hasNext());\n+        try {\n+            it1.next();\n+            fail(\"Iterator at end of Collection should throw \"\n+                    + \"NoSuchElementException when next is called.\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+        // make sure nothing has changed after non-modification\n+        verify();\n+\n+        resetFull();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            assertTrue(\"Iterator for full collection should haveNext\", it1.hasNext());\n+            it1.next();\n+        }\n+        assertTrue(\"Iterator should be finished\", !it1.hasNext());\n+\n+        final ArrayList<E> list = new ArrayList<E>();\n+        it1 = getCollection().iterator();\n+        for (int i = 0; i < getCollection().size(); i++) {\n+            final E next = it1.next();\n+            assertTrue(\"Collection should contain element returned by its iterator\",\n+                    getCollection().contains(next));\n+            list.add(next);\n+        }\n+        try {\n+            it1.next();\n+            fail(\"iterator.next() should raise NoSuchElementException after it finishes\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+        // make sure nothing has changed after non-modification\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests removals from {@link Collection#iterator()}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCollectionIteratorRemove() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        try {\n+            getCollection().iterator().remove();\n+            fail(\"New iterator.remove should raise IllegalState\");\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            iter.hasNext();\n+            iter.remove();\n+            fail(\"New iterator.remove should raise IllegalState even after hasNext\");\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        Iterator<E> iter = getCollection().iterator();\n+        while (iter.hasNext()) {\n+            Object o = iter.next();\n+            // TreeMap reuses the Map Entry, so the verify below fails\n+            // Clone it here if necessary\n+            if (o instanceof Map.Entry) {\n+                o = cloneMapEntry((Map.Entry<E, E>) o);\n+            }\n+            iter.remove();\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how).\n+            //\n+            // see areEqualElementsDistinguishable()\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(o);\n+                verify();\n+            }\n+\n+            size--;\n+            assertEquals(\"Collection should shrink by one after iterator.remove\", size,\n+                    getCollection().size());\n+        }\n+        assertTrue(\"Collection should be empty after iterator purge\", getCollection().isEmpty());\n+\n+        resetFull();\n+        iter = getCollection().iterator();\n+        iter.next();\n+        iter.remove();\n+        try {\n+            iter.remove();\n+            fail(\"Second iter.remove should raise IllegalState\");\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#remove(Object)}.\n+     */\n+    public void testCollectionRemove() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        final E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent element\", !getCollection().remove(elements[i]));\n+            verify();\n+        }\n+\n+        final E[] other = getOtherElements();\n+\n+        resetFull();\n+        for (int i = 0; i < other.length; i++) {\n+            assertTrue(\"Shouldn't remove nonexistent other element\", !getCollection().remove(other[i]));\n+            verify();\n+        }\n+\n+        final int size = getCollection().size();\n+        for (final E element : elements) {\n+            resetFull();\n+            assertTrue(\"Collection should remove extant element: \" + element,\n+                    getCollection().remove(element));\n+\n+            // if the elements aren't distinguishable, we can just remove a\n+            // matching element from the confirmed collection and verify\n+            // contents are still the same.  Otherwise, we don't have the\n+            // ability to distinguish the elements and determine which to\n+            // remove from the confirmed collection (in which case, we don't\n+            // verify because we don't know how).\n+            //\n+            // see areEqualElementsDistinguishable()\n+            if (!areEqualElementsDistinguishable()) {\n+                getConfirmed().remove(element);\n+                verify();\n+            }\n+\n+            assertEquals(\"Collection should shrink after remove\", size - 1, getCollection().size());\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#removeAll(Collection)}.\n+     */\n+    public void testCollectionRemoveAll() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        assertTrue(\"Empty collection removeAll should return false for empty input\",\n+                !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty collection removeAll should return false for nonempty input\",\n+                   !getCollection().removeAll(new ArrayList<E>(getCollection())));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full collection removeAll should return false for empty input\",\n+                   !getCollection().removeAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return false for other elements\",\n+                   !getCollection().removeAll(Arrays.asList(getOtherElements())));\n+        verify();\n+\n+        assertTrue(\"Full collection removeAll should return true for full elements\",\n+                getCollection().removeAll(new HashSet<E>(getCollection())));\n+        getConfirmed().removeAll(new HashSet<E>(getConfirmed()));\n+        verify();\n+\n+        resetFull();\n+        final int size = getCollection().size();\n+        final int min = getFullElements().length < 2 ? 0 : 2;\n+        final int max = getFullElements().length == 1 ? 1 :\n+                getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n+        final Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n+        assertTrue(\"Full collection removeAll should work\", getCollection().removeAll(all));\n+        getConfirmed().removeAll(all);\n+        verify();\n+\n+        assertTrue(\"Collection should shrink after removeAll\", getCollection().size() < size);\n+        final Iterator<E> iter = all.iterator();\n+        while (iter.hasNext()) {\n+            assertTrue(\"Collection shouldn't contain removed element\",\n+                    !getCollection().contains(iter.next()));\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#retainAll(Collection)}.\n+     */\n+    public void testCollectionRetainAll() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        final List<E> elements = Arrays.asList(getFullElements());\n+        final List<E> other = Arrays.asList(getOtherElements());\n+\n+        assertTrue(\"Empty retainAll() should return false\",\n+                !getCollection().retainAll(Collections.EMPTY_SET));\n+        verify();\n+\n+        assertTrue(\"Empty retainAll() should return false\", !getCollection().retainAll(elements));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection should change from retainAll empty\",\n+                getCollection().retainAll(Collections.EMPTY_SET));\n+        getConfirmed().retainAll(Collections.EMPTY_SET);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Collection changed from retainAll other\", getCollection().retainAll(other));\n+        getConfirmed().retainAll(other);\n+        verify();\n+\n+        resetFull();\n+        int size = getCollection().size();\n+        assertTrue(\"Collection shouldn't change from retainAll elements\",\n+                   !getCollection().retainAll(elements));\n+        verify();\n+        assertEquals(\"Collection size shouldn't change\", size, getCollection().size());\n+\n+        if (getFullElements().length > 1) {\n+            resetFull();\n+            size = getCollection().size();\n+            final int min = getFullElements().length < 2 ? 0 : 2;\n+            final int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n+            assertTrue(\"Collection should changed by partial retainAll\",\n+                    getCollection().retainAll(elements.subList(min, max)));\n+            getConfirmed().retainAll(elements.subList(min, max));\n+            verify();\n+\n+            final Iterator<E> iter = getCollection().iterator();\n+            while (iter.hasNext()) {\n+                assertTrue(\"Collection only contains retained element\",\n+                        elements.subList(min, max).contains(iter.next()));\n+            }\n+        }\n+\n+        resetFull();\n+        final HashSet<E> set = new HashSet<E>(elements);\n+        size = getCollection().size();\n+        assertTrue(\"Collection shouldn't change from retainAll without \" +\n+                   \"duplicate elements\", !getCollection().retainAll(set));\n+        verify();\n+        assertEquals(\"Collection size didn't change from nonduplicate \" +\n+                     \"retainAll\", size, getCollection().size());\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#size()}.\n+     */\n+    public void testCollectionSize() {\n+        resetEmpty();\n+        assertEquals(\"Size of new Collection is 0.\", 0, getCollection().size());\n+\n+        resetFull();\n+        assertTrue(\"Size of full collection should be greater than zero\", getCollection().size() > 0);\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#toArray()}.\n+     */\n+    public void testCollectionToArray() {\n+        resetEmpty();\n+        assertEquals(\"Empty Collection should return empty array for toArray\",\n+                     0, getCollection().toArray().length);\n+\n+        resetFull();\n+        final Object[] array = getCollection().toArray();\n+        assertEquals(\"Full collection toArray should be same size as collection\",\n+                array.length, getCollection().size());\n+        final Object[] confirmedArray = getConfirmed().toArray();\n+        assertEquals(\"length of array from confirmed collection should \"\n+                + \"match the length of the collection's array\", confirmedArray.length, array.length);\n+        final boolean[] matched = new boolean[array.length];\n+\n+        for (int i = 0; i < array.length; i++) {\n+            assertTrue(\"Collection should contain element in toArray\",\n+                    getCollection().contains(array[i]));\n+\n+            boolean match = false;\n+            // find a match in the confirmed array\n+            for (int j = 0; j < array.length; j++) {\n+                // skip already matched\n+                if (matched[j]) {\n+                    continue;\n+                }\n+                if (array[i] == confirmedArray[j]\n+                        || array[i] != null && array[i].equals(confirmedArray[j])) {\n+                    matched[j] = true;\n+                    match = true;\n+                    break;\n+                }\n+            }\n+            if (!match) {\n+                fail(\"element \" + i + \" in returned array should be found \"\n+                        + \"in the confirmed collection's array\");\n+            }\n+        }\n+        for (final boolean element : matched) {\n+            assertEquals(\"Collection should return all its elements in \" + \"toArray\", true,\n+                    element);\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link Collection#toArray(Object[])}.\n+     */\n+    public void testCollectionToArray2() {\n+        resetEmpty();\n+        Object[] a = new Object[] { new Object(), null, null };\n+        Object[] array = getCollection().toArray(a);\n+        assertEquals(\"Given array shouldn't shrink\", array, a);\n+        assertNull(\"Last element should be set to null\", a[0]);\n+        verify();\n+\n+        resetFull();\n+        try {\n+            array = getCollection().toArray(new Void[0]);\n+            fail(\"toArray(new Void[0]) should raise ArrayStore\");\n+        } catch (final ArrayStoreException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            array = getCollection().toArray(null);\n+            fail(\"toArray(null) should raise NPE\");\n+        } catch (final NullPointerException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        array = getCollection().toArray(new Object[0]);\n+        a = getCollection().toArray();\n+        assertEquals(\"toArrays should be equal\",\n+                     Arrays.asList(array), Arrays.asList(a));\n+\n+        // Figure out if they're all the same class\n+        // TODO: It'd be nicer to detect a common superclass\n+        final HashSet<Class<?>> classes = new HashSet<Class<?>>();\n+        for (final Object element : array) {\n+            classes.add(element == null ? null : element.getClass());\n+        }\n+        if (classes.size() > 1) {\n+            return;\n+        }\n+\n+        Class<?> cl = classes.iterator().next();\n+        if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet\n+            cl = Map.Entry.class;\n+        }\n+        a = (Object[]) Array.newInstance(cl, 0);\n+        array = getCollection().toArray(a);\n+        assertEquals(\"toArray(Object[]) should return correct array type\",\n+                a.getClass(), array.getClass());\n+        assertEquals(\"type-specific toArrays should be equal\",\n+                Arrays.asList(array),\n+                Arrays.asList(getCollection().toArray()));\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests <code>toString</code> on a collection.\n+     */\n+    public void testCollectionToString() {\n+        resetEmpty();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+\n+        resetFull();\n+        assertTrue(\"toString shouldn't return null\", getCollection().toString() != null);\n+    }\n+\n+    /**\n+     *  If isRemoveSupported() returns false, tests to see that remove\n+     *  operations raise an UnsupportedOperationException.\n+     */\n+    public void testUnsupportedRemove() {\n+        if (isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        try {\n+            getCollection().clear();\n+            fail(\"clear should raise UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().removeAll(null);\n+            fail(\"removeAll should raise UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            getCollection().retainAll(null);\n+            fail(\"retainAll should raise UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iterator = getCollection().iterator();\n+            iterator.next();\n+            iterator.remove();\n+            fail(\"iterator.remove should raise UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+\n+    }\n+\n+    /**\n+     *  Tests that the collection's iterator is fail-fast.\n+     */\n+    public void testCollectionIteratorFailFast() {\n+        if (!isFailFastSupported()) {\n+            return;\n+        }\n+\n+        if (isAddSupported()) {\n+            resetFull();\n+            try {\n+                final Iterator<E> iter = getCollection().iterator();\n+                final E o = getOtherElements()[0];\n+                getCollection().add(o);\n+                getConfirmed().add(o);\n+                iter.next();\n+                fail(\"next after add should raise ConcurrentModification\");\n+            } catch (final ConcurrentModificationException e) {\n+                // expected\n+            }\n+            verify();\n+\n+            resetFull();\n+            try {\n+                final Iterator<E> iter = getCollection().iterator();\n+                getCollection().addAll(Arrays.asList(getOtherElements()));\n+                getConfirmed().addAll(Arrays.asList(getOtherElements()));\n+                iter.next();\n+                fail(\"next after addAll should raise ConcurrentModification\");\n+            } catch (final ConcurrentModificationException e) {\n+                // expected\n+            }\n+            verify();\n+        }\n+\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            getCollection().clear();\n+            iter.next();\n+            fail(\"next after clear should raise ConcurrentModification\");\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        } catch (final NoSuchElementException e) {\n+            // (also legal given spec)\n+        }\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            getCollection().remove(getFullElements()[0]);\n+            iter.next();\n+            fail(\"next after remove should raise ConcurrentModification\");\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            final List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().removeAll(sublist);\n+            iter.next();\n+            fail(\"next after removeAll should raise ConcurrentModification\");\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        }\n+\n+        resetFull();\n+        try {\n+            final Iterator<E> iter = getCollection().iterator();\n+            final List<E> sublist = Arrays.asList(getFullElements()).subList(2,5);\n+            getCollection().retainAll(sublist);\n+            iter.next();\n+            fail(\"next after retainAll should raise ConcurrentModification\");\n+        } catch (final ConcurrentModificationException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        Object obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            final Object dest = in.readObject();\n+            in.close();\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj)) - EMPTY Collection\", obj, dest);\n+            }\n+        }\n+        obj = makeFullCollection();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            final Object dest = in.readObject();\n+            in.close();\n+            if (isEqualsCheckable()) {\n+                assertEquals(\"obj != deserialize(serialize(obj)) - FULL Collection\", obj, dest);\n+            }\n+        }\n+    }\n+\n+    public Collection<E> getCollection() {\n+        return collection;\n+    }\n+\n+    /**\n+     * Set the collection.\n+     * @param collection the Collection<E> to set\n+     */\n+    public void setCollection(final Collection<E> collection) {\n+        this.collection = collection;\n+    }\n+\n+    public Collection<E> getConfirmed() {\n+        return confirmed;\n+    }\n+\n+    /**\n+     * Set the confirmed.\n+     * @param confirmed the Collection<E> to set\n+     */\n+    public void setConfirmed(final Collection<E> confirmed) {\n+        this.confirmed = confirmed;\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#contains(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotCollectionContains(final Collection<?> coll, final Object element) {\n+        try {\n+            assertFalse(coll.contains(element));\n+        } catch (final ClassCastException e) {\n+            //apparently not\n+        } catch (final NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotCollectionContainsAll(final Collection<?> coll, final Collection<?> sub) {\n+        try {\n+            assertFalse(coll.containsAll(sub));\n+        } catch (final ClassCastException cce) {\n+            //apparently not\n+        } catch (final NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#remove(Object)}\n+     * @param coll\n+     * @param element\n+     */\n+    protected static void assertNotRemoveFromCollection(final Collection<?> coll, final Object element) {\n+        try {\n+            assertFalse(coll.remove(element));\n+        } catch (final ClassCastException cce) {\n+            //apparently not\n+        } catch (final NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+\n+    /**\n+     * Handle optional exceptions of {@link Collection#removeAll(Collection)}\n+     * @param coll\n+     * @param sub\n+     */\n+    protected static void assertNotRemoveAllFromCollection(final Collection<?> coll, final Collection<?> sub) {\n+        try {\n+            assertFalse(coll.removeAll(sub));\n+        } catch (final ClassCastException cce) {\n+            //apparently not\n+        } catch (final NullPointerException e) {\n+            //apparently not\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.collection.CompositeCollection;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link CompositeCollection} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CompositeCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public CompositeCollectionTest(final String name) {\n+        super(name);\n+    }\n+\n+ //-----------------------------------------------------------------------------\n+    /**\n+     * Run stock collection tests without Mutator, so turn off add, remove\n+     */\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Empty collection is empty composite\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CompositeCollection<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"2\", \"3\", \"4\" };\n+    }\n+\n+    /**\n+     * Full collection consists of 4 collections, each with one element\n+     */\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final CompositeCollection<E> compositeCollection = new CompositeCollection<E>();\n+        final E[] elements = getFullElements();\n+        for (final E element : elements) {\n+            final Collection<E> summand = new HashSet<E>();\n+            summand.add(element);\n+            compositeCollection.addComposited(summand);\n+        }\n+        return compositeCollection;\n+    }\n+\n+    /**\n+     * Full collection should look like a collection with 4 elements\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final Collection<E> collection = new HashSet<E>();\n+        collection.addAll(Arrays.asList(getFullElements()));\n+        return collection;\n+    }\n+\n+    /**\n+     * Override testUnsupportedRemove, since the default impl expects removeAll,\n+     * retainAll and iterator().remove to throw\n+     */\n+    @Override\n+    public void testUnsupportedRemove() {\n+        resetFull();\n+        try {\n+            getCollection().remove(null);\n+            fail(\"remove should raise UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+    //--------------------------------------------------------------------------\n+\n+    protected CompositeCollection<E> c;\n+    protected Collection<E> one;\n+    protected Collection<E> two;\n+\n+    protected void setUpTest() {\n+        c = new CompositeCollection<E>();\n+        one = new HashSet<E>();\n+        two = new HashSet<E>();\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    protected void setUpMutatorTest() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            \n+            public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {\n+                for (final Collection<E> coll : collections) {\n+                    coll.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+                for (final Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n+                for (final Collection<E> collection : collections) {\n+                    collection.remove(obj);\n+                }\n+                return true;\n+            }\n+        });\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        setUpTest();\n+        final HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"a\");\n+        set.add((E) \"b\");\n+        c.addComposited(set);\n+        assertEquals(set.size(), c.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMultipleCollectionsSize() {\n+        setUpTest();\n+        final HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"a\");\n+        set.add((E) \"b\");\n+        c.addComposited(set);\n+        final HashSet<E> other = new HashSet<E>();\n+        other.add((E) \"c\");\n+        c.addComposited(other);\n+        assertEquals(set.size() + other.size(), c.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsEmpty() {\n+        setUpTest();\n+        assertTrue(c.isEmpty());\n+        final HashSet<E> empty = new HashSet<E>();\n+        c.addComposited(empty);\n+        assertTrue(c.isEmpty());\n+        empty.add((E) \"a\");\n+        assertTrue(!c.isEmpty());\n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one);\n+        c.addComposited(two);\n+        final Iterator<E> i = c.iterator();\n+        E next = i.next();\n+        assertTrue(c.contains(next));\n+        assertTrue(one.contains(next));\n+        next = i.next();\n+        i.remove();\n+        assertTrue(!c.contains(next));\n+        assertTrue(!two.contains(next));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClear() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        c.clear();\n+        assertTrue(one.isEmpty());\n+        assertTrue(two.isEmpty());\n+        assertTrue(c.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"1\");\n+        c.addComposited(one);\n+        assertTrue(c.containsAll(two));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        one.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one);\n+        c.retainAll(two);\n+        assertTrue(!c.contains(\"2\"));\n+        assertTrue(!one.contains(\"2\"));\n+        assertTrue(c.contains(\"1\"));\n+        assertTrue(one.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"serial\" })\n+    public void testAddAllMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final E obj) {\n+                for (final Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+                for (final Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n+                return false;\n+            }\n+        });\n+\n+        c.addComposited(one);\n+        two.add((E) \"foo\");\n+        c.addAll(two);\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"serial\" })\n+    public void testAddMutator() {\n+        setUpTest();\n+        c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n+            public boolean add(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final E obj) {\n+                for (final Collection<E> collection : collections) {\n+                    collection.add(obj);\n+                }\n+                return true;\n+            }\n+\n+            public boolean addAll(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Collection<? extends E> coll) {\n+                for (final Collection<E> collection : collections) {\n+                    collection.addAll(coll);\n+                }\n+                return true;\n+            }\n+\n+            public boolean remove(final CompositeCollection<E> composite,\n+                    final List<Collection<E>> collections, final Object obj) {\n+                return false;\n+            }\n+        });\n+\n+        c.addComposited(one);\n+        c.add((E) \"foo\");\n+        assertTrue(c.contains(\"foo\"));\n+        assertTrue(one.contains(\"foo\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToCollection() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        final Collection<E> foo = c.toCollection();\n+        assertTrue(foo.containsAll(c));\n+        assertEquals(c.size(), foo.size());\n+        one.add((E) \"3\");\n+        assertTrue(!foo.containsAll(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAllToCollection() {\n+        setUpTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        c.addComposited(one, two);\n+        final Collection<E> toCollection = new HashSet<E>();\n+        toCollection.addAll(c);\n+        assertTrue(toCollection.containsAll(c));\n+        assertEquals(c.size(), toCollection.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one, two);\n+        c.remove(\"1\");\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        // need separate list to remove, as otherwise one clears itself\n+        final Collection<E> removing = new ArrayList<E>(one);\n+        c.addComposited(one, two);\n+        c.removeAll(removing);\n+        assertTrue(!c.contains(\"1\"));\n+        assertTrue(!one.contains(\"1\"));\n+        assertTrue(!two.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        setUpMutatorTest();\n+        one.add((E) \"1\");\n+        two.add((E) \"2\");\n+        two.add((E) \"1\");\n+        c.addComposited(one, two);\n+        c.removeComposited(one);\n+        assertTrue(c.contains(\"1\"));\n+        assertEquals(2, c.size());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeCollection.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeCollection.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import static java.util.Arrays.asList;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.IndexedCollection;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the \n+ * {@link IndexedCollection} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class IndexedCollectionTest extends AbstractCollectionTest<String> {\n+\n+    public IndexedCollectionTest(final String name) {\n+        super(name);\n+    }\n+\n+   //------------------------------------------------------------------------\n+\n+    protected Collection<String> decorateCollection(final Collection<String> collection) {\n+        return IndexedCollection.nonUniqueIndexedCollection(collection, new IntegerTransformer());\n+    }\n+\n+    protected IndexedCollection<Integer, String> decorateUniqueCollection(final Collection<String> collection) {\n+        return IndexedCollection.uniqueIndexedCollection(collection, new IntegerTransformer());\n+    }\n+\n+    private static final class IntegerTransformer implements Transformer<String, Integer>, Serializable {\n+        private static final long serialVersionUID = 809439581555072949L;\n+\n+        public Integer transform(final String input) {\n+            return Integer.valueOf(input);\n+        }\n+    }\n+    \n+    @Override\n+    public Collection<String> makeObject() {\n+        return decorateCollection(new ArrayList<String>());\n+    }\n+\n+    @Override\n+    public Collection<String> makeConfirmedCollection() {\n+        return new ArrayList<String>();\n+    }\n+\n+    @Override\n+    public String[] getFullElements() {\n+        return new String[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+    }\n+\n+    @Override\n+    public String[] getOtherElements() {\n+        return new String[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n+    }\n+\n+    @Override\n+    public Collection<String> makeFullCollection() {\n+        final List<String> list = new ArrayList<String>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return decorateCollection(list);\n+    }\n+\n+    @Override\n+    public Collection<String> makeConfirmedFullCollection() {\n+        final List<String> list = new ArrayList<String>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    public Collection<String> makeTestCollection() {\n+        return decorateCollection(new ArrayList<String>());\n+    }\n+\n+    public Collection<String> makeUniqueTestCollection() {\n+        return decorateUniqueCollection(new ArrayList<String>());\n+    }\n+    \n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        // FIXME: support canonical tests\n+        return true;\n+    }\n+\n+    //------------------------------------------------------------------------\n+\n+    public void testAddedObjectsCanBeRetrievedByKey() throws Exception {\n+        final Collection<String> coll = makeTestCollection();\n+        coll.add(\"12\");\n+        coll.add(\"16\");\n+        coll.add(\"1\");\n+        coll.addAll(asList(\"2\",\"3\",\"4\"));\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        final IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;\n+        assertEquals(\"12\", indexed.get(12));\n+        assertEquals(\"16\", indexed.get(16));\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+        assertEquals(\"4\", indexed.get(4));\n+    }\n+    \n+    public void testEnsureDuplicateObjectsCauseException() throws Exception {\n+        final Collection<String> coll = makeUniqueTestCollection();\n+\n+        coll.add(\"1\");\n+        try {\n+            coll.add(\"1\");\n+            fail();\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testDecoratedCollectionIsIndexedOnCreation() throws Exception {\n+        final Collection<String> original = makeFullCollection();\n+        final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n+        \n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+    \n+    public void testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately() throws Exception {\n+        final Collection<String> original = new ArrayList<String>();\n+        final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n+        \n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+\n+        assertNull(indexed.get(1));\n+        assertNull(indexed.get(2));\n+        assertNull(indexed.get(3));\n+\n+        indexed.reindex();\n+\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.collection.PredicatedCollection;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the \n+ * {@link PredicatedCollection} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public PredicatedCollectionTest(final String name) {\n+        super(name);\n+    }\n+\n+   //------------------------------------------------------------------------\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected Collection<E> decorateCollection(\n+                final Collection<E> collection, final Predicate<E> predicate) {\n+        return PredicatedCollection.predicatedCollection(collection, predicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeObject() {\n+        return decorateCollection(new ArrayList<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return decorateCollection(list, truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(final E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    public Collection<E> makeTestCollection() {\n+        return decorateCollection(new ArrayList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        final Collection<E> c = makeTestCollection();\n+        final Integer i = new Integer(3);\n+        try {\n+            c.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !c.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        final Collection<E> c = makeTestCollection();\n+        final List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            c.addAll(elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"one\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"two\"));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(new Integer(3)));\n+        assertTrue(\"Collection shouldn't contain illegal element\", !c.contains(\"four\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedCollection.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedCollection.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/SynchronizedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.collection.SynchronizedCollection;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link SynchronizedCollection} implementation.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class SynchronizedCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public SynchronizedCollectionTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return SynchronizedCollection.synchronizedCollection(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/SynchronizedCollection.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/SynchronizedCollection.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.collection.TransformedCollection;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the {@link TransformedCollection}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedCollectionTest extends AbstractCollectionTest<Object> {\n+    \n+    private static class StringToInteger implements Transformer<Object, Object> {\n+        public Object transform(final Object input) {\n+            return new Integer((String) input);\n+        }\n+    }\n+    \n+    public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n+    public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n+\n+    public TransformedCollectionTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<Object> makeConfirmedCollection() {\n+        return new ArrayList<Object>();\n+    }\n+\n+    @Override\n+    public Collection<Object> makeConfirmedFullCollection() {\n+        final List<Object> list = new ArrayList<Object>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+    \n+    @Override\n+    public Collection<Object> makeObject() {\n+        return TransformedCollection.transformingCollection(new ArrayList<Object>(), NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    public Collection<Object> makeFullCollection() {\n+        final List<Object> list = new ArrayList<Object>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Object[] getFullElements() {\n+        return new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+    }\n+\n+    @Override\n+    public Object[] getOtherElements() {\n+        return new Object[] {\"9\", \"88\", \"678\", \"87\", \"98\", \"78\", \"99\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTransformedCollection() {\n+        final Collection<Object> coll = TransformedCollection.transformingCollection(new ArrayList<Object>(), STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, coll.size());\n+        final Object[] els = getFullElements();\n+        for (int i = 0; i < els.length; i++) {\n+            coll.add(els[i]);\n+            assertEquals(i + 1, coll.size());\n+            assertEquals(true, coll.contains(new Integer((String) els[i])));\n+            assertEquals(false, coll.contains(els[i]));\n+        }\n+        \n+        assertEquals(true, coll.remove(new Integer((String) els[0])));\n+    }\n+\n+    public void testTransformedCollection_decorateTransform() {\n+        final Collection originalCollection = new ArrayList();\n+        final Object[] els = getFullElements();\n+        for (final Object el : els) {\n+            originalCollection.add(el);\n+        }\n+        final Collection<Object> collection = TransformedCollection.transformedCollection(originalCollection, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, collection.size());\n+        for (final Object el : els) {\n+            assertEquals(true, collection.contains(new Integer((String) el)));\n+            assertEquals(false, collection.contains(el));\n+        }\n+        \n+        assertEquals(false, collection.remove(els[0]));\n+        assertEquals(true, collection.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedCollection.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedCollection.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.BoundedCollection;\n+import org.apache.commons.collections4.collection.UnmodifiableBoundedCollection;\n+import org.apache.commons.collections4.list.FixedSizeList;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableBoundedCollection} implementation.\n+ * \n+ * @version $Id$\n+ */\n+public class UnmodifiableBoundedCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableBoundedCollectionTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<E>());\n+        return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final E[] allElements = getFullElements();\n+        final BoundedCollection<E> coll = FixedSizeList.<E>fixedSizeList(new ArrayList<E>(Arrays.asList(allElements)));\n+        return UnmodifiableBoundedCollection.unmodifiableBoundedCollection(coll);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean skipSerializedCanonicalTests() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableCollection} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableCollectionTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableCollectionTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableCollection.unmodifiableCollection(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableCollection.unmodifiableCollection(list);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableCollection.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableCollection.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+import org.junit.Test;\n+\n+/**\n+ * Abstract test class for testing the Comparator interface.\n+ * <p>\n+ * Concrete subclasses declare the comparator to be tested.\n+ * They also declare certain aspects of the tests.\n+ */\n+public abstract class AbstractComparatorTest<T> extends AbstractObjectTest {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractComparatorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    \n+    /**\n+     * Implement this method to return a list of sorted objects.\n+     * \n+     * @return sorted objects\n+     */\n+    public abstract List<T> getComparableObjectsOrdered();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements the abstract superclass method to return the comparator.\n+     * \n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract Comparator<T> makeObject();\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsEmptyCollections() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overrides superclass to block tests.\n+     */\n+    @Override\n+    public boolean supportsFullCollections() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Reverse the list.\n+     */\n+    protected void reverseObjects(final List<?> list) {\n+        Collections.reverse(list);\n+    }\n+\n+    /**\n+     * Randomize the list.\n+     */\n+    protected void randomizeObjects(final List<?> list) {\n+        Collections.shuffle(list);\n+    }\n+\n+    /**\n+     * Sort the list.\n+     */\n+    protected void sortObjects(final List<T> list, final Comparator<? super T> comparator) {\n+        Collections.sort(list, comparator);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test sorting an empty list\n+     */\n+    @Test\n+    public void testEmptyListSort() {\n+        final List<T> list = new LinkedList<T>();\n+        sortObjects(list, makeObject());\n+\n+        final List<T> list2 = new LinkedList<T>();\n+\n+        assertTrue(\"Comparator cannot sort empty lists\", list2.equals(list));\n+    }\n+\n+    /**\n+     * Test sorting a reversed list.\n+     */\n+    @Test\n+    public void testReverseListSort() {\n+        final Comparator<T> comparator = makeObject();\n+\n+        final List<T> randomList = getComparableObjectsOrdered();\n+        reverseObjects(randomList);\n+        sortObjects(randomList, comparator);\n+\n+        final List<T> orderedList = getComparableObjectsOrdered();\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+    }\n+\n+    /**\n+     * Test sorting a random list.\n+     */\n+    @Test\n+    public void testRandomListSort() {\n+        final Comparator<T> comparator = makeObject();\n+\n+        final List<T> randomList = getComparableObjectsOrdered();\n+        randomizeObjects(randomList);\n+        sortObjects(randomList,comparator);\n+\n+        final List<T> orderedList = getComparableObjectsOrdered();\n+\n+        /* debug \n+        Iterator i = randomList.iterator();\n+        while (i.hasNext()) {\n+            System.out.println(i.next());\n+        }\n+        */\n+\n+        assertTrue(\"Comparator did not reorder the List correctly\",\n+                   orderedList.equals(randomList));\n+\n+    }\n+\n+    /**\n+     * Nearly all Comparators should be Serializable.\n+     */\n+    @Test\n+    public void testComparatorIsSerializable() {\n+        final Comparator<T> comparator = makeObject();\n+        assertTrue(\"This comparator should be Serializable.\",\n+                   comparator instanceof Serializable);\n+    }\n+\n+    public String getCanonicalComparatorName(final Object object) {\n+        final StringBuilder retval = new StringBuilder();\n+        retval.append(TEST_DATA_PATH);\n+        String colName = object.getClass().getName();\n+        colName = colName.substring(colName.lastIndexOf(\".\")+1,colName.length());\n+        retval.append(colName);\n+        retval.append(\".version\");\n+        retval.append(getCompatibilityVersion());\n+        retval.append(\".obj\");\n+        return retval.toString();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Comparator\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testComparatorCompatibility() throws IOException, ClassNotFoundException {\n+        if (!skipSerializedCanonicalTests()) {\n+            Comparator<T> comparator = null;\n+    \n+            // test to make sure the canonical form has been preserved\n+            try {\n+                comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n+            } catch (final FileNotFoundException exception) {\n+    \n+                final boolean autoCreateSerialized = false;\n+    \n+                if (autoCreateSerialized) {\n+                    comparator = makeObject();\n+                    final String fileName = getCanonicalComparatorName(comparator);\n+                    writeExternalFormToDisk((Serializable) comparator, fileName);\n+                    fail(\"Serialized form could not be found.  A serialized version \"\n+                            + \"has now been written (and should be added to CVS): \" + fileName);\n+                } else {\n+                    fail(\"The Serialized form could be located to test serialization \"\n+                            + \"compatibility: \" + exception.getMessage());\n+                }\n+            }\n+    \n+            \n+            // make sure the canonical form produces the ordering we currently\n+            // expect\n+            final List<T> randomList = getComparableObjectsOrdered();\n+            reverseObjects(randomList);\n+            sortObjects(randomList, comparator);\n+    \n+            final List<T> orderedList = getComparableObjectsOrdered();\n+    \n+            assertTrue(\"Comparator did not reorder the List correctly\",\n+                       orderedList.equals(randomList));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/AbstractNullComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.comparators.NullComparator;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test the NullComparator.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractNullComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    public AbstractNullComparatorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        final TestSuite suite = new TestSuite(AbstractNullComparatorTest.class.getName());\n+        suite.addTest(new TestSuite(TestNullComparator1.class));\n+        suite.addTest(new TestSuite(TestNullComparator2.class));\n+        return suite;\n+    }\n+\n+    /**\n+     *  Test the NullComparator with nulls high, using comparable comparator\n+     **/\n+    public static class TestNullComparator1 extends AbstractNullComparatorTest {\n+\n+        public TestNullComparator1(final String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public Comparator<Integer> makeObject() {\n+            return new NullComparator<Integer>();\n+        }\n+\n+        @Override\n+        public List<Integer> getComparableObjectsOrdered() {\n+            final List<Integer> list = new LinkedList<Integer>();\n+            list.add(new Integer(1));\n+            list.add(new Integer(2));\n+            list.add(new Integer(3));\n+            list.add(new Integer(4));\n+            list.add(new Integer(5));\n+            list.add(null);\n+            return list;\n+        }\n+\n+        @Override\n+        public String getCanonicalComparatorName(final Object object) {\n+            return super.getCanonicalComparatorName(object) + \"1\";\n+        }\n+        \n+        @Override\n+        public String getCompatibilityVersion() {\n+            return \"4\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj1\");\n+//        }\n+        \n+    }\n+\n+    /**\n+     *  Test the NullComparator with nulls low using the comparable comparator\n+     **/\n+    public static class TestNullComparator2 extends AbstractNullComparatorTest {\n+\n+        public TestNullComparator2(final String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public Comparator<Integer> makeObject() {\n+            return new NullComparator<Integer>(false);\n+        }\n+\n+        @Override\n+        public List<Integer> getComparableObjectsOrdered() {\n+            final List<Integer> list = new LinkedList<Integer>();\n+            list.add(null);\n+            list.add(new Integer(1));\n+            list.add(new Integer(2));\n+            list.add(new Integer(3));\n+            list.add(new Integer(4));\n+            list.add(new Integer(5));\n+            return list;\n+        }\n+\n+        @Override\n+        public String getCanonicalComparatorName(final Object object) {\n+            return super.getCanonicalComparatorName(object) + \"2\";\n+        }\n+        \n+        @Override\n+        public String getCompatibilityVersion() {\n+            return \"4\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj2\");\n+//        }\n+        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/BooleanComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.comparators.BooleanComparator;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for {@link BooleanComparator}.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class BooleanComparatorTest extends AbstractComparatorTest<Boolean> {\n+\n+    // conventional\n+    // ------------------------------------------------------------------------\n+\n+    public BooleanComparatorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    // collections testing framework\n+    // ------------------------------------------------------------------------\n+\n+    @Override\n+    public Comparator<Boolean> makeObject() {\n+        return new BooleanComparator();\n+    }\n+\n+    @Override\n+    public List<Boolean> getComparableObjectsOrdered() {\n+        final List<Boolean> list = new ArrayList<Boolean>();\n+        list.add(new Boolean(false));\n+        list.add(Boolean.FALSE);\n+        list.add(new Boolean(false));\n+        list.add(Boolean.TRUE);\n+        list.add(new Boolean(true));\n+        list.add(true);\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/BooleanComparator.version4.obj\");\n+//    }\n+\n+    // tests\n+    // ------------------------------------------------------------------------\n+\n+    @Test\n+    public void testConstructors() {\n+        allTests(false,new BooleanComparator());\n+        allTests(false,new BooleanComparator(false));\n+        allTests(true,new BooleanComparator(true));\n+    }\n+\n+    @Test\n+\n+    public void testStaticFactoryMethods() {\n+        allTests(false,BooleanComparator.getFalseFirstComparator());\n+        allTests(false,BooleanComparator.booleanComparator(false));\n+        allTests(true,BooleanComparator.getTrueFirstComparator());\n+        allTests(true,BooleanComparator.booleanComparator(true));\n+    }\n+\n+    @Test\n+    public void testEqualsCompatibleInstance() {\n+        assertEquals(new BooleanComparator(),new BooleanComparator(false));\n+        assertEquals(new BooleanComparator(false),new BooleanComparator(false));\n+        assertEquals(new BooleanComparator(false),BooleanComparator.getFalseFirstComparator());\n+        assertSame(BooleanComparator.getFalseFirstComparator(),BooleanComparator.booleanComparator(false));\n+\n+        assertEquals(new BooleanComparator(true),new BooleanComparator(true));\n+        assertEquals(new BooleanComparator(true),BooleanComparator.getTrueFirstComparator());\n+        assertSame(BooleanComparator.getTrueFirstComparator(),BooleanComparator.booleanComparator(true));\n+\n+        assertTrue(!new BooleanComparator().equals(new BooleanComparator(true)));\n+        assertTrue(!new BooleanComparator(true).equals(new BooleanComparator(false)));\n+    }\n+\n+    // utilities\n+    // ------------------------------------------------------------------------\n+\n+    protected void allTests(final boolean trueFirst, final BooleanComparator comp) {\n+        orderIndependentTests(comp);\n+        if(trueFirst) {\n+            trueFirstTests(comp);\n+        } else {\n+            falseFirstTests(comp);\n+        }\n+    }\n+\n+    protected void trueFirstTests(final BooleanComparator comp) {\n+        assertNotNull(comp);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) > 0);\n+        assertTrue(comp.compare(true, false) < 0);\n+    }\n+\n+    protected void falseFirstTests(final BooleanComparator comp) {\n+        assertNotNull(comp);\n+        assertEquals(0,comp.compare(true, true));\n+        assertEquals(0,comp.compare(false, false));\n+        assertTrue(comp.compare(false, true) < 0);\n+        assertTrue(comp.compare(true, false) > 0);\n+    }\n+\n+    protected void orderIndependentTests(final BooleanComparator comp) {\n+        nullArgumentTests(comp);\n+    }\n+\n+    protected void nullArgumentTests(final BooleanComparator comp) {\n+        assertNotNull(comp);\n+        try {\n+            comp.compare(null,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(final NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(Boolean.TRUE,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(final NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(Boolean.FALSE,null);\n+            fail(\"Expected NullPointerException\");\n+        } catch(final NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(null,Boolean.TRUE);\n+            fail(\"Expected NullPointerException\");\n+        } catch(final NullPointerException e) {\n+            // expected\n+        }\n+        try {\n+            comp.compare(null,Boolean.FALSE);\n+            fail(\"Expected NullPointerException\");\n+        } catch(final NullPointerException e) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ComparableComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+\n+/**\n+ * Tests for ComparableComparator.\n+ *\n+ * @version $Id$\n+ *\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class ComparableComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    public ComparableComparatorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+        return new ComparableComparator<Integer>();\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        final List<Integer> list = new LinkedList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        list.add(5);\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ComparableComparator.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+import org.apache.commons.collections4.comparators.ComparatorChain;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for ComparatorChain.\n+ *\n+ * @version $Id$\n+ */\n+public class ComparatorChainTest extends AbstractComparatorTest<ComparatorChainTest.PseudoRow> {\n+\n+    public ComparatorChainTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Comparator<PseudoRow> makeObject() {\n+        final ComparatorChain<PseudoRow> chain = new ComparatorChain<PseudoRow>(new ColumnComparator(0));\n+        chain.addComparator(new ColumnComparator(1), true); // reverse the second column\n+        chain.addComparator(new ColumnComparator(2), false);\n+        return chain;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ComparatorChain.version4.obj\");\n+//    }\n+    \n+    @Test\n+    public void testNoopComparatorChain() {\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n+        chain.addComparator(new ComparableComparator<Integer>());\n+\n+        final int correctValue = i1.compareTo(i2);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n+    }\n+\n+    @Test\n+    public void testBadNoopComparatorChain() {\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n+        try {\n+            chain.compare(i1,i2);\n+            fail(\"An exception should be thrown when a chain contains zero comparators.\");\n+        } catch (final UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testListComparatorChain() {\n+        final List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        list.add(new ComparableComparator<Integer>());\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n+\n+        final int correctValue = i1.compareTo(i2);\n+        assertTrue(\"Comparison returns the right order\", chain.compare(i1, i2) == correctValue);\n+    }\n+\n+    @Test\n+    public void testBadListComparatorChain() {\n+        final List<Comparator<Integer>> list = new LinkedList<Comparator<Integer>>();\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>(list);\n+        final Integer i1 = new Integer(4);\n+        final Integer i2 = new Integer(6);\n+        try {\n+            chain.compare(i1, i2);\n+            fail(\"An exception should be thrown when a chain contains zero comparators.\");\n+        } catch (final UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testComparatorChainOnMinvaluedCompatator() {\n+        // -1 * Integer.MIN_VALUE is less than 0,\n+        // test that ComparatorChain handles this edge case correctly\n+        final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n+        chain.addComparator(new Comparator<Integer>() {\n+            public int compare(final Integer a, final Integer b) {\n+                final int result = a.compareTo(b);\n+                if (result < 0) {\n+                    return Integer.MIN_VALUE;\n+                }\n+                if (result > 0) {\n+                    return Integer.MAX_VALUE;\n+                }\n+                return 0;\n+            }\n+        }, true);\n+\n+        assertTrue(chain.compare(new Integer(4), new Integer(5)) > 0);\n+        assertTrue(chain.compare(new Integer(5), new Integer(4)) < 0);\n+        assertTrue(chain.compare(new Integer(4), new Integer(4)) == 0);\n+    }\n+\n+    @Override\n+    public List<PseudoRow> getComparableObjectsOrdered() {\n+        final List<PseudoRow> list = new LinkedList<PseudoRow>();\n+        // this is the correct order assuming a\n+        // \"0th forward, 1st reverse, 2nd forward\" sort\n+        list.add(new PseudoRow(1, 2, 3));\n+        list.add(new PseudoRow(2, 3, 5));\n+        list.add(new PseudoRow(2, 2, 4));\n+        list.add(new PseudoRow(2, 2, 8));\n+        list.add(new PseudoRow(3, 1, 0));\n+        list.add(new PseudoRow(4, 4, 4));\n+        list.add(new PseudoRow(4, 4, 7));\n+        return list;\n+    }\n+\n+    public static class PseudoRow implements Serializable {\n+\n+        /**\n+         * Generated serial version ID.\n+         */\n+        private static final long serialVersionUID = 8085570439751032499L;\n+        public int cols[] = new int[3];\n+\n+        public PseudoRow(final int col1, final int col2, final int col3) {\n+            cols[0] = col1;\n+            cols[1] = col2;\n+            cols[2] = col3;\n+        }\n+\n+        public int getColumn(final int colIndex) {\n+            return cols[colIndex];\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder buf = new StringBuilder();\n+            buf.append(\"[\");\n+            buf.append(cols[0]);\n+            buf.append(\",\");\n+            buf.append(cols[1]);\n+            buf.append(\",\");\n+            buf.append(cols[2]);\n+            buf.append(\"]\");\n+            return buf.toString();\n+        }\n+\n+        @Override\n+        public boolean equals(final Object o) {\n+            if (!(o instanceof PseudoRow)) {\n+                return false;\n+            }\n+\n+            final PseudoRow row = (PseudoRow) o;\n+            if (getColumn(0) != row.getColumn(0)) {\n+                return false;\n+            }\n+\n+            if (getColumn(1) != row.getColumn(1)) {\n+                return false;\n+            }\n+\n+            if (getColumn(2) != row.getColumn(2)) {\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+    }\n+\n+    public static class ColumnComparator implements Comparator<PseudoRow>, Serializable {\n+        private static final long serialVersionUID = -2284880866328872105L;\n+\n+        protected int colIndex = 0;\n+\n+        public ColumnComparator(final int colIndex) {\n+            this.colIndex = colIndex;\n+        }\n+\n+        public int compare(final PseudoRow o1, final PseudoRow o2) {\n+\n+            final int col1 = o1.getColumn(colIndex);\n+            final int col2 = o2.getColumn(colIndex);\n+\n+            if (col1 > col2) {\n+                return 1;\n+            }\n+            if (col1 < col2) {\n+                return -1;\n+            }\n+            return 0;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return colIndex;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object that) {\n+            return that instanceof ColumnComparator && colIndex == ((ColumnComparator) that).colIndex;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.apache.commons.collections4.comparators.FixedOrderComparator;\n+import org.junit.Test;\n+\n+/**\n+ * Test class for FixedOrderComparator.\n+ *\n+ * @version $Id$\n+ */\n+public class FixedOrderComparatorTest extends AbstractComparatorTest<String> {\n+\n+    /**\n+     * Top cities of the world, by population including metro areas.\n+     */\n+    private static final String topCities[] = new String[] {\n+        \"Tokyo\",\n+        \"Mexico City\",\n+        \"Mumbai\",\n+        \"Sao Paulo\",\n+        \"New York\",\n+        \"Shanghai\",\n+        \"Lagos\",\n+        \"Los Angeles\",\n+        \"Calcutta\",\n+        \"Buenos Aires\"\n+    };\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public FixedOrderComparatorTest(final String name) {\n+        super(name);\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+    @Override\n+    public Comparator<String> makeObject() {\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        return comparator;\n+    }\n+\n+    @Override\n+    public List<String> getComparableObjectsOrdered() {\n+        return Arrays.asList(topCities);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/FixedOrderComparator.version4.obj\");\n+//    }\n+    \n+    //\n+    // The tests\n+    //\n+\n+    /**\n+     * Tests that the constructor plus add method compares items properly.\n+     */\n+    @Test\n+    public void testConstructorPlusAdd() {\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>();\n+        for (final String topCitie : topCities) {\n+            comparator.add(topCitie);\n+        }\n+        final String[] keys = topCities.clone();\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests that the array constructor compares items properly.\n+     */\n+    @Test\n+    public void testArrayConstructor() {\n+        final String[] keys = topCities.clone();\n+        final String[] topCitiesForTest = topCities.clone();\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest[0] = \"Brighton\";\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests the list constructor.\n+     */\n+    @Test\n+    public void testListConstructor() {\n+        final String[] keys = topCities.clone();\n+        final List<String> topCitiesForTest = new LinkedList<String>(Arrays.asList(topCities));\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCitiesForTest);\n+        assertComparatorYieldsOrder(keys, comparator);\n+        // test that changing input after constructor has no effect\n+        topCitiesForTest.set(0, \"Brighton\");\n+        assertComparatorYieldsOrder(keys, comparator);\n+    }\n+\n+    /**\n+     * Tests addAsEqual method.\n+     */\n+    @Test\n+    public void testAddAsEqual() {\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+        assertEquals(0, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals(-1, comparator.compare(\"Tokyo\", \"Minneapolis\"));\n+        assertEquals(1, comparator.compare(\"Shanghai\", \"Minneapolis\"));\n+    }\n+\n+    /**\n+     * Tests whether or not updates are disabled after a comparison is made.\n+     */\n+    @Test\n+    public void testLock() {\n+        final FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        assertEquals(false, comparator.isLocked());\n+        comparator.compare(\"New York\", \"Tokyo\");\n+        assertEquals(true, comparator.isLocked());\n+        try {\n+            comparator.add(\"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+\n+        try {\n+            comparator.addAsEqual(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown an UnsupportedOperationException\");\n+        } catch (final UnsupportedOperationException e) {\n+            // success -- ignore\n+        }\n+    }\n+\n+    @Test\n+    public void testUnknownObjectBehavior() {\n+        FixedOrderComparator<String> comparator = new FixedOrderComparator<String>(topCities);\n+        try {\n+            comparator.compare(\"New York\", \"Minneapolis\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (final IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        try {\n+            comparator.compare(\"Minneapolis\", \"New York\");\n+            fail(\"Should have thrown a IllegalArgumentException\");\n+        } catch (final IllegalArgumentException e) {\n+            // success-- ignore\n+        }\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.EXCEPTION, comparator.getUnknownObjectBehavior());\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.BEFORE);\n+        assertEquals(FixedOrderComparator.UnknownObjectBehavior.BEFORE, comparator.getUnknownObjectBehavior());\n+        LinkedList<String> keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.addFirst(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals(-1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals( 1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+        comparator = new FixedOrderComparator<String>(topCities);\n+        comparator.setUnknownObjectBehavior(FixedOrderComparator.UnknownObjectBehavior.AFTER);\n+        keys = new LinkedList<String>(Arrays.asList(topCities));\n+        keys.add(\"Minneapolis\");\n+        assertComparatorYieldsOrder(keys.toArray(new String[0]), comparator);\n+\n+        assertEquals( 1, comparator.compare(\"Minneapolis\", \"New York\"));\n+        assertEquals(-1, comparator.compare(\"New York\", \"Minneapolis\"));\n+        assertEquals( 0, comparator.compare(\"Minneapolis\", \"St Paul\"));\n+\n+    }\n+\n+    //\n+    // Helper methods\n+    //\n+\n+    /** Shuffles the keys and asserts that the comparator sorts them back to\n+     * their original order.\n+     */\n+    private void assertComparatorYieldsOrder(final String[] orderedObjects,\n+                                             final Comparator<String> comparator) {\n+        final String[] keys = orderedObjects.clone();\n+\n+        // shuffle until the order changes.  It's extremely rare that\n+        // this requires more than one shuffle.\n+\n+        boolean isInNewOrder = false;\n+        final Random rand = new Random();\n+        while (keys.length > 1 && isInNewOrder == false) {\n+            // shuffle:\n+            for (int i = keys.length-1; i > 0; i--) {\n+                final String swap = keys[i];\n+                final int j = rand.nextInt(i+1);\n+                keys[i] = keys[j];\n+                keys[j] = swap;\n+            }\n+\n+            // testShuffle\n+            for (int i = 0; i < keys.length && !isInNewOrder; i++) {\n+                if( !orderedObjects[i].equals(keys[i])) {\n+                    isInNewOrder = true;\n+                }\n+            }\n+        }\n+\n+        // The real test:  sort and make sure they come out right.\n+\n+        Arrays.sort(keys, comparator);\n+\n+        for (int i = 0; i < orderedObjects.length; i++) {\n+            assertEquals(orderedObjects[i], keys[i]);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+import org.apache.commons.collections4.comparators.ReverseComparator;\n+import org.junit.Test;\n+\n+/**\n+ * Tests for ReverseComparator.\n+ *\n+ * @version $Id$\n+ */\n+public class ReverseComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    public ReverseComparatorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * For the purposes of this test, return a\n+     * ReverseComparator that wraps the java.util.Collections.reverseOrder()\n+     * Comparator.  The resulting comparator should\n+     * sort according to natural Order.  (Note: we wrap\n+     * a Comparator taken from the JDK so that we can\n+     * save a \"canonical\" form in SVN.\n+     *\n+     * @return Comparator that returns \"natural\" order\n+     */\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+        return new ReverseComparator<Integer>(Collections.<Integer>reverseOrder());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ReverseComparator.version4.obj\");\n+//    }\n+    \n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        final List<Integer> list = new LinkedList<Integer>();\n+        list.add(new Integer(1));\n+        list.add(new Integer(2));\n+        list.add(new Integer(3));\n+        list.add(new Integer(4));\n+        list.add(new Integer(5));\n+        return list;\n+    }\n+\n+    /**\n+     * Override this inherited test since Collections.reverseOrder\n+     * doesn't adhere to the \"soft\" Comparator contract, and we've\n+     * already \"canonized\" the comparator returned by makeComparator.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void testSerializeDeserializeThenCompare() throws Exception {\n+        final Comparator comp = new ReverseComparator(new ComparableComparator());\n+\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(comp);\n+        out.close();\n+\n+        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        final Object dest = in.readObject();\n+        in.close();\n+        assertEquals(\"obj != deserialize(serialize(obj))\",comp,dest);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/TransformingComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators;\n+\n+import java.util.Comparator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.ComparatorUtils;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+\n+/**\n+ * Test class for TransformingComparator.\n+ *\n+ * @version $Id$\n+ */\n+public class TransformingComparatorTest extends AbstractComparatorTest<Integer> {\n+\n+    //\n+    // Initialization and busywork\n+    //\n+\n+    public TransformingComparatorTest(final String name) {\n+        super(name);\n+    }\n+\n+    //\n+    // Set up and tear down\n+    //\n+\n+    @Override\n+    public Comparator<Integer> makeObject() {\n+       final Comparator<String> decorated = new ComparableComparator<String>();\n+       return ComparatorUtils.transformedComparator(decorated, TransformerUtils.<Integer>stringValueTransformer());\n+    }\n+\n+    @Override\n+    public List<Integer> getComparableObjectsOrdered() {\n+        final List<Integer> list = new LinkedList<Integer>();\n+        list.add(1);\n+        list.add(2);\n+        list.add(3);\n+        list.add(4);\n+        list.add(5);\n+        return list;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/TransformingComparator.version4.obj\");\n+//    }\n+\n+    //\n+    // The tests\n+    //\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/comparators/sequence/SequencesComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.comparators.sequence;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.apache.commons.collections4.comparators.sequence.CommandVisitor;\n+import org.apache.commons.collections4.comparators.sequence.SequencesComparator;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SequencesComparatorTest {\n+\n+    private List<String> before;\n+    private List<String> after;\n+    private int[]        length;\n+\n+    @Test\n+    public void testLength() {\n+        for (int i = 0; i < before.size(); ++i) {\n+            final SequencesComparator<Character> comparator =\n+                    new SequencesComparator<Character>(sequence(before.get(i)),\n+                            sequence(after.get(i)));\n+            Assert.assertEquals(length[i], comparator.getScript().getModifications());\n+        }\n+    }\n+\n+    @Test\n+    public void testExecution() {\n+        final ExecutionVisitor<Character> ev = new ExecutionVisitor<Character>();\n+        for (int i = 0; i < before.size(); ++i) {\n+            ev.setList(sequence(before.get(i)));\n+            new SequencesComparator<Character>(sequence(before.get(i)),\n+                    sequence(after.get(i))).getScript().visit(ev);\n+            Assert.assertEquals(after.get(i), ev.getString());\n+        }\n+    }\n+\n+    @Test\n+    public void testMinimal() {\n+        final String[] shadokAlph = new String[] {\n+            new String(\"GA\"),\n+            new String(\"BU\"),\n+            new String(\"ZO\"),\n+            new String(\"MEU\")\n+        };\n+        final List<String> sentenceBefore = new ArrayList<String>();\n+        final List<String> sentenceAfter  = new ArrayList<String>();\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[3]);\n+\n+        final Random random = new Random(4564634237452342L);\n+\n+        for (int nbCom = 0; nbCom <= 40; nbCom+=5) {\n+            sentenceAfter.clear();\n+            sentenceAfter.addAll(sentenceBefore);\n+            for (int i = 0; i<nbCom; i++) {\n+                if (random.nextInt(2) == 0) {\n+                    sentenceAfter.add(random.nextInt(sentenceAfter.size() + 1),\n+                                      shadokAlph[random.nextInt(4)]);\n+                } else {\n+                    sentenceAfter.remove(random.nextInt(sentenceAfter.size()));\n+                }\n+            }\n+\n+            final SequencesComparator<String> comparator =\n+                    new SequencesComparator<String>(sentenceBefore, sentenceAfter);\n+            Assert.assertTrue(comparator.getScript().getModifications() <= nbCom);\n+        }\n+    }\n+\n+    @Test\n+    public void testShadok() {\n+        final int lgMax = 5;\n+        final String[] shadokAlph = new String[] {\n+            new String(\"GA\"),\n+            new String(\"BU\"),\n+            new String(\"ZO\"),\n+            new String(\"MEU\")\n+        };\n+        List<List<String>> shadokSentences = new ArrayList<List<String>>();\n+        for (int lg=0; lg<lgMax; ++lg) {\n+            final List<List<String>> newTab = new ArrayList<List<String>>();\n+            newTab.add(new ArrayList<String>());\n+            for (final String element : shadokAlph) {\n+                for (final List<String> sentence : shadokSentences) {\n+                    final List<String> newSentence = new ArrayList<String>(sentence);\n+                    newSentence.add(element);\n+                    newTab.add(newSentence);\n+                }\n+            }\n+            shadokSentences = newTab;\n+        }\n+\n+        final ExecutionVisitor<String> ev = new ExecutionVisitor<String>();\n+\n+        for (int i = 0; i < shadokSentences.size(); ++i) {\n+            for (int j = 0; j < shadokSentences.size(); ++j) {\n+                ev.setList(shadokSentences.get(i));\n+                new SequencesComparator<String>(shadokSentences.get(i),\n+                        shadokSentences.get(j)).getScript().visit(ev);\n+\n+                final StringBuilder concat = new StringBuilder();\n+                for (final String s : shadokSentences.get(j)) {\n+                    concat.append(s);\n+                }\n+                Assert.assertEquals(concat.toString(), ev.getString());\n+            }\n+        }\n+    }\n+\n+    private List<Character> sequence(final String string) {\n+        final List<Character> list = new ArrayList<Character>();\n+        for (int i = 0; i < string.length(); ++i) {\n+            list.add(new Character(string.charAt(i)));\n+        }\n+        return list;\n+    }\n+\n+    private class ExecutionVisitor<T> implements CommandVisitor<T> {\n+\n+        private List<T> v;\n+        private int index;\n+\n+        public void setList(final List<T> array) {\n+            v = new ArrayList<T>(array);\n+            index = 0;\n+        }\n+\n+        public void visitInsertCommand(final T object) {\n+            v.add(index++, object);\n+        }\n+\n+        public void visitKeepCommand(final T object) {\n+            ++index;\n+        }\n+\n+        public void visitDeleteCommand(final T object) {\n+            v.remove(index);\n+        }\n+\n+        public String getString() {\n+            final StringBuffer buffer = new StringBuffer();\n+            for (final T c : v) {\n+                buffer.append(c);\n+            }\n+            return buffer.toString();\n+        }\n+\n+    }\n+\n+    @Before\n+    public void setUp() {\n+\n+        before = Arrays.asList(new String[] {\n+            \"bottle\",\n+            \"nematode knowledge\",\n+            \"\",\n+            \"aa\",\n+            \"prefixed string\",\n+            \"ABCABBA\",\n+            \"glop glop\",\n+            \"coq\",\n+            \"spider-man\"\n+        });\n+\n+        after = Arrays.asList(new String[] {\n+            \"noodle\",\n+            \"empty bottle\",\n+            \"\",\n+            \"C\",\n+            \"prefix\",\n+            \"CBABAC\",\n+            \"pas glop pas glop\",\n+            \"ane\",\n+            \"klingon\"\n+        });\n+\n+        length = new int[] {\n+            6,\n+            16,\n+            0,\n+            3,\n+            9,\n+            5,\n+            8,\n+            6,\n+            13\n+        };\n+\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        before = null;\n+        after  = null;\n+        length = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractAnyAllOnePredicateTest.java\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Predicate;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+\n+/**\n+ * Base class for tests of AnyPredicate, AllPredicate, and OnePredicate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractAnyAllOnePredicateTest<T> extends AbstractCompositePredicateTest<T> {\n+\n+    /**\n+     * Creates a new <code>TestCompositePredicate</code>.\n+     *\n+     * @param testValue the value which the mock predicates should expect to see (may be null).\n+     */\n+    protected AbstractAnyAllOnePredicateTest(final T testValue) {\n+        super(testValue);\n+    }\n+\n+    /**\n+     * Tests whether <code>getInstance</code> with a one element array returns the first element in the array.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public final void singleElementArrayToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(predicate);\n+        assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests that passing a singleton collection to <code>getInstance</code> returns the single element in the\n+     * collection.\n+     */\n+    @Override\n+    @Test\n+    public final void singletonCollectionToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(\n+                Collections.<Predicate<T>>singleton(predicate));\n+        assertSame(\"expected singleton collection member to be returned by getInstance()\",\n+                predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests creating composite predicate instances with single predicates and verifies that the composite returns\n+     * the same value as the single predicate does. \n+     */\n+    @SuppressWarnings(\"boxing\")\n+    public final void singleValues() {\n+        assertTrue(getPredicateInstance(true).evaluate(null));\n+        assertFalse(getPredicateInstance(false).evaluate(null));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractClosureTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public abstract class AbstractClosureTest {\n+\n+    @Test\n+    public void closureSanityTests() throws Exception {\n+        final Closure<?> closure = generateClosure();\n+        Assert.assertNotNull(closure);\n+    }\n+\n+    /**\n+     * @return a closure for general sanity tests.\n+     */\n+    protected abstract <T> Closure<T> generateClosure();\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+/**\n+ * Base class for tests of composite predicates.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractCompositePredicateTest<T> extends AbstractMockPredicateTest<T> {\n+\n+    /**\n+     * Creates a new <code>TestCompositePredicate</code>.\n+     *\n+     * @param testValue the value which the mock predicates should expect to see (may be null).\n+     */\n+    protected AbstractCompositePredicateTest(final T testValue) {\n+        super(testValue);\n+    }\n+\n+    /**\n+     * Creates an instance of the predicate to test.\n+     *\n+     * @param predicates the arguments to <code>getInstance</code>.\n+     *\n+     * @return a predicate to test.\n+     */\n+    protected abstract Predicate<T> getPredicateInstance(final Predicate<? super T> ... predicates);\n+\n+    /**\n+     * Creates an instance of the predicate to test.\n+     *\n+     * @param predicates the argument to <code>getInstance</code>.\n+     *\n+     * @return a predicate to test.\n+     */\n+    protected abstract Predicate<T> getPredicateInstance(final Collection<Predicate<T>> predicates);\n+\n+    /**\n+     * Creates an instance of the predicate to test.\n+     *\n+     * @param mockReturnValues the return values for the mock predicates, or null if that mock is not expected\n+     *                         to be called\n+     *\n+     * @return a predicate to test.\n+     */\n+    protected final Predicate<T> getPredicateInstance(final Boolean... mockReturnValues) {\n+        final List<Predicate<T>> predicates = new ArrayList<Predicate<T>>();\n+        for (final Boolean returnValue : mockReturnValues) {\n+            predicates.add(createMockPredicate(returnValue));\n+        }\n+        return getPredicateInstance(predicates);\n+    }\n+\n+    /**\n+     * Tests whether <code>getInstance</code> with a one element array returns the first element in the array.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void singleElementArrayToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(predicate);\n+        Assert.assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests that passing a singleton collection to <code>getInstance</code> returns the single element in the\n+     * collection.\n+     */\n+    public void singletonCollectionToGetInstance() {\n+        final Predicate<T> predicate = createMockPredicate(null);\n+        final Predicate<T> allPredicate = getPredicateInstance(\n+                Collections.<Predicate<T>>singleton(predicate));\n+        Assert.assertSame(\"expected argument to be returned by getInstance()\", predicate, allPredicate);\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with a null predicate array.\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullArrayToGetInstance() {\n+        getPredicateInstance((Predicate<T>[]) null);\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with a single null element in the predicate array.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullElementInArrayToGetInstance() {\n+        getPredicateInstance(new Predicate[] { null });\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with two null elements in the predicate array.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullElementsInArrayToGetInstance() {\n+        getPredicateInstance(new Predicate[] { null, null });\n+    }\n+\n+\n+    /**\n+     * Tests <code>getInstance</code> with a null predicate collection\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullCollectionToGetInstance() {\n+        getPredicateInstance((Collection<Predicate<T>>) null);\n+    }\n+\n+    /**\n+     * Tests <code>getInstance</code> with a predicate collection that contains null elements\n+     */\n+    @Test(expected = IllegalArgumentException.class)\n+    public final void nullElementsInCollectionToGetInstance() {\n+        final Collection<Predicate<T>> coll = new ArrayList<Predicate<T>>();\n+        coll.add(null);\n+        coll.add(null);\n+        getPredicateInstance(coll);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import static org.easymock.EasyMock.verify;\n+import static org.easymock.EasyMock.replay;\n+import org.junit.Before;\n+import org.junit.After;\n+import org.apache.commons.collections4.Predicate;\n+import org.easymock.EasyMock;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Base class for tests of predicates which delegate to other predicates when evaluating an object.  This class\n+ * provides methods to create and verify mock predicates to which to delegate.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMockPredicateTest<T> {\n+    /**\n+     * Mock predicates created by a single test case which need to be verified after the test completes.\n+     */\n+    private List<Predicate<? super T>> mockPredicatesToVerify;\n+    \n+    /**\n+     * The value to pass to mocks.\n+     */\n+    private final T testValue;\n+\n+    /**\n+     * Creates a new <code>PredicateTestBase</code>.\n+     *\n+     * @param testValue the value to pass to mock predicates.\n+     */\n+    protected AbstractMockPredicateTest(final T testValue) {\n+        this.testValue = testValue;\n+    }\n+\n+    /**\n+     * Creates the list of predicates to verify.\n+     */\n+    @Before\n+    public final void createVerifyList()\n+    {\n+        mockPredicatesToVerify = new ArrayList<Predicate<? super T>>();\n+    }\n+\n+    /**\n+     * Verifies all the mock predicates created for the test.\n+     */\n+    @After\n+    public final void verifyPredicates()\n+    {\n+        for (final Predicate<? super T> predicate : mockPredicatesToVerify) {\n+            verify(predicate);\n+        }\n+    }\n+\n+    /**\n+     * Gets the value which will be passed to the mock predicates.\n+     *\n+     * @return the test value.\n+     */\n+    protected final T getTestValue() {\n+        return testValue;\n+    }\n+\n+    /**\n+     * Creates a single mock predicate.\n+     *\n+     * @param returnValue the return value for the mock predicate, or null if the mock is not expected to be called.\n+     *\n+     * @return a single mock predicate.\n+     */\n+    @SuppressWarnings({\"unchecked\", \"boxing\"})\n+    protected final Predicate<T> createMockPredicate(final Boolean returnValue) {\n+        final Predicate<T> mockPredicate = EasyMock.createMock(Predicate.class);\n+        if (returnValue != null) {\n+            EasyMock.expect(mockPredicate.evaluate(testValue)).andReturn(returnValue);\n+        }\n+        replay(mockPredicate);\n+        mockPredicatesToVerify.add(mockPredicate);\n+\n+        return mockPredicate;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public abstract class AbstractPredicateTest {\n+    protected Object cObject;\n+    protected String cString;\n+    protected Integer cInteger;\n+\n+    @Before\n+    public void initialiseTestObjects() throws Exception {\n+        cObject = new Object();\n+        cString = \"Hello\";\n+        cInteger = new Integer(6);\n+    }\n+    \n+    @Test\n+    public void predicateSanityTests() throws Exception {\n+        final Predicate<?> predicate = generatePredicate();\n+        Assert.assertNotNull(predicate);\n+    }\n+\n+    /**\n+     * @return a predicate for general sanity tests.\n+     */\n+    protected abstract Predicate<?> generatePredicate();\n+\n+    protected <T> void assertFalse(final Predicate<T> predicate, final T testObject) {\n+        Assert.assertFalse(predicate.evaluate(testObject));\n+    }\n+\n+    protected <T> void assertTrue(final Predicate<T> predicate, final T testObject) {\n+        Assert.assertTrue(predicate.evaluate(testObject));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.AllPredicate;\n+\n+import static org.apache.commons.collections4.functors.AllPredicate.allPredicate;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+/**\n+ * Tests the org.apache.commons.collections.functors.AllPredicate class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class AllPredicateTest extends AbstractAnyAllOnePredicateTest<Integer> {\n+\n+    /**\n+     * Creates a new <code>TestAllPredicate</code>.\n+     */\n+    public AllPredicateTest() {\n+        super(42);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected final Predicate<Integer> getPredicateInstance(final Predicate<? super Integer> ... predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */    \n+    @Override\n+    protected final Predicate<Integer> getPredicateInstance(final Collection<Predicate<Integer>> predicates) {\n+        return AllPredicate.allPredicate(predicates);\n+    }\n+\n+    /**\n+     * Verifies that providing an empty predicate array evaluates to true.\n+     */\n+    @SuppressWarnings({\"unchecked\"})\n+    @Test\n+    public void emptyArrayToGetInstance() {\n+        assertTrue(\"empty array not true\", getPredicateInstance(new Predicate[] {}).evaluate(null));\n+    }\n+\n+    /**\n+     * Verifies that providing an empty predicate collection evaluates to true.\n+     */\n+    @Test\n+    public void emptyCollectionToGetInstance() {\n+        final Predicate<Integer> allPredicate = getPredicateInstance(\n+                Collections.<Predicate<Integer>>emptyList());\n+        assertTrue(\"empty collection not true\", allPredicate.evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether a single true predicate evaluates to true.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void oneTruePredicate() {\n+        // use the constructor directly, as getInstance() returns the original predicate when passed\n+        // an array of size one.\n+        final Predicate<Integer> predicate = createMockPredicate(true);\n+        \n+        assertTrue(\"single true predicate evaluated to false\",\n+                allPredicate(predicate).evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether a single false predicate evaluates to true.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Test\n+    public void oneFalsePredicate() {\n+        // use the constructor directly, as getInstance() returns the original predicate when passed\n+        // an array of size one.\n+        final Predicate<Integer> predicate = createMockPredicate(false);\n+        assertFalse(\"single false predicate evaluated to true\",\n+                allPredicate(predicate).evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether multiple true predicates evaluates to true.\n+     */\n+    @Test\n+    public void allTrue() {\n+        assertTrue(\"multiple true predicates evaluated to false\",\n+                getPredicateInstance(true, true).evaluate(getTestValue()));\n+        assertTrue(\"multiple true predicates evaluated to false\",\n+                getPredicateInstance(true, true, true).evaluate(getTestValue()));\n+    }\n+\n+    /**\n+     * Tests whether combining some true and one false evalutes to false.  Also verifies that only the first\n+     * false predicate is actually evaluated\n+     */\n+    @Test\n+    public void trueAndFalseCombined() {\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(false, null).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(false, null, null).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(true, false, null).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(true, true, false).evaluate(getTestValue()));\n+        assertFalse(\"false predicate evaluated to true\",\n+                getPredicateInstance(true, true, false, null).evaluate(getTestValue()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.collections4.Closure;\n+import org.apache.commons.collections4.FunctorException;\n+import org.apache.commons.collections4.functors.CatchAndRethrowClosure;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class CatchAndRethrowClosureTest extends AbstractClosureTest {\n+\n+    private static <T> Closure<T> generateIOExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(final T input) throws IOException  {\n+                throw new IOException();\n+            }\n+        };\n+    }\n+\n+    private static <T> Closure<T> generateNullPointerExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(final T input) {\n+                throw new NullPointerException();\n+            }\n+        };\n+    }\n+\n+    private static <T> Closure<T> generateNoExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(final T input) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected <T> Closure<T> generateClosure() {\n+        return generateNoExceptionClosure();\n+    }\n+    \n+    @Test\n+    public void testThrowingClosure() {\n+        Closure<Integer> closure = generateNoExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+        } catch (final FunctorException ex) {\n+            Assert.fail();\n+        } catch (final RuntimeException ex) {\n+            Assert.fail();\n+        }\n+        \n+        closure = generateIOExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+            Assert.fail();\n+        } catch (final FunctorException ex) {\n+            Assert.assertTrue(ex.getCause() instanceof IOException);\n+        } catch (final RuntimeException ex) {\n+            Assert.fail();\n+        }\n+\n+        closure = generateNullPointerExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+            Assert.fail();\n+        } catch (final FunctorException ex) {\n+            Assert.fail();\n+        } catch (final RuntimeException ex) {\n+            Assert.assertTrue(ex instanceof NullPointerException);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/ComparatorPredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import static org.apache.commons.collections4.functors.ComparatorPredicate.*;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.junit.Test;\n+\n+\n+public class ComparatorPredicateTest extends AbstractPredicateTest {\n+    private class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n+        public int compare(final T first, final T second) {\n+            return first.compareTo(second);\n+        }\n+    }\n+\n+    @Test\n+    public void compareEquals() {\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareGreater() {\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n+        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n+        assertFalse(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareLess() {\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertFalse(p, Integer.valueOf(value.intValue()));\n+        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareGreaterOrEqual() {\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n+        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareLessOrEqual() {\n+        final Integer value = Integer.valueOf(10);\n+        final Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+    \n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/EqualPredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import static org.apache.commons.collections4.functors.EqualPredicate.equalPredicate;\n+import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate;\n+import static org.junit.Assert.assertSame;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.junit.Test;\n+\n+\n+public class EqualPredicateTest extends AbstractPredicateTest {\n+    private static final EqualsTestObject FALSE_OBJECT = new EqualsTestObject(false);\n+    private static final EqualsTestObject TRUE_OBJECT = new EqualsTestObject(true);\n+\n+    @Override\n+    protected Predicate<Object> generatePredicate() {\n+       return equalPredicate(null);\n+    }\n+    \n+    @Test\n+    public void testNullArgumentEqualsNullPredicate() throws Exception {\n+        assertSame(nullPredicate(), equalPredicate(null));\n+    }\n+    \n+    @Test\n+    public void objectFactoryUsesEqualsForTest() throws Exception {\n+        final Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);\n+        assertFalse(predicate, FALSE_OBJECT);\n+        assertTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);\n+    }\n+    \n+    @SuppressWarnings(\"boxing\")\n+    @Test\n+    public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {\n+        final Predicate<Number> predicate = equalPredicate((Number) 4);\n+        assertTrue(predicate, 4);\n+    }\n+\n+    public static class EqualsTestObject {\n+        private final boolean b;\n+\n+        public EqualsTestObject(final boolean b) {\n+            this.b = b;\n+        }\n+        \n+        @Override\n+        public boolean equals(final Object obj) {\n+            return b;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/functors/NullPredicateTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.functors;\n+\n+import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate;\n+import static org.junit.Assert.assertSame;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.NullPredicate;\n+import org.junit.Test;\n+\n+\n+public class NullPredicateTest extends AbstractPredicateTest {\n+    @Test\n+    public void testNullPredicate() {\n+        assertSame(NullPredicate.nullPredicate(), NullPredicate.nullPredicate());\n+        assertTrue(nullPredicate(), null);\n+    }\n+    \n+    public void ensurePredicateCanBeTypedWithoutWarning() throws Exception {\n+        final Predicate<String> predicate = NullPredicate.nullPredicate();\n+        assertFalse(predicate, cString);\n+    }\n+\n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return nullPredicate();\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+\n+/**\n+ * Abstract class for testing the Iterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of Iterator.\n+ * Concrete subclasses must provide the iterator to be tested.\n+ * They must also specify certain details of how the iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractIteratorTest<E> extends AbstractObjectTest {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test class name\n+     */\n+    public AbstractIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return an iterator over an empty collection.\n+     * \n+     * @return an empty iterator\n+     */\n+    public abstract Iterator<E> makeEmptyIterator();\n+\n+    /**\n+     * Implements the abstract superclass method to return the full iterator.\n+     * \n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract Iterator<E> makeObject();\n+\n+    /**\n+     * Whether or not we are testing an iterator that can be empty.\n+     * Default is true.\n+     * \n+     * @return true if Iterator can be empty\n+     */\n+    public boolean supportsEmptyIterator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that can contain elements.\n+     * Default is true.\n+     * \n+     * @return true if Iterator can be full\n+     */\n+    public boolean supportsFullIterator() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports remove().\n+     * Default is true.\n+     * \n+     * @return true if Iterator supports remove\n+     */\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    /**\n+     * Allows subclasses to add complex cross verification\n+     */\n+    public void verify() {\n+        // do nothing\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test the empty iterator.\n+     */\n+    public void testEmptyIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        final Iterator<E> it = makeEmptyIterator();\n+        \n+        // hasNext() should return false\n+        assertEquals(\"hasNext() should return false for empty iterators\", false, it.hasNext());\n+        \n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+        verify();\n+        \n+        assertNotNull(it.toString());\n+    }\n+\n+    /**\n+     * Test normal iteration behaviour.\n+     */\n+    public void testFullIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        final Iterator<E> it = makeObject();\n+\n+        // hasNext() must be true (ensure makeFullIterator is correct!)\n+        assertEquals(\"hasNext() should return true for at least one element\", true, it.hasNext());\n+\n+        // next() must not throw exception (ensure makeFullIterator is correct!)\n+        try {\n+            it.next();\n+        } catch (final NoSuchElementException e) {\n+            fail(\"Full iterators must have at least one element\");\n+        }\n+\n+        // iterate through\n+        while (it.hasNext()) {\n+            it.next();\n+            verify();\n+        }\n+\n+        // next() must throw NoSuchElementException now\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+        \n+        assertNotNull(it.toString());\n+    }\n+\n+    /**\n+     * Test remove behaviour.\n+     */\n+    public void testRemove() {\n+        final Iterator<E> it = makeObject();\n+        \n+        if (supportsRemove() == false) {\n+            // check for UnsupportedOperationException if not supported\n+            try {\n+                it.remove();\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        \n+        // should throw IllegalStateException before next() called\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        verify();\n+        \n+        // remove after next should be fine\n+        it.next();\n+        it.remove();\n+        \n+        // should throw IllegalStateException for second remove()\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Abstract class for testing the ListIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of ListIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractListIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     *\n+     * @return an empty iterator\n+     */\n+    @Override\n+    public abstract ListIterator<E> makeEmptyIterator();\n+\n+    /**\n+     * Implements the abstract superclass method to return the list iterator.\n+     *\n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract ListIterator<E> makeObject();\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports add().\n+     * Default is true.\n+     *\n+     * @return true if Iterator supports add\n+     */\n+    public boolean supportsAdd() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports set().\n+     * Default is true.\n+     *\n+     * @return true if Iterator supports set\n+     */\n+    public boolean supportsSet() {\n+        return true;\n+    }\n+\n+    /**\n+     * The value to be used in the add and set tests.\n+     * Default is null.\n+     */\n+    public E addSetValue() {\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    public void testEmptyListIteratorIsIndeedEmpty() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        final ListIterator<E> it = makeEmptyIterator();\n+\n+        assertEquals(false, it.hasNext());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+\n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+\n+        // previous() should throw a NoSuchElementException\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+    }\n+\n+    /**\n+     * Test navigation through the iterator.\n+     */\n+    public void testWalkForwardAndBack() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        final ListIterator<E> it = makeObject();\n+        while (it.hasNext()) {\n+            list.add(it.next());\n+        }\n+\n+        // check state at end\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+\n+        // loop back through comparing\n+        for (int i = list.size() - 1; i >= 0; i--) {\n+            assertEquals(i + 1, it.nextIndex());\n+            assertEquals(i, it.previousIndex());\n+\n+            final Object obj = list.get(i);\n+            assertEquals(obj, it.previous());\n+        }\n+\n+        // check state at start\n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from previous at start of ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+    }\n+\n+    /**\n+     * Test add behaviour.\n+     */\n+    public void testAdd() {\n+        ListIterator<E> it = makeObject();\n+\n+        final E addValue = addSetValue();\n+        if (supportsAdd() == false) {\n+            // check for UnsupportedOperationException if not supported\n+            try {\n+                it.add(addValue);\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        // add at start should be OK, added should be previous\n+        it = makeObject();\n+        it.add(addValue);\n+        assertEquals(addValue, it.previous());\n+\n+        // add at start should be OK, added should not be next\n+        it = makeObject();\n+        it.add(addValue);\n+        assertTrue(addValue != it.next());\n+\n+        // add in middle and at end should be OK\n+        it = makeObject();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.add(addValue);\n+            // check add OK\n+            assertEquals(addValue, it.previous());\n+            it.next();\n+        }\n+    }\n+\n+    /**\n+     * Test set behaviour.\n+     */\n+    public void testSet() {\n+        final ListIterator<E> it = makeObject();\n+\n+        if (supportsSet() == false) {\n+            // check for UnsupportedOperationException if not supported\n+            try {\n+                it.set(addSetValue());\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        // should throw IllegalStateException before next() called\n+        try {\n+            it.set(addSetValue());\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+\n+        // set after next should be fine\n+        it.next();\n+        it.set(addSetValue());\n+\n+        // repeated set calls should be fine\n+        it.set(addSetValue());\n+\n+    }\n+\n+    public void testRemoveThenSet() {\n+        final ListIterator<E> it = makeObject();\n+        if (supportsRemove() && supportsSet()) {\n+            it.next();\n+            it.remove();\n+            try {\n+                it.set(addSetValue());\n+                fail(\"IllegalStateException must be thrown from set after remove\");\n+            } catch (final IllegalStateException e) {\n+            }\n+        }\n+    }\n+\n+    public void testAddThenSet() {\n+        final ListIterator<E> it = makeObject();\n+        // add then set\n+        if (supportsAdd() && supportsSet()) {\n+            it.next();\n+            it.add(addSetValue());\n+            try {\n+                it.set(addSetValue());\n+                fail(\"IllegalStateException must be thrown from set after add\");\n+            } catch (final IllegalStateException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test remove after add behaviour.\n+     */\n+    public void testAddThenRemove() {\n+        final ListIterator<E> it = makeObject();\n+\n+        // add then remove\n+        if (supportsAdd() && supportsRemove()) {\n+            it.next();\n+            it.add(addSetValue());\n+            try {\n+                it.remove();\n+                fail(\"IllegalStateException must be thrown from remove after add\");\n+            } catch (final IllegalStateException e) {\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.MapIterator;\n+\n+/**\n+ * Abstract class for testing the MapIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of MapIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapIteratorTest<K, V> extends AbstractIteratorTest<K> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractMapIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implement this method to return a map iterator over an empty map.\n+     *\n+     * @return an empty iterator\n+     */\n+    @Override\n+    public abstract MapIterator<K, V> makeEmptyIterator();\n+\n+    /**\n+     * Implement this method to return a map iterator over a map with elements.\n+     *\n+     * @return a full iterator\n+     */\n+    @Override\n+    public abstract MapIterator<K, V> makeObject();\n+\n+    /**\n+     * Implement this method to return the map which contains the same data as the\n+     * iterator.\n+     *\n+     * @return a full map which can be updated\n+     */\n+    public abstract Map<K, V> getMap();\n+\n+    /**\n+     * Implement this method to return the confirmed map which contains the same\n+     * data as the iterator.\n+     *\n+     * @return a full map which can be updated\n+     */\n+    public abstract Map<K, V> getConfirmedMap();\n+\n+    /**\n+     * Whether or not we are testing an iterator that supports setValue().\n+     * Default is true.\n+     *\n+     * @return true if Iterator supports set\n+     */\n+    public boolean supportsSetValue() {\n+        return true;\n+    }\n+\n+    /**\n+     * Whether the get operation on the map structurally modifies the map,\n+     * such as with LRUMap. Default is false.\n+     *\n+     * @return true if the get method structurally modifies the map\n+     */\n+    public boolean isGetStructuralModify() {\n+        return false;\n+    }\n+\n+    /**\n+     * The values to be used in the add and set tests.\n+     * Default is two strings.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] addSetValues() {\n+        return (V[]) new Object[] { \"A\", \"B\" };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    public void testEmptyMapIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        final MapIterator<K, V> it = makeEmptyIterator();\n+        assertEquals(false, it.hasNext());\n+\n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+\n+        // getKey() should throw an IllegalStateException\n+        try {\n+            it.getKey();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+\n+        // getValue() should throw an IllegalStateException\n+        try {\n+            it.getValue();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+\n+        if (supportsSetValue() == false) {\n+            // setValue() should throw an UnsupportedOperationException/IllegalStateException\n+            try {\n+                it.setValue(addSetValues()[0]);\n+                fail();\n+            } catch (final UnsupportedOperationException ex) {\n+            } catch (final IllegalStateException ex) {}\n+        } else {\n+            // setValue() should throw an IllegalStateException\n+            try {\n+                it.setValue(addSetValues()[0]);\n+                fail();\n+            } catch (final IllegalStateException ex) {}\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the full list iterator contract is correct.\n+     */\n+    public void testFullMapIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+        assertEquals(true, it.hasNext());\n+\n+        assertEquals(true, it.hasNext());\n+        final Set<K> set = new HashSet<K>();\n+        while (it.hasNext()) {\n+            // getKey\n+            final K key = it.next();\n+            assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.add(key));\n+\n+            // getValue\n+            final V value = it.getValue();\n+            if (isGetStructuralModify() == false) {\n+                assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            }\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+\n+            verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSet() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        final V newValue = addSetValues()[0];\n+        final V newValue2 = addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1];\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n+        final V value = it.getValue();\n+\n+        if (supportsSetValue() == false) {\n+            try {\n+                it.setValue(newValue);\n+                fail();\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+        final V old = it.setValue(newValue);\n+        confirmed.put(key, newValue);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        assertSame(\"setValue must return old value\", value, old);\n+        assertEquals(\"Map must contain key\", true, map.containsKey(key));\n+        // test against confirmed, as map may contain value twice\n+        assertEquals(\"Map must not contain old value\",\n+            confirmed.containsValue(old), map.containsValue(old));\n+        assertEquals(\"Map must contain new value\", true, map.containsValue(newValue));\n+        verify();\n+\n+        it.setValue(newValue);  // same value - should be OK\n+        confirmed.put(key, newValue);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue, it.getValue());\n+        verify();\n+\n+        it.setValue(newValue2);  // new value\n+        confirmed.put(key, newValue2);\n+        assertSame(\"Key must not change after setValue\", key, it.getKey());\n+        assertSame(\"Value must be changed after setValue\", newValue2, it.getValue());\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testRemove() { // override\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n+\n+        if (supportsRemove() == false) {\n+            try {\n+                it.remove();\n+                fail();\n+            } catch (final UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+\n+        it.remove();\n+        confirmed.remove(key);\n+        assertEquals(false, map.containsKey(key));\n+        verify();\n+\n+        try {\n+            it.remove();  // second remove fails\n+        } catch (final IllegalStateException ex) {\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSetRemoveSet() {\n+        if (supportsSetValue() == false || supportsRemove() == false) {\n+            return;\n+        }\n+        final V newValue = addSetValues()[0];\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n+\n+        it.setValue(newValue);\n+        it.remove();\n+        confirmed.remove(key);\n+        verify();\n+\n+        try {\n+            it.setValue(newValue);\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorRemoveGetKey() {\n+        if (supportsRemove() == false) {\n+            return;\n+        }\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n+\n+        it.remove();\n+        confirmed.remove(key);\n+        verify();\n+\n+        try {\n+            it.getKey();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorRemoveGetValue() {\n+        if (supportsRemove() == false) {\n+            return;\n+        }\n+        final MapIterator<K, V> it = makeObject();\n+        final Map<K, V> confirmed = getConfirmedMap();\n+\n+        assertEquals(true, it.hasNext());\n+        final K key = it.next();\n+\n+        it.remove();\n+        confirmed.remove(key);\n+        verify();\n+\n+        try {\n+            it.getValue();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+        verify();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.OrderedMapIterator;\n+\n+/**\n+ * Abstract class for testing the OrderedMapIterator interface.\n+ * <p>\n+ * This class provides a framework for testing an implementation of MapIterator.\n+ * Concrete subclasses must provide the list iterator to be tested.\n+ * They must also specify certain details of how the list iterator operates by\n+ * overriding the supportsXxx() methods if necessary.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractOrderedMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractOrderedMapIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public abstract OrderedMapIterator<K, V> makeEmptyIterator();\n+\n+    @Override\n+    public abstract OrderedMapIterator<K, V> makeObject();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the empty list iterator contract is correct.\n+     */\n+    @Override\n+    public void testEmptyMapIterator() {\n+        if (supportsEmptyIterator() == false) {\n+            return;\n+        }\n+\n+        super.testEmptyMapIterator();\n+\n+        final OrderedMapIterator<K, V> it = makeEmptyIterator();\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the full list iterator contract is correct.\n+     */\n+    @Override\n+    public void testFullMapIterator() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        super.testFullMapIterator();\n+\n+        final OrderedMapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        final Set<K> set = new HashSet<K>();\n+        while (it.hasNext()) {\n+            // getKey\n+            final K key = it.next();\n+            assertSame(\"it.next() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.add(key));\n+\n+            // getValue\n+            final V value = it.getValue();\n+            if (isGetStructuralModify() == false) {\n+                assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            }\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+\n+            assertEquals(true, it.hasPrevious());\n+\n+            verify();\n+        }\n+        while (it.hasPrevious()) {\n+            // getKey\n+            final Object key = it.previous();\n+            assertSame(\"it.previous() should equals getKey()\", key, it.getKey());\n+            assertTrue(\"Key must be in map\",  map.containsKey(key));\n+            assertTrue(\"Key must be unique\", set.remove(key));\n+\n+            // getValue\n+            final Object value = it.getValue();\n+            if (isGetStructuralModify() == false) {\n+                assertSame(\"Value must be mapped to key\", map.get(key), value);\n+            }\n+            assertTrue(\"Value must be in map\",  map.containsValue(value));\n+\n+            assertEquals(true, it.hasNext());\n+\n+            verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test that the iterator order matches the keySet order.\n+     */\n+    public void testMapIteratorOrder() {\n+        if (supportsFullIterator() == false) {\n+            return;\n+        }\n+\n+        final OrderedMapIterator<K, V> it = makeObject();\n+        final Map<K, V> map = getMap();\n+\n+        assertEquals(\"keySet() not consistent\", new ArrayList<K>(map.keySet()), new ArrayList<K>(map.keySet()));\n+\n+        final Iterator<K> it2 = map.keySet().iterator();\n+        assertEquals(true, it.hasNext());\n+        assertEquals(true, it2.hasNext());\n+        final List<K> list = new ArrayList<K>();\n+        while (it.hasNext()) {\n+            final K key = it.next();\n+            assertEquals(it2.next(), key);\n+            list.add(key);\n+        }\n+        assertEquals(map.size(), list.size());\n+        while (it.hasPrevious()) {\n+            final K key = it.previous();\n+            assertEquals(list.get(list.size() - 1), key);\n+            list.remove(list.size() - 1);\n+        }\n+        assertEquals(0, list.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ArrayIterator2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.ArrayIterator;\n+\n+/**\n+ * Tests the ArrayIterator with primitive type arrays.\n+ *\n+ * @version $Id$\n+ */\n+public class ArrayIterator2Test<E> extends AbstractIteratorTest<E> {\n+\n+    protected int[] testArray = { 2, 4, 6, 8 };\n+\n+    public ArrayIterator2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeEmptyIterator() {\n+        return new ArrayIterator<E>(new int[0]);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeObject() {\n+        return new ArrayIterator<E>(testArray);\n+    }\n+\n+    public ArrayIterator<E> makeArrayIterator(final Object array) {\n+        return new ArrayIterator<E>(array);\n+    }\n+\n+    public ArrayIterator<E> makeArrayIterator(final Object array, final int index) {\n+        return new ArrayIterator<E>(array, index);\n+    }\n+\n+    public ArrayIterator<E> makeArrayIterator(final Object array, final int start, final int end) {\n+        return new ArrayIterator<E>(array, start, end);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<E> iter = makeObject();\n+        for (final int element : testArray) {\n+            final Integer testValue = new Integer(element);\n+            final Number iterValue = (Number) iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    // proves that an ArrayIterator set with the constructor has the same number of elements\n+    // as an ArrayIterator set with setArray(Object)\n+    public void testSetArray() {\n+        final Iterator<E> iter1 = makeArrayIterator(testArray);\n+        int count1 = 0;\n+        while (iter1.hasNext()) {\n+            ++count1;\n+            iter1.next();\n+        }\n+\n+        assertEquals(\"the count should be right using the constructor\", count1, testArray.length);\n+\n+        final ArrayIterator<E> iter2 = makeObject();\n+        iter2.setArray(testArray);\n+        int count2 = 0;\n+        while (iter2.hasNext()) {\n+            ++count2;\n+            iter2.next();\n+        }\n+\n+        assertEquals(\"the count should be right using setArray(Object)\", count2, testArray.length);\n+    }\n+\n+    public void testIndexedArray() {\n+        Iterator<E> iter = makeArrayIterator(testArray, 2);\n+        int count = 0;\n+        while (iter.hasNext()) {\n+            ++count;\n+            iter.next();\n+        }\n+\n+        assertEquals(\"the count should be right using ArrayIterator(Object,2) \", count, testArray.length - 2);\n+\n+        iter = makeArrayIterator(testArray, 1, testArray.length - 1);\n+        count = 0;\n+        while (iter.hasNext()) {\n+            ++count;\n+            iter.next();\n+        }\n+\n+        assertEquals(\n+            \"the count should be right using ArrayIterator(Object,1,\" + (testArray.length - 1) + \") \",\n+            count,\n+            testArray.length - 2);\n+\n+        try {\n+            iter = makeArrayIterator(testArray, -1);\n+            fail(\"new ArrayIterator(Object,-1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, testArray.length + 1);\n+            fail(\"new ArrayIterator(Object,length+1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, 0, -1);\n+            fail(\"new ArrayIterator(Object,0,-1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, 0, testArray.length + 1);\n+            fail(\"new ArrayIterator(Object,0,length+1) should throw an ArrayIndexOutOfBoundsException\");\n+        } catch (final ArrayIndexOutOfBoundsException aioobe) {\n+            // expected\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, 1, 1);\n+            // expected not to fail\n+        } catch (final IllegalArgumentException iae) {\n+            // MODIFIED: an iterator over a zero-length section of array\n+            //  should be perfectly legal behavior\n+            fail(\"new ArrayIterator(Object,1,1) should NOT throw an IllegalArgumentException\");\n+        }\n+\n+        try {\n+            iter = makeArrayIterator(testArray, testArray.length - 1, testArray.length - 2);\n+            fail(\"new ArrayIterator(Object,length-2,length-1) should throw an IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.ArrayIterator;\n+\n+/**\n+ * Tests the ArrayIterator to ensure that the next() method will actually\n+ * perform the iteration rather than the hasNext() method.\n+ * The code of this test was supplied by Mauricio S. Moura.\n+ *\n+ * @version $Id$\n+ */\n+public class ArrayIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+\n+    public ArrayIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeEmptyIterator() {\n+        return new ArrayIterator<E>(new Object[0]);\n+    }\n+\n+    @Override\n+    public ArrayIterator<E> makeObject() {\n+        return new ArrayIterator<E>(testArray);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    public void testNullArray() {\n+        try {\n+            new ArrayIterator<Object>(null);\n+            fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n+        } catch (final NullPointerException e) {\n+            // expected\n+        }\n+\n+        final ArrayIterator<Object> iter = new ArrayIterator<Object>();\n+        try {\n+            iter.setArray(null);\n+\n+            fail(\"setArray(null) should throw a NullPointerException\");\n+        } catch (final NullPointerException e) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testReset() {\n+        final ArrayIterator<E> it = makeObject();\n+        it.next();\n+        it.reset();\n+        assertEquals(\"One\", it.next());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ArrayListIterator2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.iterators.ArrayListIterator;\n+\n+/**\n+ * Test the ArrayListIterator class with primitives.\n+ *\n+ * @version $Id$\n+ */\n+public class ArrayListIterator2Test<E> extends ArrayIterator2Test<E> {\n+\n+    public ArrayListIterator2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeEmptyIterator() {\n+        return new ArrayListIterator<E>(new int[0]);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeObject() {\n+        return new ArrayListIterator<E>(testArray);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array) {\n+        return new ArrayListIterator<E>(array);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array, final int index) {\n+        return new ArrayListIterator<E>(array, index);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array, final int start, final int end) {\n+        return new ArrayListIterator<E>(array, start, end);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ArrayListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Arrays;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.ArrayListIterator;\n+\n+/**\n+ * Test the ArrayListIterator class.\n+ *\n+ * @version $Id$\n+ */\n+public class ArrayListIteratorTest<E> extends ArrayIteratorTest<E> {\n+\n+    public ArrayListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeEmptyIterator() {\n+        return new ArrayListIterator<E>(new Object[0]);\n+    }\n+\n+    @Override\n+    public ArrayListIterator<E> makeObject() {\n+        return new ArrayListIterator<E>(testArray);\n+    }\n+\n+    public ArrayListIterator<E> makeArrayListIterator(final Object array) {\n+        return new ArrayListIterator<E>(array);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    /**\n+     * Test the basic ListIterator functionality - going backwards using\n+     * <code>previous()</code>.\n+     */\n+    public void testListIterator() {\n+        final ListIterator<E> iter = makeObject();\n+\n+        // TestArrayIterator#testIterator() has already tested the iterator forward,\n+        //  now we need to test it in reverse\n+\n+        // fast-forward the iterator to the end...\n+        while (iter.hasNext()) {\n+            iter.next();\n+        }\n+\n+        for (int x = testArray.length - 1; x >= 0; x--) {\n+            final Object testValue = testArray[x];\n+            final Object iterValue = iter.previous();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasPrevious());\n+\n+        try {\n+            iter.previous();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+\n+    }\n+\n+    /**\n+     * Tests the {@link java.util.ListIterator#set} operation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorSet() {\n+        final String[] testData = new String[] { \"a\", \"b\", \"c\" };\n+\n+        final String[] result = new String[] { \"0\", \"1\", \"2\" };\n+\n+        ListIterator<E> iter = makeArrayListIterator(testData);\n+        int x = 0;\n+\n+        while (iter.hasNext()) {\n+            iter.next();\n+            iter.set((E) Integer.toString(x));\n+            x++;\n+        }\n+\n+        assertTrue(\"The two arrays should have the same value, i.e. {0,1,2}\", Arrays.equals(testData, result));\n+\n+        // a call to set() before a call to next() or previous() should throw an IllegalStateException\n+        iter = makeArrayListIterator(testArray);\n+\n+        try {\n+            iter.set((E) \"should fail\");\n+            fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        } catch (final Throwable t) { // should never happen\n+            fail(t.toString());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/CollatingIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.comparators.ComparableComparator;\n+import org.apache.commons.collections4.iterators.CollatingIterator;\n+\n+/**\n+ * Unit test suite for {@link CollatingIterator}.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class CollatingIteratorTest extends AbstractIteratorTest<Integer> {\n+\n+    //------------------------------------------------------------ Conventional\n+\n+    public CollatingIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //--------------------------------------------------------------- Lifecycle\n+\n+    private Comparator<Integer> comparator = null;\n+    private ArrayList<Integer> evens = null;\n+    private ArrayList<Integer> odds = null;\n+    private ArrayList<Integer> fib = null;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        comparator = new ComparableComparator<Integer>();\n+        evens = new ArrayList<Integer>();\n+        odds = new ArrayList<Integer>();\n+        for (int i = 0; i < 20; i++) {\n+            if (0 == i % 2) {\n+                evens.add(i);\n+            } else {\n+                odds.add(i);\n+            }\n+        }\n+        fib = new ArrayList<Integer>();\n+        fib.add(1);\n+        fib.add(1);\n+        fib.add(2);\n+        fib.add(3);\n+        fib.add(5);\n+        fib.add(8);\n+        fib.add(13);\n+        fib.add(21);\n+    }\n+\n+    //---------------------------------------------------- TestIterator Methods\n+\n+    @Override\n+    public CollatingIterator<Integer> makeEmptyIterator() {\n+        return new CollatingIterator<Integer>(comparator);\n+    }\n+\n+    @Override\n+    public CollatingIterator<Integer> makeObject() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(odds.iterator());\n+        iter.addIterator(fib.iterator());\n+        return iter;\n+    }\n+\n+    //------------------------------------------------------------------- Tests\n+\n+    public void testGetSetComparator() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>();\n+        assertNull(iter.getComparator());\n+        iter.setComparator(comparator);\n+        assertSame(comparator, iter.getComparator());\n+        iter.setComparator(null);\n+        assertNull(iter.getComparator());\n+    }\n+\n+    public void testIterateEven() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        for (int i = 0; i < evens.size(); i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n+            assertEquals(0,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateEvenOdd() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, evens.iterator(), odds.iterator());\n+        for (int i = 0; i < 20; i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(new Integer(i), iter.next());\n+            assertEquals(i % 2,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateOddEven() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator, odds.iterator(), evens.iterator());\n+        for (int i = 0; i < 20; i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(new Integer(i),iter.next());\n+            assertEquals(i % 2 == 0 ? 1 : 0,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateEvenEven() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(evens.iterator());\n+        for (int i = 0; i < evens.size(); i++) {\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n+            assertEquals(0,iter.getIteratorIndex());\n+            assertTrue(iter.hasNext());\n+            assertEquals(evens.get(i), iter.next());\n+            assertEquals(1,iter.getIteratorIndex());\n+        }\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testIterateFibEvenOdd() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(fib.iterator());\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(odds.iterator());\n+\n+        assertEquals(new Integer(0),iter.next());  // even   0\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(1),iter.next());  // fib    1\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(1),iter.next());  // fib    1\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(1),iter.next());  // odd    1\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(2),iter.next());  // fib    2\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(2),iter.next());  // even   2\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(3),iter.next());  // fib    3\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(3),iter.next());  // odd    3\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(4),iter.next());  // even   4\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(5),iter.next());  // fib    5\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(5),iter.next());  // odd    5\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(6),iter.next());  // even   6\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(7),iter.next());  // odd    7\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(8),iter.next());  // fib    8\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(8),iter.next());  // even   8\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(9),iter.next());  // odd    9\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(10),iter.next()); // even  10\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(11),iter.next()); // odd   11\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(12),iter.next()); // even  12\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(13),iter.next()); // fib   13\n+        assertEquals(0,iter.getIteratorIndex());\n+        assertEquals(new Integer(13),iter.next()); // odd   13\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(14),iter.next()); // even  14\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(15),iter.next()); // odd   15\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(16),iter.next()); // even  16\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(17),iter.next()); // odd   17\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(18),iter.next()); // even  18\n+        assertEquals(1,iter.getIteratorIndex());\n+        assertEquals(new Integer(19),iter.next()); // odd   19\n+        assertEquals(2,iter.getIteratorIndex());\n+        assertEquals(new Integer(21),iter.next()); // fib   21\n+        assertEquals(0,iter.getIteratorIndex());\n+\n+        assertTrue(!iter.hasNext());\n+    }\n+\n+    public void testRemoveFromSingle() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        int expectedSize = evens.size();\n+        while (iter.hasNext()) {\n+            final Object o = iter.next();\n+            final Integer val = (Integer) o;\n+            if (val.intValue() % 4 == 0) {\n+                expectedSize--;\n+                iter.remove();\n+            }\n+        }\n+        assertEquals(expectedSize,evens.size());\n+    }\n+\n+    public void testRemoveFromDouble() {\n+        final CollatingIterator<Integer> iter = new CollatingIterator<Integer>(comparator);\n+        iter.addIterator(evens.iterator());\n+        iter.addIterator(odds.iterator());\n+        int expectedSize = evens.size() + odds.size();\n+        while (iter.hasNext()) {\n+            final Object o = iter.next();\n+            final Integer val = (Integer) o;\n+            if (val.intValue() % 4 == 0 || val.intValue() % 3 == 0) {\n+                expectedSize--;\n+                iter.remove();\n+            }\n+        }\n+        assertEquals(expectedSize, evens.size() + odds.size());\n+    }\n+\n+    public void testNullComparator() {\n+       final List<Integer> l1 = Arrays.asList(1, 3, 5);\n+       final List<Integer> l2 = Arrays.asList(2, 4, 6);\n+\n+       final CollatingIterator<Integer> collatingIterator1 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n+       try {\n+           collatingIterator1.next();\n+       } catch (final NullPointerException e) {\n+           assertTrue(e.getMessage().startsWith(\"You must invoke setComparator\"));\n+       }\n+\n+       int i = 0;\n+       final CollatingIterator<Integer> collatingIterator2 = new CollatingIterator<Integer>(null, l1.iterator(), l2.iterator());\n+       collatingIterator2.setComparator(new ComparableComparator<Integer>());\n+       for ( ; collatingIterator2.hasNext(); i++ ) {\n+          final Integer n = collatingIterator2.next();\n+          assertEquals(\"wrong order\", (int)n, i + 1);\n+       }\n+       assertEquals(\"wrong size\", i, l1.size() + l2.size());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/FilterIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import static org.apache.commons.collections4.functors.TruePredicate.truePredicate;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.NotNullPredicate;\n+import org.apache.commons.collections4.iterators.ArrayIterator;\n+import org.apache.commons.collections4.iterators.FilterIterator;\n+\n+/**\n+ * Test the filter iterator.\n+ *\n+ * @version $Id$\n+ */\n+public class FilterIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    /** Creates new TestFilterIterator */\n+    public FilterIteratorTest(final String name) {\n+        super(name);\n+    }\n+\n+    private String[] array;\n+    private List<E> list;\n+    private FilterIterator<E> iterator;\n+\n+    /**\n+     * Set up instance variables required by this test case.\n+     */\n+    @Override\n+    public void setUp() {\n+        array = new String[] { \"a\", \"b\", \"c\" };\n+        initIterator();\n+    }\n+\n+    /**\n+     * Tear down instance variables required by this test case.\n+     */\n+    @Override\n+    public void tearDown() throws Exception {\n+        iterator = null;\n+    }\n+\n+    /**\n+     * Returns an full iterator wrapped in a\n+     * FilterIterator that blocks all the elements\n+     *\n+     * @return \"empty\" FilterIterator\n+     */\n+    @Override\n+    public FilterIterator<E> makeEmptyIterator() {\n+        return makeBlockAllFilter(new ArrayIterator<E>(array));\n+    }\n+\n+    /**\n+     * Returns an array with elements wrapped in a pass-through\n+     * FilterIterator\n+     * \n+     * @return a filtered iterator\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public FilterIterator<E> makeObject() {\n+        list = new ArrayList<E>(Arrays.asList((E[]) array));\n+        return makePassThroughFilter(list.iterator());\n+    }\n+\n+    public void testRepeatedHasNext() {\n+        for (int i = 0; i <= array.length; i++) {\n+            assertTrue(iterator.hasNext());\n+        }\n+    }\n+\n+    public void testRepeatedNext() {\n+        for (@SuppressWarnings(\"unused\") final String element : array) {\n+            iterator.next();\n+        }\n+        verifyNoMoreElements();\n+    }\n+\n+    public void testReturnValues() {\n+        verifyElementsInPredicate(new String[0]);\n+        verifyElementsInPredicate(new String[] { \"a\" });\n+        verifyElementsInPredicate(new String[] { \"b\" });\n+        verifyElementsInPredicate(new String[] { \"c\" });\n+        verifyElementsInPredicate(new String[] { \"a\", \"b\" });\n+        verifyElementsInPredicate(new String[] { \"a\", \"c\" });\n+        verifyElementsInPredicate(new String[] { \"b\", \"c\" });\n+        verifyElementsInPredicate(new String[] { \"a\", \"b\", \"c\" });\n+    }\n+\n+    /**\n+     * Test that when the iterator is changed, the hasNext method returns the\n+     * correct response for the new iterator.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetIterator() {\n+        final Iterator<E> iter1 = Collections.singleton((E) new Object()).iterator();\n+        final Iterator<E> iter2 = Collections.<E>emptyList().iterator();\n+\n+        final FilterIterator<E> filterIterator = new FilterIterator<E>(iter1);\n+        filterIterator.setPredicate(truePredicate());\n+        // this iterator has elements\n+        assertEquals(true, filterIterator.hasNext());\n+\n+        // this iterator has no elements\n+        filterIterator.setIterator(iter2);\n+        assertEquals(false, filterIterator.hasNext());\n+    }\n+\n+    /**\n+     * Test that when the predicate is changed, the hasNext method returns the\n+     * correct response for the new predicate.\n+     */\n+    public void testSetPredicate() {\n+        final Iterator<E> iter = Collections.singleton((E) null).iterator();\n+\n+        final FilterIterator<E> filterIterator = new FilterIterator<E>(iter);\n+        filterIterator.setPredicate(truePredicate());\n+        // this predicate matches\n+        assertEquals(true, filterIterator.hasNext());\n+\n+        // this predicate doesn't match\n+        filterIterator.setPredicate(NotNullPredicate.notNullPredicate());\n+        assertEquals(false, filterIterator.hasNext());\n+    }\n+\n+    private void verifyNoMoreElements() {\n+        assertTrue(!iterator.hasNext());\n+        try {\n+            iterator.next();\n+            fail(\"NoSuchElementException expected\");\n+        }\n+        catch (final NoSuchElementException e) {\n+            // success\n+        }\n+    }\n+\n+    private void verifyElementsInPredicate(final String[] elements) {\n+        final Predicate<E> pred = new Predicate<E>() {\n+            public boolean evaluate(final E x) {\n+                for (final String element : elements) {\n+                    if (element.equals(x)) {\n+                        return true;\n+                    }\n+                }\n+                return false;\n+            }\n+        };\n+        initIterator();\n+        iterator.setPredicate(pred);\n+        for (int i = 0; i < elements.length; i++) {\n+            final String s = (String)iterator.next();\n+            assertEquals(elements[i], s);\n+            assertTrue(i == elements.length - 1 ? !iterator.hasNext() : iterator.hasNext());\n+        }\n+        verifyNoMoreElements();\n+\n+        // test removal\n+        initIterator();\n+        iterator.setPredicate(pred);\n+        if (iterator.hasNext()) {\n+            final Object last = iterator.next();\n+            iterator.remove();\n+            assertTrue(\"Base of FilterIterator still contains removed element.\", !list.contains(last));\n+        }\n+    }\n+\n+    private void initIterator() {\n+        iterator = makeObject();\n+    }\n+\n+    /**\n+     * Returns a FilterIterator that does not filter\n+     * any of its elements\n+     *\n+     * @param i      the Iterator to \"filter\"\n+     * @return \"filtered\" iterator\n+     */\n+    protected FilterIterator<E> makePassThroughFilter(final Iterator<E> i) {\n+        final Predicate<E> pred = new Predicate<E>() {\n+                public boolean evaluate(final E x) { return true; }\n+        };\n+        return new FilterIterator<E>(i, pred);\n+    }\n+\n+    /**\n+     * Returns a FilterIterator that blocks\n+     * all of its elements\n+     *\n+     * @param i      the Iterator to \"filter\"\n+     * @return \"filtered\" iterator\n+     */\n+    protected FilterIterator<E> makeBlockAllFilter(final Iterator<E> i) {\n+        final Predicate<E> pred = new Predicate<E>() {\n+                public boolean evaluate(final E x) { return false; }\n+        };\n+        return new FilterIterator<E>(i, pred);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Random;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.PredicateUtils;\n+import org.apache.commons.collections4.iterators.FilterListIterator;\n+import org.apache.commons.collections4.list.GrowthList;\n+import org.junit.Assert;\n+\n+/**\n+ * Tests the FilterListIterator class.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class FilterListIteratorTest extends TestCase {\n+    public FilterListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    private ArrayList<Integer> list = null;\n+    private ArrayList<Integer> odds = null;\n+    private ArrayList<Integer> evens = null;\n+    private ArrayList<Integer> threes = null;\n+    private ArrayList<Integer> fours = null;\n+    private ArrayList<Integer> sixes = null;\n+    private Predicate<Integer> truePred = null;\n+    private Predicate<Integer> falsePred = null;\n+    private Predicate<Integer> evenPred = null;\n+    private Predicate<Integer> oddPred = null;\n+    private Predicate<Integer> threePred = null;\n+    private Predicate<Integer> fourPred = null;\n+    private final Random random = new Random();\n+\n+    @Override\n+    public void setUp() {\n+        list = new ArrayList<Integer>();\n+        odds = new ArrayList<Integer>();\n+        evens = new ArrayList<Integer>();\n+        threes = new ArrayList<Integer>();\n+        fours = new ArrayList<Integer>();\n+        sixes = new ArrayList<Integer>();\n+        for (int i = 0; i < 20; i++) {\n+            list.add(new Integer(i));\n+            if (i % 2 == 0) { evens.add(new Integer(i)); }\n+            if (i % 2 == 1) { odds.add(new Integer(i)); }\n+            if (i % 3 == 0) { threes.add(new Integer(i)); }\n+            if (i % 4 == 0) { fours.add(new Integer(i)); }\n+            if (i % 6 == 0) { sixes.add(new Integer(i)); }\n+        }\n+\n+        truePred = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer x) { \n+                return true;\n+            }\n+        };\n+\n+        falsePred = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer x) { \n+                return true;\n+            }\n+        };\n+\n+        evenPred = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer x) { \n+                return x % 2 == 0;\n+            }\n+        };\n+\n+        oddPred = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer x) { \n+                return x % 2 == 1;\n+            }\n+        };\n+\n+        threePred = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer x) { \n+                return x % 3 == 0;\n+            }\n+        };\n+\n+        fourPred = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer x) { \n+                return x % 4 == 0;\n+            }\n+        };\n+\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        list = null;\n+        odds = null;\n+        evens = null;\n+        threes = null;\n+        fours = null;\n+        sixes = null;\n+        truePred = null;\n+        falsePred = null;\n+        evenPred = null;\n+        oddPred = null;\n+        threePred = null;\n+        fourPred = null;\n+    }\n+\n+    public void testWalkLists() {\n+        // this just confirms that our walkLists method works OK\n+        walkLists(list,list.listIterator());\n+    }\n+\n+    public void testManual() {\n+        // do this one \"by hand\" as a sanity check\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        \n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(18), filtered.next());\n+\n+        assertEquals(new Integer(18), filtered.previous());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(0), filtered.previous());\n+    \n+        assertTrue(!filtered.hasPrevious());\n+\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(18), filtered.next());\n+\n+        assertTrue(!filtered.hasNext());\n+\n+        assertEquals(new Integer(18), filtered.previous());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(0), filtered.previous());\n+\n+        assertEquals(new Integer(0), filtered.next());\n+        assertEquals(new Integer(0), filtered.previous());\n+        assertEquals(new Integer(0), filtered.next());\n+\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+        assertEquals(new Integer(6), filtered.previous());\n+        assertEquals(new Integer(3), filtered.previous());\n+        assertEquals(new Integer(3), filtered.next());\n+        assertEquals(new Integer(6), filtered.next());\n+\n+        assertEquals(new Integer(9), filtered.next());\n+        assertEquals(new Integer(12), filtered.next());\n+        assertEquals(new Integer(15), filtered.next());\n+        assertEquals(new Integer(15), filtered.previous());\n+        assertEquals(new Integer(12), filtered.previous());\n+        assertEquals(new Integer(9), filtered.previous());\n+    }\n+\n+    public void testTruePredicate() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+        walkLists(list, filtered);\n+    }\n+    \n+    public void testFalsePredicate() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), falsePred);\n+        walkLists(new ArrayList<Integer>(), filtered);\n+    }\n+\n+    public void testEvens() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), evenPred);\n+        walkLists(evens, filtered);\n+    }\n+    \n+    public void testOdds() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), oddPred);\n+        walkLists(odds, filtered);\n+    }\n+\n+    public void testThrees() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+        walkLists(threes, filtered);\n+    }\n+\n+    public void testFours() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        walkLists(fours, filtered);\n+    }\n+\n+    public void testNestedSixes() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), threePred),\n+                                        evenPred\n+                                      );\n+        walkLists(sixes, filtered);\n+    }\n+\n+    public void testNestedSixes2() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), evenPred),\n+                                        threePred\n+                                      );\n+        walkLists(sixes, filtered);\n+    }\n+\n+    public void testNestedSixes3() {        \n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n+                                        new FilterListIterator<Integer>(list.listIterator(), threePred),\n+                                        evenPred\n+                                      );\n+        walkLists(sixes, new FilterListIterator<Integer>(filtered, truePred));\n+    }\n+\n+    public void testNextChangesPrevious() {\n+        {\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            nextNextPrevious(threes.listIterator(), filtered);\n+        }\n+    \n+        {\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            nextNextPrevious(list.listIterator(), filtered);\n+        }\n+    }\n+\n+    public void testPreviousChangesNext() {\n+        {\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n+            final ListIterator<Integer> expected = threes.listIterator();\n+            walkForward(expected,filtered);\n+            previousPreviousNext(expected,filtered);\n+        }\n+        {\n+            final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n+            final ListIterator<Integer> expected = list.listIterator();\n+            walkForward(expected, filtered);\n+            previousPreviousNext(expected, filtered);\n+        }\n+    }\n+\n+    public void testFailingHasNextBug() {\n+        final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), fourPred);\n+        final ListIterator<Integer> expected = fours.listIterator();\n+        while (expected.hasNext()) {\n+            expected.next();\n+            filtered.next();\n+        }\n+        assertTrue(filtered.hasPrevious());\n+        assertTrue(!filtered.hasNext());\n+        assertEquals(expected.previous(), filtered.previous());\n+    }\n+\n+    /**\n+     * Test for {@link \"https://issues.apache.org/jira/browse/COLLECTIONS-360 COLLECTIONS-360\"}\n+     */\n+    public void testCollections360() throws Throwable {\n+        final Collection<Predicate<Object>> var7 = new GrowthList<Predicate<Object>>();\n+        final Predicate<Object> var9 = PredicateUtils.anyPredicate(var7);\n+        final FilterListIterator<Object> var13 = new FilterListIterator<Object>(var9);\n+        Assert.assertFalse(var13.hasNext());\n+        final FilterListIterator<Object> var14 = new FilterListIterator<Object>(var9);\n+        Assert.assertFalse(var14.hasPrevious());\n+    }\n+\n+    // Utilities\n+\n+    private void walkForward(final ListIterator<?> expected, final ListIterator<?> testing) {\n+        while (expected.hasNext()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n+            assertTrue(testing.hasNext());\n+            assertEquals(expected.next(), testing.next());\n+        }\n+    }\n+\n+    private void walkBackward(final ListIterator<?> expected, final ListIterator<?> testing) {\n+        while (expected.hasPrevious()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n+            assertTrue(testing.hasPrevious());\n+            assertEquals(expected.previous(), testing.previous());\n+        }\n+    }\n+\n+    private void nextNextPrevious(final ListIterator<?> expected, final ListIterator<?> testing) {\n+        // calls to next() should change the value returned by previous()\n+        // even after previous() has been set by a call to hasPrevious()\n+        assertEquals(expected.next(), testing.next());\n+        assertEquals(expected.hasPrevious(), testing.hasPrevious());\n+        final Object expecteda = expected.next();\n+        final Object testinga = testing.next();\n+        assertEquals(expecteda, testinga);\n+        final Object expectedb = expected.previous();\n+        final Object testingb = testing.previous();\n+        assertEquals(expecteda, expectedb);\n+        assertEquals(testinga, testingb);\n+    }\n+\n+    private void previousPreviousNext(final ListIterator<?> expected, final ListIterator<?> testing) {\n+        // calls to previous() should change the value returned by next()\n+        // even after next() has been set by a call to hasNext()\n+        assertEquals(expected.previous(), testing.previous());\n+        assertEquals(expected.hasNext(), testing.hasNext());\n+        final Object expecteda = expected.previous();\n+        final Object testinga = testing.previous();\n+        assertEquals(expecteda, testinga);\n+        final Object expectedb = expected.next();\n+        final Object testingb = testing.next();\n+        assertEquals(expecteda, testingb);\n+        assertEquals(expecteda, expectedb);\n+        assertEquals(testinga, testingb);\n+    }\n+\n+    private <E> void walkLists(final List<E> list, final ListIterator<E> testing) {\n+        final ListIterator<E> expected = list.listIterator();\n+\n+        // walk all the way forward\n+        walkForward(expected,testing);\n+\n+        // walk all the way back\n+        walkBackward(expected,testing);\n+\n+        // forward,back,forward\n+        while (expected.hasNext()) {\n+            assertEquals(expected.nextIndex(), testing.nextIndex());\n+            assertEquals(expected.previousIndex(), testing.previousIndex());\n+            assertTrue(testing.hasNext());\n+            assertEquals(expected.next(), testing.next());\n+            assertTrue(testing.hasPrevious());\n+            assertEquals(expected.previous(), testing.previous());\n+            assertTrue(testing.hasNext());\n+            assertEquals(expected.next(), testing.next());\n+        }\n+\n+        // walk all the way back\n+        walkBackward(expected, testing);\n+\n+        for (int i = 0; i < list.size(); i++) {\n+            // walk forward i\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasNext());\n+                assertEquals(expected.next(), testing.next());\n+            }\n+            // walk back i/2\n+            for (int j = 0; j < i / 2; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasPrevious());\n+                assertEquals(expected.previous(), testing.previous());\n+            }\n+            // walk forward i/2\n+            for (int j = 0; j < i / 2; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasNext()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasNext());\n+                assertEquals(expected.next(), testing.next());\n+            }\n+            // walk back i\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(expected.nextIndex(), testing.nextIndex());\n+                assertEquals(expected.previousIndex(), testing.previousIndex());\n+                assertTrue(expected.hasPrevious()); // if this one fails we've got a logic error in the test\n+                assertTrue(testing.hasPrevious());\n+                assertEquals(expected.previous(), testing.previous());\n+            }\n+        }\n+\n+        // random walk\n+        final StringBuilder walkdescr = new StringBuilder(500);\n+        for (int i = 0; i < 500; i++) {\n+            if (random.nextBoolean()) {\n+                // step forward\n+                walkdescr.append(\"+\");\n+                if (expected.hasNext()) {\n+                    assertEquals(walkdescr.toString(), expected.next(), testing.next());\n+                }\n+            } else {\n+                // step backward\n+                walkdescr.append(\"-\");\n+                if (expected.hasPrevious()) {\n+                    assertEquals(walkdescr.toString(), expected.previous(), testing.previous());\n+                }\n+            }\n+            assertEquals(walkdescr.toString(), expected.nextIndex(), testing.nextIndex());\n+            assertEquals(walkdescr.toString(), expected.previousIndex(), testing.previousIndex());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.IteratorUtils;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.iterators.IteratorChain;\n+\n+/**\n+ * Tests the IteratorChain class.\n+ *\n+ * @version $Id$\n+ */\n+public class IteratorChainTest extends AbstractIteratorTest<String> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+\n+    public IteratorChainTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        list1 = new ArrayList<String>();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList<String>();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList<String>();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");        \n+    }\n+\n+    @Override\n+    public IteratorChain<String> makeEmptyIterator() {\n+        final ArrayList<String> list = new ArrayList<String>();\n+        return new IteratorChain<String>(list.iterator());\n+    }\n+\n+    @Override\n+    public IteratorChain<String> makeObject() {\n+        final IteratorChain<String> chain = new IteratorChain<String>();\n+\n+        chain.addIterator(list1.iterator());\n+        chain.addIterator(list2.iterator());\n+        chain.addIterator(list3.iterator());\n+        return chain;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<String> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\", \n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    public void testRemoveFromFilteredIterator() {\n+\n+        final Predicate<Integer> myPredicate = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer i) {\n+                return i.compareTo(new Integer(4)) < 0;\n+            }\n+        };\n+\n+        final List<Integer> list1 = new ArrayList<Integer>();\n+        final List<Integer> list2 = new ArrayList<Integer>();\n+\n+        list1.add(new Integer(1));\n+        list1.add(new Integer(2));\n+        list2.add(new Integer(3));\n+        list2.add(new Integer(4)); // will be ignored by the predicate\n+\n+        final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n+        final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n+\n+        final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, list1.size());\n+        assertEquals(1, list2.size());\n+    }\n+    \n+    @Override\n+    public void testRemove() {\n+        final Iterator<String> iter = makeObject();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Calling remove before the first call to next() should throw an exception\");\n+        } catch (final IllegalStateException e) {\n+\n+        }\n+\n+        for (final String testValue : testArray) {\n+            final String iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+            if (!iterValue.equals(\"Four\")) {\n+                iter.remove();\n+            }\n+        }\n+\n+        assertTrue(\"List is empty\",list1.size() == 0);\n+        assertTrue(\"List is empty\",list2.size() == 1);\n+        assertTrue(\"List is empty\",list3.size() == 0);\n+    }\n+\n+    public void testFirstIteratorIsEmptyBug() {\n+        final List<String> empty = new ArrayList<String>();\n+        final List<String> notEmpty = new ArrayList<String>();\n+        notEmpty.add(\"A\");\n+        notEmpty.add(\"B\");\n+        notEmpty.add(\"C\");\n+        final IteratorChain<String> chain = new IteratorChain<String>();\n+        chain.addIterator(empty.iterator());\n+        chain.addIterator(notEmpty.iterator());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"A\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"B\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"C\",chain.next());\n+        assertTrue(\"should not have next\",!chain.hasNext());\n+    }\n+    \n+    public void testEmptyChain() {\n+        final IteratorChain<Object> chain = new IteratorChain<Object>();\n+        assertEquals(false, chain.hasNext());\n+        try {\n+            chain.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            chain.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.iterators.IteratorIterable;\n+\n+/**\n+ * Tests for IteratorIterable.\n+ * \n+ * @version $Id$\n+ */\n+public class IteratorIterableTest extends BulkTest {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(IteratorIterableTest.class);\n+    }\n+\n+    public IteratorIterableTest(final String name) {\n+        super(name);\n+    }\n+\n+    private Iterator<Integer> createIterator() {\n+        final List<Integer> list = new ArrayList<Integer>();\n+        list.add(Integer.valueOf(0));\n+        list.add(Integer.valueOf(1));\n+        list.add(Integer.valueOf(2));\n+        final Iterator<Integer> iter = list.iterator();\n+        return iter;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<Integer> iter = createIterator();\n+        final Iterable<Number> iterable = new IteratorIterable<Number>(iter);\n+        \n+        // first use\n+        verifyIteration(iterable);\n+        \n+        // second use\n+        for (@SuppressWarnings(\"unused\") final Number actual : iterable) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+\n+    public void testMultipleUserIterator() {\n+        final Iterator<Integer> iter = createIterator();\n+\n+        final Iterable<Number> iterable = new IteratorIterable<Number>(iter, true);\n+        \n+        // first use\n+        verifyIteration(iterable);\n+        \n+        // second use\n+        verifyIteration(iterable);\n+    }\n+\n+    private void verifyIteration(final Iterable<Number> iterable) {\n+        int expected = 0;\n+        for (final Number actual : iterable) {\n+            assertEquals(expected, actual.intValue());\n+            ++expected;\n+        }\n+        assertTrue(expected > 0);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.IteratorUtils;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.iterators.LazyIteratorChain;\n+\n+/**\n+ * Tests the LazyIteratorChain class.\n+ *\n+ * @version $Id$\n+ */\n+public class LazyIteratorChainTest extends AbstractIteratorTest<String> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+\n+    public LazyIteratorChainTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        list1 = new ArrayList<String>();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList<String>();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList<String>();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");        \n+    }\n+\n+    @Override\n+    public LazyIteratorChain<String> makeEmptyIterator() {\n+        return new LazyIteratorChain<String>() {\n+            @Override\n+            protected Iterator<String> nextIterator(final int count) {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public LazyIteratorChain<String> makeObject() {\n+        final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {\n+            @Override\n+            protected Iterator<String> nextIterator(final int count) {\n+                switch (count) {\n+                case 1:\n+                    return list1.iterator();\n+                case 2:\n+                    return list2.iterator();\n+                case 3:\n+                    return list3.iterator();\n+                }\n+                return null;\n+            }\n+        };\n+\n+        return chain;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<String> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\", \n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    public void testRemoveFromFilteredIterator() {\n+\n+        final Predicate<Integer> myPredicate = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer i) {\n+                return i.compareTo(new Integer(4)) < 0;\n+            }\n+        };\n+\n+        final List<Integer> list1 = new ArrayList<Integer>();\n+        final List<Integer> list2 = new ArrayList<Integer>();\n+\n+        list1.add(new Integer(1));\n+        list1.add(new Integer(2));\n+        list2.add(new Integer(3));\n+        list2.add(new Integer(4)); // will be ignored by the predicate\n+\n+        final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n+        final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n+\n+        final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, list1.size());\n+        assertEquals(1, list2.size());\n+    }\n+    \n+    @Override\n+    public void testRemove() {\n+        final Iterator<String> iter = makeObject();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Calling remove before the first call to next() should throw an exception\");\n+        } catch (final IllegalStateException e) {\n+\n+        }\n+\n+        for (final String testValue : testArray) {\n+            final String iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+            if (!iterValue.equals(\"Four\")) {\n+                iter.remove();\n+            }\n+        }\n+\n+        assertTrue(\"List is empty\",list1.size() == 0);\n+        assertTrue(\"List is empty\",list2.size() == 1);\n+        assertTrue(\"List is empty\",list3.size() == 0);\n+    }\n+\n+    public void testFirstIteratorIsEmptyBug() {\n+        final List<String> empty = new ArrayList<String>();\n+        final List<String> notEmpty = new ArrayList<String>();\n+        notEmpty.add(\"A\");\n+        notEmpty.add(\"B\");\n+        notEmpty.add(\"C\");\n+        final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {\n+            @Override\n+            protected Iterator<String> nextIterator(final int count) {\n+                switch (count) {\n+                case 1:\n+                    return empty.iterator();\n+                case 2:\n+                    return notEmpty.iterator();\n+                }\n+                return null;\n+            }\n+        };\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"A\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"B\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"C\",chain.next());\n+        assertTrue(\"should not have next\",!chain.hasNext());\n+    }\n+    \n+    public void testEmptyChain() {\n+        final LazyIteratorChain<String> chain = makeEmptyIterator();\n+        assertEquals(false, chain.hasNext());\n+        try {\n+            chain.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            chain.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapper2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+import org.apache.commons.collections4.iterators.ListIteratorWrapper;\n+\n+/**\n+ * Tests the ListIteratorWrapper to insure that it behaves as expected when wrapping a ListIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class ListIteratorWrapper2Test<E> extends AbstractIteratorTest<E> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<E> list1 = null;\n+\n+    public ListIteratorWrapper2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void setUp() {\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeEmptyIterator() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        return new ListIteratorWrapper<E>(list.listIterator());\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeObject() {\n+        return new ListIteratorWrapper<E>(list1.listIterator());\n+    }\n+\n+    public void testIterator() {\n+        final ListIterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+\n+        // now, read it backwards\n+        for (int i = testArray.length - 1; i > -1; --i) {\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.previous();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        try {\n+            iter.previous();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+\n+        // now, read it forwards again\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testRemove() {\n+        final ListIterator<E> iter = makeObject();\n+\n+        //initial state:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n+        } catch (final IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //establish size:\n+        int sz = list1.size();\n+\n+        //verify initial next() call:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //verify remove():\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        //like we never started iterating:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+ \n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n+        } catch (final IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //two consecutive next() calls:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+        //call previous():\n+        assertEquals(list1.get(1), iter.previous());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //this would dig into cache on a plain Iterator, but forwards directly to wrapped ListIterator:\n+        assertEquals(list1.get(0), iter.previous());\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //here's the proof; remove() still works:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //further testing would be fairly meaningless:\n+    }\n+\n+    public void testReset() {\n+        final ResettableListIterator<E> iter = makeObject();\n+        final E first = iter.next();\n+        final E second = iter.next();\n+\n+        iter.reset();\n+\n+        // after reset, there shouldn't be any previous elements\n+        assertFalse(\"No previous elements after reset()\", iter.hasPrevious());\n+\n+        // after reset, the results should be the same as before\n+        assertEquals(\"First element should be the same\", first, iter.next());\n+        assertEquals(\"Second elment should be the same\", second, iter.next());\n+\n+        // after passing the point, where we resetted, continuation should work as expected\n+        for (int i = 2; i < testArray.length; i++) {\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ListIteratorWrapperTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+import org.apache.commons.collections4.iterators.ListIteratorWrapper;\n+\n+/**\n+ * Tests the ListIteratorWrapper to insure that it simulates\n+ * a ListIterator correctly.\n+ *\n+ * @version $Id$\n+ */\n+public class ListIteratorWrapperTest<E> extends AbstractIteratorTest<E> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<E> list1 = null;\n+\n+    public ListIteratorWrapperTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void setUp() {\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeEmptyIterator() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        return new ListIteratorWrapper<E>(list.iterator());\n+    }\n+\n+    @Override\n+    public ResettableListIterator<E> makeObject() {\n+        return new ListIteratorWrapper<E>(list1.iterator());\n+    }\n+\n+    public void testIterator() {\n+        final ListIterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+\n+        // now, read it backwards\n+        for (int i = testArray.length - 1; i > -1; --i) {\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.previous();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        try {\n+            iter.previous();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\",\n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+\n+        // now, read it forwards again\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testRemove() {\n+        final ListIterator<E> iter = makeObject();\n+\n+        //initial state:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be initially positioned first\");\n+        } catch (final IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //establish size:\n+        int sz = list1.size();\n+\n+        //verify initial next() call:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //verify remove():\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        //like we never started iterating:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+ \n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper#remove() should fail; must be repositioned first\");\n+        } catch (final IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //two consecutive next() calls:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+        //call previous():\n+        assertEquals(list1.get(1), iter.previous());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //should support remove() after calling previous() once from tip because we haven't changed the underlying iterator's position:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        //dig into cache\n+        assertEquals(list1.get(0), iter.previous());\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        try {\n+            iter.remove();\n+            fail(\"ListIteratorWrapper does not support the remove() method while dug into the cache via previous()\");\n+        } catch (final IllegalStateException e) {\n+        }\n+\n+        //no change from invalid op:\n+        assertEquals(-1, iter.previousIndex());\n+        assertEquals(0, iter.nextIndex());\n+\n+        //dig out of cache, first next() maintains current position:\n+        assertEquals(list1.get(0), iter.next());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+        //continue traversing underlying iterator with this next() call, and we're out of the hole, so to speak:\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+        //verify remove() works again:\n+        iter.remove();\n+        assertEquals(--sz, list1.size());\n+        assertEquals(0, iter.previousIndex());\n+        assertEquals(1, iter.nextIndex());\n+\n+        assertEquals(list1.get(1), iter.next());\n+        assertEquals(1, iter.previousIndex());\n+        assertEquals(2, iter.nextIndex());\n+\n+    }\n+\n+    public void testReset() {\n+        final ResettableListIterator<E> iter = makeObject();\n+        final E first = iter.next();\n+        final E second = iter.next();\n+\n+        iter.reset();\n+\n+        // after reset, there shouldn't be any previous elements\n+        assertFalse(\"No previous elements after reset()\", iter.hasPrevious());\n+\n+        // after reset, the results should be the same as before\n+        assertEquals(\"First element should be the same\", first, iter.next());\n+        assertEquals(\"Second elment should be the same\", second, iter.next());\n+\n+        // after passing the point, where we resetted, continuation should work as expected\n+        for (int i = 2; i < testArray.length; i++) {\n+            final Object testValue = testArray[i];\n+            final E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/LoopingIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.LoopingIterator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the LoopingIterator class.\n+ *\n+ * @version $Id$\n+ */\n+public class LoopingIteratorTest extends TestCase {\n+\n+    public LoopingIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Tests constructor exception.\n+     */\n+    public void testConstructorEx() throws Exception {\n+        try {\n+            new LoopingIterator<Object>(null);\n+            fail();\n+        } catch (final NullPointerException ex) {\n+        }\n+    }\n+    \n+    /**\n+     * Tests whether an empty looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping0() throws Exception {\n+        final List<Object> list = new ArrayList<Object>();\n+        final LoopingIterator<Object> loop = new LoopingIterator<Object>(list);\n+        assertTrue(\"hasNext should return false\", loop.hasNext() == false);\n+\n+        try {\n+            loop.next();\n+            fail(\"NoSuchElementException was not thrown during next() call.\");\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether a populated looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping1() throws Exception {\n+        final List<String> list = Arrays.asList(new String[] { \"a\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+    }\n+\n+    /**\n+     * Tests whether a populated looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping2() throws Exception {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"b\", loop.next());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+    }\n+\n+    /**\n+     * Tests whether a populated looping iterator works as designed.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testLooping3() throws Exception {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"b\", loop.next());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"c\", loop.next());\n+\n+        assertTrue(\"4th hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+\n+    }\n+\n+    /**\n+     * Tests the remove() method on a LoopingIterator wrapped ArrayList.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testRemoving1() throws Exception {\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+        assertEquals(\"list should have 3 elements.\", 3, list.size());\n+\n+        assertTrue(\"1st hasNext should return true\", loop.hasNext());\n+        assertEquals(\"a\", loop.next());\n+        loop.remove();  // removes a\n+        assertEquals(\"list should have 2 elements.\", 2, list.size());\n+\n+        assertTrue(\"2nd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"b\", loop.next());\n+        loop.remove();  // removes b\n+        assertEquals(\"list should have 1 elements.\", 1, list.size());\n+\n+        assertTrue(\"3rd hasNext should return true\", loop.hasNext());\n+        assertEquals(\"c\", loop.next());\n+        loop.remove();  // removes c\n+        assertEquals(\"list should have 0 elements.\", 0, list.size());\n+\n+        assertTrue(\"4th hasNext should return false\", loop.hasNext() == false);\n+        try {\n+            loop.next();\n+            fail(\"Expected NoSuchElementException to be thrown.\");\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests the reset() method on a LoopingIterator wrapped ArrayList.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testReset() throws Exception {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertEquals(\"a\", loop.next());\n+        assertEquals(\"b\", loop.next());\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());\n+        assertEquals(\"b\", loop.next());\n+        assertEquals(\"c\", loop.next());\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());\n+        assertEquals(\"b\", loop.next());\n+        assertEquals(\"c\", loop.next());\n+    }\n+    \n+    /**\n+     * Tests the size() method on a LoopingIterator wrapped ArrayList.\n+     * @throws Exception  If something unexpected occurs.\n+     */\n+    public void testSize() throws Exception {\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingIterator<String> loop = new LoopingIterator<String>(list);\n+\n+        assertEquals(3, loop.size());\n+        loop.next();\n+        loop.next();\n+        assertEquals(3, loop.size());\n+        loop.reset();\n+        assertEquals(3, loop.size());\n+        loop.next();\n+        loop.remove();\n+        assertEquals(2, loop.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.LoopingListIterator;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the LoopingListIterator class.\n+ *\n+ * @version $Id$\n+ */\n+public class LoopingListIteratorTest extends TestCase {\n+\n+    public LoopingListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+    \n+    /**\n+     * Tests constructor exception.\n+     */\n+    public void testConstructorEx() throws Exception {\n+        try {\n+            new LoopingListIterator<Object>(null);\n+            fail();\n+        } catch (final NullPointerException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether an empty looping list iterator works.\n+     */\n+    public void testLooping0() throws Exception {\n+        final List<Object> list = new ArrayList<Object>();\n+        final LoopingListIterator<Object> loop = new LoopingListIterator<Object>(list);\n+        assertFalse(loop.hasNext());\n+        assertFalse(loop.hasPrevious());\n+        \n+        try {\n+            loop.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+\n+        try {\n+            loop.previous();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests whether a looping list iterator works on a list with only\n+     * one element.\n+     */\n+    public void testLooping1() throws Exception {\n+        final List<String> list = Arrays.asList(new String[] { \"a\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+    }\n+\n+    /**\n+     * Tests whether a looping list iterator works on a list with two\n+     * elements.\n+     */\n+    public void testLooping2() throws Exception {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"b\", loop.next());     // <a> b\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        // Reset the iterator and try using previous.\n+        loop.reset();                       // <a> b\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+    }\n+\n+    /**\n+     * Tests jogging back and forth between two elements, but not over\n+     * the begin/end boundary of the list.\n+     */\n+    public void testJoggingNotOverBoundary() {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+    \n+        // Try jogging back and forth between the elements, but not\n+        // over the begin/end boundary.\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());     // a <b>\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+        assertEquals(\"a\", loop.next());     // a <b>\n+\n+        assertEquals(\"b\", loop.next());     // <a> b\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        assertEquals(\"b\", loop.next());     // <a> b\n+    }\n+\n+    /**\n+     * Tests jogging back and forth between two elements over the\n+     * begin/end boundary of the list.\n+     */\n+    public void testJoggingOverBoundary() {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n+    \n+        // Try jogging back and forth between the elements, but not\n+        // over the begin/end boundary.\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        assertEquals(\"b\", loop.next());     // <a> b\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+        assertEquals(\"a\", loop.next());     // a <b>\n+        assertEquals(\"a\", loop.previous()); // <a> b\n+    }\n+\n+    /**\n+     * Tests removing an element from a wrapped ArrayList.\n+     */\n+    public void testRemovingElementsAndIteratingForward() {\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        loop.remove();                  // <b> c\n+        assertEquals(2, list.size());\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"b\", loop.next()); // b <c>\n+        loop.remove();                  // <c>\n+        assertEquals(1, list.size());\n+\n+        assertTrue(loop.hasNext());\n+        assertEquals(\"c\", loop.next()); // <c>\n+        loop.remove();                  // ---\n+        assertEquals(0, list.size());\n+\n+        assertFalse(loop.hasNext());\n+        try {\n+            loop.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests removing an element from a wrapped ArrayList.\n+     */\n+    public void testRemovingElementsAndIteratingBackwards() {\n+        final List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"a\", \"b\", \"c\" }));\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        loop.remove();                      // <a> b\n+        assertEquals(2, list.size());\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"b\", loop.previous()); // a <b>\n+        loop.remove();                      // <a>\n+        assertEquals(1, list.size());\n+\n+        assertTrue(loop.hasPrevious());\n+        assertEquals(\"a\", loop.previous()); // <a>\n+        loop.remove();                      // ---\n+        assertEquals(0, list.size());\n+\n+        assertFalse(loop.hasPrevious());\n+        try {\n+            loop.previous();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    /**\n+     * Tests the reset method.\n+     */\n+    public void testReset() {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        assertEquals(\"b\", loop.next()); // a b <c>\n+        loop.reset();                   // <a> b c\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        loop.reset();                   // <a> b c\n+        assertEquals(\"a\", loop.next()); // a <b> c\n+        assertEquals(\"b\", loop.next()); // a b <c>\n+        assertEquals(\"c\", loop.next()); // <a> b c\n+        loop.reset();                   // <a> b c\n+\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        assertEquals(\"b\", loop.previous()); // a <b> c\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"c\", loop.previous()); // a b <c>\n+        assertEquals(\"b\", loop.previous()); // a <b> c\n+        assertEquals(\"a\", loop.previous()); // <a> b c\n+    }\n+\n+    /**\n+     * Tests the add method.\n+     */\n+    public void testAdd() {\n+        List<String> list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <b> e f\n+\n+        loop.add(\"a\");                      // <a> b e f\n+        assertEquals(\"b\", loop.next());     // a <b> e f\n+        loop.reset();                       // <a> b e f\n+        assertEquals(\"a\", loop.next());     // a <b> e f\n+        assertEquals(\"b\", loop.next());     // a b <e> f\n+\n+        loop.add(\"c\");                      // a b c <e> f\n+        assertEquals(\"e\", loop.next());     // a b c e <f>\n+        assertEquals(\"e\", loop.previous()); // a b c <e> f\n+        assertEquals(\"c\", loop.previous()); // a b <c> e f\n+        assertEquals(\"c\", loop.next());     // a b c <e> f\n+        \n+        loop.add(\"d\");                      // a b c d <e> f\n+        loop.reset();                       // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+        assertEquals(\"b\", loop.next());     // a b <c> d e f\n+        assertEquals(\"c\", loop.next());     // a b c <d> e f\n+        assertEquals(\"d\", loop.next());     // a b c d <e> f\n+        assertEquals(\"e\", loop.next());     // a b c d e <f>\n+        assertEquals(\"f\", loop.next());     // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+\n+        list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n+        loop = new LoopingListIterator<String>(list); // <b> e f        \n+\n+        loop.add(\"a\");                      // a <b> e f\n+        assertEquals(\"a\", loop.previous()); // a b e <f>\n+        loop.reset();                       // <a> b e f\n+        assertEquals(\"f\", loop.previous()); // a b e <f>\n+        assertEquals(\"e\", loop.previous()); // a b <e> f\n+\n+        loop.add(\"d\");                      // a b d <e> f\n+        assertEquals(\"d\", loop.previous()); // a b <d> e f\n+\n+        loop.add(\"c\");                      // a b c <d> e f\n+        assertEquals(\"c\", loop.previous()); // a b <c> d e f\n+\n+        loop.reset();\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+        assertEquals(\"b\", loop.next());     // a b <c> d e f\n+        assertEquals(\"c\", loop.next());     // a b c <d> e f\n+        assertEquals(\"d\", loop.next());     // a b c d <e> f\n+        assertEquals(\"e\", loop.next());     // a b c d e <f>\n+        assertEquals(\"f\", loop.next());     // <a> b c d e f\n+        assertEquals(\"a\", loop.next());     // a <b> c d e f\n+    }\n+\n+    /**\n+     * Tests nextIndex and previousIndex.\n+     */\n+    public void testNextAndPreviousIndex() {\n+        final List<String> list = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b c\n+\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.next());        // a <b> c\n+        assertEquals(1, loop.nextIndex());\n+        assertEquals(0, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.previous());    // <a> b c\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+\n+        assertEquals(\"c\", loop.previous());    // a b <c>\n+        assertEquals(2, loop.nextIndex());\n+        assertEquals(1, loop.previousIndex());\n+\n+        assertEquals(\"b\", loop.previous());    // a <b> c\n+        assertEquals(1, loop.nextIndex());\n+        assertEquals(0, loop.previousIndex());\n+\n+        assertEquals(\"a\", loop.previous());    // <a> b c\n+        assertEquals(0, loop.nextIndex());\n+        assertEquals(2, loop.previousIndex());\n+    }\n+\n+    /**\n+     * Tests using the set method to change elements.\n+     */\n+    public void testSet() {\n+        final List<String> list = Arrays.asList(new String[] { \"q\", \"r\", \"z\" });\n+        final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <q> r z\n+\n+        assertEquals(\"z\", loop.previous()); // q r <z>\n+        loop.set(\"c\");                      // q r <c>\n+\n+        loop.reset();                       // <q> r c\n+        assertEquals(\"q\", loop.next());     // q <r> c\n+        loop.set(\"a\");                      // a <r> c\n+        \n+        assertEquals(\"r\", loop.next());     // a r <c>\n+        loop.set(\"b\");                      // a b <c>\n+\n+        loop.reset();                       // <a> b c\n+        assertEquals(\"a\", loop.next());     // a <b> c\n+        assertEquals(\"b\", loop.next());     // a b <c>\n+        assertEquals(\"c\", loop.next());     // <a> b c\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java\n+/*\n+ * Copyright 2013 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+\n+import org.apache.commons.collections4.iterators.NodeListIterator;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+\n+/**\n+ * Tests the NodeListIterator.\n+ */\n+public class NodeListIteratorTest extends AbstractIteratorTest<Node> {\n+\n+    // Node array to be filled with mocked Node instances \n+    private Node[] nodes;\n+    \n+    // NodeListIterator supports two constructors. This flag allows to\n+    // control, which constructor to use in makeObject() and makeEmtpyIterator\n+    private boolean createIteratorWithStandardConstr = true;\n+    \n+    /**\n+     * Constructor \n+     * @param testName \n+     */\n+    public NodeListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp(); \n+\n+        // Default: use standard constr.\n+        createIteratorWithStandardConstr = true;\n+        \n+        \n+        // create mocked Node Instances and fill Node[] to be used by test cases\n+        final Node node1 = createMock(Element.class);\n+        final Node node2 = createMock(Element.class);\n+        final Node node3 = createMock(Text.class);\n+        final Node node4 = createMock(Element.class);\n+        nodes = new Node[] {node1, node2, node3, node4};\n+        \n+        replay(node1);\n+        replay(node2);\n+        replay(node3);\n+        replay(node4);\n+    }\n+\n+    @Override\n+    public Iterator<Node> makeEmptyIterator() {\n+        final NodeList emptyNodeList = new NodeList() {\n+            public Node item(final int index) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            public int getLength() {\n+                return 0;\n+            }\n+        };\n+        \n+        if (createIteratorWithStandardConstr) {\n+            return new NodeListIterator(emptyNodeList);\n+        } else {\n+            final Node parentNode = createMock(Node.class);\n+            expect(parentNode.getChildNodes()).andStubReturn(emptyNodeList);\n+            replay(parentNode);\n+            \n+            return new NodeListIterator(parentNode);\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<Node> makeObject() {\n+        final NodeList nodeList = new NodeList() {\n+            public Node item(final int index) {\n+                return nodes[index];\n+            }\n+            public int getLength() {\n+                return nodes.length;\n+            }\n+        };\n+\n+        return new NodeListIterator(nodeList);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testNullConstructor(){\n+        try{\n+            @SuppressWarnings(\"unused\")\n+            final NodeListIterator iter = new NodeListIterator((Node) null);\n+            fail(\"IllegalArgumentException expected!\");\n+        }catch(final IllegalArgumentException e){\n+            // expected.\n+        }\n+    }\n+\n+    /**\n+     * tests the convenience Constructor with parameter type org.w3c.Node\n+     */\n+    public void testEmptyIteratorWithNodeConstructor(){\n+        createIteratorWithStandardConstr = false;\n+        testEmptyIterator();\n+    }\n+\n+    /**\n+     * tests the convenience Constructor with parameter type org.w3c.Node\n+     */\n+    public void testFullIteratorWithNodeConstructor(){\n+        createIteratorWithStandardConstr = false;\n+        testFullIterator();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ObjectArrayIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.ObjectArrayIterator;\n+\n+/**\n+ * Tests the ObjectArrayIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class ObjectArrayIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+\n+    public ObjectArrayIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayIterator<E>((E[]) new Object[0]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayIterator<E> makeObject() {\n+        return new ObjectArrayIterator<E>((E[]) testArray);\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator() {\n+        return new ObjectArrayIterator<E>();\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator(final E[] array) {\n+        return new ObjectArrayIterator<E>(array);\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int index) {\n+        return new ObjectArrayIterator<E>(array, index);\n+    }\n+\n+    public ObjectArrayIterator<E> makeArrayIterator(final E[] array, final int start, final int end) {\n+        return new ObjectArrayIterator<E>(array, start, end);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final E iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    public void testNullArray() {\n+        try {\n+            makeArrayIterator(null);\n+\n+            fail(\"Constructor should throw a NullPointerException when constructed with a null array\");\n+        } catch (final NullPointerException e) {\n+            // expected\n+        }\n+\n+        final ObjectArrayIterator<E> iter = makeArrayIterator();\n+        try {\n+            iter.setArray(null);\n+\n+            fail(\"setArray(null) should throw a NullPointerException\");\n+        } catch (final NullPointerException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testDoubleSet() {\n+        final ObjectArrayIterator<E> it = makeArrayIterator();\n+        it.setArray((E[]) new String[0]);\n+        try {\n+            it.setArray((E[]) new String[0]);\n+            fail();\n+        } catch (final IllegalStateException ex) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        final ObjectArrayIterator<E> it = makeArrayIterator((E[]) testArray);\n+        it.next();\n+        it.reset();\n+        assertEquals(\"One\", it.next());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIterator2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import org.apache.commons.collections4.iterators.ObjectArrayListIterator;\n+\n+/**\n+ * Tests the ObjectArrayListIterator class.\n+ *\n+ * @version $Id$\n+ */\n+public class ObjectArrayListIterator2Test<E> extends AbstractListIteratorTest<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+\n+    public ObjectArrayListIterator2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayListIterator<E>((E[]) new Object[0]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeObject() {\n+        return new ObjectArrayListIterator<E>((E[]) testArray);\n+    }\n+\n+    public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n+    }\n+\n+    @Override\n+    public boolean supportsAdd() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ObjectArrayListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Arrays;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.ObjectArrayListIterator;\n+\n+/**\n+ * Tests the ObjectArrayListIterator class.\n+ *\n+ * @version $Id$\n+ */\n+public class ObjectArrayListIteratorTest<E> extends ObjectArrayIteratorTest<E> {\n+\n+    public ObjectArrayListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeEmptyIterator() {\n+        return new ObjectArrayListIterator<E>((E[]) new Object[0]);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ObjectArrayListIterator<E> makeObject() {\n+        return new ObjectArrayListIterator<E>((E[]) testArray);\n+    }\n+\n+    public ObjectArrayListIterator<E> makeArrayListIterator(final E[] array) {\n+        return new ObjectArrayListIterator<E>(array);\n+    }\n+\n+    /**\n+     * Test the basic ListIterator functionality - going backwards using\n+     * <code>previous()</code>.\n+     */\n+    public void testListIterator() {\n+        final ListIterator<E> iter = makeObject();\n+\n+        // TestArrayIterator#testIterator() has already tested the iterator forward,\n+        //  now we need to test it in reverse\n+\n+        // fast-forward the iterator to the end...\n+        while (iter.hasNext()) {\n+            iter.next();\n+        }\n+\n+        for (int x = testArray.length - 1; x >= 0; x--) {\n+            final Object testValue = testArray[x];\n+            final Object iterValue = iter.previous();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasPrevious());\n+\n+        try {\n+            iter.previous();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+\n+    }\n+\n+    /**\n+     * Tests the {@link java.util.ListIterator#set} operation.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorSet() {\n+        final String[] testData = new String[] { \"a\", \"b\", \"c\" };\n+\n+        final String[] result = new String[] { \"0\", \"1\", \"2\" };\n+\n+        ListIterator<E> iter = makeArrayListIterator((E[]) testData);\n+        int x = 0;\n+\n+        while (iter.hasNext()) {\n+            iter.next();\n+            iter.set((E) Integer.toString(x));\n+            x++;\n+        }\n+\n+        assertTrue(\"The two arrays should have the same value, i.e. {0,1,2}\", Arrays.equals(testData, result));\n+\n+        // a call to set() before a call to next() or previous() should throw an IllegalStateException\n+        iter = makeArrayListIterator((E[]) testArray);\n+\n+        try {\n+            iter.set((E) \"should fail\");\n+            fail(\"ListIterator#set should fail if next() or previous() have not yet been called.\");\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        } catch (final Throwable t) { // should never happen\n+            fail(t.toString());\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ObjectGraphIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.IteratorUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.iterators.ObjectGraphIterator;\n+\n+/**\n+ * Testcase.\n+ *\n+ * @version $Id$\n+ */\n+public class ObjectGraphIteratorTest extends AbstractIteratorTest<Object> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\" };\n+\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+    protected List<Iterator<String>> iteratorList = null;\n+\n+    public ObjectGraphIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        list1 = new ArrayList<String>();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList<String>();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList<String>();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");\n+        iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public ObjectGraphIterator<Object> makeEmptyIterator() {\n+        final ArrayList<Object> list = new ArrayList<Object>();\n+        return new ObjectGraphIterator<Object>(list.iterator());\n+    }\n+\n+    @Override\n+    public ObjectGraphIterator<Object> makeObject() {\n+        return new ObjectGraphIterator<Object>(iteratorList.iterator());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteratorConstructor_null1() {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructor_null_next() {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructor_null_remove() {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null);\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteratorConstructorIteration_Empty() {\n+        final List<Iterator<Object>> iteratorList = new ArrayList<Iterator<Object>>();\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_Simple() {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_SimpleNoHasNext() {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+        }\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorIteration_WithEmptyIterators() {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteratorConstructorRemove() {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator());\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(testArray[i], it.next());\n+            it.remove();\n+        }\n+        assertEquals(false, it.hasNext());\n+        assertEquals(0, list1.size());\n+        assertEquals(0, list2.size());\n+        assertEquals(0, list3.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteration_IteratorOfIterators() {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(list3.iterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    public void testIteration_IteratorOfIteratorsWithEmptyIterators() {\n+        final List<Iterator<String>> iteratorList = new ArrayList<Iterator<String>>();\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list1.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list2.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        iteratorList.add(list3.iterator());\n+        iteratorList.add(IteratorUtils.<String>emptyIterator());\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(iteratorList.iterator(), null);\n+\n+        for (int i = 0; i < 6; i++) {\n+            assertEquals(true, it.hasNext());\n+            assertEquals(testArray[i], it.next());\n+        }\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIteration_RootNull() {\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(null, null);\n+\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {\n+        }\n+    }\n+\n+    public void testIteration_RootNoTransformer() {\n+        final Forest forest = new Forest();\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, null);\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(forest, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed1() {\n+        final Forest forest = new Forest();\n+        final Leaf l1 = forest.addTree().addBranch().addLeaf();\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed2() {\n+        final Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        final Branch b1 = forest.getTree(0).addBranch();\n+        final Branch b2 = forest.getTree(0).addBranch();\n+        final Branch b3 = forest.getTree(2).addBranch();\n+        /* Branch b4 = */ forest.getTree(2).addBranch();\n+        final Branch b5 = forest.getTree(2).addBranch();\n+        final Leaf l1 = b1.addLeaf();\n+        final Leaf l2 = b1.addLeaf();\n+        final Leaf l3 = b2.addLeaf();\n+        final Leaf l4 = b3.addLeaf();\n+        final Leaf l5 = b5.addLeaf();\n+\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l2, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l3, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l4, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l5, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    public void testIteration_Transformed3() {\n+        final Forest forest = new Forest();\n+        forest.addTree();\n+        forest.addTree();\n+        forest.addTree();\n+        final Branch b1 = forest.getTree(1).addBranch();\n+        final Branch b2 = forest.getTree(1).addBranch();\n+        final Branch b3 = forest.getTree(2).addBranch();\n+        final Branch b4 = forest.getTree(2).addBranch();\n+        /* Branch b5 = */ forest.getTree(2).addBranch();\n+        final Leaf l1 = b1.addLeaf();\n+        final Leaf l2 = b1.addLeaf();\n+        final Leaf l3 = b2.addLeaf();\n+        final Leaf l4 = b3.addLeaf();\n+        final Leaf l5 = b4.addLeaf();\n+\n+        final Iterator<Object> it = new ObjectGraphIterator<Object>(forest, new LeafFinder());\n+\n+        assertEquals(true, it.hasNext());\n+        assertSame(l1, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l2, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l3, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l4, it.next());\n+        assertEquals(true, it.hasNext());\n+        assertSame(l5, it.next());\n+        assertEquals(false, it.hasNext());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class LeafFinder implements Transformer<Object, Object> {\n+        public Object transform(final Object input) {\n+            if (input instanceof Forest) {\n+                return ((Forest) input).treeIterator();\n+            }\n+            if (input instanceof Tree) {\n+                return ((Tree) input).branchIterator();\n+            }\n+            if (input instanceof Branch) {\n+                return ((Branch) input).leafIterator();\n+            }\n+            if (input instanceof Leaf) {\n+                return input;\n+            }\n+            throw new ClassCastException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class Forest {\n+        List<Tree> trees = new ArrayList<Tree>();\n+\n+        Tree addTree() {\n+            trees.add(new Tree());\n+            return getTree(trees.size() - 1);\n+        }\n+\n+        Tree getTree(final int index) {\n+            return trees.get(index);\n+        }\n+\n+        Iterator<Tree> treeIterator() {\n+            return trees.iterator();\n+        }\n+    }\n+\n+    static class Tree {\n+        List<Branch> branches = new ArrayList<Branch>();\n+\n+        Branch addBranch() {\n+            branches.add(new Branch());\n+            return getBranch(branches.size() - 1);\n+        }\n+\n+        Branch getBranch(final int index) {\n+            return branches.get(index);\n+        }\n+\n+        Iterator<Branch> branchIterator() {\n+            return branches.iterator();\n+        }\n+    }\n+\n+    static class Branch {\n+        List<Leaf> leaves = new ArrayList<Leaf>();\n+\n+        Leaf addLeaf() {\n+            leaves.add(new Leaf());\n+            return getLeaf(leaves.size() - 1);\n+        }\n+\n+        Leaf getLeaf(final int index) {\n+            return leaves.get(index);\n+        }\n+\n+        Iterator<Leaf> leafIterator() {\n+            return leaves.iterator();\n+        }\n+    }\n+\n+    static class Leaf {\n+        String colour;\n+\n+        String getColour() {\n+            return colour;\n+        }\n+\n+        void setColour(final String colour) {\n+            this.colour = colour;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ReverseListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+import org.apache.commons.collections4.iterators.ReverseListIterator;\n+\n+/**\n+ * Tests the ReverseListIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class ReverseListIteratorTest<E> extends AbstractListIteratorTest<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\", \"Four\" };\n+\n+    public ReverseListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ListIterator<E> makeEmptyIterator() {\n+        return new ReverseListIterator<E>(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ReverseListIterator<E> makeObject() {\n+        final List<E> list = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+        return new ReverseListIterator<E>(list);\n+    }\n+\n+    // overrides\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testEmptyListIteratorIsIndeedEmpty() {\n+        final ListIterator<E> it = makeEmptyIterator();\n+\n+        assertEquals(false, it.hasNext());\n+        assertEquals(-1, it.nextIndex());  // reversed index\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(0, it.previousIndex());  // reversed index\n+\n+        // next() should throw a NoSuchElementException\n+        try {\n+            it.next();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+\n+        // previous() should throw a NoSuchElementException\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from empty ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+    }\n+\n+    @Override\n+    public void testWalkForwardAndBack() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        final ListIterator<E> it = makeObject();\n+        while (it.hasNext()) {\n+            list.add(it.next());\n+        }\n+\n+        // check state at end\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+\n+        // this had to be commented out, as there is a bug in the JDK before JDK1.5\n+        // where calling previous at the start of an iterator would push the cursor\n+        // back to an invalid negative value\n+//        try {\n+//            it.next();\n+//            fail(\"NoSuchElementException must be thrown from next at end of ListIterator\");\n+//        } catch (NoSuchElementException e) {\n+//        }\n+\n+        // loop back through comparing\n+        for (int i = list.size() - 1; i >= 0; i--) {\n+            assertEquals(\"\" + i, list.size() - i - 2, it.nextIndex());  // reversed index\n+            assertEquals(list.size() - i - 1, it.previousIndex());  // reversed index\n+\n+            final Object obj = list.get(i);\n+            assertEquals(obj, it.previous());\n+        }\n+\n+        // check state at start\n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        try {\n+            it.previous();\n+            fail(\"NoSuchElementException must be thrown from previous at start of ListIterator\");\n+        } catch (final NoSuchElementException e) {\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testReverse() {\n+        final ListIterator<E> it = makeObject();\n+        assertEquals(true, it.hasNext());\n+        assertEquals(3, it.nextIndex());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(4, it.previousIndex());\n+        assertEquals(\"Four\", it.next());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(3, it.previousIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(\"Three\", it.next());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(2, it.previousIndex());\n+        assertEquals(\"Two\", it.next());\n+        assertEquals(true, it.hasNext());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(\"One\", it.next());\n+        assertEquals(false, it.hasNext());\n+        assertEquals(-1, it.nextIndex());\n+        assertEquals(true, it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(\"One\", it.previous());\n+        assertEquals(\"Two\", it.previous());\n+        assertEquals(\"Three\", it.previous());\n+        assertEquals(\"Four\", it.previous());\n+    }\n+\n+    public void testReset() {\n+        final ResettableListIterator<E> it = makeObject();\n+        assertEquals(\"Four\", it.next());\n+        it.reset();\n+        assertEquals(\"Four\", it.next());\n+        it.next();\n+        it.next();\n+        it.reset();\n+        assertEquals(\"Four\", it.next());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/SingletonIterator2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.iterators.SingletonIterator;\n+\n+/**\n+ * Tests the SingletonIterator to ensure that the next() method will actually\n+ * perform the iteration rather than the hasNext() method.\n+ *\n+ * @version $Id$\n+ */\n+public class SingletonIterator2Test<E> extends AbstractIteratorTest<E> {\n+\n+    private static final Object testValue = \"foo\";\n+\n+    public SingletonIterator2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeEmptyIterator() {\n+        final SingletonIterator<E> iter = new SingletonIterator<E>((E) testValue);\n+        iter.next();\n+        iter.remove();\n+        iter.reset();\n+        return iter;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeObject() {\n+        return new SingletonIterator<E>((E) testValue, false);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsEmptyIterator() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIterator() {\n+        final Iterator<E> iter = makeObject();\n+        assertTrue(\"Iterator has a first item\", iter.hasNext());\n+\n+        final E iterValue = iter.next();\n+        assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    public void testReset() {\n+        final ResettableIterator<E> it = makeObject();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/SingletonIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.iterators.SingletonIterator;\n+\n+/**\n+ * Tests the SingletonIterator to ensure that the next() method will actually\n+ * perform the iteration rather than the hasNext() method.\n+ *\n+ * @version $Id$\n+ */\n+public class SingletonIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    private static final Object testValue = \"foo\";\n+\n+    public SingletonIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Returns a SingletonIterator from which\n+     * the element has already been removed.\n+     */\n+    @Override\n+    public SingletonIterator<E> makeEmptyIterator() {\n+        final SingletonIterator<E> iter = makeObject();\n+        iter.next();\n+        iter.remove();\n+        iter.reset();\n+        return iter;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonIterator<E> makeObject() {\n+        return new SingletonIterator<E>((E) testValue);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supportsEmptyIterator() {\n+        return true;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<E> iter = makeObject();\n+        assertTrue(\"Iterator has a first item\", iter.hasNext());\n+\n+        final E iterValue = iter.next();\n+        assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\n+                \"NoSuchElementException must be thrown\",\n+                e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSingletonIteratorRemove() {\n+        final ResettableIterator<E> iter = new SingletonIterator<E>((E) \"xyzzy\");\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"xyzzy\",iter.next());\n+        iter.remove();\n+        iter.reset();\n+        assertTrue(! iter.hasNext());\n+    }\n+\n+    public void testReset() {\n+        final ResettableIterator<E> it = makeObject();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+\n+        it.reset();\n+        it.reset();\n+\n+        assertEquals(true, it.hasNext());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.ResettableListIterator;\n+import org.apache.commons.collections4.iterators.SingletonListIterator;\n+\n+/**\n+ * Tests the SingletonListIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class SingletonListIteratorTest<E> extends AbstractListIteratorTest<E> {\n+\n+    private static final Object testValue = \"foo\";\n+    \n+    public SingletonListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+    \n+    /**\n+     * Returns a SingletonListIterator from which \n+     * the element has already been removed.\n+     */\n+    @Override\n+    public SingletonListIterator<E> makeEmptyIterator() {\n+        final SingletonListIterator<E> iter = makeObject();\n+        iter.next();\n+        iter.remove();\n+        iter.reset();        \n+        return iter;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonListIterator<E> makeObject() {\n+        return new SingletonListIterator<E>((E) testValue);\n+    }\n+\n+    @Override\n+    public boolean supportsAdd() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supportsEmptyIterator() {\n+        return true;\n+    }\n+\n+    public void testIterator() {\n+        final ListIterator<E> iter = makeObject();\n+        assertTrue( \"Iterator should have next item\", iter.hasNext() );\n+        assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", -1, iter.previousIndex() );\n+        \n+        Object iterValue = iter.next();\n+        assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        \n+        assertTrue( \"Iterator should have no next item\", !iter.hasNext() );\n+        assertTrue( \"Iterator should have previous item\", iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 1, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", 0, iter.previousIndex() );\n+\n+        iterValue = iter.previous();\n+        assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        \n+        assertTrue( \"Iterator should have next item\", iter.hasNext() );\n+        assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", -1, iter.previousIndex() );\n+\n+        iterValue = iter.next();\n+        assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        \n+        assertTrue( \"Iterator should have no next item\", !iter.hasNext() );\n+        assertTrue( \"Iterator should have previous item\", iter.hasPrevious() );\n+        assertEquals( \"Iteration next index\", 1, iter.nextIndex() );\n+        assertEquals( \"Iteration previous index\", 0, iter.previousIndex() );\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+          assertTrue(\"NoSuchElementException must be thrown\", \n+             e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+        iter.previous();\n+        try {\n+            iter.previous();\n+        } catch (final Exception e) {\n+          assertTrue(\"NoSuchElementException must be thrown\", \n+             e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+    \n+    public void testReset() {\n+        final ResettableListIterator<E> it = makeObject();\n+        \n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+\n+        it.reset();\n+        \n+        assertEquals(true, it.hasNext());\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(testValue, it.next());\n+        assertEquals(false, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+        \n+        it.reset();\n+        it.reset();\n+        \n+        assertEquals(true, it.hasNext());\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UniqueFilterIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.iterators.UniqueFilterIterator;\n+\n+/**\n+ * Tests the UniqueFilterIterator class.\n+ *\n+ * @version $Id$\n+ */\n+public class UniqueFilterIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<E> list1 = null;\n+\n+    public UniqueFilterIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void setUp() {\n+        list1 = new ArrayList<E>();\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"Three\");\n+        list1.add((E) \"Two\");\n+        list1.add((E) \"One\");\n+        list1.add((E) \"Four\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Five\");\n+        list1.add((E) \"Six\");\n+        list1.add((E) \"Five\");\n+    }\n+\n+    @Override\n+    public UniqueFilterIterator<E> makeEmptyIterator() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        return new UniqueFilterIterator<E>(list.iterator());\n+    }\n+\n+    @Override\n+    public UniqueFilterIterator<E> makeObject() {\n+        final Iterator<E> i = list1.iterator();\n+        return new UniqueFilterIterator<E>(i);\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<E> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final E iterValue = iter.next();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", ! iter.hasNext() );\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\", \n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableIterator;\n+\n+/**\n+ * Tests the UnmodifiableIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+    protected List<E> testList;\n+\n+    public UnmodifiableIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+    }\n+\n+    @Override\n+    public Iterator<E> makeEmptyIterator() {\n+        return UnmodifiableIterator.unmodifiableIterator(Collections.<E>emptyList().iterator());\n+    }\n+\n+    @Override\n+    public Iterator<E> makeObject() {\n+        return UnmodifiableIterator.unmodifiableIterator(testList.iterator());\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        Iterator<E> it = makeObject();\n+        assertSame(it, UnmodifiableIterator.unmodifiableIterator(it));\n+\n+        it = testList.iterator();\n+        assertTrue(it != UnmodifiableIterator.unmodifiableIterator(it));\n+\n+        try {\n+            UnmodifiableIterator.unmodifiableIterator(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableListIterator;\n+\n+/**\n+ * Tests the UnmodifiableListIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableListIteratorTest<E> extends AbstractListIteratorTest<E> {\n+\n+    protected String[] testArray = { \"One\", \"Two\", \"Three\" };\n+    protected List<E> testList;\n+\n+    public UnmodifiableListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        testList = new ArrayList<E>(Arrays.asList((E[]) testArray));\n+    }\n+\n+    @Override\n+    public ListIterator<E> makeEmptyIterator() {\n+        return UnmodifiableListIterator.umodifiableListIterator(Collections.<E>emptyList().listIterator());\n+    }\n+\n+    @Override\n+    public ListIterator<E> makeObject() {\n+        return UnmodifiableListIterator.umodifiableListIterator(testList.listIterator());\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsAdd() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSet() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testListIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        ListIterator<E> it = makeObject();\n+        assertSame(it, UnmodifiableListIterator.umodifiableListIterator(it));\n+\n+        it = testList.listIterator();\n+        assertTrue(it != UnmodifiableListIterator.umodifiableListIterator(it));\n+\n+        try {\n+            UnmodifiableListIterator.umodifiableListIterator(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.bidimap.DualHashBidiMap;\n+import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+\n+/**\n+ * Tests the UnmodifiableMapIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {\n+\n+    public UnmodifiableMapIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> makeEmptyIterator() {\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(new DualHashBidiMap<K, V>().mapIterator());\n+    }\n+\n+    @Override\n+    public MapIterator<K, V> makeObject() {\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(getMap().mapIterator());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public IterableMap<K, V> getMap() {\n+        final IterableMap<K, V> testMap = new DualHashBidiMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V)\"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> getConfirmedMap() {\n+        final Map<K, V> testMap = new HashMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V)\"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSetValue() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        MapIterator<K, V> it = makeObject();\n+        assertSame(it, UnmodifiableMapIterator.unmodifiableMapIterator(it));\n+\n+        it = getMap().mapIterator() ;\n+        assertTrue(it != UnmodifiableMapIterator.unmodifiableMapIterator(it));\n+\n+        try {\n+            UnmodifiableMapIterator.unmodifiableMapIterator(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+\n+/**\n+ * Tests the UnmodifiableOrderedMapIterator.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableOrderedMapIteratorTest<K, V> extends AbstractOrderedMapIteratorTest<K, V> {\n+\n+    public UnmodifiableOrderedMapIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public OrderedMapIterator<K, V> makeEmptyIterator() {\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(\n+                ListOrderedMap.listOrderedMap(new HashMap<K, V>()).mapIterator());\n+    }\n+\n+    @Override\n+    public OrderedMapIterator<K, V> makeObject() {\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(getMap().mapIterator());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public OrderedMap<K, V> getMap() {\n+        final OrderedMap<K, V> testMap = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V) \"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> getConfirmedMap() {\n+        final Map<K, V> testMap = new TreeMap<K, V>();\n+        testMap.put((K) \"A\", (V) \"a\");\n+        testMap.put((K) \"B\", (V) \"b\");\n+        testMap.put((K) \"C\", (V) \"c\");\n+        return testMap;\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsSetValue() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testOrderedMapIterator() {\n+        assertTrue(makeEmptyIterator() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        OrderedMapIterator<K, V> it = makeObject();\n+        assertSame(it, UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n+\n+        it = getMap().mapIterator() ;\n+        assertTrue(it != UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it));\n+\n+        try {\n+            UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract tests that can be extended to test any Map.Entry implementation.\n+ * Subclasses must implement {@link #makeMapEntry(Object, Object)} to return\n+ * a new Map.Entry of the type being tested. Subclasses must also implement\n+ * {@link #testConstructors()} to test the constructors of the Map.Entry\n+ * type being tested.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapEntryTest<K, V> extends TestCase {\n+    \n+    protected final String key = \"name\";\n+    protected final String value = \"duke\";\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public AbstractMapEntryTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * This implementation simply calls {@link #makeMapEntry(Object, Object)}\n+     * with null for key and value. Subclasses can override this method if desired.\n+     */\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return makeMapEntry(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    public abstract Map.Entry<K, V> makeMapEntry(K key, V value);\n+\n+    /**\n+     * Makes a Map.Entry of a type that's known to work correctly.\n+     */\n+    public Map.Entry<K, V> makeKnownMapEntry() {\n+        return makeKnownMapEntry(null, null);\n+    }\n+\n+    /**\n+     * Makes a Map.Entry of a type that's known to work correctly.\n+     */\n+    public Map.Entry<K, V> makeKnownMapEntry(final K key, final V value) {\n+        final Map<K, V> map = new HashMap<K, V>(1);\n+        map.put(key, value);\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        return entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+\n+        assertTrue(entry.getKey() == key);\n+\n+        entry.setValue((V) value);\n+        assertTrue(entry.getValue() == value);\n+\n+        // check that null doesn't do anything funny\n+        entry = makeMapEntry(null, null);\n+        assertTrue(entry.getKey() == null);\n+\n+        entry.setValue(null);\n+        assertTrue(entry.getValue() == null);\n+    }\n+\n+    /**\n+     * Subclasses should override this method to test the\n+     * desired behaviour of the class with respect to\n+     * handling of self-references.\n+     *\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        // test that #setValue does not permit\n+        //  the MapEntry to contain itself (and thus cause infinite recursion\n+        //  in #hashCode and #toString)\n+\n+        final Map.Entry<K, V> entry = makeMapEntry();\n+\n+        try {\n+            entry.setValue((V) entry);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(entry.getKey() == null && entry.getValue() == null);\n+        }\n+    }\n+\n+    /**\n+     * Subclasses should provide tests for their constructors.\n+     *\n+     */\n+    public abstract void testConstructors();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        // 1. test with object data\n+        Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);\n+        Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);\n+\n+        assertTrue(e1.equals(e1));\n+        assertTrue(e2.equals(e1));\n+        assertTrue(e1.equals(e2));\n+        assertTrue(e1.hashCode() == e2.hashCode());\n+\n+        // 2. test with nulls\n+        e1 = makeMapEntry();\n+        e2 = makeKnownMapEntry();\n+\n+        assertTrue(e1.equals(e1));\n+        assertTrue(e2.equals(e1));\n+        assertTrue(e1.equals(e2));\n+        assertTrue(e1.hashCode() == e2.hashCode());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToString() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+        assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n+\n+        // test with nulls\n+        entry = makeMapEntry();\n+        assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.keyvalue.DefaultKeyValue;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test the DefaultKeyValue class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DefaultKeyValueTest<K, V> extends TestCase {\n+    \n+    private final String key = \"name\";\n+    private final String value = \"duke\";\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public DefaultKeyValueTest(final String testName) {\n+        super(testName);\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of DefaultKeyValue with the default (null) key and value.\n+     * Subclasses should override this method to return a DefaultKeyValue\n+     * of the type being tested.\n+     */\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue() {\n+        return new DefaultKeyValue<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of DefaultKeyValue with the specified key and value.\n+     * Subclasses should override this method to return a DefaultKeyValue\n+     * of the type being tested.\n+     */\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue(final K key, final V value) {\n+        return new DefaultKeyValue<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        kv.setKey((K) key);\n+        assertTrue(kv.getKey() == key);\n+\n+        kv.setValue((V) value);\n+        assertTrue(kv.getValue() == value);\n+\n+        // check that null doesn't do anything funny\n+        kv.setKey(null);\n+        assertTrue(kv.getKey() == null);\n+\n+        kv.setValue(null);\n+        assertTrue(kv.getValue() == null);\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        // test that #setKey and #setValue do not permit\n+        //  the KVP to contain itself (and thus cause infinite recursion\n+        //  in #hashCode and #toString)\n+\n+        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        try {\n+            kv.setKey((K) kv);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(kv.getKey() == null && kv.getValue() == null);\n+        }\n+\n+        try {\n+            kv.setValue((V) kv);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (final IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(kv.getKey() == null && kv.getValue() == null);\n+        }\n+    }\n+\n+    /**\n+     * Subclasses should override this method to test their own constructors.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test default constructor\n+        DefaultKeyValue<K, V> kv = new DefaultKeyValue<K, V>();\n+        assertTrue(kv.getKey() == null && kv.getValue() == null);\n+\n+        // 2. test key-value constructor\n+        kv = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        assertTrue(kv.getKey() == key && kv.getValue() == value);\n+\n+        // 3. test copy constructor\n+        final DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<K, V>(kv);\n+        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n+\n+        // test that the KVPs are independent\n+        kv.setKey(null);\n+        kv.setValue(null);\n+\n+        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n+\n+        // 4. test Map.Entry constructor\n+        final Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) key, (V) value);\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        kv = new DefaultKeyValue<K, V>(entry);\n+        assertTrue(kv.getKey() == key && kv.getValue() == value);\n+\n+        // test that the KVP is independent of the Map.Entry\n+        entry.setValue(null);\n+        assertTrue(kv.getValue() == value);\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        // 1. test with object data\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);\n+\n+        assertTrue(kv.equals(kv));\n+        assertTrue(kv.equals(kv2));\n+        assertTrue(kv.hashCode() == kv2.hashCode());\n+\n+        // 2. test with nulls\n+        kv = makeDefaultKeyValue(null, null);\n+        kv2 = makeDefaultKeyValue(null, null);\n+\n+        assertTrue(kv.equals(kv));\n+        assertTrue(kv.equals(kv2));\n+        assertTrue(kv.hashCode() == kv2.hashCode());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToString() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n+\n+        // test with nulls\n+        kv = makeDefaultKeyValue(null, null);\n+        assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToMapEntry() {\n+        final DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+\n+        final Map<K, V> map = new HashMap<K, V>();\n+        map.put(kv.getKey(), kv.getValue());\n+        final Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        assertTrue(entry.equals(kv.toMapEntry()));\n+        assertTrue(entry.hashCode() == kv.hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/DefaultMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.keyvalue.DefaultKeyValue;\n+import org.apache.commons.collections4.keyvalue.DefaultMapEntry;\n+\n+/**\n+ * Test the DefaultMapEntry class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DefaultMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n+\n+    public DefaultMapEntryTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new DefaultMapEntry<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n+        return new DefaultMapEntry<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Subclasses should override this method.\n+     *\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test key-value constructor\n+        final Map.Entry<K, V> entry = new DefaultMapEntry<K, V>((K) key, (V) value);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 2. test pair constructor\n+        final KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        assertSame(key, pair.getKey());\n+        assertSame(value, pair.getValue());\n+\n+        // 3. test copy constructor\n+        final Map.Entry<K, V> entry2 = new DefaultMapEntry<K, V>(entry);\n+        assertSame(key, entry2.getKey());\n+        assertSame(value, entry2.getValue());\n+\n+        // test that the objects are independent\n+        entry.setValue(null);\n+        assertSame(value, entry2.getValue());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        final Map.Entry<K, V> entry = makeMapEntry();\n+\n+        try {\n+            entry.setValue((V) entry);\n+            assertSame(entry, entry.getValue());\n+\n+        } catch (final Exception e) {\n+            fail(\"This Map.Entry implementation supports value self-reference.\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.keyvalue.MultiKey;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.collections4.keyvalue.MultiKey}.\n+ *\n+ * @version $Id$\n+ */\n+public class MultiKeyTest extends TestCase {\n+\n+    Integer ONE = new Integer(1);\n+    Integer TWO = new Integer(2);\n+    Integer THREE = new Integer(3);\n+    Integer FOUR = new Integer(4);\n+    Integer FIVE = new Integer(5);\n+\n+    public MultiKeyTest(final String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructors() throws Exception {\n+        MultiKey<Integer> mk = null;\n+        mk = new MultiKey<Integer>(ONE, TWO);\n+        assertTrue(Arrays.equals(new Object[] { ONE, TWO }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE);\n+        assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE, FOUR);\n+        assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE, FOUR, FIVE);\n+        assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR, FIVE }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(new Integer[] { THREE, FOUR, ONE, TWO }, false);\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+    }\n+\n+    public void testConstructorsByArray() throws Exception {\n+        MultiKey<Integer> mk = null;\n+        Integer[] keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys);\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+\n+        keys = new Integer[] {};\n+        mk = new MultiKey<Integer>(keys);\n+        assertTrue(Arrays.equals(new Object[] {}, mk.getKeys()));\n+\n+        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys, true);\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+\n+        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys, false);\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        // change key - don't do this!\n+        // the hashcode of the MultiKey is now broken\n+        keys[3] = FIVE;\n+        assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, FIVE }, mk.getKeys()));\n+    }\n+\n+    public void testConstructorsByArrayNull() throws Exception {\n+        final Integer[] keys = null;\n+        try {\n+            new MultiKey<Integer>(keys);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey<Integer>(keys, true);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey<Integer>(keys, false);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        assertEquals(2, new MultiKey<Integer>(ONE, TWO).size());\n+        assertEquals(2, new MultiKey<Object>(null, null).size());\n+        assertEquals(3, new MultiKey<Integer>(ONE, TWO, THREE).size());\n+        assertEquals(3, new MultiKey<Object>(null, null, null).size());\n+        assertEquals(4, new MultiKey<Integer>(ONE, TWO, THREE, FOUR).size());\n+        assertEquals(4, new MultiKey<Object>(null, null, null, null).size());\n+        assertEquals(5, new MultiKey<Integer>(ONE, TWO, THREE, FOUR, FIVE).size());\n+        assertEquals(5, new MultiKey<Object>(null, null, null, null, null).size());\n+\n+        assertEquals(0, new MultiKey<Object>(new Object[] {}).size());\n+        assertEquals(1, new MultiKey<Integer>(new Integer[] { ONE }).size());\n+        assertEquals(2, new MultiKey<Integer>(new Integer[] { ONE, TWO }).size());\n+        assertEquals(7, new MultiKey<Integer>(new Integer[] { ONE, TWO, ONE, TWO, ONE, TWO, ONE }).size());\n+    }\n+\n+    public void testGetIndexed() {\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        assertSame(ONE, mk.getKey(0));\n+        assertSame(TWO, mk.getKey(1));\n+        try {\n+            mk.getKey(-1);\n+            fail();\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            mk.getKey(2);\n+            fail();\n+        } catch (final IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetKeysSimpleConstructor() {\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        final Object[] array = mk.getKeys();\n+        assertSame(ONE, array[0]);\n+        assertSame(TWO, array[1]);\n+        assertEquals(2, array.length);\n+    }\n+\n+    public void testGetKeysArrayConstructorCloned() {\n+        final Integer[] keys = new Integer[] { ONE, TWO };\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(keys, true);\n+        final Object[] array = mk.getKeys();\n+        assertTrue(array != keys);\n+        assertTrue(Arrays.equals(array, keys));\n+        assertSame(ONE, array[0]);\n+        assertSame(TWO, array[1]);\n+        assertEquals(2, array.length);\n+    }\n+\n+    public void testGetKeysArrayConstructorNonCloned() {\n+        final Integer[] keys = new Integer[] { ONE, TWO };\n+        final MultiKey<Integer> mk = new MultiKey<Integer>(keys, false);\n+        final Object[] array = mk.getKeys();\n+        assertTrue(array != keys);  // still not equal\n+        assertTrue(Arrays.equals(array, keys));\n+        assertSame(ONE, array[0]);\n+        assertSame(TWO, array[1]);\n+        assertEquals(2, array.length);\n+    }\n+\n+    public void testHashCode() {\n+        final MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+\n+        assertTrue(mk1.hashCode() == mk1.hashCode());\n+        assertTrue(mk1.hashCode() == mk2.hashCode());\n+        assertTrue(mk1.hashCode() != mk3.hashCode());\n+\n+        final int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();\n+        assertEquals(total, mk1.hashCode());\n+    }\n+\n+    public void testEquals() {\n+        final MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        final MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+\n+        assertEquals(mk1, mk1);\n+        assertEquals(mk1, mk2);\n+        assertTrue(mk1.equals(mk3) == false);\n+        assertTrue(mk1.equals(\"\") == false);\n+        assertTrue(mk1.equals(null) == false);\n+    }\n+\n+    static class SystemHashCodeSimulatingKey implements Serializable {\n+\n+        private static final long serialVersionUID = -1736147315703444603L;\n+        private final String name;\n+        private int hashCode = 1;\n+\n+        public SystemHashCodeSimulatingKey(final String name)\n+        {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj)\n+        {\n+            return obj instanceof SystemHashCodeSimulatingKey \n+                && name.equals(((SystemHashCodeSimulatingKey)obj).name);\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            return hashCode;\n+        }\n+\n+        private Object readResolve() {\n+            hashCode=2; // simulate different hashCode after deserialization in another process\n+            return this;\n+        }\n+    }\n+    \n+    public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException\n+    {\n+        SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n+        final MultiKey mk = new MultiKey(ONE, sysKey);\n+        final Map map = new HashMap();\n+        map.put(mk, TWO);\n+\n+        // serialize\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(sysKey);\n+        out.writeObject(map);\n+        out.close();\n+\n+        // deserialize\n+        final ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        final ObjectInputStream in = new ObjectInputStream(bais);\n+        sysKey = (SystemHashCodeSimulatingKey)in.readObject(); // simulate deserialization in another process\n+        final Map map2 = (Map) in.readObject();\n+        in.close();\n+\n+        assertEquals(2, sysKey.hashCode()); // different hashCode now\n+\n+        final MultiKey mk2 = new MultiKey(ONE, sysKey);\n+        assertEquals(TWO, map2.get(mk2));        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/TiedMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.keyvalue.TiedMapEntry;\n+\n+/**\n+ * Test the TiedMapEntry class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TiedMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n+\n+    public TiedMapEntryTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the instance to test\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n+        final Map<K, V> map = new HashMap<K, V>();\n+        map.put(key, value);\n+        return new TiedMapEntry<K, V>(map, key);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests the constructors.\n+     */\n+    @Override\n+    public void testConstructors() {\n+        // ignore\n+    }\n+\n+    /**\n+     * Tests the constructors.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValue() {\n+        final Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"A\", (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        map.put((K) \"C\", (V) \"c\");\n+        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(map, (K) \"A\");\n+        assertSame(\"A\", entry.getKey());\n+        assertSame(\"a\", entry.getValue());\n+        assertSame(\"a\", entry.setValue((V) \"x\"));\n+        assertSame(\"A\", entry.getKey());\n+        assertSame(\"x\", entry.getValue());\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"B\");\n+        assertSame(\"B\", entry.getKey());\n+        assertSame(\"b\", entry.getValue());\n+        assertSame(\"b\", entry.setValue((V) \"y\"));\n+        assertSame(\"B\", entry.getKey());\n+        assertSame(\"y\", entry.getValue());\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"C\");\n+        assertSame(\"C\", entry.getKey());\n+        assertSame(\"c\", entry.getValue());\n+        assertSame(\"c\", entry.setValue((V) \"z\"));\n+        assertSame(\"C\", entry.getKey());\n+        assertSame(\"z\", entry.getValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/UnmodifiableMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.keyvalue.DefaultKeyValue;\n+import org.apache.commons.collections4.keyvalue.UnmodifiableMapEntry;\n+\n+/**\n+ * Test the UnmodifiableMapEntry class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n+\n+    public UnmodifiableMapEntryTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new UnmodifiableMapEntry<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(final K key, final V value) {\n+        return new UnmodifiableMapEntry<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Subclasses should override this method.\n+     *\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test key-value constructor\n+        Map.Entry<K, V> entry = new UnmodifiableMapEntry<K, V>((K) key, (V) value);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 2. test pair constructor\n+        final KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        entry = new UnmodifiableMapEntry<K, V>(pair);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 3. test copy constructor\n+        final Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<K, V>(entry);\n+        assertSame(key, entry2.getKey());\n+        assertSame(value, entry2.getValue());\n+\n+        assertTrue(entry instanceof Unmodifiable);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // check that null doesn't do anything funny\n+        entry = makeMapEntry(null, null);\n+        assertSame(null, entry.getKey());\n+        assertSame(null, entry.getValue());\n+    }\n+\n+    @Override\n+    public void testSelfReferenceHandling() {\n+        // block\n+    }\n+\n+    public void testUnmodifiable() {\n+        final Map.Entry<K, V> entry = makeMapEntry();\n+        try {\n+            entry.setValue(null);\n+            fail();\n+        } catch (final UnsupportedOperationException ex) {}\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/AbstractLinkedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.collections4.list.AbstractLinkedList;\n+\n+/**\n+ * Test case for {@link AbstractLinkedList}.\n+ *\n+ * @version $Id$\n+ * @author David Hay\n+ */\n+public abstract class AbstractLinkedListTest<E> extends AbstractListTest<E> {\n+\n+    public AbstractLinkedListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFirst() {\n+        resetEmpty();\n+        final AbstractLinkedList<E> list = getCollection();\n+        if (isRemoveSupported() == false) {\n+            try {\n+                list.removeFirst();\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value1\", list.removeFirst());\n+        checkNodes();\n+        list.addLast((E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.removeFirst());\n+        assertEquals(\"value3\", list.removeFirst());\n+        checkNodes();\n+        list.addLast((E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value4\", list.removeFirst());\n+        checkNodes();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLast() {\n+        resetEmpty();\n+        final AbstractLinkedList<E> list = getCollection();\n+        if (isRemoveSupported() == false) {\n+            try {\n+                list.removeLast();\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        assertEquals(\"value2\", list.removeLast());\n+        list.addFirst((E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value1\", list.removeLast());\n+        assertEquals(\"value3\", list.removeLast());\n+        list.addFirst((E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value4\", list.removeFirst());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddNodeAfter() {\n+        resetEmpty();\n+        final AbstractLinkedList<E> list = getCollection();\n+        if (isAddSupported() == false) {\n+            try {\n+                list.addFirst(null);\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+\n+        list.addFirst((E) \"value1\");\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value2\");\n+        assertEquals(\"value1\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.removeFirst();\n+        checkNodes();\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value3\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        list.addNodeAfter(list.getNode(0, false), (E) \"value4\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value3\", list.getLast());\n+        assertEquals(\"value4\", list.get(1));\n+        list.addNodeAfter(list.getNode(2, false), (E) \"value5\");\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value4\", list.get(1));\n+        assertEquals(\"value3\", list.get(2));\n+        assertEquals(\"value5\", list.getLast());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveNode() {\n+        resetEmpty();\n+        if (isAddSupported() == false || isRemoveSupported() == false) {\n+            return;\n+        }\n+        final AbstractLinkedList<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        assertEquals(\"value2\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        list.addFirst((E) \"value1\");\n+        list.addFirst((E) \"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value2\", list.getLast());\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        assertEquals(\"value0\", list.getFirst());\n+        assertEquals(\"value0\", list.getLast());\n+        checkNodes();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGetNode() {\n+        resetEmpty();\n+        final AbstractLinkedList<E> list = getCollection();\n+        // get marker\n+        assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n+        try {\n+            list.getNode(0, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        list.addAll( Arrays.asList((E[]) new String[]{\"value1\", \"value2\"}));\n+        checkNodes();\n+        list.addFirst((E) \"value0\");\n+        checkNodes();\n+        list.removeNode(list.getNode(1, false));\n+        checkNodes();\n+        try {\n+            list.getNode(2, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+        try {\n+            list.getNode(-1, false);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+         try {\n+            list.getNode(3, true);\n+            fail(\"Expecting IndexOutOfBoundsException.\");\n+        } catch (final IndexOutOfBoundsException ex) {\n+            // expected\n+        }\n+    }\n+\n+    protected void checkNodes() {\n+        final AbstractLinkedList<E> list = getCollection();\n+        for (int i = 0; i < list.size; i++) {\n+            assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n+            if (i < list.size - 1) {\n+                assertEquals(list.getNode(i + 1, false).previous,\n+                    list.getNode(i, false));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public AbstractLinkedList<E> getCollection() {\n+        return (AbstractLinkedList<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/AbstractListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+import org.apache.commons.collections4.iterators.AbstractListIteratorTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.List} methods and contracts.\n+ * <p>\n+ * To use, simply extend this class, and implement\n+ * the {@link #makeObject} method.\n+ * <p>\n+ * If your {@link List} fails one of these tests by design,\n+ * you may still use this base set of cases.  Simply override the\n+ * test case (method) your {@link List} fails or override one of the\n+ * protected methods from AbstractTestCollection.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractListTest<E> extends AbstractCollectionTest<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test class name\n+     */\n+    public AbstractListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns true if the collections produced by\n+     *  {@link #makeObject()} and {@link #makeFullCollection()}\n+     *  support the <code>set operation.<p>\n+     *  Default implementation returns true.  Override if your collection\n+     *  class does not support set.\n+     */\n+    public boolean isSetSupported() {\n+        return true;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that the test list implementation matches the confirmed list\n+     *  implementation.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void verify() {\n+        super.verify();\n+\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        assertEquals(\"List should equal confirmed\", list1, list2);\n+        assertEquals(\"Confirmed should equal list\", list2, list1);\n+\n+        assertEquals(\"Hash codes should be equal\", list1.hashCode(), list2.hashCode());\n+\n+        int i = 0;\n+        final Iterator<E> iterator1 = list1.iterator();\n+        final Iterator<E> iterator2 = list2.iterator();\n+        final E[] array = (E[]) list1.toArray();\n+        while (iterator2.hasNext()) {\n+            assertTrue(\"List iterator should have next\", iterator1.hasNext());\n+            final Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(\"Iterator elements should be equal\", o1, o2);\n+            o2 = list1.get(i);\n+            assertEquals(\"get should return correct element\", o1, o2);\n+            o2 = array[i];\n+            assertEquals(\"toArray should have correct element\", o1, o2);\n+            i++;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * List equals method is defined.\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns an empty {@link ArrayList}.\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        return list;\n+    }\n+\n+    /**\n+     * Returns a full {@link ArrayList}.\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Returns {@link #makeObject()}.\n+     *\n+     * @return an empty list to be used for testing\n+     */\n+    @Override\n+    public abstract List<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> makeFullCollection() {\n+        // only works if list supports optional \"addAll(Collection)\"\n+        final List<E> list = makeObject();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the {@link #collection} field cast to a {@link List}.\n+     *\n+     * @return the collection field as a List\n+     */\n+    @Override\n+    public List<E> getCollection() {\n+        return (List<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * Returns the {@link #confirmed} field cast to a {@link List}.\n+     *\n+     * @return the confirmed field as a List\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on an\n+     *  empty list.\n+     */\n+    public void testListAddByIndexBoundsChecking() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        List<E> list;\n+        final E element = getOtherElements()[0];\n+\n+        try {\n+            list = makeObject();\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeObject();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeObject();\n+            list.add(1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeObject();\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#add(int, Object)} on a\n+     *  full list.\n+     */\n+    public void testListAddByIndexBoundsChecking2() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        List<E> list;\n+        final E element = getOtherElements()[0];\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(Integer.MIN_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(list.size() + 1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [size + 1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list = makeFullCollection();\n+            list.add(Integer.MAX_VALUE, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#add(int,Object)}.\n+     */\n+    public void testListAddByIndex() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        final E element = getOtherElements()[0];\n+        final int max = getFullElements().length;\n+\n+        for (int i = 0; i <= max; i++) {\n+            resetFull();\n+            getCollection().add(i, element);\n+            getConfirmed().add(i, element);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#equals(Object)}.\n+     */\n+    public void testListEquals() {\n+        resetEmpty();\n+        List<E> list = getCollection();\n+        assertEquals(\"Empty lists should be equal\", true, list.equals(getConfirmed()));\n+        verify();\n+        assertEquals(\"Empty list should equal self\", true, list.equals(list));\n+        verify();\n+\n+        List<E> list2 = Arrays.asList(getFullElements());\n+        assertEquals(\"Empty list shouldn't equal full\", false, list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertEquals(\"Empty list shouldn't equal other\", false, list.equals(list2));\n+        verify();\n+\n+        resetFull();\n+        list = getCollection();\n+        assertEquals(\"Full lists should be equal\", true, list.equals(getConfirmed()));\n+        verify();\n+        assertEquals(\"Full list should equal self\", true, list.equals(list));\n+        verify();\n+\n+        list2 = makeObject();\n+        assertEquals(\"Full list shouldn't equal empty\", false, list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getOtherElements());\n+        assertEquals(\"Full list shouldn't equal other\", false, list.equals(list2));\n+        verify();\n+\n+        list2 = Arrays.asList(getFullElements());\n+        if (list2.size() < 2 && isAddSupported()) {\n+            // main list is only size 1, so lets add other elements to get a better list\n+            list.addAll(Arrays.asList(getOtherElements()));\n+            getConfirmed().addAll(Arrays.asList(getOtherElements()));\n+            list2 = new ArrayList<E>(list2);\n+            list2.addAll(Arrays.asList(getOtherElements()));\n+        }\n+        if (list2.size() > 1) {\n+            Collections.reverse(list2);\n+            assertEquals(\n+                \"Full list shouldn't equal full list with same elements but different order\",\n+                false, list.equals(list2));\n+            verify();\n+        }\n+\n+        resetFull();\n+        list = getCollection();\n+        assertEquals(\"List shouldn't equal String\", false, list.equals(\"\"));\n+        verify();\n+\n+        final List<E> listForC = Arrays.asList(getFullElements());\n+        final Collection<E> c = new AbstractCollection<E>() {\n+            @Override\n+            public int size() {\n+                return listForC.size();\n+            }\n+\n+            @Override\n+            public Iterator<E> iterator() {\n+                return listForC.iterator();\n+            }\n+        };\n+\n+        assertEquals(\"List shouldn't equal nonlist with same elements in same order\", false, list.equals(c));\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link List#hashCode()}.\n+     */\n+    public void testListHashCode() {\n+        resetEmpty();\n+        int hash1 = getCollection().hashCode();\n+        int hash2 = getConfirmed().hashCode();\n+        assertEquals(\"Empty lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+\n+        resetFull();\n+        hash1 = getCollection().hashCode();\n+        hash2 = getConfirmed().hashCode();\n+        assertEquals(\"Full lists should have equal hashCodes\", hash1, hash2);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link List#get(int)}.\n+     */\n+    public void testListGetByIndex() {\n+        resetFull();\n+        final List<E> list = getCollection();\n+        final E[] elements = getFullElements();\n+        for (int i = 0; i < elements.length; i++) {\n+            assertEquals(\"List should contain correct elements\", elements[i], list.get(i));\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on an\n+     *  empty list.\n+     */\n+    public void testListGetByIndexBoundsChecking() {\n+        final List<E> list = makeObject();\n+\n+        try {\n+            list.get(Integer.MIN_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(-1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(0);\n+            fail(\"List.get should throw IndexOutOfBoundsException [0]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(Integer.MAX_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#get(int)} on a\n+     *  full list.\n+     */\n+    public void testListGetByIndexBoundsChecking2() {\n+        final List<E> list = makeFullCollection();\n+\n+        try {\n+            list.get(Integer.MIN_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(-1);\n+            fail(\"List.get should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(getFullElements().length);\n+            fail(\"List.get should throw IndexOutOfBoundsException [size]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(Integer.MAX_VALUE);\n+            fail(\"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#indexOf}.\n+     */\n+    public void testListIndexOf() {\n+        resetFull();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final Iterator<E> iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            final Object element = iterator.next();\n+            assertEquals(\"indexOf should return correct result\",\n+                list1.indexOf(element), list2.indexOf(element));\n+            verify();\n+        }\n+\n+        final E[] other = getOtherElements();\n+        for (final E element : other) {\n+            assertEquals(\"indexOf should return -1 for nonexistent element\",\n+                -1, list1.indexOf(element));\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests {@link List#lastIndexOf}.\n+     */\n+    public void testListLastIndexOf() {\n+        resetFull();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final Iterator<E> iterator = list2.iterator();\n+        while (iterator.hasNext()) {\n+            final E element = iterator.next();\n+            assertEquals(\"lastIndexOf should return correct result\",\n+              list1.lastIndexOf(element), list2.lastIndexOf(element));\n+            verify();\n+        }\n+\n+        final E[] other = getOtherElements();\n+        for (final E element : other) {\n+            assertEquals(\"lastIndexOf should return -1 for nonexistent \" +\n+                \"element\", -1, list1.lastIndexOf(element));\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on an\n+     *  empty list.\n+     */\n+    public void testListSetByIndexBoundsChecking() {\n+        if (!isSetSupported()) {\n+            return;\n+        }\n+\n+        final List<E> list = makeObject();\n+        final E element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(0, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [0]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests bounds checking for {@link List#set(int,Object)} on a\n+     *  full list.\n+     */\n+    public void testListSetByIndexBoundsChecking2() {\n+        if (!isSetSupported()) {\n+            return;\n+        }\n+\n+        final List<E> list = makeFullCollection();\n+        final E element = getOtherElements()[0];\n+\n+        try {\n+            list.set(Integer.MIN_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(getFullElements().length, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [size]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.set(Integer.MAX_VALUE, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Test {@link List#set(int,Object)}.\n+     */\n+    public void testListSetByIndex() {\n+        if (!isSetSupported()) {\n+            return;\n+        }\n+\n+        resetFull();\n+        final E[] elements = getFullElements();\n+        final E[] other = getOtherElements();\n+\n+        for (int i = 0; i < elements.length; i++) {\n+            final E n = other[i % other.length];\n+            final E v = getCollection().set(i, n);\n+            assertEquals(\"Set should return correct element\", elements[i], v);\n+            getConfirmed().set(i, n);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  If {@link #isSetSupported()} returns false, tests that set operation\n+     *  raises <Code>UnsupportedOperationException.\n+     */\n+    public void testUnsupportedSet() {\n+        if (isSetSupported()) {\n+            return;\n+        }\n+\n+        resetFull();\n+        try {\n+            getCollection().set(0, getFullElements()[0]);\n+            fail(\"Emtpy collection should not support set.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        // make sure things didn't change even if the expected exception was\n+        // thrown.\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on an\n+     *  empty list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        final List<E> list = makeObject();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(0);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [0]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [1]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests bounds checking for {@link List#remove(int)} on a\n+     *  full list.\n+     */\n+    public void testListRemoveByIndexBoundsChecking2() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        final List<E> list = makeFullCollection();\n+\n+        try {\n+            list.remove(Integer.MIN_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MIN_VALUE]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(-1);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [-1]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(getFullElements().length);\n+            fail(\"List.remove should throw IndexOutOfBoundsException [size]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.remove(Integer.MAX_VALUE);\n+            fail(\"List.remove should throw IndexOutOfBoundsException \" +\n+              \"[Integer.MAX_VALUE]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests {@link List#remove(int)}.\n+     */\n+    public void testListRemoveByIndex() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        final int max = getFullElements().length;\n+        for (int i = 0; i < max; i++) {\n+            resetFull();\n+            final E o1 = getCollection().remove(i);\n+            final E o2 = getConfirmed().remove(i);\n+            assertEquals(\"remove should return correct element\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator()}.\n+     */\n+    public void testListListIterator() {\n+        resetFull();\n+        forwardTest(getCollection().listIterator(), 0);\n+        backwardTest(getCollection().listIterator(), 0);\n+    }\n+\n+    /**\n+     *  Tests the read-only bits of {@link List#listIterator(int)}.\n+     */\n+    public void testListListIteratorByIndex() {\n+        resetFull();\n+        try {\n+            getCollection().listIterator(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        resetFull();\n+        try {\n+            getCollection().listIterator(getCollection().size() + 1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        resetFull();\n+        for (int i = 0; i <= getConfirmed().size(); i++) {\n+            forwardTest(getCollection().listIterator(i), i);\n+            backwardTest(getCollection().listIterator(i), i);\n+        }\n+        resetFull();\n+        for (int i = 0; i <= getConfirmed().size(); i++) {\n+            backwardTest(getCollection().listIterator(i), i);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorPreviousRemoveNext() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n+        final E two2 = it.previous();\n+        final E one2 = it.previous();\n+        assertEquals(one, one2);\n+        assertEquals(two, two2);\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n+        it.remove(); // removed element at index 1 (one)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(two, getCollection().get(1));\n+        final E two3 = it.next();  // do next after remove\n+        assertEquals(two, two3);\n+        assertEquals(getCollection().size() > 2, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorPreviousRemovePrevious() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n+        final E two2 = it.previous();\n+        final E one2 = it.previous();\n+        assertEquals(one, one2);\n+        assertEquals(two, two2);\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n+        it.remove(); // removed element at index 1 (one)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(two, getCollection().get(1));\n+        final E zero3 = it.previous();  // do previous after remove\n+        assertEquals(zero, zero3);\n+        assertEquals(false, it.hasPrevious());\n+        assertEquals(getCollection().size() > 2, it.hasNext());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorNextRemoveNext() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+        final E three = getCollection().get(3);\n+\n+        it.remove(); // removed element at index 2 (two)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        final E three2 = it.next();  // do next after remove\n+        assertEquals(three, three2);\n+        assertEquals(getCollection().size() > 3, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    /**\n+     * Tests remove on list iterator is correct.\n+     */\n+    public void testListListIteratorNextRemovePrevious() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        resetFull();\n+        if (getCollection().size() < 4) {\n+            return;\n+        }\n+        final ListIterator<E> it = getCollection().listIterator();\n+        final E zero = it.next();\n+        final E one = it.next();\n+        final E two = it.next();\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        assertEquals(two, getCollection().get(2));\n+\n+        it.remove(); // removed element at index 2 (two)\n+        assertEquals(zero, getCollection().get(0));\n+        assertEquals(one, getCollection().get(1));\n+        final E one2 = it.previous();  // do previous after remove\n+        assertEquals(one, one2);\n+        assertEquals(true, it.hasNext());\n+        assertEquals(true, it.hasPrevious());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Traverses to the end of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void forwardTest(final ListIterator<E> iter, int i) {\n+        final List<E> list = getCollection();\n+        final int max = getFullElements().length;\n+\n+        while (i < max) {\n+            assertTrue(\"Iterator should have next\", iter.hasNext());\n+            assertEquals(\"Iterator.nextIndex should work\",\n+                i, iter.nextIndex());\n+            assertEquals(\"Iterator.previousIndex should work\",\n+                i - 1, iter.previousIndex());\n+            final Object o = iter.next();\n+            assertEquals(\"Iterator returned correct element\", list.get(i), o);\n+            i++;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have next\", !iter.hasNext());\n+        assertEquals(\"nextIndex should be size\", max, iter.nextIndex());\n+        assertEquals(\"previousIndex should be size - 1\", max - 1, iter.previousIndex());\n+\n+        try {\n+            iter.next();\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Traverses to the beginning of the given iterator.\n+     *\n+     *  @param iter  the iterator to traverse\n+     *  @param i     the starting index\n+     */\n+    private void backwardTest(final ListIterator<E> iter, int i) {\n+        final List<E> list = getCollection();\n+\n+        while (i > 0) {\n+            assertTrue(\"Iterator should have previous, i:\" + i,\n+                iter.hasPrevious());\n+            assertEquals(\"Iterator.nextIndex should work, i:\" + i,\n+                i, iter.nextIndex());\n+            assertEquals(\"Iterator.previousIndex should work, i:\" + i,\n+                i - 1, iter.previousIndex());\n+            final E o = iter.previous();\n+            assertEquals(\"Iterator returned correct element\",\n+                list.get(i - 1), o);\n+            i--;\n+        }\n+\n+        assertTrue(\"Iterator shouldn't have previous\", !iter.hasPrevious());\n+        final int nextIndex = iter.nextIndex();\n+        assertEquals(\"nextIndex should be 0\", 0, nextIndex);\n+        final int prevIndex = iter.previousIndex();\n+        assertEquals(\"previousIndex should be -1\", -1, prevIndex);\n+\n+        try {\n+            iter.previous();\n+            fail(\"Exhausted iterator should raise NoSuchElement\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Tests the {@link ListIterator#add(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorAdd() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+\n+        resetEmpty();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final E[] elements = getFullElements();\n+        ListIterator<E> iter1 = list1.listIterator();\n+        ListIterator<E> iter2 = list2.listIterator();\n+\n+        for (final E element : elements) {\n+            iter1.add(element);\n+            iter2.add(element);\n+            verify();\n+        }\n+\n+        resetFull();\n+        iter1 = getCollection().listIterator();\n+        iter2 = getConfirmed().listIterator();\n+        for (final E element : elements) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(element);\n+            iter2.add(element);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     *  Tests the {@link ListIterator#set(Object)} method of the list\n+     *  iterator.\n+     */\n+    public void testListIteratorSet() {\n+        if (!isSetSupported()) {\n+            return;\n+        }\n+\n+        final E[] elements = getFullElements();\n+\n+        resetFull();\n+        final ListIterator<E> iter1 = getCollection().listIterator();\n+        final ListIterator<E> iter2 = getConfirmed().listIterator();\n+        for (final E element : elements) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.set(element);\n+            iter2.set(element);\n+            verify();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyListSerialization() throws IOException, ClassNotFoundException {\n+        final List<E> list = makeObject();\n+        if (!(list instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n+\n+        final byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        final List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Both lists are empty\", 0, list.size());\n+        assertEquals(\"Both lists are empty\", 0, list2.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullListSerialization() throws IOException, ClassNotFoundException {\n+        final List<E> list = makeFullCollection();\n+        final int size = getFullElements().length;\n+        if (!(list instanceof Serializable && isTestSerialization())) {\n+            return;\n+        }\n+\n+        final byte[] objekt = writeExternalFormToBytes((Serializable) list);\n+        final List<E> list2 = (List<E>) readExternalFormFromBytes(objekt);\n+\n+        assertEquals(\"Both lists are same size\", size, list.size());\n+        assertEquals(\"Both lists are same size\", size, list2.size());\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the List\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        List list = makeEmptyList();\n+        if (!(list instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        final List<E> list = makeObject();\n+        if (list instanceof Serializable && !skipSerializedCanonicalTests()\n+                && isTestSerialization()) {\n+            final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n+            assertEquals(\"List is empty\", 0, list2.size());\n+            assertEquals(list, list2);\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the List\n+     * against the canonical version in SVN.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFullListCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        List list = makeFullList();\n+        if (!(list instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        final List<E> list = makeFullCollection();\n+        if(list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n+            if (list2.size() == 4) {\n+                // old serialized tests\n+                return;\n+            }\n+            assertEquals(\"List is the right size\",list.size(), list2.size());\n+            assertEquals(list, list2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.\n+     *  The returned bulk test will run through every <code>TestList</code>\n+     *  method, <i>including</i> another <code>bulkTestSubList</code>.\n+     *  Sublists are tested until the size of the sublist is less than 10.\n+     *  Each sublist is 6 elements smaller than its parent list.\n+     *  (By default this means that two rounds of sublists will be tested).\n+     *  The verify() method is overloaded to test that the original list is\n+     *  modified when the sublist is.\n+     */\n+    public BulkTest bulkTestSubList() {\n+        if (getFullElements().length - 6 < 10) {\n+            return null;\n+        }\n+        return new BulkTestSubList<E>(this);\n+    }\n+\n+   public static class BulkTestSubList<E> extends AbstractListTest<E> {\n+\n+       private final AbstractListTest<E> outer;\n+\n+       public BulkTestSubList(final AbstractListTest<E> outer) {\n+           super(\"\");\n+           this.outer = outer;\n+       }\n+\n+       @Override\n+       @SuppressWarnings(\"unchecked\")\n+       public E[] getFullElements() {\n+           final List<E> l = Arrays.asList(outer.getFullElements());\n+           return (E[]) l.subList(3, l.size() - 3).toArray();\n+       }\n+\n+       @Override\n+       public E[] getOtherElements() {\n+           return outer.getOtherElements();\n+       }\n+\n+       @Override\n+       public boolean isAddSupported() {\n+           return outer.isAddSupported();\n+       }\n+\n+       @Override\n+       public boolean isSetSupported() {\n+           return outer.isSetSupported();\n+       }\n+\n+       @Override\n+       public boolean isRemoveSupported() {\n+           return outer.isRemoveSupported();\n+       }\n+\n+       @Override\n+       public List<E> makeObject() {\n+           return outer.makeFullCollection().subList(4, 4);\n+       }\n+\n+       @Override\n+       public List<E> makeFullCollection() {\n+           final int size = getFullElements().length;\n+           return outer.makeFullCollection().subList(3, size - 3);\n+       }\n+\n+       @Override\n+       public void resetEmpty() {\n+           outer.resetFull();\n+           this.setCollection(outer.getCollection().subList(4, 4));\n+           this.setConfirmed(outer.getConfirmed().subList(4, 4));\n+       }\n+\n+       @Override\n+       public void resetFull() {\n+           outer.resetFull();\n+           final int size = outer.getConfirmed().size();\n+           this.setCollection(outer.getCollection().subList(3, size - 3));\n+           this.setConfirmed(outer.getConfirmed().subList(3, size - 3));\n+       }\n+\n+       @Override\n+       public void verify() {\n+           super.verify();\n+           outer.verify();\n+       }\n+\n+       @Override\n+       public boolean isTestSerialization() {\n+           return false;\n+       }\n+   }\n+\n+   /**\n+    *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n+    *  if elements are added to the original list.\n+    */\n+   public void testListSubListFailFastOnAdd() {\n+       if (!isFailFastSupported()) {\n+        return;\n+    }\n+       if (!isAddSupported()) {\n+        return;\n+    }\n+\n+       resetFull();\n+       final int size = getCollection().size();\n+       List<E> sub = getCollection().subList(1, size);\n+       getCollection().add(getOtherElements()[0]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().add(0, getOtherElements()[0]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().addAll(Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().addAll(0, Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+   }\n+\n+   /**\n+    *  Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n+    *  if elements are removed from the original list.\n+    */\n+   public void testListSubListFailFastOnRemove() {\n+       if (!isFailFastSupported()) {\n+        return;\n+    }\n+       if (!isRemoveSupported()) {\n+        return;\n+    }\n+\n+       resetFull();\n+       final int size = getCollection().size();\n+       List<E> sub = getCollection().subList(1, size);\n+       getCollection().remove(0);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().remove(getFullElements()[2]);\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().removeAll(Arrays.asList(getFullElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().retainAll(Arrays.asList(getOtherElements()));\n+       failFastAll(sub);\n+\n+       resetFull();\n+       sub = getCollection().subList(1, size);\n+       getCollection().clear();\n+       failFastAll(sub);\n+   }\n+\n+   /**\n+    *  Invokes all the methods on the given sublist to make sure they raise\n+    *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n+    */\n+   protected void failFastAll(final List<E> list) {\n+       final Method[] methods = List.class.getMethods();\n+       for (final Method method : methods) {\n+           failFastMethod(list, method);\n+       }\n+   }\n+\n+   /**\n+    *  Invokes the given method on the given sublist to make sure it raises\n+    *  a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n+    *\n+    *  Unless the method happens to be the equals() method, in which case\n+    *  the test is skipped.  There seems to be a bug in\n+    *  java.util.AbstractList.subList(int,int).equals(Object) -- it never\n+    *  raises a ConcurrentModificationException.\n+    *\n+    *  @param list  the sublist to test\n+    *  @param m     the method to invoke\n+    */\n+   protected void failFastMethod(final List<E> list, final Method m) {\n+       if (m.getName().equals(\"equals\")) {\n+        return;\n+    }\n+\n+       final E element = getOtherElements()[0];\n+       final Collection<E> c = Collections.singleton(element);\n+\n+       final Class<?>[] types = m.getParameterTypes();\n+       final Object[] params = new Object[types.length];\n+       for (int i = 0; i < params.length; i++) {\n+           if (types[i] == Integer.TYPE) {\n+            params[i] = new Integer(0);\n+        } else if (types[i] == Collection.class) {\n+            params[i] = c;\n+        } else if (types[i] == Object.class) {\n+            params[i] = element;\n+        } else if (types[i] == Object[].class) {\n+            params[i] = new Object[0];\n+        }\n+       }\n+\n+       try {\n+           m.invoke(list, params);\n+           fail(m.getName() + \" should raise ConcurrentModification\");\n+       } catch (final IllegalAccessException e) {\n+           // impossible\n+       } catch (final InvocationTargetException e) {\n+           final Throwable t = e.getTargetException();\n+           if (t instanceof ConcurrentModificationException) {\n+               // expected\n+               return;\n+           } else {\n+               fail(m.getName() + \" raised unexpected \" + e);\n+           }\n+       }\n+   }\n+\n+   //-----------------------------------------------------------------------\n+   public BulkTest bulkTestListIterator() {\n+       return new TestListIterator();\n+   }\n+\n+   public class TestListIterator extends AbstractListIteratorTest<E> {\n+       public TestListIterator() {\n+           super(\"TestListIterator\");\n+       }\n+\n+       @Override\n+       public E addSetValue() {\n+           return AbstractListTest.this.getOtherElements()[0];\n+       }\n+\n+       @Override\n+       public boolean supportsRemove() {\n+           return AbstractListTest.this.isRemoveSupported();\n+       }\n+\n+       @Override\n+       public boolean supportsAdd() {\n+           return AbstractListTest.this.isAddSupported();\n+       }\n+\n+       @Override\n+       public boolean supportsSet() {\n+           return AbstractListTest.this.isSetSupported();\n+       }\n+\n+       @Override\n+       public ListIterator<E> makeEmptyIterator() {\n+           resetEmpty();\n+           return AbstractListTest.this.getCollection().listIterator();\n+       }\n+\n+       @Override\n+       public ListIterator<E> makeObject() {\n+           resetFull();\n+           return AbstractListTest.this.getCollection().listIterator();\n+       }\n+   }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/CursorableLinkedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.list.CursorableLinkedList;\n+\n+/**\n+ * Test class.\n+ *\n+ * @version $Id$\n+ */\n+public class CursorableLinkedListTest<E> extends AbstractLinkedListTest<E> {\n+    public CursorableLinkedListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(CursorableLinkedListTest.class);\n+    }\n+\n+    private CursorableLinkedList<E> list;\n+\n+    @Override\n+    public void setUp() {\n+        list = new CursorableLinkedList<E>();\n+    }\n+\n+    @Override\n+    public CursorableLinkedList<E> makeObject() {\n+        return new CursorableLinkedList<E>();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAdd() {\n+        assertEquals(\"[]\",list.toString());\n+        assertTrue(list.add((E) new Integer(1)));\n+        assertEquals(\"[1]\",list.toString());\n+        assertTrue(list.add((E) new Integer(2)));\n+        assertEquals(\"[1, 2]\",list.toString());\n+        assertTrue(list.add((E) new Integer(3)));\n+        assertEquals(\"[1, 2, 3]\",list.toString());\n+        assertTrue(list.addFirst((E) new Integer(0)));\n+        assertEquals(\"[0, 1, 2, 3]\",list.toString());\n+        assertTrue(list.addLast((E) new Integer(4)));\n+        assertEquals(\"[0, 1, 2, 3, 4]\",list.toString());\n+        list.add(0,(E) new Integer(-2));\n+        assertEquals(\"[-2, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(1,(E) new Integer(-1));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(7,(E) new Integer(5));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5]\",list.toString());\n+\n+        final java.util.List<E> list2 = new java.util.LinkedList<E>();\n+        list2.add((E) \"A\");\n+        list2.add((E) \"B\");\n+        list2.add((E) \"C\");\n+\n+        assertTrue(list.addAll(list2));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+        assertTrue(list.addAll(3,list2));\n+        assertEquals(\"[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClear() {\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        list.add((E) \"element\");\n+        assertEquals(1,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        list.add((E) \"element1\");\n+        list.add((E) \"element2\");\n+        assertEquals(2,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        for (int i = 0; i < 1000; i++) {\n+            list.add((E) new Integer(i));\n+        }\n+        assertEquals(1000, list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContains() {\n+        assertTrue(!list.contains(\"A\"));\n+        assertTrue(list.add((E) \"A\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.add((E) \"B\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.addFirst((E) \"a\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.remove(\"a\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.remove(\"A\"));\n+        assertTrue(!list.contains(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsAll() {\n+        assertTrue(list.containsAll(list));\n+        final java.util.List<E> list2 = new java.util.LinkedList<E>();\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"A\");\n+        assertTrue(!list.containsAll(list2));\n+        list.add((E) \"B\");\n+        list.add((E) \"A\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"B\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"C\");\n+        assertTrue(!list.containsAll(list2));\n+        list.add((E) \"C\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add((E) \"C\");\n+        assertTrue(list.containsAll(list2));\n+        assertTrue(list.containsAll(list));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNavigation() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"3\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"4\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"5\", it.next());\n+        assertTrue(!it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"5\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"4\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"3\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorSet() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n+        assertEquals(\"1\", it.next());\n+        it.set((E) \"a\");\n+        assertEquals(\"a\", it.previous());\n+        it.set((E) \"A\");\n+        assertEquals(\"A\", it.next());\n+        assertEquals(\"2\", it.next());\n+        it.set((E) \"B\");\n+        assertEquals(\"3\", it.next());\n+        assertEquals(\"4\", it.next());\n+        it.set((E) \"D\");\n+        assertEquals(\"5\", it.next());\n+        it.set((E) \"E\");\n+        assertEquals(\"[A, B, 3, D, E]\", list.toString());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorRemove() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n+        try {\n+            it.remove();\n+            fail();\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\", it.next());\n+        assertEquals(\"2\", it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n+        assertEquals(\"3\", it.next());\n+        assertEquals(\"3\", it.previous());\n+        assertEquals(\"1\", it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\", list.toString());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"3\", it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\", list.toString());\n+        try {\n+            it.remove();\n+        } catch (final IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\", it.next());\n+        assertEquals(\"5\", it.next());\n+        it.remove();\n+        assertEquals(\"[4]\", list.toString());\n+        assertEquals(\"4\", it.previous());\n+        it.remove();\n+        assertEquals(\"[]\", list.toString());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorAdd() {\n+        final CursorableLinkedList.Cursor<E> it = list.cursor();\n+        it.add((E) \"1\");\n+        assertEquals(\"[1]\", list.toString());\n+        it.add((E) \"3\");\n+        assertEquals(\"[1, 3]\", list.toString());\n+        it.add((E) \"5\");\n+        assertEquals(\"[1, 3, 5]\", list.toString());\n+        assertEquals(\"5\", it.previous());\n+        it.add((E) \"4\");\n+        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n+        assertEquals(\"4\", it.previous());\n+        assertEquals(\"3\", it.previous());\n+        it.add((E) \"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        it.close();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorConcurrentModification() {\n+        // this test verifies that cursors remain valid when the list\n+        // is modified via other means.\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+        list.add((E) \"7\");\n+        list.add((E) \"9\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final CursorableLinkedList.Cursor<E> c2 = list.cursor();\n+        final Iterator<E> li = list.iterator();\n+\n+        // test cursors remain valid when list modified by std Iterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\", li.next());\n+        assertEquals(\"2\", li.next());\n+        li.remove();\n+        assertEquals(\"3\", li.next());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(\"3\", c1.next());\n+        assertEquals(\"1\", c2.next());\n+\n+        // test cursor c1 can remove elements from previously modified list\n+        // test cursor c2 skips elements removed via different cursor\n+        c1.remove();\n+        assertEquals(\"5\", c2.next());\n+        c2.add((E) \"6\");\n+        assertEquals(\"5\", c1.next());\n+        assertEquals(\"6\", c1.next());\n+        assertEquals(\"7\", c1.next());\n+\n+        // test cursors remain valid when list mod via CursorableLinkedList\n+        // test cursor remains valid when elements inserted into list before\n+        // the current position of the cursor.\n+        list.add(0, (E) \"0\");\n+\n+        // test cursor remains valid when element inserted immediately after\n+        // current element of a cursor, and the element is seen on the\n+        // next call to the next method of that cursor.\n+        list.add(5, (E) \"8\");\n+\n+        assertEquals(\"8\", c1.next());\n+        assertEquals(\"9\", c1.next());\n+        c1.add((E) \"10\");\n+        assertEquals(\"7\", c2.next());\n+        assertEquals(\"8\", c2.next());\n+        assertEquals(\"9\", c2.next());\n+        assertEquals(\"10\", c2.next());\n+\n+        try {\n+            c2.next();\n+            fail();\n+        } catch (final NoSuchElementException nse) {\n+        }\n+\n+        try {\n+            li.next();\n+            fail();\n+        } catch (final ConcurrentModificationException cme) {\n+        }\n+\n+        c1.close(); // not necessary\n+        c2.close(); // not necessary\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexMid() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        final Iterator<E> li = list.iterator();\n+\n+        // test cursors remain valid when list modified by std Iterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\", li.next());\n+        assertEquals(\"2\", li.next());\n+        li.remove();\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"3\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexFirst() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        list.remove(0);\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"2\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"3\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexAddBefore() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        list.add(0, (E) \"0\");\n+        assertEquals(2, c1.nextIndex());\n+        assertEquals(\"2\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexAddNext() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        list.add(0, (E) \"0\");\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"0\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCursorNextIndexAddAfter() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"5\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+\n+        assertEquals(0, c1.nextIndex());\n+        list.add(1, (E) \"0\");\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"0\", c1.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(true, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(\"A\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(true, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextNextRemoveIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"C\", c1.next());\n+\n+        assertEquals(\"B\", list.remove(1));\n+\n+        assertEquals(false, c1.nextIndexValid);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(\"C\", c1.current.value);\n+        assertEquals(\"D\", c1.next.value);\n+\n+        assertEquals(\"[A, C, D]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, D]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousRemoveByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        c1.remove();\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextRemoveByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        c1.remove();\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousAddIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        list.add(1, (E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"B\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextAddIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+\n+        list.add(1, (E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"A\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[Z, B, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextAddIndex1ByList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        list.add(1, (E) \"Z\");\n+\n+        assertEquals(false, c1.nextIndexValid);\n+        assertEquals(\"B\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousAddByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        c1.add((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(2, c1.nextIndex);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"B\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, B, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextAddByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        c1.add((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(3, c1.nextIndex);\n+        assertEquals(false, c1.currentRemovedByAnother);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, B, Z, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextRemoveByListSetByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        list.remove(1);\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(null, c1.current);\n+        assertEquals(\"C\", c1.next.value);\n+        assertEquals(\"[A, C]\", list.toString());\n+\n+        try {\n+            c1.set((E) \"Z\");\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextPreviousSetByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+        assertEquals(\"B\", c1.previous());\n+\n+        c1.set((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(1, c1.nextIndex);\n+        assertEquals(\"Z\", c1.current.value);\n+        assertEquals(\"Z\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_CursorNextNextSetByIterator() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+\n+        final CursorableLinkedList.Cursor<E> c1 = list.cursor();\n+        assertEquals(\"A\", c1.next());\n+        assertEquals(\"B\", c1.next());\n+\n+        c1.set((E) \"Z\");\n+\n+        assertEquals(true, c1.nextIndexValid);\n+        assertEquals(2, c1.nextIndex);\n+        assertEquals(\"Z\", c1.current.value);\n+        assertEquals(\"C\", c1.next.value);\n+\n+        assertEquals(\"[A, Z, C]\", list.toString());\n+        c1.remove();  // works ok\n+        assertEquals(\"[A, C]\", list.toString());\n+        try {\n+            c1.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        assertTrue(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+        list.add((E) \"A\");\n+        assertTrue(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+\n+        final CursorableLinkedList<E> list2 = new CursorableLinkedList<E>();\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+\n+        final java.util.List<E> list3 = new java.util.LinkedList<E>();\n+        assertTrue(!list.equals(list3));\n+        assertTrue(!list3.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list2.add((E) \"A\");\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(!list2.equals(list3));\n+        assertTrue(!list3.equals(list2));\n+\n+        list3.add((E) \"A\");\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add((E) \"B\");\n+        assertTrue(list.equals(list));\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+        assertTrue(!list.equals(list3));\n+        assertTrue(!list3.equals(list));\n+\n+        list2.add((E) \"B\");\n+        list3.add((E) \"B\");\n+        assertTrue(list.equals(list));\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add((E) \"C\");\n+        list2.add((E) \"C\");\n+        list3.add((E) \"C\");\n+        assertTrue(list.equals(list));\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list.hashCode(),list2.hashCode());\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add((E) \"D\");\n+        list2.addFirst((E) \"D\");\n+        assertTrue(list.equals(list));\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGet() {\n+        try {\n+            list.get(0);\n+            fail(\"shouldn't get here\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        assertTrue(list.add((E) \"A\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertTrue(list.add((E) \"B\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertEquals(\"B\",list.get(1));\n+\n+        try {\n+            list.get(-1);\n+            fail(\"shouldn't get here\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(2);\n+            fail(\"shouldn't get here\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIndexOf() {\n+        assertEquals(-1,list.indexOf(\"A\"));\n+        assertEquals(-1,list.lastIndexOf(\"A\"));\n+        list.add((E) \"A\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(-1,list.indexOf(\"B\"));\n+        assertEquals(-1,list.lastIndexOf(\"B\"));\n+        list.add((E) \"B\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(1,list.indexOf(\"B\"));\n+        assertEquals(1,list.lastIndexOf(\"B\"));\n+        list.addFirst((E) \"B\");\n+        assertEquals(1,list.indexOf(\"A\"));\n+        assertEquals(1,list.lastIndexOf(\"A\"));\n+        assertEquals(0,list.indexOf(\"B\"));\n+        assertEquals(2,list.lastIndexOf(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIsEmpty() {\n+        assertTrue(list.isEmpty());\n+        list.add((E) \"element\");\n+        assertTrue(!list.isEmpty());\n+        list.remove(\"element\");\n+        assertTrue(list.isEmpty());\n+        list.add((E) \"element\");\n+        assertTrue(!list.isEmpty());\n+        list.clear();\n+        assertTrue(list.isEmpty());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        Iterator<E> it = list.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"3\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"4\", it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"5\", it.next());\n+        assertTrue(!it.hasNext());\n+\n+        it = list.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"1\", it.next());\n+        it.remove();\n+        assertEquals(\"[2, 3, 4, 5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"2\", it.next());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"3\", it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"4\", it.next());\n+        it.remove();\n+        assertEquals(\"[5]\", list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"5\", it.next());\n+        it.remove();\n+        assertEquals(\"[]\", list.toString());\n+        assertTrue(!it.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorNavigation() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        final ListIterator<E> it = list.listIterator();\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+        assertEquals(0, it.nextIndex());\n+        assertEquals(\"1\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"2\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(\"3\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(2, it.previousIndex());\n+        assertEquals(3, it.nextIndex());\n+        assertEquals(\"4\", it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(3, it.previousIndex());\n+        assertEquals(4, it.nextIndex());\n+        assertEquals(\"5\", it.next());\n+        assertTrue(!it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(4, it.previousIndex());\n+        assertEquals(5, it.nextIndex());\n+        assertEquals(\"5\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(3, it.previousIndex());\n+        assertEquals(4, it.nextIndex());\n+        assertEquals(\"4\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(2, it.previousIndex());\n+        assertEquals(3, it.nextIndex());\n+        assertEquals(\"3\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1, it.previousIndex());\n+        assertEquals(2, it.nextIndex());\n+        assertEquals(\"2\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0, it.previousIndex());\n+        assertEquals(1, it.nextIndex());\n+        assertEquals(\"1\", it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1, it.previousIndex());\n+        assertEquals(0, it.nextIndex());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorSet() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        final ListIterator<E> it = list.listIterator();\n+        assertEquals(\"1\", it.next());\n+        it.set((E) \"a\");\n+        assertEquals(\"a\", it.previous());\n+        it.set((E) \"A\");\n+        assertEquals(\"A\", it.next());\n+        assertEquals(\"2\", it.next());\n+        it.set((E) \"B\");\n+        assertEquals(\"3\", it.next());\n+        assertEquals(\"4\", it.next());\n+        it.set((E) \"D\");\n+        assertEquals(\"5\", it.next());\n+        it.set((E) \"E\");\n+        assertEquals(\"[A, B, 3, D, E]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorRemove() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        final ListIterator<E> it = list.listIterator();\n+        try {\n+            it.remove();\n+        } catch(final IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\",it.next());\n+        assertEquals(\"2\",it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"3\",it.previous());\n+        assertEquals(\"1\",it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        try {\n+            it.remove();\n+        } catch(final IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\",it.next());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[4]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIteratorAdd() {\n+        final ListIterator<E> it = list.listIterator();\n+        it.add((E) \"1\");\n+        assertEquals(\"[1]\", list.toString());\n+        it.add((E) \"3\");\n+        assertEquals(\"[1, 3]\", list.toString());\n+        it.add((E) \"5\");\n+        assertEquals(\"[1, 3, 5]\", list.toString());\n+        assertEquals(\"5\", it.previous());\n+        it.add((E) \"4\");\n+        assertEquals(\"[1, 3, 4, 5]\", list.toString());\n+        assertEquals(\"4\", it.previous());\n+        assertEquals(\"3\", it.previous());\n+        it.add((E) \"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveAll() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        final HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"A\");\n+        set.add((E) \"2\");\n+        set.add((E) \"C\");\n+        set.add((E) \"4\");\n+        set.add((E) \"D\");\n+\n+        assertTrue(list.removeAll(set));\n+        assertEquals(\"[1, 3, 5]\", list.toString());\n+        assertTrue(!list.removeAll(set));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveByIndex() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        assertEquals(\"1\", list.remove(0));\n+        assertEquals(\"[2, 3, 4, 5]\", list.toString());\n+        assertEquals(\"3\", list.remove(1));\n+        assertEquals(\"[2, 4, 5]\", list.toString());\n+        assertEquals(\"4\", list.remove(1));\n+        assertEquals(\"[2, 5]\", list.toString());\n+        assertEquals(\"5\", list.remove(1));\n+        assertEquals(\"[2]\", list.toString());\n+        assertEquals(\"2\", list.remove(0));\n+        assertEquals(\"[]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        list.add((E) \"1\");\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        assertEquals(\"[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]\", list.toString());\n+        assertTrue(!list.remove(\"6\"));\n+        assertTrue(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4, 5]\", list.toString());\n+        assertTrue(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(!list.remove(\"5\"));\n+        assertTrue(list.remove(\"1\"));\n+        assertEquals(\"[1, 2, 3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"1\"));\n+        assertEquals(\"[2, 3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 2, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"3\"));\n+        assertEquals(\"[4, 3, 4]\", list.toString());\n+        assertTrue(list.remove(\"3\"));\n+        assertEquals(\"[4, 4]\", list.toString());\n+        assertTrue(list.remove(\"4\"));\n+        assertEquals(\"[4]\", list.toString());\n+        assertTrue(list.remove(\"4\"));\n+        assertEquals(\"[]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        list.add((E) \"1\");\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        list.add((E) \"5\");\n+\n+        final HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"A\");\n+        set.add((E) \"2\");\n+        set.add((E) \"C\");\n+        set.add((E) \"4\");\n+        set.add((E) \"D\");\n+\n+        assertTrue(list.retainAll(set));\n+        assertEquals(\"[2, 2, 4, 4]\", list.toString());\n+        assertTrue(!list.retainAll(set));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSet() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\", list.toString());\n+        list.set(0, (E) \"A\");\n+        assertEquals(\"[A, 2, 3, 4, 5]\", list.toString());\n+        list.set(1, (E) \"B\");\n+        assertEquals(\"[A, B, 3, 4, 5]\", list.toString());\n+        list.set(2, (E) \"C\");\n+        assertEquals(\"[A, B, C, 4, 5]\", list.toString());\n+        list.set(3, (E) \"D\");\n+        assertEquals(\"[A, B, C, D, 5]\", list.toString());\n+        list.set(4, (E) \"E\");\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubList() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[A, B, C, D, E]\", list.subList(0, 5).toString());\n+        assertEquals(\"[B, C, D, E]\", list.subList(1, 5).toString());\n+        assertEquals(\"[C, D, E]\", list.subList(2, 5).toString());\n+        assertEquals(\"[D, E]\", list.subList(3, 5).toString());\n+        assertEquals(\"[E]\", list.subList(4, 5).toString());\n+        assertEquals(\"[]\", list.subList(5, 5).toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddEnd() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(5, 5);\n+        sublist.add((E) \"F\");\n+        assertEquals(\"[A, B, C, D, E, F]\", list.toString());\n+        assertEquals(\"[F]\", sublist.toString());\n+        sublist.add((E) \"G\");\n+        assertEquals(\"[A, B, C, D, E, F, G]\", list.toString());\n+        assertEquals(\"[F, G]\", sublist.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddBegin() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(0, 0);\n+        sublist.add((E) \"a\");\n+        assertEquals(\"[a, A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[a]\", sublist.toString());\n+        sublist.add((E) \"b\");\n+        assertEquals(\"[a, b, A, B, C, D, E]\", list.toString());\n+        assertEquals(\"[a, b]\", sublist.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListAddMiddle() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(1, 3);\n+        sublist.add((E) \"a\");\n+        assertEquals(\"[A, B, C, a, D, E]\", list.toString());\n+        assertEquals(\"[B, C, a]\", sublist.toString());\n+        sublist.add((E) \"b\");\n+        assertEquals(\"[A, B, C, a, b, D, E]\", list.toString());\n+        assertEquals(\"[B, C, a, b]\", sublist.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSubListRemove() {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final List<E> sublist = list.subList(1, 4);\n+        assertEquals(\"[B, C, D]\", sublist.toString());\n+        assertEquals(\"[A, B, C, D, E]\", list.toString());\n+        sublist.remove(\"C\");\n+        assertEquals(\"[B, D]\", sublist.toString());\n+        assertEquals(\"[A, B, D, E]\", list.toString());\n+        sublist.remove(1);\n+        assertEquals(\"[B]\", sublist.toString());\n+        assertEquals(\"[A, B, E]\", list.toString());\n+        sublist.clear();\n+        assertEquals(\"[]\", sublist.toString());\n+        assertEquals(\"[A, E]\", list.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToArray() {\n+        list.add((E) \"1\");\n+        list.add((E) \"2\");\n+        list.add((E) \"3\");\n+        list.add((E) \"4\");\n+        list.add((E) \"5\");\n+\n+        final Object[] elts = list.toArray();\n+        assertEquals(\"1\", elts[0]);\n+        assertEquals(\"2\", elts[1]);\n+        assertEquals(\"3\", elts[2]);\n+        assertEquals(\"4\", elts[3]);\n+        assertEquals(\"5\", elts[4]);\n+        assertEquals(5, elts.length);\n+\n+        final String[] elts2 = list.toArray(new String[0]);\n+        assertEquals(\"1\", elts2[0]);\n+        assertEquals(\"2\", elts2[1]);\n+        assertEquals(\"3\", elts2[2]);\n+        assertEquals(\"4\", elts2[3]);\n+        assertEquals(\"5\", elts2[4]);\n+        assertEquals(5, elts2.length);\n+\n+        final String[] elts3 = new String[5];\n+        assertSame(elts3, list.toArray(elts3));\n+        assertEquals(\"1\", elts3[0]);\n+        assertEquals(\"2\", elts3[1]);\n+        assertEquals(\"3\", elts3[2]);\n+        assertEquals(\"4\", elts3[3]);\n+        assertEquals(\"5\", elts3[4]);\n+        assertEquals(5, elts3.length);\n+\n+        final String[] elts4 = new String[3];\n+        final String[] elts4b = list.toArray(elts4);\n+        assertTrue(elts4 != elts4b);\n+        assertEquals(\"1\", elts4b[0]);\n+        assertEquals(\"2\", elts4b[1]);\n+        assertEquals(\"3\", elts4b[2]);\n+        assertEquals(\"4\", elts4b[3]);\n+        assertEquals(\"5\", elts4b[4]);\n+        assertEquals(5, elts4b.length);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialization() throws Exception {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+\n+        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerializationWithOpenCursor() throws Exception {\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        list.add((E) \"D\");\n+        list.add((E) \"E\");\n+        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLongSerialization() throws Exception {\n+        // recursive serialization will cause a stack\n+        // overflow exception with long lists\n+        for (int i = 0; i < 10000; i++) {\n+            list.add((E) new Integer(i));\n+        }\n+\n+        final java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        final java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        final java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        final java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        final Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    /**\n+     *  Ignore the serialization tests for sublists and sub-sublists.\n+     *\n+     *  @return an array of sublist serialization test names\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        final ArrayList<String> list = new ArrayList<String>();\n+        final String prefix = \"CursorableLinkedListTest\";\n+        final String bulk = \".bulkTestSubList\";\n+        final String[] ignored = new String[] {\n+                \".testEmptyListSerialization\",\n+                \".testFullListSerialization\",\n+                \".testEmptyListCompatibility\",\n+                \".testFullListCompatibility\",\n+                \".testSimpleSerialization\",\n+                \".testCanonicalEmptyCollectionExists\",\n+                \".testCanonicalFullCollectionExists\",\n+                \".testSerializeDeserializeThenCompare\"\n+        };\n+        for (final String element : ignored) {\n+            list.add(prefix + bulk + element);\n+            list.add(prefix + bulk + bulk + element);\n+        }\n+        return list.toArray(new String[0]);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CursorableLinkedList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CursorableLinkedList.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/FixedSizeListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.list.FixedSizeList;\n+\n+/**\n+ * Extension of {@link AbstractListTest} for exercising the {@link FixedSizeList}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedSizeListTest<E> extends AbstractListTest<E> {\n+\n+    public FixedSizeListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return FixedSizeList.fixedSizeList(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public List<E> makeFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return FixedSizeList.fixedSizeList(list);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/FixedSizeList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/FixedSizeList.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/GrowthListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.list.GrowthList;\n+\n+/**\n+ * Extension of {@link AbstractListTest} for exercising the {@link GrowthList}.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class GrowthListTest<E> extends AbstractListTest<E> {\n+\n+    public GrowthListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return new GrowthList<E>();\n+    }\n+\n+    @Override\n+    public List<E> makeFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return GrowthList.growthList(list);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGrowthAdd() {\n+        final Integer one = new Integer(1);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.add(1, one);\n+        assertEquals(2, grower.size());\n+        assertEquals(null, grower.get(0));\n+        assertEquals(one, grower.get(1));\n+    }\n+\n+    public void testGrowthAddAll() {\n+        final Integer one = new Integer(1);\n+        final Integer two = new Integer(2);\n+        final Collection<Integer> coll = new ArrayList<Integer>();\n+        coll.add(one);\n+        coll.add(two);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.addAll(1, coll);\n+        assertEquals(3, grower.size());\n+        assertEquals(null, grower.get(0));\n+        assertEquals(one, grower.get(1));\n+        assertEquals(two, grower.get(2));\n+    }\n+\n+    public void testGrowthSet1() {\n+        final Integer one = new Integer(1);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.set(1, one);\n+        assertEquals(2, grower.size());\n+        assertEquals(null, grower.get(0));\n+        assertEquals(one, grower.get(1));\n+    }\n+\n+    public void testGrowthSet2() {\n+        final Integer one = new Integer(1);\n+        final GrowthList<Integer> grower = new GrowthList<Integer>();\n+        assertEquals(0, grower.size());\n+        grower.set(0, one);\n+        assertEquals(1, grower.size());\n+        assertEquals(one, grower.get(0));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListAddByIndexBoundsChecking() {\n+        List<E> list;\n+        final E element = getOtherElements()[0];\n+        try {\n+            list = makeObject();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListAddByIndexBoundsChecking2() {\n+        List<E> list;\n+        final E element = getOtherElements()[0];\n+        try {\n+            list = makeFullCollection();\n+            list.add(-1, element);\n+            fail(\"List.add should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListSetByIndexBoundsChecking() {\n+        final List<E> list = makeObject();\n+        final E element = getOtherElements()[0];\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch (final IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Override.\n+     */\n+    @Override\n+    public void testListSetByIndexBoundsChecking2() {\n+        final List<E> list = makeFullCollection();\n+        final E element = getOtherElements()[0];\n+        try {\n+            list.set(-1, element);\n+            fail(\"List.set should throw IndexOutOfBoundsException [-1]\");\n+        } catch(final IndexOutOfBoundsException e) {\n+            // expected\n+        } \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/GrowthList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/GrowthList.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/NodeCachingLinkedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.list.NodeCachingLinkedList;\n+\n+/**\n+ * Test class for NodeCachingLinkedList, a performance optimised LinkedList.\n+ *\n+ * @version $Id$\n+ */\n+public class NodeCachingLinkedListTest<E> extends AbstractLinkedListTest<E> {\n+\n+    public NodeCachingLinkedListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(NodeCachingLinkedListTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public NodeCachingLinkedList<E> makeObject() {\n+        return new NodeCachingLinkedList<E>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testShrinkCache() {\n+        if (isRemoveSupported() == false || isAddSupported() == false) {\n+            return;\n+        }\n+        resetEmpty();\n+        final NodeCachingLinkedList<E> list = getCollection();\n+\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        list.removeAllNodes(); // Will dump all 4 elements into cache\n+        list.setMaximumCacheSize(2); // shrink cache\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        checkNodes();\n+        list.removeNode(list.getNode(0, false)); // no room in cache\n+        list.removeNode(list.getNode(0, false));\n+        list.removeNode(list.getNode(0, false));\n+        checkNodes();\n+        list.addAll(Arrays.asList((E[]) new String[] { \"1\", \"2\", \"3\", \"4\" }));\n+        checkNodes();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public static void compareSpeed() {\n+        final NodeCachingLinkedList<Object> ncll = new NodeCachingLinkedList<Object>();\n+        final LinkedList<Object> ll = new LinkedList<Object>();\n+\n+        final Object o1 = new Object();\n+        final Object o2 = new Object();\n+\n+        final int loopCount = 4000000;\n+\n+        long startTime, endTime;\n+\n+        System.out.println(\"Testing relative execution time of commonly-used methods...\");\n+\n+        startTime = System.currentTimeMillis();\n+        for(int x = loopCount; x > 0; x--) {\n+            // unrolled a few times to minimize effect of loop\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+            //\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+            //\n+            ll.addFirst(o1);\n+            ll.addLast(o2);\n+            ll.removeFirst();\n+            ll.removeLast();\n+            ll.add(o1);\n+            ll.remove(0);\n+        }\n+        endTime = System.currentTimeMillis();\n+        System.out.println(\"Time with LinkedList: \" + (endTime - startTime) + \" ms\");\n+\n+        startTime = System.currentTimeMillis();\n+        for(int x = loopCount; x > 0; x--) {\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+            //\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+            //\n+            ncll.addFirst(o1);\n+            ncll.addLast(o2);\n+            ncll.removeFirst();\n+            ncll.removeLast();\n+            ncll.add(o1);\n+            ncll.remove(0);\n+        }\n+        endTime = System.currentTimeMillis();\n+        System.out.println(\"Time with NodeCachingLinkedList: \" + (endTime - startTime) + \" ms\");\n+\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(),\n+//           \"src/test/resources/data/test/NodeCachingLinkedList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(),\n+//            \"src/test/resources/data/test/NodeCachingLinkedList.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public NodeCachingLinkedList<E> getCollection() {\n+        return (NodeCachingLinkedList<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/PredicatedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+import org.apache.commons.collections4.list.PredicatedList;\n+\n+/**\n+ * Extension of {@link AbstractListTest} for exercising the \n+ * {@link PredicatedList} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedListTest<E> extends AbstractListTest<E> {\n+\n+    public PredicatedListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+ //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected List<E> decorateList(final List<E> list, final Predicate<E> predicate) {\n+        return PredicatedList.predicatedList(list, predicate);\n+    }\n+\n+    @Override\n+    public List<E> makeObject() {\n+        return decorateList(new ArrayList<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+    }\n+\n+//--------------------------------------------------------------------\n+\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(final E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    public List<E> makeTestList() {\n+        return decorateList(new ArrayList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        final List<E> list = makeTestList();\n+        final Integer i = new Integer(3);\n+        try {\n+            list.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !list.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        final List<E> list = makeTestList();\n+        final List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            list.addAll(0, elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"one\"));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"two\"));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(new Integer(3)));\n+        assertTrue(\"List shouldn't contain illegal element\",\n+         !list.contains(\"four\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalSet() {\n+        final List<E> list = makeTestList();\n+        try {\n+            list.set(0, (E) new Integer(3));\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLegalAddAll() {\n+        final List<E> list = makeTestList();\n+        list.add((E) \"zero\");\n+        final List<E> elements = new ArrayList<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) \"three\");\n+        list.addAll(1,elements);\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"zero\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"one\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"two\"));\n+        assertTrue(\"List should contain legal element\",\n+         list.contains(\"three\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedList.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.list.SetUniqueList;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class SetUniqueListTest<E> extends AbstractListTest<E> {\n+\n+    public SetUniqueListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public List<E> makeObject() {\n+        return new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+    }\n+\n+    @Override\n+    public void testListIteratorSet() {\n+        // override to block\n+        resetFull();\n+        final ListIterator<E> it = getCollection().listIterator();\n+        it.next();\n+        try {\n+            it.set(null);\n+            fail();\n+        } catch (final UnsupportedOperationException ex) {}\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        // override to avoid duplicate \"One\"\n+        return (E[]) new Object[] {\n+                new String(\"\"),\n+                new String(\"One\"),\n+                new Integer(2),\n+                \"Three\",\n+                new Integer(4),\n+                new Double(5),\n+                new Float(6),\n+                \"Seven\",\n+                \"Eight\",\n+                new String(\"Nine\"),\n+                new Integer(10),\n+                new Short((short)11),\n+                new Long(12),\n+                \"Thirteen\",\n+                \"14\",\n+                \"15\",\n+                new Byte((byte)16)\n+        };\n+    }\n+\n+    @Override\n+    public void testListIteratorAdd() {\n+        // override to cope with Set behaviour\n+        resetEmpty();\n+        final List<E> list1 = getCollection();\n+        final List<E> list2 = getConfirmed();\n+\n+        final E[] elements = getOtherElements();  // changed here\n+        ListIterator<E> iter1 = list1.listIterator();\n+        ListIterator<E> iter2 = list2.listIterator();\n+\n+        for (final E element : elements) {\n+            iter1.add(element);\n+            iter2.add(element);\n+            super.verify();  // changed here\n+        }\n+\n+        resetFull();\n+        iter1 = getCollection().listIterator();\n+        iter2 = getConfirmed().listIterator();\n+        for (final E element : elements) {\n+            iter1.next();\n+            iter2.next();\n+            iter1.add(element);\n+            iter2.add(element);\n+            super.verify();  // changed here\n+        }\n+    }\n+\n+    @Override\n+    public void testCollectionAddAll() {\n+        // override for set behaviour\n+        resetEmpty();\n+        E[] elements = getFullElements();\n+        boolean r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Empty collection should change after addAll\", r);\n+        for (final E element : elements) {\n+            assertTrue(\"Collection should contain added element\",\n+                    getCollection().contains(element));\n+        }\n+\n+        resetFull();\n+        final int size = getCollection().size();\n+        elements = getOtherElements();\n+        r = getCollection().addAll(Arrays.asList(elements));\n+        getConfirmed().addAll(Arrays.asList(elements));\n+        verify();\n+        assertTrue(\"Full collection should change after addAll\", r);\n+        for (int i = 0; i < elements.length; i++) {\n+            assertTrue(\"Full collection should contain added element \" + i,\n+                    getCollection().contains(elements[i]));\n+        }\n+        assertEquals(\"Size should increase after addAll\",\n+                size + elements.length, getCollection().size());\n+    }\n+\n+    public void testIntCollectionAddAll() {\n+      // make a SetUniqueList with one element\n+      final List<Integer> list = new SetUniqueList<Integer>(new ArrayList<Integer>(), new HashSet<Integer>());\n+      final Integer existingElement = new Integer(1);\n+      list.add(existingElement);\n+\n+      // add two new unique elements at index 0\n+      final Integer firstNewElement = new Integer(2);\n+      final Integer secondNewElement = new Integer(3);\n+      Collection<Integer> collection = Arrays.asList(new Integer[] {firstNewElement, secondNewElement});\n+      list.addAll(0, collection);\n+      assertEquals(\"Unique elements should be added.\", 3, list.size());\n+      assertEquals(\"First new element should be at index 0\", firstNewElement, list.get(0));\n+      assertEquals(\"Second new element should be at index 1\", secondNewElement, list.get(1));\n+      assertEquals(\"Existing element should shift to index 2\", existingElement, list.get(2));\n+\n+      // add a duplicate element and a unique element at index 0\n+      final Integer thirdNewElement = new Integer(4);\n+      collection = Arrays.asList(new Integer[] {existingElement, thirdNewElement});\n+      list.addAll(0, collection);\n+      assertEquals(\"Duplicate element should not be added, unique element should be added.\",\n+        4, list.size());\n+      assertEquals(\"Third new element should be at index 0\", thirdNewElement, list.get(0));\n+    }\n+    \n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListSetByIndex() {\n+        // override for set behaviour\n+        resetFull();\n+        final int size = getCollection().size();\n+        getCollection().set(0, (E) new Long(1000));\n+        assertEquals(size, getCollection().size());\n+\n+        getCollection().set(2, (E) new Long(1000));\n+        assertEquals(size - 1, getCollection().size());\n+        assertEquals(new Long(1000), getCollection().get(1));  // set into 2, but shifted down to 1\n+    }\n+\n+    boolean extraVerify = true;\n+    @Override\n+    public void testCollectionIteratorRemove() {\n+        try {\n+            extraVerify = false;\n+            super.testCollectionIteratorRemove();\n+        } finally {\n+            extraVerify = true;\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void verify() {\n+        super.verify();\n+\n+        if (extraVerify) {\n+            final int size = getCollection().size();\n+            getCollection().add((E) new Long(1000));\n+            assertEquals(size + 1, getCollection().size());\n+\n+            getCollection().add((E) new Long(1000));\n+            assertEquals(size + 1, getCollection().size());\n+            assertEquals(new Long(1000), getCollection().get(size));\n+\n+            getCollection().remove(size);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFactory() {\n+        final Integer[] array = new Integer[] { new Integer(1), new Integer(2), new Integer(1) };\n+        final ArrayList<Integer> list = new ArrayList<Integer>(Arrays.asList(array));\n+        final SetUniqueList<Integer> lset = SetUniqueList.setUniqueList(list);\n+\n+        assertEquals(\"Duplicate element was added.\", 2, lset.size());\n+        assertEquals(new Integer(1), lset.get(0));\n+        assertEquals(new Integer(2), lset.get(1));\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(2), list.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAdd() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        // Duplicate element\n+        final E obj = (E) new Integer(1);\n+        lset.add(obj);\n+        lset.add(obj);\n+        assertEquals(\"Duplicate element was added.\", 1, lset.size());\n+\n+        // Unique element\n+        lset.add((E) new Integer(2));\n+        assertEquals(\"Unique element was not added.\", 2, lset.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddAll() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        lset.addAll(\n+            Arrays.asList((E[]) new Integer[] { new Integer(1), new Integer(1)}));\n+\n+        assertEquals(\"Duplicate element was added.\", 1, lset.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSet() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        // Duplicate element\n+        final E obj1 = (E) new Integer(1);\n+        final E obj2 = (E) new Integer(2);\n+        final E obj3 = (E) new Integer(3);\n+\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj1);\n+        assertEquals(2, lset.size());\n+        assertSame(obj1, lset.get(0));\n+        assertSame(obj2, lset.get(1));\n+\n+        lset.clear();\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj2);\n+        assertEquals(1, lset.size());\n+        assertSame(obj2, lset.get(0));\n+\n+        lset.clear();\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj3);\n+        assertEquals(2, lset.size());\n+        assertSame(obj3, lset.get(0));\n+        assertSame(obj2, lset.get(1));\n+\n+        lset.clear();\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(1, obj1);\n+        assertEquals(1, lset.size());\n+        assertSame(obj1, lset.get(0));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListIterator() {\n+        final SetUniqueList<E> lset = new SetUniqueList<E>(new ArrayList<E>(), new HashSet<E>());\n+\n+        final E obj1 = (E) new Integer(1);\n+        final E obj2 = (E) new Integer(2);\n+        lset.add(obj1);\n+        lset.add(obj2);\n+\n+        // Attempts to add a duplicate object\n+        for (final ListIterator<E> it = lset.listIterator(); it.hasNext();) {\n+            it.next();\n+\n+            if (!it.hasNext()) {\n+                it.add(obj1);\n+                break;\n+            }\n+        }\n+\n+        assertEquals(\"Duplicate element was added\", 2, lset.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUniqueListReInsert() {\n+        final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n+        l.add((E) new Object());\n+        l.add((E) new Object());\n+\n+        final E a = l.get(0);\n+\n+        // duplicate is removed\n+        l.set(0, l.get(1));\n+        assertEquals(1, l.size());\n+\n+        // old object is added back in\n+        l.add(1, a);\n+        assertEquals(2, l.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUniqueListDoubleInsert() {\n+        final List<E> l = SetUniqueList.setUniqueList(new LinkedList<E>());\n+        l.add((E) new Object());\n+        l.add((E) new Object());\n+\n+        // duplicate is removed\n+        l.set(0, l.get(1));\n+        assertEquals(1, l.size());\n+\n+        // duplicate should be removed again\n+        l.add(1, l.get(0));\n+        assertEquals(1, l.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetDownwardsInList() {\n+        /*\n+         * Checks the following semantics\n+         * [a,b]\n+         * set(0,b): [b]->a\n+         * So UniqList contains [b] and a is returned\n+         */\n+        final ArrayList<E> l = new ArrayList<E>();\n+        final HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        final E a = (E) new Object();\n+        final E b = (E) new Object();\n+        ul.add(a);\n+        ul.add(b);\n+        assertEquals(a, l.get(0));\n+        assertEquals(b, l.get(1));\n+        assertTrue(s.contains(a));\n+        assertTrue(s.contains(b));\n+\n+        assertEquals(a, ul.set(0, b));\n+        assertEquals(1, s.size());\n+        assertEquals(1, l.size());\n+        assertEquals(b, l.get(0));\n+        assertTrue(s.contains(b));\n+        assertFalse(s.contains(a));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetInBiggerList() {\n+        /*\n+         * Checks the following semantics\n+         * [a,b,c]\n+         * set(0,b): [b,c]->a\n+         * So UniqList contains [b,c] and a is returned\n+         */\n+        final ArrayList<E> l = new ArrayList<E>();\n+        final HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        final E a = (E) new Object();\n+        final E b = (E) new Object();\n+        final E c = (E) new Object();\n+\n+        ul.add(a);\n+        ul.add(b);\n+        ul.add(c);\n+        assertEquals(a, l.get(0));\n+        assertEquals(b, l.get(1));\n+        assertEquals(c, l.get(2));\n+        assertTrue(s.contains(a));\n+        assertTrue(s.contains(b));\n+        assertTrue(s.contains(c));\n+\n+        assertEquals(a, ul.set(0, b));\n+        assertEquals(2, s.size());\n+        assertEquals(2, l.size());\n+        assertEquals(b, l.get(0));\n+        assertEquals(c, l.get(1));\n+        assertFalse(s.contains(a));\n+        assertTrue(s.contains(b));\n+        assertTrue(s.contains(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetUpwardsInList() {\n+        /*\n+         * Checks the following semantics\n+         * [a,b,c]\n+         * set(1,a): [a,c]->b\n+         * So UniqList contains [a,c] and b is returned\n+         */\n+        final ArrayList<E> l = new ArrayList<E>();\n+        final HashSet<E> s = new HashSet<E>();\n+        final SetUniqueList<E> ul = new SetUniqueList<E>(l, s);\n+\n+        final E a = (E) new String(\"A\");\n+        final E b = (E) new String(\"B\");\n+        final E c = (E) new String(\"C\");\n+\n+        ul.add(a);\n+        ul.add(b);\n+        ul.add(c);\n+        assertEquals(a, l.get(0));\n+        assertEquals(b, l.get(1));\n+        assertEquals(c, l.get(2));\n+        assertTrue(s.contains(a));\n+        assertTrue(s.contains(b));\n+        assertTrue(s.contains(c));\n+\n+        assertEquals(b, ul.set(1, a));\n+        assertEquals(2, s.size());\n+        assertEquals(2, l.size());\n+        assertEquals(a, l.get(0));\n+        assertEquals(c, l.get(1));\n+        assertTrue(s.contains(a));\n+        assertFalse(s.contains(b));\n+        assertTrue(s.contains(c));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/SetUniqueList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/SetUniqueList.fullCollection.version4.obj\");\n+//    }\n+\n+    // TODO: Generics\n+    public void testCollections304() {\n+        final List<String> list = new LinkedList<String>();\n+        final SetUniqueList<String> decoratedList = SetUniqueList.setUniqueList(list);\n+        final String s1 = \"Apple\";\n+        final String s2 = \"Lemon\";\n+        final String s3 = \"Orange\";\n+        final String s4 = \"Strawberry\";\n+\n+        decoratedList.add(s1);\n+        decoratedList.add(s2);\n+        decoratedList.add(s3);\n+\n+        assertEquals(3, decoratedList.size());\n+\n+        decoratedList.set(1, s4);\n+\n+        assertEquals(3, decoratedList.size());\n+\n+        decoratedList.add(1, s4);\n+\n+        assertEquals(3, decoratedList.size());\n+\n+        decoratedList.add(1, s2);\n+\n+        assertEquals(4, decoratedList.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCollections307() {\n+        List<E> list = new ArrayList<E>();\n+        List<E> uniqueList = SetUniqueList.setUniqueList(list);\n+\n+        final String hello = \"Hello\";\n+        final String world = \"World\";\n+        uniqueList.add((E) hello);\n+        uniqueList.add((E) world);\n+\n+        List<E> subList = list.subList(0, 0);\n+        List<E> subUniqueList = uniqueList.subList(0, 0);\n+\n+        assertFalse(subList.contains(world)); // passes\n+        assertFalse(subUniqueList.contains(world)); // fails\n+\n+        List<E> worldList = new ArrayList<E>();\n+        worldList.add((E) world);\n+        assertFalse(subList.contains(\"World\")); // passes\n+        assertFalse(subUniqueList.contains(\"World\")); // fails\n+\n+        // repeat the test with a different class than HashSet;\n+        // which means subclassing SetUniqueList below\n+        list = new ArrayList<E>();\n+        uniqueList = new SetUniqueList307(list, new java.util.TreeSet<E>());\n+\n+        uniqueList.add((E) hello);\n+        uniqueList.add((E) world);\n+\n+        subList = list.subList(0, 0);\n+        subUniqueList = uniqueList.subList(0, 0);\n+\n+        assertFalse(subList.contains(world)); // passes\n+        assertFalse(subUniqueList.contains(world)); // fails\n+\n+        worldList = new ArrayList<E>();\n+        worldList.add((E) world);\n+        assertFalse(subList.contains(\"World\")); // passes\n+        assertFalse(subUniqueList.contains(\"World\")); // fails\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testRetainAll() {\n+    \tfinal List<E> list = new ArrayList<E>(10);\n+    \tfinal SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n+    \tfor (int i = 0; i < 10; ++i) {\n+    \t\tuniqueList.add((E)Integer.valueOf(i));\n+    \t}\n+    \t\n+    \tfinal Collection<E> retained = new ArrayList<E>(5);\n+    \tfor (int i = 0; i < 5; ++i) {\n+    \t\tretained.add((E)Integer.valueOf(i * 2));\n+    \t}\n+    \t\n+    \tassertTrue(uniqueList.retainAll(retained));\n+    \tassertEquals(5, uniqueList.size());\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(0)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(2)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(4)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(6)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(8)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testRetainAllWithInitialList() {\n+    \t// initialized with empty list\n+    \tfinal List<E> list = new ArrayList<E>(10);\n+    \tfor (int i = 0; i < 5; ++i) {\n+    \t\tlist.add((E)Integer.valueOf(i));\n+    \t}\n+    \tfinal SetUniqueList<E> uniqueList = SetUniqueList.setUniqueList(list);\n+    \tfor (int i = 5; i < 10; ++i) {\n+    \t\tuniqueList.add((E)Integer.valueOf(i));\n+    \t}\n+    \t\n+    \tfinal Collection<E> retained = new ArrayList<E>(5);\n+    \tfor (int i = 0; i < 5; ++i) {\n+    \t\tretained.add((E)Integer.valueOf(i * 2));\n+    \t}\n+    \t\n+    \tassertTrue(uniqueList.retainAll(retained));\n+    \tassertEquals(5, uniqueList.size());\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(0)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(2)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(4)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(6)));\n+    \tassertTrue(uniqueList.contains(Integer.valueOf(8)));\n+    }\n+    \n+    /*\n+     * test case for https://issues.apache.org/jira/browse/COLLECTIONS-427\n+     */\n+    public void testRetainAllCollections427() {\n+        final int size = 50000;\n+        final ArrayList<Integer> list = new ArrayList<Integer>();\n+        for (int i = 0; i < size; i++) {\n+            list.add(i);\n+        }\n+        final SetUniqueList<Integer> uniqueList = SetUniqueList.setUniqueList(list);\n+        final ArrayList<Integer> toRetain = new ArrayList<Integer>();\n+        for (int i = size; i < 2*size; i++) {\n+            toRetain.add(i);\n+        }\n+\n+        final long start = System.currentTimeMillis();\n+        uniqueList.retainAll(toRetain);\n+        final long stop = System.currentTimeMillis();\n+        \n+        // make sure retainAll completes under 5 seconds\n+        // TODO if test is migrated to JUnit 4, add a Timeout rule.\n+        // http://kentbeck.github.com/junit/javadoc/latest/org/junit/rules/Timeout.html\n+        assertTrue(stop - start < 5000);\n+    }\n+    \n+    public void testSetCollections444() {\n+        final SetUniqueList<Integer> lset = new SetUniqueList<Integer>(new ArrayList<Integer>(), new HashSet<Integer>());\n+\n+        // Duplicate element\n+        final Integer obj1 = new Integer(1);\n+        final Integer obj2 = new Integer(2);\n+\n+        lset.add(obj1);\n+        lset.add(obj2);\n+        lset.set(0, obj1);\n+        assertEquals(2, lset.size());\n+        assertSame(obj1, lset.get(0));\n+        assertSame(obj2, lset.get(1));\n+\n+        assertTrue(lset.contains(obj1));\n+        assertTrue(lset.contains(obj2));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    class SetUniqueList307 extends SetUniqueList<E> {\n+        /**\n+         * Generated serial version ID.\n+         */\n+        private static final long serialVersionUID = 1415013031022962158L;\n+\n+        public SetUniqueList307(final List<E> list, final Set<E> set) {\n+            super(list, set);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/TransformedListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+import org.apache.commons.collections4.list.TransformedList;\n+\n+/**\n+ * Extension of {@link AbstractListTest} for exercising the {@link TransformedList}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedListTest<E> extends AbstractListTest<E> {\n+\n+    public TransformedListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public List<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    @Override\n+    public List<E> makeConfirmedFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public List<E> makeObject() {\n+        return TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public List<E> makeFullCollection() {\n+        final List<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedList.transformingList(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedList() {\n+        final List<E> list = TransformedList.transformingList(new ArrayList<E>(), (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, list.size());\n+        final E[] els = (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (int i = 0; i < els.length; i++) {\n+            list.add(els[i]);\n+            assertEquals(i + 1, list.size());\n+            assertEquals(true, list.contains(new Integer((String) els[i])));\n+            assertEquals(false, list.contains(els[i]));\n+        }\n+\n+        assertEquals(false, list.remove(els[0]));\n+        assertEquals(true, list.remove(new Integer((String) els[0])));\n+\n+        list.clear();\n+        for (int i = 0; i < els.length; i++) {\n+            list.add(0, els[i]);\n+            assertEquals(i + 1, list.size());\n+            assertEquals(new Integer((String) els[i]), list.get(0));\n+        }\n+\n+        list.set(0, (E) \"22\");\n+        assertEquals(new Integer(22), list.get(0));\n+\n+        final ListIterator<E> it = list.listIterator();\n+        it.next();\n+        it.set((E) \"33\");\n+        assertEquals(new Integer(33), list.get(0));\n+        it.add((E) \"44\");\n+        assertEquals(new Integer(44), list.get(1));\n+\n+        final List<E> adds = new ArrayList<E>();\n+        adds.add((E) \"1\");\n+        adds.add((E) \"2\");\n+        list.clear();\n+        list.addAll(adds);\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(2), list.get(1));\n+\n+        adds.clear();\n+        adds.add((E) \"3\");\n+        list.addAll(1, adds);\n+        assertEquals(new Integer(1), list.get(0));\n+        assertEquals(new Integer(3), list.get(1));\n+        assertEquals(new Integer(2), list.get(2));\n+    }\n+\n+    public void testTransformedList_decorateTransform() {\n+        final List<Object> originalList = new ArrayList<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalList.add(el);\n+        }\n+        final List<?> list = TransformedList.transformedList(originalList, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, list.size());\n+        for (final Object el : els) {\n+            assertEquals(true, list.contains(new Integer((String) el)));\n+            assertEquals(false, list.contains(el));\n+        }\n+        \n+        assertEquals(false, list.remove(els[0]));\n+        assertEquals(true, list.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedList.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.list.TreeList;\n+\n+/**\n+ * JUnit tests\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class TreeListTest<E> extends AbstractListTest<E> {\n+\n+    public TreeListTest(final String name) {\n+        super(name);\n+    }\n+\n+//    public static void main(String[] args) {\n+//        junit.textui.TestRunner.run(suite());\n+//        System.out.println(\"         add; toArray; iterator; insert; get; indexOf; remove\");\n+//        System.out.print(\"   TreeList = \");\n+//        benchmark(new TreeList());\n+//        System.out.print(\"\\n  ArrayList = \");\n+//        benchmark(new java.util.ArrayList());\n+//        System.out.print(\"\\n LinkedList = \");\n+//        benchmark(new java.util.LinkedList());\n+//        System.out.print(\"\\n NodeCachingLinkedList = \");\n+//        benchmark(new NodeCachingLinkedList());\n+//    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TreeListTest.class);\n+    }\n+\n+    public static void benchmark(final List<? super Integer> l) {\n+        long start = System.currentTimeMillis();\n+        for (int i = 0; i < 100000; i++) {\n+            l.add(new Integer(i));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 200; i++) {\n+            l.toArray();\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 100; i++) {\n+            final java.util.Iterator<? super Integer> it = l.iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+            }\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            final int j = (int) (Math.random() * 100000);\n+            l.add(j, new Integer(-j));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 50000; i++) {\n+            final int j = (int) (Math.random() * 110000);\n+            l.get(j);\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 200; i++) {\n+            final int j = (int) (Math.random() * 100000);\n+            l.indexOf(new Integer(j));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+\n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            final int j = (int) (Math.random() * 100000);\n+            l.remove(j);\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public TreeList<E> makeObject() {\n+        return new TreeList<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddMultiple() {\n+        final List<E> l = makeObject();\n+        l.add((E) \"hugo\");\n+        l.add((E) \"erna\");\n+        l.add((E) \"daniel\");\n+        l.add((E) \"andres\");\n+        l.add((E) \"harald\");\n+        l.add(0, null);\n+        assertEquals(null, l.get(0));\n+        assertEquals(\"hugo\", l.get(1));\n+        assertEquals(\"erna\", l.get(2));\n+        assertEquals(\"daniel\", l.get(3));\n+        assertEquals(\"andres\", l.get(4));\n+        assertEquals(\"harald\", l.get(5));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        final List<E> l = makeObject();\n+        l.add((E) \"hugo\");\n+        l.add((E) \"erna\");\n+        l.add((E) \"daniel\");\n+        l.add((E) \"andres\");\n+        l.add((E) \"harald\");\n+        l.add(0, null);\n+        int i = 0;\n+        assertEquals(null, l.get(i++));\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"erna\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"andres\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+\n+        l.remove(0);\n+        i = 0;\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"erna\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"andres\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+\n+        i = 0;\n+        l.remove(1);\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"andres\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+\n+        i = 0;\n+        l.remove(2);\n+        assertEquals(\"hugo\", l.get(i++));\n+        assertEquals(\"daniel\", l.get(i++));\n+        assertEquals(\"harald\", l.get(i++));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInsertBefore() {\n+        final List<E> l = makeObject();\n+        l.add((E) \"erna\");\n+        l.add(0, (E) \"hugo\");\n+        assertEquals(\"hugo\", l.get(0));\n+        assertEquals(\"erna\", l.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIndexOf() {\n+        final List<E> l = makeObject();\n+        l.add((E) \"0\");\n+        l.add((E) \"1\");\n+        l.add((E) \"2\");\n+        l.add((E) \"3\");\n+        l.add((E) \"4\");\n+        l.add((E) \"5\");\n+        l.add((E) \"6\");\n+        assertEquals(0, l.indexOf(\"0\"));\n+        assertEquals(1, l.indexOf(\"1\"));\n+        assertEquals(2, l.indexOf(\"2\"));\n+        assertEquals(3, l.indexOf(\"3\"));\n+        assertEquals(4, l.indexOf(\"4\"));\n+        assertEquals(5, l.indexOf(\"5\"));\n+        assertEquals(6, l.indexOf(\"6\"));\n+\n+        l.set(1, (E) \"0\");\n+        assertEquals(0, l.indexOf(\"0\"));\n+\n+        l.set(3, (E) \"3\");\n+        assertEquals(3, l.indexOf(\"3\"));\n+        l.set(2, (E) \"3\");\n+        assertEquals(2, l.indexOf(\"3\"));\n+        l.set(1, (E) \"3\");\n+        assertEquals(1, l.indexOf(\"3\"));\n+        l.set(0, (E) \"3\");\n+        assertEquals(0, l.indexOf(\"3\"));\n+    }\n+\n+//    public void testCheck() {\n+//        List l = makeEmptyList();\n+//        l.add(\"A1\");\n+//        l.add(\"A2\");\n+//        l.add(\"A3\");\n+//        l.add(\"A4\");\n+//        l.add(\"A5\");\n+//        l.add(\"A6\");\n+//    }\n+\n+    public void testBug35258() {\n+        final Object objectToRemove = new Integer(3);\n+\n+        final List<Integer> treelist = new TreeList<Integer>();\n+        treelist.add(new Integer(0));\n+        treelist.add(new Integer(1));\n+        treelist.add(new Integer(2));\n+        treelist.add(new Integer(3));\n+        treelist.add(new Integer(4));\n+\n+        // this cause inconsistence of ListIterator()\n+        treelist.remove(objectToRemove);\n+\n+        final ListIterator<Integer> li = treelist.listIterator();\n+        assertEquals(new Integer(0), li.next());\n+        assertEquals(new Integer(0), li.previous());\n+        assertEquals(new Integer(0), li.next());\n+        assertEquals(new Integer(1), li.next());\n+        // this caused error in bug 35258\n+        assertEquals(new Integer(1), li.previous());\n+        assertEquals(new Integer(1), li.next());\n+        assertEquals(new Integer(2), li.next());\n+        assertEquals(new Integer(2), li.previous());\n+        assertEquals(new Integer(2), li.next());\n+        assertEquals(new Integer(4), li.next());\n+        assertEquals(new Integer(4), li.previous());\n+        assertEquals(new Integer(4), li.next());\n+        assertEquals(false, li.hasNext());\n+    }\n+    \n+    public void testBugCollections447() {\n+        final List<String> treeList = new TreeList<String>();\n+        treeList.add(\"A\");\n+        treeList.add(\"B\");\n+        treeList.add(\"C\");\n+        treeList.add(\"D\");\n+        \n+        final ListIterator<String> li = treeList.listIterator();\n+        assertEquals(\"A\", li.next());\n+        assertEquals(\"B\", li.next());\n+        \n+        assertEquals(\"B\", li.previous());\n+                \n+        li.remove(); // Deletes \"B\"\n+                \n+        // previous() after remove() should move to\n+        // the element before the one just removed\n+        assertEquals(\"A\", li.previous());\n+    }    \n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.list;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.collections4.list.UnmodifiableList;\n+\n+/**\n+ * Extension of {@link AbstractListTest} for exercising the\n+ * {@link UnmodifiableList} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableListTest<E> extends AbstractListTest<E> {\n+\n+    public UnmodifiableListTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public UnmodifiableList<E> makeObject() {\n+        return new UnmodifiableList<E>(new ArrayList<E>());\n+    }\n+\n+    @Override\n+    public UnmodifiableList<E> makeFullCollection() {\n+        final ArrayList<E> list = new ArrayList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return new UnmodifiableList<E>(list);\n+    }\n+\n+    @Override\n+    public boolean isSetSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected UnmodifiableList<E> list;\n+    protected ArrayList<E> array;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected void setupList() {\n+        list = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) new Integer(1));\n+    }\n+\n+    /**\n+     * Verify that base list and sublists are not modifiable\n+     */\n+    public void testUnmodifiable() {\n+        setupList();\n+        verifyUnmodifiable(list);\n+        verifyUnmodifiable(list.subList(0, 2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected void verifyUnmodifiable(final List<E> list) {\n+        try {\n+            list.add(0, (E) new Integer(0));\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.add((E) new Integer(0));\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.addAll(0, array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.addAll(array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.clear();\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.remove(0);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.remove(new Integer(0));\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.removeAll(array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.retainAll(array);\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            list.set(0, (E) new Integer(0));\n+             fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Verify that iterator is not modifiable\n+     */\n+    public void testUnmodifiableIterator() {\n+        setupList();\n+        final Iterator<E> iterator = list.iterator();\n+        try {\n+            iterator.next();\n+            iterator.remove();\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableList.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableList.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;\n+\n+/**\n+ * Abstract test class for {@link IterableMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractIterableMapTest<K, V> extends AbstractMapTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractIterableMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract IterableMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        return (IterableMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFailFastEntrySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        if (isFailFastExpected() == false) {\n+            return;\n+        }\n+        resetFull();\n+        Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();\n+        final Map.Entry<K, V> val = it.next();\n+        getMap().remove(val.getKey());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().entrySet().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final ConcurrentModificationException ex) {}\n+    }\n+\n+    public void testFailFastKeySet() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        if (isFailFastExpected() == false) {\n+            return;\n+        }\n+        resetFull();\n+        Iterator<K> it = getMap().keySet().iterator();\n+        final K val = it.next();\n+        getMap().remove(val);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().keySet().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final ConcurrentModificationException ex) {}\n+    }\n+\n+    public void testFailFastValues() {\n+        if (isRemoveSupported() == false) {\n+            return;\n+        }\n+        if (isFailFastExpected() == false) {\n+            return;\n+        }\n+        resetFull();\n+        Iterator<V> it = getMap().values().iterator();\n+        it.next();\n+        getMap().remove(getMap().keySet().iterator().next());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().values().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (final ConcurrentModificationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestMapIterator() {\n+        return new InnerTestMapIterator();\n+    }\n+\n+    public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V> {\n+        public InnerTestMapIterator() {\n+            super(\"InnerTestMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractIterableMapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractIterableMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isGetStructuralModify() {\n+            return AbstractIterableMapTest.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractIterableMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractIterableMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractIterableMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public Map<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractIterableMapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractIterableMapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractIterableMapTest.this.verify();\n+        }\n+    }\n+\n+//  public void testCreate() throws Exception {\n+//      resetEmpty();\n+//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n+//      resetFull();\n+//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n+//  }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public IterableMap<K, V> getMap() {\n+        return (IterableMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+import org.apache.commons.collections4.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections4.set.AbstractSetTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.Map} methods and contracts.\n+ * <p>\n+ * The forces at work here are similar to those in {@link AbstractCollectionTest}.\n+ * If your class implements the full Map interface, including optional\n+ * operations, simply extend this class, and implement the\n+ * {@link #makeObject()} method.\n+ * <p>\n+ * On the other hand, if your map implementation is weird, you may have to\n+ * override one or more of the other protected methods.  They're described\n+ * below.\n+ * <p>\n+ * <b>Entry Population Methods</b>\n+ * <p>\n+ * Override these methods if your map requires special entries:\n+ *\n+ * <ul>\n+ * <li>{@link #getSampleKeys()}\n+ * <li>{@link #getSampleValues()}\n+ * <li>{@link #getNewSampleValues()}\n+ * <li>{@link #getOtherKeys()}\n+ * <li>{@link #getOtherValues()}\n+ * </ul>\n+ *\n+ * <b>Supported Operation Methods</b>\n+ * <p>\n+ * Override these methods if your map doesn't support certain operations:\n+ *\n+ * <ul>\n+ * <li> {@link #isPutAddSupported()}\n+ * <li> {@link #isPutChangeSupported()}\n+ * <li> {@link #isSetValueSupported()}\n+ * <li> {@link #isRemoveSupported()}\n+ * <li> {@link #isGetStructuralModify()}\n+ * <li> {@link #isAllowDuplicateValues()}\n+ * <li> {@link #isAllowNullKey()}\n+ * <li> {@link #isAllowNullValue()}\n+ * </ul>\n+ *\n+ * <b>Fixture Methods</b>\n+ * <p>\n+ * For tests on modification operations (puts and removes), fixtures are used\n+ * to verify that that operation results in correct state for the map and its\n+ * collection views.  Basically, the modification is performed against your\n+ * map implementation, and an identical modification is performed against\n+ * a <I>confirmed</I> map implementation.  A confirmed map implementation is\n+ * something like <Code>java.util.HashMap</Code>, which is known to conform\n+ * exactly to the {@link Map} contract.  After the modification takes place\n+ * on both your map implementation and the confirmed map implementation, the\n+ * two maps are compared to see if their state is identical.  The comparison\n+ * also compares the collection views to make sure they're still the same.<P>\n+ *\n+ * The upshot of all that is that <I>any</I> test that modifies the map in\n+ * <I>any</I> way will verify that <I>all</I> of the map's state is still\n+ * correct, including the state of its collection views.  So for instance\n+ * if a key is removed by the map's key set's iterator, then the entry set\n+ * is checked to make sure the key/value pair no longer appears.<P>\n+ *\n+ * The {@link #map} field holds an instance of your collection implementation.\n+ * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n+ * that map's collection views.  And the {@link #confirmed} field holds\n+ * an instance of the confirmed collection implementation.  The\n+ * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to\n+ * empty or full maps, so that tests can proceed from a known state.<P>\n+ *\n+ * After a modification operation to both {@link #map} and {@link #confirmed},\n+ * the {@link #verify()} method is invoked to compare the results.  The\n+ * {@link #verify} method calls separate methods to verify the map and its three\n+ * collection views ({@link #verifyMap}, {@link #verifyEntrySet},\n+ * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override\n+ * one of the verification methods to perform additional verifications.  For\n+ * instance, TestDoubleOrderedMap would want override its\n+ * {@link #verifyValues()} method to verify that the values are unique and in\n+ * ascending order.<P>\n+ *\n+ * <b>Other Notes</b>\n+ * <p>\n+ * If your {@link Map} fails one of these tests by design, you may still use\n+ * this base set of cases.  Simply override the test case (method) your map\n+ * fails and/or the methods that define the assumptions used by the test\n+ * cases.  For example, if your map does not allow duplicate values, override\n+ * {@link #isAllowDuplicateValues()} and have it return <code>false</code>\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapTest<K, V> extends AbstractObjectTest {\n+\n+    /**\n+     * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString\n+     * This avoids nulls for JDK1.2\n+     */\n+    private static final boolean JDK12;\n+    static {\n+        final String str = System.getProperty(\"java.version\");\n+        JDK12 = str.startsWith(\"1.2\");\n+    }\n+\n+    // These instance variables are initialized with the reset method.\n+    // Tests for map methods that alter the map (put, putAll, remove)\n+    // first call reset() to create the map and its views; then perform\n+    // the modification on the map; perform the same modification on the\n+    // confirmed; and then call verify() to ensure that the map is equal\n+    // to the confirmed, that the already-constructed collection views\n+    // are still equal to the confirmed's collection views.\n+\n+    /** Map created by reset(). */\n+    protected Map<K, V> map;\n+\n+    /** Entry set of map created by reset(). */\n+    protected Set<Map.Entry<K, V>> entrySet;\n+\n+    /** Key set of map created by reset(). */\n+    protected Set<K> keySet;\n+\n+    /** Values collection of map created by reset(). */\n+    protected Collection<V> values;\n+\n+    /** HashMap created by reset(). */\n+    protected Map<K, V> confirmed;\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>put</code> and <code>putAll</code> operations\n+     * adding new mappings.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support put adding.\n+     */\n+    public boolean isPutAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>put</code> and <code>putAll</code> operations\n+     * changing existing mappings.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support put changing.\n+     */\n+    public boolean isPutChangeSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>setValue</code> operation on entrySet entries.\n+     * <p>\n+     * Default implementation returns isPutChangeSupported().\n+     * Override if your collection class does not support setValue but does\n+     * support put changing.\n+     */\n+    public boolean isSetValueSupported() {\n+        return isPutChangeSupported();\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>remove</code> and <code>clear</code> operations.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * can cause structural modification on a get(). The example is LRUMap.\n+     * <p>\n+     * Default implementation returns false.\n+     * Override if your map class structurally modifies on get.\n+     */\n+    public boolean isGetStructuralModify() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether the sub map views of SortedMap are serializable.\n+     * If the class being tested is based around a TreeMap then you should\n+     * override and return false as TreeMap has a bug in deserialization.\n+     *\n+     * @return false\n+     */\n+    public boolean isSubMapViewsSerializable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports null keys.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support null keys.\n+     */\n+    public boolean isAllowNullKey() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports null values.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support null values.\n+     */\n+    public boolean isAllowNullValue() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports duplicate values.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support duplicate values.\n+     */\n+    public boolean isAllowDuplicateValues() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * provide fail-fast behavior on their various iterators.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support fast failure.\n+     */\n+    public boolean isFailFastExpected() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns the set of keys in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleValues()} and all array elements must be different. The\n+     *  default implementation constructs a set of String keys, and includes a\n+     *  single null key if {@link #isAllowNullKey()} returns <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        final Object[] result = new Object[] {\n+            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\",\n+            \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n+            \"key\",\n+            \"key2\",\n+            isAllowNullKey() && !JDK12 ? null : \"nonnullkey\"\n+        };\n+        return (K[]) result;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getOtherKeys() {\n+        return (K[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getOtherValues() {\n+        return (V[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <E> List<E> getAsList(final Object[] o) {\n+        final ArrayList<E> result = new ArrayList<E>();\n+        for (final Object element : o) {\n+            result.add((E) element);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a list of string elements suitable for return by\n+     * {@link #getOtherKeys()} or {@link #getOtherValues}.\n+     *\n+     * <p>Override getOtherElements to return the results of this method if your\n+     * collection does not support heterogenous elements or the null element.\n+     * </p>\n+     */\n+    public Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\",\"then\",\"despite\",/* of */\"space\",\"I\",\"would\",\"be\",\"brought\",\n+            \"From\",\"limits\",\"far\",\"remote\",\"where\",\"thou\",\"dost\",\"stay\"\n+        };\n+    }\n+\n+    /**\n+     * Returns the set of values in the mappings used to test the map.  This\n+     * method must return an array with the same length as\n+     * {@link #getSampleKeys()}.  The default implementation constructs a set of\n+     * String values and includes a single null value if\n+     * {@link #isAllowNullValue()} returns <code>true</code>, and includes\n+     * two values that are the same if {@link #isAllowDuplicateValues()} returns\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        final Object[] result = new Object[] {\n+            \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n+            \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n+            isAllowNullValue() && !JDK12 ? null : \"nonnullvalue\",\n+            \"value\",\n+            isAllowDuplicateValues() ? \"value\" : \"value2\",\n+        };\n+        return (V[]) result;\n+    }\n+\n+    /**\n+     * Returns a the set of values that can be used to replace the values\n+     * returned from {@link #getSampleValues()}.  This method must return an\n+     * array with the same length as {@link #getSampleValues()}.  The values\n+     * returned from this method should not be the same as those returned from\n+     * {@link #getSampleValues()}.  The default implementation constructs a\n+     * set of String values and includes a single null value if\n+     * {@link #isAllowNullValue()} returns <code>true</code>, and includes two values\n+     * that are the same if {@link #isAllowDuplicateValues()} returns\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        final Object[] result = new Object[] {\n+            isAllowNullValue() && !JDK12 && isAllowDuplicateValues() ? null : \"newnonnullvalue\",\n+            \"newvalue\",\n+            isAllowDuplicateValues() ? \"newvalue\" : \"newvalue2\",\n+            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\",\n+            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\",\n+            \"newseev\", \"newyouv\", \"newallv\", \"newagainv\",\n+        };\n+        return (V[]) result;\n+    }\n+\n+    /**\n+     *  Helper method to add all the mappings described by\n+     * {@link #getSampleKeys()} and {@link #getSampleValues()}.\n+     */\n+    public void addSampleMappings(final Map<? super K, ? super V> m) {\n+\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            try {\n+                m.put(keys[i], values[i]);\n+            } catch (final NullPointerException exception) {\n+                assertTrue(\"NullPointerException only allowed to be thrown \" +\n+                           \"if either the key or value is null.\",\n+                           keys[i] == null || values[i] == null);\n+\n+                assertTrue(\"NullPointerException on null key, but \" +\n+                           \"isAllowNullKey is not overridden to return false.\",\n+                           keys[i] == null || !isAllowNullKey());\n+\n+                assertTrue(\"NullPointerException on null value, but \" +\n+                           \"isAllowNullValue is not overridden to return false.\",\n+                           values[i] == null || !isAllowNullValue());\n+\n+                assertTrue(\"Unknown reason for NullPointer.\", false);\n+            }\n+        }\n+        assertEquals(\"size must reflect number of mappings added.\",\n+                     keys.length, m.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return a new, empty {@link Map} to be used for testing.\n+     *\n+     * @return the map to be tested\n+     */\n+    @Override\n+    public abstract Map<K,V> makeObject();\n+\n+    /**\n+     * Return a new, populated map.  The mappings in the map should match the\n+     * keys and values returned from {@link #getSampleKeys()} and\n+     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()\n+     * and calls {@link #addSampleMappings} to add all the mappings to the\n+     * map.\n+     *\n+     * @return the map to be tested\n+     */\n+    public Map<K, V> makeFullMap() {\n+        final Map<K, V> m = makeObject();\n+        addSampleMappings(m);\n+        return m;\n+    }\n+\n+    /**\n+     * Override to return a map other than HashMap as the confirmed map.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n+    }\n+\n+    /**\n+     * Creates a new Map Entry that is independent of the first and the map.\n+     */\n+    public static <K, V> Map.Entry<K, V> cloneMapEntry(final Map.Entry<K, V> entry) {\n+        final HashMap<K, V> map = new HashMap<K, V>();\n+        map.put(entry.getKey(), entry.getValue());\n+        return map.entrySet().iterator().next();\n+    }\n+\n+    /**\n+     * Gets the compatability version, needed for package access.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return super.getCompatibilityVersion();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test to ensure the test setup is working properly.  This method checks\n+     * to ensure that the getSampleKeys and getSampleValues methods are\n+     * returning results that look appropriate.  That is, they both return a\n+     * non-null array of equal length.  The keys array must not have any\n+     * duplicate values, and may only contain a (single) null key if\n+     * isNullKeySupported() returns true.  The values array must only have a null\n+     * value if useNullValue() is true and may only have duplicate values if\n+     * isAllowDuplicateValues() returns true.\n+     */\n+    public void testSampleMappings() {\n+        final Object[] keys = getSampleKeys();\n+        final Object[] values = getSampleValues();\n+        final Object[] newValues = getNewSampleValues();\n+\n+        assertNotNull(\"failure in test: Must have keys returned from \" +\n+                 \"getSampleKeys.\", keys);\n+\n+        assertNotNull(\"failure in test: Must have values returned from \" +\n+                 \"getSampleValues.\", values);\n+\n+        // verify keys and values have equivalent lengths (in case getSampleX are\n+        // overridden)\n+        assertEquals(\"failure in test: not the same number of sample \" +\n+                   \"keys and values.\",  keys.length, values.length);\n+\n+        assertEquals(\"failure in test: not the same number of values and new values.\",\n+                   values.length, newValues.length);\n+\n+        // verify there aren't duplicate keys, and check values\n+        for (int i = 0; i < keys.length - 1; i++) {\n+            for (int j = i + 1; j < keys.length; j++) {\n+                assertTrue(\"failure in test: duplicate null keys.\",\n+                        keys[i] != null || keys[j] != null);\n+                assertTrue(\n+                        \"failure in test: duplicate non-null key.\",\n+                        keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) && !keys[j]\n+                                .equals(keys[i]));\n+            }\n+            assertTrue(\"failure in test: found null key, but isNullKeySupported \" + \"is false.\",\n+                    keys[i] != null || isAllowNullKey());\n+            assertTrue(\n+                    \"failure in test: found null value, but isNullValueSupported \" + \"is false.\",\n+                    values[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: found null new value, but isNullValueSupported \"\n+                    + \"is false.\", newValues[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: values should not be the same as new value\",\n+                    values[i] != newValues[i]\n+                            && (values[i] == null || !values[i].equals(newValues[i])));\n+        }\n+    }\n+\n+    // tests begin here.  Each test adds a little bit of tested functionality.\n+    // Many methods assume previous methods passed.  That is, they do not\n+    // exhaustively recheck things that have already been checked in a previous\n+    // test methods.\n+\n+    /**\n+     * Test to ensure that makeEmptyMap and makeFull returns a new non-null\n+     * map with each invocation.\n+     */\n+    public void testMakeMap() {\n+        final Map<K, V> em = makeObject();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        final Map<K, V> em2 = makeObject();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n+                   \"with each invocation.\", em != em2);\n+\n+        final Map<K, V> fm = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        final Map<K, V> fm2 = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        assertTrue(\"failure in test: makeFullMap must return a new map \" +\n+                   \"with each invocation.\", fm != fm2);\n+    }\n+\n+    /**\n+     * Tests Map.isEmpty()\n+     */\n+    public void testMapIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"Map.isEmpty() should return true with an empty map\",\n+                     true, getMap().isEmpty());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n+                     false, getMap().isEmpty());\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.size()\n+     */\n+    public void testMapSize() {\n+        resetEmpty();\n+        assertEquals(\"Map.size() should be 0 with an empty map\",\n+                     0, getMap().size());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.size() should equal the number of entries \" +\n+                     \"in the map\", getSampleKeys().length, getMap().size());\n+        verify();\n+    }\n+\n+    /**\n+     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}\n+     * can add and remove elements}, then {@link Map#size()} and\n+     * {@link Map#isEmpty()} are used to ensure that map has no elements after\n+     * a call to clear.  If the map does not support adding and removing\n+     * elements, this method checks to ensure clear throws an\n+     * UnsupportedOperationException.\n+     */\n+    public void testMapClear() {\n+        if (!isRemoveSupported()) {\n+            try {\n+                resetFull();\n+                getMap().clear();\n+                fail(\"Expected UnsupportedOperationException on clear\");\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        resetEmpty();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+\n+        resetFull();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.containsKey(Object) by verifying it returns false for all\n+     * sample keys on a map created using an empty map and returns true for\n+     * all sample keys returned on a full map.\n+     */\n+    public void testMapContainsKey() {\n+        final Object[] keys = getSampleKeys();\n+\n+        resetEmpty();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must not contain key when map is empty\",\n+                       !getMap().containsKey(keys[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for (final Object key : keys) {\n+            assertTrue(\"Map must contain key for a mapping in the map. \" +\n+                       \"Missing: \" + key, getMap().containsKey(key));\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.containsValue(Object) by verifying it returns false for all\n+     * sample values on an empty map and returns true for all sample values on\n+     * a full map.\n+     */\n+    public void testMapContainsValue() {\n+        final Object[] values = getSampleValues();\n+\n+        resetEmpty();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Empty map must not contain value\",\n+                       !getMap().containsValue(values[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for (final Object value : values) {\n+            assertTrue(\"Map must contain value for a mapping in the map.\",\n+                    getMap().containsValue(value));\n+        }\n+        verify();\n+    }\n+\n+\n+    /**\n+     * Tests Map.equals(Object)\n+     */\n+    public void testMapEquals() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        // modify the HashMap created from the full map and make sure this\n+        // change results in map.equals() to return false.\n+        final Iterator<K> iter = confirmed.keySet().iterator();\n+        iter.next();\n+        iter.remove();\n+        assertTrue(\"Different maps equal.\", !getMap().equals(confirmed));\n+\n+        resetFull();\n+        assertTrue(\"equals(null) returned true.\", !getMap().equals(null));\n+        assertTrue(\"equals(new Object()) returned true.\",\n+                   !getMap().equals(new Object()));\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.get(Object)\n+     */\n+    public void testMapGet() {\n+        resetEmpty();\n+\n+        final Object[] keys = getSampleKeys();\n+        final Object[] values = getSampleValues();\n+\n+        for (final Object key : keys) {\n+            assertTrue(\"Empty map.get() should return null.\",\n+                    getMap().get(key) == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+        for (int i = 0; i < keys.length; i++) {\n+            assertEquals(\"Full map.get() should return value from mapping.\",\n+                         values[i], getMap().get(keys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.hashCode()\n+     */\n+    public void testMapHashCode() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+\n+        resetFull();\n+        assertTrue(\"Equal maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+    }\n+\n+    /**\n+     * Tests Map.toString().  Since the format of the string returned by the\n+     * toString() method is not defined in the Map interface, there is no\n+     * common way to test the results of the toString() method.  Thereforce,\n+     * it is encouraged that Map implementations override this test with one\n+     * that checks the format matches any format defined in its API.  This\n+     * default implementation just verifies that the toString() method does\n+     * not return null.\n+     */\n+    public void testMapToString() {\n+        resetEmpty();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyMapCompatibility() throws Exception {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeEmptyMap();\n+        if (!(map instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        final Map<K, V> map = makeObject();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            @SuppressWarnings(\"unchecked\")\n+            final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertEquals(\"Map is empty\", 0, map2.size());\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testFullMapCompatibility() throws Exception {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeFullMap();\n+        if (!(map instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        final Map<K, V> map = makeFullMap();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            @SuppressWarnings(\"unchecked\")\n+            final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+            assertEquals(\"Map is the right size\", getSampleKeys().length, map2.size());\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(Object, Object)\n+     */\n+    public void testMapPut() {\n+        resetEmpty();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        final V[] newValues = getNewSampleValues();\n+\n+        if (isPutAddSupported()) {\n+            for (int i = 0; i < keys.length; i++) {\n+                final Object o = getMap().put(keys[i], values[i]);\n+                getConfirmed().put(keys[i], values[i]);\n+                verify();\n+                assertTrue(\"First map.put should return null\", o == null);\n+                assertTrue(\"Map should contain key after put\",\n+                        getMap().containsKey(keys[i]));\n+                assertTrue(\"Map should contain value after put\",\n+                        getMap().containsValue(values[i]));\n+            }\n+            if (isPutChangeSupported()) {\n+                for (int i = 0; i < keys.length; i++) {\n+                    final Object o = getMap().put(keys[i], newValues[i]);\n+                    getConfirmed().put(keys[i], newValues[i]);\n+                    verify();\n+                    assertEquals(\"Map.put should return previous value when changed\", values[i], o);\n+                    assertTrue(\"Map should still contain key after put when changed\",\n+                            getMap().containsKey(keys[i]));\n+                    assertTrue(\"Map should contain new value after put when changed\",\n+                            getMap().containsValue(newValues[i]));\n+\n+                    // if duplicates are allowed, we're not guaranteed that the value\n+                    // no longer exists, so don't try checking that.\n+                    if (!isAllowDuplicateValues()) {\n+                        assertTrue(\"Map should not contain old value after put when changed\",\n+                                !getMap().containsValue(values[i]));\n+                    }\n+                }\n+            } else {\n+                try {\n+                    // two possible exception here, either valid\n+                    getMap().put(keys[0], newValues[0]);\n+                    fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n+                } catch (final IllegalArgumentException ex) {\n+                } catch (final UnsupportedOperationException ex) {}\n+            }\n+\n+        } else if (isPutChangeSupported()) {\n+            resetEmpty();\n+            try {\n+                getMap().put(keys[0], values[0]);\n+                fail(\"Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size\");\n+            } catch (final IllegalArgumentException ex) {\n+            } catch (final UnsupportedOperationException ex) {\n+            }\n+\n+            resetFull();\n+            int i = 0;\n+            for (final Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n+                final K  key = it.next();\n+                final V o = getMap().put(key, newValues[i]);\n+                final V value = getConfirmed().put(key, newValues[i]);\n+                verify();\n+                assertEquals(\"Map.put should return previous value when changed\", value, o);\n+                assertTrue(\"Map should still contain key after put when changed\", getMap()\n+                        .containsKey(key));\n+                assertTrue(\"Map should contain new value after put when changed\", getMap()\n+                        .containsValue(newValues[i]));\n+\n+                // if duplicates are allowed, we're not guaranteed that the value\n+                // no longer exists, so don't try checking that.\n+                if (!isAllowDuplicateValues()) {\n+                    assertTrue(\"Map should not contain old value after put when changed\",\n+                        !getMap().containsValue(values[i]));\n+                }\n+            }\n+        } else {\n+            try {\n+                getMap().put(keys[0], values[0]);\n+                fail(\"Expected UnsupportedOperationException on put (add)\");\n+            } catch (final UnsupportedOperationException ex) {}\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(null, value)\n+     */\n+    public void testMapPutNullKey() {\n+        resetFull();\n+        final V[] values = getSampleValues();\n+\n+        if (isPutAddSupported()) {\n+            if (isAllowNullKey()) {\n+                getMap().put(null, values[0]);\n+            } else {\n+                try {\n+                    getMap().put(null, values[0]);\n+                    fail(\"put(null, value) should throw NPE/IAE\");\n+                } catch (final NullPointerException ex) {\n+                } catch (final IllegalArgumentException ex) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(null, value)\n+     */\n+    public void testMapPutNullValue() {\n+        resetFull();\n+        final K[] keys = getSampleKeys();\n+\n+        if (isPutAddSupported()) {\n+            if (isAllowNullValue()) {\n+                getMap().put(keys[0], null);\n+            } else {\n+                try {\n+                    getMap().put(keys[0], null);\n+                    fail(\"put(key, null) should throw NPE/IAE\");\n+                } catch (final NullPointerException ex) {\n+                } catch (final IllegalArgumentException ex) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.putAll(map)\n+     */\n+    public void testMapPutAll() {\n+        if (!isPutAddSupported()) {\n+            if (!isPutChangeSupported()) {\n+                final Map<K, V> temp = makeFullMap();\n+                resetEmpty();\n+                try {\n+                    getMap().putAll(temp);\n+                    fail(\"Expected UnsupportedOperationException on putAll\");\n+                } catch (final UnsupportedOperationException ex) {}\n+            }\n+            return;\n+        }\n+\n+        // check putAll OK adding empty map to empty map\n+        resetEmpty();\n+        assertEquals(0, getMap().size());\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(0, getMap().size());\n+\n+        // check putAll OK adding empty map to non-empty map\n+        resetFull();\n+        final int size = getMap().size();\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(size, getMap().size());\n+\n+        // check putAll OK adding non-empty map to empty map\n+        resetEmpty();\n+        Map<K, V> m2 = makeFullMap();\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+\n+        // check putAll OK adding non-empty JDK map to empty map\n+        resetEmpty();\n+        m2 = makeConfirmedMap();\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        for(int i = 0; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+\n+        // check putAll OK adding non-empty JDK map to non-empty map\n+        resetEmpty();\n+        m2 = makeConfirmedMap();\n+        getMap().put(keys[0], values[0]);\n+        getConfirmed().put(keys[0], values[0]);\n+        verify();\n+        for(int i = 1; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.remove(Object)\n+     */\n+    public void testMapRemove() {\n+        if (!isRemoveSupported()) {\n+            try {\n+                resetFull();\n+                getMap().remove(getMap().keySet().iterator().next());\n+                fail(\"Expected UnsupportedOperationException on remove\");\n+            } catch (final UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        resetEmpty();\n+\n+        final Object[] keys = getSampleKeys();\n+        final Object[] values = getSampleValues();\n+        for (final Object key : keys) {\n+            final Object o = getMap().remove(key);\n+            assertTrue(\"First map.remove should return null\", o == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            final Object o = getMap().remove(keys[i]);\n+            getConfirmed().remove(keys[i]);\n+            verify();\n+\n+            assertEquals(\"map.remove with valid key should return value\",\n+                         values[i], o);\n+        }\n+\n+        final Object[] other = getOtherKeys();\n+\n+        resetFull();\n+        final int size = getMap().size();\n+        for (final Object element : other) {\n+            final Object o = getMap().remove(element);\n+            assertNull(\"map.remove for nonexistent key should return null\", o);\n+            assertEquals(\"map.remove for nonexistent key should not \" +\n+                         \"shrink map\", size, getMap().size());\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testValuesClearChangesMap() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(values.size() > 0);\n+        values.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(values.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(values.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(values.size() == 0);\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testKeySetClearChangesMap() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Set<K> keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        keySet.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(keySet.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(keySet.size() == 0);\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet()} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testEntrySetClearChangesMap() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        entrySet.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEntrySetContains1() {\n+        resetFull();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        assertEquals(true, entrySet.contains(entry));\n+    }\n+\n+    public void testEntrySetContains2() {\n+        resetFull();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final Map.Entry<K, V> test = cloneMapEntry(entry);\n+        assertEquals(true, entrySet.contains(test));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySetContains3() {\n+        resetFull();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        final Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+        assertEquals(false, entrySet.contains(test));\n+    }\n+\n+    public void testEntrySetRemove1() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        final int size = getMap().size();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final K key = entry.getKey();\n+\n+        assertEquals(true, entrySet.remove(entry));\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    public void testEntrySetRemove2() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        final int size = getMap().size();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final K key = entry.getKey();\n+        final Map.Entry<K, V> test = cloneMapEntry(entry);\n+\n+        assertEquals(true, entrySet.remove(test));\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySetRemove3() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        resetFull();\n+        final int size = getMap().size();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        final K key = entry.getKey();\n+        final HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        final Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+\n+        assertEquals(false, entrySet.remove(test));\n+        assertEquals(true, getMap().containsKey(key));\n+        assertEquals(size, getMap().size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map by removing from the values collection\n+     * and testing if the value was removed from the map.\n+     * <p>\n+     * We should really test the \"vice versa\" case--that values removed\n+     * from the map are removed from the values collection--also,\n+     * but that's a more difficult test to construct (lacking a\n+     * \"removeValue\" method.)\n+     * </p>\n+     * <p>\n+     * See bug <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=9573\">\n+     * 9573</a>.\n+     * </p>\n+     */\n+    public void testValuesRemoveChangesMap() {\n+        resetFull();\n+        final V[] sampleValues = getSampleValues();\n+        final Collection<V> values = getMap().values();\n+        for (int i = 0; i < sampleValues.length; i++) {\n+            if (map.containsValue(sampleValues[i])) {\n+                int j = 0;  // loop counter prevents infinite loops when remove is broken\n+                while (values.contains(sampleValues[i]) && j < 10000) {\n+                    try {\n+                        values.remove(sampleValues[i]);\n+                    } catch (final UnsupportedOperationException e) {\n+                        // if values.remove is unsupported, just skip this test\n+                        return;\n+                    }\n+                    j++;\n+                }\n+                assertTrue(\"values().remove(obj) is broken\", j < 10000);\n+                assertTrue(\n+                    \"Value should have been removed from the underlying map.\",\n+                    !getMap().containsValue(sampleValues[i]));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests values.removeAll.\n+     */\n+    public void testValuesRemoveAll() {\n+        resetFull();\n+        final Collection<V> values = getMap().values();\n+        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        if (!values.equals(sampleValuesAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(values.removeAll(Collections.<V> emptySet()));\n+        } catch (final UnsupportedOperationException e) {\n+            // if values.removeAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertEquals(sampleValuesAsList.size(), getMap().size());\n+        try {\n+            assertTrue(values.removeAll(sampleValuesAsList));\n+        } catch (final UnsupportedOperationException e) {\n+            // if values.removeAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test values.retainAll.\n+     */\n+    public void testValuesRetainAll() {\n+        resetFull();\n+        final Collection<V> values = getMap().values();\n+        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        if (!values.equals(sampleValuesAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(values.retainAll(sampleValuesAsList));\n+        } catch (final UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertEquals(sampleValuesAsList.size(), getMap().size());\n+        try {\n+            assertTrue(values.retainAll(Collections.<V> emptySet()));\n+        } catch (final UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verifies that values.iterator.remove changes the underlying map.\n+     */\n+    public void testValuesIteratorRemoveChangesMap() {\n+        resetFull();\n+        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        final Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n+        final Collection<V> values = getMap().values();\n+        for (final Iterator<V> iter = values.iterator(); iter.hasNext();) {\n+            final V value = iter.next();\n+            Integer count = cardinality.get(value);\n+            if (count == null) {\n+                return;\n+            }\n+            try {\n+                iter.remove();\n+                cardinality.put(value, --count);\n+            } catch (final UnsupportedOperationException e) {\n+                // if values.iterator.remove is unsupported, just skip this test\n+                return;\n+            }\n+            final boolean expected = count > 0;\n+            final StringBuilder msg = new StringBuilder(\"Value should \");\n+            msg.append(expected ? \"yet \" : \"no longer \");\n+            msg.append(\"be present in the underlying map\");\n+            assertEquals(msg.toString(), expected, getMap().containsValue(value));\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} set is backed by\n+     * the underlying map by removing from the keySet set\n+     * and testing if the key was removed from the map.\n+     */\n+    public void testKeySetRemoveChangesMap() {\n+        resetFull();\n+        final K[] sampleKeys = getSampleKeys();\n+        final Set<K> keys = getMap().keySet();\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            try {\n+                keys.remove(sampleKeys[i]);\n+            } catch (final UnsupportedOperationException e) {\n+                // if key.remove is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\n+                \"Key should have been removed from the underlying map.\",\n+                !getMap().containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Test keySet.removeAll.\n+     */\n+    public void testKeySetRemoveAll() {\n+        resetFull();\n+        final Set<K> keys = getMap().keySet();\n+        final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(keys.removeAll(Collections.<K> emptySet()));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+            assertTrue(keys.removeAll(sampleKeysAsList));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test keySet.retainAll.\n+     */\n+    public void testKeySetRetainAll() {\n+        resetFull();\n+        final Set<K> keys = getMap().keySet();\n+        final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(keys.retainAll(sampleKeysAsList));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+            assertTrue(keys.retainAll(Collections.<K> emptySet()));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that keySet.iterator.remove changes the underlying map.\n+     */\n+    public void testKeySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (final Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n+            final K key = iter.next();\n+            try {\n+                iter.remove();\n+            } catch (final UnsupportedOperationException e) {\n+                return;\n+            }\n+            assertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet} set is backed by\n+     * the underlying map by removing from the entrySet set\n+     * and testing if the entry was removed from the map.\n+     */\n+    public void testEntrySetRemoveChangesMap() {\n+        resetFull();\n+        final K[] sampleKeys = getSampleKeys();\n+        final V[] sampleValues = getSampleValues();\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            try {\n+                entrySet.remove(new DefaultMapEntry<K, V>(sampleKeys[i], sampleValues[i]));\n+            } catch (final UnsupportedOperationException e) {\n+                // if entrySet removal is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\n+                    \"Entry should have been removed from the underlying map.\",\n+                    !getMap().containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Test entrySet.removeAll.\n+     */\n+    public void testEntrySetRemoveAll() {\n+        resetFull();\n+        final K[] sampleKeys = getSampleKeys();\n+        final V[] sampleValues = getSampleValues();\n+        //verify map looks as expected:\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            if (!getMap().containsKey(sampleKeys[i])) {\n+                return;\n+            }\n+            final V value = sampleValues[i];\n+            final V test = getMap().get(sampleKeys[i]);\n+            if (value == test || value != null && value.equals(test)) {\n+                continue;\n+            }\n+            return;\n+        }\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        try {\n+            assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>> emptySet()));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeys.length, getMap().size());\n+        try {\n+            assertTrue(entrySet.removeAll(comparisonSet));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test entrySet.retainAll.\n+     */\n+    public void testEntrySetRetainAll() {\n+        resetFull();\n+        final K[] sampleKeys = getSampleKeys();\n+        final V[] sampleValues = getSampleValues();\n+        //verify map looks as expected:\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            if (!getMap().containsKey(sampleKeys[i])) {\n+                return;\n+            }\n+            final V value = sampleValues[i];\n+            final V test = getMap().get(sampleKeys[i]);\n+            if (value == test || value != null && value.equals(test)) {\n+                continue;\n+            }\n+            return;\n+        }\n+        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        try {\n+            assertFalse(entrySet.retainAll(comparisonSet));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeys.length, getMap().size());\n+        try {\n+            assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>> emptySet()));\n+        } catch (final UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that entrySet.iterator.remove changes the underlying map.\n+     */\n+    public void testEntrySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (final Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n+            final K key = iter.next().getKey();\n+            try {\n+                iter.remove();\n+            } catch (final UnsupportedOperationException e) {\n+                return;\n+            }\n+            assertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Utility methods to create an array of Map.Entry objects\n+     * out of the given key and value arrays.<P>\n+     *\n+     * @param keys    the array of keys\n+     * @param values  the array of values\n+     * @return an array of Map.Entry of those keys to those values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Map.Entry<K, V>[] makeEntryArray(final K[] keys, final V[] values) {\n+        final Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n+        for (int i = 0; i < keys.length; i++) {\n+            final Map<K, V> map = makeConfirmedMap();\n+            map.put(keys[i], values[i]);\n+            result[i] = map.entrySet().iterator().next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Bulk test {@link Map#entrySet()}.  This method runs through all of\n+     * the tests in {@link AbstractSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing the map's entry set\n+     */\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestMapEntrySet();\n+    }\n+\n+    public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>> {\n+        public TestMapEntrySet() {\n+            super(\"MapEntrySet\");\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Entry<K, V>[] getFullElements() {\n+            return getFullNonNullElements();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Map.Entry<K, V>[] getFullNonNullElements() {\n+            final K[] k = getSampleKeys();\n+            final V[] v = getSampleValues();\n+            return makeEntryArray(k, v);\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        @Override\n+        public Map.Entry<K, V>[] getOtherElements() {\n+            final K[] k = getOtherKeys();\n+            final V[] v = getOtherValues();\n+            return makeEntryArray(k, v);\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> makeObject() {\n+            return AbstractMapTest.this.makeObject().entrySet();\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> makeFullCollection() {\n+            return makeFullMap().entrySet();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            // Collection views don't support add operations.\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            // Entry set should only support remove if map does\n+            return AbstractMapTest.this.isRemoveSupported();\n+        }\n+\n+        public boolean isGetStructuralModify() {\n+            return AbstractMapTest.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMapTest.this.resetFull();\n+            setCollection(AbstractMapTest.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMapTest.this.resetEmpty();\n+            setCollection(AbstractMapTest.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n+        }\n+\n+        public void testMapEntrySetIteratorEntry() {\n+            resetFull();\n+            final Iterator<Map.Entry<K, V>> it = getCollection().iterator();\n+            int count = 0;\n+            while (it.hasNext()) {\n+                final Map.Entry<K, V> entry = it.next();\n+                assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n+                assertEquals(true, AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n+                if (isGetStructuralModify() == false) {\n+                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());\n+                }\n+                count++;\n+            }\n+            assertEquals(getCollection().size(), count);\n+        }\n+\n+        public void testMapEntrySetIteratorEntrySetValue() {\n+            final K key1 = getSampleKeys()[0];\n+            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n+            final V newValue1 = getNewSampleValues()[0];\n+            final V newValue2 = getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n+\n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n+            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestMapEntrySet.this.getCollection().iterator();\n+            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            verify();\n+\n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (final UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n+            verify();\n+\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n+            verify();\n+\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+            assertEquals(newValue2, entry2.getValue());\n+            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue2));\n+            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));\n+            verify();\n+        }\n+\n+        public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {\n+            Map.Entry<K, V> entry = null;\n+            while (itConfirmed.hasNext()) {\n+                final Map.Entry<K, V> temp = itConfirmed.next();\n+                if (temp.getKey() == null) {\n+                    if (key == null) {\n+                        entry = temp;\n+                        break;\n+                    }\n+                } else if (temp.getKey().equals(key)) {\n+                    entry = temp;\n+                    break;\n+                }\n+            }\n+            assertNotNull(\"No matching entry in map for key '\" + key + \"'\", entry);\n+            return entry;\n+        }\n+\n+        public void testMapEntrySetRemoveNonMapEntry() {\n+            if (isRemoveSupported() == false) {\n+                return;\n+            }\n+            resetFull();\n+            assertEquals(false, getCollection().remove(null));\n+            assertEquals(false, getCollection().remove(new Object()));\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractMapTest.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     * Bulk test {@link Map#keySet()}.  This method runs through all of\n+     * the tests in {@link AbstractSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing the map's key set\n+     */\n+    public BulkTest bulkTestMapKeySet() {\n+        return new TestMapKeySet();\n+    }\n+\n+    public class TestMapKeySet extends AbstractSetTest<K> {\n+        public TestMapKeySet() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return getSampleKeys();\n+        }\n+\n+        @Override\n+        public K[] getOtherElements() {\n+            return getOtherKeys();\n+        }\n+\n+        @Override\n+        public Set<K> makeObject() {\n+            return AbstractMapTest.this.makeObject().keySet();\n+        }\n+\n+        @Override\n+        public Set<K> makeFullCollection() {\n+            return AbstractMapTest.this.makeFullMap().keySet();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMapTest.this.resetEmpty();\n+            setCollection(AbstractMapTest.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMapTest.this.resetFull();\n+            setCollection(AbstractMapTest.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractMapTest.this.verify();\n+        }\n+    }\n+\n+    /**\n+     * Bulk test {@link Map#values()}.  This method runs through all of\n+     * the tests in {@link AbstractCollectionTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractCollectionTest} instance for testing the map's\n+     *    values collection\n+     */\n+    public BulkTest bulkTestMapValues() {\n+        return new TestMapValues();\n+    }\n+\n+    public class TestMapValues extends AbstractCollectionTest<V> {\n+        public TestMapValues() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return getSampleValues();\n+        }\n+\n+        @Override\n+        public V[] getOtherElements() {\n+            return getOtherValues();\n+        }\n+\n+        @Override\n+        public Collection<V> makeObject() {\n+            return AbstractMapTest.this.makeObject().values();\n+        }\n+\n+        @Override\n+        public Collection<V> makeFullCollection() {\n+            return AbstractMapTest.this.makeFullMap().values();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean areEqualElementsDistinguishable() {\n+            // equal values are associated with different keys, so they are\n+            // distinguishable.\n+            return true;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMapTest.this.resetFull();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMapTest.this.resetEmpty();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractMapTest.this.verify();\n+        }\n+\n+        // TODO: should test that a remove on the values collection view\n+        // removes the proper mapping and not just any mapping that may have\n+        // the value equal to the value returned from the values iterator.\n+    }\n+\n+\n+    /**\n+     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     * {@link #values} and {@link #confirmed} fields to empty.\n+     */\n+    public void resetEmpty() {\n+        this.map = makeObject();\n+        views();\n+        this.confirmed = makeConfirmedMap();\n+    }\n+\n+    /**\n+     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     * {@link #values} and {@link #confirmed} fields to full.\n+     */\n+    public void resetFull() {\n+        this.map = makeFullMap();\n+        views();\n+        this.confirmed = makeConfirmedMap();\n+        final K[] k = getSampleKeys();\n+        final V[] v = getSampleValues();\n+        for (int i = 0; i < k.length; i++) {\n+            confirmed.put(k[i], v[i]);\n+        }\n+    }\n+\n+    /**\n+     * Resets the collection view fields.\n+     */\n+    private void views() {\n+        this.keySet = getMap().keySet();\n+        // see verifyValues: retrieve the values collection only when verifying them\n+        // this.values = getMap().values();\n+        this.entrySet = getMap().entrySet();\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * This method checks that the map is equal to the HashMap,\n+     * <I>and</I> that the map's collection views are still equal to\n+     * the HashMap's collection views.  An <Code>equals</Code> test\n+     * is done on the maps and their collection views; their size and\n+     * <Code>isEmpty</Code> results are compared; their hashCodes are\n+     * compared; and <Code>containsAll</Code> tests are run on the\n+     * collection views.\n+     */\n+    public void verify() {\n+        verifyMap();\n+        verifyEntrySet();\n+        verifyKeySet();\n+        verifyValues();\n+    }\n+\n+    public void verifyMap() {\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"Map should be same size as HashMap\", size, getMap().size());\n+        assertEquals(\"Map should be empty if HashMap is\", empty, getMap().isEmpty());\n+        assertEquals(\"hashCodes should be the same\", getConfirmed().hashCode(), getMap().hashCode());\n+        // this fails for LRUMap because confirmed.equals() somehow modifies\n+        // map, causing concurrent modification exceptions.\n+        //assertEquals(\"Map should still equal HashMap\", confirmed, map);\n+        // this works though and performs the same verification:\n+        assertTrue(\"Map should still equal HashMap\", getMap().equals(getConfirmed()));\n+        // TODO: this should really be reexamined to figure out why LRU map\n+        // behaves like it does (the equals shouldn't modify since all accesses\n+        // by the confirmed collection should be through an iterator, thus not\n+        // causing LRUMap to change).\n+    }\n+\n+    public void verifyEntrySet() {\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"entrySet should be same size as HashMap's\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     size, entrySet.size());\n+        assertEquals(\"entrySet should be empty if HashMap is\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     empty, entrySet.isEmpty());\n+        assertTrue(\"entrySet should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                   entrySet.containsAll(getConfirmed().entrySet()));\n+        assertEquals(\"entrySet hashCodes should be the same\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     getConfirmed().entrySet().hashCode(), entrySet.hashCode());\n+        assertEquals(\"Map's entry set should still equal HashMap's\",\n+                     getConfirmed().entrySet(), entrySet);\n+    }\n+\n+    public void verifyKeySet() {\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"keySet should be same size as HashMap's\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     size, keySet.size());\n+        assertEquals(\"keySet should be empty if HashMap is\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     empty, keySet.isEmpty());\n+        assertTrue(\"keySet should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                   keySet.containsAll(getConfirmed().keySet()));\n+        assertEquals(\"keySet hashCodes should be the same\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     getConfirmed().keySet().hashCode(), keySet.hashCode());\n+        assertEquals(\"Map's key set should still equal HashMap's\",\n+                getConfirmed().keySet(), keySet);\n+    }\n+\n+    public void verifyValues() {\n+        final List<V> known = new ArrayList<V>(getConfirmed().values());\n+        \n+        // bug in IBM JDK: IBM J9 VM build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067\n+        // a call to values() on an empty map retrieved via TreeMap#headMap or tailMap\n+        // will render the values view unusable: resulting in NullPointExceptions or missing values\n+        // it will also not recover, as the value view is cached internally\n+        values = getMap().values();\n+        \n+        final List<V> test = new ArrayList<V>(values);\n+\n+        final int size = getConfirmed().size();\n+        final boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"values should be same size as HashMap's\" +\n+                     \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                     size, values.size());\n+        assertEquals(\"values should be empty if HashMap is\" +\n+                     \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                     empty, values.isEmpty());\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                    test.containsAll(known));\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                   known.containsAll(test));\n+        // originally coded to use a HashBag, but now separate jar so...\n+        for (final V v : known) {\n+            final boolean removed = test.remove(v);\n+            assertTrue(\"Map's values should still equal HashMap's\", removed);\n+        }\n+        assertTrue(\"Map's values should still equal HashMap's\", test.isEmpty());\n+    }\n+\n+    /**\n+     * Erases any leftover instance variables by setting them to null.\n+     */\n+    @Override\n+    public void tearDown() throws Exception {\n+        map = null;\n+        keySet = null;\n+        entrySet = null;\n+        values = null;\n+        confirmed = null;\n+    }\n+\n+    /**\n+     * Get the map.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getMap() {\n+        return map;\n+    }\n+\n+    /**\n+     * Get the confirmed.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getConfirmed() {\n+        return confirmed;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.OrderedMapIterator;\n+import org.apache.commons.collections4.comparators.NullComparator;\n+import org.apache.commons.collections4.iterators.AbstractOrderedMapIteratorTest;\n+\n+/**\n+ * Abstract test class for {@link OrderedMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractOrderedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractOrderedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract OrderedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        return (OrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * OrderedMap uses TreeMap as its known comparison.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new NullComparator<K>());\n+    }\n+\n+    /**\n+     * The only confirmed collection we have that is ordered is the sorted one.\n+     * Thus, sort the keys.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        final List<K> list = new ArrayList<K>(Arrays.asList(super.getSampleKeys()));\n+        Collections.sort(list, new NullComparator<K>());\n+        return (K[]) list.toArray();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        try {\n+            ordered.firstKey();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        final K confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, ordered.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        try {\n+            ordered.lastKey();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedLast = null;\n+        for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, ordered.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        assertEquals(null, ordered.nextKey(getOtherKeys()[0]));\n+        if (!isAllowNullKey()) {\n+            try {\n+                assertEquals(null, ordered.nextKey(null)); // this is allowed too\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+\n+        resetFull();\n+        ordered = getMap();\n+        final Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            final K confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.nextKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                ordered.nextKey(null);\n+                fail();\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+    }\n+\n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        assertEquals(null, ordered.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, ordered.previousKey(null)); // this is allowed too\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.previousKey(null));\n+        }\n+\n+        resetFull();\n+        ordered = getMap();\n+        final List<K> list = new ArrayList<K>(confirmed.keySet());\n+        Collections.reverse(list);\n+        final Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            final K confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.previousKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                ordered.previousKey(null);\n+                fail();\n+            } catch (final NullPointerException ex) {}\n+        } else {\n+            if (isAllowNullKey() == false) {\n+                assertEquals(null, ordered.previousKey(null));\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestOrderedMapIterator() {\n+        return new InnerTestOrderedMapIterator();\n+    }\n+\n+    public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V> {\n+        public InnerTestOrderedMapIterator() {\n+            super(\"InnerTestOrderedMapIterator\");\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractOrderedMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isGetStructuralModify() {\n+            return AbstractOrderedMapTest.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractOrderedMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public OrderedMapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractOrderedMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public OrderedMapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractOrderedMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public OrderedMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedMapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedMapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractOrderedMapTest.this.verify();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> getMap() {\n+        return (OrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.BulkTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.SortedMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedMapTest<K, V> extends AbstractMapTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractSortedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Can't sort null keys.\n+     *\n+     * @return false\n+     */\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     * SortedMap uses TreeMap as its known comparison.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testComparator() {\n+//        SortedMap<K, V> sm = makeFullMap();\n+        // no tests I can think of\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        return (SortedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    public void testFirstKey() {\n+        final SortedMap<K, V> sm = makeFullMap();\n+        assertSame(sm.keySet().iterator().next(), sm.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        final SortedMap<K, V> sm = makeFullMap();\n+        K obj = null;\n+        for (final Iterator<K> it = sm.keySet().iterator(); it.hasNext();) {\n+            obj = it.next();\n+        }\n+        assertSame(obj, sm.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestHeadMap() {\n+        return new TestHeadMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new TestTailMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new TestSubMap<K, V>(this);\n+    }\n+\n+    public static abstract class TestViewMap <K, V> extends AbstractSortedMapTest<K, V> {\n+        protected final AbstractMapTest<K, V> main;\n+        protected final List<K> subSortedKeys = new ArrayList<K>();\n+        protected final List<V> subSortedValues = new ArrayList<V>();\n+        protected final List<V> subSortedNewValues = new ArrayList<V>();\n+\n+        public TestViewMap(final String name, final AbstractMapTest<K, V> main) {\n+            super(name);\n+            this.main = main;\n+        }\n+        @Override\n+        public void resetEmpty() {\n+            // needed to init verify correctly\n+            main.resetEmpty();\n+            super.resetEmpty();\n+        }\n+        @Override\n+        public void resetFull() {\n+            // needed to init verify correctly\n+            main.resetFull();\n+            super.resetFull();\n+        }\n+        @Override\n+        public void verify() {\n+            // cross verify changes on view with changes on main map\n+            super.verify();\n+            main.verify();\n+        }\n+        @Override\n+        public BulkTest bulkTestHeadMap() {\n+            return null;  // block infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestTailMap() {\n+            return null;  // block infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSubMap() {\n+            return null;  // block infinite recursion\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public K[] getSampleKeys() {\n+            return (K[]) subSortedKeys.toArray();\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getSampleValues() {\n+            return (V[]) subSortedValues.toArray();\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getNewSampleValues() {\n+            return (V[]) subSortedNewValues.toArray();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+//        public void testSimpleSerialization() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testSimpleSerialization();\n+//        }\n+//        public void testSerializeDeserializeThenCompare() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testSerializeDeserializeThenCompare();\n+//        }\n+//        public void testEmptyMapCompatibility() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testEmptyMapCompatibility();\n+//        }\n+//        public void testFullMapCompatibility() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testFullMapCompatibility();\n+//        }\n+    }\n+\n+    public static class TestHeadMap<K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 6;\n+        final K toKey;\n+\n+        public TestHeadMap(final AbstractMapTest<K, V> main) {\n+            super(\"SortedMap.HeadMap\", main);\n+            final Map<K, V> sm = main.makeFullMap();\n+            for (final Entry<K, V> entry : sm.entrySet()) {\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.toKey = this.subSortedKeys.get(SUBSIZE);\n+            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n+            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n+        }\n+        public void testHeadMapOutOfRange() {\n+            if (isPutAddSupported() == false) {\n+                return;\n+            }\n+            resetEmpty();\n+            try {\n+                getMap().put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (final IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".HeadMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj\");\n+//        }\n+    }\n+\n+    public static class TestTailMap <K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 6;\n+        final K fromKey;\n+        final K invalidKey;\n+\n+        public TestTailMap(final AbstractMapTest<K, V> main) {\n+            super(\"SortedMap.TailMap\", main);\n+            final Map<K, V> sm = main.makeFullMap();\n+            for (final Entry<K, V> entry : sm.entrySet()) {\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n+            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n+            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n+        }\n+        public void testTailMapOutOfRange() {\n+            if (isPutAddSupported() == false) {\n+                return;\n+            }\n+            resetEmpty();\n+            try {\n+                getMap().put(invalidKey, subSortedValues.get(0));\n+                fail();\n+            } catch (final IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".TailMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj\");\n+//        }\n+    }\n+\n+    public static class TestSubMap<K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 3;\n+        final K fromKey;\n+        final K toKey;\n+\n+        public TestSubMap(final AbstractMapTest<K, V> main) {\n+            super(\"SortedMap.SubMap\", main);\n+            final Map<K, V> sm = main.makeFullMap();\n+            for (final Entry<K, V> entry : sm.entrySet()) {\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n+            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+\n+            this.subSortedKeys.subList(0, SUBSIZE).clear();\n+            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n+\n+            this.subSortedValues.subList(0, SUBSIZE).clear();\n+            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n+\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n+                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n+        }\n+        public void testSubMapOutOfRange() {\n+            if (isPutAddSupported() == false) {\n+                return;\n+            }\n+            resetEmpty();\n+            try {\n+                getMap().put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (final IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".SubMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj\");\n+//        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getMap() {\n+        return (SortedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getConfirmed() {\n+        return (SortedMap<K, V>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/CaseInsensitiveMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.CaseInsensitiveMap;\n+\n+/**\n+ * Tests for the {@link CaseInsensitiveMap} implementation.\n+ *\n+ * @version $Id$\n+ */\n+public class CaseInsensitiveMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public CaseInsensitiveMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(CaseInsensitiveMapTest.class);\n+    }\n+\n+    @Override\n+    public CaseInsensitiveMap<K, V> makeObject() {\n+        return new CaseInsensitiveMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCaseInsensitive() {\n+        final Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        assertEquals(\"One\", map.get(\"one\"));\n+        assertEquals(\"One\", map.get(\"oNe\"));\n+        map.put((K) \"two\", (V) \"Three\");\n+        assertEquals(\"Three\", map.get(\"Two\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        final Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        map.put(null, (V) \"Three\");\n+        assertEquals(\"Three\", map.get(null));\n+        map.put(null, (V) \"Four\");\n+        assertEquals(\"Four\", map.get(null));\n+        final Set<K> keys = map.keySet();\n+        assertTrue(keys.contains(\"one\"));\n+        assertTrue(keys.contains(\"two\"));\n+        assertTrue(keys.contains(null));\n+        assertEquals(3, keys.size());\n+    }\n+\n+    public void testPutAll() {\n+        final Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(\"One\", \"One\");\n+        map.put(\"Two\", \"Two\");\n+        map.put(\"one\", \"Three\");\n+        map.put(null, \"Four\");\n+        map.put(new Integer(20), \"Five\");\n+        final Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<Object, String>(map);\n+        assertEquals(4, caseInsensitiveMap.size()); // ones collapsed\n+        final Set<Object> keys = caseInsensitiveMap.keySet();\n+        assertTrue(keys.contains(\"one\"));\n+        assertTrue(keys.contains(\"two\"));\n+        assertTrue(keys.contains(null));\n+        assertTrue(keys.contains(Integer.toString(20)));\n+        assertEquals(4, keys.size());\n+        assertTrue(!caseInsensitiveMap.containsValue(\"One\")\n+            || !caseInsensitiveMap.containsValue(\"Three\")); // ones collaped\n+        assertEquals(\"Four\", caseInsensitiveMap.get(null));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        final CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        final CaseInsensitiveMap<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CaseInsensitiveMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CaseInsensitiveMap.fullCollection.version4.obj\");\n+//    }\n+\n+    // COLLECTIONS-294\n+    public void testLocaleIndependence() {\n+        final Locale orig = Locale.getDefault();\n+\n+        final Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\", \"\", \"\"), Locale.getDefault() };\n+\n+        final String[][] data = { \n+            { \"i\", \"I\" },\n+            { \"\\u03C2\", \"\\u03C3\" },\n+            { \"\\u03A3\", \"\\u03C2\" },\n+            { \"\\u03A3\", \"\\u03C3\" },\n+        };\n+\n+        try {\n+            for (final Locale locale : locales) {\n+                Locale.setDefault(locale);\n+                for (int j = 0; j < data.length; j++) {\n+                    assertTrue(\"Test data corrupt: \" + j, data[j][0].equalsIgnoreCase(data[j][1]));\n+                    final CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<String, String>();\n+                    map.put(data[j][0], \"value\");\n+                    assertEquals(Locale.getDefault() + \": \" + j, \"value\", map.get(data[j][1]));\n+                }\n+            }\n+        } finally {\n+            Locale.setDefault(orig);\n+        }\n+    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final CaseInsensitiveMap<String,String> map = new CaseInsensitiveMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.map.CompositeMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link CompositeMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CompositeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+    /** used as a flag in MapMutator tests */\n+    private boolean pass = false;\n+    \n+    public CompositeMapTest(final String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        this.pass = false;\n+    }\n+    \n+    @Override\n+    public CompositeMap<K, V> makeObject() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>();\n+        map.addComposited(new HashMap<K, V>());\n+        map.setMutator( new EmptyMapMutator<K, V>() );\n+        return map;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildOne() {\n+        final HashMap<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"1\", (V) \"one\");\n+        map.put((K) \"2\", (V) \"two\");\n+        return map;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildTwo() {\n+        final HashMap<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"3\", (V) \"three\");\n+        map.put((K) \"4\", (V) \"four\");\n+        return map;\n+    }\n+    \n+    public void testGet() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        assertEquals(\"one\", map.get(\"1\"));\n+        assertEquals(\"four\", map.get(\"4\"));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddComposited() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        try {\n+            map.addComposited(three);\n+            fail(\"Expecting IllegalArgumentException.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(three);\n+        assertFalse(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(buildOne());\n+        assertFalse(map.containsKey(\"2\"));\n+        \n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFromUnderlying() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        three.remove(\"5\");\n+        assertFalse(map.containsKey(\"5\"));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFromComposited() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        final HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        map.remove(\"5\");\n+        assertFalse(three.containsKey(\"5\"));\n+    }\n+    \n+    public void testResolveCollision() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+\n+            public void resolveCollision(final CompositeMap<K, V> composite,\n+            final Map<K, V> existing,\n+            final Map<K, V> added,\n+            final Collection<K> intersect) {\n+                pass = true;\n+            }\n+            \n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+                final V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.addComposited(buildOne());\n+        assertTrue(pass);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+            public void resolveCollision(final CompositeMap<K, V> composite,\n+            final Map<K, V> existing,\n+            final Map<K, V> added,\n+            final Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+                final V value) {\n+                pass = true;\n+                return (V) \"foo\";\n+            }\n+            \n+            public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.put((K) \"willy\", (V) \"wonka\");\n+        assertTrue(pass);\n+    }\n+    \n+    public void testPutAll() {\n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+            public void resolveCollision(final CompositeMap<K, V> composite,\n+            final Map<K, V> existing,\n+            final Map<K, V> added,\n+            final Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+                final V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n+                pass = true;\n+            }\n+        });\n+        \n+        map.putAll(null);\n+        assertTrue(pass);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CompositeMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/CompositeMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/DefaultedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FactoryUtils;\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.functors.ConstantFactory;\n+import org.apache.commons.collections4.map.DefaultedMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link DefaultedMap} implementation.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class DefaultedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();\n+\n+    public DefaultedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet() {\n+        final Map<K, V> map = new DefaultedMap<K, V>((V) \"NULL\");\n+\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet2() {\n+        final HashMap<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet3() {\n+        final HashMap<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet4() {\n+        final HashMap<K, V> base = new HashMap<K, V>();\n+        final Map<K, V> map = DefaultedMap.defaultedMap(base, new Transformer<K, V>() {\n+            public V transform(final K input) {\n+                if (input instanceof String) {\n+                    return (V) \"NULL\";\n+                }\n+                return (V) \"NULL_OBJECT\";\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+        assertEquals(\"NULL_OBJECT\", map.get(new Integer(0)));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+        assertEquals(\"NULL_OBJECT\", map.get(new Integer(0)));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/DefaultedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/DefaultedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Map;\n+import java.util.Collection;\n+\n+import org.apache.commons.collections4.map.CompositeMap;\n+\n+/**\n+ * This class is used in TestCompositeMap. When testing serialization, \n+ * the class has to be separate of TestCompositeMap, else the test \n+ * class also has to be serialized. \n+ */\n+class EmptyMapMutator<K,V> implements CompositeMap.MapMutator<K,V> {\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2729718980002476794L;\n+\n+    public void resolveCollision(final CompositeMap<K,V> composite,\n+    final Map<K,V> existing,\n+    final Map<K,V> added,\n+    final Collection<K> intersect) {\n+        // Do nothing\n+    }\n+    \n+    public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, final V value) {\n+        return composited[0].put(key, value);\n+    }\n+    \n+    public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n+        composited[0].putAll(t);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/FixedSizeMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.map.FixedSizeMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the {@link FixedSizeMap}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedSizeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public FixedSizeMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return FixedSizeMap.fixedSizeMap(new HashMap<K, V>());\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        final Map<K, V> map = new HashMap<K, V>();\n+        addSampleMappings(map);\n+        return FixedSizeMap.fixedSizeMap(map);\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/FixedSizeMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/FixedSizeMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/FixedSizeSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.FixedSizeSortedMap;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the {@link FixedSizeSortedMap}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class FixedSizeSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    public FixedSizeSortedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(FixedSizeSortedMapTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<K, V>());\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        final SortedMap<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/FixedSizeSortedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/FixedSizeSortedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/Flat3MapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.iterators.AbstractMapIteratorTest;\n+import org.apache.commons.collections4.map.Flat3Map;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class Flat3MapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n+    private static final String TEN = \"10\";\n+    private static final String TWENTY = \"20\";\n+    private static final String THIRTY = \"30\";\n+\n+    public Flat3MapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(Flat3MapTest.class);\n+    }\n+\n+    @Override\n+    public Flat3Map<K, V> makeObject() {\n+        return new Flat3Map<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals1() {\n+        final Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        final Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"b\", (V) \"testA\");\n+        assertEquals(false, map1.equals(map2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals2() {\n+        final Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        final Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"c\", (V) \"testA\");\n+        assertEquals(false, map1.equals(map2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone2() {\n+        final Flat3Map<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertSame(TEN, map.get(ONE));\n+        assertSame(TWENTY, map.get(TWO));\n+\n+        // clone works (size = 2)\n+        final Flat3Map<K, V> cloned = map.clone();\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+\n+        // change original doesn't change clone\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+        assertEquals(4, map.size());\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone4() {\n+        final Flat3Map<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n+        // clone works (size = 4)\n+        final Flat3Map<K, V> cloned = map.clone();\n+        assertEquals(4, map.size());\n+        assertEquals(4, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertEquals(true, cloned.containsKey(TEN));\n+        assertEquals(true, cloned.containsKey(TWENTY));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+        assertSame(ONE, cloned.get(TEN));\n+        assertSame(TWO, cloned.get(TWENTY));\n+\n+        // change original doesn't change clone\n+        map.clear();\n+        assertEquals(0, map.size());\n+        assertEquals(4, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertEquals(true, cloned.containsKey(TEN));\n+        assertEquals(true, cloned.containsKey(TWENTY));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+        assertSame(ONE, cloned.get(TEN));\n+        assertSame(TWO, cloned.get(TWENTY));\n+    }\n+\n+    public void testSerialisation0() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        final byte[] bytes = bout.toByteArray();\n+        out.close();\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        final ObjectInputStream in = new ObjectInputStream(bin);\n+        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(0, map.size());\n+        assertEquals(0, ser.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialisation2() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        final byte[] bytes = bout.toByteArray();\n+        out.close();\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        final ObjectInputStream in = new ObjectInputStream(bin);\n+        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(2, map.size());\n+        assertEquals(2, ser.size());\n+        assertEquals(true, ser.containsKey(ONE));\n+        assertEquals(true, ser.containsKey(TWO));\n+        assertEquals(TEN, ser.get(ONE));\n+        assertEquals(TWENTY, ser.get(TWO));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialisation4() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n+        final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        final ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        final byte[] bytes = bout.toByteArray();\n+        out.close();\n+        final ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        final ObjectInputStream in = new ObjectInputStream(bin);\n+        final Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(4, map.size());\n+        assertEquals(4, ser.size());\n+        assertEquals(true, ser.containsKey(ONE));\n+        assertEquals(true, ser.containsKey(TWO));\n+        assertEquals(true, ser.containsKey(TEN));\n+        assertEquals(true, ser.containsKey(TWENTY));\n+        assertEquals(TEN, ser.get(ONE));\n+        assertEquals(TWENTY, ser.get(TWO));\n+        assertEquals(ONE, ser.get(TEN));\n+        assertEquals(TWO, ser.get(TWENTY));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue1() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(\"NewValue\", map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue2() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        final Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(\"NewValue\", map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue3() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        it.next();\n+        final Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(\"NewValue\", map.get(THREE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue1() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(\"NewValue\", map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue2() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(\"NewValue\", map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue3() throws Exception {\n+        final Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        final MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(\"NewValue\", map.get(THREE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public BulkTest bulkTestMapIterator() {\n+        return new TestFlatMapIterator();\n+    }\n+\n+    public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V> {\n+        public TestFlatMapIterator() {\n+            super(\"TestFlatMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return Flat3MapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return Flat3MapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return Flat3MapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return Flat3MapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return Flat3MapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public IterableMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return Flat3MapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return Flat3MapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            Flat3MapTest.this.verify();\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/Flat3Map.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/Flat3Map.fullCollection.version4.obj\");\n+//    }\n+\n+    public void testCollections261() {\n+        final Flat3Map<Integer, Integer> m = new Flat3Map<Integer, Integer>();\n+        m.put( new Integer(1), new Integer(1) );\n+        m.put( new Integer(0), new Integer(0) );\n+        assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n+        assertEquals( new Integer(0), m.remove( new Integer(0) ) ); \n+\n+        m.put( new Integer(2), new Integer(2) );\n+        m.put( new Integer(1), new Integer(1) );\n+        m.put( new Integer(0), new Integer(0) );\n+        assertEquals( new Integer(2), m.remove( new Integer(2) ) ); \n+        assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n+        assertEquals( new Integer(0), m.remove( new Integer(0) ) ); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/HashedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.HashedMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class HashedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public HashedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(HashedMapTest.class);\n+    }\n+\n+    @Override\n+    public HashedMap<K, V> makeObject() {\n+        return new HashedMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        final HashedMap<K, V> map = new HashedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        final HashedMap<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    public void testInternalState() {\n+        final HashedMap<K, V> map = new HashedMap<K, V>(42, 0.75f);\n+        assertEquals(0.75f, map.loadFactor, 0.1f);\n+        assertEquals(0, map.size);\n+        assertEquals(64, map.data.length);\n+        assertEquals(48, map.threshold);\n+        assertEquals(0, map.modCount);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/HashedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/HashedMap.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final HashedMap<String,String> map = new HashedMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/IdentityMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.map.AbstractHashedMap;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+\n+/**\n+ * A <code>Map</code> implementation that matches keys and values based\n+ * on <code>==</code> not <code>equals()</code>.\n+ * <p>\n+ * <strong>This map will violate the detail of various Map and map view contracts.</note>\n+ * As a general rule, don't compare this map to other maps. In particular, you can't\n+ * use decorators like {@link ListOrderedMap} on it, which silently assume that these\n+ * contracts are fulfilled.\n+ * <p>\n+ * <strong>Note that IdentityMap is not synchronized and is not thread-safe.</strong>\n+ * If you wish to use this map from multiple threads concurrently, you must use\n+ * appropriate synchronization. The simplest approach is to wrap this map\n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ * <p>\n+ * From 4.0, this class is replaced by java.util.IdentityHashMap but kept as a\n+ * test-class because it is still used by the ReferenceIdentityMapTest.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class IdentityMap<K, V>\n+        extends AbstractHashedMap<K, V> implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = 2028493495224302329L;\n+\n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public IdentityMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     */\n+    public IdentityMap(final int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor.\n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is negative\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public IdentityMap(final int initialCapacity, final float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public IdentityMap(final Map<K, V> map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hash code for the key specified.\n+     * This implementation uses the identity hash code.\n+     *\n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    @Override\n+    protected int hash(final Object key) {\n+        return System.identityHashCode(key);\n+    }\n+\n+    /**\n+     * Compares two keys for equals.\n+     * This implementation uses <code>==</code>.\n+     *\n+     * @param key1  the first key to compare\n+     * @param key2  the second key to compare\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualKey(final Object key1, final Object key2) {\n+        return key1 == key2;\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses <code>==</code>.\n+     *\n+     * @param value1  the first value to compare\n+     * @param value2  the second value to compare\n+     * @return true if equal by identity\n+     */\n+    @Override\n+    protected boolean isEqualValue(final Object value1, final Object value2) {\n+        return value1 == value2;\n+    }\n+\n+    /**\n+     * Creates an entry to store the data.\n+     * This implementation creates an IdentityEntry instance.\n+     *\n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    @Override\n+    protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n+                                              final K key, final V value) {\n+        return new IdentityEntry<K, V>(next, hashCode, key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * HashEntry\n+     */\n+    protected static class IdentityEntry<K, V> extends HashEntry<K, V> {\n+\n+        protected IdentityEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+            super(next, hashCode, key, value);\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n+            return\n+                getKey() == other.getKey() &&\n+                getValue() == other.getValue();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(getKey()) ^\n+                   System.identityHashCode(getValue());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    @Override\n+    public IdentityMap<K, V> clone() {\n+        return (IdentityMap<K, V>) super.clone();\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/LRUMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.map.LRUMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class LRUMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public LRUMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(LRUMapTest.class);\n+    }\n+\n+    @Override\n+    public LRUMap<K, V> makeObject() {\n+        return new LRUMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> makeFullMap() {\n+        return (LRUMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public boolean isGetStructuralModify() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLRU() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        Iterator<K> kit;\n+        Iterator<V> vit;\n+\n+        final LRUMap<K, V> map = new LRUMap<K, V>(2);\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+\n+        map.put(keys[0], values[0]);\n+        assertEquals(1, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+\n+        map.put(keys[1], values[1]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        map.put(keys[2], values[2]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        map.put(keys[2], values[0]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[0], vit.next());\n+\n+        map.put(keys[1], values[3]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[2], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        final List<K> list = new ArrayList<K>(ordered.keySet());\n+        final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAccessOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        Iterator<K> kit = null;\n+        Iterator<V> vit = null;\n+\n+        resetEmpty();\n+        map.put(keys[0], values[0]);\n+        map.put(keys[1], values[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        // change to order\n+        map.put(keys[0], values[3]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+\n+        // change to order\n+        map.get(keys[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[3], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        // change to order\n+        map.get(keys[0]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+\n+        // no change to order\n+        map.get(keys[0]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        final LRUMap<K, V> map = new LRUMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        final Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRU() {\n+        final MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<K, String>(2);\n+        assertNull(map.entry);\n+        map.put((K) \"A\", \"a\");\n+        assertNull(map.entry);\n+        map.put((K) \"B\", \"b\");\n+        assertNull(map.entry);\n+        map.put((K) \"C\", \"c\");  // removes oldest, which is A=a\n+        assertNotNull(map.entry);\n+        assertEquals(\"A\", map.key);\n+        assertEquals(\"a\", map.value);\n+        assertEquals(\"C\", map.entry.getKey());  // entry is reused\n+        assertEquals(\"c\", map.entry.getValue());  // entry is reused\n+        assertEquals(false, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {\n+        /**\n+         * Generated serial version ID.\n+         */\n+        private static final long serialVersionUID = -2126883654452042477L;\n+        LinkEntry<K, V> entry;\n+        K key;\n+        V value;\n+\n+        MockLRUMapSubclass(final int size) {\n+            super(size);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n+            this.entry = entry;\n+            this.key = entry.getKey();\n+            this.value = entry.getValue();\n+            return true;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUBlocksRemove() {\n+        final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, false);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUBlocksRemoveScan() {\n+        final MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, true);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n+        /**\n+         * Generated serial version ID.\n+         */\n+        private static final long serialVersionUID = 6278917461128992945L;\n+\n+        MockLRUMapSubclassBlocksRemove(final int size, final boolean scanUntilRemove) {\n+            super(size, scanUntilRemove);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUFirstBlocksRemove() {\n+        final MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<K, V>(2);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n+        assertEquals(2, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(false, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n+        /**\n+         * Generated serial version ID.\n+         */\n+        private static final long serialVersionUID = -6939790801702973428L;\n+\n+        MockLRUMapSubclassFirstBlocksRemove(final int size) {\n+            super(size, true);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(final LinkEntry<K, V> entry) {\n+            if (\"a\".equals(entry.getValue())) {\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class SingleHashCode {\n+        private final String code;\n+        SingleHashCode(final String code) {\n+            this.code = code;\n+        }\n+        @Override\n+        public int hashCode() {\n+            // always return the same hashcode\n+            // that way, it will end up in the same bucket\n+            return 12;\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SingleHashCode:\" + code;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_Buckets() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n+        final SingleHashCode one = new SingleHashCode(\"1\");\n+        final SingleHashCode two = new SingleHashCode(\"2\");\n+        final SingleHashCode three = new SingleHashCode(\"3\");\n+        final SingleHashCode four = new SingleHashCode(\"4\");\n+        final SingleHashCode five = new SingleHashCode(\"5\");\n+        final SingleHashCode six = new SingleHashCode(\"6\");\n+\n+        final LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        final int hashIndex = map.hashIndex(map.hash(one), 4);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(one, map.header.after.key);  // LRU\n+        assertEquals(two, map.header.after.after.key);\n+        assertEquals(three, map.header.after.after.after.key);  // MRU\n+        assertEquals(three, map.data[hashIndex].key);\n+        assertEquals(two, map.data[hashIndex].next.key);\n+        assertEquals(one, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) four, (V) \"D\");  // reuses last in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(two, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(four, map.header.after.after.after.key);  // MRU\n+        assertEquals(four, map.data[hashIndex].key);\n+        assertEquals(three, map.data[hashIndex].next.key);\n+        assertEquals(two, map.data[hashIndex].next.next.key);\n+\n+        map.get(three);\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(two, map.header.after.key);  // LRU\n+        assertEquals(four, map.header.after.after.key);\n+        assertEquals(three, map.header.after.after.after.key);  // MRU\n+        assertEquals(four, map.data[hashIndex].key);\n+        assertEquals(three, map.data[hashIndex].next.key);\n+        assertEquals(two, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) five, (V) \"E\");  // reuses last in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(four, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(five, map.header.after.after.after.key);  // MRU\n+        assertEquals(five, map.data[hashIndex].key);\n+        assertEquals(four, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+\n+        map.get(three);\n+        map.get(five);\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(four, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(five, map.header.after.after.after.key);  // MRU\n+        assertEquals(five, map.data[hashIndex].key);\n+        assertEquals(four, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) six, (V) \"F\");  // reuses middle in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(three, map.header.after.key);  // LRU\n+        assertEquals(five, map.header.after.after.key);\n+        assertEquals(six, map.header.after.after.after.key);  // MRU\n+        assertEquals(six, map.data[hashIndex].key);\n+        assertEquals(five, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_getEntry_int() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n+        final SingleHashCode one = new SingleHashCode(\"1\");\n+        final SingleHashCode two = new SingleHashCode(\"2\");\n+        final SingleHashCode three = new SingleHashCode(\"3\");\n+\n+        final LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n+        assertEquals(one, map.getEntry(0).key);\n+        assertEquals(two, map.getEntry(1).key);\n+        assertEquals(three, map.getEntry(2).key);\n+        try {\n+            map.getEntry(-1);\n+            fail();\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            map.getEntry(3);\n+            fail();\n+        } catch (final IndexOutOfBoundsException ex) {}\n+    }\n+    \n+    public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {\n+\n+        final LRUMap<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(final Thread t, final Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        final Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (final MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {\n+                                iter.next();\n+                                if (iter.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (final InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.start();\n+                thread.wait();\n+            }\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (final Thread thread : threads) {\n+            thread.interrupt();\n+        }\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(final Thread t, final Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        final Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (final Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {\n+                                final Map.Entry<Object, Thread> entry = iter.next();\n+                                if (entry.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (final InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.start();\n+                thread.wait();\n+            }\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (final Thread thread : threads) {\n+            thread.interrupt();\n+        }\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromKeySet() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(final Thread t, final Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        final Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (final Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {\n+                                final String name = (String) iter.next();\n+                                if (name.substring(0, name.indexOf('[')).equals(getName())) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (final InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.start();\n+                thread.wait();\n+            }\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (final Thread thread : threads) {\n+            thread.interrupt();\n+        }\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromValues() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(final Thread t, final Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        final Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (final Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {\n+                                if (iter.next() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (final InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.start();\n+                thread.wait();\n+            }\n+        }\n+\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (final Thread thread : threads) {\n+            thread.interrupt();\n+        }\n+        for (final Thread thread : threads) {\n+            synchronized (thread) {\n+                thread.join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LRUMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LRUMap.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> getMap() {\n+        return (LRUMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/LazyMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import static org.apache.commons.collections4.map.LazyMap.lazyMap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FactoryUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.map.LazyMap;\n+import org.junit.Test;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link LazyMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class LazyMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n+\n+    public LazyMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public LazyMap<K,V> makeObject() {\n+        return lazyMap(new HashMap<K,V>(), FactoryUtils.<V>nullFactory());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testMapGet() {\n+        //TODO eliminate need for this via superclass - see svn history.\n+    }\n+\n+    @Test\n+    public void mapGetWithFactory() {\n+        Map<Integer, Number> map = lazyMap(new HashMap<Integer,Number>(), oneFactory);\n+        assertEquals(0, map.size());\n+        final Number i1 = map.get(\"Five\");\n+        assertEquals(1, i1);\n+        assertEquals(1, map.size());\n+        final Number i2 = map.get(new String(new char[] {'F','i','v','e'}));\n+        assertEquals(1, i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+\n+        map = lazyMap(new HashMap<Integer,Number>(), FactoryUtils.<Long>nullFactory());\n+        final Object o = map.get(\"Five\");\n+        assertEquals(null,o);\n+        assertEquals(1, map.size());\n+    }\n+\n+    @Test\n+    public void mapGetWithTransformer() {\n+        final Transformer<Number, Integer> intConverter = new Transformer<Number, Integer>(){\n+            public Integer transform(final Number input) {\n+                return input.intValue();\n+            }\n+        };\n+        final Map<Long, Number> map = lazyMap(new HashMap<Long,Number>(), intConverter );\n+        assertEquals(0, map.size());\n+        final Number i1 = map.get(123L);\n+        assertEquals(123, i1);\n+        assertEquals(1, map.size());\n+    }\n+\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/LazyMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/LazyMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import static org.apache.commons.collections4.map.LazySortedMap.lazySortedMap;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.FactoryUtils;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.map.LazySortedMap;\n+import org.junit.Test;\n+\n+/**\n+ * Extension of {@link LazyMapTest} for exercising the \n+ * {@link LazySortedMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class LazySortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+    \n+    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n+   \n+    public LazySortedMapTest(final String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    public SortedMap<K,V> makeObject() {\n+        return lazySortedMap(new TreeMap<K,V>(), FactoryUtils.<V>nullFactory());\n+    }\n+    \n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TODO TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    // from TestLazyMap\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testMapGet() {\n+        //TODO eliminate need for this via superclass - see svn history.\n+    }\n+    \n+    @Test\n+    public void mapGet() {\n+        Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n+        assertEquals(0, map.size());\n+        final Number i1 = map.get(5);\n+        assertEquals(1, i1);\n+        assertEquals(1, map.size());\n+\n+        map = lazySortedMap(new TreeMap<Integer,Number>(), FactoryUtils.<Number>nullFactory());\n+        final Number o = map.get(5);\n+        assertEquals(null,o);\n+        assertEquals(1, map.size());\n+        \n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSortOrder() {\n+        final SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n+        map.put(\"A\",  5);\n+        map.get(\"B\"); // Entry with value \"One\" created\n+        map.put(\"C\", 8);\n+        assertEquals(\"First key should be A\", \"A\", map.firstKey());\n+        assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n+        assertEquals(\"First key in tail map should be B\", \n+            \"B\", map.tailMap(\"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\", \n+            \"B\", map.headMap(\"C\").lastKey());\n+        assertEquals(\"Last key in submap should be B\",\n+            \"B\", map.subMap(\"A\",\"C\").lastKey());\n+        \n+        final Comparator<?> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", \n+            c == null);      \n+    } \n+    \n+    public void testTransformerDecorate() {\n+        final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n+        SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n+        assertTrue(map instanceof LazySortedMap);  \n+         try {\n+            map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n+            fail(\"Expecting IllegalArgumentException for null transformer\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = lazySortedMap((SortedMap<Integer,Number>) null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        } \n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/LazySortedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/LazySortedMap.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/LinkedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.ResettableIterator;\n+import org.apache.commons.collections4.list.AbstractListTest;\n+import org.apache.commons.collections4.map.LinkedMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class LinkedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public LinkedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(LinkedMapTest.class);\n+    }\n+\n+    @Override\n+    public LinkedMap<K, V> makeObject() {\n+        return new LinkedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> makeFullMap() {\n+        return (LinkedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        final List<K> list = new ArrayList<K>(ordered.keySet());\n+        final ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsertionOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) {\n+            return;\n+        }\n+        final K[] keys = getSampleKeys();\n+        final V[] values = getSampleValues();\n+        Iterator<K> keyIter;\n+        Iterator<V> valueIter;\n+\n+        resetEmpty();\n+        map.put(keys[0], values[0]);\n+        map.put(keys[1], values[1]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[1]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[0], values[3]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[3], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.get(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.get(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(lm.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lm.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.getValue(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.getValue(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(lm.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lm.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        assertEquals(-1, lm.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lm = getMap();\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lm.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.remove(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.remove(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(lm.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            final Object key = list.get(i);\n+            final Object value = lm.get(key);\n+            assertEquals(value, lm.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lm.containsKey(key));\n+        }\n+    }\n+\n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+\n+    public class TestListView extends AbstractListTest<K> {\n+\n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return LinkedMapTest.this.makeObject().asList();\n+        }\n+\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return LinkedMapTest.this.makeFullMap().asList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return LinkedMapTest.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return LinkedMapTest.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        final LinkedMap<K, V> map = new LinkedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        final Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LinkedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/LinkedMap.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> getMap() {\n+        return (LinkedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final LinkedMap<String,String> map = new LinkedMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/ListOrderedMap2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.list.AbstractListTest;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+\n+/**\n+ * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}\n+ * implementation.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class ListOrderedMap2Test<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public ListOrderedMap2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ListOrderedMap2Test.class);\n+    }\n+\n+    @Override\n+    public ListOrderedMap<K, V> makeObject() {\n+        return new ListOrderedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.get(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.get(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.getValue(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.getValue(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lom = getMap();\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.remove(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.remove(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            final Object key = list.get(i);\n+            final Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+\n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+\n+    public class TestListView extends AbstractListTest<K> {\n+\n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return ListOrderedMap2Test.this.makeObject().asList();\n+        }\n+\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return ListOrderedMap2Test.this.makeFullMap().asList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return ListOrderedMap2Test.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return ListOrderedMap2Test.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.list.AbstractListTest;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+\n+/**\n+ * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ListOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public ListOrderedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ListOrderedMapTest.class);\n+    }\n+\n+    @Override\n+    public ListOrderedMap<K, V> makeObject() {\n+        return ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.get(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.get(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.getValue(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.getValue(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lom = getMap();\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.setValue(0, (V) \"\");\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(lom.size(), (V) \"\");\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        for (int i = 0; i < lom.size(); i++) {\n+            final V value = lom.getValue(i);\n+            final Object input = new Integer(i);\n+            assertEquals(value, lom.setValue(i, (V) input));\n+            assertEquals(input, lom.getValue(i));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.remove(0);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.remove(-1);\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        final List<K> list = new ArrayList<K>();\n+        for (final MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            final Object key = list.get(i);\n+            final Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut_intObjectObject() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+\n+        try {\n+            lom.put(1, (K) \"testInsert1\", (V) \"testInsert1v\");\n+            fail(\"should not be able to insert at pos 1 in empty Map\");\n+        } catch (final IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.put(-1, (K) \"testInsert-1\", (V) \"testInsert-1v\");\n+            fail(\"should not be able to insert at pos -1 in empty Map\");\n+        } catch (final IndexOutOfBoundsException ex) {}\n+\n+        // put where key doesn't exist\n+        lom.put(0, (K) \"testInsert1\", (V) \"testInsert1v\");\n+        assertEquals(\"testInsert1v\", lom.getValue(0));\n+\n+        lom.put((K) \"testInsertPut\", (V) \"testInsertPutv\");\n+        assertEquals(\"testInsert1v\", lom.getValue(0));\n+        assertEquals(\"testInsertPutv\", lom.getValue(1));\n+\n+        lom.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsertPutv\", lom.getValue(2));\n+\n+        lom.put(3, (K) \"testInsert3\", (V) \"testInsert3v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsertPutv\", lom.getValue(2));\n+        assertEquals(\"testInsert3v\", lom.getValue(3));\n+\n+        // put in a full map\n+        resetFull();\n+        lom = getMap();\n+        final ListOrderedMap<K, V> lom2 = new ListOrderedMap<K, V>();\n+        lom2.putAll(lom);\n+\n+        lom2.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n+        assertEquals(\"testInsert0v\", lom2.getValue(0));\n+        for (int i = 0; i < lom.size(); i++) {\n+            assertEquals(lom2.getValue(i + 1), lom.getValue(i));\n+        }\n+\n+        // put where key does exist\n+        final Integer i1 = new Integer(1);\n+        final Integer i1b = new Integer(1);\n+        final Integer i2 = new Integer(2);\n+        final Integer i3 = new Integer(3);\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertSame(i1, lom.get(0));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertEquals(\"2\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+        assertSame(i1b, lom.get(0));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(1, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertEquals(\"2\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(2, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"2\", lom.getValue(0));\n+        assertEquals(\"One\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(3, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"2\", lom.getValue(0));\n+        assertEquals(\"3\", lom.getValue(1));\n+        assertEquals(\"One\", lom.getValue(2));\n+    }\n+\n+    public void testPutAllWithIndex() {\n+        resetEmpty();\n+        final ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;\n+\n+        // Create Initial Data\n+        lom.put(\"testInsert0\", \"testInsert0v\");\n+        lom.put(\"testInsert1\", \"testInsert1v\");\n+        lom.put(\"testInsert2\", \"testInsert2v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsert2v\", lom.getValue(2));\n+\n+        // Create New Test Map and Add using putAll(int, Object, Object)\n+        final Map<String, String> values = new ListOrderedMap<String, String>();\n+        values.put(\"NewInsert0\", \"NewInsert0v\");\n+        values.put(\"NewInsert1\", \"NewInsert1v\");\n+        lom.putAll(1, values);\n+\n+        // Perform Asserts\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"NewInsert0v\", lom.getValue(1));\n+        assertEquals(\"NewInsert1v\", lom.getValue(2));\n+        assertEquals(\"testInsert1v\", lom.getValue(3));\n+        assertEquals(\"testInsert2v\", lom.getValue(4));\n+    }\n+\n+    public void testPutAllWithIndexBug441() {\n+        // see COLLECTIONS-441\n+        resetEmpty();\n+        final ListOrderedMap<K, V> lom = getMap();\n+\n+        final int size = 5;\n+        for (int i = 0; i < size; i++) {\n+            lom.put((K) Integer.valueOf(i), (V) Boolean.valueOf(true));\n+        }\n+\n+        final Map<K, V> map = new TreeMap<K, V>();\n+        for (int i = 0; i < size; i++) {\n+            map.put((K) Integer.valueOf(i), (V) Boolean.valueOf(false));\n+        }\n+\n+        lom.putAll(3, map);\n+        \n+        final List<K> orderedList = lom.asList();\n+        for (int i = 0; i < size; i++) {\n+            assertEquals(i, orderedList.get(i));\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testValueList_getByIndex() {\n+        resetFull();\n+        final ListOrderedMap<K, V> lom = getMap();\n+        for (int i = 0; i < lom.size(); i++) {\n+            final V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().get(i));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueList_setByIndex() {\n+        resetFull();\n+        final ListOrderedMap<K, V> lom = getMap();\n+        for (int i = 0; i < lom.size(); i++) {\n+            final Object input = new Integer(i);\n+            final V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().set(i, (V) input));\n+            assertEquals(input, lom.getValue(i));\n+            assertEquals(input, lom.valueList().get(i));\n+        }\n+    }\n+\n+    public void testValueList_removeByIndex() {\n+        resetFull();\n+        final ListOrderedMap<K, V> lom = getMap();\n+        while (lom.size() > 1) {\n+            final V expected = lom.getValue(1);\n+            assertEquals(expected, lom.valueList().remove(1));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestKeyListView() {\n+        return new TestKeyListView();\n+    }\n+\n+    public BulkTest bulkTestValueListView() {\n+        return new TestValueListView();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public class TestKeyListView extends AbstractListTest<K> {\n+        TestKeyListView() {\n+            super(\"TestKeyListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return ListOrderedMapTest.this.makeObject().keyList();\n+        }\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return ListOrderedMapTest.this.makeFullMap().keyList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return ListOrderedMapTest.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return ListOrderedMapTest.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public class TestValueListView extends AbstractListTest<V> {\n+        TestValueListView() {\n+            super(\"TestValueListView\");\n+        }\n+\n+        @Override\n+        public List<V> makeObject() {\n+            return ListOrderedMapTest.this.makeObject().valueList();\n+        }\n+        @Override\n+        public List<V> makeFullCollection() {\n+            return ListOrderedMapTest.this.makeFullMap().valueList();\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return ListOrderedMapTest.this.getSampleValues();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return true;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return true;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return ListOrderedMapTest.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/ListOrderedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/ListOrderedMap.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/MultiKeyMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.keyvalue.MultiKey;\n+import org.apache.commons.collections4.map.LRUMap;\n+import org.apache.commons.collections4.map.MultiKeyMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class MultiKeyMapTest<K, V> extends AbstractIterableMapTest<MultiKey<? extends K>, V> {\n+\n+    static final Integer I1 = new Integer(1);\n+    static final Integer I2 = new Integer(2);\n+    static final Integer I3 = new Integer(3);\n+    static final Integer I4 = new Integer(4);\n+    static final Integer I5 = new Integer(5);\n+    static final Integer I6 = new Integer(6);\n+    static final Integer I7 = new Integer(7);\n+    static final Integer I8 = new Integer(8);\n+\n+    public MultiKeyMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(MultiKeyMapTest.class);\n+    }\n+\n+    @Override\n+    public MultiKeyMap<K, V> makeObject() {\n+        return new MultiKeyMap<K, V>();\n+    }\n+\n+    @Override\n+    public MultiKey<K>[] getSampleKeys() {\n+        return getMultiKeyKeys();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiKey<K>[] getMultiKeyKeys() {\n+        return new MultiKey[] {\n+            new MultiKey<Integer>(I1, I2),\n+            new MultiKey<Integer>(I2, I3),\n+            new MultiKey<Integer>(I3, I4),\n+            new MultiKey<Integer>(I1, I1, I2),\n+            new MultiKey<Integer>(I2, I3, I4),\n+            new MultiKey<Integer>(I3, I7, I6),\n+            new MultiKey<Integer>(I1, I1, I2, I3),\n+            new MultiKey<Integer>(I2, I4, I5, I6),\n+            new MultiKey<Integer>(I3, I6, I7, I8),\n+            new MultiKey<Integer>(I1, I1, I2, I3, I4),\n+            new MultiKey<Integer>(I2, I3, I4, I5, I6),\n+            new MultiKey<Integer>(I3, I5, I6, I7, I8),\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] {\n+            \"2A\", \"2B\", \"2C\",\n+            \"3D\", \"3E\", \"3F\",\n+            \"4G\", \"4H\", \"4I\",\n+            \"5J\", \"5K\", \"5L\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] {\n+            \"1a\", \"1b\", \"1c\",\n+            \"2d\", \"2e\", \"2f\",\n+            \"3g\", \"3h\", \"3i\",\n+            \"4j\", \"4k\", \"4l\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey<K>[] getOtherKeys() {\n+        return new MultiKey[] {\n+            new MultiKey<Integer>(I1, I7),\n+            new MultiKey<Integer>(I1, I8),\n+            new MultiKey<Integer>(I2, I4),\n+            new MultiKey<Integer>(I2, I5),\n+        };\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+        assertEquals(null, map.put(new MultiKey<K>(null, null), null));\n+        try {\n+            map.put(null, (V) new Object());\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMultiKeyGet() {\n+        resetFull();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+        final V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            final MultiKey<K> key = keys[i];\n+            final V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(null, multimap.get(null, key.getKey(1)));\n+                assertEquals(null, multimap.get(key.getKey(0), null));\n+                assertEquals(null, multimap.get(null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(null, null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(null, multimap.get(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyContainsKey() {\n+        resetFull();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+\n+        for (final MultiKey<K> key : keys) {\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null));\n+                assertEquals(false, multimap.containsKey(null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyPut() {\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+        final V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            final MultiKeyMap<K, V> multimap = new MultiKeyMap<K, V>();\n+\n+            final MultiKey<K> key = keys[i];\n+            final V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyRemove() {\n+        final MultiKey<K>[] keys = getMultiKeyKeys();\n+        final V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            resetFull();\n+            final MultiKeyMap<K, V> multimap = getMap();\n+            final int size = multimap.size();\n+\n+            final MultiKey<K> key = keys[i];\n+            final V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll1() {\n+        resetFull();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1);\n+        assertEquals(8, multimap.size());\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll2() {\n+        resetFull();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I2, I3);\n+        assertEquals(9, multimap.size());\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll3() {\n+        resetFull();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1, I1, I2);\n+        assertEquals(9, multimap.size());\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll4() {\n+        resetFull();\n+        final MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1, I1, I2, I3);\n+        assertEquals(10, multimap.size());\n+        for (final MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            final MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        final MultiKeyMap<K, V> map = new MultiKeyMap<K, V>();\n+        map.put(new MultiKey<K>((K) I1, (K) I2), (V) \"1-2\");\n+        final Map<MultiKey<? extends K>, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(new MultiKey<K>((K) I1, (K) I2)), cloned.get(new MultiKey<K>((K) I1, (K) I2)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLRUMultiKeyMap() {\n+        final MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));\n+        map.put((K) I1, (K) I2, (V) \"1-2\");\n+        map.put((K) I1, (K) I3, (V) \"1-1\");\n+        assertEquals(2, map.size());\n+        map.put((K) I1, (K) I4, (V) \"1-4\");\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(I1, I3));\n+        assertEquals(true, map.containsKey(I1, I4));\n+        assertEquals(false, map.containsKey(I1, I2));\n+\n+        final MultiKeyMap<K, V> cloned = map.clone();\n+        assertEquals(2, map.size());\n+        assertEquals(true, cloned.containsKey(I1, I3));\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(false, cloned.containsKey(I1, I2));\n+        cloned.put((K) I1, (K) I5, (V) \"1-5\");\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(true, cloned.containsKey(I1, I5));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/MultiKeyMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/MultiKeyMap.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public MultiKeyMap<K, V> getMap() {\n+        return (MultiKeyMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/MultiValueMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+import org.apache.commons.collections4.IteratorUtils;\n+import org.apache.commons.collections4.MultiMap;\n+import org.apache.commons.collections4.map.MultiValueMap;\n+\n+/**\n+ * TestMultiValueMap.\n+ *\n+ * @since 3.2\n+ * @version $Id$\n+ */\n+public class MultiValueMapTest<K, V> extends AbstractObjectTest {\n+\n+    public MultiValueMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public void testNoMappingReturnsNull() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        assertNull(map.get(\"whatever\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueCollectionType() {\n+        final MultiValueMap<K, V> map = createTestMap(LinkedList.class);\n+        assertTrue(map.get(\"one\") instanceof LinkedList);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMultipleValues() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"un\");\n+        assertEquals(expected, map.get(\"one\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue(\"uno\"));\n+        assertTrue(map.containsValue(\"un\"));\n+        assertTrue(map.containsValue(\"dos\"));\n+        assertTrue(map.containsValue(\"deux\"));\n+        assertTrue(map.containsValue(\"tres\"));\n+        assertTrue(map.containsValue(\"trois\"));\n+        assertFalse(map.containsValue(\"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testKeyContainsValue() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue(\"one\", \"uno\"));\n+        assertTrue(map.containsValue(\"one\", \"un\"));\n+        assertTrue(map.containsValue(\"two\", \"dos\"));\n+        assertTrue(map.containsValue(\"two\", \"deux\"));\n+        assertTrue(map.containsValue(\"three\", \"tres\"));\n+        assertTrue(map.containsValue(\"three\", \"trois\"));\n+        assertFalse(map.containsValue(\"four\", \"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValues() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"dos\");\n+        expected.add((V) \"tres\");\n+        expected.add((V) \"un\");\n+        expected.add((V) \"deux\");\n+        expected.add((V) \"trois\");\n+        final Collection<Object> c = map.values();\n+        assertEquals(6, c.size());\n+        assertEquals(expected, new HashSet<Object>(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiValueMap<K, V> createTestMap() {\n+        return createTestMap(ArrayList.class);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(final Class<C> collectionClass) {\n+        final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);\n+        map.put((K) \"one\", (V) \"uno\");\n+        map.put((K) \"one\", (V) \"un\");\n+        map.put((K) \"two\", (V) \"dos\");\n+        map.put((K) \"two\", (V) \"deux\");\n+        map.put((K) \"three\", (V) \"tres\");\n+        map.put((K) \"three\", (V) \"trois\");\n+        return map;\n+    }\n+\n+    public void testKeyedIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator(\"one\")));\n+        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList(new String[]{ \"uno\", \"un\" }));\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testRemoveAllViaIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    public void testRemoveAllViaKeyedIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        for (final Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertEquals(4, map.totalSize());\n+    }\n+\n+    public void testTotalSizeA() {\n+        assertEquals(6, createTestMap().totalSize());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapEquals() {\n+        final MultiValueMap<K, V> one = new MultiValueMap<K, V>();\n+        final Integer value = new Integer(1);\n+        one.put((K) \"One\", value);\n+        one.remove(\"One\", value);\n+\n+        final MultiValueMap<K, V> two = new MultiValueMap<K, V>();\n+        assertEquals(two, one);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGetCollection() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        map.put((K) \"A\", \"AA\");\n+        assertSame(map.get(\"A\"), map.getCollection(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTotalSize() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.totalSize());\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.totalSize());\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(2, map.totalSize());\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(3, map.totalSize());\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(4, map.totalSize());\n+        map.remove(\"A\");\n+        assertEquals(3, map.totalSize());\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(2, map.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(2, map.size());\n+        map.remove(\"A\");\n+        assertEquals(1, map.size());\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(1, map.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize_Key() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(0, map.size(\"B\"));\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(0, map.size(\"B\"));\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(1, map.size(\"B\"));\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(2, map.size(\"B\"));\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(3, map.size(\"B\"));\n+        map.remove(\"A\");\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(3, map.size(\"B\"));\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(2, map.size(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator_Key() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(false, map.iterator(\"A\").hasNext());\n+        map.put((K) \"A\", \"AA\");\n+        final Iterator<?> it = map.iterator(\"A\");\n+        assertEquals(true, it.hasNext());\n+        it.next();\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue_Key() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(false, map.containsValue(\"A\", \"AA\"));\n+        assertEquals(false, map.containsValue(\"B\", \"BB\"));\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(true, map.containsValue(\"A\", \"AA\"));\n+        assertEquals(false, map.containsValue(\"A\", \"AB\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithList() {\n+        final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);\n+        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n+        assertEquals(1, test.size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithSet() {\n+        final MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);\n+        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n+        assertEquals(null, test.put((K) \"A\", \"a\"));\n+        assertEquals(1, test.size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map1() {\n+        final MultiMap<K, V> original = new MultiValueMap<K, V>();\n+        original.put((K) \"key\", \"object1\");\n+        original.put((K) \"key\", \"object2\");\n+\n+        final MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        test.put((K) \"keyA\", \"objectA\");\n+        test.put((K) \"key\", \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(2, test.size());\n+        assertEquals(4, test.totalSize());\n+        assertEquals(1, test.getCollection(\"keyA\").size());\n+        assertEquals(3, test.getCollection(\"key\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map2() {\n+        final Map<K, V> original = new HashMap<K, V>();\n+        original.put((K) \"keyX\", (V) \"object1\");\n+        original.put((K) \"keyY\", (V) \"object2\");\n+\n+        final MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        test.put((K) \"keyA\", \"objectA\");\n+        test.put((K) \"keyX\", \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(3, test.size());\n+        assertEquals(4, test.totalSize());\n+        assertEquals(1, test.getCollection(\"keyA\").size());\n+        assertEquals(2, test.getCollection(\"keyX\").size());\n+        assertEquals(1, test.getCollection(\"keyY\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_KeyCollection() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        Collection<V> coll = (Collection<V>) Arrays.asList(new Object[] { \"X\", \"Y\", \"Z\" });\n+\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", null));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", new ArrayList<V>()));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        coll = (Collection<V>) Arrays.asList(new Object[] { \"M\" });\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(4, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+        assertEquals(true, map.containsValue(\"A\", \"M\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove_KeyItem() {\n+        final MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        map.put((K) \"A\", \"AA\");\n+        map.put((K) \"A\", \"AB\");\n+        map.put((K) \"A\", \"AC\");\n+        assertEquals(null, map.remove(\"C\", \"CA\"));\n+        assertEquals(null, map.remove(\"A\", \"AD\"));\n+        assertEquals(\"AC\", map.remove(\"A\", \"AC\"));\n+        assertEquals(\"AB\", map.remove(\"A\", \"AB\"));\n+        assertEquals(\"AA\", map.remove(\"A\", \"AA\"));\n+        assertEquals(new MultiValueMap<K, V>(), map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Manual serialization testing as this class cannot easily \n+    // extend the AbstractTestMap\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    @Override\n+    public Object makeObject() {\n+        final Map m = makeEmptyMap();\n+        m.put(\"a\", \"1\");\n+        m.put(\"a\", \"1b\");\n+        m.put(\"b\", \"2\");\n+        m.put(\"c\", \"3\");\n+        m.put(\"c\", \"3b\");\n+        m.put(\"d\", \"4\");\n+        return m;\n+    }\n+\n+    private Map makeEmptyMap() {\n+        return new MultiValueMap();\n+    }\n+\n+    public void testEmptyMapCompatibility() throws Exception {\n+        final Map<?,?> map = makeEmptyMap();\n+        final Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+        assertEquals(\"Map is empty\", 0, map2.size());\n+    }\n+    public void testFullMapCompatibility() throws Exception {\n+        final Map<?,?> map = (Map<?,?>) makeObject();\n+        final Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        assertEquals(\"Map is the right size\", map.size(), map2.size());\n+        for (final Object key : map.keySet()) {\n+            assertEquals( \"Map had inequal elements\", map.get(key), map2.get(key) );\n+            map2.remove(key);\n+        }\n+        assertEquals(\"Map had extra values\", 0, map2.size());\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) makeEmptyMap(),\n+//            \"src/test/resources/data/test/MultiValueMap.emptyCollection.version4.obj\");\n+//\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) makeObject(),\n+//            \"src/test/resources/data/test/MultiValueMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.PassiveExpiringMap;\n+import org.apache.commons.collections4.map.PassiveExpiringMap.ExpirationPolicy;\n+\n+public class PassiveExpiringMapTest<K, V>\n+    extends AbstractMapTest<K, V> {\n+\n+    private static class TestExpirationPolicy\n+        implements ExpirationPolicy<Integer, String> {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        public long expirationTime(final Integer key, final String value) {\n+            // odd keys expire immediately, even keys never expire\n+            if (key == null) {\n+                return 0;\n+            }\n+\n+            if (key.intValue() % 2 == 0) {\n+                return -1;\n+            }\n+\n+            return 0;\n+        }\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(PassiveExpiringMapTest.class);\n+    }\n+\n+    public PassiveExpiringMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+//                \"src/test/resources/data/test/PassiveExpiringMap.emptyCollection.version4.obj\");\n+//    \n+//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+//                \"src/test/resources/data/test/PassiveExpiringMap.fullCollection.version4.obj\");\n+//    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    private Map<Integer, String> makeDecoratedTestMap() {\n+        final Map<Integer, String> m = new HashMap<Integer, String>();\n+        m.put(Integer.valueOf(1), \"one\");\n+        m.put(Integer.valueOf(2), \"two\");\n+        m.put(Integer.valueOf(3), \"three\");\n+        m.put(Integer.valueOf(4), \"four\");\n+        m.put(Integer.valueOf(5), \"five\");\n+        m.put(Integer.valueOf(6), \"six\");\n+        return new PassiveExpiringMap<Integer, String>(\n+                                                       new TestExpirationPolicy(),\n+                                                       m);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeObject() {\n+        return new PassiveExpiringMap<K, V>();\n+    }\n+\n+    private Map<Integer, String> makeTestMap() {\n+        final Map<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n+                                                                         new TestExpirationPolicy());\n+        m.put(Integer.valueOf(1), \"one\");\n+        m.put(Integer.valueOf(2), \"two\");\n+        m.put(Integer.valueOf(3), \"three\");\n+        m.put(Integer.valueOf(4), \"four\");\n+        m.put(Integer.valueOf(5), \"five\");\n+        m.put(Integer.valueOf(6), \"six\");\n+        return m;\n+    }\n+\n+    public void testConstructors() {\n+        try {\n+            final Map<String, String> map = null;\n+            new PassiveExpiringMap<String, String>(map);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        try {\n+            final ExpirationPolicy<String, String> policy = null;\n+            new PassiveExpiringMap<String, String>(policy);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        try {\n+            final TimeUnit unit = null;\n+            new PassiveExpiringMap<String, String>(10L, unit);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (final IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testContainsKey() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.containsKey(Integer.valueOf(1)));\n+        assertFalse(m.containsKey(Integer.valueOf(3)));\n+        assertFalse(m.containsKey(Integer.valueOf(5)));\n+        assertTrue(m.containsKey(Integer.valueOf(2)));\n+        assertTrue(m.containsKey(Integer.valueOf(4)));\n+        assertTrue(m.containsKey(Integer.valueOf(6)));\n+    }\n+\n+    public void testContainsValue() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.containsValue(\"one\"));\n+        assertFalse(m.containsValue(\"three\"));\n+        assertFalse(m.containsValue(\"five\"));\n+        assertTrue(m.containsValue(\"two\"));\n+        assertTrue(m.containsValue(\"four\"));\n+        assertTrue(m.containsValue(\"six\"));\n+    }\n+\n+    public void testDecoratedMap() {\n+        // entries shouldn't expire\n+        final Map<Integer, String> m = makeDecoratedTestMap();\n+        assertEquals(6, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+\n+        // removing a single item shouldn't affect any other items\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+        m.remove(Integer.valueOf(2));\n+        assertEquals(5, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+        assertNull(m.get(Integer.valueOf(2)));\n+\n+        // adding a single, even item shouldn't affect any other items\n+        assertNull(m.get(Integer.valueOf(2)));\n+        m.put(Integer.valueOf(2), \"two\");\n+        assertEquals(6, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\n+        // adding a single, odd item (one that expires) shouldn't affect any\n+        // other items\n+        // put the entry expires immediately\n+        m.put(Integer.valueOf(1), \"one-one\");\n+        assertEquals(5, m.size());\n+        assertNull(m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+    }\n+\n+    public void testEntrySet() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.entrySet().size());\n+    }\n+\n+    public void testGet() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertNull(m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+        assertNull(m.get(Integer.valueOf(3)));\n+        assertEquals(\"four\", m.get(Integer.valueOf(4)));\n+        assertNull(m.get(Integer.valueOf(5)));\n+        assertEquals(\"six\", m.get(Integer.valueOf(6)));\n+    }\n+\n+    public void testIsEmpty() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.isEmpty());\n+\n+        // remove just evens\n+        m = makeTestMap();\n+        m.remove(Integer.valueOf(2));\n+        m.remove(Integer.valueOf(4));\n+        m.remove(Integer.valueOf(6));\n+        assertTrue(m.isEmpty());\n+    }\n+\n+    public void testKeySet() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.keySet().size());\n+    }\n+\n+    public void testSize() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.size());\n+    }\n+\n+    public void testValues() {\n+        final Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.values().size());\n+    }\n+\n+    public void testZeroTimeToLive() {\n+        // item should not be available\n+        final PassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n+                                                                                      0L);\n+        m.put(\"a\", \"b\");\n+        assertNull(m.get(\"a\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/PredicatedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+import org.apache.commons.collections4.map.PredicatedMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link PredicatedMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n+        public boolean evaluate(final Object o) {\n+            return o instanceof String;\n+        }\n+    };\n+\n+    public PredicatedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected IterableMap<K, V> decorateMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n+        final Predicate<? super V> valuePredicate) {\n+        return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return decorateMap(new HashMap<K, V>(), truePredicate, truePredicate);\n+    }\n+\n+    public IterableMap<K, V> makeTestMap() {\n+        return decorateMap(new HashMap<K, V>(), testPredicate, testPredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySet() {\n+        Map<K, V> map = makeTestMap();\n+        assertTrue(\"returned entryset should not be null\",\n+            map.entrySet() != null);\n+        map = decorateMap(new HashMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n+        assertTrue(\"returned entryset should contain one entry\",\n+            map.entrySet().size() == 1);\n+        map = decorateMap(map, null, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        final Map<K, V> map = makeTestMap();\n+        try {\n+            map.put((K) \"Hi\", (V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put((K) new Integer(3), (V) \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        final Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n+        try {\n+            final Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"F\", (V) \"f\");\n+        iterator = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/PredicatedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/PredicatedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/PredicatedSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+import org.apache.commons.collections4.map.PredicatedSortedMap;\n+\n+/**\n+ * Extension of {@link PredicatedMapTest} for exercising the\n+ * {@link PredicatedSortedMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n+        public boolean evaluate(final Object o) {\n+            return o instanceof String;\n+        }\n+    };\n+\n+    public PredicatedSortedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected SortedMap<K, V> decorateMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n+        final Predicate<? super V> valuePredicate) {\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return decorateMap(new TreeMap<K, V>(), truePredicate, truePredicate);\n+    }\n+\n+    public SortedMap<K, V> makeTestMap() {\n+        return decorateMap(new TreeMap<K, V>(), testPredicate, testPredicate);\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    // from TestPredicatedMap\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySet() {\n+        SortedMap<K, V> map = makeTestMap();\n+        assertTrue(\"returned entryset should not be null\",\n+            map.entrySet() != null);\n+        map = decorateMap(new TreeMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n+        assertTrue(\"returned entryset should contain one entry\",\n+            map.entrySet().size() == 1);\n+        map = decorateMap(map, null, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        final Map<K, V> map = makeTestMap();\n+        try {\n+            map.put((K) \"Hi\", (V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put((K) new Integer(3), (V) \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        final Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n+        try {\n+            final Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"F\", (V) \"f\");\n+        iterator = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSortOrder() {\n+        final SortedMap<K, V> map = makeTestMap();\n+        map.put((K) \"A\",  (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        try {\n+            map.put(null, (V) \"c\");\n+            fail(\"Null key should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        map.put((K) \"C\", (V) \"c\");\n+        try {\n+            map.put((K) \"D\", null);\n+            fail(\"Null value should raise IllegalArgument\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertEquals(\"First key should be A\", \"A\", map.firstKey());\n+        assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n+        assertEquals(\"First key in tail map should be B\",\n+            \"B\", map.tailMap((K) \"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\",\n+            \"B\", map.headMap((K) \"C\").lastKey());\n+        assertEquals(\"Last key in submap should be B\",\n+           \"B\", map.subMap((K) \"A\",(K) \"C\").lastKey());\n+\n+        final Comparator<? super K> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\",\n+            c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/PredicatedSortedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/PredicatedSortedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/ReferenceIdentityMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.map.ReferenceIdentityMap;\n+import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;\n+\n+/**\n+ * Tests for ReferenceIdentityMap.\n+ *\n+ * @version $Id$\n+ */\n+public class ReferenceIdentityMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    private static final Integer I1A = new Integer(1);\n+    private static final Integer I1B = new Integer(1);\n+    private static final Integer I2A = new Integer(2);\n+    private static final Integer I2B = new Integer(2);\n+\n+    public ReferenceIdentityMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ReferenceIdentityMapTest.class);\n+    }\n+\n+    @Override\n+    public ReferenceIdentityMap<K, V> makeObject() {\n+        return new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        // Testing against another [collections] class generally isn't a good idea,\n+        // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.\n+        // arguably ReferenceIdentityMap should do the same but that's a later discussion.\n+        return new IdentityMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/ReferenceIdentityMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/ReferenceIdentityMap.fullCollection.version4.obj\");\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasics() {\n+        final IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+        assertEquals(0, map.size());\n+\n+        map.put((K) I1A, (V) I2A);\n+        assertEquals(1, map.size());\n+        assertSame(I2A, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(true, map.containsValue(I2A));\n+        assertEquals(false, map.containsValue(I2B));\n+\n+        map.put((K) I1A, (V) I2B);\n+        assertEquals(1, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+\n+        map.put((K) I1B, (V) I2B);\n+        assertEquals(2, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(I2B, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(true, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashEntry() {\n+        final IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        final Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        final Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        final Map.Entry<K, V> entry2 = it.next();\n+        final Map.Entry<K, V> entry3 = it.next();\n+\n+        assertEquals(true, entry1.equals(entry2));\n+        assertEquals(true, entry2.equals(entry1));\n+        assertEquals(false, entry1.equals(entry3));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, getMap().get(null));\n+        assertEquals(false, getMap().containsKey(null));\n+        assertEquals(false, getMap().containsValue(null));\n+        assertEquals(null, getMap().remove(null));\n+        assertEquals(false, getMap().entrySet().contains(null));\n+        assertEquals(false, getMap().keySet().contains(null));\n+        assertEquals(false, getMap().values().contains(null));\n+        try {\n+            getMap().put(null, null);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+        try {\n+            getMap().put((K) new Object(), null);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+        try {\n+            getMap().put(null, (V) new Object());\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+/*\n+    // Tests often fail because gc is uncontrollable\n+\n+    public void testPurge() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildRefMap() {\n+        final K key = (K) new Object();\n+        final V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        final Map<K, V> testMap = new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        testMap.put(key, value);\n+\n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        return testMap;\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        final Map<K, V> testMap = buildRefMap();\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while (true) {\n+            System.gc();\n+            if (iterations++ > 50) {\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if (\n+                keyReference.get() == null &&\n+                valueReference.get() == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                @SuppressWarnings(\"unused\")\n+                final byte[] b =  new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void gc() {\n+        try {\n+            // trigger GC\n+            final byte[][] tooLarge = new byte[1000000000][1000000000];\n+            fail(\"you have too much RAM\");\n+        } catch (final OutOfMemoryError ex) {\n+            System.gc(); // ignore\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.ReferenceMap;\n+import org.apache.commons.collections4.map.AbstractReferenceMap.ReferenceStrength;\n+\n+/**\n+ * Tests for ReferenceMap.\n+ *\n+ * @version $Id$\n+ */\n+public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public ReferenceMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ReferenceMapTest.class);\n+    }\n+\n+    @Override\n+    public ReferenceMap<K, V> makeObject() {\n+        return new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/ReferenceMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/ReferenceMap.fullCollection.version4.obj\");\n+//    }\n+    \n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+        try {\n+            map.put((K) new Object(), null);\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+        try {\n+            map.put(null, (V) new Object());\n+            fail();\n+        } catch (final NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+/*\n+    // Tests often fail because gc is uncontrollable\n+\n+    public void testPurge() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildRefMap() {\n+        final K key = (K) new Object();\n+        final V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        final Map<K, V> testMap = new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        testMap.put(key, value);\n+\n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        return testMap;\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        final Map<K, V> testMap = buildRefMap();\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while (true) {\n+            System.gc();\n+            if (iterations++ > 50) {\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if (keyReference.get() == null && valueReference.get() == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                @SuppressWarnings(\"unused\")\n+                final byte[] b = new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void gc() {\n+        try {\n+            // trigger GC\n+            final byte[][] tooLarge = new byte[1000000000][1000000000];\n+            fail(\"you have too much RAM\");\n+        } catch (final OutOfMemoryError ex) {\n+            System.gc(); // ignore\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/SingletonMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections4.BoundedMap;\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.KeyValue;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+import org.apache.commons.collections4.map.SingletonMap;\n+import org.apache.commons.collections4.map.UnmodifiableOrderedMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class SingletonMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final String TEN = \"10\";\n+\n+    public SingletonMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(SingletonMapTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMap<K, V> makeObject() {\n+        // need an empty singleton map, but thats not possible\n+        // use a ridiculous fake instead to make the tests pass\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        // the ridiculous map above still doesn't pass these tests\n+        // but its not relevant, so we ignore them\n+        return new String[] {\n+            \"SingletonMapTest.bulkTestMapIterator.testEmptyMapIterator\",\n+            \"SingletonMapTest.bulkTestOrderedMapIterator.testEmptyMapIterator\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> makeFullMap() {\n+        return new SingletonMap<K, V>((K) ONE, (V) TWO);\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        return (K[]) new Object[] { ONE };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] { TWO };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] { TEN };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        final SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        final SingletonMap<K, V> cloned = map.clone();\n+        assertEquals(1, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsValue(TWO));\n+    }\n+\n+    public void testKeyValue() {\n+        final SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        assertEquals(ONE, map.getKey());\n+        assertEquals(TWO, map.getValue());\n+        assertTrue(map instanceof KeyValue);\n+    }\n+\n+    public void testBoundedMap() {\n+        final SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(1, map.maxSize());\n+        assertTrue(map instanceof BoundedMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    public BulkTest bulkTestMapIterator() {\n+//        return new TestFlatMapIterator();\n+//    }\n+//\n+//    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator {\n+//        public TestFlatMapIterator() {\n+//            super(\"TestFlatMapIterator\");\n+//        }\n+//\n+//        public Object[] addSetValues() {\n+//            return TestSingletonMap.this.getNewSampleValues();\n+//        }\n+//\n+//        public boolean supportsRemove() {\n+//            return TestSingletonMap.this.isRemoveSupported();\n+//        }\n+//\n+//        public boolean supportsSetValue() {\n+//            return TestSingletonMap.this.isSetValueSupported();\n+//        }\n+//\n+//        public MapIterator makeEmptyMapIterator() {\n+//            resetEmpty();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public MapIterator makeFullMapIterator() {\n+//            resetFull();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public Map getMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.map;\n+//        }\n+//\n+//        public Map getConfirmedMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.confirmed;\n+//        }\n+//\n+//        public void verify() {\n+//            super.verify();\n+//            TestSingletonMap.this.verify();\n+//        }\n+//    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/SingletonMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/SingletonMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/StaticBucketMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.StaticBucketMap;\n+\n+/**\n+ * Unit tests.\n+ * {@link StaticBucketMap}.\n+ *\n+ * @version $Id$\n+ */\n+public class StaticBucketMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public StaticBucketMapTest(final String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(StaticBucketMapTest.class);\n+    }\n+\n+    @Override\n+    public StaticBucketMap<K, V> makeObject() {\n+        return new StaticBucketMap<K, V>(30);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isFailFastExpected() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        final String pre = \"StaticBucketMapTest.bulkTestMap\";\n+        final String post = \".testCollectionIteratorFailFast\";\n+        return new String[] {\n+            pre + \"EntrySet\" + post,\n+            pre + \"KeySet\" + post,\n+            pre + \"Values\" + post\n+        };\n+    }\n+\n+    // Bugzilla 37567\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_get_nullMatchesIncorrectly() {\n+        final StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put(null, (V) \"A\");\n+        assertEquals(\"A\", map.get(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            final String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, null, map.get(str));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_containsKey_nullMatchesIncorrectly() {\n+        final StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put(null, (V) \"A\");\n+        assertEquals(true, map.containsKey(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            final String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, false, map.containsKey(str));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_containsValue_nullMatchesIncorrectly() {\n+        final StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put((K) \"A\", null);\n+        assertEquals(true, map.containsValue(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            final String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, false, map.containsValue(str));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/TransformedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+import org.apache.commons.collections4.map.TransformedMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the {@link TransformedMap}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public TransformedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return TransformedMap.transformingMap(new HashMap<K, V>(), TransformerUtils.<K> nopTransformer(),\n+                TransformerUtils.<V> nopTransformer());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedMap() {\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        Map<K, V> map = TransformedMap\n+                .transformingMap(\n+                        new HashMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(new Integer((String) els[i])));\n+            assertEquals(false, map.containsKey(els[i]));\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(els[i], map.get(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(null, map.remove(els[0]));\n+        assertEquals(els[0], map.remove(new Integer((String) els[0])));\n+\n+        map = TransformedMap.transformingMap(new HashMap(), null, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(new Integer((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(new Integer((String) els[i]), map.get(els[i]));\n+        }\n+\n+        assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n+\n+        final Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n+        assertEquals(new Integer(66), array[0].getValue());\n+        assertEquals(new Integer(66), map.get(array[0].getKey()));\n+\n+        final Map.Entry entry = entrySet.iterator().next();\n+        entry.setValue(\"88\");\n+        assertEquals(new Integer(88), entry.getValue());\n+        assertEquals(new Integer(88), map.get(entry.getKey()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        final Map<K, V> base = new HashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        final Map<K, V> trans = TransformedMap\n+                .transformingMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(\"1\", trans.get(\"A\"));\n+        assertEquals(\"2\", trans.get(\"B\"));\n+        assertEquals(\"3\", trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        final Map<K, V> base = new HashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        final Map<K, V> trans = TransformedMap\n+                .transformedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(new Integer(1), trans.get(\"A\"));\n+        assertEquals(new Integer(2), trans.get(\"B\"));\n+        assertEquals(new Integer(3), trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/TransformedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/TransformedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+import org.apache.commons.collections4.map.TransformedSortedMap;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the {@link TransformedSortedMap}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    public TransformedSortedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TransformedSortedMapTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedMap<K, V> makeObject() {\n+        return TransformedSortedMap.transformingSortedMap(new TreeMap<K, V>(),\n+                (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),\n+                (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedMap() {\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        SortedMap<K, V> map = TransformedSortedMap\n+                .transformingSortedMap(\n+                        new TreeMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(new Integer((String) els[i])));\n+            try {\n+                map.containsKey(els[i]);\n+                fail();\n+            } catch (final ClassCastException ex) {}\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(els[i], map.get(new Integer((String) els[i])));\n+        }\n+\n+        try {\n+            map.remove(els[0]);\n+            fail();\n+        } catch (final ClassCastException ex) {}\n+        assertEquals(els[0], map.remove(new Integer((String) els[0])));\n+\n+        map = TransformedSortedMap\n+                .transformingSortedMap(\n+                        new TreeMap<K, V>(),\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(new Integer((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(new Integer((String) els[i]), map.get(els[i]));\n+        }\n+\n+        assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n+\n+        final Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        final Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n+        assertEquals(new Integer(66), array[0].getValue());\n+        assertEquals(new Integer(66), map.get(array[0].getKey()));\n+\n+        final Map.Entry<K, V> entry = entrySet.iterator().next();\n+        entry.setValue((V) \"88\");\n+        assertEquals(new Integer(88), entry.getValue());\n+        assertEquals(new Integer(88), map.get(entry.getKey()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        final SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        final SortedMap<K, V> trans = TransformedSortedMap\n+                .transformingSortedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(\"1\", trans.get(\"A\"));\n+        assertEquals(\"2\", trans.get(\"B\"));\n+        assertEquals(\"3\", trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        final SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        final SortedMap<K, V> trans = TransformedSortedMap\n+                .transformedSortedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(new Integer(1), trans.get(\"A\"));\n+        assertEquals(new Integer(2), trans.get(\"B\"));\n+        assertEquals(new Integer(3), trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/TransformedSortedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/TransformedSortedMap.fullCollection.version4.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.IterableMap;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.map.UnmodifiableMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the\n+ * {@link UnmodifiableMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public UnmodifiableMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<K, V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        final Map<K, V> m = new HashMap<K, V>();\n+        addSampleMappings(m);\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        final Map<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableMap.unmodifiableMap(map));\n+\n+        try {\n+            UnmodifiableMap.unmodifiableMap(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.map.ListOrderedMap;\n+import org.apache.commons.collections4.map.UnmodifiableOrderedMap;\n+\n+/**\n+ * Extension of {@link AbstractOrderedMapTest} for exercising the\n+ * {@link UnmodifiableOrderedMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public UnmodifiableOrderedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public OrderedMap<K, V> makeObject() {\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        final OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        addSampleMappings(m);\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        final OrderedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));\n+\n+        try {\n+            UnmodifiableOrderedMap.unmodifiableOrderedMap(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableOrderedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableOrderedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.map;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.map.UnmodifiableSortedMap;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the\n+ * {@link UnmodifiableSortedMap} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    public UnmodifiableSortedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<K, V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        final SortedMap<K, V> m = new TreeMap<K, V>();\n+        addSampleMappings(m);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        final SortedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n+\n+        try {\n+            UnmodifiableSortedMap.unmodifiableSortedMap(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableSortedMap.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableSortedMap.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+\n+/**\n+ * Test cases for CircularFifoQueue.\n+ *\n+ * @version $Id$\n+ */\n+public class CircularFifoQueueTest<E> extends AbstractCollectionTest<E> {\n+\n+    public CircularFifoQueueTest(final String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(CircularFifoQueueTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that\n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        final Iterator<E> iterator1 = getCollection().iterator();\n+        final Iterator<E> iterator2 = getConfirmed().iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            final Object o1 = iterator1.next();\n+            final Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because CircularFifoQueue doesn't allow null elements.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because CircularFifoQueue isn't fail fast.\n+     * @return false\n+     */\n+    @Override\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty ArrayList.\n+     *\n+     * @return an empty ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new ArrayList<E>();\n+    }\n+\n+    /**\n+     * Returns a full ArrayList.\n+     *\n+     * @return a full ArrayList\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final Collection<E> c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Returns an empty CircularFifoQueue that won't overflow.\n+     *\n+     * @return an empty CircularFifoQueue\n+     */\n+    @Override\n+    public Collection<E> makeObject() {\n+        return new CircularFifoQueue<E>(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCircularFifoQueueCircular() {\n+        final List<E> list = new ArrayList<E>();\n+        list.add((E) \"A\");\n+        list.add((E) \"B\");\n+        list.add((E) \"C\");\n+        final Queue<E> queue = new CircularFifoQueue<E>(list);\n+\n+        assertEquals(true, queue.contains(\"A\"));\n+        assertEquals(true, queue.contains(\"B\"));\n+        assertEquals(true, queue.contains(\"C\"));\n+\n+        queue.add((E) \"D\");\n+\n+        assertEquals(false, queue.contains(\"A\"));\n+        assertEquals(true, queue.contains(\"B\"));\n+        assertEquals(true, queue.contains(\"C\"));\n+        assertEquals(true, queue.contains(\"D\"));\n+\n+        assertEquals(\"B\", queue.peek());\n+        assertEquals(\"B\", queue.remove());\n+        assertEquals(\"C\", queue.remove());\n+        assertEquals(\"D\", queue.remove());\n+    }\n+\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testCircularFifoQueueRemove() {\n+        resetFull();\n+        final int size = getConfirmed().size();\n+        for (int i = 0; i < size; i++) {\n+            final Object o1 = getCollection().remove();\n+            final Object o2 = getConfirmed().remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            getCollection().remove();\n+            fail(\"Empty queue should raise Underflow.\");\n+        } catch (final NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new CircularFifoQueue<E>(0);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new CircularFifoQueue<E>(-20);\n+        } catch (final IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new CircularFifoQueue<E>(null);\n+        } catch (final NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError1() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[1, 2, 5]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError2() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+        fifo.add((E) \"6\");\n+\n+        assertEquals(5, fifo.size());\n+        assertEquals(\"[2, 3, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[2, 4, 5, 6]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError3() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");\n+\n+        assertEquals(\"[1, 2, 3, 4, 5]\", fifo.toString());\n+\n+        fifo.remove(\"3\");\n+        assertEquals(\"[1, 2, 4, 5]\", fifo.toString());\n+\n+        fifo.add((E) \"6\");\n+        fifo.add((E) \"7\");\n+        assertEquals(\"[2, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");\n+        assertEquals(\"[2, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError4() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"4\");  // remove element in middle of array, after start\n+        assertEquals(\"[3, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError5() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"5\");  // remove element at last pos in array\n+        assertEquals(\"[3, 4, 6, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError6() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"6\");  // remove element at position zero in array\n+        assertEquals(\"[3, 4, 5, 7]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError7() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+\n+        assertEquals(\"[3, 4, 5, 6, 7]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array\n+        assertEquals(\"[3, 4, 5, 6]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError8() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"7\");  // remove element at position one in array, need to shift 8\n+        assertEquals(\"[4, 5, 6, 8]\", fifo.toString());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveError9() throws Exception {\n+        // based on bug 33071\n+        final CircularFifoQueue<E> fifo = new CircularFifoQueue<E>(5);\n+        fifo.add((E) \"1\");\n+        fifo.add((E) \"2\");\n+        fifo.add((E) \"3\");\n+        fifo.add((E) \"4\");\n+        fifo.add((E) \"5\");  // end=0\n+        fifo.add((E) \"6\");  // end=1\n+        fifo.add((E) \"7\");  // end=2\n+        fifo.add((E) \"8\");  // end=3\n+\n+        assertEquals(\"[4, 5, 6, 7, 8]\", fifo.toString());\n+\n+        fifo.remove(\"8\");  // remove element at position two in array\n+        assertEquals(\"[4, 5, 6, 7]\", fifo.toString());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRepeatedSerialization() throws Exception {\n+        // bug 31433\n+        final CircularFifoQueue<E> b = new CircularFifoQueue<E>(2);\n+        b.add((E) \"a\");\n+        assertEquals(1, b.size());\n+        assertEquals(true, b.contains(\"a\"));\n+\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b);\n+\n+        final CircularFifoQueue<E> b2 = (CircularFifoQueue<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(1, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        b2.add((E) \"b\");\n+        assertEquals(2, b2.size());\n+        assertEquals(true, b2.contains(\"a\"));\n+        assertEquals(true, b2.contains(\"b\"));\n+\n+        bos = new ByteArrayOutputStream();\n+        new ObjectOutputStream(bos).writeObject(b2);\n+\n+        final CircularFifoQueue<E> b3 = (CircularFifoQueue<E>) new ObjectInputStream(\n+            new ByteArrayInputStream(bos.toByteArray())).readObject();\n+\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"a\"));\n+        assertEquals(true, b3.contains(\"b\"));\n+        b3.add((E) \"c\");\n+        assertEquals(2, b3.size());\n+        assertEquals(true, b3.contains(\"b\"));\n+        assertEquals(true, b3.contains(\"c\"));\n+    }\n+\n+    public void testGetIndex() {\n+        resetFull();\n+        \n+        final CircularFifoQueue<E> queue = getCollection();\n+        final List<E> confirmed = getConfirmed();\n+        for (int i = 0; i < confirmed.size(); i++) {\n+            assertEquals(confirmed.get(i), queue.get(i));\n+        }\n+\n+        // remove the first two elements and check again\n+        queue.remove();\n+        queue.remove();\n+        \n+        for (int i = 0; i < queue.size(); i++) {\n+            assertEquals(confirmed.get(i + 2), queue.get(i));\n+        }        \n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CircularFifoQueue.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CircularFifoQueue.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CircularFifoQueue<E> getCollection() {\n+        return (CircularFifoQueue<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<E> getConfirmed() {\n+        return (List<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.collection.PredicatedCollectionTest;\n+\n+/**\n+ * Extension of {@link PredicatedCollectionTest} for exercising the\n+ * {@link PredicatedQueue} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PredicatedQueueTest<E> extends PredicatedCollectionTest<E> {\n+\n+    public PredicatedQueueTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //---------------------------------------------------------------\n+\n+    protected Queue<E> decorateCollection(final Queue<E> queue, final Predicate<E> predicate) {\n+        return PredicatedQueue.predicatedQueue(queue, predicate);\n+    }\n+\n+    @Override\n+    public Queue<E> makeObject() {\n+        return decorateCollection(new LinkedList<E>(), truePredicate);\n+    }\n+    \n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final Queue<E> queue = new LinkedList<E>();\n+        queue.addAll(Arrays.asList(getFullElements()));\n+        return decorateCollection(queue, truePredicate);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new LinkedList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final List<E> list = new LinkedList<E>();\n+        list.addAll(java.util.Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    //------------------------------------------------------------\n+\n+    public Queue<E> makeTestQueue() {\n+        return decorateCollection(new LinkedList<E>(), testPredicate);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGet() {\n+        final Queue<E> queue = makeTestQueue();\n+\n+        assertNull(queue.peek());\n+\n+        queue.add((E) \"one\");\n+        queue.add((E) \"two\");\n+        queue.add((E) \"three\");\n+        assertEquals(\"Queue get\", \"one\", queue.peek());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove() {\n+        final Queue<E> queue = makeTestQueue();\n+        queue.add((E) \"one\");\n+        assertEquals(\"Queue get\", \"one\", queue.poll());\n+        assertNull(queue.peek());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedQueue.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedQueue.fullCollection.version4.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link TransformedQueue} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class TransformedQueueTest<E> extends AbstractCollectionTest<E> {\n+    \n+    public TransformedQueueTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Queue<E> makeConfirmedCollection() {\n+        return new LinkedList<E>();\n+    }\n+\n+    @Override\n+    public Queue<E> makeConfirmedFullCollection() {\n+        final Queue<E> list = new LinkedList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Queue<E> makeObject() {\n+        return TransformedQueue.transformingQueue(new LinkedList<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Queue<E> makeFullCollection() {\n+        final Queue<E> list = new LinkedList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedQueue.transformingQueue(list, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testTransformedQueue() {\n+        final Queue<Object> queue = TransformedQueue.transformingQueue(new LinkedList<Object>(),\n+                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, queue.size());\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            queue.add(els[i]);\n+            assertEquals(i + 1, queue.size());\n+            assertEquals(true, queue.contains(new Integer((String) els[i])));\n+            assertEquals(false, queue.contains(els[i]));\n+        }\n+        \n+        assertEquals(false, queue.remove(els[0]));\n+        assertEquals(true, queue.remove(new Integer((String) els[0])));\n+        \n+    }\n+\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public void testTransformedQueue_decorateTransform() {\n+        final Queue originalQueue = new LinkedList();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalQueue.add(el);\n+        }\n+        final Queue<?> queue = TransformedQueue.transformedQueue(originalQueue,\n+                TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, queue.size());\n+        for (final Object el : els) {\n+            assertEquals(true, queue.contains(new Integer((String) el)));\n+            assertEquals(false, queue.contains(el));\n+        }\n+        \n+        assertEquals(false, queue.remove(els[0]));\n+        assertEquals(true, queue.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+    \n+//  public void testCreate() throws Exception {\n+//      resetEmpty();\n+//      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.emptyCollection.version4.obj\");\n+//      resetFull();\n+//      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.fullCollection.version4.obj\");\n+//  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.queue;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractCollectionTest} for exercising the\n+ * {@link UnmodifiableQueue} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableQueueTest<E> extends AbstractCollectionTest<E> {\n+\n+    public UnmodifiableQueueTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public Collection<E> makeObject() {\n+        return UnmodifiableQueue.unmodifiableQueue(new LinkedList<E>());\n+    }\n+\n+    @Override\n+    public Collection<E> makeFullCollection() {\n+        final Queue<E> queue = new LinkedList<E>();\n+        queue.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableQueue.unmodifiableQueue(queue);\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new LinkedList<E>();\n+    }\n+\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final LinkedList<E> list = new LinkedList<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    public void testQueueRemove() {\n+        resetEmpty();\n+        try {\n+            getCollection().remove();\n+            fail();\n+        } catch (final UnsupportedOperationException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableQueue.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableQueue.fullCollection.version4.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Queue<E> getCollection() {\n+        return (Queue<E>) super.getCollection();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.collection.AbstractCollectionTest;\n+\n+/**\n+ * Abstract test class for {@link Set} methods and contracts.\n+ * <p>\n+ * Since {@link Set} doesn't stipulate much new behavior that isn't already\n+ * found in {@link Collection}, this class basically just adds tests for\n+ * {@link Set#equals} and {@link Set#hashCode()} along with an updated\n+ * {@link #verify()} that ensures elements do not appear more than once in the\n+ * set.\n+ * <p>\n+ * To use, subclass and override the {@link #makeObject()}\n+ * method.  You may have to override other protected methods if your\n+ * set is not modifiable, or if your set restricts what kinds of\n+ * elements may be added; see {@link AbstractCollectionTest} for more details.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSetTest<E> extends AbstractCollectionTest<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param name  name for test\n+     */\n+    public AbstractSetTest(final String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Provides additional verifications for sets.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        \n+        assertEquals(\"Sets should be equal\", getConfirmed(), getCollection());\n+        assertEquals(\"Sets should have equal hashCodes\", \n+                     getConfirmed().hashCode(), getCollection().hashCode());\n+        final Collection<E> set = makeConfirmedCollection();\n+        final Iterator<E> iterator = getCollection().iterator();\n+        while (iterator.hasNext()) {\n+            assertTrue(\"Set.iterator should only return unique elements\", set.add(iterator.next()));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Set equals method is defined.\n+     */\n+    @Override\n+    public boolean isEqualsCheckable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns an empty Set for use in modification testing.\n+     *\n+     * @return a confirmed empty collection\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    /**\n+     * Returns a full Set for use in modification testing.\n+     *\n+     * @return a confirmed full collection\n+     */\n+    @Override\n+    public Collection<E> makeConfirmedFullCollection() {\n+        final Collection<E> set = makeConfirmedCollection();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    /**\n+     * Makes an empty set.  The returned set should have no elements.\n+     *\n+     * @return an empty set\n+     */\n+    @Override\n+    public abstract Set<E> makeObject();\n+\n+    /**\n+     * Makes a full set by first creating an empty set and then adding\n+     * all the elements returned by {@link #getFullElements()}.\n+     *\n+     * Override if your set does not support the add operation.\n+     *\n+     * @return a full set\n+     */\n+    @Override\n+    public Set<E> makeFullCollection() {\n+        final Set<E> set = makeObject();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.  \n+     */\n+    @Override\n+    public Set<E> getCollection() {\n+        return (Set<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * Return the {@link AbstractCollectionTest#confirmed} fixture, but cast as a Set.\n+     */\n+    @Override\n+    public Set<E> getConfirmed() {\n+        return (Set<E>) super.getConfirmed();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests {@link Set#equals(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetEquals() {\n+        resetEmpty();\n+        assertEquals(\"Empty sets should be equal\", getCollection(), getConfirmed());\n+        verify();\n+\n+        final Collection<E> set2 = makeConfirmedCollection();\n+        set2.add((E) \"foo\");\n+        assertTrue(\"Empty set shouldn't equal nonempty set\", !getCollection().equals(set2));\n+\n+        resetFull();\n+        assertEquals(\"Full sets should be equal\", getCollection(), getConfirmed());\n+        verify();\n+\n+        set2.clear();\n+        set2.addAll(Arrays.asList(getOtherElements()));\n+        assertTrue(\"Sets with different contents shouldn't be equal\", !getCollection().equals(set2));\n+    }\n+\n+    /**\n+     * Tests {@link Set#hashCode()}.\n+     */\n+    public void testSetHashCode() {\n+        resetEmpty();\n+        assertEquals(\"Empty sets have equal hashCodes\", \n+                getCollection().hashCode(), getConfirmed().hashCode());\n+\n+        resetFull();\n+        assertEquals(\"Equal sets have equal hashCodes\", \n+                getCollection().hashCode(), getConfirmed().hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Iterator;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections4.BulkTest;\n+\n+/**\n+ * Abstract test class for {@link SortedSet} methods and contracts.\n+ * <p>\n+ * To use, subclass and override the {@link #makeObject()}\n+ * method.  You may have to override other protected methods if your\n+ * set is not modifiable, or if your set restricts what kinds of\n+ * elements may be added; see {@link AbstractSetTest} for more details.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedSetTest<E> extends AbstractSetTest<E> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param name  name for test\n+     */\n+    public AbstractSortedSetTest(final String name) {\n+        super(name);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Verification extension, will check the order of elements,\n+     * the sets should already be verified equal.\n+     */\n+    @Override\n+    public void verify() {\n+        super.verify();\n+        \n+        // Check that iterator returns elements in order and first() and last()\n+        // are consistent\n+        final Iterator<E> colliter = getCollection().iterator();\n+        final Iterator<E> confiter = getConfirmed().iterator();\n+        E first = null;\n+        E last = null;\n+        while (colliter.hasNext()) {\n+            if (first == null) {\n+                first = colliter.next();\n+                last = first;\n+            } else {\n+              last = colliter.next();\n+            }  \n+            assertEquals(\"Element appears to be out of order.\", last, confiter.next());\n+        }\n+        if (getCollection().size() > 0) {\n+            assertEquals(\"Incorrect element returned by first().\", first,\n+                getCollection().first());\n+            assertEquals(\"Incorrect element returned by last().\", last,\n+                getCollection().last());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because SortedSets don't allow null elements (normally).\n+     * @return false\n+     */\n+    @Override\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedSet<E> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> makeFullCollection() {\n+        return (SortedSet<E>) super.makeFullCollection();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty {@link TreeSet} for use in modification testing.\n+     *\n+     * @return a confirmed empty collection\n+     */\n+    @Override\n+    public SortedSet<E> makeConfirmedCollection() {\n+        return new TreeSet<E>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to return comparable objects.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullNonNullElements() {\n+        final Object[] elements = new Object[30];\n+\n+        for (int i = 0; i < 30; i++) {\n+            elements[i] = new Integer(i + i + 1);\n+        }\n+        return (E[]) elements;\n+    }\n+\n+    /**\n+     * Override to return comparable objects.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getOtherNonNullElements() {\n+        final Object[] elements = new Object[30];\n+        for (int i = 0; i < 30; i++) {\n+            elements[i] = new Integer(i + i + 2);\n+        }\n+        return (E[]) elements;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Bulk test {@link SortedSet#subSet(Object, Object)}.  This method runs through all of\n+     * the tests in {@link AbstractSortedSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing a subset.\n+     */\n+    public BulkTest bulkTestSortedSetSubSet() {\n+        final int length = getFullElements().length;\n+\n+        final int lobound = length / 3;\n+        final int hibound = lobound * 2;\n+        return new TestSortedSetSubSet(lobound, hibound);\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link SortedSet#headSet(Object)}.  This method runs through all of\n+     * the tests in {@link AbstractSortedSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing a headset.\n+     */\n+    public BulkTest bulkTestSortedSetHeadSet() {\n+        final int length = getFullElements().length;\n+\n+        final int lobound = length / 3;\n+        final int hibound = lobound * 2;\n+        return new TestSortedSetSubSet(hibound, true);\n+\n+    }\n+\n+    /**\n+     * Bulk test {@link SortedSet#tailSet(Object)}.  This method runs through all of\n+     * the tests in {@link AbstractSortedSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the set and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing a tailset.\n+     */\n+    public BulkTest bulkTestSortedSetTailSet() {\n+        final int length = getFullElements().length;\n+        final int lobound = length / 3;\n+        return new TestSortedSetSubSet(lobound, false);\n+    }\n+\n+    public class TestSortedSetSubSet extends AbstractSortedSetTest<E> {\n+\n+        private int m_Type;\n+        private int m_LowBound;\n+        private int m_HighBound;\n+        private E[] m_FullElements;\n+        private E[] m_OtherElements;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public TestSortedSetSubSet(final int bound, final boolean head) {\n+            super(\"TestSortedSetSubSet\");\n+            if (head) {\n+                //System.out.println(\"HEADSET\");\n+                m_Type = TYPE_HEADSET;\n+                m_HighBound = bound;\n+                m_FullElements = (E[]) new Object[bound];\n+                System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, m_FullElements, 0, bound);\n+                m_OtherElements = (E[]) new Object[bound - 1];\n+                System.arraycopy(//src src_pos dst dst_pos length\n+                AbstractSortedSetTest.this.getOtherElements(), 0, m_OtherElements, 0, bound - 1);\n+                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n+                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n+            } else {\n+                //System.out.println(\"TAILSET\");\n+                m_Type = TYPE_TAILSET;\n+                m_LowBound = bound;\n+                final Object[] allelements = AbstractSortedSetTest.this.getFullElements();\n+                //System.out.println(\"bound = \"+bound +\"::length=\"+allelements.length);\n+                m_FullElements = (E[]) new Object[allelements.length - bound];\n+                System.arraycopy(allelements, bound, m_FullElements, 0, allelements.length - bound);\n+                m_OtherElements = (E[]) new Object[allelements.length - bound - 1];\n+                System.arraycopy(//src src_pos dst dst_pos length\n+                AbstractSortedSetTest.this.getOtherElements(), bound, m_OtherElements, 0, allelements.length - bound - 1);\n+                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n+                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n+                //resetFull();\n+                //System.out.println(collection);\n+                //System.out.println(confirmed);\n+\n+            }\n+\n+        } //type\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public TestSortedSetSubSet(final int lobound, final int hibound) {\n+            super(\"TestSortedSetSubSet\");\n+            //System.out.println(\"SUBSET\");\n+            m_Type = TYPE_SUBSET;\n+            m_LowBound = lobound;\n+            m_HighBound = hibound;\n+            final int length = hibound - lobound;\n+            //System.out.println(\"Low=\" + lobound + \"::High=\" + hibound + \"::Length=\" + length);\n+            m_FullElements = (E[]) new Object[length];\n+            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), lobound, m_FullElements, 0, length);\n+            m_OtherElements = (E[]) new Object[length - 1];\n+            System.arraycopy(//src src_pos dst dst_pos length\n+            AbstractSortedSetTest.this.getOtherElements(), lobound, m_OtherElements, 0, length - 1);\n+\n+            //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n+            //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n+\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractSortedSetTest.this.isNullSupported();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return AbstractSortedSetTest.this.isAddSupported();\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractSortedSetTest.this.isRemoveSupported();\n+        }\n+        @Override\n+        public boolean isFailFastSupported() {\n+            return AbstractSortedSetTest.this.isFailFastSupported();\n+        }\n+\n+        @Override\n+        public E[] getFullElements() {\n+            return m_FullElements;\n+        }\n+        @Override\n+        public E[] getOtherElements() {\n+            return m_OtherElements;\n+        }\n+\n+        private SortedSet<E> getSubSet(final SortedSet<E> set) {\n+            final E[] elements = AbstractSortedSetTest.this.getFullElements();\n+            switch (m_Type) {\n+                case TYPE_SUBSET :\n+                    return set.subSet(elements[m_LowBound], elements[m_HighBound]);\n+                case TYPE_HEADSET :\n+                    return set.headSet(elements[m_HighBound]);\n+                case TYPE_TAILSET :\n+                    return set.tailSet(elements[m_LowBound]);\n+                default :\n+                    return null;\n+            }\n+        }\n+\n+        @Override\n+        public SortedSet<E> makeObject() {\n+            return getSubSet(AbstractSortedSetTest.this.makeObject());\n+        }\n+\n+        @Override\n+        public SortedSet<E> makeFullCollection() {\n+            return getSubSet(AbstractSortedSetTest.this.makeFullCollection());\n+        }\n+        \n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+        \n+        @Override\n+        public BulkTest bulkTestSortedSetSubSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSortedSetHeadSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSortedSetTailSet() {\n+            return null;  // prevent infinite recursion\n+        }\n+\n+        static final int TYPE_SUBSET = 0;\n+        static final int TYPE_TAILSET = 1;\n+        static final int TYPE_HEADSET = 2;\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> getCollection() {\n+        return (SortedSet<E>) super.getCollection();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedSet<E> getConfirmed() {\n+        return (SortedSet<E>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/CompositeSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.set.CompositeSet.SetMutator;\n+\n+/**\n+ * Extension of {@link AbstractSetTest} for exercising the\n+ * {@link CompositeSet} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class CompositeSetTest<E> extends AbstractSetTest<E> {\n+    public CompositeSetTest(final String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public CompositeSet<E> makeObject() {\n+        final HashSet<E> contained = new HashSet<E>();\n+        final CompositeSet<E> set = new CompositeSet<E>(contained);\n+        set.setMutator( new EmptySetMutator<E>(contained) );\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> buildOne() {\n+        final HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"1\");\n+        set.add((E) \"2\");\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> buildTwo() {\n+        final HashSet<E> set = new HashSet<E>();\n+        set.add((E) \"3\");\n+        set.add((E) \"4\");\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContains() {\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[]{ buildOne(), buildTwo() });\n+        assertTrue(set.contains(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveUnderlying() {\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        one.remove(\"1\");\n+        assertFalse(set.contains(\"1\"));\n+\n+        two.remove(\"3\");\n+        assertFalse(set.contains(\"3\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        set.remove(\"1\");\n+        assertFalse(one.contains(\"1\"));\n+\n+        set.remove(\"3\");\n+        assertFalse(one.contains(\"3\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFailedCollisionResolution() {\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>(new Set[] { one, two });\n+        set.setMutator(new SetMutator<E>() {\n+            private static final long serialVersionUID = 1L;\n+\n+            public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing,\n+                final Set<E> added, final Collection<E> intersects) {\n+                //noop\n+            }\n+\n+            public boolean add(final CompositeSet<E> composite,\n+                    final List<Set<E>> collections, final E obj) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public boolean addAll(final CompositeSet<E> composite,\n+                    final List<Set<E>> collections, final Collection<? extends E> coll) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+\n+        final HashSet<E> three = new HashSet<E>();\n+        three.add((E) \"1\");\n+        try {\n+            set.addComposited(three);\n+            fail(\"IllegalArgumentException should have been thrown\");\n+        }\n+        catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddComposited() {\n+        final Set<E> one = buildOne();\n+        final Set<E> two = buildTwo();\n+        final CompositeSet<E> set = new CompositeSet<E>();\n+        set.addComposited(one, two);\n+        final CompositeSet<E> set2 = new CompositeSet<E>(buildOne());\n+        set2.addComposited(buildTwo());\n+        assertTrue(set.equals(set2));\n+        final HashSet<E> set3 = new HashSet<E>();\n+        set3.add((E) \"1\");\n+        set3.add((E) \"2\");\n+        set3.add((E) \"3\");\n+        final HashSet<E> set4 = new HashSet<E>();\n+        set4.add((E) \"4\");\n+        final CompositeSet<E> set5 = new CompositeSet<E>(set3);\n+        set5.addComposited(set4);\n+        assertTrue(set.equals(set5));\n+        try {\n+            set.addComposited(set3);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException ex) {\n+            // expected\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/CompositeSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This class is used in CompositeSetTest. When testing serialization, \n+ * the class has to be separate of CompositeSetTest, else the test \n+ * class also has to be serialized. \n+ */\n+class EmptySetMutator<E> implements CompositeSet.SetMutator<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5321193666420238910L;\n+\n+    private final Set<E> contained;\n+\n+    public EmptySetMutator(final Set<E> set) {\n+        this.contained = set;\n+    }\n+\n+    public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing, final Set<E> added, final Collection<E> intersects) {\n+        throw new IllegalArgumentException();\n+    }\n+    \n+    public boolean add(final CompositeSet<E> composite, final List<Set<E>> collections, final E obj) {\n+        return contained.add(obj);\n+    }\n+    \n+    public boolean addAll(final CompositeSet<E> composite, final List<Set<E>> collections, final Collection<? extends E> coll) {\n+        return contained.addAll(coll);\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/ListOrderedSet2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Extension of {@link AbstractSetTest} for exercising the {@link ListOrderedSet}\n+ * implementation.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class ListOrderedSet2Test<E> extends AbstractSetTest<E> {\n+\n+    private static final Integer ZERO = new Integer(0);\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n+\n+    public ListOrderedSet2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ListOrderedSet<E> makeObject() {\n+        return new ListOrderedSet<E>();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected ListOrderedSet<E> setupSet() {\n+        final ListOrderedSet<E> set = makeObject();\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testOrdering() {\n+        final ListOrderedSet<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n+\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i += 2) {\n+            assertTrue(\"Must be able to remove int\", set.remove(Integer.toString(i)));\n+        }\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong after remove \", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+\n+        assertEquals(\"Size of set is wrong!\", 10, set.size());\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+        for (int i = 0; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddRemove() {\n+        final ListOrderedSet<E> set = makeObject();\n+        final List<E> view = set.asList();\n+        set.add((E) ZERO);\n+        set.add((E) ONE);\n+        set.add((E) TWO);\n+\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertEquals(3, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(ONE, view.get(1));\n+        assertSame(TWO, view.get(2));\n+\n+        assertEquals(0, set.indexOf(ZERO));\n+        assertEquals(1, set.indexOf(ONE));\n+        assertEquals(2, set.indexOf(TWO));\n+\n+        set.remove(1);\n+        assertEquals(2, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(TWO, set.get(1));\n+        assertEquals(2, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(TWO, view.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddIndexed() {\n+        final ListOrderedSet<E> set = makeObject();\n+        set.add((E) ZERO);\n+        set.add((E) TWO);\n+\n+        set.add(1, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        set.add(0, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        final List<E> list = new ArrayList<E>();\n+        list.add((E) ZERO);\n+        list.add((E) TWO);\n+\n+        set.addAll(0, list);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        list.add(0, (E) THREE); // list = [3,0,2]\n+        set.remove(TWO);    //  set = [0,1]\n+        set.addAll(1, list);\n+        assertEquals(4, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(THREE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertSame(ONE, set.get(3));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) collection, \"D:/dev/collections/data/test/ListOrderedSet.fullCollection.version3.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Extension of {@link AbstractSetTest} for exercising the\n+ * {@link ListOrderedSet} implementation.\n+ * \n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class ListOrderedSetTest<E>\n+    extends AbstractSetTest<E> {\n+\n+    private static final Integer ZERO = new Integer(0);\n+\n+    private static final Integer ONE = new Integer(1);\n+\n+    private static final Integer TWO = new Integer(2);\n+\n+    private static final Integer THREE = new Integer(3);\n+\n+    public ListOrderedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public ListOrderedSet<E> makeObject() {\n+        return ListOrderedSet.listOrderedSet(new HashSet<E>());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected ListOrderedSet<E> setupSet() {\n+        final ListOrderedSet<E> set = makeObject();\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testOrdering() {\n+        final ListOrderedSet<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n+\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i += 2) {\n+            assertTrue(\"Must be able to remove int\",\n+                       set.remove(Integer.toString(i)));\n+        }\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong after remove \",\n+                         Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+\n+        assertEquals(\"Size of set is wrong!\", 10, set.size());\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+        for (int i = 0; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddRemove() {\n+        final ListOrderedSet<E> set = makeObject();\n+        final List<E> view = set.asList();\n+        set.add((E) ZERO);\n+        set.add((E) ONE);\n+        set.add((E) TWO);\n+\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertEquals(3, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(ONE, view.get(1));\n+        assertSame(TWO, view.get(2));\n+\n+        assertEquals(0, set.indexOf(ZERO));\n+        assertEquals(1, set.indexOf(ONE));\n+        assertEquals(2, set.indexOf(TWO));\n+\n+        set.remove(1);\n+        assertEquals(2, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(TWO, set.get(1));\n+        assertEquals(2, view.size());\n+        assertSame(ZERO, view.get(0));\n+        assertSame(TWO, view.get(1));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddIndexed() {\n+        final ListOrderedSet<E> set = makeObject();\n+        set.add((E) ZERO);\n+        set.add((E) TWO);\n+\n+        set.add(1, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        set.add(0, (E) ONE);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        final List<E> list = new ArrayList<E>();\n+        list.add((E) ZERO);\n+        list.add((E) TWO);\n+\n+        set.addAll(0, list);\n+        assertEquals(3, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(ONE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+\n+        list.add(0, (E) THREE); // list = [3,0,2]\n+        set.remove(TWO); //  set = [0,1]\n+        set.addAll(1, list);\n+        assertEquals(4, set.size());\n+        assertSame(ZERO, set.get(0));\n+        assertSame(THREE, set.get(1));\n+        assertSame(TWO, set.get(2));\n+        assertSame(ONE, set.get(3));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListAddReplacing() {\n+        final ListOrderedSet<E> set = makeObject();\n+        final A a = new A();\n+        final B b = new B();\n+        set.add((E) a);\n+        assertEquals(1, set.size());\n+        set.add((E) b); // will match but not replace A as equal\n+        assertEquals(1, set.size());\n+        assertSame(a, set.decorated().iterator().next());\n+        assertSame(a, set.iterator().next());\n+        assertSame(a, set.get(0));\n+        assertSame(a, set.asList().get(0));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRetainAll() {\n+        final List<E> list = new ArrayList<E>(10);\n+        final Set<E> set = new HashSet<E>(10);\n+        final ListOrderedSet<E> orderedSet = ListOrderedSet.listOrderedSet(set, list);\n+        for (int i = 0; i < 10; ++i) {\n+            orderedSet.add((E) Integer.valueOf(10 - i - 1));\n+        }\n+\n+        final Collection<E> retained = new ArrayList<E>(5);\n+        for (int i = 0; i < 5; ++i) {\n+            retained.add((E) Integer.valueOf(i * 2));\n+        }\n+\n+        assertTrue(orderedSet.retainAll(retained));\n+        assertEquals(5, orderedSet.size());\n+        // insertion order preserved?\n+        assertEquals(Integer.valueOf(8), orderedSet.get(0));\n+        assertEquals(Integer.valueOf(6), orderedSet.get(1));\n+        assertEquals(Integer.valueOf(4), orderedSet.get(2));\n+        assertEquals(Integer.valueOf(2), orderedSet.get(3));\n+        assertEquals(Integer.valueOf(0), orderedSet.get(4));\n+    }\n+\n+    /*\n+     * test case for https://issues.apache.org/jira/browse/COLLECTIONS-426\n+     */\n+    public void testRetainAllCollections426() {\n+        final int size = 100000;\n+        final ListOrderedSet<Integer> set = new ListOrderedSet<Integer>();\n+        for (int i = 0; i < size; i++) {\n+            set.add(i);\n+        }\n+        final ArrayList<Integer> list = new ArrayList<Integer>();\n+        for (int i = size; i < 2 * size; i++) {\n+            list.add(i);\n+        }\n+\n+        final long start = System.currentTimeMillis();\n+        set.retainAll(list);\n+        final long stop = System.currentTimeMillis();\n+\n+        // make sure retainAll completes under 5 seconds\n+        // TODO if test is migrated to JUnit 4, add a Timeout rule.\n+        // http://kentbeck.github.com/junit/javadoc/latest/org/junit/rules/Timeout.html\n+        assertTrue(stop - start < 5000);\n+    }\n+\n+    static class A {\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            return obj instanceof A || obj instanceof B;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 1;\n+        }\n+    }\n+\n+    static class B {\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            return obj instanceof A || obj instanceof B;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return 1;\n+        }\n+    }\n+\n+    public void testDecorator() {\n+        try {\n+            ListOrderedSet.listOrderedSet((List<E>) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n+        }\n+        try {\n+            ListOrderedSet.listOrderedSet((Set<E>) null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n+        }\n+        try {\n+            ListOrderedSet.listOrderedSet(null, null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n+        }\n+        try {\n+            ListOrderedSet.listOrderedSet(new HashSet<E>(), null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n+        }\n+        try {\n+            ListOrderedSet.listOrderedSet(null, new ArrayList<E>());\n+            fail();\n+        } catch (final IllegalArgumentException ex) {\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ListOrderedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/ListOrderedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/MapBackedSet2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.map.LinkedMap;\n+\n+/**\n+ * JUnit test.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class MapBackedSet2Test<E> extends AbstractSetTest<E> {\n+\n+    public MapBackedSet2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Set<E> makeObject() {\n+        return MapBackedSet.mapBackedSet(new LinkedMap<E, Object>());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> setupSet() {\n+        final Set<E> set = makeObject();\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+        return set;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testOrdering() {\n+        final Set<E> set = setupSet();\n+        Iterator<E> it = set.iterator();\n+\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i += 2) {\n+            assertTrue(\"Must be able to remove int\", set.remove(Integer.toString(i)));\n+        }\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong after remove \", Integer.toString(i), it.next());\n+        }\n+\n+        for (int i = 0; i < 10; i++) {\n+            set.add((E) Integer.toString(i));\n+        }\n+\n+        assertEquals(\"Size of set is wrong!\", 10, set.size());\n+\n+        it = set.iterator();\n+        for (int i = 1; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+        for (int i = 0; i < 10; i += 2) {\n+            assertEquals(\"Sequence is wrong\", Integer.toString(i), it.next());\n+        }\n+    }\n+\n+    @Override\n+    public void testCanonicalEmptyCollectionExists() {\n+    }\n+\n+    @Override\n+    public void testCanonicalFullCollectionExists() {\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/MapBackedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.map.HashedMap;\n+\n+/**\n+ * JUnit test.\n+ *\n+ * @since 3.1\n+ * @version $Id$\n+ */\n+public class MapBackedSetTest<E> extends AbstractSetTest<E> {\n+\n+    public MapBackedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Set<E> makeObject() {\n+        return MapBackedSet.mapBackedSet(new HashedMap<E, Object>());\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/MapBackedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/MapBackedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/PredicatedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractSetTest} for exercising the \n+ * {@link PredicatedSet} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSetTest<E> extends AbstractSetTest<E> {\n+\n+    public PredicatedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+ //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    protected PredicatedSet<E> decorateSet(final Set<E> set, final Predicate<? super E> predicate) {\n+        return PredicatedSet.predicatedSet(set, predicate);\n+    }\n+\n+    @Override\n+    public PredicatedSet<E> makeObject() {\n+        return decorateSet(new HashSet<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public E[] getFullElements() {\n+        return (E[]) new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+    }\n+\n+//--------------------------------------------------------------------\n+\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(final E o) {\n+                return o instanceof String;\n+            }\n+        };\n+\n+    protected PredicatedSet<E> makeTestSet() {\n+        return decorateSet(new HashSet<E>(), testPredicate);\n+    }\n+\n+    public void testGetSet() {\n+        final PredicatedSet<E> set = makeTestSet();\n+        assertTrue(\"returned set should not be null\", set.decorated() != null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        final Set<E> set = makeTestSet();\n+        final Integer i = new Integer(3);\n+        try {\n+            set.add((E) i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !set.contains(i));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        final Set<E> set = makeTestSet();\n+        final Set<E> elements = new HashSet<E>();\n+        elements.add((E) \"one\");\n+        elements.add((E) \"two\");\n+        elements.add((E) new Integer(3));\n+        elements.add((E) \"four\");\n+        try {\n+            set.addAll(elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(\"one\"));\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(\"two\"));\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(new Integer(3)));\n+        assertTrue(\"Set shouldn't contain illegal element\",\n+         !set.contains(\"four\"));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/PredicatedSortedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractSortedSetTest} for exercising the\n+ * {@link PredicatedSortedSet} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class PredicatedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n+\n+    public PredicatedSortedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(PredicatedSortedSetTest.class);\n+    }\n+\n+ //-------------------------------------------------------------------\n+\n+    protected Predicate<E> truePredicate = TruePredicate.<E>truePredicate();\n+\n+    @Override\n+    public SortedSet<E> makeObject() {\n+        return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), truePredicate);\n+    }\n+\n+    @Override\n+    public SortedSet<E> makeFullCollection() {\n+        final TreeSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return PredicatedSortedSet.predicatedSortedSet(set, truePredicate);\n+    }\n+\n+//--------------------------------------------------------------------\n+    protected Predicate<E> testPredicate =\n+        new Predicate<E>() {\n+            public boolean evaluate(final E o) {\n+                return o instanceof String && ((String) o).startsWith(\"A\");\n+            }\n+        };\n+\n+    protected PredicatedSortedSet<E> makeTestSet() {\n+        return PredicatedSortedSet.predicatedSortedSet(new TreeSet<E>(), testPredicate);\n+    }\n+\n+    public void testGetSet() {\n+        final PredicatedSortedSet<E> set = makeTestSet();\n+        assertTrue(\"returned set should not be null\", set.decorated() != null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAdd() {\n+        final SortedSet<E> set = makeTestSet();\n+        final String testString = \"B\";\n+        try {\n+            set.add((E) testString);\n+            fail(\"Should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\",\n+         !set.contains(testString));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIllegalAddAll() {\n+        final SortedSet<E> set = makeTestSet();\n+        final Set<E> elements = new TreeSet<E>();\n+        elements.add((E) \"Aone\");\n+        elements.add((E) \"Atwo\");\n+        elements.add((E) \"Bthree\");\n+        elements.add((E) \"Afour\");\n+        try {\n+            set.addAll(elements);\n+            fail(\"Should fail string predicate.\");\n+        } catch (final IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Aone\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Atwo\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Bthree\"));\n+        assertTrue(\"Set shouldn't contain illegal element\", !set.contains(\"Afour\"));\n+    }\n+\n+    public void testComparator() {\n+        final SortedSet<E> set = makeTestSet();\n+        final Comparator<? super E> c = set.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSortedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/PredicatedSortedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractSetTest} for exercising the {@link TransformedSet}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSetTest<E> extends AbstractSetTest<E> {\n+\n+    public TransformedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public Set<E> makeConfirmedCollection() {\n+        return new HashSet<E>();\n+    }\n+\n+    @Override\n+    public Set<E> makeConfirmedFullCollection() {\n+        final Set<E> set = new HashSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return set;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> makeObject() {\n+        return TransformedSet.transformingSet(new HashSet<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<E> makeFullCollection() {\n+        final Set<E> list = new HashSet<E>();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return TransformedSet.transformingSet(list,\n+                (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedSet() {\n+        final Set<E> set = TransformedSet.transformingSet(new HashSet<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, set.size());\n+        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            set.add(els[i]);\n+            assertEquals(i + 1, set.size());\n+            assertEquals(true, set.contains(new Integer((String) els[i])));\n+            assertEquals(false, set.contains(els[i]));\n+        }\n+\n+        assertEquals(false, set.remove(els[0]));\n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+\n+    }\n+\n+    public void testTransformedSet_decorateTransform() {\n+        final Set<Object> originalSet = new HashSet<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalSet.add(el);\n+        }\n+        final Set<?> set = TransformedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, set.size());\n+        for (final Object el : els) {\n+            assertEquals(true, set.contains(new Integer((String) el)));\n+            assertEquals(false, set.contains(el));\n+        }\n+        \n+        assertEquals(false, set.remove(els[0]));\n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.TreeSet;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractSortedSetTest} for exercising the {@link TransformedSortedSet}\n+ * implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TransformedSortedSetTest<E> extends AbstractSortedSetTest<E> {\n+\n+    public TransformedSortedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TransformedSortedSetTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedSet<E> makeObject() {\n+        return TransformedSortedSet.transformingSortedSet(new TreeSet<E>(), (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedSet<E> makeFullCollection() {\n+        final SortedSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return TransformedSortedSet.transformingSortedSet(set, (Transformer<E, E>) TransformedCollectionTest.NOOP_TRANSFORMER);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedSet() {\n+        final SortedSet<E> set = TransformedSortedSet.transformingSortedSet(new TreeSet<E>(),\n+                (Transformer<E, E>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, set.size());\n+        final E[] els = (E[]) new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+        for (int i = 0; i < els.length; i++) {\n+            set.add(els[i]);\n+            assertEquals(i + 1, set.size());\n+            assertEquals(true, set.contains(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+    }\n+\n+    public void testTransformedSet_decorateTransform() {\n+        final Set<Object> originalSet = new TreeSet<Object>();\n+        final Object[] els = new Object[] {\"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\"};\n+        for (final Object el : els) {\n+            originalSet.add(el);\n+        }\n+        final Set<?> set = TransformedSortedSet.transformedSet(originalSet, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(els.length, set.size());\n+        for (final Object el : els) {\n+            assertEquals(true, set.contains(new Integer((String) el)));\n+        }\n+        \n+        assertEquals(true, set.remove(new Integer((String) els[0])));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSortedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedSortedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractSetTest} for exercising the\n+ * {@link UnmodifiableSet} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableSetTest<E> extends AbstractSetTest<E> {\n+\n+    public UnmodifiableSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableSetTest.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+    @Override\n+    public Set<E> makeObject() {\n+        return UnmodifiableSet.unmodifiableSet(new HashSet<E>());\n+    }\n+\n+    @Override\n+    public Set<E> makeFullCollection() {\n+        final HashSet<E> set = new HashSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.set;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractSortedSetTest} for exercising the\n+ * {@link UnmodifiableSortedSet} implementation.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableSortedSetTest<E> extends AbstractSortedSetTest<E> {\n+    protected UnmodifiableSortedSet<E> set = null;\n+    protected ArrayList<E> array = null;\n+\n+    public UnmodifiableSortedSetTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableSortedSetTest.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+    @Override\n+    public SortedSet<E> makeObject() {\n+        return UnmodifiableSortedSet.unmodifiableSortedSet(new TreeSet<E>());\n+    }\n+\n+    @Override\n+    public UnmodifiableSortedSet<E> makeFullCollection() {\n+        final TreeSet<E> set = new TreeSet<E>();\n+        set.addAll(Arrays.asList(getFullElements()));\n+        return (UnmodifiableSortedSet<E>) UnmodifiableSortedSet.unmodifiableSortedSet(set);\n+    }\n+\n+    @Override\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //--------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    protected void setupSet() {\n+        set = makeFullCollection();\n+        array = new ArrayList<E>();\n+        array.add((E) new Integer(1));\n+    }\n+\n+    /**\n+     * Verify that base set and subsets are not modifiable\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testUnmodifiable() {\n+        setupSet();\n+        verifyUnmodifiable(set);\n+        verifyUnmodifiable(set.headSet((E) new Integer(1)));\n+        verifyUnmodifiable(set.tailSet((E) new Integer(1)));\n+        verifyUnmodifiable(set.subSet((E) new Integer(1), (E) new Integer(3)));\n+    }\n+\n+    /**\n+     * Verifies that a set is not modifiable\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void verifyUnmodifiable(final Set<E> set) {\n+        try {\n+            set.add((E) \"value\");\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.addAll(new TreeSet<E>());\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.clear();\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.remove(\"x\");\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.removeAll(array);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+        try {\n+            set.retainAll(array);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (final UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testComparator() {\n+        setupSet();\n+        final Comparator<? super E> c = set.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSortedSet.emptyCollection.version4.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/UnmodifiableSortedSet.fullCollection.version4.obj\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/splitmap/TransformedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.splitmap;\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.functors.NOPTransformer;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * TODO fix version, add Serialization tests\n+ * FIXME the serialization result is stored as TransformedSplitMap.versionX.obj\n+ * to distinguish it from the one for o.a.c.c.map.TransformedMap.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TransformedMapTest extends BulkTest {\n+\n+    private final Transformer<Integer, String> intToString = new Transformer<Integer, String>() {\n+        public String transform(final Integer input) {\n+            return String.valueOf(input);\n+        }\n+    };\n+\n+    private final Transformer<Object, Class<?>> objectToClass = new Transformer<Object, Class<?>>() {\n+        public java.lang.Class<?> transform(final Object input) {\n+            return input == null ? null : input.getClass();\n+        }\n+    };\n+\n+    private final Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(final String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public TransformedMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testTransformedMap() {\n+        final TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.transformingMap(\n+                new HashMap<String, Class<?>>(), intToString, objectToClass);\n+\n+        final Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n+        final Object[] v = new Object[] { \"\", new Object(), new HashMap<Object, Object>(), 0, BigInteger.TEN, null,\n+                new Object[0] };\n+\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < k.length; i++) {\n+            map.put(k[i], v[i]);\n+            assertEquals(i + 1, map.size());\n+            assertTrue(map.containsKey(intToString.transform(k[i])));\n+            assertFalse(map.containsKey(k[i]));\n+            assertTrue(map.containsValue(objectToClass.transform(v[i])));\n+            assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));\n+            assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));\n+        }\n+\n+        int sz = map.size();\n+        assertEquals(null, map.remove(k[0]));\n+        assertEquals(sz, map.size());\n+        assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n+        assertEquals(--sz, map.size());\n+\n+        final TransformedMap<String, String, String, Integer> map2 = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map2.size());\n+        for (int i = 0; i < 6; i++) {\n+            map2.put(String.valueOf(i), String.valueOf(i));\n+            assertEquals(i + 1, map2.size());\n+            assertTrue(map2.containsValue(i));\n+            assertFalse(map2.containsValue(String.valueOf(i)));\n+            assertTrue(map2.containsKey(String.valueOf(i)));\n+            assertEquals(i, map2.get(String.valueOf(i)).intValue());\n+        }\n+\n+        int sz2 = map2.size();\n+        assertEquals(Integer.valueOf(0), map2.remove(\"0\"));\n+        assertEquals(--sz2, map2.size());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testMapIterator() {\n+        final TransformedMap<String, String, String, Integer> map = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < 6; i++) {\n+            map.put(String.valueOf(i), String.valueOf(i));\n+        }\n+\n+        for (final MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n+            final String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(map.get(k), it.getValue());\n+        }\n+    }\n+\n+    public void testEmptyMap() throws IOException, ClassNotFoundException {\n+        final TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+\n+        final ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"/TransformedSplitMap.emptyCollection.version4.obj\" ) );\n+        final Object readObject = in.readObject();\n+        in.close();\n+\n+        final TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        assertTrue( \"Map should be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+\n+    public void testFullMap() throws IOException, ClassNotFoundException {\n+        final TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+        map.put( \"a\", \"b\" );\n+        map.put( \"c\", \"d\" );\n+        map.put( \"e\", \"f\" );\n+        map.put( \"g\", \"h\" );\n+\n+        final ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"TransformedSplitMap.fullCollection.version4.obj\" ) );\n+        final Object readObject = in.readObject();\n+        in.close();\n+\n+        final TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        assertFalse( \"Map should not be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+\n+//    public void testCreate() throws IOException {\n+//        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+//                new HashMap<String, String>(),\n+//                NOPTransformer.<String>nopTransformer(),\n+//                NOPTransformer.<String>nopTransformer() );\n+//\n+//        ObjectOutputStream out = new ObjectOutputStream(\n+//                new FileOutputStream( \"src/test/resources/data/test/TransformedSplitMap.emptyCollection.version4.obj\" ) );\n+//        out.writeObject( map );\n+//\n+//        map.put( \"a\", \"b\" );\n+//        map.put( \"c\", \"d\" );\n+//        map.put( \"e\", \"f\" );\n+//        map.put( \"g\", \"h\" );\n+//\n+//        out = new ObjectOutputStream(\n+//                new FileOutputStream( \"src/test/resources/data/test/TransformedSplitMap.fullCollection.version4.obj\" ) );\n+//        out.writeObject( map );\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/trie/ByteArrayKeyAnalyzerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ByteArrayKeyAnalyzerTest {\n+\n+    private static final int SIZE = 20000;\n+    \n+    @Test\n+    public void bitSet() {\n+        final byte[] key = toByteArray(\"10100110\", 2);\n+        final ByteArrayKeyAnalyzer ka = new ByteArrayKeyAnalyzer(key.length * 8);\n+        final int length = ka.lengthInBits(key);\n+        \n+        Assert.assertTrue(ka.isBitSet(key, 0, length));\n+        Assert.assertFalse(ka.isBitSet(key, 1, length));\n+        Assert.assertTrue(ka.isBitSet(key, 2, length));\n+        Assert.assertFalse(ka.isBitSet(key, 3, length));\n+        Assert.assertFalse(ka.isBitSet(key, 4, length));\n+        Assert.assertTrue(ka.isBitSet(key, 5, length));\n+        Assert.assertTrue(ka.isBitSet(key, 6, length));\n+        Assert.assertFalse(ka.isBitSet(key, 7, length));\n+    }\n+    \n+    @Test\n+    public void keys() {\n+        final PatriciaTrie<byte[], BigInteger> trie\n+            = new PatriciaTrie<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n+        \n+        final Map<byte[], BigInteger> map \n+            = new TreeMap<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n+        \n+        for (int i = 0; i < SIZE; i++) {\n+            final BigInteger value = BigInteger.valueOf(i);\n+            final byte[] key = toByteArray(value);\n+            \n+            final BigInteger existing = trie.put(key, value);\n+            Assert.assertNull(existing);\n+            \n+            map.put(key, value);\n+        }\n+        \n+        Assert.assertEquals(map.size(), trie.size());\n+        \n+        for (final byte[] key : map.keySet()) {\n+            final BigInteger expected = new BigInteger(1, key);\n+            final BigInteger value = trie.get(key);\n+            \n+            Assert.assertEquals(expected, value);\n+        }\n+    }\n+    \n+    @Test\n+    public void prefix() {\n+        final byte[] prefix   = toByteArray(\"00001010\", 2);\n+        final byte[] key1     = toByteArray(\"11001010\", 2);\n+        final byte[] key2     = toByteArray(\"10101100\", 2);\n+        \n+        final ByteArrayKeyAnalyzer keyAnalyzer = new ByteArrayKeyAnalyzer(key1.length * 8);\n+        \n+        final int prefixLength = keyAnalyzer.lengthInBits(prefix);\n+            \n+        Assert.assertFalse(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key1));\n+        Assert.assertTrue(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key2));\n+    }\n+    \n+    private static byte[] toByteArray(final String value, final int radix) {\n+        return toByteArray(Long.parseLong(value, radix));\n+    }\n+    \n+    private static byte[] toByteArray(final long value) {\n+        return toByteArray(BigInteger.valueOf(value));\n+    }\n+    \n+    private static byte[] toByteArray(final BigInteger value) {\n+        final byte[] src = value.toByteArray();\n+        if (src.length <= 1) {\n+            return src;\n+        }\n+        \n+        if (src[0] != 0) {\n+            return src;\n+        }\n+        \n+        final byte[] dst = new byte[src.length-1];\n+        System.arraycopy(src, 1, dst, 0, dst.length);\n+        return dst;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.SortedMap;\n+import java.util.StringTokenizer;\n+import java.util.TreeMap;\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.collections4.Trie.Cursor;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PatriciaTrieTest {\n+    \n+    @Test\n+    public void testSimple() {\n+        final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n+        Assert.assertTrue(intTrie.isEmpty());\n+        Assert.assertEquals(0, intTrie.size());\n+        \n+        intTrie.put(1, \"One\");\n+        Assert.assertFalse(intTrie.isEmpty());\n+        Assert.assertEquals(1, intTrie.size());\n+        \n+        Assert.assertEquals(\"One\", intTrie.remove(1));\n+        Assert.assertNull(intTrie.remove(1));\n+        Assert.assertTrue(intTrie.isEmpty());\n+        Assert.assertEquals(0, intTrie.size());\n+        \n+        intTrie.put(1, \"One\");\n+        Assert.assertEquals(\"One\", intTrie.get(1));\n+        Assert.assertEquals(\"One\", intTrie.put(1, \"NotOne\"));\n+        Assert.assertEquals(1, intTrie.size());\n+        Assert.assertEquals(\"NotOne\", intTrie.get(1));\n+        Assert.assertEquals(\"NotOne\", intTrie.remove(1));\n+        Assert.assertNull(intTrie.put(1, \"One\"));\n+    }\n+    \n+    @Test\n+    public void testCeilingEntry() {\n+        final PatriciaTrie<Character, String> charTrie \n+            = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        \n+        final Object[] results = new Object[] {\n+            'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+            'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+            'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+            'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+            'z', \"z\"\n+        };\n+        \n+        for(int i = 0; i < results.length; i++) {\n+            final Map.Entry<Character, String> found = charTrie.ceilingEntry((Character)results[i]);\n+            Assert.assertNotNull(found);\n+            Assert.assertEquals(results[i], found.getKey());\n+            Assert.assertEquals(results[++i], found.getValue());\n+        }\n+        \n+        // Remove some & try again...\n+        charTrie.remove('a');\n+        charTrie.remove('z');\n+        charTrie.remove('q');\n+        charTrie.remove('l');\n+        charTrie.remove('p');\n+        charTrie.remove('m');\n+        charTrie.remove('u');\n+        \n+        Map.Entry<Character, String> found = charTrie.ceilingEntry('u');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'v', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('a');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'b', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('z');\n+        Assert.assertNull(found);\n+        \n+        found = charTrie.ceilingEntry('q');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'r', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('l');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'n', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('p');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'r', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('m');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'n', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('\\0');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'b', found.getKey());\n+        \n+        charTrie.put('\\0', \"\");\n+        found = charTrie.ceilingEntry('\\0');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'\\0', found.getKey());      \n+    }\n+    \n+    @Test\n+    public void testLowerEntry() {\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        \n+        final Object[] results = new Object[] {\n+            'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+            'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+            'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+            'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+            'z', \"z\"\n+        };\n+        \n+        for(int i = 0; i < results.length; i+=2) {\n+            //System.out.println(\"Looking for: \" + results[i]);\n+            final Map.Entry<Character, String> found = charTrie.lowerEntry((Character)results[i]);\n+            if(i == 0) {\n+                Assert.assertNull(found);\n+            } else {\n+                Assert.assertNotNull(found);\n+                Assert.assertEquals(results[i-2], found.getKey());\n+                Assert.assertEquals(results[i-1], found.getValue());\n+            }\n+        }\n+\n+        Map.Entry<Character, String> found = charTrie.lowerEntry((char)('z' + 1));\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'z', found.getKey());\n+        \n+        // Remove some & try again...\n+        charTrie.remove('a');\n+        charTrie.remove('z');\n+        charTrie.remove('q');\n+        charTrie.remove('l');\n+        charTrie.remove('p');\n+        charTrie.remove('m');\n+        charTrie.remove('u');\n+        \n+        found = charTrie.lowerEntry('u');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'t', found.getKey());\n+        \n+        found = charTrie.lowerEntry('v');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'t', found.getKey());\n+        \n+        found = charTrie.lowerEntry('a');\n+        Assert.assertNull(found);\n+        \n+        found = charTrie.lowerEntry('z');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'y', found.getKey());\n+        \n+        found = charTrie.lowerEntry((char)('z'+1));\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'y', found.getKey());\n+        \n+        found = charTrie.lowerEntry('q');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'o', found.getKey());\n+        \n+        found = charTrie.lowerEntry('r');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'o', found.getKey());\n+        \n+        found = charTrie.lowerEntry('p');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'o', found.getKey());\n+        \n+        found = charTrie.lowerEntry('l');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'k', found.getKey());\n+        \n+        found = charTrie.lowerEntry('m');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'k', found.getKey());\n+        \n+        found = charTrie.lowerEntry('\\0');\n+        Assert.assertNull(found);\n+        \n+        charTrie.put('\\0', \"\");\n+        found = charTrie.lowerEntry('\\0');\n+        Assert.assertNull(found);      \n+    }\n+    \n+    @Test\n+    public void testIteration() {\n+        final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n+        intTrie.put(1, \"One\");\n+        intTrie.put(5, \"Five\");\n+        intTrie.put(4, \"Four\");\n+        intTrie.put(2, \"Two\");\n+        intTrie.put(3, \"Three\");\n+        intTrie.put(15, \"Fifteen\");\n+        intTrie.put(13, \"Thirteen\");\n+        intTrie.put(14, \"Fourteen\");\n+        intTrie.put(16, \"Sixteen\");\n+        \n+        TestCursor cursor = new TestCursor(\n+                1, \"One\", 2, \"Two\", 3, \"Three\", 4, \"Four\", 5, \"Five\", 13, \"Thirteen\",\n+                14, \"Fourteen\", 15, \"Fifteen\", 16, \"Sixteen\");\n+\n+        cursor.starting();\n+        intTrie.traverse(cursor);\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (final Map.Entry<Integer, String> entry : intTrie.entrySet()) {\n+            cursor.select(entry);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (final Integer integer : intTrie.keySet()) {\n+            cursor.checkKey(integer);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (final String string : intTrie.values()) {\n+            cursor.checkValue(string);\n+        }\n+        cursor.finished();\n+\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'z', \"z\");\n+        \n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+\n+        cursor.starting();\n+        for (final Map.Entry<Character, String> entry : charTrie.entrySet()) {\n+            cursor.select(entry);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (final Character character : charTrie.keySet()) {\n+            cursor.checkKey(character);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (final String string : charTrie.values()) {\n+            cursor.checkValue(string);\n+        }\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testSelect() {\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        final TestCursor cursor = new TestCursor(\n+                'd', \"d\", 'e', \"e\", 'f', \"f\", 'g', \"g\",\n+                'a', \"a\", 'b', \"b\", 'c', \"c\",  \n+                'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'h', \"h\", 'i', \"i\", 'j', \"j\", 'k', \"k\", \n+                't', \"t\", 'u', \"u\", 'v', \"v\", 'w', \"w\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", \n+                'x', \"x\", 'y', \"y\", 'z', \"z\");\n+                \n+        Assert.assertEquals(26, charTrie.size());\n+        \n+        cursor.starting();\n+        charTrie.select('d', cursor);\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testTraverseCursorRemove() {\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        final TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'z', \"z\");\n+        \n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+        \n+        // Test removing both an internal & external node.\n+        // 'm' is an example External node in this Trie, and 'p' is an internal.\n+        \n+        Assert.assertEquals(26, charTrie.size());\n+        \n+        final Object[] toRemove = new Object[] { 'g', 'd', 'e', 'm', 'p', 'q', 'r', 's' };\n+        cursor.addToRemove(toRemove);\n+        \n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+            \n+        Assert.assertEquals(26 - toRemove.length, charTrie.size());\n+\n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (final Entry<Character, String> entry : charTrie.entrySet()) {\n+            cursor.select(entry);\n+            if (Arrays.asList(toRemove).contains(entry.getKey())) {\n+                Assert.fail(\"got an: \" + entry);\n+            }\n+        }\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testIteratorRemove() {\n+        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        final TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'z', \"z\");\n+        \n+        // Test removing both an internal & external node.\n+        // 'm' is an example External node in this Trie, and 'p' is an internal.\n+        \n+        Assert.assertEquals(26, charTrie.size());\n+        \n+        final Object[] toRemove = new Object[] { 'e', 'm', 'p', 'q', 'r', 's' };\n+        \n+        cursor.starting();\n+        for(final Iterator<Map.Entry<Character, String>> i = charTrie.entrySet().iterator(); i.hasNext(); ) {\n+            final Map.Entry<Character,String> entry = i.next();\n+            cursor.select(entry);\n+            if(Arrays.asList(toRemove).contains(entry.getKey())) {\n+                i.remove();            \n+            }\n+        }\n+        cursor.finished();\n+            \n+        Assert.assertEquals(26 - toRemove.length, charTrie.size());\n+        \n+        cursor.remove(toRemove);\n+\n+        cursor.starting();\n+        for (final Entry<Character, String> entry : charTrie.entrySet()) {\n+            cursor.select(entry);\n+            if (Arrays.asList(toRemove).contains(entry.getKey())) {\n+                Assert.fail(\"got an: \" + entry);\n+            }\n+        }\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testHamlet() throws Exception {\n+        // Make sure that Hamlet is read & stored in the same order as a SortedSet.\n+        final List<String> original = new ArrayList<String>();\n+        final List<String> control = new ArrayList<String>();\n+        final SortedMap<String, String> sortedControl = new TreeMap<String, String>();\n+        final PatriciaTrie<String, String> trie = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final InputStream in = getClass().getResourceAsStream(\"hamlet.txt\");\n+        final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n+        \n+        String read = null;\n+        while( (read = reader.readLine()) != null) {\n+            final StringTokenizer st = new StringTokenizer(read);\n+            while(st.hasMoreTokens()) {\n+                final String token = st.nextToken();\n+                original.add(token);\n+                sortedControl.put(token, token);\n+                trie.put(token, token);\n+            }\n+        }\n+        control.addAll(sortedControl.values());\n+\n+        Assert.assertEquals(control.size(), sortedControl.size());\n+        Assert.assertEquals(sortedControl.size(), trie.size());\n+        Iterator<String> iter = trie.values().iterator();\n+        for (final String aControl : control) {\n+            Assert.assertEquals(aControl, iter.next());\n+        }\n+        \n+        final Random rnd = new Random();\n+        int item = 0;\n+        iter = trie.values().iterator();\n+        int removed = 0;\n+        for(; item < control.size(); item++) {\n+            Assert.assertEquals(control.get(item), iter.next());\n+            if(rnd.nextBoolean()) {\n+                iter.remove();\n+                removed++;\n+            }\n+        }\n+        \n+        Assert.assertEquals(control.size(), item);\n+        Assert.assertTrue(removed > 0);\n+        Assert.assertEquals(control.size(), trie.size() + removed);\n+        \n+        // reset hamlet\n+        trie.clear();\n+        for (final String anOriginal : original) {\n+            trie.put(anOriginal, anOriginal);\n+        }\n+        \n+        assertEqualArrays(sortedControl.values().toArray(), trie.values().toArray());\n+        assertEqualArrays(sortedControl.keySet().toArray(), trie.keySet().toArray());\n+        assertEqualArrays(sortedControl.entrySet().toArray(), trie.entrySet().toArray());\n+        \n+        Assert.assertEquals(sortedControl.firstKey(), trie.firstKey());\n+        Assert.assertEquals(sortedControl.lastKey(), trie.lastKey());\n+        \n+        SortedMap<String, String> sub = trie.headMap(control.get(523));\n+        Assert.assertEquals(523, sub.size());\n+        for(int i = 0; i < control.size(); i++) {\n+            if(i < 523) {\n+                Assert.assertTrue(sub.containsKey(control.get(i)));\n+            } else {\n+                Assert.assertFalse(sub.containsKey(control.get(i)));\n+            }\n+        }\n+        // Too slow to check values on all, so just do a few.\n+        Assert.assertTrue(sub.containsValue(control.get(522)));\n+        Assert.assertFalse(sub.containsValue(control.get(523)));\n+        Assert.assertFalse(sub.containsValue(control.get(524)));\n+        \n+        try {\n+            sub.headMap(control.get(524));\n+            Assert.fail(\"should have thrown IAE\");\n+        } catch(final IllegalArgumentException expected) {}\n+        \n+        Assert.assertEquals(sub.lastKey(), control.get(522));\n+        Assert.assertEquals(sub.firstKey(), control.get(0));\n+        \n+        sub = sub.tailMap(control.get(234));\n+        Assert.assertEquals(289, sub.size());\n+        Assert.assertEquals(control.get(234), sub.firstKey());\n+        Assert.assertEquals(control.get(522), sub.lastKey());\n+        for(int i = 0; i < control.size(); i++) {\n+            if(i < 523 && i > 233) {\n+                Assert.assertTrue(sub.containsKey(control.get(i)));\n+            } else {\n+                Assert.assertFalse(sub.containsKey(control.get(i)));\n+            }\n+        }\n+\n+        try {\n+            sub.tailMap(control.get(232));\n+            Assert.fail(\"should have thrown IAE\");\n+        } catch(final IllegalArgumentException expected) {}\n+        \n+        sub = sub.subMap(control.get(300), control.get(400));\n+        Assert.assertEquals(100, sub.size());\n+        Assert.assertEquals(control.get(300), sub.firstKey());\n+        Assert.assertEquals(control.get(399), sub.lastKey());\n+        \n+        for(int i = 0; i < control.size(); i++) {\n+            if(i < 400 && i > 299) {\n+                Assert.assertTrue(sub.containsKey(control.get(i)));\n+            } else {\n+                Assert.assertFalse(sub.containsKey(control.get(i)));\n+            }\n+        }\n+    }\n+    \n+    @Test\n+    public void testPrefixedBy() {\n+        final PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final String[] keys = new String[]{\n+                \"\", \n+                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n+                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n+                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n+                \"Amma\"\n+        };\n+\n+        for (final String key : keys) {\n+            trie.put(key, key);\n+        }\n+        \n+        SortedMap<String, String> map;\n+        Iterator<String> iterator;\n+        Iterator<Map.Entry<String, String>> entryIterator;\n+        Map.Entry<String, String> entry;\n+        \n+        map = trie.getPrefixedBy(\"Al\");\n+        Assert.assertEquals(8, map.size());\n+        Assert.assertEquals(\"Alabama\", map.firstKey());\n+        Assert.assertEquals(\"Alliese\", map.lastKey());\n+        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n+        Assert.assertNotNull(trie.get(\"Xavier\"));\n+        Assert.assertNull(map.get(\"Xavier\"));\n+        Assert.assertNull(trie.get(\"Alice\"));\n+        Assert.assertNull(map.get(\"Alice\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Alabama\", iterator.next());\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Alien\", iterator.next());\n+        Assert.assertEquals(\"Allie\", iterator.next());\n+        Assert.assertEquals(\"Alliese\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Albert\");\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        Assert.assertEquals(4, map.size());\n+        Assert.assertEquals(\"Albert\", map.firstKey());\n+        Assert.assertEquals(\"Alberts\", map.lastKey());\n+        Assert.assertNull(trie.get(\"Albertz\"));\n+        map.put(\"Albertz\", \"Albertz\");\n+        Assert.assertEquals(\"Albertz\", trie.get(\"Albertz\"));\n+        Assert.assertEquals(5, map.size());\n+        Assert.assertEquals(\"Albertz\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Albertz\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        Assert.assertEquals(\"Albertz\", map.remove(\"Albertz\"));\n+        \n+        map = trie.getPrefixedBy(\"Alberto\");\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertEquals(\"Alberto\", map.firstKey());\n+        Assert.assertEquals(\"Albertoo\", map.lastKey());\n+        entryIterator = map.entrySet().iterator();\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Alberto\", entry.getKey());\n+        Assert.assertEquals(\"Alberto\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoo\", entry.getKey());\n+        Assert.assertEquals(\"Albertoo\", entry.getValue());\n+        Assert.assertFalse(entryIterator.hasNext());\n+        trie.put(\"Albertoad\", \"Albertoad\");\n+        Assert.assertEquals(3, map.size());\n+        Assert.assertEquals(\"Alberto\", map.firstKey());\n+        Assert.assertEquals(\"Albertoo\", map.lastKey());\n+        entryIterator = map.entrySet().iterator();\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Alberto\", entry.getKey());\n+        Assert.assertEquals(\"Alberto\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoad\", entry.getKey());\n+        Assert.assertEquals(\"Albertoad\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoo\", entry.getKey());\n+        Assert.assertEquals(\"Albertoo\", entry.getValue());\n+        Assert.assertFalse(entryIterator.hasNext());\n+        Assert.assertEquals(\"Albertoo\", trie.remove(\"Albertoo\"));\n+        Assert.assertEquals(\"Alberto\", map.firstKey());\n+        Assert.assertEquals(\"Albertoad\", map.lastKey());\n+        Assert.assertEquals(2, map.size());\n+        entryIterator = map.entrySet().iterator();\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Alberto\", entry.getKey());\n+        Assert.assertEquals(\"Alberto\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoad\", entry.getKey());\n+        Assert.assertEquals(\"Albertoad\", entry.getValue());\n+        Assert.assertFalse(entryIterator.hasNext());\n+        Assert.assertEquals(\"Albertoad\", trie.remove(\"Albertoad\"));\n+        trie.put(\"Albertoo\", \"Albertoo\");\n+        \n+        map = trie.getPrefixedBy(\"X\");\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertFalse(map.containsKey(\"Albert\"));\n+        Assert.assertTrue(map.containsKey(\"Xavier\"));\n+        Assert.assertFalse(map.containsKey(\"Xalan\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Xavier\", iterator.next());\n+        Assert.assertEquals(\"XyZ\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"An\");\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Anna\", map.firstKey());\n+        Assert.assertEquals(\"Anna\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Anna\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Ban\");\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Banane\", map.firstKey());\n+        Assert.assertEquals(\"Banane\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Banane\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Am\");\n+        Assert.assertFalse(map.isEmpty());\n+        Assert.assertEquals(3, map.size());\n+        Assert.assertEquals(\"Amber\", trie.remove(\"Amber\"));\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Amma\", iterator.next());\n+        Assert.assertEquals(\"Ammun\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        iterator = map.keySet().iterator();\n+        map.put(\"Amber\", \"Amber\");\n+        Assert.assertEquals(3, map.size());\n+        try {\n+            iterator.next();\n+            Assert.fail(\"CME expected\");\n+        } catch(final ConcurrentModificationException expected) {}\n+        Assert.assertEquals(\"Amber\", map.firstKey());\n+        Assert.assertEquals(\"Ammun\", map.lastKey());\n+        \n+        map = trie.getPrefixedBy(\"Ak\\0\");\n+        Assert.assertTrue(map.isEmpty());\n+        \n+        map = trie.getPrefixedBy(\"Ak\");\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertEquals(\"Akka\", map.firstKey());\n+        Assert.assertEquals(\"Akko\", map.lastKey());\n+        map.put(\"Ak\", \"Ak\");\n+        Assert.assertEquals(\"Ak\", map.firstKey());\n+        Assert.assertEquals(\"Akko\", map.lastKey());\n+        Assert.assertEquals(3, map.size());\n+        trie.put(\"Al\", \"Al\");\n+        Assert.assertEquals(3, map.size());\n+        Assert.assertEquals(\"Ak\", map.remove(\"Ak\"));\n+        Assert.assertEquals(\"Akka\", map.firstKey());\n+        Assert.assertEquals(\"Akko\", map.lastKey());\n+        Assert.assertEquals(2, map.size());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Akka\", iterator.next());\n+        Assert.assertEquals(\"Akko\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        Assert.assertEquals(\"Al\", trie.remove(\"Al\"));\n+        \n+        map = trie.getPrefixedBy(\"Akka\");\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Akka\", map.firstKey());\n+        Assert.assertEquals(\"Akka\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Akka\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Ab\");\n+        Assert.assertTrue(map.isEmpty());\n+        Assert.assertEquals(0, map.size());\n+        try {\n+            final Object o = map.firstKey();\n+            Assert.fail(\"got a first key: \" + o);\n+        } catch(final NoSuchElementException nsee) {}\n+        try {\n+            final Object o = map.lastKey();\n+            Assert.fail(\"got a last key: \" + o);\n+        } catch(final NoSuchElementException nsee) {}\n+        iterator = map.values().iterator();\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Albertooo\");\n+        Assert.assertTrue(map.isEmpty());\n+        Assert.assertEquals(0, map.size());\n+        try {\n+            final Object o = map.firstKey();\n+            Assert.fail(\"got a first key: \" + o);\n+        } catch(final NoSuchElementException nsee) {}\n+        try {\n+            final Object o = map.lastKey();\n+            Assert.fail(\"got a last key: \" + o);\n+        } catch(final NoSuchElementException nsee) {}\n+        iterator = map.values().iterator();\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"\");\n+        Assert.assertSame(trie, map); // stricter than necessary, but a good check\n+        \n+        map = trie.getPrefixedBy(\"\\0\");\n+        Assert.assertTrue(map.isEmpty());\n+        Assert.assertEquals(0, map.size());\n+        try {\n+            final Object o = map.firstKey();\n+            Assert.fail(\"got a first key: \" + o);\n+        } catch(final NoSuchElementException nsee) {}\n+        try {\n+            final Object o = map.lastKey();\n+            Assert.fail(\"got a last key: \" + o);\n+        } catch(final NoSuchElementException nsee) {}\n+        iterator = map.values().iterator();\n+        Assert.assertFalse(iterator.hasNext());\n+    }\n+    \n+    @Test\n+    public void testPrefixByOffsetAndLength() {\n+        final PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final String[] keys = new String[]{\n+                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n+                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n+                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n+                \"Amma\"\n+        };\n+    \n+        for (final String key : keys) {\n+            trie.put(key, key);\n+        }\n+        \n+        SortedMap<String, String> map;\n+        Iterator<String> iterator;\n+        \n+        map = trie.getPrefixedBy(\"Alice\", 2);\n+        Assert.assertEquals(8, map.size());\n+        Assert.assertEquals(\"Alabama\", map.firstKey());\n+        Assert.assertEquals(\"Alliese\", map.lastKey());\n+        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n+        Assert.assertNotNull(trie.get(\"Xavier\"));\n+        Assert.assertNull(map.get(\"Xavier\"));\n+        Assert.assertNull(trie.get(\"Alice\"));\n+        Assert.assertNull(map.get(\"Alice\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Alabama\", iterator.next());\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Alien\", iterator.next());\n+        Assert.assertEquals(\"Allie\", iterator.next());\n+        Assert.assertEquals(\"Alliese\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"BAlice\", 1, 2);\n+        Assert.assertEquals(8, map.size());\n+        Assert.assertEquals(\"Alabama\", map.firstKey());\n+        Assert.assertEquals(\"Alliese\", map.lastKey());\n+        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n+        Assert.assertNotNull(trie.get(\"Xavier\"));\n+        Assert.assertNull(map.get(\"Xavier\"));\n+        Assert.assertNull(trie.get(\"Alice\"));\n+        Assert.assertNull(map.get(\"Alice\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Alabama\", iterator.next());\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Alien\", iterator.next());\n+        Assert.assertEquals(\"Allie\", iterator.next());\n+        Assert.assertEquals(\"Alliese\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+    }\n+    \n+    @Test\n+    public void testPrefixedByRemoval() {\n+        final PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final String[] keys = new String[]{\n+                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n+                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n+                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n+                \"Amma\"\n+        };\n+\n+        for (final String key : keys) {\n+            trie.put(key, key);\n+        }\n+        \n+        SortedMap<String, String> map = trie.getPrefixedBy(\"Al\");\n+        Assert.assertEquals(8, map.size());\n+        Iterator<String> iter = map.keySet().iterator();\n+        Assert.assertEquals(\"Alabama\", iter.next());\n+        Assert.assertEquals(\"Albert\", iter.next());\n+        Assert.assertEquals(\"Alberto\", iter.next());\n+        Assert.assertEquals(\"Albertoo\", iter.next());\n+        Assert.assertEquals(\"Alberts\", iter.next());\n+        Assert.assertEquals(\"Alien\", iter.next());\n+        iter.remove();\n+        Assert.assertEquals(7, map.size());\n+        Assert.assertEquals(\"Allie\", iter.next());\n+        Assert.assertEquals(\"Alliese\", iter.next());\n+        Assert.assertFalse(iter.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Ak\");\n+        Assert.assertEquals(2, map.size());\n+        iter = map.keySet().iterator();\n+        Assert.assertEquals(\"Akka\", iter.next());\n+        iter.remove();\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Akko\", iter.next());\n+        if(iter.hasNext()) {\n+            Assert.fail(\"shouldn't have next (but was: \" + iter.next() + \")\");\n+        }\n+        Assert.assertFalse(iter.hasNext());\n+    }\n+\n+    @Test\n+    public void testTraverseWithAllNullBitKey() {\n+        final PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        //\n+        // One entry in the Trie\n+        // Entry is stored at the root\n+        //\n+        \n+        // trie.put(\"\", \"All Bits Are Zero\");\n+        trie.put(\"\\0\", \"All Bits Are Zero\");\n+        \n+        //\n+        //  / (\"\")   <-- root\n+        //  \\_/  \\\n+        //       null\n+        //\n+        \n+        final List<String> strings = new ArrayList<String>();\n+        trie.traverse(new Cursor<String, String>() {\n+            public Decision select(final Entry<? extends String, ? extends String> entry) {\n+                strings.add(entry.getValue());\n+                return Decision.CONTINUE;\n+            }\n+        });\n+        \n+        Assert.assertEquals(1, strings.size());\n+        \n+        strings.clear();\n+        for (final String s : trie.values()) {\n+            strings.add(s);\n+        }\n+        Assert.assertEquals(1, strings.size());\n+    }\n+    \n+    @Test\n+    public void testSelectWithAllNullBitKey() {\n+        final PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        // trie.put(\"\", \"All Bits Are Zero\");\n+        trie.put(\"\\0\", \"All Bits Are Zero\");\n+        \n+        final List<String> strings = new ArrayList<String>();\n+        trie.select(\"Hello\", new Cursor<String, String>() {\n+            public Decision select(final Entry<? extends String, ? extends String> entry) {\n+                strings.add(entry.getValue());\n+                return Decision.CONTINUE;\n+            }\n+        });\n+        Assert.assertEquals(1, strings.size());\n+    }\n+    \n+    private static class TestCursor implements Cursor<Object, Object> {\n+        private final List<Object> keys;\n+        private final List<Object> values;\n+        private Object selectFor;\n+        private List<Object> toRemove;\n+        private int index = 0;\n+        \n+        TestCursor(final Object... objects) {\n+            if(objects.length % 2 != 0) {\n+                throw new IllegalArgumentException(\"must be * 2\");\n+            }\n+            \n+            keys = new ArrayList<Object>(objects.length / 2);\n+            values = new ArrayList<Object>(keys.size());\n+            toRemove = Collections.emptyList();\n+            for(int i = 0; i < objects.length; i++) {\n+                keys.add(objects[i]);\n+                values.add(objects[++i]);\n+            }\n+        }\n+        \n+        void selectFor(final Object object) {\n+            selectFor = object;\n+        }\n+        \n+        void addToRemove(final Object... objects) {\n+            toRemove = new ArrayList<Object>(Arrays.asList(objects));\n+        }\n+        \n+        void remove(final Object... objects) {\n+            for (final Object object : objects) {\n+                final int idx = keys.indexOf(object);\n+                keys.remove(idx);\n+                values.remove(idx);\n+            }\n+        }\n+        \n+        void starting() {\n+            index = 0;\n+        }\n+        \n+        public void checkKey(final Object k) {\n+            Assert.assertEquals(keys.get(index++), k);\n+        }\n+        \n+        public void checkValue(final Object o) {\n+            Assert.assertEquals(values.get(index++), o);\n+        }\n+\n+        public Decision select(final Entry<?, ?> entry) {\n+          //  System.out.println(\"Scanning: \" + entry.getKey());\n+            Assert.assertEquals(keys.get(index), entry.getKey());\n+            Assert.assertEquals(values.get(index), entry.getValue());\n+            index++;\n+            \n+            if(toRemove.contains(entry.getKey())) {\n+              // System.out.println(\"Removing: \" + entry.getKey());\n+                index--;\n+                keys.remove(index);\n+                values.remove(index);\n+                toRemove.remove(entry.getKey());\n+                return Decision.REMOVE;\n+            } \n+            \n+            if(selectFor != null && selectFor.equals(entry.getKey())) {\n+                return Decision.EXIT;\n+            } else {\n+                return Decision.CONTINUE;\n+            }\n+        }\n+        \n+        void finished() {\n+            Assert.assertEquals(keys.size(), index);\n+        }\n+    }\n+    \n+    private static void assertEqualArrays(final Object[] a, final Object[] b) {\n+        Assert.assertTrue(Arrays.equals(a, b));\n+    }\n+}", "timestamp": 1366220223, "metainfo": ""}