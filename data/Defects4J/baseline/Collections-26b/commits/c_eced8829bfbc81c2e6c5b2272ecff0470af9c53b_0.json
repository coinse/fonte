{"sha": "eced8829bfbc81c2e6c5b2272ecff0470af9c53b", "log": "[COLLECTIONS-567] Add interface / skeleton code and first implementation of a MultiSet.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/MultiSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Defines a collection that counts the number of times an object appears in\n+ * the collection.\n+ * <p>\n+ * Suppose you have a MultiSet that contains <code>{a, a, b, c}</code>.\n+ * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n+ * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n+ *\n+ * @param <E> the type held in the multiset\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public interface MultiSet<E> extends Collection<E> {\n+\n+    /**\n+     * Returns the number of occurrences of the given object currently\n+     * in the MultiSet. If the object does not exist in the multiset,\n+     * return 0.\n+     *\n+     * @param object  the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    int getCount(Object object);\n+\n+    /**\n+     * Sets the number of occurrences of the specified object in the MultiSet\n+     * to the given count.\n+     * <p>\n+     * If the provided count is zero, the object will be removed from the\n+     * {@link #uniqueSet()}.\n+     * \n+     * @param object  the object to update\n+     * @param count  the number of occurrences of the object\n+     * @return the number of occurrences of the object before this operation, zero\n+     *   if the object was not contained in the multiset\n+     * @throws IllegalArgumentException if count is negative\n+     */\n+    int setCount(E object, int count);\n+\n+    /**\n+     * Adds one copy of the specified object to the MultiSet.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as 1.\n+     *\n+     * @param object  the object to add\n+     * @return <code>true</code> always, as the size of the MultiSet is increased\n+     *   in any case\n+     */\n+    @Override\n+    boolean add(E object);\n+\n+    /**\n+     * Adds a number of occurrences of the specified object to the MultiSet.\n+     * <p>\n+     * If the object is already in the {@link #uniqueSet()} then increment its\n+     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n+     * {@link #uniqueSet()} and report its count as <code>occurrences</code>.\n+     *\n+     * @param object  the object to add\n+     * @param occurrences  the number of occurrences to add, may be zero,\n+     *   in which case no change is made to the multiset\n+     * @return the number of occurrences of the object in the multiset before\n+     *   this operation; possibly zero\n+     * @throws IllegalArgumentException if occurrences is negative\n+     */\n+    int add(E object, int occurrences);\n+\n+    /**\n+     * Removes one occurrence of the given object from the MultiSet.\n+     * <p>\n+     * If the number of occurrences after this operations is reduced\n+     * to zero, the object will be removed from the {@link #uniqueSet()}.\n+     *\n+     * @param object  the object to remove\n+     * @return <code>true</code> if this call changed the collection\n+     */\n+    @Override\n+    boolean remove(Object object);\n+\n+    /**\n+     * Removes a number of occurrences of the specified object from the MultiSet.\n+     * <p>\n+     * If the number of occurrences to remove is greater than the actual number of\n+     * occurrences in the multiset, the object will be removed from the multiset.\n+     *\n+     * @param object  the object to remove\n+     * @param occurrences  the number of occurrences to remove, may be zero,\n+     *   in which case no change is made to the multiset\n+     * @return the number of occurrences of the object in the multiset\n+     *   before the operation; possibly zero\n+     * @throws IllegalArgumentException if occurrences is negative\n+     */\n+    int remove(Object object, int occurrences);\n+\n+    /**\n+     * Returns a {@link Set} of unique elements in the MultiSet.\n+     * <p>\n+     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n+     * <p>\n+     * The returned set is backed by this multiset, so any change to either\n+     * is immediately reflected in the other.\n+     *\n+     * @return the Set of unique MultiSet elements\n+     */\n+    Set<E> uniqueSet();\n+\n+    /**\n+     * Returns a {@link Set} of all entries contained in the MultiSet.\n+     * <p>\n+     * The returned set is backed by this multiset, so any change to either\n+     * is immediately reflected in the other.\n+     *\n+     * @return the Set of MultiSet entries\n+     */\n+    Set<Entry<E>> entrySet();\n+\n+    /**\n+     * Returns an {@link Iterator} over the entire set of members,\n+     * including copies due to cardinality. This iterator is fail-fast\n+     * and will not tolerate concurrent modifications.\n+     *\n+     * @return iterator over all elements in the MultiSet\n+     */\n+    @Override\n+    Iterator<E> iterator();\n+\n+    /**\n+     * Returns the total number of items in the MultiSet.\n+     *\n+     * @return the total size of the multiset\n+     */\n+    @Override\n+    int size();\n+\n+    /**\n+     * Returns <code>true</code> if the MultiSet contains at least one\n+     * occurrence for each element contained in the given collection.\n+     *\n+     * @param coll  the collection to check against\n+     * @return <code>true</code> if the MultiSet contains all the collection\n+     */\n+    @Override\n+    boolean containsAll(Collection<?> coll);\n+\n+    /**\n+     * Remove all occurrences of all elements from this MultiSet represented\n+     * in the given collection.\n+     *\n+     * @param coll  the collection of elements to remove\n+     * @return <code>true</code> if this call changed the multiset\n+     */\n+    @Override\n+    boolean removeAll(Collection<?> coll);\n+\n+    /**\n+     * Remove any elements of this MultiSet that are not contained in the\n+     * given collection.\n+     *\n+     * @param coll  the collection of elements to retain\n+     * @return <code>true</code> if this call changed the multiset\n+     */\n+    @Override\n+    boolean retainAll(Collection<?> coll);\n+\n+    /**\n+     * Compares this MultiSet to another object.\n+     * <p>\n+     * This MultiSet equals another object if it is also a MultiSet\n+     * that contains the same number of occurrences of the same elements.\n+     *\n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    @Override\n+    boolean equals(Object obj);\n+\n+    /**\n+     * Gets a hash code for the MultiSet compatible with the definition of equals.\n+     * The hash code is defined as the sum total of a hash code for each element.\n+     * The per element hash code is defined as\n+     * <code>(e==null ? 0 : e.hashCode()) ^ noOccurances)</code>.\n+     *\n+     * @return the hash code of the MultiSet\n+     */\n+    @Override\n+    int hashCode();\n+\n+    /**\n+     * An unmodifiable entry for an element and its occurrence as contained in a MultiSet.\n+     * <p>\n+     * The {@link MultiSet#entrySet()} method returns a view of the multiset whose elements\n+     * implements this interface.\n+     *\n+     * @param <E>  the element type\n+     */\n+    interface Entry<E> {\n+\n+        /**\n+         * Returns the element corresponding to this entry.\n+         *\n+         * @return the element corresponding to this entry\n+         */\n+        E getElement();\n+\n+        /**\n+         * Returns the number of occurrences for the element of this entry.\n+         *\n+         * @return the number of occurrences of the element\n+         */\n+        int getCount();\n+\n+        /**\n+         * Compares the specified object with this entry for equality.\n+         * Returns true if the given object is also a multiset entry\n+         * and the two entries represent the same element with the same\n+         * number of occurrences.\n+         * <p>\n+         * More formally, two entries <tt>e1</tt> and <tt>e2</tt> represent\n+         * the same mapping if\n+         * <pre>\n+         *     (e1.getElement()==null ? e2.getElement()==null\n+         *                            : e1.getElement().equals(e2.getElement())) &amp;&amp;\n+         *     (e1.getCount()==e2.getCount())\n+         * </pre>\n+         *\n+         * @param o object to be compared for equality with this multiset entry\n+         * @return true if the specified object is equal to this multiset entry\n+         */\n+        @Override\n+        boolean equals(Object o);\n+\n+        /**\n+         * Returns the hash code value for this multiset entry.\n+         * <p>\n+         * The hash code of a multiset entry <tt>e</tt> is defined to be:\n+         * <pre>\n+         *      (e==null ? 0 : e.hashCode()) ^ noOccurances)\n+         * </pre>\n+         *\n+         * @return the hash code value for this multiset entry\n+         */\n+        @Override\n+        int hashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multiset;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.MultiSet;\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n+\n+/**\n+ * Abstract implementation of the {@link MultiSet} interface to simplify the\n+ * creation of subclass implementations.\n+ * <p>\n+ * Subclasses specify a Map implementation to use as the internal storage. The\n+ * map will be used to map multiset elements to a number; the number represents the\n+ * number of occurrences of that element in the multiset.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapMultiSet<E> extends AbstractCollection<E> implements MultiSet<E> {\n+\n+    /** The map to use to store the data */\n+    private transient Map<E, MutableInteger> map;\n+    /** The current total size of the multiset */\n+    private transient int size;\n+    /** The modification count for fail fast iterators */\n+    private transient int modCount;\n+    /** View of the elements */\n+    private transient Set<E> uniqueSet;\n+    /** View of the entries */\n+    private transient Set<Entry<E>> entrySet;\n+\n+    /**\n+     * Constructor needed for subclass serialisation.\n+     */\n+    protected AbstractMapMultiSet() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that assigns the specified Map as the backing store. The map\n+     * must be empty and non-null.\n+     *\n+     * @param map the map to assign\n+     */\n+    protected AbstractMapMultiSet(final Map<E, MutableInteger> map) {\n+        super();\n+        this.map = map;\n+    }\n+\n+    /**\n+     * Utility method for implementations to access the map that backs this multiset.\n+     * Not intended for interactive use outside of subclasses.\n+     *\n+     * @return the map being used by the Bag\n+     */\n+    protected Map<E, MutableInteger> getMap() {\n+        return map;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements in this multiset.\n+     *\n+     * @return current size of the multiset\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if the underlying map is empty.\n+     *\n+     * @return true if multiset is empty\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    /**\n+     * Returns the number of occurrence of the given element in this multiset by\n+     * looking up its count in the underlying map.\n+     *\n+     * @param object the object to search for\n+     * @return the number of occurrences of the object, zero if not found\n+     */\n+    @Override\n+    public int getCount(final Object object) {\n+        final MutableInteger count = map.get(object);\n+        if (count != null) {\n+            return count.value;\n+        }\n+        return 0;\n+    }\n+\n+    @Override\n+    public int setCount(final E object, final int count) {\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"Count must not be negative.\");\n+        }\n+\n+        int oldCount = getCount(object);\n+        if (oldCount < count) {\n+            add(object, count - oldCount);\n+        } else {\n+            remove(object, oldCount - count);\n+        }\n+        return oldCount;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determines if the multiset contains the given element by checking if the\n+     * underlying map contains the element as a key.\n+     *\n+     * @param object the object to search for\n+     * @return true if the multiset contains the given element\n+     */\n+    @Override\n+    public boolean contains(final Object object) {\n+        return map.containsKey(object);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the multiset elements. Elements present in the\n+     * MultiSet more than once will be returned repeatedly.\n+     *\n+     * @return the iterator\n+     */\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new MultiSetIterator<E>(this);\n+    }\n+\n+    /**\n+     * Inner class iterator for the MultiSet.\n+     */\n+    static class MultiSetIterator<E> implements Iterator<E> {\n+        private final AbstractMapMultiSet<E> parent;\n+        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n+        private Map.Entry<E, MutableInteger> current;\n+        private int itemCount;\n+        private final int mods;\n+        private boolean canRemove;\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param parent the parent multiset\n+         */\n+        public MultiSetIterator(final AbstractMapMultiSet<E> parent) {\n+            this.parent = parent;\n+            this.entryIterator = parent.map.entrySet().iterator();\n+            this.current = null;\n+            this.mods = parent.modCount;\n+            this.canRemove = false;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public boolean hasNext() {\n+            return itemCount > 0 || entryIterator.hasNext();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public E next() {\n+            if (parent.modCount != mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (itemCount == 0) {\n+                current = entryIterator.next();\n+                itemCount = current.getValue().value;\n+            }\n+            canRemove = true;\n+            itemCount--;\n+            return current.getKey();\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void remove() {\n+            if (parent.modCount != mods) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (canRemove == false) {\n+                throw new IllegalStateException();\n+            }\n+            final MutableInteger mut = current.getValue();\n+            if (mut.value > 1) {\n+                mut.value--;\n+            } else {\n+                entryIterator.remove();\n+            }\n+            parent.size--;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean add(final E object) {\n+        add(object, 1);\n+        return true;\n+    }\n+\n+    @Override\n+    public int add(final E object, final int occurrences) {\n+        if (occurrences < 0) {\n+            throw new IllegalArgumentException(\"Occurrences must not be negative.\");\n+        }\n+\n+        final MutableInteger mut = map.get(object);\n+        int oldCount = mut != null ? mut.value : 0;\n+\n+        if (occurrences > 0) {\n+            modCount++;\n+            size += occurrences;\n+            if (mut == null) {\n+                map.put(object, new MutableInteger(occurrences));\n+            } else {\n+                mut.value += occurrences;\n+            }\n+        }\n+        return oldCount;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clears the multiset by clearing the underlying map.\n+     */\n+    @Override\n+    public void clear() {\n+        modCount++;\n+        map.clear();\n+        size = 0;\n+    }\n+\n+    @Override\n+    public boolean remove(final Object object) {\n+        final MutableInteger mut = map.get(object);\n+        if (mut == null) {\n+            return false;\n+        }\n+        modCount++;\n+        map.remove(object);\n+        size -= mut.value;\n+        return true;\n+    }\n+\n+    @Override\n+    public int remove(final Object object, final int occurrences) {\n+        if (occurrences < 0) {\n+            throw new IllegalArgumentException(\"Occurrences must not be negative.\");\n+        }\n+\n+        final MutableInteger mut = map.get(object);\n+        if (mut == null) {\n+            return 0;\n+        }\n+        int oldCount = mut.value;\n+        if (occurrences > 0) {\n+            modCount++;\n+            if (occurrences < mut.value) {\n+                mut.value -= occurrences;\n+                size -= occurrences;\n+            } else {\n+                map.remove(object);\n+                size -= mut.value;\n+            }\n+        }\n+        return oldCount;\n+    }\n+\n+    @Override\n+    public boolean removeAll(final Collection<?> coll) {\n+        boolean result = false;\n+        final Iterator<?> i = coll.iterator();\n+        while (i.hasNext()) {\n+            final Object obj = i.next();\n+            final boolean changed = remove(obj, getCount(obj)) != 0;\n+            result = result || changed;\n+        }\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Mutable integer class for storing the data.\n+     */\n+    protected static class MutableInteger {\n+        /** The value of this mutable. */\n+        protected int value;\n+\n+        /**\n+         * Constructor.\n+         * @param value the initial value\n+         */\n+        MutableInteger(final int value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object obj) {\n+            if (obj instanceof MutableInteger == false) {\n+                return false;\n+            }\n+            return ((MutableInteger) obj).value == value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return value;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an array of all of this multiset's elements.\n+     *\n+     * @return an array of all of this multiset's elements\n+     */\n+    @Override\n+    public Object[] toArray() {\n+        final Object[] result = new Object[size()];\n+        int i = 0;\n+        final Iterator<E> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+            final E current = it.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                result[i++] = current;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns an array of all of this multiset's elements.\n+     * If the input array has more elements than are in the multiset,\n+     * trailing elements will be set to null.\n+     *\n+     * @param <T> the type of the array elements\n+     * @param array the array to populate\n+     * @return an array of all of this multiset's elements\n+     * @throws ArrayStoreException if the runtime type of the specified array is not\n+     *   a supertype of the runtime type of the elements in this list\n+     * @throws NullPointerException if the specified array is null\n+     */\n+    @Override\n+    public <T> T[] toArray(T[] array) {\n+        final int size = size();\n+        if (array.length < size) {\n+            @SuppressWarnings(\"unchecked\") // safe as both are of type T\n+            final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n+            array = unchecked;\n+        }\n+\n+        int i = 0;\n+        final Iterator<E> it = map.keySet().iterator();\n+        while (it.hasNext()) {\n+            final E current = it.next();\n+            for (int index = getCount(current); index > 0; index--) {\n+                // unsafe, will throw ArrayStoreException if types are not compatible, see javadoc\n+                @SuppressWarnings(\"unchecked\")\n+                final T unchecked = (T) current;\n+                array[i++] = unchecked;\n+            }\n+        }\n+        while (i < array.length) {\n+            array[i++] = null;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Returns a view of the underlying map's key set.\n+     *\n+     * @return the set of unique elements in this multiset\n+     */\n+    @Override\n+    public Set<E> uniqueSet() {\n+        if (uniqueSet == null) {\n+            uniqueSet = new UniqueSet<E>(this);\n+        }\n+        return uniqueSet;\n+    }\n+\n+    /**\n+     * Creates a unique set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the uniqueSet iterator\n+     */\n+    protected Iterator<E> createUniqueSetIterator(final Iterator<E> iterator) {\n+        return new UniqueSetIterator<E>(iterator, this);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the underlying map's key set.\n+     *\n+     * @return the set of unique elements in this multiset\n+     */\n+    @Override\n+    public Set<Entry<E>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet<E>(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     *\n+     * @param iterator  the iterator to decorate\n+     * @return the entrySet iterator\n+     */\n+    protected Iterator<Entry<E>> createEntrySetIterator(final Iterator<Map.Entry<E, MutableInteger>> iterator) {\n+        return new EntrySetIterator<E>(iterator, this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class UniqueSet.\n+     */\n+    protected static class UniqueSet<E> extends AbstractCollectionDecorator<E> implements Set<E> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 20150610L;\n+\n+        /** The parent multiset */\n+        protected final AbstractMapMultiSet<E> parent;\n+\n+        /**\n+         * Constructs a new unique element view of the MultiSet.\n+         *\n+         * @param parent  the parent MultiSet\n+         */\n+        protected UniqueSet(final AbstractMapMultiSet<E> parent) {\n+            super(parent.map.keySet());\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return parent.createUniqueSetIterator(super.iterator());\n+        }\n+\n+        @Override\n+        public boolean contains(final Object key) {\n+            return parent.contains(key);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object key) {\n+            return parent.remove(key, parent.getCount(key)) != 0;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object object) {\n+            return object == this || decorated().equals(object);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return decorated().hashCode();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            parent.clear();\n+        }\n+    }\n+\n+    /**\n+     * Inner class UniqueSetIterator.\n+     */\n+    protected static class UniqueSetIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+        /** The parent multiset */\n+        protected final AbstractMapMultiSet<E> parent;\n+\n+        /** The last returned element */\n+        protected E lastElement = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent multiset\n+         */\n+        protected UniqueSetIterator(final Iterator<E> iterator, final AbstractMapMultiSet<E> parent) {\n+            super(iterator);\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public E next() {\n+            lastElement = super.next();\n+            canRemove = true;\n+            return lastElement;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            final int count = parent.getCount(lastElement);\n+            super.remove();\n+            parent.remove(lastElement, count);\n+            lastElement = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class EntrySet.\n+     */\n+    protected static class EntrySet<E> extends AbstractSet<Entry<E>> {\n+\n+        private final AbstractMapMultiSet<E> parent;\n+\n+        /**\n+         * Constructs a new view of the BidiMap.\n+         *\n+         * @param parent  the parent BidiMap\n+         */\n+        protected EntrySet(final AbstractMapMultiSet<E> parent) {\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return parent.entrySet.size();\n+        }\n+\n+        @Override\n+        public Iterator<Entry<E>> iterator() {\n+            return parent.createEntrySetIterator(parent.map.entrySet().iterator());\n+        }\n+\n+        @Override\n+        public boolean contains(final Object obj) {\n+            if (obj instanceof Entry<?> == false) {\n+                return false;\n+            }\n+            final Entry<?> entry = (Entry<?>) obj;\n+            final Object element = entry.getElement();\n+            return parent.getCount(element) == entry.getCount();\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Entry<?> == false) {\n+                return false;\n+            }\n+            final Entry<?> entry = (Entry<?>) obj;\n+            final Object element = entry.getElement();\n+            if (parent.contains(element)) {\n+                final int count = parent.getCount(element);\n+                if (entry.getCount() == count) {\n+                    parent.remove(element, count);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class EntrySetIterator.\n+     */\n+    protected static class EntrySetIterator<E> implements Iterator<Entry<E>> {\n+\n+        /** The parent map */\n+        protected final AbstractMapMultiSet<E> parent;\n+\n+        protected final Iterator<Map.Entry<E, MutableInteger>> decorated;\n+\n+        /** The last returned entry */\n+        protected Entry<E> last = null;\n+\n+        /** Whether remove is allowed at present */\n+        protected boolean canRemove = false;\n+\n+        /**\n+         * Constructor.\n+         * @param iterator  the iterator to decorate\n+         * @param parent  the parent multiset\n+         */\n+        protected EntrySetIterator(final Iterator<Map.Entry<E, MutableInteger>> iterator,\n+                                   final AbstractMapMultiSet<E> parent) {\n+            this.decorated = iterator;\n+            this.parent = parent;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return decorated.hasNext();\n+        }\n+\n+        @Override\n+        public Entry<E> next() {\n+            last = new MultiSetEntry<E>(decorated.next());\n+            canRemove = true;\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            if (canRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            decorated.remove();\n+            last = null;\n+            canRemove = false;\n+        }\n+    }\n+\n+    /**\n+     * Inner class MultiSetEntry.\n+     */\n+    protected static class MultiSetEntry<E> implements Entry<E> {\n+\n+        protected final Map.Entry<E, MutableInteger> parentEntry;\n+\n+        /**\n+         * Constructor.\n+         * @param entry  the entry to decorate\n+         * @param parent  the parent map\n+         */\n+        protected MultiSetEntry(final Map.Entry<E, MutableInteger> parentEntry) {\n+            this.parentEntry = parentEntry;\n+        }\n+\n+        @Override\n+        public E getElement() {\n+            return parentEntry.getKey();\n+        }\n+\n+        @Override\n+        public int getCount() {\n+            return parentEntry.getValue().value;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s:%d\", getElement(), getCount());\n+        }\n+        \n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     * @param out the output stream\n+     * @throws IOException any of the usual I/O related exceptions\n+     */\n+    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n+        out.writeInt(map.size());\n+        for (final Map.Entry<E, MutableInteger> entry : map.entrySet()) {\n+            out.writeObject(entry.getKey());\n+            out.writeInt(entry.getValue().value);\n+        }\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * @param map the map to use\n+     * @param in the input stream\n+     * @throws IOException any of the usual I/O related exceptions\n+     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n+     * @throws ClassCastException if the stream does not contain the correct objects\n+     */\n+    protected void doReadObject(final Map<E, MutableInteger> map, final ObjectInputStream in)\n+            throws IOException, ClassNotFoundException {\n+        this.map = map;\n+        final int entrySize = in.readInt();\n+        for (int i = 0; i < entrySize; i++) {\n+            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n+            final E obj = (E) in.readObject();\n+            final int count = in.readInt();\n+            map.put(obj, new MutableInteger(count));\n+            size += count;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        if (object instanceof MultiSet == false) {\n+            return false;\n+        }\n+        final MultiSet<?> other = (MultiSet<?>) object;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        for (final E element : map.keySet()) {\n+            if (other.getCount(element) != getCount(element)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        for (final Map.Entry<E, MutableInteger> entry : map.entrySet()) {\n+            final E element = entry.getKey();\n+            final MutableInteger count = entry.getValue();\n+            total += (element == null ? 0 : element.hashCode()) ^ count.value;\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Implement a toString() method suitable for debugging.\n+     *\n+     * @return a debugging toString\n+     */\n+    @Override\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"[]\";\n+        }\n+        final StringBuilder buf = new StringBuilder();\n+        buf.append('[');\n+        final Iterator<E> it = uniqueSet().iterator();\n+        while (it.hasNext()) {\n+            final Object current = it.next();\n+            final int count = getCount(current);\n+            buf.append(current);\n+            buf.append(':');\n+            buf.append(count);\n+            if (it.hasNext()) {\n+                buf.append(\", \");\n+            }\n+        }\n+        buf.append(']');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multiset;\n+\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.MultiSet;\n+import org.apache.commons.collections4.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * Decorates another <code>MultSet</code> to provide additional behaviour.\n+ * <p>\n+ * Methods are forwarded directly to the decorated multiset.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractMultiSetDecorator<E>\n+        extends AbstractCollectionDecorator<E> implements MultiSet<E> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 20150610L;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractMultiSetDecorator() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param multiset  the multiset to decorate, must not be null\n+     * @throws IllegalArgumentException if multiset is null\n+     */\n+    protected AbstractMultiSetDecorator(final MultiSet<E> multiset) {\n+        super(multiset);\n+    }\n+\n+    /**\n+     * Gets the multiset being decorated.\n+     *\n+     * @return the decorated multiset\n+     */\n+    @Override\n+    protected MultiSet<E> decorated() {\n+        return (MultiSet<E>) super.decorated();\n+    }\n+\n+    @Override\n+    public boolean equals(final Object object) {\n+        return object == this || decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public int getCount(final Object object) {\n+        return decorated().getCount(object);\n+    }\n+\n+    @Override\n+    public int setCount(E object, int count) {\n+        return decorated().setCount(object, count);\n+    }\n+\n+    @Override\n+    public int add(final E object, final int count) {\n+        return decorated().add(object, count);\n+    }\n+\n+    @Override\n+    public int remove(final Object object, final int count) {\n+        return decorated().remove(object, count);\n+    }\n+\n+    @Override\n+    public Set<E> uniqueSet() {\n+        return decorated().uniqueSet();\n+    }\n+\n+    @Override\n+    public Set<Entry<E>> entrySet() {\n+        return decorated().entrySet();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multiset/HashMultiSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multiset;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections4.MultiSet;\n+\n+/**\n+ * Implements {@link MultiSet}, using a {@link HashMap} to provide the\n+ * data storage. This is the standard implementation of a multiset.\n+ * <p>\n+ * A {@link MultiSet} stores each object in the collection together with a\n+ * count of occurrences. Extra methods on the interface allow multiple copies\n+ * of an object to be added or removed at once.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class HashMultiSet<E> extends AbstractMapMultiSet<E> implements Serializable {\n+\n+    /** Serial version lock */\n+    private static final long serialVersionUID = 20150610L;\n+\n+    /**\n+     * Constructs an empty {@link HashMultiSet}.\n+     */\n+    public HashMultiSet() {\n+        super(new HashMap<E, MutableInteger>());\n+    }\n+\n+    /**\n+     * Constructs a bag containing all the members of the given collection.\n+     *\n+     * @param coll  a collection to copy into this bag\n+     */\n+    public HashMultiSet(final Collection<? extends E> coll) {\n+        this();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the bag out using a custom routine.\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        super.doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the bag in using a custom routine.\n+     */\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        super.doReadObject(new HashMap<E, MutableInteger>(), in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multiset/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link org.apache.commons.collections4.MultiSet MultiSet} and\n+ * {@link org.apache.commons.collections4.SortedMultiSet SortedMultiSet} interfaces.\n+ * A multiset stores an object and a count of the number of occurrences of the object.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>HashMultiSet - implementation that uses a HashMap to store the data\n+ *   <li>TreeMultiSet - implementation that uses a TreeMap to store the data\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Unmodifiable - ensures the multiset cannot be altered\n+ *   <li>Predicated - ensures that only elements that are valid according to a predicate can be added\n+ *   <li>Transformed - transforms each element added to the multiset\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.multiset;", "timestamp": 1434054639, "metainfo": ""}