{"sha": "5ea7e3a7d4cee4110927fa5925ae14c4e8df5391", "log": "[COLLECTIONS-296] Added CollectionUtils#merge methods to merge two sorted Collections. Thanks to Julius Davies for the report and patch.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n import java.lang.reflect.Array;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Comparator;\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.HashSet;\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Merges two sorted Collections, a and b, into a single, sorted List\n+     * such that the natural ordering of the elements is retained.\n+     * <p>\n+     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n+     *\n+     * @param <O>  the element type\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @return a new sorted List, containing the elements of Collection a and b\n+     * @throws IllegalArgumentException if either collection is null\n+     */\n+    public static <O extends Comparable<? super O>> List<O> merge(Collection<? extends O> a,\n+                                                                  Collection<? extends O> b) {\n+        return merge(a, b, ComparatorUtils.<O>naturalComparator(), true);\n+    }\n+\n+    /**\n+    /**\n+     * Merges two sorted Collections, a and b, into a single, sorted List\n+     * such that the natural ordering of the elements is retained.\n+     * <p>\n+     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n+     *\n+     * @param <O>  the element type\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n+     *   they will be removed in the output collection\n+     * @return a new sorted List, containing the elements of Collection a and b\n+     * @throws IllegalArgumentException if either collection is null\n+     */\n+    public static <O extends Comparable<? super O>> List<O> merge(final Collection<? extends O> a,\n+                                                                  final Collection<? extends O> b,\n+                                                                  final boolean includeDuplicates) {\n+        return merge(a, b, ComparatorUtils.<O>naturalComparator(), includeDuplicates);\n+    }\n+\n+    /**\n+     * Merges two sorted Collections, a and b, into a single, sorted List\n+     * such that the ordering of the elements according to Comparator c is retained.\n+     * <p>\n+     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n+     *\n+     * @param <O>  the element type\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @param c  the comparator to use for the merge. \n+     * @return a new sorted List, containing the elements of Collection a and b\n+     * @throws IllegalArgumentException if either collection or the comparator is null\n+     */\n+    public static <O> List<O> merge(final Collection<? extends O> a, final Collection<? extends O> b,\n+                                    final Comparator<? super O> c) {\n+        return merge(a, b, c, true);\n+    }\n+    \n+    /**\n+     * Merges two sorted Collections, a and b, into a single, sorted List\n+     * such that the ordering of the elements according to Comparator c is retained.\n+     * <p>\n+     * Uses the standard O(n) merge algorithm for combining two sorted lists.\n+     *\n+     * @param <O>  the element type\n+     * @param a  the first collection, must not be null\n+     * @param b  the second collection, must not be null\n+     * @param c  the comparator to use for the merge. \n+     * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n+     *   they will be removed in the output collection\n+     * @return a new sorted List, containing the elements of Collection a and b\n+     * @throws IllegalArgumentException if either collection or the comparator is null\n+     */\n+    public static <O> List<O> merge(final Collection<? extends O> a, final Collection<? extends O> b,\n+                                    final Comparator<? super O> c, final boolean includeDuplicates) {\n+        \n+        if (a == null || b == null) {\n+            throw new IllegalArgumentException(\"The collections must not be null\");\n+        }\n+        if (c == null) {\n+            throw new IllegalArgumentException(\"The comparator must not be null\");\n+        }\n+\n+        final List<O> mergedList = new ArrayList<O>(a.size() + b.size());\n+        \n+        // if either collection is empty, just return the other one\n+        if (a.isEmpty() || b.isEmpty()) {\n+            mergedList.addAll(a.isEmpty() ? b : a);\n+            return mergedList;\n+        }\n+\n+        final Iterator<? extends O> it1 = a.iterator();\n+        final Iterator<? extends O> it2 = b.iterator();\n+        O o1 = it1.next();\n+        O o2 = it2.next();\n+        O last = null;\n+        while (true) {\n+            final int x = c.compare(o1, o2);\n+            if (x <= 0) {\n+                last = addItemToList(o1, mergedList, last, includeDuplicates);\n+                if (it1.hasNext()) {\n+                    o1 = it1.next();\n+                } else {\n+                    // a is empty, so add current element of b\n+                    last = addItemToList(o2, mergedList, last, includeDuplicates);\n+                    break;\n+                }\n+            } else {\n+                last = addItemToList(o2, mergedList, last, includeDuplicates);\n+                if (it2.hasNext()) {\n+                    o2 = it2.next();\n+                } else {\n+                    // b is empty, so add current element of a\n+                    last = addItemToList(o1, mergedList, last, includeDuplicates);\n+                    break;\n+                }                \n+            }\n+        }\n+\n+        // add the remaining elements from the non-empty iterator\n+        final Iterator<? extends O> it = it1.hasNext() ? it1 : it2;\n+        while (it.hasNext()) {\n+            last = addItemToList(it.next(), mergedList, last, includeDuplicates);\n+        }\n+        \n+        return mergedList;\n+    }\n+\n+    /**\n+     * Adds an item to the specified list.\n+     *\n+     * @param item  the item to add\n+     * @param list  the list to use\n+     * @param lastItem  the last added item, may be null\n+     * @param includeDuplicates  whether duplicate entries are allowed\n+     * @return the last added item\n+     */\n+    private static <E> E addItemToList(final E item, final List<E> list, final E lastItem,\n+                                       final boolean includeDuplicates) {\n+        if (includeDuplicates || lastItem == null || !lastItem.equals(item)) {\n+            list.add(item);\n+            return item;\n+        } else {\n+            return lastItem;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Returns a collection containing all the elements in <code>collection</code>\n      * that are also in <code>retain</code>. The cardinality of an element <code>e</code>\n      * in the returned collection is the same as the cardinality of <code>e</code>\n--- a/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n     private Collection<Integer> collectionC = null;\n \n     /**\n+     * Sorted Collection of {@link Integer}s\n+     */\n+    private Collection<Integer> collectionD = null;\n+\n+    /**\n+     * Sorted Collection of {@link Integer}s\n+     */\n+    private Collection<Integer> collectionE = null;\n+\n+    /**\n      * Collection of {@link Integer}s, bound as {@link Number}s\n      */\n     private Collection<Number> collectionA2 = null;\n     private Iterable<Number> iterableA2 = null;\n \n     private Iterable<Number> iterableB2 = null;\n+\n+    private Collection<Integer> emptyCollection = new ArrayList<Integer>(1);\n \n     @Before\n     public void setUp() {\n         collectionC2 = new LinkedList<Number>(collectionC);\n         iterableA2 = collectionA2;\n         iterableB2 = collectionB2;\n+        \n+        collectionD = new ArrayList<Integer>();\n+        collectionD.add(1);\n+        collectionD.add(3);\n+        collectionD.add(3);\n+        collectionD.add(3);\n+        collectionD.add(5);\n+        collectionD.add(7);\n+        collectionD.add(7);\n+        collectionD.add(10);\n+\n+        collectionE = new ArrayList<Integer>();\n+        collectionE.add(2);\n+        collectionE.add(4);\n+        collectionE.add(4);\n+        collectionE.add(5);\n+        collectionE.add(6);\n+        collectionE.add(6);\n+        collectionE.add(9);\n     }\n \n     @Test\n         expect(iterator.hasNext()).andReturn(true);\n         expect(iterator.next()).andReturn(t);\n     }\n+        \n+    @Test(expected=IllegalArgumentException.class)\n+    public void mergeException1() {\n+        CollectionUtils.merge(collectionA, null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void mergeException2() {\n+        CollectionUtils.merge(collectionA, collectionC, null);\n+    }\n+\n+    @Test\n+    public void testMerge() {\n+        List<Integer> result = CollectionUtils.merge(emptyCollection, emptyCollection);\n+        assertEquals(\"Merge empty with empty\", 0, result.size());\n+\n+        result = CollectionUtils.merge(collectionA, emptyCollection);\n+        assertEquals(\"Merge empty with non-empty\", collectionA, result);\n+\n+        List<Integer> result1 = CollectionUtils.merge(collectionD, collectionE);\n+        List<Integer> result2 = CollectionUtils.merge(collectionE, collectionD);\n+        assertEquals(\"Merge two lists 1\", result1, result2);\n+        \n+        List<Integer> combinedList = new ArrayList<Integer>();\n+        combinedList.addAll(collectionD);\n+        combinedList.addAll(collectionE);\n+        Collections.sort(combinedList);\n+\n+        assertEquals(\"Merge two lists 2\", combinedList, result2);\n+\n+        final Comparator<Integer> reverseComparator =\n+                ComparatorUtils.reversedComparator(ComparatorUtils.<Integer>naturalComparator());\n+\n+        result = CollectionUtils.merge(emptyCollection, emptyCollection, reverseComparator);\n+        assertEquals(\"Comparator Merge empty with empty\", 0, result.size());\n+\n+        Collections.reverse((List<Integer>) collectionD);\n+        Collections.reverse((List<Integer>) collectionE);\n+        Collections.reverse(combinedList);\n+\n+        result1 = CollectionUtils.merge(collectionD, collectionE, reverseComparator);\n+        result2 = CollectionUtils.merge(collectionE, collectionD, reverseComparator);\n+        assertEquals(\"Comparator Merge two lists 1\", result1, result2);\n+        assertEquals(\"Comparator Merge two lists 2\", combinedList, result2);\n+    }\n+    \n+    @Test\n+    public void testMergeIgnoreDuplicates() {\n+        List<Integer> result1 = CollectionUtils.merge(collectionD, collectionE, false);\n+        List<Integer> result2 = CollectionUtils.merge(collectionE, collectionD, false);\n+        assertEquals(\"Merge two lists 1 - ignore duplicates\", result1, result2);\n+        \n+        Set<Integer> combinedSet = new HashSet<Integer>();\n+        combinedSet.addAll(collectionD);\n+        combinedSet.addAll(collectionE);\n+        List<Integer> combinedList = new ArrayList<Integer>(combinedSet);\n+        Collections.sort(combinedList);\n+\n+        assertEquals(\"Merge two lists 2 - ignore duplicates\", combinedList, result2);\n+    }\n+    \n }", "timestamp": 1366319200, "metainfo": ""}