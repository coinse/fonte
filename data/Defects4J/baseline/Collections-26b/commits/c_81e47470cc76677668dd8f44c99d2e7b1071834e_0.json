{"sha": "81e47470cc76677668dd8f44c99d2e7b1071834e", "log": "Further cleanup of trie package & interface, renamed AbstractTrie to AbstractBitwiseTrie, added TODOs.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/Trie.java\n+++ b/src/main/java/org/apache/commons/collections4/Trie.java\n  * @since 4.0\n  * @version $Id$\n  */\n+// TODO: should extend IterableSortedMap\n+// TODO: move bitwise getPrefixedBy methods to AbstractBitwiseTrie\n+// TODO: consider a BitwiseTrie interface which extends Trie and supports the bitwise selection methods\n+// TODO: consider a better name for getPrefixedBy: maybe prefixMap(...)\n public interface Trie<K, V> extends SortedMap<K, V> {\n-\n-    /**\n-     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n-     * metric to the given key. This is NOT lexicographic closeness.\n-     * For example, given the keys:\n-     *\n-     * <ol>\n-     * <li>D = 1000100\n-     * <li>H = 1001000\n-     * <li>L = 1001100\n-     * </ol>\n-     *\n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n-     * return 'L', because the XOR distance between D &amp; L is smaller\n-     * than the XOR distance between D &amp; H.\n-     *\n-     * @param key  the key to use in the search\n-     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n-     *   to the provided key\n-     */\n-    public Map.Entry<K, V> select(K key);\n-\n-    /**\n-     * Returns the key that is closest in a bitwise XOR metric to the\n-     * provided key. This is NOT lexicographic closeness!\n-     *\n-     * For example, given the keys:\n-     *\n-     * <ol>\n-     * <li>D = 1000100\n-     * <li>H = 1001000\n-     * <li>L = 1001100\n-     * </ol>\n-     *\n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n-     * return 'L', because the XOR distance between D &amp; L is smaller\n-     * than the XOR distance between D &amp; H.\n-     *\n-     * @param key  the key to use in the search\n-     * @return the key that is closest in a bitwise XOR metric to the provided key\n-     */\n-    public K selectKey(K key);\n-\n-    /**\n-     * Returns the value whose key is closest in a bitwise XOR metric to\n-     * the provided key. This is NOT lexicographic closeness!\n-     *\n-     * For example, given the keys:\n-     *\n-     * <ol>\n-     * <li>D = 1000100\n-     * <li>H = 1001000\n-     * <li>L = 1001100\n-     * </ol>\n-     *\n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n-     * return 'L', because the XOR distance between D &amp; L is smaller\n-     * than the XOR distance between D &amp; H.\n-     *\n-     * @param key  the key to use in the search\n-     * @return the value whose key is closest in a bitwise XOR metric\n-     * to the provided key\n-     */\n-    public V selectValue(K key);\n-\n-    /**\n-     * Iterates through the {@link Trie}, starting with the entry whose bitwise\n-     * value is closest in an XOR metric to the given key. After the closest\n-     * entry is found, the {@link Trie} will call select on that entry and continue\n-     * calling select for each entry (traversing in order of XOR closeness,\n-     * NOT lexicographically) until the cursor returns {@link Cursor.Decision#EXIT}.\n-     * <p>\n-     * The cursor can return {@link Cursor.Decision#CONTINUE} to continue traversing.\n-     * <p>\n-     * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n-     * and stop traversing.\n-     * <p>\n-     * Note: The {@link Cursor.Decision#REMOVE} operation is not supported.\n-     *\n-     * @param key  the key to use in the search\n-     * @param cursor  the cursor used throughout the search\n-     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null\n-     * if it continued till the end\n-     */\n-    public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n \n     /**\n      * Traverses the {@link Trie} in lexicographical order.\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.collections4.Trie;\n+\n+/**\n+ * This class provides some basic {@link Trie} functionality and\n+ * utility methods for actual bitwise {@link Trie} implementations.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+abstract class AbstractBitwiseTrie<K, V> extends AbstractMap<K, V>\n+        implements Trie<K, V>, Serializable {\n+\n+    private static final long serialVersionUID = 5826987063535505652L;\n+\n+    // TODO Privatise fields?\n+\n+    /**\n+     * The {@link KeyAnalyzer} that's being used to build the PATRICIA {@link Trie}.\n+     */\n+    protected final KeyAnalyzer<? super K> keyAnalyzer;\n+\n+    /**\n+     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n+     */\n+    public AbstractBitwiseTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n+        if (keyAnalyzer == null) {\n+            throw new NullPointerException(\"keyAnalyzer\");\n+        }\n+\n+        this.keyAnalyzer = keyAnalyzer;\n+    }\n+\n+    /**\n+     * Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n+     */\n+    public KeyAnalyzer<? super K> getKeyAnalyzer() {\n+        return keyAnalyzer;\n+    }\n+\n+    /**\n+     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n+     * metric to the given key. This is NOT lexicographic closeness.\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n+     * @param key  the key to use in the search\n+     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n+     *   to the provided key\n+     */\n+    public abstract Map.Entry<K, V> select(K key);\n+\n+    /**\n+     * Returns the key that is closest in a bitwise XOR metric to the\n+     * provided key. This is NOT lexicographic closeness!\n+     *\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n+     * @param key  the key to use in the search\n+     * @return the key that is closest in a bitwise XOR metric to the provided key\n+     */\n+    public K selectKey(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getKey();\n+    }\n+\n+    /**\n+     * Returns the value whose key is closest in a bitwise XOR metric to\n+     * the provided key. This is NOT lexicographic closeness!\n+     *\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n+     * @param key  the key to use in the search\n+     * @return the value whose key is closest in a bitwise XOR metric\n+     * to the provided key\n+     */\n+    public V selectValue(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+\n+    /**\n+     * Iterates through the {@link Trie}, starting with the entry whose bitwise\n+     * value is closest in an XOR metric to the given key. After the closest\n+     * entry is found, the {@link Trie} will call select on that entry and continue\n+     * calling select for each entry (traversing in order of XOR closeness,\n+     * NOT lexicographically) until the cursor returns {@link Cursor.Decision#EXIT}.\n+     * <p>\n+     * The cursor can return {@link Cursor.Decision#CONTINUE} to continue traversing.\n+     * <p>\n+     * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * and stop traversing.\n+     * <p>\n+     * Note: The {@link Cursor.Decision#REMOVE} operation is not supported.\n+     *\n+     * @param key  the key to use in the search\n+     * @param cursor  the cursor used throughout the search\n+     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null\n+     * if it continued till the end\n+     */\n+    public abstract Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder buffer = new StringBuilder();\n+        buffer.append(\"Trie[\").append(size()).append(\"]={\\n\");\n+        for (final Map.Entry<K, V> entry : entrySet()) {\n+            buffer.append(\"  \").append(entry).append(\"\\n\");\n+        }\n+        buffer.append(\"}\\n\");\n+        return buffer.toString();\n+    }\n+\n+    /**\n+     * A utility method to cast keys. It actually doesn't cast anything. It's just fooling the compiler!\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    final K castKey(final Object key) {\n+        return (K) key;\n+    }\n+\n+    /**\n+     * Returns the length of the given key in bits\n+     *\n+     * @see KeyAnalyzer#lengthInBits(Object)\n+     */\n+    final int lengthInBits(final K key) {\n+        if (key == null) {\n+            return 0;\n+        }\n+\n+        return keyAnalyzer.lengthInBits(key);\n+    }\n+\n+    /**\n+     * Returns the number of bits per element in the key\n+     *\n+     * @see KeyAnalyzer#bitsPerElement()\n+     */\n+    final int bitsPerElement() {\n+        return keyAnalyzer.bitsPerElement();\n+    }\n+\n+    /**\n+     * Returns whether or not the given bit on the key is set or false if the key is null.\n+     *\n+     * @see KeyAnalyzer#isBitSet(Object, int, int)\n+     */\n+    final boolean isBitSet(final K key, final int bitIndex, final int lengthInBits) {\n+        if (key == null) { // root's might be null!\n+            return false;\n+        }\n+        return keyAnalyzer.isBitSet(key, bitIndex, lengthInBits);\n+    }\n+\n+    /**\n+     * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}.\n+     */\n+    final int bitIndex(final K key, final K foundKey) {\n+        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), foundKey, 0, lengthInBits(foundKey));\n+    }\n+\n+    /**\n+     * An utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n+     */\n+    final boolean compareKeys(final K key, final K other) {\n+        if (key == null) {\n+            return other == null;\n+        } else if (other == null) {\n+            return false;\n+        }\n+\n+        return keyAnalyzer.compare(key, other) == 0;\n+    }\n+\n+    /**\n+     * Returns true if both values are either null or equal.\n+     */\n+    static boolean compare(final Object a, final Object b) {\n+        return a == null ? b == null : a.equals(b);\n+    }\n+\n+    /**\n+     * A basic implementation of {@link Entry}.\n+     */\n+    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n+\n+        private static final long serialVersionUID = -944364551314110330L;\n+\n+        protected K key;\n+\n+        protected V value;\n+\n+        private final int hashCode;\n+\n+        public BasicEntry(final K key) {\n+            this.key = key;\n+            this.hashCode = key != null ? key.hashCode() : 0;\n+        }\n+\n+        public BasicEntry(final K key, final V value) {\n+            this.key = key;\n+            this.value = value;\n+            this.hashCode = (key != null ? key.hashCode() : 0) ^ (value != null ? value.hashCode() : 0);\n+        }\n+\n+        /**\n+         * Replaces the current key and value with the provided key &amp; value.\n+         */\n+        public V setKeyValue(final K key, final V value) {\n+            this.key = key;\n+            return setValue(value);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        public V setValue(final V value) {\n+            final V previous = this.value;\n+            this.value = value;\n+            return previous;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(final Object o) {\n+            if (o == this) {\n+                return true;\n+            } else if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            final Map.Entry<?, ?> other = (Map.Entry<?, ?>)o;\n+            if (compare(key, other.getKey())\n+                    && compare(value, other.getValue())) {\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return key + \"=\" + value;\n+        }\n+    }\n+}\n--- a/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java\n \n /**\n  * Defines the interface to analyze {@link org.apache.commons.collections4.Trie Trie} keys on a bit level.\n- * {@link KeyAnalyzer}'s methods return the length of the key in bits,\n- * whether or not a bit is set, and bits per element in the key.\n+ * {@link KeyAnalyzer}'s methods return the length of the key in bits, whether or not a bit is set,\n+ * and bits per element in the key.\n  * <p>\n  * Additionally, a method determines if a key is a prefix of another\n  * key and returns the bit index where one key is different from another\n \n     /**\n      * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n-     * if key's bits are all 0\n+     * if key's bits are all 0.\n      */\n     public static final int NULL_BIT_KEY = -1;\n \n     /**\n-     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n-     * if key and found key are equal. This is a very very specific case\n-     * and shouldn't happen on a regular basis\n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n+     * This is a very very specific case and shouldn't happen on a regular basis.\n      */\n     public static final int EQUAL_BIT_KEY = -2;\n \n     public static final int OUT_OF_BOUNDS_BIT_KEY = -3;\n \n     /**\n-     * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n      */\n     static boolean isOutOfBoundsIndex(final int bitIndex) {\n         return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n     }\n \n     /**\n-     * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n      */\n     static boolean isEqualBitKey(final int bitIndex) {\n         return bitIndex == EQUAL_BIT_KEY;\n     }\n \n     /**\n-     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}\n+     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n      */\n     static boolean isNullBitKey(final int bitIndex) {\n         return bitIndex == NULL_BIT_KEY;\n     }\n \n     /**\n-     * Returns true if the given bitIndex is valid. Indices\n-     * are considered valid if they're between 0 and\n-     * {@link Integer#MAX_VALUE}\n+     * Returns true if the given bitIndex is valid.\n+     * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n      */\n     static boolean isValidBitIndex(final int bitIndex) {\n         return bitIndex >= 0;\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n import org.apache.commons.collections4.Trie;\n \n /**\n- * <h3>PATRICIA {@link Trie}</h3>\n- *\n- * <i>Practical Algorithm to Retrieve Information Coded in Alphanumeric</i>\n- *\n- * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing\n+ * Implementation of a PATRICIA Trie (Practical Algorithm to Retrieve Information\n+ * Coded in Alphanumeric).\n+ * <p>\n+ * A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing\n  * all data at the edges of the {@link Trie} (and having empty internal nodes),\n  * PATRICIA stores data in every node. This allows for very efficient traversal,\n  * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)}\n  * is the number of bits in the largest item in the tree. In practice,\n  * operations actually take O(A(K)) time, where A(K) is the average number of\n  * bits of all items in the tree.\n- *\n- * <p>Most importantly, PATRICIA requires very few comparisons to keys while\n+ * <p>\n+ * Most importantly, PATRICIA requires very few comparisons to keys while\n  * doing any operation. While performing a lookup, each comparison (at most\n  * K of them, described above) will perform a single bit comparison against\n  * the given key, instead of comparing the entire key to another key.\n- *\n- * <p>The {@link Trie} can return operations in lexicographical order using the\n+ * <p>\n+ * The {@link Trie} can return operations in lexicographical order using the\n  * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The\n  * {@link Trie} can also scan for items that are 'bitwise' (using an XOR\n  * metric) by the 'select' method. Bitwise closeness is determined by the\n  * {@link KeyAnalyzer} returning true or false for a bit being set or not in\n  * a given key.\n- *\n- * <p>This PATRICIA {@link Trie} supports both variable length & fixed length\n+ * <p>\n+ * This PATRICIA {@link Trie} supports both variable length & fixed length\n  * keys. Some methods, such as {@link #getPrefixedBy(Object)} are suited only\n  * to variable length keys, whereas {@link #getPrefixedByBits(Object, int)} is\n  * suited to fixed-size keys.\n- *\n- * <p>Any methods here that take an {@link Object} argument may throw a\n+ * <p>\n+ * Any methods here that take an {@link Object} argument may throw a\n  * {@link ClassCastException} if the method is expecting an instance of K\n  * and it isn't K.\n  *\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrieBase.java\n  * @since 4.0\n  * @version $Id$\n  */\n-abstract class PatriciaTrieBase<K, V> extends AbstractTrie<K, V> {\n+abstract class PatriciaTrieBase<K, V> extends AbstractBitwiseTrie<K, V> {\n \n     private static final long serialVersionUID = 5155253417231339498L;\n \n--- a/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n         this.delegate = trie;\n-    }\n-\n-    public synchronized Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n-        return delegate.select(key, cursor);\n-    }\n-\n-    public synchronized Entry<K, V> select(final K key) {\n-        return delegate.select(key);\n-    }\n-\n-    public synchronized K selectKey(final K key) {\n-        return delegate.selectKey(key);\n-    }\n-\n-    public synchronized V selectValue(final K key) {\n-        return delegate.selectValue(key);\n     }\n \n     public synchronized Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n--- a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n             throw new IllegalArgumentException(\"Trie must not be null\");\n         }\n         this.delegate = trie;\n-    }\n-\n-    public Entry<K, V> select(final K key, final Cursor<? super K, ? super V> cursor) {\n-        final Cursor<K, V> c = new Cursor<K, V>() {\n-            public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n-                final Decision decision = cursor.select(entry);\n-                switch (decision) {\n-                    case REMOVE:\n-                    case REMOVE_AND_EXIT:\n-                        throw new UnsupportedOperationException();\n-                    default:\n-                        // other decisions are fine\n-                        break;\n-                }\n-\n-                return decision;\n-            }\n-        };\n-\n-        return delegate.select(key, c);\n-    }\n-\n-    public Entry<K, V> select(final K key) {\n-        return delegate.select(key);\n-    }\n-\n-    public K selectKey(final K key) {\n-        return delegate.selectKey(key);\n-    }\n-\n-    public V selectValue(final K key) {\n-        return delegate.selectValue(key);\n     }\n \n     public Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n     }\n \n     public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n-        return Collections.unmodifiableSortedMap(\n-                delegate.subMap(fromKey, toKey));\n+        return Collections.unmodifiableSortedMap(delegate.subMap(fromKey, toKey));\n     }\n \n     public SortedMap<K, V> tailMap(final K fromKey) {\n     }\n \n     public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n-        return Collections.unmodifiableSortedMap(\n-                delegate.getPrefixedBy(key, offset, length));\n+        return Collections.unmodifiableSortedMap(delegate.getPrefixedBy(key, offset, length));\n     }\n \n     public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n-        return Collections.unmodifiableSortedMap(\n-                delegate.getPrefixedBy(key, length));\n+        return Collections.unmodifiableSortedMap(delegate.getPrefixedBy(key, length));\n     }\n \n     public SortedMap<K, V> getPrefixedBy(final K key) {\n-        return Collections.unmodifiableSortedMap(\n-                delegate.getPrefixedBy(key));\n+        return Collections.unmodifiableSortedMap(delegate.getPrefixedBy(key));\n     }\n \n     public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n-        return Collections.unmodifiableSortedMap(\n-                delegate.getPrefixedByBits(key, lengthInBits));\n+        return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n     }\n \n     public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {", "timestamp": 1370901938, "metainfo": ""}