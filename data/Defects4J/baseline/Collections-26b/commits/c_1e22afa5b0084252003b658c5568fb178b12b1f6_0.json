{"sha": "1e22afa5b0084252003b658c5568fb178b12b1f6", "log": "Added new testing code submitted by Paul Jack < pjack at sfaf dot org >   ", "commit": "\n--- a/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.3 2002/02/22 02:18:50 mas Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/02/22 02:18:50 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.4 2002/05/28 06:51:03 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/28 06:51:03 $\n  *\n  * ====================================================================\n  *\n     public static void main(final String unusedArgs[]) {\n         junit.textui.TestRunner.run(TestDoubleOrderedMap.class);\n     }\n+\n+    /**\n+     *  Override the Map.put() test because it tries put with the same key\n+     *  which is invalid in the modified double ordered map contract. (The\n+     *  DoubleOrderedMap documentation states that an IllegalArgumentException\n+     *  is thrown when a key is tried to be put into the map again.  This\n+     *  differs from the standard Map contract which would replace the value\n+     *  for that key and return it.\n+     **/\n+    public void testMapPut() {\n+    }\n }\n--- a/src/test/org/apache/commons/collections/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/TestLRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.20 2002/05/09 03:20:59 mas Exp $\n- * $Revision: 1.20 $\n- * $Date: 2002/05/09 03:20:59 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.21 2002/05/28 06:51:03 mas Exp $\n+ * $Revision: 1.21 $\n+ * $Date: 2002/05/28 06:51:03 $\n  *\n  * ====================================================================\n  *\n import java.util.Iterator;\n import java.util.Map;\n import java.util.HashMap;\n+import java.util.Set;\n \n /**\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n- * @version $Id: TestLRUMap.java,v 1.20 2002/05/09 03:20:59 mas Exp $\n+ * @version $Id: TestLRUMap.java,v 1.21 2002/05/28 06:51:03 mas Exp $\n  */\n public class TestLRUMap extends TestSequencedHashMap\n {\n         assertTrue(\"newest key is '2'\",counter.get(1).equals(\"2\"));\n     }\n \n+\n+    protected void entrySetEqualsMap(Set set, Map m) {\n+        // Overridden because LRUMap.get(Object) actually alters the map,\n+        // so there's no way to verify that the entry set and map contain\n+        // the same entries\n+    }\n+\n     private class LRUCounter extends LRUMap {\n         int removedCount = 0;\n         ArrayList list = new ArrayList(3); \n--- a/src/test/org/apache/commons/collections/TestMap.java\n+++ b/src/test/org/apache/commons/collections/TestMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.15 2002/05/08 17:54:28 morgand Exp $\n- * $Revision: 1.15 $\n- * $Date: 2002/05/08 17:54:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestMap.java,v 1.16 2002/05/28 06:51:03 mas Exp $\n+ * $Revision: 1.16 $\n+ * $Date: 2002/05/28 06:51:03 $\n  *\n  * ====================================================================\n  *\n import junit.framework.*;\n import java.io.IOException;\n import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.ConcurrentModificationException;\n import java.util.Map;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.Set;\n import java.util.Iterator;\n+import java.util.HashMap;\n import java.util.HashSet;\n import java.util.NoSuchElementException;\n \n  *\n  * @author Michael Smith\n  * @author Rodney Waldhoff\n- * @version $Id: TestMap.java,v 1.15 2002/05/08 17:54:28 morgand Exp $\n+ * @version $Id: TestMap.java,v 1.16 2002/05/28 06:51:03 mas Exp $\n  */\n public abstract class TestMap extends TestObject {\n \n         Map fm = makeFullMap();\n \n         for(int i = 0; i < keys.length; i++) {\n-            assertTrue(\"Map must contain key for a mapping in the map.\", \n-                       fm.containsKey(keys[i]));\n+            assertTrue(\"Map must contain key for a mapping in the map. \" +\n+\t\t       \"Missing: \" + keys[i], fm.containsKey(keys[i]));\n         }\n     }\n \n         }\n     }\n \n-    // TODO: test entrySet().clear()\n-    // TODO: test entrySet().add() throws OperationNotSupported\n-    // TODO: test entrySet().addAll() throws OperationNotSupported\n-    // TODO: test entrySet().contains(Object)\n-    // TODO: test entrySet().containsAll(Collection)\n-    // TODO: test entrySet().equals(Object)\n-    // TODO: test entrySet().hashCode()\n-    // TODO: test entrySet().toArray()\n-    // TODO: test entrySet().toArray(Object[] a)\n-    // TODO: test entrySet().remove(Object)\n-    // TODO: test entrySet().removeAll(Collection)\n-    // TODO: test entrySet().retainAll(Collection)\n+    /**\n+     *  Tests Map.entrySet().clear() using Map.isEmpty() and\n+     *  Map.entrySet().isEmpty().  \n+     **/\n+    public void testEntrySetClear() {\n+        if (!isAddRemoveModifiable()) return;\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+        set.clear();\n+        assertTrue(\"entrySet should be empty after clear\", set.isEmpty());\n+        assertTrue(\"map should be empty after entrySet.clear()\", m.isEmpty());\n+    }\n+\n+\n+    /**\n+     *  Tests Map.entrySet().add(Object);\n+     **/\n+    public void testEntrySetAdd() {\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+        try {\n+            set.add(new Object());\n+            fail(\"entrySet().add should raise UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests Map.entrySet().addAll(Collection);\n+     **/\n+    public void testEntrySetAddAll() {\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+        try {\n+            set.addAll(java.util.Collections.singleton(new Object()));\n+            fail(\"entrySet().addAll(Collection) should raise \" +\n+\t\t \"UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     *  Tests Map.entrySetContainsAll(Collection)\n+     **/\n+    public void testEntrySetContainsAll() {\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+\n+        java.util.ArrayList list = new java.util.ArrayList();\n+        Iterator iterator = set.iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            list.add(new DefaultMapEntry(entry.getKey(), entry.getValue()));\n+\n+\t    assertTrue(\"entrySet().containsAll failed\", set.containsAll(list));\n+        }\n+\n+        list.add(new Object());\n+        assertTrue(\"entrySet().containsAll failed\", !set.containsAll(list));\n+    }\n+\n+\n+    /**\n+     *  Tests entrySet().equals(Object)\n+     **/\n+    public void testEntrySetEquals() {\n+        Map m = makeFullMap();\n+        Map m2 = new HashMap(m);\n+        assertTrue(\"Equal maps should have equal entrySets\", \n+\t\t   m.entrySet().equals(m2.entrySet()));\n+\n+        assertTrue(\"entrySet.equals(null) returned true\", \n+\t\t   !m.entrySet().equals(null));\n+        assertTrue(\"Unequal maps should have unequal entrySets\", \n+\t\t   !m.entrySet().equals(Collections.EMPTY_SET));\n+    }\n+\n+\n+    /**\n+     *  Test entrySet().hashCde()\n+     **/\n+    public void testEntrySetHashCode() {\n+        Map m = makeFullMap();\n+        Map m2 = new HashMap(m);\n+        Set set = m.entrySet();\n+        Set set2 = m2.entrySet();\n+        assertTrue(\"hashCode of equal entrySets should be same\", \n+\t\t   set.hashCode() == set2.hashCode());\n+    }\n+\n+\n+    /**\n+     *  Test entrySet().toArray() and entrySet().toArray(Object[])\n+     **/\n+    public void testEntrySetToArray() {\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+        Object[] a = set.toArray();\n+        assertTrue(\"entrySet.toArray() should be same size as map\", \n+\t\t   a.length == m.size());\n+\n+        a = set.toArray(new Object[0]);\n+        assertTrue(\"entrySet.toArray(new Object[0]) should be same size \" +\n+\t\t   \"as map\", a.length == m.size());\n+\n+        a = new Object[m.size() * 2];\n+        a[m.size()] = new Object();\n+        a = set.toArray(a);\n+        assertTrue(\"entrySet.toArray(new Object[m.size * 2]) should set \" +\n+\t\t   \"last element to null\", a[m.size()] == null);\n+\n+        a = set.toArray(new Map.Entry[0]);\n+        assertTrue(\"entrySet.toArray(new Map.Entry[0]) should return \" +\n+\t\t   \"instanceof Map.Entry[]\", a instanceof Map.Entry[]);\n+\n+        try {\n+            a = set.toArray(new String[0]);\n+            fail(\"entrySet.toArray(new String[]) should raise \" +\n+\t\t \"ArrayStoreException.\");\n+        } catch (ArrayStoreException e) {\n+            // expected\n+        }\n+        \n+    }\n+\n+    /**\n+     *  Tests entrySet().remove(Object)\n+     **/\n+    public void testEntrySetRemove2() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+\n+        boolean r = set.remove(null);\n+        assertTrue(\"entrySet.remove(null) should return false\", !r);\n+\n+        r = set.remove(\"Not a Map.Entry\");\n+        assertTrue(\"entrySet.remove should return false for non-Map.Entry\", \n+\t\t   !r);\n+\n+\tm = makeEmptyMap();\n+\tset = m.entrySet();\n+\n+\tObject[] keys = getSampleKeys();\n+\tObject[] values = getSampleValues();\n+\n+\tfor(int i = 0; i < keys.length; i++) {\n+\t    // remove on all elements should return false because the map is\n+\t    // empty.\n+\t    r = set.remove(new DefaultMapEntry(keys[i], values[i]));\n+\t    assertTrue(\"entrySet.remove for nonexistent entry should \" +\n+\t\t       \"return false\", !r);\n+\t}\n+\n+\t// reset to full map to check actual removes\n+\tm = makeFullMap();\n+\tset = m.entrySet();\n+\n+        int size = m.size();\n+        Map.Entry entry = (Map.Entry)set.iterator().next();\n+        r = set.remove(entry);\n+        assertTrue(\"entrySet.remove for internal entry should return true\", r);\n+        assertTrue(\"entrySet.size should shrink after successful remove\", \n+\t\t   set.size() == size - 1);\n+        assertTrue(\"map size should shrink after succuessful entrySet.remove\", \n+\t\t   m.size() == size - 1);\n+        entrySetEqualsMap(set, m);\n+\n+        size--;\n+        entry = (Map.Entry)set.iterator().next();\n+        entry = new DefaultMapEntry(entry.getKey(), entry.getValue());\n+        r = set.remove(entry);\n+        assertTrue(\"entrySet.remove for external entry should return true\", r);\n+        assertTrue(\"entrySet.size should shrink after successful remove\", \n+\t\t   set.size() == size - 1);\n+        assertTrue(\"map size should shrink after succuessful entrySet.remove\",\n+\t\t   m.size() == size - 1);\n+        assertTrue(\"After remove, entrySet should not contain element\", \n+\t\t   !set.contains(entry));\n+        entrySetEqualsMap(set, m);\n+        r = set.remove(entry);\n+        assertTrue(\"second entrySet.remove should return false\", !r);\n+    }\n+\n+\n+    /**\n+     *  Tests entrySet().removeAll() and entrySet().retainAll()\n+     **/\n+    public void testEntrySetBulkRemoveOperations() {\n+\tif (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeFullMap();\n+        Set set = m.entrySet();\n+        Map m2 = new HashMap(m);\n+        Set set2 = m2.entrySet();\n+\n+        Object[] entries = set2.toArray();\n+        Collection c = Arrays.asList(entries).subList(2, 5);\n+        boolean r = set.removeAll(c);\n+        set2.removeAll(c);\n+        assertTrue(\"entrySet().removeAll() returned false\", r);\n+        assertTrue(\"entrySet().removeAll() failed\", m2.equals(m));\n+        assertTrue(\"entrySet().removeAll() returned true\", !set.removeAll(c));\n+\n+        m = makeFullMap();\n+        set = m.entrySet();\n+        m2 = new HashMap(m);\n+        set2 = m2.entrySet();\n+        entries = set2.toArray();\n+        c = Arrays.asList(entries).subList(2, 5);\n+        r = set.retainAll(c);\n+        set2.retainAll(c);\n+        assertTrue(\"entrySet().retainAll returned false\", r);\n+        assertTrue(\"entrySet().retainAll() failed\", m2.equals(m));\n+        assertTrue(\"entrySet().retainAll returned true\", !set.retainAll(c));\n+    }\n+\n \n     /**\n      *  Tests:\n \n         while(iter.hasNext()) {\n             Map.Entry entry = (Map.Entry)iter.next();\n-            \n-            assertTrue(\"Entry key from entry set iterator must exist in map\",\n-                       m.containsKey(entry.getKey()));\n+\n+            assertTrue(\"Entry key from entry set iterator must exist in map: \" +\n+\t\t       entry, m.containsKey(entry.getKey()));\n             try {\n                 iter.remove();\n                 // note: we do not check that the mapping was actually removed\n     }\n \n     /**\n+     *  utility method to ensure that a set of Map.Entry objects matches those\n+     *  found in the specified map.\n+     **/\n+    protected void entrySetEqualsMap(Set set, Map m) {\n+        Iterator iterator = set.iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+            assertTrue(\"map should contain key found in entrySet\", \n+\t\t       m.containsKey(key));\n+            Object v2 = m.get(key);\n+            assertTrue(\"map should contain entry found in entrySet\", \n+\t\t       (value == null) ? v2 == null : value.equals(v2));\n+        }\n+    }\n+\n+\n+    /**\n      *  Tests whether the map's entrySet() is backed by the map by making sure\n      *  a put in the map is reflected in the entrySet.  This test does nothing\n      *  if add/remove modifications are not supported.\n                      m.isEmpty(), s.isEmpty());\n         assertEquals(\"entrySet() must adjust size when map changes.\",\n                      m.size(), s.size());\n-        // TODO: test set and map reflect the same contents\n+\n+        entrySetEqualsMap(s, m);\n     }\n \n     /**\n      *  Tests whether the map's entrySet() is backed by the map by making sure\n-     *  a remove from the map is reflected in the entrySet.  This test does nothing\n-     *  if add/remove modifications are not supported.\n+     *  a remove from the map is reflected in the entrySet.  This test does\n+     *  nothing if add/remove modifications are not supported.\n      **/\n     public void testEntrySetChangesWithMapRemove() {\n         if(!isAddRemoveModifiable()) return;\n                          m.isEmpty(), s.isEmpty());\n             assertEquals(\"entrySet() must adjust size when map changes.\",\n                          m.size(), s.size());\n-            //TODO: test set and map reflect the same contents\n-        }\n-    }\n-\n-    // TODO: test entrySet() changes after Map.remove\n-    // TODO: test entrySet() changes after Map.clear\n-    // TODO: test entrySet() changes after Map.putAll\n+            entrySetEqualsMap(s, m);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests whether the map's entrySet() is backed by the map by making sure\n+     *  a clear on the map is reflected in the entrySet.  This test does\n+     *  nothing if add/remove modifications are not supported.\n+     **/\n+    public void testEntrySetChangesWithMapClear() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeFullMap();\n+        Set s = m.entrySet();\n+        m.clear();\n+        assertTrue(\"entrySet() must be empty after map.clear()\", s.isEmpty());\n+    }\n+\n+\n+    /**\n+     *  Tests whether the map's entrySet() is backed by the map by making sure\n+     *  a putAll on the map is reflected in the entrySet.  This test does\n+     *  nothing if add/remove modifications are not supported.\n+     **/\n+    public void testEntrySetChangesWithMapPutAll() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeFullMap();\n+        Set s = m.entrySet();\n+\n+        Map m2 = new HashMap();\n+        m2.put(\"1\", \"One\");\n+        m2.put(\"2\", \"Two\");\n+        m2.put(\"3\", \"Three\");\n+\n+        m.putAll(m2);\n+        entrySetEqualsMap(s, m);\n+    }\n+\n \n     /**\n      *  Tests whether the map's entrySet() is backed by the map by making sure\n         }\n     }\n \n-    // TODO: test map changes after entrySet().remove\n-    // TODO: test map changes after entrySet().removeAll\n-    // TODO: test map changes after entrySet().retainAll\n-\n+    /**\n+     *  Tests Map.equals(Object)\n+     **/\n     public void testMapEquals() {\n-        // XXX finish me\n-    }\n-\n+        Map m = makeEmptyMap();\n+        assertTrue(\"Empty maps unequal.\", m.equals(new HashMap()));\n+\n+        m = makeFullMap();\n+        Map m2 = new HashMap();\n+        m2.putAll(m);\n+        assertTrue(\"Full maps unequal.\", m.equals(m2));\n+\n+\t// modify the HashMap created from the full map and make sure this\n+\t// change results in map.equals() to return false.\n+        Iterator iter = m2.keySet().iterator();\n+        iter.next();\n+        iter.remove();\n+        assertTrue(\"Different maps equal.\", !m.equals(m2));\n+\n+        assertTrue(\"equals(null) returned true.\", !m.equals(null));\n+        assertTrue(\"equals(new Object()) returned true.\", \n+\t\t   !m.equals(new Object()));\n+    }\n+\n+    /**\n+     *  Tests Map.get(Object)\n+     **/\n     public void testMapGet() {\n-        // XXX finish me\n-    }\n-\n+        Map m = makeEmptyMap();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Empty map.get() should return null.\", \n+\t\t       m.get(keys[i]) == null);\n+        }\n+\n+        m = makeFullMap();\n+        for (int i = 0; i < keys.length; i++) {\n+\t    assertEquals(\"Full map.get() should return value from mapping.\", \n+\t\t\t values[i], m.get(keys[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests Map.hashCode()\n+     **/\n     public void testMapHashCode() {\n-        // XXX finish me\n-    }\n-\n+        Map m = makeEmptyMap();\n+\tMap m2 = new HashMap();\n+        assertTrue(\"Empty maps have different hashCodes.\", \n+\t\t   m.hashCode() == m2.hashCode());\n+\n+        m = makeFullMap();\n+        m2.putAll(m);\n+        assertTrue(\"Equal maps have different hashCodes.\", \n+\t\t   m.hashCode() == m2.hashCode());\n+    }\n+\n+    /**\n+     *  Tests Map.toString().  Since the format of the string returned by the\n+     *  toString() method is not defined in the Map interface, there is no\n+     *  common way to test the results of the toString() method.  Thereforce,\n+     *  it is encouraged that Map implementations override this test with one\n+     *  that checks the format matches any format defined in its API.  This\n+     *  default implementation just verifies that the toString() method does\n+     *  not return null.\n+     **/\n+    public void testMapToString() {\n+        Map m = makeEmptyMap();\n+        String s = m.toString();\n+        assertTrue(\"Empty map toString() should not return null\", s != null);\n+    }\n+\n+    /**\n+     *  Tests Map.keySet()\n+     **/\n     public void testMapKeySet() {\n-        // XXX finish me\n+        Map m = makeFullMap();\n+        Map m2 = new HashMap(m);\n+        assertTrue(\"Equal maps have unequal keySets.\", \n+\t\t   m.keySet().equals(m2.keySet()));\n     }\n     \n     //-------TEST AGAINST OPTIONAL OPERATIONS, ENABLE IN TEST SUBCLASSES\n         assertEquals(\"Map is the right size\",map.size(), getSampleKeys().length);\n     }\n \n-    /*\n-        // optional operation\n-public void testMapClear() {\n-    // XXX finish me\n-}\n-\n-    // optional operation\n+    /**\n+     *  Tests Map.put(Object, Object)\n+     **/\n     public void testMapPut() {\n-        // XXX finish me\n-    }\n-\n-    // optional operation\n+        if (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeEmptyMap();\n+\n+\tObject[] keys = getSampleKeys();\n+\tObject[] values = getSampleValues();\n+\tObject[] newValues = getNewSampleValues();\n+\n+\tfor(int i = 0; i < keys.length; i++) {\n+\t    Object o = m.put(keys[i], values[i]);\n+\t    assertTrue(\"First map.put should return null\", o == null);\n+\t    assertTrue(\"Map should contain key after put\", \n+\t\t       m.containsKey(keys[i]));\n+\t    assertTrue(\"Map should contain value after put\", \n+\t\t       m.containsValue(values[i]));\n+\t}\n+\t\n+\tfor(int i = 0; i < keys.length; i++) {\n+\t    Object o = m.put(keys[i], newValues[i]);\n+\t    assertEquals(\"Second map.put should return previous value\",\n+\t\t\t values[i], o);\n+\t    assertTrue(\"Map should still contain key after put\",\n+\t\t       m.containsKey(keys[i]));\n+\t    assertTrue(\"Map should contain new value after put\",\n+\t\t       m.containsValue(newValues[i]));\n+\n+\t    // if duplicates are allowed, we're not guarunteed that the value\n+\t    // no longer exists, so don't try checking that.\n+\t    if(!useDuplicateValues()) {\n+\t\tassertTrue(\"Map should not contain old value after second put\",\n+\t\t\t   !m.containsValue(values[i]));\n+\t    }\n+\t}\n+    }\n+\n+    /**\n+     *  Tests Map.putAll(Collection)\n+     **/\n     public void testMapPutAll() {\n-        // XXX finish me\n-    }\n-\n-    // optional operation\n+        if (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeEmptyMap();\n+\tMap m2 = makeFullMap();\n+\n+\tm.putAll(m2);\n+\n+        assertTrue(\"Maps should be equal after putAll\", m.equals(m2));\n+\n+\t// repeat test with a different map implementation\n+\n+\tm2 = new HashMap();\n+\tObject[] keys = getSampleKeys();\n+\tObject[] values = getSampleValues();\n+\tfor(int i = 0; i < keys.length; i++) {\n+\t    m2.put(keys[i], values[i]);\n+\t}\n+\t\n+\tm = makeEmptyMap();\n+\tm.putAll(m2);\n+\t\n+\tassertTrue(\"Maps should be equal after putAll\", m.equals(m2));\n+    }\n+\n+    /**\n+     *  Tests Map.remove(Object)\n+     **/\n     public void testMapRemove() {\n-        // XXX finish me\n-    }\n-\n+        if (!isAddRemoveModifiable()) return;\n+\n+        Map m = makeEmptyMap();\n+\tObject[] keys = getSampleKeys();\n+\tfor(int i = 0; i < keys.length; i++) {\n+\t    Object o = m.remove(keys[i]);\n+\t    assertTrue(\"First map.remove should return null\", o == null);\n+\t}\n+\n+\tm = makeFullMap();\n+\tint startSize = m.size();\n+\n+\tObject[] values = getSampleValues();\n+\n+\tfor(int i = 0; i < keys.length; i++) {\n+\t    Object o = m.remove(keys[i]);\n+\n+\t    assertEquals(\"map.remove with valid key should return value\",\n+\t\t\t values[i], o);\n+\t    assertEquals(\"map.remove should reduce size by one\",\n+\t\t\t (startSize - i) - 1, m.size());\n+\t}\n+    }\n+\n+    /**\n+     *  Tests Map.values()\n+     **/\n     public void testMapValues() {\n-        // XXX finish me\n+        Map m = makeFullMap();\n+\n+        // since Collection.equals is reference-based, have to do\n+        // this the long way...\n+\n+\tObject[] values = getSampleValues();\n+\n+\tCollection c = m.values();\n+\t\n+\tassertEquals(\"values() should have same size as map\", \n+\t\t     m.size(), c.size());\n+\n+\tassertEquals(\"values() should have same number of sample values\",\n+\t\t     values.length, c.size());\n+\n+\tboolean[] matched = new boolean[values.length];\n+\n+\tIterator iter = c.iterator();\n+\twhile(iter.hasNext()) {\n+\t    Object o = iter.next();\n+\t    boolean found = false;\n+\n+\t    for(int i = 0; i < values.length; i++) {\n+\t\t// skip values already matched\n+\t\tif(matched[i]) continue;\n+\t\t\n+\t\tif((o == null && values[i] == null) ||\n+\t\t   (o != null && o.equals(values[i]))) {\n+\t\t    matched[i] = true;\n+\t\t    found = true;\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n+\t    if(!found) {\n+\t\t// no match for this element\n+\t\tfail(\"values() returned an unexpected value\");\n+\t    }\n+\t}\n+\n+\tfor(int i = 0; i < matched.length; i++) {\n+\t    if(!matched[i]) {\n+\t\tfail(\"values() did not return all values from map\");\n+\t    }\n+\t}\n     }\n \n     /**\n--- a/src/test/org/apache/commons/collections/TestMultiHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestMultiHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.3 2002/02/26 00:13:37 morgand Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/02/26 00:13:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.4 2002/05/28 06:51:03 mas Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/05/28 06:51:03 $\n  *\n  * ====================================================================\n  *\n         // for.\n         return;\n     }\n+\n+    // Next four are overriden \n+    // because MultiHashMap values are always a collection\n+\n+    // TODO: implement the tests to ensure that Map.get(Object) returns the\n+    // appropriate collection of values\n+\n+    public void testMapGet() {\n+    }\n+\n+    public void testMapPut() {\n+    }\n+\n+    public void testMapPutAll() {\n+    }\n+\n+    public void testMapRemove() {\n+    }\n+\n+    public void testMapValues() {\n+    }\n+\n }", "timestamp": 1022568663, "metainfo": ""}