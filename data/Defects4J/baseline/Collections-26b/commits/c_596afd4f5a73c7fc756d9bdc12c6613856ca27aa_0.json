{"sha": "596afd4f5a73c7fc756d9bdc12c6613856ca27aa", "log": "Moved and renamed - was originally from Velocity CVS (which came from elswhere...) PR: Obtained from: Submitted by: Reviewed by:   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n+package org.apache.commons.collections;\n+\n+/*\n+ * Copyright (c) 2001 The Java Apache Project.  All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. All advertising materials mentioning features or use of this\n+ *    software must display the following acknowledgment:\n+ *    \"This product includes software developed by the Java Apache\n+ *    Project for use in the Apache JServ servlet engine project\n+ *    <http://java.apache.org/>.\"\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written \n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Commons\" nor may \"Apache\" appear in their names without prior \n+ *    written permission of the Apache Group.\n+ *\n+ * 6. Redistributions of any form whatsoever must retain the following\n+ *    acknowledgment:\n+ *    \"This product includes software developed by the Java Apache\n+ *    Project for use in the Apache JServ servlet engine project\n+ *    <http://java.apache.org/>.\"\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE JAVA APACHE PROJECT \"AS IS\" AND ANY\n+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE JAVA APACHE PROJECT OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\n+ * OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Java Apache Group. For more information\n+ * on the Java Apache Project and the Apache JServ Servlet Engine project,\n+ * please see <http://java.apache.org/>.\n+ *\n+ */\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.LineNumberReader;\n+import java.io.OutputStream;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+import java.util.StringTokenizer;\n+import java.util.Vector;\n+\n+/**\n+ * This class extends normal Java properties by adding the possibility\n+ * to use the same key many times concatenating the value strings\n+ * instead of overwriting them.\n+ *\n+ * <p>The Extended Properties syntax is explained here:\n+ *\n+ * <ul>\n+ *  <li>\n+ *   Each property has the syntax <code>key = value</code>\n+ *  </li>\n+ *  <li>\n+ *   The <i>key</i> may use any character but the equal sign '='.\n+ *  </li>\n+ *  <li>\n+ *   <i>value</i> may be separated on different lines if a backslash\n+ *   is placed at the end of the line that continues below.\n+ *  </li>\n+ *  <li>\n+ *   If <i>value</i> is a list of strings, each token is separated\n+ *   by a comma ','.\n+ *  </li>\n+ *  <li>\n+ *   Commas in each token are escaped placing a backslash right before\n+ *   the comma.\n+ *  </li>\n+ *  <li>\n+ *   If a <i>key</i> is used more than once, the values are appended\n+ *   like if they were on the same line separated with commas.\n+ *  </li>\n+ *  <li>\n+ *   Blank lines and lines starting with character '#' are skipped.\n+ *  </li>\n+ *  <li>\n+ *   If a property is named \"include\" (or whatever is defined by\n+ *   setInclude() and getInclude() and the value of that property is\n+ *   the full path to a file on disk, that file will be included into\n+ *   the ConfigurationsRepository. You can also pull in files relative\n+ *   to the parent configuration file. So if you have something\n+ *   like the following:\n+ *\n+ *   include = additional.properties\n+ *\n+ *   Then \"additional.properties\" is expected to be in the same\n+ *   directory as the parent configuration file.\n+ * \n+ *   Duplicate name values will be replaced, so be careful.\n+ *\n+ *  </li>\n+ * </ul>\n+ *\n+ * <p>Here is an example of a valid extended properties file:\n+ *\n+ * <p><pre>\n+ *      # lines starting with # are comments\n+ *\n+ *      # This is the simplest property\n+ *      key = value\n+ *\n+ *      # A long property may be separated on multiple lines\n+ *      longvalue = aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa \\\n+ *                  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+ *\n+ *      # This is a property with many tokens\n+ *      tokens_on_a_line = first token, second token\n+ *\n+ *      # This sequence generates exactly the same result\n+ *      tokens_on_multiple_lines = first token\n+ *      tokens_on_multiple_lines = second token\n+ *\n+ *      # commas may be escaped in tokens\n+ *      commas.excaped = Hi\\, what'up?\n+ * </pre>\n+ *\n+ * <p><b>NOTE</b>: this class has <b>not</b> been written for\n+ * performance nor low memory usage.  In fact, it's way slower than it\n+ * could be and generates too much memory garbage.  But since\n+ * performance is not an issue during intialization (and there is not\n+ * much time to improve it), I wrote it this way.  If you don't like\n+ * it, go ahead and tune it up!\n+ *\n+ *\n+ * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n+ * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n+ * @author <a href=\"mailto:daveb@miceda-data\">Dave Bryson</a>\n+ * @author <a href=\"mailto:jvanzyl@periapt.com\">Jason van Zyl</a>\n+ * @author <a href=\"mailto:geirm@optonline.net\">Geir Magnusson Jr.</a>\n+ * @author <a href=\"mailto:leon@opticode.co.za\">Leon Messerschmidt</a>\n+ * @version $Id: ExtendedProperties.java,v 1.1 2001/04/16 05:01:03 geirm Exp $\n+ */\n+public class ExtendedProperties extends Hashtable\n+{\n+    /**\n+     * Default configurations repository.\n+     */\n+    private ExtendedProperties defaults;\n+\n+    /**\n+     * The file connected to this repository (holding comments and\n+     * such).\n+     *\n+     * @serial\n+     */\n+    protected String file;\n+\n+    /**\n+     * Base path of the configuration file used to create\n+     * this Configuration object.\n+     */\n+    protected String basePath;\n+\n+    /**\n+     * File separator.\n+     */\n+    protected String fileSeparator = System.getProperty(\"file.separator\");\n+\n+    /**\n+     * Has this configuration been intialized.\n+     */\n+    protected boolean isInitialized = false;\n+\n+    /**\n+     * This is the name of the property that can point to other\n+     * properties file for including other properties files.\n+     */\n+    protected static String include = \"include\";\n+\n+    /**\n+     * These are the keys in the order they listed\n+     * in the configuration file. This is useful when\n+     * you wish to perform operations with configuration\n+     * information in a particular order.\n+     */\n+    protected ArrayList keysAsListed = new ArrayList();\n+\n+    /**\n+     * This class is used to read properties lines.  These lines do\n+     * not terminate with new-line chars but rather when there is no\n+     * backslash sign a the end of the line.  This is used to\n+     * concatenate multiple lines for readability.\n+     */\n+    class PropertiesReader extends LineNumberReader\n+    {\n+        /**\n+         * Constructor.\n+         *\n+         * @param reader A Reader.\n+         */\n+        public PropertiesReader(Reader reader)\n+        {\n+            super(reader);\n+        }\n+\n+        /**\n+         * Read a property.\n+         *\n+         * @return A String.\n+         * @exception IOException.\n+         */\n+        public String readProperty() throws IOException\n+        {\n+            StringBuffer buffer = new StringBuffer();\n+\n+            try\n+            {\n+                while (true)\n+                {\n+                    String line = readLine().trim();\n+                    if ((line.length() != 0) && (line.charAt(0) != '#'))\n+                    {\n+                        if (line.endsWith(\"\\\\\"))\n+                        {\n+                            line = line.substring(0, line.length() - 1);\n+                            buffer.append(line);\n+                        }\n+                        else\n+                        {\n+                            buffer.append(line);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            catch (NullPointerException e)\n+            {\n+                return null;\n+            }\n+\n+            return buffer.toString();\n+        }\n+    }\n+\n+    /**\n+     * This class divides into tokens a property value.  Token\n+     * separator is \",\" but commas into the property value are escaped\n+     * using the backslash in front.\n+     */\n+    class PropertiesTokenizer extends StringTokenizer\n+    {\n+        /**\n+         * Constructor.\n+         *\n+         * @param string A String.\n+         */\n+        public PropertiesTokenizer(String string)\n+        {\n+            super(string, \",\");\n+        }\n+\n+        /**\n+         * Check whether the object has more tokens.\n+         *\n+         * @return True if the object has more tokens.\n+         */\n+        public boolean hasMoreTokens()\n+        {\n+            return super.hasMoreTokens();\n+        }\n+\n+        /**\n+         * Get next token.\n+         *\n+         * @return A String.\n+         */\n+        public String nextToken()\n+        {\n+            StringBuffer buffer = new StringBuffer();\n+\n+            while (hasMoreTokens())\n+            {\n+                String token = super.nextToken();\n+                if (token.endsWith(\"\\\\\"))\n+                {\n+                    buffer.append(token.substring(0, token.length() - 1));\n+                    buffer.append(\",\");\n+                }\n+                else\n+                {\n+                    buffer.append(token);\n+                    break;\n+                }\n+            }\n+\n+            return buffer.toString().trim();\n+        }\n+    }\n+\n+    /**\n+     * Creates an empty extended properties object.\n+     */\n+    public ExtendedProperties ()\n+    {\n+        super();\n+    }\n+\n+    /**\n+     * Creates and loads the extended properties from the specified\n+     * file.\n+     *\n+     * @param file A String.\n+     * @exception IOException.\n+     */\n+    public ExtendedProperties(String file) \n+        throws IOException\n+    {\n+        this(file,null);\n+    }\n+\n+    /**\n+     * Creates and loads the extended properties from the specified\n+     * file.\n+     *\n+     * @param file A String.\n+     * @exception IOException.\n+     */\n+    public ExtendedProperties (String file, String defaultFile)\n+        throws IOException\n+    {\n+        this.file = file;\n+        \n+        basePath = new File(file).getAbsolutePath();\n+        basePath = basePath.substring(0, basePath.lastIndexOf(fileSeparator) + 1);\n+        \n+        this.load(new FileInputStream(file));\n+        \n+        if (defaultFile != null)\n+        {\n+            defaults = new ExtendedProperties(defaultFile);\n+        }            \n+    }\n+\n+    /**\n+     * Private initializer method that sets up the generic\n+     * resources.\n+     *\n+     * @exception IOException, if there was an I/O problem.\n+     */\n+    private void init( ExtendedProperties exp ) throws IOException\n+    {\n+        isInitialized = true;\n+    }\n+    \n+    /**\n+     * Indicate to client code whether property\n+     * resources have been initialized or not.\n+     */\n+    public boolean isInitialized()\n+    {\n+        return isInitialized;\n+    }        \n+\n+    /**\n+     * Gets the property value for including other properties files.\n+     * By default it is \"include\".\n+     *\n+     * @return A String.\n+     */\n+    public String getInclude()\n+    {\n+        return this.include;\n+    }\n+\n+    /**\n+     * Sets the property value for including other properties files.\n+     * By default it is \"include\".\n+     *\n+     * @param inc A String.\n+     */\n+    public void setInclude(String inc)\n+    {\n+        this.include = inc;\n+    }\n+\n+    /**\n+     * Load the properties from the given input stream.\n+     *\n+     * @param input An InputStream.\n+     * @exception IOException.\n+     */\n+    public synchronized void load(InputStream input)\n+        throws IOException\n+    {\n+        PropertiesReader reader =\n+            new PropertiesReader(new InputStreamReader(input));\n+\n+        try\n+        {\n+            while (true)\n+            {\n+                String line = reader.readProperty();\n+                int equalSign = line.indexOf('=');\n+\n+                if (equalSign > 0)\n+                {\n+                    String key = line.substring(0, equalSign).trim();\n+                    String value = line.substring(equalSign + 1).trim();\n+\n+                    /*\n+                     * Configure produces lines like this ... just\n+                     * ignore them.\n+                     */\n+                    if (\"\".equals(value))\n+                        continue;\n+\n+                    if (getInclude() != null && \n+                        key.equalsIgnoreCase(getInclude()))\n+                    {\n+                        /*\n+                         * Recursively load properties files.\n+                         */\n+                        File file = null;\n+                        \n+                        if (value.startsWith(fileSeparator))\n+                        {\n+                            /*\n+                             * We have an absolute path so we'll\n+                             * use this.\n+                             */\n+                            file = new File(value);\n+                        }\n+                        else\n+                        {   \n+                            /* \n+                             * We have a relative path, and we have\n+                             * two possible forms here. If we have the\n+                             * \"./\" form then just strip that off first\n+                             * before continuing.\n+                             */\n+                            if (value.startsWith(\".\" + fileSeparator))\n+                            {\n+                                value = value.substring(2);\n+                            }\n+                            \n+                            file = new File(basePath + value);\n+                        }\n+                        \n+                        if (file != null && file.exists() && file.canRead())\n+                        {\n+                            load ( new FileInputStream(file));\n+                        }\n+                    }\n+                    else\n+                    {\n+                        addProperty(key,value);\n+                        //setProperty(key,value);\n+                    }                       \n+                }\n+            }\n+        }\n+        catch (NullPointerException e)\n+        {\n+            /*\n+             * Should happen only when EOF is reached.\n+             */\n+            return;\n+        }\n+    }\n+\n+    /**\n+     *  Gets a property from the configuration.\n+     *\n+     *  @param key property to retrieve\n+     *  @return value as object. Will return user value if exists,\n+     *          if not then default value if exists, otherwise null\n+     */\n+    public Object getProperty( String key)\n+    {\n+        /*\n+         *  first, try to get from the 'user value' store\n+         */\n+        Object o = this.get(key);\n+\n+        if ( o == null)\n+        {\n+            /*\n+             *  if there isn't a value there, get it from the\n+             *  defaults if we have them\n+             */\n+            \n+            if (defaults != null)\n+            {\n+                o = defaults.get(key);\n+            }\n+        }\n+\n+        return o;\n+    }\n+    \n+    /**\n+     * Add a property to the configuration. If it already\n+     * exists then the value stated here will be added\n+     * to the configuration entry. For example, if\n+     *\n+     * resource.loader = file\n+     *\n+     * is already present in the configuration and you\n+     *\n+     * addProperty(\"resource.loader\", \"classpath\")\n+     *\n+     * Then you will end up with a Vector like the\n+     * following:\n+     *\n+     * [\"file\", \"classpath\"]\n+     *\n+     * @param String key\n+     * @param String value\n+     */\n+    //public void setProperty(String key, Object token)\n+    public void addProperty(String key, Object token)\n+    {\n+        Object o = this.get(key);\n+\n+        /*\n+         *  $$$ GMJ\n+         *  FIXME : post 1.0 release, we need to not assume\n+         *  that a scalar is a String - it can be an Object\n+         *  so we should make a little vector-like class\n+         *  say, Foo that wraps (not extends Vector),\n+         *  so we can do things like\n+         *  if ( !( o instanceof Foo) )\n+         *  so we know it's our 'vector' container\n+         *\n+         *  This applies throughout\n+         */\n+        \n+        if (o instanceof String)\n+        {\n+            Vector v = new Vector(2);\n+            v.addElement(o);\n+            v.addElement(token);\n+            put(key, v);\n+        }\n+        else if (o instanceof Vector)\n+        {\n+            ((Vector) o).addElement(token);\n+        }\n+        else\n+        {\n+            /*\n+             * This is the first time that we have seen\n+             * request to place an object in the \n+             * configuration with the key 'key'. So\n+             * we just want to place it directly into\n+             * the configuration ... but we are going to\n+             * make a special exception for String objects\n+             * that contain \",\" characters. We will take\n+             * CSV lists and turn the list into a vector of\n+             * Strings before placing it in the configuration.\n+             * This is a concession for Properties and the\n+             * like that cannot parse multiple same key\n+             * values.\n+             */\n+            if (token instanceof String && ((String)token).indexOf(\",\") > 0)\n+            {\n+                PropertiesTokenizer tokenizer = \n+                    new PropertiesTokenizer((String)token);\n+                    \n+                while (tokenizer.hasMoreTokens())\n+                {\n+                    String value = tokenizer.nextToken();\n+                    \n+                    /*\n+                     * we know this is a string, so make sure it\n+                     * just goes in rather than risking vectorization\n+                     * if it contains an escaped comma\n+                     */\n+                    addStringProperty(key,value);\n+                }\n+            }\n+            else\n+            {\n+                /*\n+                 * We want to keep track of the order the keys\n+                 * are parsed, or dynamically entered into\n+                 * the configuration. So when we see a key\n+                 * for the first time we will place it in\n+                 * an ArrayList so that if a client class needs\n+                 * to perform operations with configuration\n+                 * in a definite order it will be possible.\n+                 */\n+\n+                /*\n+                 * safety check\n+                 */\n+\n+                if( !containsKey( key ) )\n+                {\n+                    keysAsListed.add(key);\n+                }\n+\n+                /*\n+                 * and the value\n+                 */\n+                put(key, token);\n+            }                \n+        }\n+    }\n+\n+\n+    /**\n+     *  Sets a string property w/o checking for commas - used\n+     *  internally when a property has been broken up into\n+     *  strings that could contain escaped commas to prevent\n+     *  the inadvertant vectorization.\n+     *\n+     *  Thanks to Leon Messerschmidt for this one.\n+     *\n+     */\n+    private  void addStringProperty(String key, String token)\n+    {\n+        Object o = this.get(key);\n+\n+        /*\n+         *  $$$ GMJ\n+         *  FIXME : post 1.0 release, we need to not assume\n+         *  that a scalar is a String - it can be an Object\n+         *  so we should make a little vector-like class\n+         *  say, Foo that wraps (not extends Vector),\n+         *  so we can do things like\n+         *  if ( !( o instanceof Foo) )\n+         *  so we know it's our 'vector' container\n+         *\n+         *  This applies throughout\n+         */\n+\n+        /*\n+         *  do the usual thing - if we have a value and \n+         *  it's scalar, make a vector, otherwise add\n+         *  to the vector\n+         */\n+ \n+        if (o instanceof String)\n+        {\n+            Vector v = new Vector(2);\n+            v.addElement(o);\n+            v.addElement(token);\n+            put(key, v);\n+        }\n+        else if (o instanceof Vector)\n+        {\n+            ((Vector) o).addElement(token);\n+        }\n+        else\n+        {\n+            if( !containsKey( key ) )\n+            {\n+                keysAsListed.add(key);\n+            }\n+\n+            put( key, token);\n+        }\n+    }\n+\n+    /**\n+     * Set a property, this will replace any previously\n+     * set values. Set values is implicitly a call\n+     * to clearProperty(key), addProperty(key,value).\n+     *\n+     * @param String key\n+     * @param String value\n+     */\n+    public void setProperty(String key, Object value)\n+    {\n+        clearProperty(key);\n+        addProperty(key,value);\n+    }\n+    \n+    /**\n+     * Save the properties to the given outputstream.\n+     *\n+     * @param output An OutputStream.\n+     * @param header A String.\n+     * @exception IOException.\n+     */\n+    public synchronized void save(OutputStream output,\n+                                  String Header)\n+        throws IOException\n+    {\n+        if(output != null)\n+        {\n+            PrintWriter theWrtr = new PrintWriter(output);\n+            if(Header != null)\n+            {\n+                theWrtr.println(Header);\n+            }\n+            Enumeration theKeys = keys();\n+            while(theKeys.hasMoreElements())\n+            {\n+                String key = (String) theKeys.nextElement();\n+                Object value = get((Object) key);\n+                if(value != null)\n+                {\n+                    if(value instanceof String)\n+                    {\n+                        StringBuffer currentOutput = new StringBuffer();\n+                        currentOutput.append(key);\n+                        currentOutput.append(\"=\");\n+                        currentOutput.append((String) value);\n+                        theWrtr.println(currentOutput.toString());\n+                    }\n+                    else if(value instanceof Vector)\n+                    {\n+                        Vector values = (Vector) value;\n+                        Enumeration valuesEnum = values.elements();\n+                        while(valuesEnum.hasMoreElements())\n+                        {\n+                            String currentElement = \n+                                   (String) valuesEnum.nextElement();\n+                            StringBuffer currentOutput = new StringBuffer();\n+                            currentOutput.append(key);\n+                            currentOutput.append(\"=\");\n+                            currentOutput.append(currentElement);\n+                            theWrtr.println(currentOutput.toString());\n+                        }\n+                    }\n+                }    \n+                theWrtr.println();\n+                theWrtr.flush();\n+            }    \n+        }        \n+    }\n+\n+    /**\n+     * Combines an existing Hashtable with this Hashtable.\n+     *\n+     * Warning: It will overwrite previous entries without warning.\n+     *\n+     * @param Configuration\n+     */\n+    public void combine( ExtendedProperties c)\n+    {\n+        for (Iterator i = c.getKeys() ; i.hasNext() ;)\n+        {\n+            String key = (String) i.next();\n+            //clearProperty(key);\n+            setProperty( key, c.get(key) );\n+        }\n+    }\n+    \n+    /**\n+     * Clear a property in the configuration.\n+     *\n+     * @param String key to remove along with corresponding value.\n+     */\n+    public void clearProperty(String key)\n+    {\n+        if (containsKey(key))\n+        {\n+            /*\n+             * we also need to rebuild the keysAsListed or else\n+             * things get *very* confusing\n+             */\n+\n+            for(int i = 0; i < keysAsListed.size(); i++)\n+            {\n+                if ( ( (String) keysAsListed.get(i)).equals( key ) )\n+                {\n+                    keysAsListed.remove(i);\n+                    break;\n+                }\n+            }\n+\n+            remove(key);\n+        }            \n+    }\n+\n+    /**\n+     * Get the list of the keys contained in the configuration\n+     * repository.\n+     *\n+     * @return An Iterator.\n+     */\n+    public Iterator getKeys()\n+    {\n+        return keysAsListed.iterator();\n+    }\n+\n+    /**\n+     * Get the list of the keys contained in the configuration\n+     * repository that match the specified prefix.\n+     *\n+     * @param prefix The prefix to test against.\n+     * @return An Iterator of keys that match the prefix.\n+     */\n+    public Iterator getKeys(String prefix)\n+    {\n+        Iterator keys = getKeys();\n+        ArrayList matchingKeys = new ArrayList();\n+        \n+        while( keys.hasNext() )\n+        {\n+            Object key = keys.next();\n+            \n+            if( key instanceof String && ((String) key).startsWith(prefix) )\n+            {\n+                matchingKeys.add(key);\n+            }\n+        }\n+        return matchingKeys.iterator();\n+    }\n+\n+    /**\n+     * Create a Configurations object that is a subset\n+     * of this one. Take into account duplicate keys\n+     * by using the setProperty() in Configuration.\n+     *\n+     * @param String prefix\n+     */\n+    public ExtendedProperties subset(String prefix)\n+    {\n+        ExtendedProperties c = new ExtendedProperties();\n+        Iterator keys = getKeys();\n+        boolean validSubset = false;\n+        \n+        while( keys.hasNext() )\n+        {\n+            Object key = keys.next();\n+            \n+            if( key instanceof String && ((String) key).startsWith(prefix) )\n+            {\n+                if (!validSubset)\n+                {\n+                    validSubset = true;\n+                }\n+                \n+                String newKey = null;\n+                \n+                /*\n+                 * Check to make sure that c.subset(prefix) doesn't\n+                 * blow up when there is only a single property\n+                 * with the key prefix. This is not a useful\n+                 * subset but it is a valid subset.\n+                 */\n+                if ( ((String)key).length() == prefix.length())\n+                {\n+                    newKey = prefix;\n+                }\n+                else\n+                {\n+                    newKey = ((String)key).substring(prefix.length() + 1);\n+                }                    \n+                \n+                /*\n+                 * Make sure to use the setProperty() method and not\n+                 * just put(). setProperty() takes care of catching\n+                 * all the keys in the order they appear in a\n+                 * properties files or the order they are set\n+                 * dynamically.\n+                 */\n+\n+                c.setProperty(newKey, get(key));\n+            }\n+        }\n+        \n+        if (validSubset)\n+        {\n+            return c;\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Display the configuration for debugging\n+     * purposes.\n+     */\n+    public void display()\n+    {\n+        Iterator i = getKeys();\n+        \n+        while (i.hasNext())\n+        {\n+            String key = (String) i.next();\n+            Object value = get(key);\n+            System.out.println(key + \" => \" + value);\n+        }\n+    }     \n+\n+    /**\n+     * Get a string associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated string.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a String.\n+     */\n+    public String getString(String key)\n+    {\n+        return getString(key, null);\n+    }\n+\n+    /**\n+     * Get a string associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated string if key is found,\n+     * default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a String.\n+     */\n+    public String getString(String key,\n+                            String defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof String)\n+        {\n+            return (String) value;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getString(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a String object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a list of properties associated with the given\n+     * configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated properties if key is found.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a String/Vector.\n+     * @exception IllegalArgumentException if one of the tokens is\n+     * malformed (does not contain an equals sign).\n+     */\n+    public Properties getProperties(String key)\n+    {\n+        return getProperties(key, new Properties());\n+    }\n+\n+    /**\n+     * Get a list of properties associated with the given\n+     * configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated properties if key is found.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a String/Vector.\n+     * @exception IllegalArgumentException if one of the tokens is\n+     * malformed (does not contain an equals sign).\n+     */\n+    public Properties getProperties(String key,\n+                                    Properties defaults)\n+    {\n+        /*\n+         * Grab an array of the tokens for this key.\n+         */\n+        String[] tokens = getStringArray(key);\n+\n+        /* \n+         * Each token is of the form 'key=value'.\n+         */\n+        Properties props = new Properties(defaults);\n+        for (int i = 0; i < tokens.length; i++)\n+        {\n+            String token = tokens[i];\n+            int equalSign = token.indexOf('=');\n+            if (equalSign > 0)\n+            {\n+                String pkey = token.substring(0, equalSign).trim();\n+                String pvalue = token.substring(equalSign + 1).trim();\n+                props.put(pkey, pvalue);\n+            }\n+            else\n+            {\n+                throw new IllegalArgumentException(\"'\" +\n+                                                   token +\n+                                                   \"' does not contain \" +\n+                                                   \"an equals sign\");\n+            }\n+        }\n+        return props;\n+    }\n+\n+    /**\n+     * Get an array of strings associated with the given configuration\n+     * key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated string array if key is found.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a String/Vector.\n+     */\n+    public String[] getStringArray(String key)\n+    {\n+        Object value = get(key);\n+\n+        // What's your vector, Victor?\n+        Vector vector;\n+        if (value instanceof String)\n+        {\n+            vector = new Vector(1);\n+            vector.addElement(value);\n+        }\n+        else if (value instanceof Vector)\n+        {\n+            vector = (Vector)value;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getStringArray(key);\n+            }\n+            else\n+            {\n+                return new String[0];\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a String/Vector object\");\n+        }\n+\n+        String[] tokens = new String[vector.size()];\n+        for (int i = 0; i < tokens.length; i++)\n+        tokens[i] = (String)vector.elementAt(i);\n+\n+        return tokens;\n+    }\n+\n+    /**\n+     * Get a Vector of strings associated with the given configuration\n+     * key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated Vector.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Vector.\n+     */\n+    public Vector getVector(String key)\n+    {\n+        return getVector(key, null);\n+    }\n+\n+    /**\n+     * Get a Vector of strings associated with the given configuration\n+     * key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated Vector.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Vector.\n+     */\n+    public Vector getVector(String key,\n+                            Vector defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Vector)\n+        {\n+            return (Vector) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Vector v = new Vector(1);\n+            v.addElement((String) value);\n+            put(key, v);\n+            return v;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getVector(key, defaultValue);\n+            }\n+            else\n+            {\n+                return ((defaultValue == null) ?\n+                        new Vector() : defaultValue);\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Vector object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a boolean associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated boolean.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Boolean.\n+     */\n+    public boolean getBoolean(String key)\n+    {\n+        Boolean b = getBoolean(key, (Boolean) null);\n+        if (b != null)\n+        {\n+            return b.booleanValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \"doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a boolean associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated boolean.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Boolean.\n+     */\n+    public boolean getBoolean(String key, boolean defaultValue)\n+    {\n+        return getBoolean(key, new Boolean(defaultValue)).booleanValue();\n+    }\n+\n+    /**\n+     * Get a boolean associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated boolean if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Boolean.\n+     */\n+    public Boolean getBoolean(String key, Boolean defaultValue)\n+    {\n+    \n+        Object value = get(key);\n+\n+        if (value instanceof Boolean)\n+        {\n+            return (Boolean) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            String s = testBoolean((String)value);\n+            Boolean b = new Boolean(s);\n+            put(key, b);\n+            return b;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getBoolean(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Boolean object\");\n+        }\n+    }\n+    \n+    /**\n+     * Test whether the string represent by value maps to a boolean\n+     * value or not. We will allow <code>true</code>, <code>on</code>,\n+     * and <code>yes</code> for a <code>true</code> boolean value, and\n+     * <code>false</code>, <code>off</code>, and <code>no</code> for\n+     * <code>false</code> boolean values.  Case of value to test for\n+     * boolean status is ignored.\n+     *\n+     * @param String The value to test for boolean state.\n+     * @return <code>true</code> or <code>false</code> if the supplied\n+     * text maps to a boolean value, or <code>null</code> otherwise.\n+     */\n+    public String testBoolean(String value)\n+    {\n+        String s = ((String)value).toLowerCase();\n+    \n+        if (s.equals(\"true\") || s.equals(\"on\") || s.equals(\"yes\"))\n+        {\n+            return \"true\";\n+        }\n+        else if (s.equals(\"false\") || s.equals(\"off\") || s.equals(\"no\"))\n+        {\n+            return \"false\";\n+        }\n+        else\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a byte associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated byte.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Byte.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public byte getByte(String key)\n+    {\n+        Byte b = getByte(key, null);\n+        if (b != null)\n+        {\n+            return b.byteValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a byte associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated byte.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Byte.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public byte getByte(String key,\n+                        byte defaultValue)\n+    {\n+        return getByte(key, new Byte(defaultValue)).byteValue();\n+    }\n+\n+    /**\n+     * Get a byte associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated byte if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Byte.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Byte getByte(String key,\n+                        Byte defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Byte)\n+        {\n+            return (Byte) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Byte b = new Byte((String) value);\n+            put(key, b);\n+            return b;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getByte(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Byte object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a short associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated short.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Short.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public short getShort(String key)\n+    {\n+        Short s = getShort(key, null);\n+        if (s != null)\n+        {\n+            return s.shortValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a short associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated short.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Short.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public short getShort(String key,\n+                          short defaultValue)\n+    {\n+        return getShort(key, new Short(defaultValue)).shortValue();\n+    }\n+\n+    /**\n+     * Get a short associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated short if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Short.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Short getShort(String key,\n+                          Short defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Short)\n+        {\n+            return (Short) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Short s = new Short((String) value);\n+            put(key, s);\n+            return s;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getShort(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Short object\");\n+        }\n+    }\n+\n+    /**\n+     * The purpose of this method is to get the configuration resource\n+     * with the given name as an integer.\n+     *\n+     * @param name The resource name.\n+     * @return The value of the resource as an integer.\n+     */\n+    public int getInt(String name)\n+    {\n+        return getInteger(name);\n+    }\n+\n+    /**\n+     * The purpose of this method is to get the configuration resource\n+     * with the given name as an integer, or a default value.\n+     *\n+     * @param name The resource name\n+     * @param def The default value of the resource.\n+     * @return The value of the resource as an integer.\n+     */\n+    public int getInt(String name,\n+                      int def)\n+    {\n+        return getInteger(name, def);\n+    }\n+\n+    /**\n+     * Get a int associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated int.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Integer.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public int getInteger(String key)\n+    {\n+        Integer i = getInteger(key, null);\n+        if (i != null)\n+        {\n+            return i.intValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a int associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated int.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Integer.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public int getInteger(String key,\n+                          int defaultValue)\n+    {\n+        return getInteger(key, new Integer(defaultValue)).intValue();\n+    }\n+\n+    /**\n+     * Get a int associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated int if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Integer.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Integer getInteger(String key,\n+                              Integer defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Integer)\n+        {\n+            return (Integer) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Integer i = new Integer((String) value);\n+            put(key, i);\n+            return i;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getInteger(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Integer object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a long associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated long.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Long.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public long getLong(String key)\n+    {\n+        Long l = getLong(key, null);\n+        if (l != null)\n+        {\n+            return l.longValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a long associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated long.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Long.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public long getLong(String key,\n+                        long defaultValue)\n+    {\n+        return getLong(key, new Long(defaultValue)).longValue();\n+    }\n+\n+    /**\n+     * Get a long associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated long if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Long.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Long getLong(String key,\n+                        Long defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Long)\n+        {\n+            return (Long) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Long l = new Long((String) value);\n+            put(key, l);\n+            return l;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getLong(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Long object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a float associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated float.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Float.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public float getFloat(String key)\n+    {\n+        Float f = getFloat(key, null);\n+        if (f != null)\n+        {\n+            return f.floatValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a float associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated float.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Float.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public float getFloat(String key,\n+                          float defaultValue)\n+    {\n+        return getFloat(key, new Float(defaultValue)).floatValue();\n+    }\n+\n+    /**\n+     * Get a float associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated float if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Float.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Float getFloat(String key,\n+                          Float defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Float)\n+        {\n+            return (Float) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Float f = new Float((String) value);\n+            put(key, f);\n+            return f;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getFloat(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Float object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a double associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @return The associated double.\n+     * @exception NoSuchElementException is thrown if the key doesn't\n+     * map to an existing object.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Double.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public double getDouble(String key)\n+    {\n+        Double d = getDouble(key, null);\n+        if (d != null)\n+        {\n+            return d.doubleValue();\n+        }\n+        else\n+        {\n+            throw new NoSuchElementException(\n+                key + \" doesn't map to an existing object\");\n+        }\n+    }\n+\n+    /**\n+     * Get a double associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated double.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Double.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public double getDouble(String key,\n+                            double defaultValue)\n+    {\n+        return getDouble(key, new Double(defaultValue)).doubleValue();\n+    }\n+\n+    /**\n+     * Get a double associated with the given configuration key.\n+     *\n+     * @param key The configuration key.\n+     * @param defaultValue The default value.\n+     * @return The associated double if key is found and has valid\n+     * format, default value otherwise.\n+     * @exception ClassCastException is thrown if the key maps to an\n+     * object that is not a Double.\n+     * @exception NumberFormatException is thrown if the value mapped\n+     * by the key has not a valid number format.\n+     */\n+    public Double getDouble(String key,\n+                            Double defaultValue)\n+    {\n+        Object value = get(key);\n+\n+        if (value instanceof Double)\n+        {\n+            return (Double) value;\n+        }\n+        else if (value instanceof String)\n+        {\n+            Double d = new Double((String) value);\n+            put(key, d);\n+            return d;\n+        }\n+        else if (value == null)\n+        {\n+            if (defaults != null)\n+            {\n+                return defaults.getDouble(key, defaultValue);\n+            }\n+            else\n+            {\n+                return defaultValue;\n+            }\n+        }\n+        else\n+        {\n+            throw new ClassCastException(\n+                key + \" doesn't map to a Double object\");\n+        }\n+    }\n+\n+    /**\n+     * Convert a standard properties class into a configuration\n+     * class.\n+     *\n+     * @param Properties properties object to convert into\n+     *                   a Configuration object.\n+     *\n+     * @return Configuration configuration created from the\n+     *                      properties object.\n+     */\n+    public static ExtendedProperties convertProperties(Properties p)\n+    {\n+         ExtendedProperties c = new ExtendedProperties();\n+    \n+        for (Enumeration e = p.keys(); e.hasMoreElements() ; ) \n+        {\n+            String s = (String) e.nextElement();\n+            c.setProperty(s, p.getProperty(s));\n+        }\n+    \n+        return c;\n+    }\n+}", "timestamp": 987397263, "metainfo": ""}