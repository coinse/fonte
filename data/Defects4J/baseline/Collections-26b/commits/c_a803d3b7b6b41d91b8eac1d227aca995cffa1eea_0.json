{"sha": "a803d3b7b6b41d91b8eac1d227aca995cffa1eea", "log": "Add ReferenceIdentityMap   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/ReferenceIdentityMap.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.Reference;\n+\n+/**\n+ * A <code>Map</code> implementation that allows mappings to be\n+ * removed by the garbage collector and matches keys and values based\n+ * on <code>==</code> not <code>equals()</code>.\n+ * <p>\n+ * <p>\n+ * When you construct a <code>ReferenceIdentityMap</code>, you can specify what kind\n+ * of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The default constructor uses hard keys and soft values, providing a\n+ * memory-sensitive cache.\n+ * <p>\n+ * This map is similar to\n+ * {@link org.apache.commons.collections.map.ReferenceMap ReferenceMap}.\n+ * It differs in that keys and values in this class are compared using <code>==</code>.\n+ * <p>\n+ * This map will violate the detail of various Map and map view contracts.\n+ * As a general rule, don't compare this map to other maps.\n+ * <p>\n+ * This {@link Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceIdentityMap</code>.\n+ * Remember that synchronization will not stop the garbage collecter removing entries.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ *\n+ * @see java.lang.ref.Reference\n+ * \n+ * @since Commons Collections 3.0 (previously in main package v2.1)\n+ * @version $Revision: 1.1 $ $Date: 2004/04/27 21:37:32 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class ReferenceIdentityMap extends AbstractReferenceMap implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -1266190134568365852L;\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use hard references to keys and soft references to values.\n+     */\n+    public ReferenceIdentityMap() {\n+        super(HARD, SOFT, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     */\n+    public ReferenceIdentityMap(int keyType, int valueType) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param purgeValues should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceIdentityMap(int keyType, int valueType, boolean purgeValues) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> with the\n+     * specified reference types, load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     */\n+    public ReferenceIdentityMap(int keyType, int valueType, int capacity, float loadFactor) {\n+        super(keyType, valueType, capacity, loadFactor, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceIdentityMap</code> with the\n+     * specified reference types, load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    public ReferenceIdentityMap(int keyType, int valueType, int capacity,\n+                        float loadFactor, boolean purgeValues) {\n+        super(keyType, valueType, capacity, loadFactor, purgeValues);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the hash code for the key specified.\n+     * <p>\n+     * This implementation uses the identity hash code.\n+     * \n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    protected int hash(Object key) {\n+        return System.identityHashCode(key);\n+    }\n+\n+    /**\n+     * Gets the hash code for a MapEntry.\n+     * <p>\n+     * This implementation uses the identity hash code.\n+     * \n+     * @param key  the key to get a hash code for, may be null\n+     * @param value  the value to get a hash code for, may be null\n+     * @return the hash code, as per the MapEntry specification\n+     */\n+    protected int hashEntry(Object key, Object value) {\n+        return System.identityHashCode(key) ^\n+               System.identityHashCode(value);\n+    }\n+\n+    /**\n+     * Compares two keys for equals.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison and uses <code>==</code>.\n+     * \n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal by identity\n+     */\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n+        return (key1 == key2);\n+    }\n+\n+    /**\n+     * Compares two values for equals.\n+     * <p>\n+     * This implementation uses <code>==</code>.\n+     * \n+     * @param value1  the first value to compare passed in from outside\n+     * @param value2  the second value extracted from the entry via <code>getValue()</code>\n+     * @return true if equal by identity\n+     */\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return (value1 == value2);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestReferenceIdentityMap.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+\n+/**\n+ * Tests for ReferenceIdentityMap. \n+ * \n+ * @version $Revision: 1.1 $\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class TestReferenceIdentityMap extends AbstractTestIterableMap {\n+\n+    private static final Integer I1A = new Integer(1);\n+    private static final Integer I1B = new Integer(1);\n+    private static final Integer I2A = new Integer(2);\n+    private static final Integer I2B = new Integer(2);\n+\n+    public TestReferenceIdentityMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestReferenceIdentityMap.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestReferenceIdentityMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        return map;\n+    }\n+    \n+    public Map makeConfirmedMap() {\n+        // Testing against another [collections] class generally isn't a good idea,\n+        // but the alternative is a JDK1.4 dependency in the tests\n+        return new IdentityMap();\n+    }\n+\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBasics() {\n+        IterableMap map = new ReferenceIdentityMap(ReferenceIdentityMap.HARD, ReferenceIdentityMap.HARD);\n+        assertEquals(0, map.size());\n+        \n+        map.put(I1A, I2A);\n+        assertEquals(1, map.size());\n+        assertSame(I2A, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(true, map.containsValue(I2A));\n+        assertEquals(false, map.containsValue(I2B));\n+        \n+        map.put(I1A, I2B);\n+        assertEquals(1, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+        \n+        map.put(I1B, I2B);\n+        assertEquals(2, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(I2B, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(true, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testHashEntry() {\n+        IterableMap map = new ReferenceIdentityMap(ReferenceIdentityMap.HARD, ReferenceIdentityMap.HARD);\n+        \n+        map.put(I1A, I2A);\n+        map.put(I1B, I2A);\n+        \n+        Map.Entry entry1 = (Map.Entry) map.entrySet().iterator().next();\n+        Iterator it = map.entrySet().iterator();\n+        Map.Entry entry2 = (Map.Entry) it.next();\n+        Map.Entry entry3 = (Map.Entry) it.next();\n+        \n+        assertEquals(true, entry1.equals(entry2));\n+        assertEquals(true, entry2.equals(entry1));\n+        assertEquals(false, entry1.equals(entry3));\n+    }\n+    \n+    \n+    //-----------------------------------------------------------------------\n+   // Unfortunately, these tests all rely on System.gc(), which is\n+   // not reliable across platforms.  Not sure how to code the tests\n+   // without using System.gc() though...\n+   // They all passed on my platform though. :)\n+/*\n+    public void testPurge() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        System.gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        System.gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        System.gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        System.gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        System.gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        System.gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            System.gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+/*\n+    // Uncomment to create test files in /data/test\n+    public void testCreateTestFiles() throws Exception {\n+        ReferenceIdentityMap m = (ReferenceIdentityMap) makeEmptyMap();\n+        writeExternalFormToDisk(m, getCanonicalEmptyCollectionName(m));\n+        m = (ReferenceIdentityMap) makeFullMap();\n+        writeExternalFormToDisk(m, getCanonicalFullCollectionName(m));\n+    }\n+*/\n+\n+\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        Object key = new Object();\n+        Object value = new Object();\n+        \n+        WeakReference keyReference = new WeakReference(key);\n+        WeakReference valueReference = new WeakReference(value);\n+        \n+        Map testMap = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.HARD, true);\n+        testMap.put(key, value);\n+        \n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        \n+        // dereference strong references\n+        key = null;\n+        value = null;\n+        \n+        int iterations = 0;\n+        int bytz = 2;\n+        while(true) {\n+            System.gc();\n+            if(iterations++ > 50){\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if( \n+                keyReference.get() == null &&\n+                valueReference.get() == null) {\n+                break;\n+                \n+            } else {\n+                // create garbage:\n+                byte[] b =  new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+}", "timestamp": 1083101852, "metainfo": ""}