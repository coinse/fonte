{"sha": "dd5e51e5b31f36b66431ea6e4b5a2a6bc4dcab34", "log": "[COLLECTIONS-530] Added Builder for PredicatedCollection. Thanks to Erik.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n  */\n package org.apache.commons.collections4.collection;\n \n+import java.util.ArrayList;\n import java.util.Collection;\n-\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.Predicate;\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.bag.PredicatedBag;\n+import org.apache.commons.collections4.functors.NotNullPredicate;\n+import org.apache.commons.collections4.list.PredicatedList;\n+import org.apache.commons.collections4.queue.PredicatedQueue;\n+import org.apache.commons.collections4.set.PredicatedSet;\n \n /**\n  * Decorates another {@link Collection} to validate that additions\n  * It is normally created to decorate an empty collection.\n  * If an object cannot be added to the collection, an IllegalArgumentException is thrown.\n  * <p>\n- * One usage would be to ensure that no null entries are added to the collection.\n- * <pre>Collection coll = PredicatedCollection.decorate(new ArrayList(), NotNullPredicate.INSTANCE);</pre>\n+ * One usage would be to ensure that no null entries are added to the collection:\n+ * <pre>\n+ * Collection coll = PredicatedCollection.predicatedCollection(new ArrayList(), NotNullPredicate.INSTANCE);\n+ * </pre>\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n     protected final Predicate<? super E> predicate;\n \n     /**\n+     * Returns a Builder with the given predicate.\n+     *\n+     * @param <E>  the element type\n+     * @param predicate  the predicate to use\n+     * @return a new Builder for predicated collections\n+     * @since 4.1\n+     */\n+    public static <E> Builder<E> builder(final Predicate<? super E> predicate) {\n+        return new Builder<E>(predicate);\n+    }\n+\n+    /**\n+     * Returns a Builder with a NotNullPredicate.\n+     *\n+     * @param <E>  the element type\n+     * @return a new Builder for predicated collections that ignores null values.\n+     * @since 4.1\n+     */\n+    public static <E> Builder<E> notNullBuilder() {\n+        return new Builder<E>(NotNullPredicate.<E>notNullPredicate());\n+    }\n+\n+    /**\n      * Factory method to create a predicated (validating) collection.\n      * <p>\n      * If there are any elements already in the collection being decorated, they\n         return decorated().addAll(coll);\n     }\n \n+    /**\n+     * Builder for creating predicated collections.\n+     * <p>\n+     * Create a Builder with a predicate to validate elements against, then add any elements\n+     * to the builder. Elements that fail the predicate will be added to a rejected list.\n+     * Finally create or decorate a collection using the createPredicated[List,Set,Bag,Queue] methods.\n+     * <p>\n+     * An example:\n+     * <pre>\n+     *   Predicate&lt;String&gt; predicate = NotNullPredicate.notNullPredicate();\n+     *   PredicatedCollectionBuilder&lt;String&gt; builder = PredicatedCollection.builder(predicate);\n+     *   builder.add(\"item1\");\n+     *   builder.add(null);\n+     *   builder.add(\"item2\");\n+     *   List&lt;String&gt; predicatedList = builder.createPredicatedList();\n+     * </pre>\n+     * <p>\n+     * At the end of the code fragment above predicatedList is protected by the predicate supplied\n+     * to the builder and it contains item1 and item2.\n+     * <p>\n+     * More elements can be added to the builder once a predicated collection has been created,\n+     * but these elements will not be reflected in already created collections.\n+     *\n+     * @param <E>  the element type\n+     * @since 4.1\n+     */\n+    public static class Builder<E> {\n+\n+        /** The predicate to use. */\n+        private final Predicate<? super E> predicate;\n+\n+        /** The buffer containing valid elements. */\n+        private final List<E> accepted = new ArrayList<E>();\n+\n+        /** The buffer containing rejected elements. */\n+        private final List<E> rejected = new ArrayList<E>();\n+\n+        // -----------------------------------------------------------------------\n+        /**\n+         * Constructs a PredicatedCollectionBuilder with the specified Predicate.\n+         *\n+         * @param predicate  the predicate to use\n+         * @throws IllegalArgumentException if predicate is null\n+         */\n+        public Builder(final Predicate<? super E> predicate) {\n+            if (predicate == null) {\n+                throw new IllegalArgumentException(\"Predicate must not be null\");\n+            }\n+            this.predicate = predicate;\n+        }\n+\n+        /**\n+         * Adds the item to the builder.\n+         * <p>\n+         * If the predicate is true, it is added to the list of accepted elements,\n+         * otherwise it is added to the rejected list.\n+         *\n+         * @param item  the element to add\n+         * @return the PredicatedCollectionBuilder.\n+         */\n+        public Builder<E> add(final E item) {\n+            if (predicate.evaluate(item)) {\n+                accepted.add(item);\n+            } else {\n+                rejected.add(item);\n+            }\n+            return this;\n+        }\n+\n+        /**\n+         * Adds all elements from the given collection to the builder.\n+         * <p>\n+         * All elements for which the predicate evaluates to true will be added to the\n+         * list of accepted elements, otherwise they are added to the rejected list.\n+         *\n+         * @param items  the elements to add to the builder\n+         * @return the PredicatedCollectionBuilder.\n+         */\n+        public Builder<E> addAll(final Collection<? extends E> items) {\n+            if (items != null) {\n+                for (E item : items) {\n+                    add(item);\n+                }\n+            }\n+            return this;\n+        }\n+\n+        /**\n+         * Create a new predicated list filled with the accepted elements.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned list.\n+         *\n+         * @return a new predicated list.\n+         */\n+        public List<E> createPredicatedList() {\n+            return createPredicatedList(new ArrayList<E>());\n+        }\n+\n+        /**\n+         * Decorates the given list with validating behavior using the predicate. All accepted elements\n+         * are appended to the list. If the list already contains elements, they are validated.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned list.\n+         *\n+         * @param list  the List to decorate, must not be null\n+         * @return the decorated list.\n+         * @throws IllegalArgumentException if list is null or contains invalid elements\n+         */\n+        public List<E> createPredicatedList(final List<E> list) {\n+            if (list == null) {\n+                throw new IllegalArgumentException(\"list must not be null\");\n+            }\n+            final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);\n+            predicatedList.addAll(accepted);\n+            return predicatedList;\n+        }\n+\n+        /**\n+         * Create a new predicated set filled with the accepted elements.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned set.\n+         *\n+         * @return a new predicated set.\n+         */\n+        public Set<E> createPredicatedSet() {\n+            return createPredicatedSet(new HashSet<E>());\n+        }\n+\n+        /**\n+         * Decorates the given list with validating behavior using the predicate. All accepted elements\n+         * are appended to the set. If the set already contains elements, they are validated.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned set.\n+         *\n+         * @param set  the set to decorate, must not be null\n+         * @return the decorated set.\n+         * @throws IllegalArgumentException if set is null or contains invalid elements\n+         */\n+        public Set<E> createPredicatedSet(final Set<E> set) {\n+            if (set == null) {\n+                throw new IllegalArgumentException(\"set must not be null\");\n+            }\n+            final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);\n+            predicatedSet.addAll(accepted);\n+            return predicatedSet;\n+        }\n+\n+        /**\n+         * Create a new predicated bag filled with the accepted elements.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n+         *\n+         * @return a new predicated bag.\n+         */\n+        public Bag<E> createPredicatedBag() {\n+            return createPredicatedBag(new HashBag<E>());\n+        }\n+\n+        /**\n+         * Decorates the given bag with validating behavior using the predicate. All accepted elements\n+         * are appended to the bag. If the bag already contains elements, they are validated.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned bag.\n+         *\n+         * @param bag  the bag to decorate, must not be null\n+         * @return the decorated bag.\n+         * @throws IllegalArgumentException if bag is null or contains invalid elements\n+         */\n+        public Bag<E> createPredicatedBag(final Bag<E> bag) {\n+            if (bag == null) {\n+                throw new IllegalArgumentException(\"bag must not be null\");\n+            }\n+            final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);\n+            predicatedBag.addAll(accepted);\n+            return predicatedBag;\n+        }\n+\n+        /**\n+         * Create a new predicated queue filled with the accepted elements.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n+         *\n+         * @return a new predicated queue.\n+         */\n+        public Queue<E> createPredicatedQueue() {\n+            return createPredicatedQueue(new LinkedList<E>());\n+        }\n+\n+        /**\n+         * Decorates the given queue with validating behavior using the predicate. All accepted elements\n+         * are appended to the queue. If the queue already contains elements, they are validated.\n+         * <p>\n+         * The builder is not modified by this method, so it is possible to create more collections\n+         * or add more elements afterwards. Further changes will not propagate to the returned queue.\n+         *\n+         * @param queue  the queue to decorate, must not be null\n+         * @return the decorated queue.\n+         * @throws IllegalArgumentException if queue is null or contains invalid elements\n+         */\n+        public Queue<E> createPredicatedQueue(final Queue<E> queue) {\n+            if (queue == null) {\n+                throw new IllegalArgumentException(\"queue must not be null\");\n+            }\n+            final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);\n+            predicatedQueue.addAll(accepted);\n+            return predicatedQueue;\n+        }\n+\n+        /**\n+         * Returns an unmodifiable collection containing all rejected elements.\n+         *\n+         * @return an unmodifiable collection\n+         */\n+        public Collection<E> rejectedElements() {\n+            return Collections.unmodifiableCollection(rejected);\n+        }\n+\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/collection/PredicatedCollectionBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.collection;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Predicate;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Tests the PredicatedCollection.Builder class.\n+ * \n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class PredicatedCollectionBuilderTest {\n+\n+    /**\n+     * Verify that passing the Predicate means ending up in the buffer.\n+     */\n+    @Test\n+    public void addPass() {\n+        PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n+        builder.add(\"test\");\n+        Assert.assertEquals(builder.createPredicatedList().size(), 1);\n+    }\n+\n+    /**\n+     * Verify that failing the Predicate means NOT ending up in the buffer.\n+     */\n+    @Test\n+    public void addFail() {\n+        PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n+        builder.add((String) null);\n+        Assert.assertTrue(builder.createPredicatedList().isEmpty());\n+        \n+        Assert.assertEquals(1, builder.rejectedElements().size());\n+    }\n+\n+    /**\n+     * Verify that only items that pass the Predicate end up in the buffer.\n+     */\n+    @Test\n+    public void addAllPass() {\n+        PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n+        builder.addAll(Arrays.asList(\"test1\", null, \"test2\"));\n+        Assert.assertEquals(builder.createPredicatedList().size(), 2);\n+    }\n+\n+    @Test\n+    public void createPredicatedCollectionWithNotNullPredicate() {\n+        PredicatedCollection.Builder<String> builder = PredicatedCollection.notNullBuilder();\n+        builder.add(\"test1\");\n+        builder.add((String) null);\n+\n+        List<String> predicatedList = builder.createPredicatedList();\n+        checkPredicatedCollection1(predicatedList);\n+        \n+        Set<String> predicatedSet = builder.createPredicatedSet();\n+        checkPredicatedCollection1(predicatedSet);\n+\n+        Bag<String> predicatedBag = builder.createPredicatedBag();\n+        checkPredicatedCollection1(predicatedBag);\n+\n+        Queue<String> predicatedQueue = builder.createPredicatedQueue();\n+        checkPredicatedCollection1(predicatedQueue);\n+    }\n+    \n+    private void checkPredicatedCollection1(final Collection<String> collection) {\n+        Assert.assertEquals(1, collection.size());\n+\n+        collection.add(\"test2\");\n+        Assert.assertEquals(2, collection.size());\n+\n+        try {\n+            collection.add(null);\n+            Assert.fail(\"Expecting IllegalArgumentException for failing predicate!\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void createPredicatedCollectionWithPredicate() {\n+        OddPredicate p = new OddPredicate();\n+        PredicatedCollection.Builder<Integer> builder = PredicatedCollection.builder(p);\n+\n+        builder.add(1);\n+        builder.add(2);\n+        builder.add(3);\n+\n+        List<Integer> predicatedList = builder.createPredicatedList();\n+        checkPredicatedCollection2(predicatedList);\n+        \n+        Set<Integer> predicatedSet = builder.createPredicatedSet();\n+        checkPredicatedCollection2(predicatedSet);\n+\n+        Bag<Integer> predicatedBag = builder.createPredicatedBag();\n+        checkPredicatedCollection2(predicatedBag);\n+\n+        Queue<Integer> predicatedQueue = builder.createPredicatedQueue();\n+        checkPredicatedCollection2(predicatedQueue);\n+    }\n+\n+    private void checkPredicatedCollection2(final Collection<Integer> collection) {\n+        Assert.assertEquals(2, collection.size());\n+\n+        try {\n+            collection.add(4);\n+            Assert.fail(\"Expecting IllegalArgumentException for failing predicate!\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+        Assert.assertEquals(2, collection.size());\n+\n+        collection.add(5);\n+        Assert.assertEquals(3, collection.size());\n+    }\n+\n+    private static class OddPredicate implements Predicate<Integer> {\n+        public boolean evaluate(Integer value) {\n+            return value % 2 == 1;\n+        }\n+    }\n+}", "timestamp": 1422108220, "metainfo": ""}