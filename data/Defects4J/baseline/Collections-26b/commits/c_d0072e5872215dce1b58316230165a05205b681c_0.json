{"sha": "d0072e5872215dce1b58316230165a05205b681c", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r471575 | scolebourne | 2006-11-05 15:58:08 -0800 (Sun, 05 Nov 2006) | 1 line          Generify and remove AbstractSerializableCollectionDecorator     ------------------------------------------------------------------------     r471202 | scolebourne | 2006-11-04 06:21:44 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getCollection() - use covariant decorated()     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/UnmodifiableBoundedCollection.java\n import org.apache.commons.collections.iterators.UnmodifiableIterator;\n \n /**\n- * <code>UnmodifiableBoundedCollection</code> decorates another \n+ * <code>UnmodifiableBoundedCollection</code> decorates another\n  * <code>BoundedCollection</code> to ensure it can't be altered.\n  * <p>\n  * If a BoundedCollection is first wrapped in some other collection decorator,\n- * such as synchronized or predicated, the BoundedCollection methods are no \n+ * such as synchronized or predicated, the BoundedCollection methods are no\n  * longer accessible.\n  * The factory on this class will attempt to retrieve the bounded nature by\n  * examining the package scope variables.\n  *\n  * @author Stephen Colebourne\n  */\n-public final class UnmodifiableBoundedCollection\n-        extends AbstractSerializableCollectionDecorator\n-        implements BoundedCollection {\n+public final class UnmodifiableBoundedCollection<E> extends AbstractCollectionDecorator<E>\n+        implements BoundedCollection<E> {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -7112672385450340330L;\n \n     /**\n      * Factory method to create an unmodifiable bounded collection.\n-     * \n+     *\n      * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n      * @return a new unmodifiable bounded collection\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static BoundedCollection decorate(BoundedCollection coll) {\n-        return new UnmodifiableBoundedCollection(coll);\n+    public static <E> BoundedCollection<E> decorate(BoundedCollection<E> coll) {\n+        return new UnmodifiableBoundedCollection<E>(coll);\n     }\n-    \n+\n     /**\n      * Factory method to create an unmodifiable bounded collection.\n      * <p>\n-     * This method is capable of drilling down through up to 1000 other decorators \n+     * This method is capable of drilling down through up to 1000 other decorators\n      * to find a suitable BoundedCollection.\n-     * \n+     *\n      * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n      * @return a new unmodifiable bounded collection\n      * @throws IllegalArgumentException if bag is null\n      */\n-    public static BoundedCollection decorateUsing(Collection coll) {\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> BoundedCollection<E> decorateUsing(Collection<? super E> coll) {\n         if (coll == null) {\n             throw new IllegalArgumentException(\"The collection must not be null\");\n         }\n-        \n+\n         // handle decorators\n         for (int i = 0; i < 1000; i++) {  // counter to prevent infinite looping\n             if (coll instanceof BoundedCollection) {\n                 break;  // normal loop exit\n-            } else if (coll instanceof AbstractCollectionDecorator) {\n-                coll = ((AbstractCollectionDecorator) coll).collection;\n+            }\n+            if (coll instanceof AbstractCollectionDecorator) {\n+                coll = ((AbstractCollectionDecorator<E>) coll).collection;\n             } else if (coll instanceof SynchronizedCollection) {\n-                coll = ((SynchronizedCollection) coll).collection;\n-            } else {\n-                break;  // normal loop exit\n+                coll = ((SynchronizedCollection<E>) coll).collection;\n             }\n         }\n-            \n+\n         if (coll instanceof BoundedCollection == false) {\n             throw new IllegalArgumentException(\"The collection is not a bounded collection\");\n         }\n-        return new UnmodifiableBoundedCollection((BoundedCollection) coll);\n-    }    \n-    \n+        return new UnmodifiableBoundedCollection((BoundedCollection<E>) coll);\n+    }\n+\n     /**\n      * Constructor that wraps (not copies).\n-     * \n+     *\n      * @param coll  the collection to decorate, must not be null\n      * @throws IllegalArgumentException if coll is null\n      */\n-    private UnmodifiableBoundedCollection(BoundedCollection coll) {\n+    private UnmodifiableBoundedCollection(BoundedCollection<E> coll) {\n         super(coll);\n     }\n \n     //-----------------------------------------------------------------------\n-    public Iterator iterator() {\n-        return UnmodifiableIterator.decorate(getCollection().iterator());\n+    public Iterator<E> iterator() {\n+        return UnmodifiableIterator.decorate(decorated().iterator());\n     }\n \n-    public boolean add(Object object) {\n+    public boolean add(E object) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean addAll(Collection coll) {\n+    public boolean addAll(Collection<? extends E> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean removeAll(Collection coll) {\n+    public boolean removeAll(Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n-    public boolean retainAll(Collection coll) {\n+    public boolean retainAll(Collection<?> coll) {\n         throw new UnsupportedOperationException();\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     public boolean isFull() {\n-        return ((BoundedCollection) collection).isFull();\n+        return decorated().isFull();\n     }\n \n     public int maxSize() {\n-        return ((BoundedCollection) collection).maxSize();\n+        return decorated().maxSize();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected BoundedCollection<E> decorated() {\n+        return (BoundedCollection<E>) super.decorated();\n+    }\n }", "timestamp": 1252994091, "metainfo": ""}