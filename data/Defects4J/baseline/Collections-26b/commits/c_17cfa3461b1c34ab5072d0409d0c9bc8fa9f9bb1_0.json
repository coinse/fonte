{"sha": "17cfa3461b1c34ab5072d0409d0c9bc8fa9f9bb1", "log": "Add functor utility implementations   ", "commit": "\n--- a/src/java/org/apache/commons/collections/Closure.java\n+++ b/src/java/org/apache/commons/collections/Closure.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Closure.java,v 1.5 2003/05/11 14:15:23 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Closure.java,v 1.6 2003/05/16 13:41:10 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n-/** \n- * An interface to represent some Closure, a block of code which is executed \n- * from inside some block, function or iteration which operates on an input \n- * object.\n+/**\n+ * <code>Closure</code> defines an interface implemented by classes that\n+ * do something.\n+ * <p>\n+ * A Closure represents a block of code which is executed from inside some\n+ * block, function or iteration. It operates an input object.\n+ *  \n+ * @since Commons Collections 1.0\n+ * @version $Revision: 1.6 $ $Date: 2003/05/16 13:41:10 $\n  *\n- * @since Commons Collections 1.0\n- * @version $Revision: 1.5 $ $Date: 2003/05/11 14:15:23 $\n- * \n- * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author James Strachan\n+ * @author Nicola Ken Barozzi\n+ * @author Stephen Colebourne\n  */\n public interface Closure {\n-\n-    /** \n-     * Performs some operation on the input object.\n+    \n+    /**\n+     * Performs an action on the specified input object.\n+     *\n+     * @param input  the input to execute on\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if any other error occurs\n      */\n-    void execute(Object input);\n+    public void execute(Object input);\n     \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ClosureUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ClosureUtils.java,v 1.1 2003/05/16 13:41:10 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * <code>ClosureUtils</code> provides reference implementations and utilities\n+ * for the Closure functor interface. The supplied closures are:\n+ * <ul>\n+ * <li>Invoker - invokes a method on the input object\n+ * <li>For - repeatedly calls a closure for a fixed number of times\n+ * <li>While - repeatedly calls a closure while a predicate is true\n+ * <li>DoWhile - repeatedly calls a closure while a predicate is true\n+ * <li>Chained - chains two or more closures together\n+ * <li>Switch - calls one closure based on one or more predicates\n+ * <li>SwitchMap - calls one closure looked up from a Map\n+ * <li>Transformer - wraps a Transformer as a Closure\n+ * <li>NOP - does nothing\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied closures are Serializable.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/05/16 13:41:10 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ClosureUtils {\n+\n+    /**\n+     * A Closure that always throws an exception\n+     */\n+    private static final Closure EXCEPTION_CLOSURE = new ExceptionClosure();\n+    /**\n+     * A Closure that does nothing\n+     */\n+    private static final Closure NOP_CLOSURE = new NOPClosure();\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public ClosureUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Closure that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the closure\n+     */\n+    public static Closure exceptionClosure() {\n+        return EXCEPTION_CLOSURE;\n+    }\n+\n+    /**\n+     * Gets a Closure that will do nothing.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the closure\n+     */\n+    public static Closure nopClosure() {\n+        return NOP_CLOSURE;\n+    }\n+\n+    /**\n+     * Creates a Closure that calls a Transformer each time it is called.\n+     * The transformer will be called using the closure's input object.\n+     * The transformer's result will be ignored.\n+     *\n+     * @param transformer  the transformer to run each time in the closure\n+     * @return the closure.\n+     */\n+    public static Closure asClosure(Transformer transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"The transformer must not be null\");\n+        }\n+        return new TransformerClosure(transformer);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure <code>count</code> times.\n+     *\n+     * @param count  the number of times to loop\n+     * @param closure  the closure to call repeatedly\n+     * @return the <code>for</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Closure forClosure(int count, Closure closure) {\n+        if (count < 0) {\n+            throw new IllegalArgumentException(\"The loop count must not be less than zero, it was \" + count);\n+        }\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"The closure must not be null\");\n+        }\n+        return new ForClosure(count, closure);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure repeatedly until the \n+     * predicate returns false.\n+     *\n+     * @param predicate  the predicate to use as an end of loop test\n+     * @param closure  the closure to call repeatedly\n+     * @return the <code>while</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Closure whileClosure(Predicate predicate, Closure closure) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"The closure must not be null\");\n+        }\n+        return new WhileClosure(predicate, closure, false);\n+    }\n+\n+    /**\n+     * Creates a Closure that will call the closure once and then repeatedly\n+     * until the predicate returns false.\n+     *\n+     * @param closure  the closure to call repeatedly\n+     * @param predicate  the predicate to use as an end of loop test\n+     * @return the <code>do-while</code> closure\n+     * @throws IllegalArgumentException if either argument is null\n+     */\n+    public static Closure doWhileClosure(Closure closure, Predicate predicate) {\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"The closure must not be null\");\n+        }\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new WhileClosure(predicate, closure, true);\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the closure's\n+     * input object by reflection.\n+     *\n+     * @param methodName  the name of the method\n+     * @return the <code>invoker</code> closure\n+     * @throws IllegalArgumentException if the method name is null\n+     */\n+    public static Closure invokerClosure(String methodName) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asClosure(TransformerUtils.invokerTransformer(methodName, null, null));\n+    }\n+\n+    /**\n+     * Creates a Closure that will invoke a specific method on the closure's\n+     * input object by reflection.\n+     *\n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the <code>invoker</code> closure\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Closure invokerClosure(String methodName, Class[] paramTypes, Object[] args) {\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asClosure(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    /**\n+     * Create a new Closure that calls two Closures, passing the result of\n+     * the first into the second.\n+     * \n+     * @param closure1  the first closure\n+     * @param closure2  the second closure\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static Closure chainedClosure(Closure closure1, Closure closure2) {\n+        Closure[] closures = new Closure[] { closure1, closure2 };\n+        validate(closures);\n+        return new ChainedClosure(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure.\n+     * \n+     * @param closures  an array of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures array is null\n+     * @throws IllegalArgumentException if the closures array has 0 elements\n+     * @throws IllegalArgumentException if any closure in the array is null\n+     */\n+    public static Closure chainedClosure(Closure[] closures) {\n+        closures = copy(closures);\n+        validate(closures);\n+        return new ChainedClosure(closures);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls each closure in turn, passing the \n+     * result into the next closure. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param closures  a collection of closures to chain\n+     * @return the <code>chained</code> closure\n+     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws IllegalArgumentException if the closures collection is empty\n+     * @throws IllegalArgumentException if any closure in the collection is null\n+     */\n+    public static Closure chainedClosure(Collection closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"The closure collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure[] cmds = new Closure[closures.size()];\n+        int i = 0;\n+        for (Iterator it = closures.iterator(); it.hasNext();) {\n+            cmds[i++] = (Closure) it.next();\n+        }\n+        validate(cmds);\n+        return new ChainedClosure(cmds);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of two closures depending \n+     * on the specified predicate.\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueClosure  the closure called if the predicate is true\n+     * @param falseClosure  the closure called if the predicate is false\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either closure is null\n+     */\n+    public static Closure switchClosure(Predicate predicate, Closure trueClosure, Closure falseClosure) {\n+        return switchClosureInternal(new Predicate[] { predicate }, new Closure[] { trueClosure }, falseClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates.\n+     * <p>\n+     * The closure at array location 0 is called if the predicate at array \n+     * location 0 returned true. Each predicate is evaluated\n+     * until one returns true.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param closures  an array of closures to call\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Closure switchClosure(Predicate[] predicates, Closure[] closures) {\n+        return switchClosureInternal(copy(predicates), copy(closures), null);\n+    }\n+\n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates.\n+     * <p>\n+     * The closure at array location 0 is called if the predicate at array\n+     * location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param closures  an array of closures to call\n+     * @param defaultClosure  the default to call if no predicate matches\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Closure switchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+        return switchClosureInternal(copy(predicates), copy(closures), defaultClosure);\n+    }\n+    \n+    /**\n+     * Create a new Closure that calls one of the closures depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Closure values. A closure \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * closure is called. The default closure is set in the map with a \n+     * null key. The ordering is that of the iterator() method on the entryset \n+     * collection of the map.\n+     * \n+     * @param predicatesAndClosures  a map of predicates to closures\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Closure switchClosure(Map predicatesAndClosures) {\n+        Closure[] trs = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndClosures == null) {\n+            throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Closure def = (Closure) predicatesAndClosures.remove(null);\n+        int size = predicatesAndClosures.size();\n+        trs = new Closure[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndClosures.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            trs[i] = (Closure) entry.getValue();\n+            i++;\n+        }\n+        return switchClosureInternal(preds, trs, def);\n+    }\n+\n+    /**\n+     * Validate input and create closure.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param closures  an array of closures to call\n+     * @param defaultClosure  the default to call if no predicate matches\n+     * @return the <code>switch</code> closure\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    private static Closure switchClosureInternal(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+        validate(predicates);\n+        validate(closures);\n+        if (predicates.length != closures.length) {\n+            throw new IllegalArgumentException(\"The predicate and closure arrays must be the same size\");\n+        }\n+        if (defaultClosure == null) {\n+            defaultClosure = nopClosure();\n+        }\n+        return new SwitchClosure(predicates, closures, defaultClosure);\n+    }\n+\n+    /**\n+     * Create a new Closure that uses the input object as a key to find the\n+     * closure to call. \n+     * <p>\n+     * The Map consists of object keys and Closure values. A closure \n+     * is called if the input object equals the key. If there is no match, the\n+     * default closure is called. The default closure is set in the map\n+     * using a null key.\n+     * \n+     * @param objectsAndClosures  a map of objects to closures\n+     * @return the closure\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any closure in the map is null\n+     */\n+    public static Closure switchMapClosure(Map objectsAndClosures) {\n+        Closure[] trs = null;\n+        Predicate[] preds = null;\n+        if (objectsAndClosures == null) {\n+            throw new IllegalArgumentException(\"The obejct and closure map must not be null\");\n+        }\n+        Closure def = (Closure) objectsAndClosures.remove(null);\n+        int size = objectsAndClosures.size();\n+        trs = new Closure[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = objectsAndClosures.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = PredicateUtils.equalPredicate(entry.getKey());\n+            trs[i] = (Closure) entry.getValue();\n+            i++;\n+        }\n+        return switchClosure(preds, trs, def);\n+    }\n+\n+    /**\n+     * Clone the predicates to ensure that the internal reference can't be messed with.\n+     * \n+     * @param predicates  the predicates to copy\n+     * @return the cloned predicates\n+     */\n+    private static Predicate[] copy(Predicate[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate[]) predicates.clone();\n+    }\n+    \n+    /**\n+     * Validate the predicates to ensure that all is well.\n+     * \n+     * @param predicates  the predicates to validate\n+     * @return the validated predicates\n+     */\n+    private static void validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+        }\n+        if (predicates.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Clone the closures to ensure that the internal reference can't be messed with.\n+     * \n+     * @param closures  the closures to copy\n+     * @return the cloned closures\n+     */\n+    private static Closure[] copy(Closure[] closures) {\n+        if (closures == null) {\n+            return null;\n+        }\n+        return (Closure[]) closures.clone();\n+    }\n+    \n+    /**\n+     * Validate the closures to ensure that all is well.\n+     * \n+     * @param closures  the closures to validate\n+     * @return the validated closures\n+     */\n+    private static void validate(Closure[] closures) {\n+        if (closures == null) {\n+            throw new IllegalArgumentException(\"The closure array must not be null\");\n+        }\n+        if (closures.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"At least 1 closure must be specified in the closure array, size was \" + closures.length);\n+        }\n+        for (int i = 0; i < closures.length; i++) {\n+            if (closures[i] == null) {\n+                throw new IllegalArgumentException(\"The closure array must not contain a null closure, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    // ExceptionClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionClosure always throws an exception\n+     */\n+    private static class ExceptionClosure implements Closure, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionClosure() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public void execute(Object input) {\n+            throw new FunctorException(\"ExceptionClosure invoked\");\n+        }\n+    }\n+\n+    // NOPClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NOPClosure does nothing\n+     */\n+    private static class NOPClosure implements Closure, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private NOPClosure() {\n+            super();\n+        }\n+\n+        /**\n+         * Do nothing\n+         */\n+        public void execute(Object input) {\n+            // do nothing\n+        }\n+    }\n+\n+    // TransformerClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * TransformerClosure calls a Transformer using the input object and ignore the result.\n+     */\n+    private static class TransformerClosure implements Closure, Serializable {\n+        /** The transformer to wrap */\n+        private final Transformer iTransformer;\n+\n+        /**\n+         * Constructor to store transformer\n+         */\n+        private TransformerClosure(Transformer transformer) {\n+            super();\n+            iTransformer = transformer;\n+        }\n+\n+        /**\n+         * Call the transformer\n+         */\n+        public void execute(Object input) {\n+            iTransformer.transform(input);\n+        }\n+    }\n+\n+    // ChainedClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ChainedClosure calls a list of closures.\n+     */\n+    private static class ChainedClosure implements Closure, Serializable {\n+        /** The closures to call in turn */\n+        private final Closure[] iClosures;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ChainedClosure(Closure[] closures) {\n+            super();\n+            iClosures = closures;\n+        }\n+\n+        /**\n+         * Execute a list of closures\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iClosures.length; i++) {\n+                iClosures[i].execute(input);\n+            }\n+        }\n+    }\n+\n+    // SwitchClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * SwitchClosure calls the closure whose predicate returns true.\n+     */\n+    private static class SwitchClosure implements Closure, Serializable {\n+        /** The tests to consider */\n+        private final Predicate[] iPredicates;\n+        /** The matching closures to call */\n+        private final Closure[] iClosures;\n+        /** The default closure to call if no tests match */\n+        private final Closure iDefault;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private SwitchClosure(Predicate[] predicates, Closure[] closures, Closure defaultClosure) {\n+            super();\n+            iPredicates = predicates;\n+            iClosures = closures;\n+            iDefault = defaultClosure;\n+        }\n+\n+        /**\n+         * Execute the closure whose predicate returns true\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(input) == true) {\n+                    iClosures[i].execute(input);\n+                    return;\n+                }\n+            }\n+            iDefault.execute(input);\n+        }\n+    }\n+\n+    // ForClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ForClosure calls the closure a fixed nunmber of times.\n+     */\n+    private static class ForClosure implements Closure, Serializable {\n+        /** The number of times to loop */\n+        private final int iCount;\n+        /** The closure to call */\n+        private final Closure iClosure;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private ForClosure(int count, Closure closure) {\n+            super();\n+            iCount = count;\n+            iClosure = closure;\n+        }\n+\n+        /**\n+         * Execute the closure count times\n+         */\n+        public void execute(Object input) {\n+            for (int i = 0; i < iCount; i++) {\n+                iClosure.execute(input);\n+            }\n+        }\n+    }\n+\n+    // WhileClosure\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * WhileClosure calls the closure until the predicate is false.\n+     */\n+    private static class WhileClosure implements Closure, Serializable {\n+        /** The test condition */\n+        private final Predicate iPredicate;\n+        /** The closure to call */\n+        private final Closure iClosure;\n+        /** The flag, true is a do loop, false is a while */\n+        private final boolean iDoLoop;\n+\n+        /**\n+         * Constructor to store params\n+         */\n+        private WhileClosure(Predicate predicate, Closure closure, boolean doLoop) {\n+            super();\n+            iPredicate = predicate;\n+            iClosure = closure;\n+            iDoLoop = doLoop;\n+        }\n+\n+        /**\n+         * Execute the closure until the predicate is false\n+         */\n+        public void execute(Object input) {\n+            if (iDoLoop) {\n+                iClosure.execute(input);\n+            }\n+            while (iPredicate.evaluate(input)) {\n+                iClosure.execute(input);\n+            }\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/collections/Factory.java\n+++ b/src/java/org/apache/commons/collections/Factory.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Factory.java,v 1.3 2002/10/12 22:15:19 scolebourne Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/10/12 22:15:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Factory.java,v 1.4 2003/05/16 13:41:10 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n- * 4. The names \"The Jakarta Project\", \"Struts\", and \"Apache Software\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *    from this software without prior written permission. For written\n  *    permission, please contact apache@apache.org.\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  */\n package org.apache.commons.collections;\n \n-\n-\n /**\n- * Factory\n- * A simple interface that describes the most basic means of having the ability\n- * to create an object.\n+ * <code>Factory</code> defines an interface implemented by classes that\n+ * create objects.\n+ * \n+ * @since Commons Collections 2.1\n+ * @version $Revision: 1.4 $ $Date: 2003/05/16 13:41:10 $\n  *\n  * @author Arron Bates\n- * @version $Revision: 1.3 $\n- * @since 2.1\n+ * @author Stephen Colebourne\n  */\n public interface Factory {\n-\n-  /** Simple method from which will come the new object from the factory.\n-   *\n-   * @return Object reference to the new object.\n-   */\n-  public Object create();\n-  \n+    \n+    /**\n+     * Create a new object.\n+     *\n+     * @return a new object\n+     * @throws FunctorException (runtime) if the factory cannot create an object\n+     */\n+    public Object create();\n+    \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FactoryUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FactoryUtils.java,v 1.7 2003/05/16 13:41:10 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * <code>FactoryUtils</code> provides reference implementations and utilities\n+ * for the Factory functor interface. The supplied factories are:\n+ * <ul>\n+ * <li>Prototype - clones a specified object\n+ * <li>Reflection - creates objects using reflection\n+ * <li>Constant - always returns the same object\n+ * <li>Null - always returns null\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied factories are Serializable.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.7 $ $Date: 2003/05/16 13:41:10 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FactoryUtils {\n+\n+    /**\n+     * A factory that always throws an exception\n+     */\n+    private static final Factory EXCEPTION_FACTORY = new ExceptionFactory();\n+    /**\n+     * A factory that always returns null\n+     */\n+    private static final Factory NULL_FACTORY = new ConstantFactory(null);\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public FactoryUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a Factory that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the factory\n+     */\n+    public static Factory exceptionFactory() {\n+        return EXCEPTION_FACTORY;\n+    }\n+\n+    /**\n+     * Gets a Factory that will return null each time the factory is used.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the factory\n+     */\n+    public static Factory nullFactory() {\n+        return NULL_FACTORY;\n+    }\n+\n+    /**\n+     * Creates a Factory that will return the same object each time the factory\n+     * is used. No check is made that the object is immutable. In general, only\n+     * immutable objects should use the constant factory. Mutable objects should\n+     * use the prototype factory.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the factory\n+     * @return the <code>constant</code> factory.\n+     */\n+    public static Factory constantFactory(Object constantToReturn) {\n+        return new ConstantFactory(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Factory that will return a clone of the same prototype object\n+     * each time the factory is used. The prototype will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     *\n+     * @param prototype  the object to clone each time in the factory\n+     * @return the <code>prototype</code> factory\n+     * @throws IllegalArgumentException if the prototype is null\n+     * @throws IllegalArgumentException if the prototype cannot be cloned\n+     */\n+    public static Factory prototypeFactory(Object prototype) {\n+        if (prototype == null) {\n+            throw new IllegalArgumentException(\"The prototype must not be null\");\n+        }\n+        try {\n+            prototype.getClass().getMethod(\"clone\", null);\n+            return new PrototypeCloneFactory(prototype);\n+\n+        } catch (NoSuchMethodException ex) {\n+            try {\n+                prototype.getClass().getConstructor(new Class[] { prototype.getClass()});\n+                return new ReflectionFactory(prototype.getClass(), new Class[] { prototype.getClass()}, new Object[] { prototype });\n+\n+            } catch (NoSuchMethodException ex2) {\n+                if (prototype instanceof Serializable) {\n+                    return new PrototypeSerializationFactory((Serializable) prototype);\n+                }\n+            }\n+        }\n+        throw new IllegalArgumentException(\"The prototype must be cloneable via a public clone method\");\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * a no-args constructor.\n+     *\n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @return the <code>reflection</code> factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     */\n+    public static Factory reflectionFactory(Class classToInstantiate) {\n+        return new ReflectionFactory(classToInstantiate);\n+    }\n+\n+    /**\n+     * Creates a Factory that can create objects of a specific type using\n+     * the arguments specified to this method.\n+     *\n+     * @param classToInstantiate  the Class to instantiate each time in the factory\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the <code>reflection</code> factory\n+     * @throws IllegalArgumentException if the classToInstantiate is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     * @throws IllegalArgumentException if the constructor doesn't exist\n+     */\n+    public static Factory reflectionFactory(Class classToInstantiate, Class[] paramTypes, Object[] args) {\n+        return new ReflectionFactory(classToInstantiate, paramTypes, args);\n+    }\n+\n+    // ExceptionFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionFactory always throws an exception\n+     */\n+    private static class ExceptionFactory implements Factory, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionFactory() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public Object create() {\n+            throw new FunctorException(\"ExceptionFactory invoked\");\n+        }\n+    }\n+\n+    // ConstantFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ConstantFactory returns the same instance each time.\n+     */\n+    private static class ConstantFactory implements Factory, Serializable {\n+        /** The constant to return each time */\n+        private final Object iConstant;\n+\n+        /**\n+         * Constructor to store constant\n+         */\n+        private ConstantFactory(Object constant) {\n+            super();\n+            iConstant = constant;\n+        }\n+\n+        /**\n+         * Always return constant\n+         */\n+        public Object create() {\n+            return iConstant;\n+        }\n+    }\n+\n+    // PrototypeCloneFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * PrototypeCloneFactory creates objects by copying a prototype using the clone method.\n+     */\n+    private static class PrototypeCloneFactory implements Factory, Serializable {\n+        /** The object to clone each time */\n+        private final Object iPrototype;\n+        /** The method used to clone */\n+        private transient Method iCloneMethod;\n+\n+        /**\n+         * Constructor to store prototype\n+         */\n+        private PrototypeCloneFactory(Object prototype) {\n+            super();\n+            if (prototype == null) {\n+                throw new IllegalArgumentException(\"PrototypeCloneFactory: The prototype must not be null\");\n+            }\n+            iPrototype = prototype;\n+\n+            findCloneMethod();\n+        }\n+\n+        /**\n+         * Find the Clone method for the class specified.\n+         */\n+        private void findCloneMethod() {\n+            try {\n+                iCloneMethod = iPrototype.getClass().getMethod(\"clone\", null);\n+\n+            } catch (NoSuchMethodException ex) {\n+                throw new IllegalArgumentException(\"PrototypeCloneFactory: The clone method must exist and be public \");\n+            }\n+        }\n+\n+        /**\n+         * Return clone of prototype\n+         */\n+        public Object create() {\n+            // needed for post-serialization\n+            if (iCloneMethod == null) {\n+                findCloneMethod();\n+            }\n+\n+            try {\n+                return iCloneMethod.invoke(iPrototype, null);\n+\n+            } catch (IllegalAccessException ex) {\n+                throw new FunctorException(\"PrototypeCloneFactory: Clone method must be public\", ex);\n+            } catch (InvocationTargetException ex) {\n+                throw new FunctorException(\"PrototypeCloneFactory: Clone method threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+    // PrototypeSerializationFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * PrototypeSerializationFactory creates objects by cloning a prototype using serialization.\n+     */\n+    private static class PrototypeSerializationFactory implements Factory, Serializable {\n+        /** The object to clone via serialization each time */\n+        private final Serializable iPrototype;\n+\n+        /**\n+         * Constructor to store prototype\n+         */\n+        private PrototypeSerializationFactory(Serializable prototype) {\n+            super();\n+            if (prototype == null) {\n+                throw new IllegalArgumentException(\"PrototypeSerializationFactory: The prototype must not be null\");\n+            }\n+            iPrototype = prototype;\n+        }\n+\n+        /**\n+         * Return clone of prototype by serialization\n+         */\n+        public Object create() {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream(512);\n+            ByteArrayInputStream bais = null;\n+            try {\n+                ObjectOutputStream out = new ObjectOutputStream(baos);\n+                out.writeObject(iPrototype);\n+                \n+                bais = new ByteArrayInputStream(baos.toByteArray());\n+                ObjectInputStream in = new ObjectInputStream(bais);\n+                return in.readObject();\n+        \n+            } catch (ClassNotFoundException ex) {\n+                throw new FunctorException(ex);\n+            } catch (IOException ex) {\n+                throw new FunctorException(ex);\n+            } finally {\n+                try {\n+                    if (bais != null) {\n+                        bais.close();\n+                    }\n+                } catch (IOException ignored) {}\n+                try {\n+                    if (baos != null) {\n+                        baos.close();\n+                    }\n+                } catch (IOException ignored) {}\n+            }\n+        }\n+    }\n+\n+    // ReflectionFactory\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ReflectionFactory creates objects using reflection.\n+     */\n+    private static class ReflectionFactory implements Factory, Serializable {\n+        /** The class to create */\n+        private final Class iClassToInstantiate;\n+        /** The constructor parameter types */\n+        private final Class[] iParamTypes;\n+        /** The constructor arguments */\n+        private final Object[] iArgs;\n+        /** The constructor */\n+        private transient Constructor iConstructor = null;\n+\n+        /**\n+         * Constructor\n+         */\n+        public ReflectionFactory(Class classToInstantiate) {\n+            this(classToInstantiate, null, null);\n+        }\n+\n+        /* builds the object factory taking all the options needed to provide\n+         * arguments to a constructor.\n+         */\n+        public ReflectionFactory(Class classToInstantiate, Class[] paramTypes, Object[] args) {\n+            super();\n+            if (classToInstantiate == null) {\n+                throw new IllegalArgumentException(\"ReflectionFactory: The class to instantiate must not be null\");\n+            }\n+            if (((paramTypes == null) && (args != null))\n+                || ((paramTypes != null) && (args == null))\n+                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+                throw new IllegalArgumentException(\"ReflectionFactory: The parameter types must match the arguments\");\n+            }\n+\n+            iClassToInstantiate = classToInstantiate;\n+            if ((paramTypes == null) && (args == null)) {\n+                iParamTypes = null;\n+                iArgs = null;\n+            } else {\n+                iParamTypes = (Class[]) paramTypes.clone();\n+                iArgs = (Object[]) args.clone();\n+            }\n+\n+            findConstructor();\n+        }\n+\n+        /**\n+         * Find the Constructor for the class specified.\n+         */\n+        private void findConstructor() {\n+            try {\n+                iConstructor = iClassToInstantiate.getConstructor(iParamTypes);\n+\n+            } catch (NoSuchMethodException ex) {\n+                throw new IllegalArgumentException(\"ReflectionFactory: The constructor must exist and be public \");\n+            }\n+        }\n+\n+        /**\n+         * Create the object using a constructor\n+         */\n+        public Object create() {\n+            // needed for post-serialization\n+            if (iConstructor == null) {\n+                findConstructor();\n+            }\n+\n+            try {\n+                return iConstructor.newInstance(iArgs);\n+\n+            } catch (InstantiationException ex) {\n+                throw new FunctorException(\"ReflectionFactory: InstantiationException\", ex);\n+            } catch (IllegalAccessException ex) {\n+                throw new FunctorException(\"ReflectionFactory: Constructor must be public\", ex);\n+            } catch (InvocationTargetException ex) {\n+                throw new FunctorException(\"ReflectionFactory: Constructor threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/FunctorException.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FunctorException.java,v 1.1 2003/05/16 13:41:10 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n+/**\n+ * Exception thrown from functors.\n+ * If required, a root cause error can be wrapped within this one.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/05/16 13:41:10 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FunctorException extends RuntimeException {\n+    \n+    /**\n+     * Does JDK support nested exceptions\n+     */\n+    private static final boolean JDK_SUPPORTS_NESTED;\n+    \n+    static {\n+        boolean flag = false;\n+        try {\n+            Throwable.class.getDeclaredMethod(\"getCause\", new Class[0]);\n+            flag = true;\n+        } catch (NoSuchMethodException ex) {\n+            flag = false;\n+        }\n+        JDK_SUPPORTS_NESTED = flag;\n+    }\n+    \n+    /**\n+     * Root cause of the exception\n+     */\n+    private final Throwable iThrowable;\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> without specified\n+     * detail message.\n+     */\n+    public FunctorException() {\n+        super();\n+        iThrowable = null;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * detail message.\n+     *\n+     * @param msg  the error message.\n+     */\n+    public FunctorException(String msg) {\n+        super(msg);\n+        iThrowable = null;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FunctorException(Throwable rootCause) {\n+        super((rootCause == null ? null : rootCause.getMessage()));\n+        iThrowable = rootCause;\n+    }\n+\n+    /**\n+     * Constructs a new <code>FunctorException</code> with specified\n+     * detail message and nested <code>Throwable</code> root cause.\n+     *\n+     * @param msg        the error message.\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public FunctorException(String msg, Throwable rootCause) {\n+        super(msg);\n+        iThrowable = rootCause;\n+    }\n+\n+    /**\n+     * Gets the cause of this throwable.\n+     * \n+     * @return  the cause of this throwable, or <code>null</code>\n+     */\n+    public Throwable getCause() {\n+        return iThrowable;\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the standard error stream.\n+     */\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified stream.\n+     *\n+     * @param out  the <code>PrintStream</code> to use for output\n+     */\n+    public void printStackTrace(PrintStream out) {\n+        synchronized (out) {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the specified writer.\n+     *\n+     * @param out  the <code>PrintWriter</code> to use for output\n+     */\n+    public void printStackTrace(PrintWriter out) {\n+        synchronized (out) {\n+            super.printStackTrace(out);\n+            if (iThrowable != null && JDK_SUPPORTS_NESTED == false) {\n+                out.print(\"Caused by: \");\n+                iThrowable.printStackTrace(out);\n+            }\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/collections/Predicate.java\n+++ b/src/java/org/apache/commons/collections/Predicate.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Predicate.java,v 1.5 2002/08/15 20:04:31 pjack Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/08/15 20:04:31 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Predicate.java,v 1.6 2003/05/16 13:41:10 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  */\n package org.apache.commons.collections;\n \n-/** Performs some predicate which returns true or false based on the input object.\n-  * Predicate instances can be used to implement queries or to do filtering.\n-  *\n-  * @since 1.0\n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  */\n+/**\n+ * <code>Predicate</code> defines an interface implemented by classes that\n+ * perform a predicate test on an object. Predicate instances can be used\n+ * to implement queries or to do filtering. \n+ * \n+ * @since Commons Collections 1.0\n+ * @version $Revision: 1.6 $ $Date: 2003/05/16 13:41:10 $\n+ * \n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n public interface Predicate {\n-\n+    \n     /**\n-      *  Returns true if the input object matches this predicate. \n-      *\n-      * @return true if the input object matches this predicate, else returns false\n-      */\n-    public boolean evaluate(Object input);\n+     * Use the specified parameter to perform a test that returns true or false.\n+     *\n+     * @param object  the object to evaluate\n+     * @return true or false\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if the predicate encounters a problem\n+     */\n+    public boolean evaluate(Object object);\n+    \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/PredicateUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PredicateUtils.java,v 1.7 2003/05/16 13:41:10 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * <code>PredicateUtils</code> provides reference implementations and utilities\n+ * for the Predicate functor interface. The supplied predicates are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>InstanceOf - true if the object is an instanceof a class\n+ * <li>Equal - true if the object equals() a specified object\n+ * <li>Identity - true if the object == a specified object\n+ * <li>Null - true if the object is null\n+ * <li>NotNull - true if the object is not null\n+ * <li>Unique - true if the object has not already been evaluated\n+ * <li>And/All - true if all of the predicates are true\n+ * <li>Or/Any - true if any of the predicates is true\n+ * <li>Either/One - true if only one of the predicate is true\n+ * <li>Neither/None - true if none of the predicates are true\n+ * <li>Not - true if the predicate is false, and vice versa\n+ * <li>Transformer - wraps a Transformer as a Predicate\n+ * <li>True - always return true\n+ * <li>False - always return false\n+ * <li>Exception - always throws an exception\n+ * <li>NullIsException/NullIsFalse/NullIsTrue - check for null input\n+ * </ul>\n+ * All the supplied predicates are Serializable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.7 $ $Date: 2003/05/16 13:41:10 $\n+ * \n+ * @author Stephen Colebourne\n+ * @author Ola Berg\n+ */\n+public class PredicateUtils {\n+\n+    /**\n+     * A predicate that always throws an exception\n+     */\n+    private static final Predicate EXCEPTION_PREDICATE = new ExceptionPredicate();\n+    /**\n+     * A predicate that always returns true\n+     */\n+    private static final Predicate TRUE_PREDICATE = new ConstantPredicate(true);\n+    /**\n+     * A predicate that always returns false\n+     */\n+    private static final Predicate FALSE_PREDICATE = new ConstantPredicate(false);\n+    /**\n+     * A predicate that returns true if the object is null\n+     */\n+    private static final Predicate NULL_PREDICATE = new IdentityPredicate(null);\n+    /**\n+     * A predicate that returns true if the object is not null\n+     */\n+    private static final Predicate NOT_NULL_PREDICATE = new NotPredicate(NULL_PREDICATE);\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public PredicateUtils() {\n+        super();\n+    }\n+\n+    // Simple predicates\n+    //-----------------------------------------------------------------------------\n+\n+    /** \n+     * Gets a Predicate that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     *\n+     * @return the predicate\n+     */\n+    public static Predicate exceptionPredicate() {\n+        return EXCEPTION_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns true.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate truePredicate() {\n+        return TRUE_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that always returns false.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate falsePredicate() {\n+        return FALSE_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is null.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate nullPredicate() {\n+        return NULL_PREDICATE;\n+    }\n+\n+    /**\n+     * Gets a Predicate that checks if the input object passed in is not null.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate notNullPredicate() {\n+        return NOT_NULL_PREDICATE;\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object using equals().\n+     * \n+     * @param value  the value to compare against\n+     * @return the predicate\n+     */\n+    public static Predicate equalPredicate(Object value) {\n+        if (value == null) {\n+            return NULL_PREDICATE;\n+        }\n+        return new EqualPredicate(value);\n+    }\n+\n+    /**\n+     * Creates a Predicate that checks if the input object is equal to the\n+     * specified object by identity.\n+     * \n+     * @param value  the value to compare against\n+     * @return the predicate\n+     */\n+    public static Predicate identityPredicate(Object value) {\n+        if (value == null) {\n+            return NULL_PREDICATE;\n+        }\n+        return new IdentityPredicate(value);\n+    }\n+    \n+    /**\n+     * Creates a Predicate that checks if the object passed in is of\n+     * a particular type, using instanceof. A <code>null</code> input\n+     * object will return <code>false</code>.\n+     * \n+     * @param type  the type to check for, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the class is null\n+     */\n+    public static Predicate instanceofPredicate(Class type) {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n+        }\n+        return new InstanceofPredicate(type);\n+    }\n+\n+    /**\n+     * Creates a Predicate that returns true the first time an object is\n+     * encoutered, and false if the same object is received \n+     * again. The comparison is by equals(). A <code>null</code> input object\n+     * is accepted and will return true the first time, and false subsequently\n+     * as well.\n+     * \n+     * @return the predicate\n+     */\n+    public static Predicate uniquePredicate() {\n+        // must return new instance each time\n+        return new UniquePredicate();\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a \n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to \n+     * determine the predicate result.\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the methodName is null.\n+     */\n+    public static Predicate invokerPredicate(String methodName){\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asPredicate(TransformerUtils.invokerTransformer(methodName));\n+    }\n+\n+    /**\n+     * Creates a Predicate that invokes a method on the input object.\n+     * The method must return either a boolean or a non-null Boolean,\n+     * and have no parameters. If the input object is null, a \n+     * PredicateException is thrown.\n+     * <p>\n+     * For example, <code>PredicateUtils.invokerPredicate(\"isEmpty\");</code>\n+     * will call the <code>isEmpty</code> method on the input object to \n+     * determine the predicate result.\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Predicate invokerPredicate(String methodName, Class[] paramTypes, Object[] args){\n+        // reuse transformer as it has caching - this is lazy really, should have inner class here\n+        return asPredicate(TransformerUtils.invokerTransformer(methodName, paramTypes, args));\n+    }\n+\n+    // Boolean combinations\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that returns true only if both of the specified\n+     * predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>and</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate andPredicate(Predicate predicate1, Predicate predicate2) {\n+        return allPredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate allPredicate(Predicate[] predicates) {\n+        return new AllPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true only if all of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>all</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate allPredicate(Collection predicates) {\n+        return new AllPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if either of the specified\n+     * predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>or</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate orPredicate(Predicate predicate1, Predicate predicate2) {\n+        return anyPredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate anyPredicate(Predicate[] predicates) {\n+        return new AnyPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if any of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>any</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate anyPredicate(Collection predicates) {\n+        return new AnyPredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if one, but not both, of the\n+     * specified predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>either</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate eitherPredicate(Predicate predicate1, Predicate predicate2) {\n+        return onePredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate onePredicate(Predicate[] predicates) {\n+        return new OnePredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if only one of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>one</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate onePredicate(Collection predicates) {\n+        return new OnePredicate(validate(predicates));\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if neither of the specified \n+     * predicates are true.\n+     * \n+     * @param predicate1  the first predicate, may not be null\n+     * @param predicate2  the second predicate, may not be null\n+     * @return the <code>neither</code> predicate\n+     * @throws IllegalArgumentException if either predicate is null\n+     */\n+    public static Predicate neitherPredicate(Predicate predicate1, Predicate predicate2) {\n+        return nonePredicate(new Predicate[] { predicate1, predicate2 });\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true.\n+     * \n+     * @param predicates  an array of predicates to check, may not be null\n+     * @return the <code>none</code> predicate\n+     * @throws IllegalArgumentException if the predicates array is null\n+     * @throws IllegalArgumentException if the predicates array has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the array is null\n+     */\n+    public static Predicate nonePredicate(Predicate[] predicates) {\n+        Predicate[] preds = validate(predicates);\n+        for (int i = 0; i < preds.length; i++) {\n+            preds[i] = notPredicate(preds[i]);\n+        }\n+        return new AllPredicate(preds);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if none of the specified\n+     * predicates are true. The predicates are checked in iterator order.\n+     * \n+     * @param predicates  a collection of predicates to check, may not be null\n+     * @return the <code>none</code> predicate\n+     * @throws IllegalArgumentException if the predicates collection is null\n+     * @throws IllegalArgumentException if the predicates collection has less than 2 elements\n+     * @throws IllegalArgumentException if any predicate in the collection is null\n+     */\n+    public static Predicate nonePredicate(Collection predicates) {\n+        Predicate[] preds = validate(predicates);\n+        for (int i = 0; i < preds.length; i++) {\n+            preds[i] = notPredicate(preds[i]);\n+        }\n+        return new AllPredicate(preds);\n+    }\n+\n+    /**\n+     * Create a new Predicate that returns true if the specified predicate\n+     * returns false and vice versa.\n+     * \n+     * @param predicate  the predicate to not\n+     * @return the <code>not</code> predicate\n+     * @throws IllegalArgumentException if the predicate is null\n+     */\n+    public static Predicate notPredicate(Predicate predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NotPredicate(predicate);\n+    }\n+\n+    // Adaptors\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Create a new Predicate that wraps a Transformer. The Transformer must\n+     * return either Boolean.TRUE or Boolean.FALSE otherwise a PredicateException\n+     * will be thrown.\n+     * \n+     * @param transformer  the transformer to wrap, may not be null\n+     * @return the transformer wrapping predicate\n+     * @throws IllegalArgumentException if the transformer is null\n+     */\n+    public static Predicate asPredicate(Transformer transformer) {\n+        if (transformer == null) {\n+            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+        }\n+        return new TransformerPredicate(transformer);\n+    }\n+\n+    // Null handlers\n+    //-----------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Predicate that throws an exception if the input object is null, \n+     * otherwise it calls the specified Predicate. This allows null handling \n+     * behaviour to be added to Predicates that don't support nulls.\n+     * \n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static Predicate nullIsExceptionPredicate(Predicate predicate){\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NullIsExceptionPredicate( predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns false if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     * \n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static Predicate nullIsFalsePredicate(Predicate predicate){\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NullIsFalsePredicate(predicate);\n+    }\n+\n+    /**\n+     * Gets a Predicate that returns true if the input object is null, otherwise\n+     * it calls the specified Predicate. This allows null handling behaviour to\n+     * be added to Predicates that don't support nulls.\n+     * \n+     * @param predicate  the predicate to wrap, may not be null\n+     * @return the predicate\n+     * @throws IllegalArgumentException if the predicate is null.\n+     */\n+    public static Predicate nullIsTruePredicate(Predicate predicate){\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new NullIsTruePredicate(predicate);\n+    }\n+\n+    /**\n+     * Convert a collection to an array using the iterator.\n+     * \n+     * @param predicates  the predicates to validate\n+     * @return predicate array\n+     */\n+    private static Predicate[] validate(Collection predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate collection must not be null\");\n+        }\n+        if (predicates.size() < 2) {\n+            throw new IllegalArgumentException(\n+                \"At least 2 predicates must be specified in the predicate collection, size was \" + predicates.size());\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Predicate[] preds = new Predicate[predicates.size()];\n+        int i = 0;\n+        for (Iterator it = predicates.iterator(); it.hasNext();) {\n+            preds[i] = (Predicate) it.next();\n+            if (preds[i] == null) {\n+                throw new IllegalArgumentException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+            i++;\n+        }\n+        return preds;\n+    }\n+    \n+    /**\n+     * Validate method shared amongst predicate implementations.\n+     * \n+     * @param predicates  the predicates to validate\n+     * @return predicate array (copy)\n+     */\n+    private static Predicate[] validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+        }\n+        if (predicates.length < 2) {\n+            throw new IllegalArgumentException(\n+                \"At least 2 predicates must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        Predicate[] preds = new Predicate[predicates.length];\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+            preds[i] = predicates[i];\n+        }\n+        return preds;\n+    }\n+\n+    // ExceptionPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionPredicate always throws an exception\n+     */\n+    private static class ExceptionPredicate implements Predicate, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionPredicate() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw an exception\n+         */\n+        public boolean evaluate(Object object) {\n+            throw new FunctorException(\"ExceptionPredicate invoked\");\n+        }\n+    }\n+\n+    // ConstantPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ConstantPredicate returns the same instance each time.\n+     */\n+    private static class ConstantPredicate implements Predicate, Serializable {\n+        /** The constant value to return each time */\n+        private final boolean iConstant;\n+\n+        /**\n+         * Constructor to store constant\n+         */\n+        private ConstantPredicate(boolean constant) {\n+            super();\n+            iConstant = constant;\n+        }\n+\n+        /**\n+         * Always return constant\n+         */\n+        public boolean evaluate(Object object) {\n+            return iConstant;\n+        }\n+    }\n+\n+    // AllPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * AllPredicate returns true if all predicates return true\n+     */\n+    private static class AllPredicate implements Predicate, Serializable {\n+        /** The array of predicates to call */\n+        private final Predicate[] iPredicates;\n+\n+        /**\n+         * Constructor\n+         */\n+        private AllPredicate(Predicate[] predicates) {\n+            super();\n+            iPredicates = predicates;\n+        }\n+\n+        /**\n+         * Return true if all predicates return true\n+         */\n+        public boolean evaluate(Object object) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(object) == false) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    // AnyPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * AnyPredicate returns true if one of the predicates return true\n+     */\n+    private static class AnyPredicate implements Predicate, Serializable {\n+        /** The array of predicates to call */\n+        private final Predicate[] iPredicates;\n+\n+        /**\n+         * Constructor\n+         */\n+        private AnyPredicate(Predicate[] predicates) {\n+            super();\n+            iPredicates = predicates;\n+        }\n+\n+        /**\n+         * Return true if one of the predicates returns true\n+         */\n+        public boolean evaluate(Object object) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(object)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    // OnePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * OnePredicate returns true if only one of the predicates return true\n+     */\n+    private static class OnePredicate implements Predicate, Serializable {\n+        /** The array of predicates to call */\n+        private final Predicate[] iPredicates;\n+\n+        /**\n+         * Constructor\n+         */\n+        private OnePredicate(Predicate[] predicates) {\n+            super();\n+            iPredicates = predicates;\n+        }\n+\n+        /**\n+         * Return true if only one of the predicates returns true\n+         */\n+        public boolean evaluate(Object object) {\n+            boolean match = false;\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(object)) {\n+                    if (match) {\n+                        return false;\n+                    }\n+                    match = true;\n+                }\n+            }\n+            return match;\n+        }\n+    }\n+\n+    // NotPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NotPredicate returns the opposite of the wrapped predicate\n+     */\n+    private static class NotPredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n+        private final Predicate iPredicate;\n+\n+        /**\n+         * Constructor\n+         */\n+        private NotPredicate(Predicate predicate) {\n+            super();\n+            iPredicate = predicate;\n+        }\n+\n+        /**\n+         * Return true if the wrapped predicate returns false, and vice versa\n+         */\n+        public boolean evaluate(Object object) {\n+            return !iPredicate.evaluate(object);\n+        }\n+    }\n+\n+    // InstanceofPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * InstanceofPredicate checks the type of an object\n+     */\n+    private static class InstanceofPredicate implements Predicate, Serializable {\n+        /** The type to check for */\n+        private final Class iType;\n+\n+        /**\n+         * Constructor\n+         */\n+        public InstanceofPredicate(Class type) {\n+            super();\n+            iType = type;\n+        }\n+\n+        /**\n+         * Return true if the object is an instanceof the type of the predicate.\n+         */\n+        public boolean evaluate(Object object) {\n+            return iType.isInstance(object);\n+        }\n+    }\n+\n+    // EqualPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * EqualPredicate that checks if the object is a particular value by equals().\n+     */\n+    private static class EqualPredicate implements Predicate, Serializable {\n+        /** The object to compare to */\n+        private final Object iValue;\n+\n+        /**\n+         * Constructor\n+         */\n+        public EqualPredicate(Object value) {\n+            super();\n+            iValue = value;\n+        }\n+\n+        /**\n+         * Return true if the object is equals() to the value stored in the predicate.\n+         */\n+        public boolean evaluate(Object object) {\n+            return iValue.equals(object);\n+        }\n+    }\n+\n+    // IdentityPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * IdentityPredicate that checks if the object is a particular value by identity.\n+     */\n+    private static class IdentityPredicate implements Predicate, Serializable {\n+        /** The object to compare identity to */\n+        private final Object iValue;\n+\n+        /**\n+         * Constructor\n+         */\n+        public IdentityPredicate(Object value) {\n+            super();\n+            iValue = value;\n+        }\n+\n+        /**\n+         * Return true if the object is equals() to the value stored in the predicate.\n+         */\n+        public boolean evaluate(Object object) {\n+            return iValue == object;\n+        }\n+    }\n+\n+    // UniquePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * UniquePredicate returns true the first time an object is\n+     * encoutered, and false if the same object is received \n+     * again using equals().\n+     */\n+    private static class UniquePredicate implements Predicate, Serializable {\n+        /** The set of previously seen objects */\n+        private final Set iSet = new HashSet();\n+\n+        /**\n+         * Constructor\n+         */\n+        public UniquePredicate() {\n+            super();\n+        }\n+\n+        /**\n+         * Return true the first time, and false subsequant times\n+         * that an object is encountered, using equals().\n+         */\n+        public boolean evaluate(Object object) {\n+            return iSet.add(object);\n+        }\n+    }\n+\n+    // TransformerPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * TransformerPredicate returns the result of the Transformer as a boolean.\n+     */\n+    private static class TransformerPredicate implements Predicate, Serializable {\n+        /** The transformer to call */\n+        private final Transformer iTransformer;\n+\n+        /**\n+         * Constructor\n+         */\n+        public TransformerPredicate(Transformer transformer) {\n+            super();\n+            iTransformer = transformer;\n+        }\n+\n+        /**\n+         * Return the boolean result of a Transformer\n+         */\n+        public boolean evaluate(Object object) {\n+            Object result = iTransformer.transform(object);\n+            if (result instanceof Boolean == false) {\n+                throw new FunctorException(\n+                    \"TransformerPredicate: Transformer must return an instanceof Boolean, it was a \"\n+                        + (result == null ? \"null object\" : result.getClass().getName()));\n+            }\n+            return ((Boolean) result).booleanValue();\n+        }\n+    }\n+\n+    // NullIsExceptionPredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NullIsExceptionPredicate returns an exception if null is passed in.\n+     */\n+    private static class NullIsExceptionPredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NullIsExceptionPredicate(Predicate predicate){\n+            super();\n+            iPredicate = predicate;\n+        }\n+        \n+        /**\n+         * Return an exception if null\n+         */\n+        public boolean evaluate(Object object){\n+            if (object == null) {\n+                throw new FunctorException(\"NullIsExceptionPredicate: Input Object must not be null\");\n+            }\n+            return iPredicate.evaluate(object);\n+        }\n+    };\n+\n+    // NullIsFalsePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NullIsFalsePredicate returns false if null is passed in.\n+     */\n+    private static class NullIsFalsePredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NullIsFalsePredicate(Predicate predicate){\n+            super();\n+            iPredicate = predicate;\n+        }\n+        \n+        /**\n+         * Return false if null\n+         */\n+        public boolean evaluate(Object object){\n+            if (object == null) {\n+                return false;\n+            }\n+            return iPredicate.evaluate(object);\n+        }\n+    };\n+\n+    // NullIsTruePredicate\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NullIsTruePredicate returns true if null is passed in.\n+     */\n+    private static class NullIsTruePredicate implements Predicate, Serializable {\n+        /** The predicate to call */\n+        private final Predicate iPredicate;\n+        \n+        /**\n+         * Constructor\n+         */\n+        private NullIsTruePredicate(Predicate predicate){\n+            super();\n+            iPredicate = predicate;\n+        }\n+        \n+        /**\n+         * Return true if null\n+         */\n+        public boolean evaluate(Object object){\n+            if (object == null) {\n+                return true;\n+            }\n+            return iPredicate.evaluate(object);\n+        }\n+    };\n+\n+}\n--- a/src/java/org/apache/commons/collections/Transformer.java\n+++ b/src/java/org/apache/commons/collections/Transformer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Transformer.java,v 1.4 2002/06/12 03:59:15 mas Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/06/12 03:59:15 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Transformer.java,v 1.5 2003/05/16 13:41:10 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  */\n package org.apache.commons.collections;\n \n-/** An object capable of transforming an input object into some output object.\n-  *\n-  * @since 1.0\n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  */\n+/**\n+ * <code>Transformer</code> defines an interface implemented by classes that\n+ * transform one object into another. The original object is left unchanged.\n+ * Transformers are typically used for type conversions, or extracting data\n+ * from an object.\n+ * \n+ * @since Commons Collections 1.0\n+ * @version $Revision: 1.5 $ $Date: 2003/05/16 13:41:10 $\n+ * \n+ * @author James Strachan\n+ * @author Stephen Colebourne\n+ */\n public interface Transformer {\n \n-    /** Transforms the input object (leaving it unchanged) into some output object.\n-      * @return the transformation of the input object to the output object\n-      */\n+    /**\n+     * Transforms the input object (leaving it unchanged) into some output object.\n+     *\n+     * @param input  the object to be transformed\n+     * @return a transformed object\n+     * @throws ClassCastException (runtime) if the input is the wrong class\n+     * @throws IllegalArgumentException (runtime) if the input is invalid\n+     * @throws FunctorException (runtime) if the transform cannot be completed\n+     */\n     public Object transform(Object input);\n+    \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/TransformerUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/TransformerUtils.java,v 1.1 2003/05/16 13:41:10 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+/**\n+ * <code>TransformerUtils</code> provides reference implementations and \n+ * utilities for the Transformer functor interface. The supplied transformers are:\n+ * <ul>\n+ * <li>Invoker - returns the result of a method call on the input object\n+ * <li>Clone - returns a clone of the input object\n+ * <li>Constant - always returns the same object\n+ * <li>Closure - performs a Closure and returns the input object\n+ * <li>Predicate - returns the result of the predicate as a Boolean\n+ * <li>Factory - returns a new object from a factory\n+ * <li>Chained - chains two or more transformers together\n+ * <li>Switch - calls one transformer based on one or more predicates\n+ * <li>SwitchMap - calls one transformer looked up from a Map\n+ * <li>Instantiate - the Class input object is instantiated\n+ * <li>Map - returns an object from a supplied Map\n+ * <li>Null - always returns null\n+ * <li>NOP - returns the input object, which should be immutable\n+ * <li>Exception - always throws an exception\n+ * </ul>\n+ * All the supplied transformers are Serializable.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/05/16 13:41:10 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TransformerUtils {\n+\n+    /**\n+     * A transformer that always throws an exception\n+     */\n+    private static final Transformer EXCEPTION_TRANSFORMER = new ExceptionTransformer();\n+    /**\n+     * A transformer that always returns null\n+     */\n+    private static final Transformer NULL_TRANSFORMER = new ConstantTransformer(null);\n+    /**\n+     * A transformer that returns the input object\n+     */\n+    private static final Transformer NOP_TRANSFORMER = new NOPTransformer();\n+    /**\n+     * A transformer that clones the input object\n+     */\n+    private static final Transformer CLONE_TRANSFORMER = new CloneTransformer();\n+    /**\n+     * A transformer that creates an object from a Class\n+     */\n+    private static final Transformer INSTANTIATE_TRANSFORMER = new InstantiateTransformer(null, null);\n+\n+    /**\n+     * This class is not normally instantiated.\n+     */\n+    public TransformerUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Gets a transformer that always throws an exception.\n+     * This could be useful during testing as a placeholder.\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer exceptionTransformer() {\n+        return EXCEPTION_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Gets a transformer that always returns null.\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer nullTransformer() {\n+        return NULL_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Gets a transformer that returns the input object.\n+     * The input object should be immutable to maintain the\n+     * contract of Transformer (although this is not checked).\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer nopTransformer() {\n+        return NOP_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Gets a transformer that returns a clone of the input\n+     * object. The input object will be cloned using one of these\n+     * techniques (in order):\n+     * <ul>\n+     * <li>public clone method\n+     * <li>public copy constructor\n+     * <li>serialization clone\n+     * <ul>\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer cloneTransformer() {\n+        return CLONE_TRANSFORMER;\n+    }\n+\n+    /**\n+     * Creates a Transformer that will return the same object each time the \n+     * transformer is used.\n+     *\n+     * @param constantToReturn  the constant object to return each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer constantTransformer(Object constantToReturn) {\n+        return new ConstantTransformer(constantToReturn);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Closure each time the transformer is used.\n+     * The transformer returns the input object.\n+     *\n+     * @param command  the command to run each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer asTransformer(Closure closure) {\n+        if (closure == null) {\n+            throw new IllegalArgumentException(\"The closure must not be null\");\n+        }\n+        return new ClosureTransformer(closure);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Predicate each time the transformer is used.\n+     * The transformer will return either Boolean.TRUE or Boolean.FALSE.\n+     *\n+     * @param predicate  the predicate to run each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer asTransformer(Predicate predicate) {\n+        if (predicate == null) {\n+            throw new IllegalArgumentException(\"The predicate must not be null\");\n+        }\n+        return new PredicateTransformer(predicate);\n+    }\n+\n+    /**\n+     * Creates a Transformer that calls a Factory each time the transformer is used.\n+     * The transformer will return the value returned by the factory.\n+     *\n+     * @param factory  the factory to run each time in the transformer\n+     * @return the transformer.\n+     */\n+    public static Transformer asTransformer(Factory factory) {\n+        if (factory == null) {\n+            throw new IllegalArgumentException(\"The factory must not be null\");\n+        }\n+        return new FactoryTransformer(factory);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls two transformers, passing the result of\n+     * the first into the second.\n+     * \n+     * @param transformer1  the first transformer\n+     * @param transformer2  the second transformer\n+     * @return the transformer\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    public static Transformer chainedTransformer(Transformer transformer1, Transformer transformer2) {\n+        Transformer[] trs = new Transformer[] {transformer1, transformer2};\n+        validate(trs);\n+        return new ChainedTransformer(trs);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer.\n+     * \n+     * @param transformers  an array of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers array is null\n+     * @throws IllegalArgumentException if the transformers array has 0 elements\n+     * @throws IllegalArgumentException if any transformer in the array is null\n+     */\n+    public static Transformer chainedTransformer(Transformer[] transformers) {\n+        Transformer[] trs = copy(transformers);\n+        validate(trs);\n+        return new ChainedTransformer(trs);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls each transformer in turn, passing the \n+     * result into the next transformer. The ordering is that of the iterator()\n+     * method on the collection.\n+     * \n+     * @param transformers  a collection of transformers to chain\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the transformers collection is null\n+     * @throws IllegalArgumentException if the transformers collection is empty\n+     * @throws IllegalArgumentException if any transformer in the collection is null\n+     */\n+    public static Transformer chainedTransformer(Collection transformers) {\n+        Transformer[] trs = null;\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"The transformer collection must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        trs = new Transformer[transformers.size()];\n+        int i = 0;\n+        for (Iterator it = transformers.iterator(); it.hasNext();) {\n+            trs[i++] = (Transformer) it.next();\n+        }\n+        validate(trs);\n+        return new ChainedTransformer(trs);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of two transformers depending \n+     * on the specified predicate.\n+     * \n+     * @param predicate  the predicate to switch on\n+     * @param trueTransformer  the transformer called if the predicate is true\n+     * @param falseTransformer  the transformer called if the predicate is false\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the predicate is null\n+     * @throws IllegalArgumentException if either transformer is null\n+     */\n+    public static Transformer switchTransformer(Predicate predicate, Transformer trueTransformer, Transformer falseTransformer) {\n+        return switchTransformerInternal(new Predicate[] { predicate }, new Transformer[] { trueTransformer }, falseTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, null is returned.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Transformer switchTransformer(Predicate[] predicates, Transformer[] transformers) {\n+        return switchTransformerInternal(copy(predicates), copy(transformers), null);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. The transformer at array location 0 is called if the\n+     * predicate at array location 0 returned true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called.\n+     * \n+     * @param predicates  an array of predicates to check\n+     * @param transformers  an array of transformers to call\n+     * @param defaultTransformer  the default to call if no predicate matches\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the either array is null\n+     * @throws IllegalArgumentException if the either array has 0 elements\n+     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays are different sizes\n+     */\n+    public static Transformer switchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+        return switchTransformerInternal(copy(predicates), copy(transformers), defaultTransformer);\n+    }\n+\n+    /**\n+     * Create a new Transformer that calls one of the transformers depending \n+     * on the predicates. \n+     * <p>\n+     * The Map consists of Predicate keys and Transformer values. A transformer \n+     * is called if its matching predicate returns true. Each predicate is evaluated\n+     * until one returns true. If no predicates evaluate to true, the default\n+     * transformer is called. The default transformer is set in the map with a \n+     * null key. If no default transformer is set, null will be returned in a default\n+     * case. The ordering is that of the iterator() method on the entryset collection \n+     * of the map.\n+     * \n+     * @param predicatesAndTransformers  a map of predicates to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws ClassCastException  if the map elements are of the wrong type\n+     */\n+    public static Transformer switchTransformer(Map predicatesAndTransformers) {\n+        Transformer[] trs = null;\n+        Predicate[] preds = null;\n+        if (predicatesAndTransformers == null) {\n+            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n+        }\n+        // convert to array like this to guarantee iterator() ordering\n+        Transformer def = (Transformer) predicatesAndTransformers.remove(null);\n+        int size = predicatesAndTransformers.size();\n+        trs = new Transformer[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = predicatesAndTransformers.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = (Predicate) entry.getKey();\n+            trs[i] = (Transformer) entry.getValue();\n+            i++;\n+        }\n+        return switchTransformerInternal(preds, trs, def);\n+    }\n+\n+    /**\n+     * Validate input and create transformer\n+     */\n+    private static Transformer switchTransformerInternal(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+        validate(predicates);\n+        validate(transformers);\n+        if (predicates.length != transformers.length) {\n+            throw new IllegalArgumentException(\"The predicate and transformer arrays must be the same size\");\n+        }\n+        if (defaultTransformer == null) {\n+            defaultTransformer = nullTransformer();\n+        }\n+        return new SwitchTransformer(predicates, transformers, defaultTransformer);\n+    }\n+    \n+    /**\n+     * Create a new Transformer that uses the input object as a key to find the\n+     * transformer to call. \n+     * <p>\n+     * The Map consists of object keys and Transformer values. A transformer \n+     * is called if the input object equals the key. If there is no match, the\n+     * default transformer is called. The default transformer is set in the map\n+     * using a null key. If no default is set, null will be returned in a default case.\n+     * \n+     * @param objectsAndTransformers  a map of objects to transformers\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     * @throws IllegalArgumentException if the map is empty\n+     * @throws IllegalArgumentException if any transformer in the map is null\n+     */\n+    public static Transformer switchMapTransformer(Map objectsAndTransformers) {\n+        Transformer[] trs = null;\n+        Predicate[] preds = null;\n+        if (objectsAndTransformers == null) {\n+            throw new IllegalArgumentException(\"The obejct and transformer map must not be null\");\n+        }\n+        Transformer def = (Transformer) objectsAndTransformers.remove(null);\n+        int size = objectsAndTransformers.size();\n+        trs = new Transformer[size];\n+        preds = new Predicate[size];\n+        int i = 0;\n+        for (Iterator it = objectsAndTransformers.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            preds[i] = PredicateUtils.equalPredicate(entry.getKey());\n+            trs[i] = (Transformer) entry.getValue();\n+            i++;\n+        }\n+        return switchTransformer(preds, trs, def);\n+    }\n+\n+    /**\n+     * Gets a Transformer that expects an input Class object that it will instantiate.\n+     * \n+     * @return the transformer\n+     */\n+    public static Transformer instantiateTransformer() {\n+        return INSTANTIATE_TRANSFORMER;\n+    }\n+\n+    /** \n+     * Creates a Transformer that expects an input Class object that it will \n+     * instantiate. The constructor used is determined by the arguments specified\n+     * to this method.\n+     *\n+     * @param paramTypes  parameter types for the constructor, can be null\n+     * @param args  the arguments to pass to the constructor, can be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Transformer instantiateTransformer(Class[] paramTypes, Object[] args) {\n+        return new InstantiateTransformer(paramTypes, args);\n+    }\n+\n+    /** \n+     * Creates a Transformer that uses the passed in Map to transform the input \n+     * object (as a simple lookup).\n+     *\n+     * @param map  the map to use to transform the objects\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static Transformer mapTransformer(Map map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"The map must not be null\");\n+        }\n+        return new MapTransformer(map);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method must have no parameters. If the input object is null, \n+     * null is returned.\n+     * <p>\n+     * For example, <code>TransformerUtils.invokerTransformer(\"getName\");</code>\n+     * will call the <code>getName/code> method on the input object to \n+     * determine the transformer result.\n+     * \n+     * @param methodName  the method name to call on the input object, may not be null\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the methodName is null.\n+     */\n+    public static Transformer invokerTransformer(String methodName){\n+        return new InvokerTransformer(methodName, null, null);\n+    }\n+\n+    /**\n+     * Gets a Transformer that invokes a method on the input object.\n+     * The method parameters are specified. If the input object is null, \n+     * null is returned.\n+     * \n+     * @param methodName  the name of the method\n+     * @param paramTypes  the parameter types\n+     * @param args  the arguments\n+     * @return the transformer\n+     * @throws IllegalArgumentException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n+     */\n+    public static Transformer invokerTransformer(String methodName, Class[] paramTypes, Object[] args){\n+        return new InvokerTransformer(methodName, paramTypes, args);\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param predicates  the predicates to copy\n+     */\n+    private static Predicate[] copy(Predicate[] predicates) {\n+        if (predicates == null) {\n+            return null;\n+        }\n+        return (Predicate[]) predicates.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param predicates  the predicates to validate\n+     */\n+    private static void validate(Predicate[] predicates) {\n+        if (predicates == null) {\n+            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+        }\n+        if (predicates.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"At least 1 predicate must be specified in the predicate array, size was \" + predicates.length);\n+        }\n+        for (int i = 0; i < predicates.length; i++) {\n+            if (predicates[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy method\n+     * \n+     * @param transformers  the transformers to copy\n+     */\n+    private static Transformer[] copy(Transformer[] transformers) {\n+        if (transformers == null) {\n+            return null;\n+        }\n+        return (Transformer[]) transformers.clone();\n+    }\n+    \n+    /**\n+     * Validate method\n+     * \n+     * @param transformers  the transformers to validate\n+     */\n+    private static void validate(Transformer[] transformers) {\n+        if (transformers == null) {\n+            throw new IllegalArgumentException(\"The transformer array must not be null\");\n+        }\n+        if (transformers.length < 1) {\n+            throw new IllegalArgumentException(\n+                \"At least 1 transformer must be specified in the transformer array, size was \" + transformers.length);\n+        }\n+        for (int i = 0; i < transformers.length; i++) {\n+            if (transformers[i] == null) {\n+                throw new IllegalArgumentException(\n+                    \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n+            }\n+        }\n+    }\n+\n+    // ExceptionTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ExceptionTransformer always throws an exception.\n+     */\n+    private static class ExceptionTransformer implements Transformer, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private ExceptionTransformer() {\n+            super();\n+        }\n+\n+        /**\n+         * Always throw exception\n+         */\n+        public Object transform(Object input) {\n+            throw new FunctorException(\"ExceptionTransformer invoked\");\n+        }\n+    }\n+\n+    // NOPTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * NOPTransformer returns the input object.\n+     */\n+    private static class NOPTransformer implements Transformer, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private NOPTransformer() {\n+            super();\n+        }\n+\n+        /**\n+         * Return the input object\n+         */\n+        public Object transform(Object input) {\n+            return input;\n+        }\n+    }\n+\n+    // CloneTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * CloneTransformer returns a clone of the input object.\n+     */\n+    private static class CloneTransformer implements Transformer, Serializable {\n+\n+        /**\n+         * Constructor\n+         */\n+        private CloneTransformer() {\n+            super();\n+        }\n+\n+        /**\n+         * Returns a clone of the input object\n+         */\n+        public Object transform(Object input) {\n+            if (input == null) {\n+                return null;\n+            }\n+            return FactoryUtils.prototypeFactory(input).create();\n+        }\n+    }\n+\n+    // ConstantTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ConstantTransformer returns the same instance each time.\n+     */\n+    private static class ConstantTransformer implements Transformer, Serializable {\n+        /** The constant to return each time */\n+        private final Object iConstant;\n+\n+        /**\n+         * Constructor to store constant.\n+         */\n+        private ConstantTransformer(Object constant) {\n+            super();\n+            iConstant = constant;\n+        }\n+\n+        /**\n+         * Always return constant.\n+         */\n+        public Object transform(Object input) {\n+            return iConstant;\n+        }\n+    }\n+\n+    // ClosureTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ClosureTransformer executes a Closure object.\n+     */\n+    private static class ClosureTransformer implements Transformer, Serializable {\n+        /** The closure to call each time */\n+        private final Closure iClosure;\n+\n+        /**\n+         * Constructor to store closure.\n+         */\n+        private ClosureTransformer(Closure closure) {\n+            super();\n+            iClosure = closure;\n+        }\n+\n+        /**\n+         * Exceute the closure and return the input.\n+         */\n+        public Object transform(Object input) {\n+            iClosure.execute(input);\n+            return input;\n+        }\n+    }\n+\n+    // PredicateTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * PredicateTransformer evaluates a Predicate object.\n+     */\n+    private static class PredicateTransformer implements Transformer, Serializable {\n+        /** The predicate to call each time */\n+        private final Predicate iPredicate;\n+\n+        /**\n+         * Constructor to store predicate.\n+         */\n+        private PredicateTransformer(Predicate predicate) {\n+            super();\n+            iPredicate = predicate;\n+        }\n+\n+        /**\n+         * Evaluate the predicate and return the result as a Boolean.\n+         */\n+        public Object transform(Object input) {\n+            return new Boolean(iPredicate.evaluate(input));\n+        }\n+    }\n+\n+    // FactoryTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * FactoryTransformer returns the result of calling a Factory.\n+     */\n+    private static class FactoryTransformer implements Transformer, Serializable {\n+        /** The factory to call each time */\n+        private final Factory iFactory;\n+\n+        /**\n+         * Constructor to store factory.\n+         */\n+        private FactoryTransformer(Factory factory) {\n+            super();\n+            iFactory = factory;\n+        }\n+\n+        /**\n+         * Return the result of calling the factory.\n+         */\n+        public Object transform(Object input) {\n+            return iFactory.create();\n+        }\n+    }\n+\n+    // ChainedTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * ChainedTransformer returns the result of calling a list of transformers.\n+     */\n+    private static class ChainedTransformer implements Transformer, Serializable {\n+        /** The array of transformers to call */\n+        private final Transformer[] iTransformers;\n+\n+        /**\n+         * Constructor to store params.\n+         */\n+        private ChainedTransformer(Transformer[] transformers) {\n+            super();\n+            iTransformers = transformers;\n+        }\n+\n+        /**\n+         * Returns the result of calling a list of transformers.\n+         */\n+        public Object transform(Object object) {\n+            for (int i = 0; i < iTransformers.length; i++) {\n+                object = iTransformers[i].transform(object);\n+            }\n+            return object;\n+        }\n+    }\n+\n+    // SwitchTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * SwitchTransformer returns the result of the transformer whose predicate returns true.\n+     */\n+    private static class SwitchTransformer implements Transformer, Serializable {\n+        /** The array of predicates to switch on */\n+        private final Predicate[] iPredicates;\n+        /** The array of transformers to call */\n+        private final Transformer[] iTransformers;\n+        /** The default transformer called if no predicate matches */\n+        private final Transformer iDefault;\n+\n+        /**\n+         * Constructor to store params.\n+         */\n+        private SwitchTransformer(Predicate[] predicates, Transformer[] transformers, Transformer defaultTransformer) {\n+            super();\n+            iPredicates = predicates;\n+            iTransformers = transformers;\n+            iDefault = defaultTransformer;\n+        }\n+\n+        /**\n+         * Returns the result of the transformer whose predicate returns true.\n+         */\n+        public Object transform(Object input) {\n+            for (int i = 0; i < iPredicates.length; i++) {\n+                if (iPredicates[i].evaluate(input) == true) {\n+                    return iTransformers[i].transform(input);\n+                }\n+            }\n+            return iDefault.transform(input);\n+        }\n+    }\n+\n+    // InstantiateTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * InstantiateTransformer returns the result of instantiating the input Class object.\n+     */\n+    private static class InstantiateTransformer implements Transformer, Serializable {\n+        /** The array of reflection parameter types */\n+        private final Class[] iParamTypes;\n+        /** The array of reflection arguments */\n+        private final Object[] iArgs;\n+\n+        /**\n+         * Constructor to store params.\n+         */\n+        private InstantiateTransformer(Class[] paramTypes, Object[] args) {\n+            super();\n+            if (((paramTypes == null) && (args != null))\n+                || ((paramTypes != null) && (args == null))\n+                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+                throw new IllegalArgumentException(\"InstantiateTransformer: The parameter types must match the arguments\");\n+            }\n+            if ((paramTypes == null) && (args == null)) {\n+                iParamTypes = null;\n+                iArgs = null;\n+            } else {\n+                iParamTypes = (Class[]) paramTypes.clone();\n+                iArgs = (Object[]) args.clone();\n+            }\n+        }\n+\n+        /**\n+         * Return the result of instantiating the input Class object.\n+         */\n+        public Object transform(Object input) {\n+            try {\n+                if (input instanceof Class == false) {\n+                    throw new FunctorException(\n+                        \"InstantiateTransformer: Input object was not an instanceof Class, it was a \"\n+                            + (input == null ? \"null object\" : input.getClass().getName()));\n+                }\n+                return FactoryUtils.reflectionFactory((Class) input, iParamTypes, iArgs).create();\n+\n+            } catch (IllegalArgumentException ex) {\n+                throw new FunctorException(\"InstantiateTransformer\", ex);\n+            }\n+        }\n+    }\n+\n+    // MapTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * MapTransformer returns the result by looking up in the map.\n+     */\n+    private static class MapTransformer implements Transformer, Serializable {\n+        /** The map of data to lookup in */\n+        private final Map iMap;\n+\n+        /**\n+         * Constructor to store map.\n+         */\n+        private MapTransformer(Map map) {\n+            super();\n+            iMap = map;\n+        }\n+\n+        /**\n+         * Returns the result by looking up in the map.\n+         */\n+        public Object transform(Object input) {\n+            return iMap.get(input);\n+        }\n+    }\n+\n+    // InvokerTransformer\n+    //----------------------------------------------------------------------------------\n+\n+    /**\n+     * InvokerTransformer returns the result of invoking the specified method on \n+     * the input object.\n+     */\n+    private static class InvokerTransformer implements Transformer, Serializable {\n+        /** The method name to call */\n+        private final String iMethodName;\n+        /** The array of reflection parameter types */\n+        private final Class[] iParamTypes;\n+        /** The array of reflection arguments */\n+        private final Object[] iArgs;\n+\n+        /**\n+         * Constructor.\n+         */\n+        public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {\n+            super();\n+            if (methodName == null) {\n+                throw new IllegalArgumentException(\"InvokerTransformer: The method to invoke must not be null\");\n+            }\n+            if (((paramTypes == null) && (args != null))\n+                || ((paramTypes != null) && (args == null))\n+                || ((paramTypes != null) && (args != null) && (paramTypes.length != args.length))) {\n+                throw new IllegalArgumentException(\"InvokerTransformer: The parameter types must match the arguments\");\n+            }\n+\n+            iMethodName = methodName;\n+            if ((paramTypes == null) && (args == null)) {\n+                iParamTypes = null;\n+                iArgs = null;\n+            } else {\n+                iParamTypes = (Class[]) paramTypes.clone();\n+                iArgs = (Object[]) args.clone();\n+            }\n+        }\n+\n+        /**\n+         * Invoke the specified method on the input object.\n+         */\n+        public Object transform(Object input) {\n+            if (input == null) {\n+                return null;\n+            }\n+            try {\n+                Class cls = input.getClass();\n+                Method method = cls.getMethod(iMethodName, iParamTypes);\n+                return method.invoke(input, iArgs);\n+                \n+            } catch (NoSuchMethodException ex) {\n+                throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' does not exist\");\n+            } catch (IllegalAccessException ex) {\n+                throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\");\n+            } catch (InvocationTargetException ex) {\n+                throw new FunctorException(\"InvokerTransformer: The method '\" + iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", ex);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1053092470, "metainfo": ""}