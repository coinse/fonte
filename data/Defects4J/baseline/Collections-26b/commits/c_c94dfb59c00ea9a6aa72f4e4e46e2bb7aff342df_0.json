{"sha": "c94dfb59c00ea9a6aa72f4e4e46e2bb7aff342df", "log": "Cleanup bidimap package: package-info.java, version, author tags, javadoc.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractBidiMapDecorator.java\n  * But, you might want that loophole, so this class is kept simple.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision$\n- *\n- * @author Stephen Colebourne\n+ * @version $Id$\n  */\n-public abstract class AbstractBidiMapDecorator<K, V> extends AbstractMapDecorator<K, V> implements\n-        BidiMap<K, V> {\n+public abstract class AbstractBidiMapDecorator<K, V>\n+        extends AbstractMapDecorator<K, V> implements BidiMap<K, V> {\n \n     /**\n      * Constructor that wraps (not copies).\n         return decorated().mapIterator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K getKey(Object value) {\n         return decorated().getKey(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K removeValue(Object value) {\n         return decorated().removeValue(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public BidiMap<V, K> inverseBidiMap() {\n         return decorated().inverseBidiMap();\n     }\n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n import org.apache.commons.collections.keyvalue.AbstractMapEntryDecorator;\n \n /**\n- * Abstract <code>BidiMap</code> implemented using two maps.\n+ * Abstract {@link BidiMap} implemented using two maps.\n  * <p>\n  * An implementation can be written simply by implementing the\n- * <code>createMap</code> method.\n+ * {@link #createBidiMap(Map, Map, BidiMap)} method.\n  *\n  * @see DualHashBidiMap\n  * @see DualTreeBidiMap\n  * @since Commons Collections 3.0\n  * @version $Id$\n- *\n- * @author Matthew Hawthorne\n- * @author Stephen Colebourne\n  */\n public abstract class AbstractDualBidiMap<K, V> implements BidiMap<K, V> {\n \n \n     // Map delegation\n     //-----------------------------------------------------------------------\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n     public V get(Object key) {\n         return normalMap.get(key);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public int size() {\n         return normalMap.size();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean isEmpty() {\n         return normalMap.isEmpty();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean containsKey(Object key) {\n         return normalMap.containsKey(key);\n     }\n \n     // BidiMap changes\n     //-----------------------------------------------------------------------\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n     public V put(K key, V value) {\n         if (normalMap.containsKey(key)) {\n             reverseMap.remove(normalMap.get(key));\n         return obj;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void putAll(Map<? extends K, ? extends V> map) {\n         for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n             put(entry.getKey(), entry.getValue());\n         }\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public V remove(Object key) {\n         V value = null;\n         if (normalMap.containsKey(key)) {\n         return value;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public void clear() {\n         normalMap.clear();\n         reverseMap.clear();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public boolean containsValue(Object value) {\n         return reverseMap.containsKey(value);\n     }\n         return new BidiMapIterator<K, V>(this);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K getKey(Object value) {\n         return reverseMap.get(value);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K removeValue(Object value) {\n         K key = null;\n         if (reverseMap.containsKey(value)) {\n         return key;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public BidiMap<V, K> inverseBidiMap() {\n         if (inverseBidiMap == null) {\n             inverseBidiMap = createBidiMap(reverseMap, normalMap, this);\n             K key = MapEntry.this.getKey();\n             if (parent.reverseMap.containsKey(value) &&\n                 parent.reverseMap.get(value) != key) {\n-                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+                throw new IllegalArgumentException(\n+                        \"Cannot use setValue() when the object being set is already in the map\");\n             }\n             parent.put(key, value);\n             final V oldValue = super.setValue(value);\n             this.iterator = parent.normalMap.entrySet().iterator();\n         }\n \n+        /** {@inheritDoc} */\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        /** {@inheritDoc} */\n         public K next() {\n             last = iterator.next();\n             canRemove = true;\n             return last.getKey();\n         }\n \n+        /** {@inheritDoc} */\n         public void remove() {\n             if (canRemove == false) {\n                 throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n             canRemove = false;\n         }\n \n+        /** {@inheritDoc} */\n         public K getKey() {\n             if (last == null) {\n-                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(\n+                        \"Iterator getKey() can only be called after next() and before remove()\");\n             }\n             return last.getKey();\n         }\n \n+        /** {@inheritDoc} */\n         public V getValue() {\n             if (last == null) {\n-                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(\n+                        \"Iterator getValue() can only be called after next() and before remove()\");\n             }\n             return last.getValue();\n         }\n \n+        /** {@inheritDoc} */\n         public V setValue(V value) {\n             if (last == null) {\n-                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(\n+                        \"Iterator setValue() can only be called after next() and before remove()\");\n             }\n             if (parent.reverseMap.containsKey(value) &&\n                 parent.reverseMap.get(value) != last.getKey()) {\n-                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+                throw new IllegalArgumentException(\n+                        \"Cannot use setValue() when the object being set is already in the map\");\n             }\n             return parent.put(last.getKey(), value);\n         }\n \n+        /** {@inheritDoc} */\n         public void reset() {\n             iterator = parent.normalMap.entrySet().iterator();\n             last = null;\n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecorator.java\n  * But, you might want that loophole, so this class is kept simple.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision$\n- *\n- * @author Stephen Colebourne\n+ * @version $Id$\n  */\n public abstract class AbstractOrderedBidiMapDecorator<K, V>\n         extends AbstractBidiMapDecorator<K, V>\n         return decorated().mapIterator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K firstKey() {\n         return decorated().firstKey();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K lastKey() {\n         return decorated().lastKey();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K nextKey(K key) {\n         return decorated().nextKey(key);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K previousKey(K key) {\n         return decorated().previousKey(key);\n     }\n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapDecorator.java\n  * But, you might want that loophole, so this class is kept simple.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision$\n- *\n- * @author Stephen Colebourne\n+ * @version $Id$\n  */\n-public abstract class AbstractSortedBidiMapDecorator<K, V> extends\n-        AbstractOrderedBidiMapDecorator<K, V> implements SortedBidiMap<K, V> {\n+public abstract class AbstractSortedBidiMapDecorator<K, V>\n+        extends AbstractOrderedBidiMapDecorator<K, V> implements SortedBidiMap<K, V> {\n \n     /**\n      * Constructor that wraps (not copies).\n         return decorated().inverseBidiMap();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Comparator<? super K> comparator() {\n         return decorated().comparator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Comparator<? super V> valueComparator() {\n         return decorated().valueComparator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedMap<K, V> subMap(K fromKey, K toKey) {\n         return decorated().subMap(fromKey, toKey);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedMap<K, V> headMap(K toKey) {\n         return decorated().headMap(toKey);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedMap<K, V> tailMap(K fromKey) {\n         return decorated().tailMap(fromKey);\n     }\n--- a/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n import org.apache.commons.collections.BidiMap;\n \n /**\n- * Implementation of <code>BidiMap</code> that uses two <code>HashMap</code> instances.\n+ * Implementation of {@link BidiMap} that uses two {@link HashMap} instances.\n  * <p>\n- * Two <code>HashMap</code> instances are used in this class.\n+ * Two {@link HashMap} instances are used in this class.\n  * This provides fast lookups at the expense of storing two sets of map entries.\n  * Commons Collections would welcome the addition of a direct hash-based\n- * implementation of the <code>BidiMap</code> interface.\n+ * implementation of the {@link BidiMap} interface.\n  * <p>\n- * NOTE: From Commons Collections 3.1, all subclasses will use <code>HashMap</code>\n+ * NOTE: From Commons Collections 3.1, all subclasses will use {@link HashMap}\n  * and the flawed <code>createMap</code> method is ignored.\n  *\n  * @since Commons Collections 3.0\n  * @version $Id$\n- *\n- * @author Matthew Hawthorne\n- * @author Stephen Colebourne\n  */\n public class DualHashBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements Serializable {\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n import org.apache.commons.collections.map.AbstractSortedMapDecorator;\n \n /**\n- * Implementation of <code>BidiMap</code> that uses two <code>TreeMap</code> instances.\n+ * Implementation of {@link BidiMap} that uses two {@link TreeMap} instances.\n  * <p>\n  * The setValue() method on iterators will succeed only if the new value being set is\n  * not already in the bidimap.\n  * also be considered. It implements the interface using a dedicated design, and does\n  * not store each object twice, which can save on memory use.\n  * <p>\n- * NOTE: From Commons Collections 3.1, all subclasses will use <code>TreeMap</code>\n+ * NOTE: From Commons Collections 3.1, all subclasses will use {@link TreeMap}\n  * and the flawed <code>createMap</code> method is ignored.\n  *\n  * @since Commons Collections 3.0\n  * @version $Id$\n- *\n- * @author Matthew Hawthorne\n- * @author Stephen Colebourne\n  */\n-public class DualTreeBidiMap<K, V> extends AbstractDualBidiMap<K, V> implements\n-        SortedBidiMap<K, V>, Serializable {\n+public class DualTreeBidiMap<K, V> extends AbstractDualBidiMap<K, V>\n+        implements SortedBidiMap<K, V>, Serializable {\n \n     /** Ensure serialization compatibility */\n     private static final long serialVersionUID = 721969328361809L;\n     }\n \n     /**\n-     * Constructs a <code>DualTreeBidiMap</code> using the specified Comparator.\n+     * Constructs a {@link DualTreeBidiMap} using the specified {@link Comparator}.\n      *\n-     * @param keyComparator  the Comparator\n+     * @param keyComparator  the comparator\n+     * @param valueComparator  the values comparator to use\n      */\n     public DualTreeBidiMap(Comparator<? super K> keyComparator, Comparator<? super V> valueComparator) {\n         super(new TreeMap<K, V>(keyComparator), new TreeMap<V, K>(valueComparator));\n     }\n \n     /**\n-     * Constructs a <code>DualTreeBidiMap</code> that decorates the specified maps.\n+     * Constructs a {@link DualTreeBidiMap} that decorates the specified maps.\n      *\n      * @param normalMap  the normal direction map\n      * @param reverseMap  the reverse direction map\n     }\n \n     //-----------------------------------------------------------------------\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Comparator<? super K> comparator() {\n         return ((SortedMap<K, V>) normalMap).comparator();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public Comparator<? super V> valueComparator() {\n         return ((SortedMap<V, K>) reverseMap).comparator();\n         \n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K firstKey() {\n         return ((SortedMap<K, V>) normalMap).firstKey();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K lastKey() {\n         return ((SortedMap<K, V>) normalMap).lastKey();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K nextKey(K key) {\n         if (isEmpty()) {\n             return null;\n         return null;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public K previousKey(K key) {\n         if (isEmpty()) {\n             return null;\n         return new BidiOrderedMapIterator<K, V>(this);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedBidiMap<V, K> inverseSortedBidiMap() {\n         return inverseBidiMap();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public OrderedBidiMap<V, K> inverseOrderedBidiMap() {\n         return inverseBidiMap();\n     }\n \n     //-----------------------------------------------------------------------\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedMap<K, V> headMap(K toKey) {\n         SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).headMap(toKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedMap<K, V> tailMap(K fromKey) {\n         SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).tailMap(fromKey);\n         return new ViewMap<K, V>(this, sub);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     public SortedMap<K, V> subMap(K fromKey, K toKey) {\n         SortedMap<K, V> sub = ((SortedMap<K, V>) normalMap).subMap(fromKey, toKey);\n         return new ViewMap<K, V>(this, sub);\n             iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n         }\n \n+        /** {@inheritDoc} */\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        /** {@inheritDoc} */\n         public K next() {\n             last = iterator.next();\n             return last.getKey();\n         }\n \n+        /** {@inheritDoc} */\n         public boolean hasPrevious() {\n             return iterator.hasPrevious();\n         }\n \n+        /** {@inheritDoc} */\n         public K previous() {\n             last = iterator.previous();\n             return last.getKey();\n         }\n \n+        /** {@inheritDoc} */\n         public void remove() {\n             iterator.remove();\n             parent.remove(last.getKey());\n             last = null;\n         }\n \n+        /** {@inheritDoc} */\n         public K getKey() {\n             if (last == null) {\n-                throw new IllegalStateException(\"Iterator getKey() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(\n+                        \"Iterator getKey() can only be called after next() and before remove()\");\n             }\n             return last.getKey();\n         }\n \n+        /** {@inheritDoc} */\n         public V getValue() {\n             if (last == null) {\n-                throw new IllegalStateException(\"Iterator getValue() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(\n+                        \"Iterator getValue() can only be called after next() and before remove()\");\n             }\n             return last.getValue();\n         }\n \n+        /** {@inheritDoc} */\n         public V setValue(V value) {\n             if (last == null) {\n-                throw new IllegalStateException(\"Iterator setValue() can only be called after next() and before remove()\");\n+                throw new IllegalStateException(\n+                        \"Iterator setValue() can only be called after next() and before remove()\");\n             }\n             if (parent.reverseMap.containsKey(value) &&\n                 parent.reverseMap.get(value) != last.getKey()) {\n-                throw new IllegalArgumentException(\"Cannot use setValue() when the object being set is already in the map\");\n+                throw new IllegalArgumentException(\n+                        \"Cannot use setValue() when the object being set is already in the map\");\n             }\n             return parent.put(last.getKey(), value);\n         }\n \n+        /** {@inheritDoc} */\n         public void reset() {\n             iterator = new ArrayList<Map.Entry<K, V>>(parent.entrySet()).listIterator();\n             last = null;\n--- a/src/main/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/TreeBidiMap.java\n import org.apache.commons.collections.OrderedMapIterator;\n import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n import org.apache.commons.collections.keyvalue.UnmodifiableMapEntry;\n-import static org.apache.commons.collections.bidimap.TreeBidiMap.DataElement.*;\n+\n+import static org.apache.commons.collections.bidimap.TreeBidiMap.DataElement.KEY;\n+import static org.apache.commons.collections.bidimap.TreeBidiMap.DataElement.VALUE;\n \n /**\n  * Red-Black tree-based implementation of BidiMap where all objects added\n  * {@link DualHashBidiMap} implementations use this approach.\n  * <p>\n  * This solution keeps minimizes the data storage by holding data only once.\n- * The red-black algorithm is based on java util TreeMap, but has been modified\n+ * The red-black algorithm is based on {@link java.util.TreeMap}, but has been modified\n  * to simultaneously map a tree node by key and by value. This doubles the\n  * cost of put operations (but so does using two TreeMaps), and nearly doubles\n  * the cost of remove operations (there is a savings in that the lookup of the\n  * UnsupportedOperationException on attempts to call that method.\n  *\n  * @since Commons Collections 3.0 (previously DoubleOrderedMap v2.0)\n- * @version $Revision$\n- *\n- * @author Marc Johnson\n- * @author Stephen Colebourne\n- * @author Matt Benson\n+ * @version $Id$\n  */\n public class TreeBidiMap<K extends Comparable<K>, V extends Comparable<V>> implements OrderedBidiMap<K, V> {\n \n \n         /**\n          * Create a new TreeBidiMap.DataElement.\n+         * \n+         * @param description  the description for the element\n          */\n         private DataElement(String description) {\n             this.description = description;\n--- a/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMap.java\n import org.apache.commons.collections.set.UnmodifiableSet;\n \n /**\n- * Decorates another <code>BidiMap</code> to ensure it can't be altered.\n+ * Decorates another {@link BidiMap} to ensure it can't be altered.\n  * <p>\n  * Attempts to modify it will result in an UnsupportedOperationException. \n  *\n  * @since Commons Collections 3.0\n- * @version $Revision$\n- *\n- * @author Stephen Colebourne\n+ * @version $Id$\n  */\n public final class UnmodifiableBidiMap<K, V>\n         extends AbstractBidiMapDecorator<K, V> implements Unmodifiable {\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n      *\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable BidiMap\n      * @throws IllegalArgumentException if map is null\n--- a/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMap.java\n import org.apache.commons.collections.set.UnmodifiableSet;\n \n /**\n- * Decorates another <code>OrderedBidiMap</code> to ensure it can't be altered.\n+ * Decorates another {@link OrderedBidiMap} to ensure it can't be altered.\n  * <p>\n  * Attempts to modify it will result in an UnsupportedOperationException. \n  *\n  * @since Commons Collections 3.0\n- * @version $Revision$\n- *\n- * @author Stephen Colebourne\n+ * @version $Id$\n  */\n public final class UnmodifiableOrderedBidiMap<K, V>\n         extends AbstractOrderedBidiMapDecorator<K, V> implements Unmodifiable {\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n      *\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable OrderedBidiMap\n      * @throws IllegalArgumentException if map is null\n--- a/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMap.java\n import org.apache.commons.collections.set.UnmodifiableSet;\n \n /**\n- * Decorates another <code>SortedBidiMap</code> to ensure it can't be altered.\n+ * Decorates another {@link SortedBidiMap} to ensure it can't be altered.\n  * <p>\n- * Attempts to modify it will result in an UnsupportedOperationException. \n+ * Attempts to modify it will result in an {@link UnsupportedOperationException}. \n  *\n  * @since Commons Collections 3.0\n- * @version $Revision$\n- *\n- * @author Stephen Colebourne\n+ * @version $Id$\n  */\n public final class UnmodifiableSortedBidiMap<K, V>\n         extends AbstractSortedBidiMapDecorator<K, V> implements Unmodifiable {\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n      *\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable SortedBidiMap\n      * @throws IllegalArgumentException if map is null\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/bidimap/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link org.apache.commons.collections.BidiMap BidiMap},\n+ * {@link org.apache.commons.collections.OrderedBidiMap OrderedBidiMap} and \n+ * {@link org.apache.commons.collections.SortedBidiMap SortedBidiMap} interfaces.\n+ * A BidiMap is an extension to Map that allows keys and values to be looked up with equal ease.\n+ * One example usage is a system communicating to a legacy datasource that must convert codes\n+ * from the new format to the old format and vice versa.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>DualHashBidiMap - uses two HashMaps to implement BidiMap\n+ *   <li>DualTreeBidiMap - uses two TreeMaps to implement SortedBidiMap\n+ *   <li>TreeBidiMap - red-black tree implementation of OrderedBidiMap\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Unmodifiable - ensures the map cannot be altered\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections.bidimap;", "timestamp": 1340659137, "metainfo": ""}