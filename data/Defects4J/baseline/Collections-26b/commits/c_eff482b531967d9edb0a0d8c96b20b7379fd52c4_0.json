{"sha": "eff482b531967d9edb0a0d8c96b20b7379fd52c4", "log": "Add initial version of TreeList   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/list/TreeList.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.AbstractList;\n+import java.util.Collection;\n+\n+/**\n+ * A <code>List</code> implementation that is optimised for fast insertions and\n+ * removals at any index in the list.\n+ * <p>\n+ * This list implementation utilises a tree structure internally to ensure that\n+ * all insertions and removals are O(log n). This provides much faster performance\n+ * than both an <code>ArrayList</code> and a <code>LinkedList</code> where elements\n+ * are inserted and removed repeatedly from anywhere in the list.\n+ * <p>\n+ * The trade-off versus <code>ArrayList</code> is memory usage. <code>TreeList</code>\n+ * stores each entry in an object which uses up more memory. Also, <code>ArrayList</code>\n+ * is faster if additions and removals only occur at the end of the list, not in the middle.\n+ * <p>\n+ * The trade-off versus <code>LinkedList</code> is based on how you use the list.\n+ * If additions and removals only occur at the start or end of the list, not in the\n+ * middle then <code>LinkedList</code> is faster.\n+ * <p>\n+ * The following performance statistics are indicative of this class:\n+ * <pre>\n+ *           add   insert      get\n+ * TreeList  300      501      110\n+ * ArrayList  70    20390       20\n+ * LinkedList 50   226636   279742\n+ * </pre>\n+ * \n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/05/10 19:59:03 $\n+ *\n+ * @author Joerg Schmuecker\n+ * @author Stephen Colebourne\n+ */\n+public class TreeList extends AbstractList {\n+//    Add; insert; get\n+//    tree   = 980;170;50;\n+//    array  = 280;6920;0;\n+//    linked = 380;55480;55800;\n+\n+    /** The root node in the AVL tree */\n+    private AVLNode root;\n+\n+    /** The current size of the list */\n+    private int size;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty list.\n+     */\n+    public TreeList() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty list that copies the specified list.\n+     * \n+     * @param coll  the collection to copy\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public TreeList(Collection coll) {\n+        super();\n+        addAll(coll);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the element at the specified index.\n+     * \n+     * @param index  the index to retrieve\n+     * @return the element at the specified index\n+     */\n+    public Object get(int index) {\n+        checkInterval(index, 0, size() - 1);\n+        return root.get(index).getValue();\n+    }\n+\n+    /**\n+     * Gets the current size of the list.\n+     * \n+     * @return the current size\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Gets an iterator over the list.\n+     * \n+     * @return an iterator over the list\n+     */\n+//    public Iterator iterator() {\n+//        // override to go 65% faster\n+//        if (size() == 0) {\n+//            return IteratorUtils.EMPTY_ITERATOR;\n+//        }\n+//        return new TreeIterator(this);\n+//    }\n+\n+    /**\n+     * Searches for the index of an object in the list.\n+     * \n+     * @return the index of the object, -1 if not found\n+     */\n+    public int indexOf(Object object) {\n+        // override to go 75% faster\n+        if (root == null) {\n+            return -1;\n+        }\n+        return root.indexOf(object, root.relativePosition);\n+    }\n+\n+    /**\n+     * Searches for the presence of an object in the list.\n+     * \n+     * @return true if the object is found\n+     */\n+    public boolean contains(Object object) {\n+        return (indexOf(object) >= 0);\n+    }\n+\n+    /**\n+     * Converts the list into an array.\n+     * \n+     * @return the list as an array\n+     */\n+    public Object[] toArray() {\n+        // override to go 40% faster\n+        Object[] array = new Object[size()];\n+        if (root != null) {\n+            root.toArray(array, root.relativePosition);\n+        }\n+        return array;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new element to the list.\n+     * \n+     * @param index  the index to add before\n+     * @param obj  the element to add\n+     */\n+    public void add(int index, Object obj) {\n+        checkInterval(index, 0, size());\n+        if (root == null) {\n+            root = new AVLNode(index, obj);\n+        } else {\n+            root = root.insert(index, obj);\n+        }\n+        size++;\n+    }\n+\n+    /**\n+     * Sets the element at the specified index.\n+     * \n+     * @param index  the index to set\n+     * @param obj  the object to store at the specified index\n+     * @return the previous object at that index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    public Object set(int index, Object obj) {\n+        checkInterval(index, 0, size() - 1);\n+        AVLNode node = root.get(index);\n+        Object result = node.value;\n+        node.setValue(obj);\n+        return result;\n+    }\n+\n+    /**\n+     * Removes the element at the specified index.\n+     * \n+     * @param index  the index to remove\n+     * @return the previous object at that index\n+     */\n+    public Object remove(int index) {\n+        checkInterval(index, 0, size() - 1);\n+        Object result = get(index);\n+        root = root.remove(index);\n+        size--;\n+        return result;\n+    }\n+\n+    /**\n+     * Clears the list, removing all entries.\n+     */\n+    public void clear() {\n+        root = null;\n+        size = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the index is valid.\n+     * \n+     * @param index  the index to check\n+     * @param startIndex  the first allowed index\n+     * @param endIndex  the last allowed index\n+     * @throws IndexOutOfBoundsException if the index is invalid\n+     */\n+    private void checkInterval(int index, int startIndex, int endIndex) {\n+        if (index < startIndex || index > endIndex) {\n+            throw new IndexOutOfBoundsException(\"Invalid index:\" + index + \", size=\" + size());\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Implements an AVLNode which keeps the offset updated.\n+     * <p>\n+     * This node contains the real work.\n+     * TreeList is just there to implement {@link java.util.List}.\n+     */\n+    static class AVLNode {\n+        /** The left child node */\n+        private AVLNode left;\n+        /** The right child node */\n+        private AVLNode right;\n+        /** How many levels of left/right are below this one */\n+        private int height;\n+        /** The relative position, root holds absolute position */\n+        private int relativePosition;\n+        /** The stored element */\n+        private Object value;\n+\n+        /**\n+         * Constructs a new node with a relative position.\n+         * \n+         * @param relativePosition  the relative position of the node\n+         * @param obj  the element\n+         */\n+        public AVLNode(int relativePosition, Object obj) {\n+            super();\n+            this.relativePosition = relativePosition;\n+            this.value = obj;\n+        }\n+\n+        /**\n+         * Gets the value.\n+         * \n+         * @return the value of this node\n+         */\n+        Object getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Sets the value.\n+         * \n+         * @param obj  the value to store\n+         */\n+        void setValue(Object obj) {\n+            this.value = obj;\n+        }\n+\n+        /**\n+         * Locate the element with the given index relative to the\n+         * offset of the parent of this node.\n+         */\n+        AVLNode get(int index) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return this;\n+            }\n+\n+            AVLNode nextNode = ((indexRelativeToMe < 0) ? left : right);\n+            if (nextNode == null) {\n+                int i = 1;\n+            }\n+            return nextNode.get(indexRelativeToMe);\n+        }\n+\n+        /**\n+         * Locate the index that contains the specified object.\n+         */\n+        int indexOf(Object object, int index) {\n+            if (left != null) {\n+                int result = left.indexOf(object, index + left.relativePosition);\n+                if (result != -1) {\n+                    return result;\n+                }\n+            }\n+            if (value == null ? value == object : value.equals(object)) {\n+                return index;\n+            }\n+            if (right != null) {\n+                return right.indexOf(object, index + right.relativePosition);\n+            }\n+            return -1;\n+        }\n+\n+        /**\n+         * Stores the node and its children into the array specified.\n+         */\n+        void toArray(Object[] array, int index) {\n+            array[index] = value;\n+            if (left != null) {\n+                left.toArray(array, index + left.relativePosition);\n+            }\n+            if (right != null) {\n+                right.toArray(array, index + right.relativePosition);\n+            }\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Balances according to the AVL algorithm.\n+         */\n+        private AVLNode balance() {\n+            switch (heightRightMinusLeft()) {\n+                case 1 :\n+                case 0 :\n+                case -1 :\n+                    return this;\n+                case -2 :\n+                    if (left.heightRightMinusLeft() > 0) {\n+                        setLeft(left.rotateLeft());\n+                    }\n+                    return rotateRight();\n+                case 2 :\n+                    if (right.heightRightMinusLeft() < 0) {\n+                        setRight(right.rotateRight());\n+                    }\n+                    return rotateLeft();\n+                default :\n+                    throw new RuntimeException(\"tree inconsistent!\");\n+            }\n+        }\n+\n+        /**\n+         * Returns the height of the node or -1 if the node is null.\n+         * \n+         * Convenience method.\n+         */\n+        private int getHeight(AVLNode n) {\n+            return (n == null ? -1 : n.height);\n+        }\n+\n+        /**\n+         * Returns the height difference\n+         */\n+        private int heightRightMinusLeft() {\n+            return getHeight(right) - getHeight(left);\n+        }\n+\n+        /**\n+         * Inserts a node at the position index.\n+         * \n+         * @param index  is the index of the position relative to the position of \n+         *  the parent node.\n+         * @param obj  is the object to be stored in the position.\n+         */\n+        AVLNode insert(int index, Object obj) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe <= 0) {\n+                return insertOnLeft(indexRelativeToMe, obj);\n+            } else {\n+                return insertOnRight(indexRelativeToMe, obj);\n+            }\n+        }\n+\n+        private AVLNode insertOnLeft(int indexRelativeToMe, Object obj) {\n+            AVLNode ret = this;\n+\n+            if (left == null) {\n+                left = new AVLNode(-1, obj);\n+            } else {\n+                left = left.insert(indexRelativeToMe, obj);\n+\n+            }\n+            if (relativePosition >= 0) {\n+                relativePosition++;\n+            }\n+            ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        private AVLNode insertOnRight(int indexRelativeToMe, Object obj) {\n+            AVLNode ret = this;\n+\n+            if (right == null) {\n+                right = new AVLNode(+1, obj);\n+            } else {\n+                right = right.insert(indexRelativeToMe, obj);\n+\n+            }\n+            if (relativePosition < 0) {\n+                relativePosition--;\n+            }\n+            ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        private void recalcHeight() {\n+            height = Math.max(left == null ? -1 : left.height, right == null ? -1 : right.height) + 1;\n+        }\n+\n+        private AVLNode rotateLeft() {\n+            AVLNode newTop = right;\n+            AVLNode movedNode = right.left;\n+\n+            int newTopPosition = relativePosition + getOffset(right);\n+            int myNewPosition = -right.relativePosition;\n+            int movedPosition = getOffset(right) + getOffset(movedNode);\n+\n+            setRight(right.left);\n+            newTop.setLeft(this);\n+\n+            setOffset(newTop, newTopPosition);\n+            setOffset(this, myNewPosition);\n+            setOffset(movedNode, movedPosition);\n+            return newTop;\n+        }\n+\n+        private int getOffset(AVLNode node) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            return node.relativePosition;\n+        }\n+\n+        private AVLNode rotateRight() {\n+            AVLNode newTop = left;\n+            AVLNode movedNode = left.right;\n+\n+            int newTopPosition = relativePosition + getOffset(left);\n+            int myNewPosition = -left.relativePosition;\n+            int movedPosition = getOffset(left) + getOffset(movedNode);\n+\n+            setLeft(left.right);\n+            newTop.setRight(this);\n+\n+            setOffset(newTop, newTopPosition);\n+            setOffset(this, myNewPosition);\n+            setOffset(movedNode, movedPosition);\n+            return newTop;\n+\n+        }\n+\n+        private void setLeft(AVLNode node) {\n+            left = node;\n+            recalcHeight();\n+        }\n+\n+        private int setOffset(AVLNode node, int newOffest) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            int oldOffset = getOffset(node);\n+            node.relativePosition = newOffest;\n+            return oldOffset;\n+        }\n+\n+        private void setRight(AVLNode node) {\n+            right = node;\n+            recalcHeight();\n+        }\n+\n+        /**\n+         * Removes the node at a given position.\n+         * \n+         * @param index  is the index of the element to be removed relative to\n+         *  the position of the parent node of the current node.\n+         * @return the new root of the tree\n+         */\n+        AVLNode remove(int index) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return removeSelf();\n+            }\n+            if (indexRelativeToMe > 0) {\n+                right = right.remove(indexRelativeToMe);\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                left = left.remove(indexRelativeToMe);\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode removeSelf() {\n+            if (right == null && left == null)\n+                return null;\n+            if (right == null) {\n+                if (relativePosition > 0) {\n+                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n+                }\n+                return left;\n+            }\n+            if (left == null) {\n+                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n+                return right;\n+            }\n+\n+            if (heightRightMinusLeft() > 0) {\n+                value = right.min().value;\n+                right = right.removeMin();\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                value = left.max().value;\n+                left = left.removeMax();\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return this;\n+        }\n+\n+        private AVLNode removeMin() {\n+            if (left == null) {\n+                return removeSelf();\n+            }\n+            left = left.removeMin();\n+            adjustOffsetForRemovalLeft();\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private void adjustOffsetForRemovalLeft() {\n+            if (relativePosition > 0) {\n+                relativePosition--;\n+            }\n+        }\n+\n+        private void adjustOffsetForRemovalRight() {\n+            if (relativePosition < 0) {\n+                relativePosition++;\n+            }\n+        }\n+\n+        private AVLNode min() {\n+            return (left == null) ? this : left.min();\n+        }\n+\n+        private AVLNode removeMax() {\n+            if (right == null) {\n+                return removeSelf();\n+            }\n+            right = right.removeMax();\n+            adjustOffsetForRemovalRight();\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode max() {\n+            return (right == null) ? this : right.max();\n+        }\n+\n+        /**\n+         * Used for debugging.\n+         */\n+        public String toString() {\n+            return \"AVLNode(\" + relativePosition + \",\" + (left != null) + \",\" + value + \",\" + (right != null) + \")\";\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Iterator over the TreeList.\n+//     * <p>\n+//     * This iterator is good at iteration, but bad at removal.\n+//     * Implementing ListIterator would be even more complex, so has been avoided.\n+//     */\n+//    static class TreeIterator implements Iterator {\n+//        /** The parent list */\n+//        private final TreeList parent;\n+//        /** A stack built up during iteration to avoid each node referencing its parent */\n+//        private ArrayStack stack = new ArrayStack();\n+//        /** Whether remove is currently allowed */\n+//        private boolean canRemoveOrSet;\n+//        /** The last node returned */\n+//        private AVLNode lastNode;\n+//        /** The next index */\n+//        private int nextIndex;\n+//        \n+//        /**\n+//         * Constructor.\n+//         * \n+//         * @param parent  the parent list\n+//         */\n+//        TreeIterator(TreeList parent) {\n+//            this.parent = parent;\n+//        }\n+//\n+//        private AVLNode findNext() {\n+//            AVLNode node = lastNode;\n+//            if (node == null) {\n+//                node = parent.root;\n+//                while (node.left != null) {\n+//                    stack.add(node);\n+//                    node = node.left;\n+//                }\n+//                return node;\n+//            }\n+//            if (node.right != null) {\n+//                node = node.right;\n+//                while (node.left != null) {\n+//                    stack.add(node);\n+//                    node = node.left;\n+//                }\n+//                return node;\n+//            }\n+//            if (stack.isEmpty()) {\n+//                throw new NoSuchElementException();\n+//            }\n+//            return (AVLNode) stack.pop();\n+//        }\n+//\n+//        public boolean hasNext() {\n+//            return (nextIndex < parent.size());\n+//        }\n+//\n+//        public Object next() {\n+//            if (hasNext() == false) {\n+//                throw new NoSuchElementException();\n+//            }\n+//            lastNode = findNext();\n+//            nextIndex++;\n+//            canRemoveOrSet = true;\n+//            return lastNode.getValue();\n+//        }\n+//\n+//        public int nextIndex() {\n+//            return nextIndex;\n+//        }\n+//\n+////        public boolean hasPrevious() {\n+////            return (nextIndex > 0);\n+////        }\n+////\n+////        public Object previous() {\n+////            if (hasPrevious() == false) {\n+////                throw new NoSuchElementException();\n+////            }\n+////            return parent.get(nextIndex--);\n+////        }\n+////\n+////        public int previousIndex() {\n+////            return nextIndex() - 1;\n+////        }\n+//\n+//        public void remove() {\n+//            if (canRemoveOrSet == false) {\n+//                throw new IllegalStateException();\n+//            }\n+//            if (nextIndex == 1) {\n+//                parent.remove(--nextIndex);\n+//                this.lastNode = null;\n+//                this.stack.clear();\n+//            } else if (hasNext()) {\n+//                AVLNode nextNode = findNext();\n+//                parent.remove(--nextIndex);\n+//                TreeIterator it = new TreeIterator(parent);\n+//                AVLNode node = null;\n+//                while (it.hasNext()) {\n+//                    it.next();\n+//                    if (it.lastNode == nextNode) {\n+//                        this.stack = it.stack;\n+//                        break;\n+//                    }\n+//                    node = it.lastNode;\n+//                }\n+//                this.lastNode = node;\n+//            } else {\n+//                parent.remove(--nextIndex);\n+//                this.lastNode = parent.root.get(parent.size() - 1);\n+//                this.stack.clear();\n+//            }\n+//            canRemoveOrSet = false;\n+//        }\n+//\n+////        public void set(Object obj) {\n+////            if (canRemoveOrSet == false) {\n+////                throw new IllegalStateException();\n+////            }\n+////            lastNode.setValue(obj);\n+////        }\n+////\n+////        public void add(Object obj) {\n+////        }\n+//    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/list/TestAll.java\n+++ b/src/test/org/apache/commons/collections/list/TestAll.java\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.5 $ $Date: 2004/02/18 01:20:34 $\n+ * @version $Revision: 1.6 $ $Date: 2004/05/10 19:59:03 $\n  * \n  * @author Stephen Colebourne\n  */\n         \n         suite.addTest(TestCursorableLinkedList.suite());\n         suite.addTest(TestNodeCachingLinkedList.suite());\n+        suite.addTest(TestTreeList.suite());\n         \n         suite.addTest(TestFixedSizeList.suite());\n         suite.addTest(TestPredicatedList.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/list/TestTreeList.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests\n+ * \n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/05/10 19:59:03 $\n+ *\n+ * @author Joerg Schmuecker\n+ */\n+public class TestTreeList extends AbstractTestList {\n+    \n+\tpublic TestTreeList(String name) {\n+\t\tsuper(name);\n+\t}\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+//        System.out.println(\"              add; insert; get; indexOf; remove\");\n+//        System.out.print(\"   TreeList = \");\n+//        benchmark(new TreeList());\n+//        System.out.print(\"\\n  ArrayList = \");\n+//        benchmark(new java.util.ArrayList());\n+//        System.out.print(\"\\n LinkedList = \");\n+//        benchmark(new NodeCachingLinkedList());\n+\n+//        benchmark(new java.util.LinkedList());\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTreeList.class);\n+    }\n+\n+    public static void benchmark(List l) {\n+        StringBuffer sb = new StringBuffer();\n+        long start = System.currentTimeMillis();\n+        for (int i = 0; i < 100000; i++) {\n+            l.add(new Integer(i));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+        \n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 200; i++) {\n+            l.toArray();\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+        \n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 100; i++) {\n+            java.util.Iterator it = l.iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+            }\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+        \n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            int j = (int) (Math.random() * 100000);\n+            l.add(j, new Integer(-j));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+        \n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            int j = (int) (Math.random() * 110000);\n+            l.get(j);\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+        \n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 200; i++) {\n+            int j = (int) (Math.random() * 100000);\n+            l.indexOf(new Integer(j));\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+        \n+        start = System.currentTimeMillis();\n+        for (int i = 0; i < 10000; i++) {\n+            int j = (int) (Math.random() * 100000);\n+            l.remove(j);\n+        }\n+        System.out.print(System.currentTimeMillis() - start + \";\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\tpublic List makeEmptyList() {\n+\t\treturn new TreeList();\n+\t}\n+\n+    //-----------------------------------------------------------------------\n+\tpublic void testAddMultiple() {\n+\t\tList l = makeEmptyList();\n+\t\tl.add(\"hugo\");\n+\t\tl.add(\"erna\");\n+\t\tl.add(\"daniel\");\n+\t\tl.add(\"andres\");\n+\t\tl.add(\"harald\");\n+\t\tl.add(0, null);\n+\t\tassertEquals(null, l.get(0));\n+\t\tassertEquals(\"hugo\", l.get(1));\n+\t\tassertEquals(\"erna\", l.get(2));\n+\t\tassertEquals(\"daniel\", l.get(3));\n+\t\tassertEquals(\"andres\", l.get(4));\n+\t\tassertEquals(\"harald\", l.get(5));\n+\t}\n+\n+\tpublic void testRemove() {\n+\t\tList l = makeEmptyList();\n+\t\tl.add(\"hugo\");\n+\t\tl.add(\"erna\");\n+\t\tl.add(\"daniel\");\n+\t\tl.add(\"andres\");\n+\t\tl.add(\"harald\");\n+\t\tl.add(0, null);\n+\t\tint i = 0;\n+\t\tassertEquals(null, l.get(i++));\n+\t\tassertEquals(\"hugo\", l.get(i++));\n+\t\tassertEquals(\"erna\", l.get(i++));\n+\t\tassertEquals(\"daniel\", l.get(i++));\n+\t\tassertEquals(\"andres\", l.get(i++));\n+\t\tassertEquals(\"harald\", l.get(i++));\n+\n+\t\tl.remove(0);\n+\t\ti = 0;\n+\t\tassertEquals(\"hugo\", l.get(i++));\n+\t\tassertEquals(\"erna\", l.get(i++));\n+\t\tassertEquals(\"daniel\", l.get(i++));\n+\t\tassertEquals(\"andres\", l.get(i++));\n+\t\tassertEquals(\"harald\", l.get(i++));\n+\n+\t\ti = 0;\n+\t\tl.remove(1);\n+\t\tassertEquals(\"hugo\", l.get(i++));\n+\t\tassertEquals(\"daniel\", l.get(i++));\n+\t\tassertEquals(\"andres\", l.get(i++));\n+\t\tassertEquals(\"harald\", l.get(i++));\n+\n+\t\ti = 0;\n+\t\tl.remove(2);\n+\t\tassertEquals(\"hugo\", l.get(i++));\n+\t\tassertEquals(\"daniel\", l.get(i++));\n+\t\tassertEquals(\"harald\", l.get(i++));\n+\t}\n+\n+\tpublic void testInsertBefore() {\n+\t\tList l = makeEmptyList();\n+\t\tl.add(\"erna\");\n+\t\tl.add(0, \"hugo\");\n+\t\tassertEquals(\"hugo\", l.get(0));\n+\t\tassertEquals(\"erna\", l.get(1));\n+\t}\n+\n+    public void testIndexOf() {\n+        List l = makeEmptyList();\n+        l.add(\"0\");\n+        l.add(\"1\");\n+        l.add(\"2\");\n+        l.add(\"3\");\n+        l.add(\"4\");\n+        l.add(\"5\");\n+        l.add(\"6\");\n+        assertEquals(0, l.indexOf(\"0\"));\n+        assertEquals(1, l.indexOf(\"1\"));\n+        assertEquals(2, l.indexOf(\"2\"));\n+        assertEquals(3, l.indexOf(\"3\"));\n+        assertEquals(4, l.indexOf(\"4\"));\n+        assertEquals(5, l.indexOf(\"5\"));\n+        assertEquals(6, l.indexOf(\"6\"));\n+        \n+        l.set(1, \"0\");\n+        assertEquals(0, l.indexOf(\"0\"));\n+        \n+        l.set(3, \"3\");\n+        assertEquals(3, l.indexOf(\"3\"));\n+        l.set(2, \"3\");\n+        assertEquals(2, l.indexOf(\"3\"));\n+        l.set(1, \"3\");\n+        assertEquals(1, l.indexOf(\"3\"));\n+        l.set(0, \"3\");\n+        assertEquals(0, l.indexOf(\"3\"));\n+    }\n+\n+//    public void testCheck() {\n+//        List l = makeEmptyList();\n+//        l.add(\"A1\");\n+//        l.add(\"A2\");\n+//        l.add(\"A3\");\n+//        l.add(\"A4\");\n+//        l.add(\"A5\");\n+//        l.add(\"A6\");\n+//    }\n+}", "timestamp": 1084219143, "metainfo": ""}