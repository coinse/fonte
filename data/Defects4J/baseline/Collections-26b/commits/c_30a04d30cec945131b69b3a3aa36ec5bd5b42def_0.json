{"sha": "30a04d30cec945131b69b3a3aa36ec5bd5b42def", "log": "Add TreeBidiMap implementation   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/TreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/TreeBidiMap.java,v 1.1 2003/11/08 18:52:51 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.iterators.OrderedMapIterator;\n+import org.apache.commons.collections.pairs.UnmodifiableMapEntry;\n+\n+/**\n+ * Red-Black tree-based implementation of BidiMap.\n+ * <p>\n+ * This class guarantees that the map will be in both ascending key order\n+ * and ascending value order, sorted according to the natural order for\n+ * the key's and value's classes.\n+ * <p>\n+ * This Map is intended for applications that need to be able to look\n+ * up a key-value pairing by either key or value, and need to do so\n+ * with equal efficiency.\n+ * <p>\n+ * While that goal could be accomplished by taking a pair of TreeMaps\n+ * and redirecting requests to the appropriate TreeMap (e.g.,\n+ * containsKey would be directed to the TreeMap that maps values to\n+ * keys, containsValue would be directed to the TreeMap that maps keys\n+ * to values), there are problems with that implementation,\n+ * particularly when trying to keep the two TreeMaps synchronized with\n+ * each other. And if the data contained in the TreeMaps is large, the\n+ * cost of redundant storage becomes significant. (See also the\n+ * {@link org.apache.commons.collections.DualTreeBidiMap DualTreeBidiMap} and\n+ * {@link org.apache.commons.collections.DualHashBidiMap DualHashBidiMap}\n+ * implementations.)\n+ * <p>\n+ * This solution keeps the data properly synchronized and minimizes\n+ * the data storage. The red-black algorithm is based on TreeMap's,\n+ * but has been modified to simultaneously map a tree node by key and\n+ * by value. This doubles the cost of put operations (but so does\n+ * using two TreeMaps), and nearly doubles the cost of remove\n+ * operations (there is a savings in that the lookup of the node to be\n+ * removed only has to be performed once). And since only one node\n+ * contains the key and value, storage is significantly less than that\n+ * required by two TreeMaps.\n+ * <p>\n+ * The Map.Entry instances returned by the appropriate methods will\n+ * not allow setValue() and will throw an\n+ * UnsupportedOperationException on attempts to call that method.\n+ *\n+ * @see BidiMap\n+ * @see DualTreeBidiMap\n+ * @see DualHashBidiMap\n+ * @since Commons Collections 2.0 (previously DoubleOrderedMap)\n+ * @version $Revision: 1.1 $ $Date: 2003/11/08 18:52:51 $\n+ * \n+ * @author Marc Johnson\n+ * @author Stephen Colebourne\n+ */\n+public class TreeBidiMap implements BidiMap {\n+\n+    private static final int KEY = 0;\n+    private static final int VALUE = 1;\n+    private static final int MAPENTRY = 2;\n+    private static final int INVERSEMAPENTRY = 3;\n+    private static final int SUM_OF_INDICES = KEY + VALUE;\n+    private static final int FIRST_INDEX = 0;\n+    private static final int NUMBER_OF_INDICES = 2;\n+    private static final String[] dataName = new String[] { \"key\", \"value\" };\n+    \n+    private Node[] rootNode = new Node[2];\n+    private int nodeCount = 0;\n+    private int modifications = 0;\n+    private Set keySet;\n+    private Set valuesSet;\n+    private Set entrySet;\n+    private TreeBidiMap.Inverse inverse = null;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty TreeBidiMap.\n+     */\n+    public TreeBidiMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new TreeBidiMap by copying an existing Map.\n+     *\n+     * @param map  the map to copy\n+     * @throws ClassCastException if the keys/values in the map are\n+     *  not Comparable or are not mutually comparable\n+     * @throws NullPointerException if any key or value in the map is null\n+     */\n+    public TreeBidiMap(final Map map) {\n+        super();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of key-value mappings in this map.\n+     *\n+     * @return the number of key-value mappings in this map\n+     */\n+    public int size() {\n+        return nodeCount;\n+    }\n+\n+    /**\n+     * Checks whether the map is empty or not.\n+     *\n+     * @return true if the map is empty\n+     */\n+    public boolean isEmpty() {\n+        return (nodeCount == 0);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified key.\n+     *\n+     * @param key  key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public boolean containsKey(final Object key) {\n+        checkKey(key);\n+        return (lookup((Comparable) key, KEY) != null);\n+    }\n+\n+    /**\n+     * Checks whether this map contains the a mapping for the specified value.\n+     *\n+     * @param value  value whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified value\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public boolean containsValue(final Object value) {\n+        checkValue(value);\n+        return (lookup((Comparable) value, VALUE) != null);\n+    }\n+\n+    /**\n+     * Gets the value to which this map maps the specified key.\n+     * Returns null if the map contains no mapping for this key.\n+     *\n+     * @param key  key whose associated value is to be returned\n+     * @return the value to which this map maps the specified key,\n+     *  or null if the map contains no mapping for this key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public Object get(final Object key) {\n+        return doGet((Comparable) key, KEY);\n+    }\n+\n+    /**\n+     * Puts the key-value pair into the map, replacing any previous pair.\n+     * <p>\n+     * When adding a key-value pair, the value may already exist in the map\n+     * against a different key. That mapping is removed, to ensure that the\n+     * value only occurs once in the inverse map.\n+     * <pre>\n+     *  BidiMap map1 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n+     * \n+     *  BidiMap map2 = new TreeBidiMap();\n+     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n+     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n+     * </pre>\n+     *\n+     * @param key  key with which the specified value is to be  associated\n+     * @param value  value to be associated with the specified key\n+     * @return the previous value for the key\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public Object put(final Object key, final Object value) {\n+        return doPut((Comparable) key, (Comparable) value, KEY);\n+    }\n+\n+    /**\n+     * Puts all the mappings from the specified map into this map.\n+     * \n+     * @param map  the map to copy from\n+     */\n+    public void putAll(Map map) {\n+        Iterator it = map.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+        \n+    /**\n+     * Removes the mapping for this key from this map if present.\n+     *\n+     * @param key  key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key,\n+     *  or null if there was no mapping for key.\n+     * @throws ClassCastException if the key is of an inappropriate type\n+     * @throws NullPointerException if the key is null\n+     */\n+    public Object remove(final Object key) {\n+        return doRemove((Comparable) key, KEY);\n+    }\n+\n+    /**\n+     * Removes all mappings from this map.\n+     */\n+    public void clear() {\n+        modify();\n+\n+        nodeCount = 0;\n+        rootNode[KEY] = null;\n+        rootNode[VALUE] = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the key to which this map maps the specified value.\n+     * Returns null if the map contains no mapping for this value.\n+     *\n+     * @param value  value whose associated key is to be returned.\n+     * @return the key to which this map maps the specified value,\n+     *  or null if the map contains no mapping for this value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public Object getKey(final Object value) {\n+        return doGet((Comparable) value, VALUE);\n+    }\n+\n+    /**\n+     * Removes the mapping for this value from this map if present\n+     *\n+     * @param value  value whose mapping is to be removed from the map\n+     * @return previous key associated with specified value,\n+     *  or null if there was no mapping for value.\n+     * @throws ClassCastException if the value is of an inappropriate type\n+     * @throws NullPointerException if the value is null\n+     */\n+    public Object removeValue(final Object value) {\n+        return doRemove((Comparable) value, VALUE);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first (lowest) key currently in this map.\n+     *\n+     * @return the first (lowest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object firstKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return leastNode(rootNode[KEY], KEY).getKey();\n+    }\n+\n+    /**\n+     * Gets the last (highest) key currently in this map.\n+     *\n+     * @return the last (highest) key currently in this sorted map\n+     * @throws NoSuchElementException if this map is empty\n+     */\n+    public Object lastKey() {\n+        if (nodeCount == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return greatestNode(rootNode[KEY], KEY).getKey();\n+    }\n+    \n+    /**\n+     * Gets the next key after the one specified.\n+     *\n+     * @param the key to search for next from\n+     * @return the next key, null if no match or at end\n+     */\n+    public Object nextKey(Object key) {\n+        checkKey(key);\n+        Node node = nextGreater(lookup((Comparable) key, KEY), KEY);\n+        return (node == null ? null : node.getKey());\n+    }\n+\n+    /**\n+     * Gets the previous key before the one specified.\n+     *\n+     * @param the key to search for previous from\n+     * @return the previous key, null if no match or at start\n+     */\n+    public Object previousKey(Object key) {\n+        checkKey(key);\n+        Node node = nextSmaller(lookup((Comparable) key, KEY), KEY);\n+        return (node == null ? null : node.getKey());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the keys contained in this map in key order.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set keySet() {\n+        if (keySet == null) {\n+            keySet = new View(this, KEY, KEY);\n+        }\n+        return keySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the values contained in this map in key order.\n+     * The returned object can be cast to a Set.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Collection values() {\n+        if (valuesSet == null) {\n+            valuesSet = new View(this, KEY, VALUE);\n+        }\n+        return valuesSet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns a set view of the entries contained in this map in key order.\n+     * For simple iteration through the map, the MapIterator is quicker.\n+     * <p>\n+     * The set is backed by the map, so changes to the map are reflected in\n+     * the set, and vice-versa. If the map is modified while an iteration over\n+     * the set is in progress, the results of the iteration are undefined.\n+     * <p>\n+     * The set supports element removal, which removes the corresponding mapping\n+     * from the map. It does not support the add or addAll operations.\n+     * The returned MapEntry objects do not support setValue.\n+     *\n+     * @return a set view of the values contained in this map.\n+     */\n+    public Set entrySet() {\n+        if (entrySet == null) {\n+            return new EntryView(this, KEY, MAPENTRY);\n+        }\n+        return entrySet;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map entries.\n+     * <p>\n+     * For this map, this iterator is the fastest way to iterate over the entries.\n+     * \n+     * @return an iterator\n+     */\n+    public MapIterator mapIterator() {\n+        if (isEmpty()) {\n+            return IteratorUtils.EMPTY_MAP_ITERATOR;\n+        }\n+        return new ViewMapIterator(this, KEY);\n+    }\n+\n+    /**\n+     * Gets the inverse map for comparison.\n+     * \n+     * @return the inverse map\n+     */\n+    public BidiMap inverseBidiMap() {\n+        if (inverse == null) {\n+            inverse = new Inverse(this);\n+        }\n+        return inverse;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @param index  the KEY or VALUE int\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        return this.doEquals(obj, KEY);\n+    }\n+    \n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @return the hash code value for this map\n+     */\n+    public int hashCode() {\n+        return this.doHashCode(KEY);\n+    }\n+    \n+    /**\n+     * Returns a string version of this Map in standard format.\n+     * \n+     * @return a standard format string version of the map\n+     */\n+    public String toString() {\n+        return this.doToString(KEY);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Common get logic, used to get by key or get by value\n+     *\n+     * @param obj  the key or value that we're looking for\n+     * @param index  the KEY or VALUE int\n+     * @return the key (if the value was mapped) or the value (if the\n+     *         key was mapped); null if we couldn't find the specified\n+     *         object\n+     */\n+    private Object doGet(final Comparable obj, final int index) {\n+        checkNonNullComparable(obj, index);\n+        Node node = lookup(obj, index);\n+        return ((node == null) ? null : node.getData(oppositeIndex(index)));\n+    }\n+\n+    /**\n+     * Common put logic, differing only in the return value.\n+     * \n+     * @param key  the key, always the main map key\n+     * @param value  the value, always the main map value\n+     * @param index  the KEY or VALUE int, for the return value only\n+     * @return the previously mapped value\n+     */\n+    private Object doPut(final Comparable key, final Comparable value, final int index) {\n+        checkKeyAndValue(key, value);\n+        \n+        // store previous and remove previous mappings\n+        Object prev = (index == KEY ? doGet(key, KEY) :  doGet(value, VALUE));\n+        doRemove((Comparable) key, KEY);\n+        doRemove((Comparable) value, VALUE);\n+        \n+        Node node = rootNode[KEY];\n+        if (node == null) {\n+            // map is empty\n+            Node root = new Node(key, value);\n+            rootNode[KEY] = root;\n+            rootNode[VALUE] = root;\n+            grow();\n+            \n+        } else {\n+            // add new mapping\n+            while (true) {\n+                int cmp = compare(key, node.getData(KEY));\n+        \n+                if (cmp == 0) {\n+                    // shouldn't happen\n+                    throw new IllegalArgumentException(\"Cannot store a duplicate key (\\\"\" + key + \"\\\") in this Map\");\n+                } else if (cmp < 0) {\n+                    if (node.getLeft(KEY) != null) {\n+                        node = node.getLeft(KEY);\n+                    } else {\n+                        Node newNode = new Node(key, value);\n+        \n+                        insertValue(newNode);\n+                        node.setLeft(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+        \n+                        break;\n+                    }\n+                } else { // cmp > 0\n+                    if (node.getRight(KEY) != null) {\n+                        node = node.getRight(KEY);\n+                    } else {\n+                        Node newNode = new Node(key, value);\n+        \n+                        insertValue(newNode);\n+                        node.setRight(newNode, KEY);\n+                        newNode.setParent(node, KEY);\n+                        doRedBlackInsert(newNode, KEY);\n+                        grow();\n+        \n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return prev;\n+    }\n+\n+    /**\n+     * Remove by object (remove by key or remove by value)\n+     *\n+     * @param o the key, or value, that we're looking for\n+     * @param index  the KEY or VALUE int\n+     *\n+     * @return the key, if remove by value, or the value, if remove by\n+     *         key. null if the specified key or value could not be\n+     *         found\n+     */\n+    private Object doRemove(final Comparable o, final int index) {\n+        Node node = lookup(o, index);\n+        Object rval = null;\n+        if (node != null) {\n+            rval = node.getData(oppositeIndex(index));\n+            doRedBlackDelete(node);\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * do the actual lookup of a piece of data\n+     *\n+     * @param data the key or value to be looked up\n+     * @param index  the KEY or VALUE int\n+     * @return the desired Node, or null if there is no mapping of the\n+     *         specified data\n+     */\n+    private Node lookup(final Comparable data, final int index) {\n+        Node rval = null;\n+        Node node = rootNode[index];\n+\n+        while (node != null) {\n+            int cmp = compare(data, node.getData(index));\n+            if (cmp == 0) {\n+                rval = node;\n+                break;\n+            } else {\n+                node = (cmp < 0) ? node.getLeft(index) : node.getRight(index);\n+            }\n+        }\n+\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node nextGreater(final Node node, final int index) {\n+        Node rval = null;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getRight(index) != null) {\n+            // everything to the node's right is larger. The least of\n+            // the right node's descendants is the next larger node\n+            rval = leastNode(node.getRight(index), index);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose left child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's left\n+            // ... and that ancestor is the next greatest node\n+            Node parent = node.getParent(index);\n+            Node child = node;\n+\n+            while ((parent != null) && (child == parent.getRight(index))) {\n+                child = parent;\n+                parent = parent.getParent(index);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * get the next larger node from the specified node\n+     *\n+     * @param node the node to be searched from\n+     * @param index  the KEY or VALUE int\n+     * @return the specified node\n+     */\n+    private Node nextSmaller(final Node node, final int index) {\n+        Node rval = null;\n+        if (node == null) {\n+            rval = null;\n+        } else if (node.getLeft(index) != null) {\n+            // everything to the node's left is smaller. The greatest of\n+            // the left node's descendants is the next smaller node\n+            rval = greatestNode(node.getLeft(index), index);\n+        } else {\n+            // traverse up our ancestry until we find an ancestor that\n+            // is null or one whose right child is our ancestor. If we\n+            // find a null, then this node IS the largest node in the\n+            // tree, and there is no greater node. Otherwise, we are\n+            // the largest node in the subtree on that ancestor's right\n+            // ... and that ancestor is the next greatest node\n+            Node parent = node.getParent(index);\n+            Node child = node;\n+\n+            while ((parent != null) && (child == parent.getLeft(index))) {\n+                child = parent;\n+                parent = parent.getParent(index);\n+            }\n+            rval = parent;\n+        }\n+        return rval;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Get the opposite index of the specified index\n+     *\n+     * @param index  the KEY or VALUE int\n+     * @return VALUE (if KEY was specified), else KEY\n+     */\n+    private static int oppositeIndex(final int index) {\n+        // old trick ... to find the opposite of a value, m or n,\n+        // subtract the value from the sum of the two possible\n+        // values. (m + n) - m = n; (m + n) - n = m\n+        return SUM_OF_INDICES - index;\n+    }\n+\n+    /**\n+     * Compare two objects\n+     *\n+     * @param o1  the first object\n+     * @param o2  the second object\n+     *\n+     * @return negative value if o1 < o2; 0 if o1 == o2; positive\n+     *         value if o1 > o2\n+     */\n+    private static int compare(final Comparable o1, final Comparable o2) {\n+        return ((Comparable) o1).compareTo(o2);\n+    }\n+\n+    /**\n+     * Find the least node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the smallest node, from the specified node, in the\n+     *         specified mapping\n+     */\n+    private static Node leastNode(final Node node, final int index) {\n+        Node rval = node;\n+        if (rval != null) {\n+            while (rval.getLeft(index) != null) {\n+                rval = rval.getLeft(index);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * Find the greatest node from a given node.\n+     *\n+     * @param node  the node from which we will start searching\n+     * @param index  the KEY or VALUE int\n+     * @return the greatest node, from the specified node\n+     */\n+    private static Node greatestNode(final Node node, final int index) {\n+        Node rval = node;\n+        if (rval != null) {\n+            while (rval.getRight(index) != null) {\n+                rval = rval.getRight(index);\n+            }\n+        }\n+        return rval;\n+    }\n+\n+    /**\n+     * copy the color from one node to another, dealing with the fact\n+     * that one or both nodes may, in fact, be null\n+     *\n+     * @param from the node whose color we're copying; may be null\n+     * @param to the node whose color we're changing; may be null\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void copyColor(final Node from, final Node to, final int index) {\n+        if (to != null) {\n+            if (from == null) {\n+                // by default, make it black\n+                to.setBlack(index);\n+            } else {\n+                to.copyColor(from, index);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * is the specified node red? if the node does not exist, no, it's\n+     * black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isRed(final Node node, final int index) {\n+        return ((node == null) ? false : node.isRed(index));\n+    }\n+\n+    /**\n+     * is the specified black red? if the node does not exist, sure,\n+     * it's black, thank you\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isBlack(final Node node, final int index) {\n+        return ((node == null) ? true : node.isBlack(index));\n+    }\n+\n+    /**\n+     * force a node (if it exists) red\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeRed(final Node node, final int index) {\n+        if (node != null) {\n+            node.setRed(index);\n+        }\n+    }\n+\n+    /**\n+     * force a node (if it exists) black\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static void makeBlack(final Node node, final int index) {\n+        if (node != null) {\n+            node.setBlack(index);\n+        }\n+    }\n+\n+    /**\n+     * get a node's grandparent. mind you, the node, its parent, or\n+     * its grandparent may not exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getGrandParent(final Node node, final int index) {\n+        return getParent(getParent(node, index), index);\n+    }\n+\n+    /**\n+     * get a node's parent. mind you, the node, or its parent, may not\n+     * exist. no problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getParent(final Node node, final int index) {\n+        return ((node == null) ? null : node.getParent(index));\n+    }\n+\n+    /**\n+     * get a node's right child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getRightChild(final Node node, final int index) {\n+        return (node == null) ? null : node.getRight(index);\n+    }\n+\n+    /**\n+     * get a node's left child. mind you, the node may not exist. no\n+     * problem\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static Node getLeftChild(final Node node, final int index) {\n+        return (node == null) ? null : node.getLeft(index);\n+    }\n+\n+    /**\n+     * is this node its parent's left child? mind you, the node, or\n+     * its parent, may not exist. no problem. if the node doesn't\n+     * exist ... it's its non-existent parent's left child. If the\n+     * node does exist but has no parent ... no, we're not the\n+     * non-existent parent's left child. Otherwise (both the specified\n+     * node AND its parent exist), check.\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isLeftChild(final Node node, final int index) {\n+        return (node == null)\n+            ? true\n+            : ((node.getParent(index) == null) ?\n+                false : (node == node.getParent(index).getLeft(index)));\n+    }\n+\n+    /**\n+     * is this node its parent's right child? mind you, the node, or\n+     * its parent, may not exist. no problem. if the node doesn't\n+     * exist ... it's its non-existent parent's right child. If the\n+     * node does exist but has no parent ... no, we're not the\n+     * non-existent parent's right child. Otherwise (both the\n+     * specified node AND its parent exist), check.\n+     *\n+     * @param node the node (may be null) in question\n+     * @param index  the KEY or VALUE int\n+     */\n+    private static boolean isRightChild(final Node node, final int index) {\n+        return (node == null)\n+            ? true\n+            : ((node.getParent(index) == null) ? \n+                false : (node == node.getParent(index).getRight(index)));\n+    }\n+\n+    /**\n+     * do a rotate left. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateLeft(final Node node, final int index) {\n+        Node rightChild = node.getRight(index);\n+        node.setRight(rightChild.getLeft(index), index);\n+\n+        if (rightChild.getLeft(index) != null) {\n+            rightChild.getLeft(index).setParent(node, index);\n+        }\n+        rightChild.setParent(node.getParent(index), index);\n+        \n+        if (node.getParent(index) == null) {\n+            // node was the root ... now its right child is the root\n+            rootNode[index] = rightChild;\n+        } else if (node.getParent(index).getLeft(index) == node) {\n+            node.getParent(index).setLeft(rightChild, index);\n+        } else {\n+            node.getParent(index).setRight(rightChild, index);\n+        }\n+\n+        rightChild.setLeft(node, index);\n+        node.setParent(rightChild, index);\n+    }\n+\n+    /**\n+     * do a rotate right. standard fare in the world of balanced trees\n+     *\n+     * @param node the node to be rotated\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void rotateRight(final Node node, final int index) {\n+        Node leftChild = node.getLeft(index);\n+        node.setLeft(leftChild.getRight(index), index);\n+        if (leftChild.getRight(index) != null) {\n+            leftChild.getRight(index).setParent(node, index);\n+        }\n+        leftChild.setParent(node.getParent(index), index);\n+\n+        if (node.getParent(index) == null) {\n+            // node was the root ... now its left child is the root\n+            rootNode[index] = leftChild;\n+        } else if (node.getParent(index).getRight(index) == node) {\n+            node.getParent(index).setRight(leftChild, index);\n+        } else {\n+            node.getParent(index).setLeft(leftChild, index);\n+        }\n+\n+        leftChild.setRight(node, index);\n+        node.setParent(leftChild, index);\n+    }\n+\n+    /**\n+     * complicated red-black insert stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param insertedNode the node to be inserted\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void doRedBlackInsert(final Node insertedNode, final int index) {\n+        Node currentNode = insertedNode;\n+        makeRed(currentNode, index);\n+\n+        while ((currentNode != null)\n+            && (currentNode != rootNode[index])\n+            && (isRed(currentNode.getParent(index), index))) {\n+            if (isLeftChild(getParent(currentNode, index), index)) {\n+                Node y = getRightChild(getGrandParent(currentNode, index), index);\n+\n+                if (isRed(y, index)) {\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(y, index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    currentNode = getGrandParent(currentNode, index);\n+                } else {\n+                    if (isRightChild(currentNode, index)) {\n+                        currentNode = getParent(currentNode, index);\n+\n+                        rotateLeft(currentNode, index);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    if (getGrandParent(currentNode, index) != null) {\n+                        rotateRight(getGrandParent(currentNode, index), index);\n+                    }\n+                }\n+            } else {\n+\n+                // just like clause above, except swap left for right\n+                Node y = getLeftChild(getGrandParent(currentNode, index), index);\n+\n+                if (isRed(y, index)) {\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(y, index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    currentNode = getGrandParent(currentNode, index);\n+                } else {\n+                    if (isLeftChild(currentNode, index)) {\n+                        currentNode = getParent(currentNode, index);\n+\n+                        rotateRight(currentNode, index);\n+                    }\n+\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeRed(getGrandParent(currentNode, index), index);\n+\n+                    if (getGrandParent(currentNode, index) != null) {\n+                        rotateLeft(getGrandParent(currentNode, index), index);\n+                    }\n+                }\n+            }\n+        }\n+\n+        makeBlack(rootNode[index], index);\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more\n+     *\n+     * @param deletedNode the node to be deleted\n+     */\n+    private void doRedBlackDelete(final Node deletedNode) {\n+        for (int index = FIRST_INDEX; index < NUMBER_OF_INDICES; index++) {\n+            // if deleted node has both left and children, swap with\n+            // the next greater node\n+            if ((deletedNode.getLeft(index) != null) && (deletedNode.getRight(index) != null)) {\n+                swapPosition(nextGreater(deletedNode, index), deletedNode, index);\n+            }\n+\n+            Node replacement =\n+                ((deletedNode.getLeft(index) != null) ? deletedNode.getLeft(index) : deletedNode.getRight(index));\n+\n+            if (replacement != null) {\n+                replacement.setParent(deletedNode.getParent(index), index);\n+\n+                if (deletedNode.getParent(index) == null) {\n+                    rootNode[index] = replacement;\n+                } else if (deletedNode == deletedNode.getParent(index).getLeft(index)) {\n+                    deletedNode.getParent(index).setLeft(replacement, index);\n+                } else {\n+                    deletedNode.getParent(index).setRight(replacement, index);\n+                }\n+\n+                deletedNode.setLeft(null, index);\n+                deletedNode.setRight(null, index);\n+                deletedNode.setParent(null, index);\n+\n+                if (isBlack(deletedNode, index)) {\n+                    doRedBlackDeleteFixup(replacement, index);\n+                }\n+            } else {\n+\n+                // replacement is null\n+                if (deletedNode.getParent(index) == null) {\n+\n+                    // empty tree\n+                    rootNode[index] = null;\n+                } else {\n+\n+                    // deleted node had no children\n+                    if (isBlack(deletedNode, index)) {\n+                        doRedBlackDeleteFixup(deletedNode, index);\n+                    }\n+\n+                    if (deletedNode.getParent(index) != null) {\n+                        if (deletedNode == deletedNode.getParent(index).getLeft(index)) {\n+                            deletedNode.getParent(index).setLeft(null, index);\n+                        } else {\n+                            deletedNode.getParent(index).setRight(null, index);\n+                        }\n+\n+                        deletedNode.setParent(null, index);\n+                    }\n+                }\n+            }\n+        }\n+        shrink();\n+    }\n+\n+    /**\n+     * complicated red-black delete stuff. Based on Sun's TreeMap\n+     * implementation, though it's barely recognizable any more. This\n+     * rebalances the tree (somewhat, as red-black trees are not\n+     * perfectly balanced -- perfect balancing takes longer)\n+     *\n+     * @param replacementNode the node being replaced\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void doRedBlackDeleteFixup(final Node replacementNode, final int index) {\n+        Node currentNode = replacementNode;\n+\n+        while ((currentNode != rootNode[index]) && (isBlack(currentNode, index))) {\n+            if (isLeftChild(currentNode, index)) {\n+                Node siblingNode = getRightChild(getParent(currentNode, index), index);\n+\n+                if (isRed(siblingNode, index)) {\n+                    makeBlack(siblingNode, index);\n+                    makeRed(getParent(currentNode, index), index);\n+                    rotateLeft(getParent(currentNode, index), index);\n+\n+                    siblingNode = getRightChild(getParent(currentNode, index), index);\n+                }\n+\n+                if (isBlack(getLeftChild(siblingNode, index), index)\n+                    && isBlack(getRightChild(siblingNode, index), index)) {\n+                    makeRed(siblingNode, index);\n+\n+                    currentNode = getParent(currentNode, index);\n+                } else {\n+                    if (isBlack(getRightChild(siblingNode, index), index)) {\n+                        makeBlack(getLeftChild(siblingNode, index), index);\n+                        makeRed(siblingNode, index);\n+                        rotateRight(siblingNode, index);\n+\n+                        siblingNode = getRightChild(getParent(currentNode, index), index);\n+                    }\n+\n+                    copyColor(getParent(currentNode, index), siblingNode, index);\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(getRightChild(siblingNode, index), index);\n+                    rotateLeft(getParent(currentNode, index), index);\n+\n+                    currentNode = rootNode[index];\n+                }\n+            } else {\n+                Node siblingNode = getLeftChild(getParent(currentNode, index), index);\n+\n+                if (isRed(siblingNode, index)) {\n+                    makeBlack(siblingNode, index);\n+                    makeRed(getParent(currentNode, index), index);\n+                    rotateRight(getParent(currentNode, index), index);\n+\n+                    siblingNode = getLeftChild(getParent(currentNode, index), index);\n+                }\n+\n+                if (isBlack(getRightChild(siblingNode, index), index)\n+                    && isBlack(getLeftChild(siblingNode, index), index)) {\n+                    makeRed(siblingNode, index);\n+\n+                    currentNode = getParent(currentNode, index);\n+                } else {\n+                    if (isBlack(getLeftChild(siblingNode, index), index)) {\n+                        makeBlack(getRightChild(siblingNode, index), index);\n+                        makeRed(siblingNode, index);\n+                        rotateLeft(siblingNode, index);\n+\n+                        siblingNode = getLeftChild(getParent(currentNode, index), index);\n+                    }\n+\n+                    copyColor(getParent(currentNode, index), siblingNode, index);\n+                    makeBlack(getParent(currentNode, index), index);\n+                    makeBlack(getLeftChild(siblingNode, index), index);\n+                    rotateRight(getParent(currentNode, index), index);\n+\n+                    currentNode = rootNode[index];\n+                }\n+            }\n+        }\n+\n+        makeBlack(currentNode, index);\n+    }\n+\n+    /**\n+     * swap two nodes (except for their content), taking care of\n+     * special cases where one is the other's parent ... hey, it\n+     * happens.\n+     *\n+     * @param x one node\n+     * @param y another node\n+     * @param index  the KEY or VALUE int\n+     */\n+    private void swapPosition(final Node x, final Node y, final int index) {\n+        // Save initial values.\n+        Node xFormerParent = x.getParent(index);\n+        Node xFormerLeftChild = x.getLeft(index);\n+        Node xFormerRightChild = x.getRight(index);\n+        Node yFormerParent = y.getParent(index);\n+        Node yFormerLeftChild = y.getLeft(index);\n+        Node yFormerRightChild = y.getRight(index);\n+        boolean xWasLeftChild = (x.getParent(index) != null) && (x == x.getParent(index).getLeft(index));\n+        boolean yWasLeftChild = (y.getParent(index) != null) && (y == y.getParent(index).getLeft(index));\n+\n+        // Swap, handling special cases of one being the other's parent.\n+        if (x == yFormerParent) { // x was y's parent\n+            x.setParent(y, index);\n+\n+            if (yWasLeftChild) {\n+                y.setLeft(x, index);\n+                y.setRight(xFormerRightChild, index);\n+            } else {\n+                y.setRight(x, index);\n+                y.setLeft(xFormerLeftChild, index);\n+            }\n+        } else {\n+            x.setParent(yFormerParent, index);\n+\n+            if (yFormerParent != null) {\n+                if (yWasLeftChild) {\n+                    yFormerParent.setLeft(x, index);\n+                } else {\n+                    yFormerParent.setRight(x, index);\n+                }\n+            }\n+\n+            y.setLeft(xFormerLeftChild, index);\n+            y.setRight(xFormerRightChild, index);\n+        }\n+\n+        if (y == xFormerParent) { // y was x's parent\n+            y.setParent(x, index);\n+\n+            if (xWasLeftChild) {\n+                x.setLeft(y, index);\n+                x.setRight(yFormerRightChild, index);\n+            } else {\n+                x.setRight(y, index);\n+                x.setLeft(yFormerLeftChild, index);\n+            }\n+        } else {\n+            y.setParent(xFormerParent, index);\n+\n+            if (xFormerParent != null) {\n+                if (xWasLeftChild) {\n+                    xFormerParent.setLeft(y, index);\n+                } else {\n+                    xFormerParent.setRight(y, index);\n+                }\n+            }\n+\n+            x.setLeft(yFormerLeftChild, index);\n+            x.setRight(yFormerRightChild, index);\n+        }\n+\n+        // Fix children's parent pointers\n+        if (x.getLeft(index) != null) {\n+            x.getLeft(index).setParent(x, index);\n+        }\n+\n+        if (x.getRight(index) != null) {\n+            x.getRight(index).setParent(x, index);\n+        }\n+\n+        if (y.getLeft(index) != null) {\n+            y.getLeft(index).setParent(y, index);\n+        }\n+\n+        if (y.getRight(index) != null) {\n+            y.getRight(index).setParent(y, index);\n+        }\n+\n+        x.swapColors(y, index);\n+\n+        // Check if root changed\n+        if (rootNode[index] == x) {\n+            rootNode[index] = y;\n+        } else if (rootNode[index] == y) {\n+            rootNode[index] = x;\n+        }\n+    }\n+\n+    /**\n+     * check if an object is fit to be proper input ... has to be\n+     * Comparable and non-null\n+     *\n+     * @param o the object being checked\n+     * @param index  the KEY or VALUE int (used to put the right word in the\n+     *              exception message)\n+     *\n+     * @throws NullPointerException if o is null\n+     * @throws ClassCastException if o is not Comparable\n+     */\n+    private static void checkNonNullComparable(final Object o, final int index) {\n+        if (o == null) {\n+            throw new NullPointerException(dataName[index] + \" cannot be null\");\n+        }\n+        if (!(o instanceof Comparable)) {\n+            throw new ClassCastException(dataName[index] + \" must be Comparable\");\n+        }\n+    }\n+\n+    /**\n+     * check a key for validity (non-null and implements Comparable)\n+     *\n+     * @param key the key to be checked\n+     *\n+     * @throws NullPointerException if key is null\n+     * @throws ClassCastException if key is not Comparable\n+     */\n+    private static void checkKey(final Object key) {\n+        checkNonNullComparable(key, KEY);\n+    }\n+\n+    /**\n+     * check a value for validity (non-null and implements Comparable)\n+     *\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if value is null\n+     * @throws ClassCastException if value is not Comparable\n+     */\n+    private static void checkValue(final Object value) {\n+        checkNonNullComparable(value, VALUE);\n+    }\n+\n+    /**\n+     * check a key and a value for validity (non-null and implements\n+     * Comparable)\n+     *\n+     * @param key the key to be checked\n+     * @param value the value to be checked\n+     *\n+     * @throws NullPointerException if key or value is null\n+     * @throws ClassCastException if key or value is not Comparable\n+     */\n+    private static void checkKeyAndValue(final Object key, final Object value) {\n+        checkKey(key);\n+        checkValue(value);\n+    }\n+\n+    /**\n+     * increment the modification count -- used to check for\n+     * concurrent modification of the map through the map and through\n+     * an Iterator from one of its Set or Collection views\n+     */\n+    private void modify() {\n+        modifications++;\n+    }\n+\n+    /**\n+     * bump up the size and note that the map has changed\n+     */\n+    private void grow() {\n+        modify();\n+        nodeCount++;\n+    }\n+\n+    /**\n+     * decrement the size and note that the map has changed\n+     */\n+    private void shrink() {\n+        modify();\n+        nodeCount--;\n+    }\n+\n+    /**\n+     * insert a node by its value\n+     *\n+     * @param newNode the node to be inserted\n+     *\n+     * @throws IllegalArgumentException if the node already exists\n+     *                                     in the value mapping\n+     */\n+    private void insertValue(final Node newNode) throws IllegalArgumentException {\n+        Node node = rootNode[VALUE];\n+\n+        while (true) {\n+            int cmp = compare(newNode.getData(VALUE), node.getData(VALUE));\n+\n+            if (cmp == 0) {\n+                throw new IllegalArgumentException(\n+                    \"Cannot store a duplicate value (\\\"\" + newNode.getData(VALUE) + \"\\\") in this Map\");\n+            } else if (cmp < 0) {\n+                if (node.getLeft(VALUE) != null) {\n+                    node = node.getLeft(VALUE);\n+                } else {\n+                    node.setLeft(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            } else { // cmp > 0\n+                if (node.getRight(VALUE) != null) {\n+                    node = node.getRight(VALUE);\n+                } else {\n+                    node.setRight(newNode, VALUE);\n+                    newNode.setParent(node, VALUE);\n+                    doRedBlackInsert(newNode, VALUE);\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares for equals as per the API.\n+     *\n+     * @param obj  the object to compare to\n+     * @param index  the KEY or VALUE int\n+     * @return true if equal\n+     */\n+    private boolean doEquals(Object obj, final int type) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map other = (Map) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+\n+        if (nodeCount > 0) {\n+            try {\n+                for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {\n+                    Object key = it.next();\n+                    Object value = it.getValue();\n+                    if (value.equals(other.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            } catch (ClassCastException ex) {\n+                return false;\n+            } catch (NullPointerException ex) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the hash code value for this map as per the API.\n+     *\n+     * @param index  the KEY or VALUE int\n+     * @return the hash code value for this map\n+     */\n+    private int doHashCode(final int type) {\n+        int total = 0;\n+        if (nodeCount > 0) {\n+            for (MapIterator it = new ViewMapIterator(this, type); it.hasNext(); ) {\n+                Object key = it.next();\n+                Object value = it.getValue();\n+                total += (key.hashCode() ^ value.hashCode());\n+            }\n+        }\n+        return total;\n+    }\n+    \n+    /**\n+     * Gets the string form of this map as per AbstractMap.\n+     *\n+     * @param index  the KEY or VALUE int\n+     * @return the string form of this map\n+     */\n+    private String doToString(final int type) {\n+        if (nodeCount == 0) {\n+            return \"{}\";\n+        }\n+        StringBuffer buf = new StringBuffer(nodeCount * 32);\n+        buf.append('{');\n+        MapIterator it = new ViewMapIterator(this, type);\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            Object key = it.next();\n+            Object value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(\", \");\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A view of this map.\n+     */\n+    static class View extends AbstractSet {\n+        \n+        protected final TreeBidiMap main;\n+        protected final int orderType;\n+        protected final int dataType;\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int\n+         */\n+        View(final TreeBidiMap main, final int orderType, final int dataType) {\n+            super();\n+            this.main = main;\n+            this.orderType = orderType;\n+            this.dataType = dataType;\n+        }\n+        \n+        public Iterator iterator() {\n+            return new ViewIterator(main, orderType, dataType);\n+        }\n+\n+        public int size() {\n+            return main.size();\n+        }\n+\n+        public boolean contains(final Object obj) {\n+            checkNonNullComparable(obj, dataType);\n+            return (main.lookup((Comparable) obj, dataType) != null);\n+        }\n+\n+        public boolean remove(final Object obj) {\n+            return (main.doRemove((Comparable) obj, dataType) != null);\n+        }\n+\n+        public void clear() {\n+            main.clear();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    static class ViewIterator implements Iterator {\n+\n+        protected final TreeBidiMap main;\n+        protected final int orderType;\n+        protected final int dataType;\n+        protected Node lastReturnedNode;\n+        protected Node nextNode;\n+        protected Node previousNode;\n+        private int expectedModifications;\n+\n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param dataType  the KEY, VALUE, MAPENTRY or INVERSEMAPENTRY int\n+         */\n+        ViewIterator(final TreeBidiMap main, final int orderType, final int dataType) {\n+            super();\n+            this.main = main;\n+            this.orderType = orderType;\n+            this.dataType = dataType;\n+            expectedModifications = main.modifications;\n+            nextNode = leastNode(main.rootNode[orderType], orderType);\n+            lastReturnedNode = null;\n+            previousNode = null;\n+        }\n+\n+        public final boolean hasNext() {\n+            return (nextNode != null);\n+        }\n+\n+        public final Object next() {\n+            if (nextNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (main.modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            lastReturnedNode = nextNode;\n+            previousNode = nextNode;\n+            nextNode = main.nextGreater(nextNode, orderType);\n+            return doGetData();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (previousNode != null);\n+        }\n+\n+        public Object previous() {\n+            if (previousNode == null) {\n+                throw new NoSuchElementException();\n+            }\n+            if (main.modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            nextNode = lastReturnedNode;\n+            if (nextNode == null) {\n+                nextNode = main.nextGreater(previousNode, orderType);\n+            }\n+            lastReturnedNode = previousNode;\n+            previousNode = main.nextSmaller(previousNode, orderType);\n+            return doGetData();\n+        }\n+\n+        protected Object doGetData() {\n+            switch (dataType) {\n+                case KEY:\n+                    return lastReturnedNode.getKey();\n+                case VALUE:\n+                    return lastReturnedNode.getValue();\n+                case MAPENTRY:\n+                    return lastReturnedNode;\n+                case INVERSEMAPENTRY:\n+                    return new UnmodifiableMapEntry(lastReturnedNode.getValue(), lastReturnedNode.getKey());\n+            }\n+            return null;\n+        }\n+\n+        public final void remove() {\n+            if (lastReturnedNode == null) {\n+                throw new IllegalStateException();\n+            }\n+            if (main.modifications != expectedModifications) {\n+                throw new ConcurrentModificationException();\n+            }\n+            main.doRedBlackDelete(lastReturnedNode);\n+            expectedModifications++;\n+            lastReturnedNode = null;\n+            if (nextNode == null) {\n+                previousNode = main.greatestNode(main.rootNode[orderType], orderType);\n+            } else {\n+                previousNode = main.nextSmaller(nextNode, orderType);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An iterator over the map.\n+     */\n+    static class ViewMapIterator extends ViewIterator implements OrderedMapIterator {\n+\n+        private final int oppositeType;\n+        \n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         */\n+        ViewMapIterator(final TreeBidiMap main, final int orderType) {\n+            super(main, orderType, orderType);\n+            this.oppositeType = oppositeIndex(dataType);\n+        }\n+        \n+        public Object getKey() {\n+            return lastReturnedNode.getData(dataType);\n+        }\n+\n+        public Object getValue() {\n+            return lastReturnedNode.getData(oppositeType);\n+        }\n+\n+        public Object setValue(final Object obj) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A view of this map.\n+     */\n+    static class EntryView extends View {\n+        \n+        private final int oppositeType;\n+        \n+        /**\n+         * Constructor.\n+         *\n+         * @param main  the main map\n+         * @param orderType  the KEY or VALUE int for the order\n+         * @param dataType  the MAPENTRY or INVERSEMAPENTRY int for the returned data\n+         */\n+        EntryView(final TreeBidiMap main, final int orderType, final int dataType) {\n+            super(main, orderType, dataType);\n+            this.oppositeType = main.oppositeIndex(orderType);\n+        }\n+        \n+        public boolean contains(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            Object value = entry.getValue();\n+            Node node = main.lookup((Comparable) entry.getKey(), orderType);\n+            return (node != null && node.getData(oppositeType).equals(value));\n+        }\n+\n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            Object value = entry.getValue();\n+            Node node = main.lookup((Comparable) entry.getKey(), orderType);\n+            if (node != null && node.getData(oppositeType).equals(value)) {\n+                main.doRedBlackDelete(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node used to store the data.\n+     */\n+    static class Node implements Map.Entry {\n+\n+        private Comparable[] data;\n+        private Node[] leftNode;\n+        private Node[] rightNode;\n+        private Node[] parentNode;\n+        private boolean[] blackColor;\n+        private int hashcodeValue;\n+        private boolean calculatedHashCode;\n+\n+        /**\n+         * Make a new cell with given key and value, and with null\n+         * links, and black (true) colors.\n+         *\n+         * @param key\n+         * @param value\n+         */\n+        Node(final Comparable key, final Comparable value) {\n+            super();\n+            data = new Comparable[] { key, value };\n+            leftNode = new Node[2];\n+            rightNode = new Node[2];\n+            parentNode = new Node[2];\n+            blackColor = new boolean[] { true, true };\n+            calculatedHashCode = false;\n+        }\n+\n+        /**\n+         * Get the specified data.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the key or value\n+         */\n+        private Comparable getData(final int index) {\n+            return data[index];\n+        }\n+\n+        /**\n+         * Set this node's left node.\n+         *\n+         * @param node  the new left node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setLeft(final Node node, final int index) {\n+            leftNode[index] = node;\n+        }\n+\n+        /**\n+         * Get the left node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the left node, may be null\n+         */\n+        private Node getLeft(final int index) {\n+            return leftNode[index];\n+        }\n+\n+        /**\n+         * Set this node's right node.\n+         *\n+         * @param node  the new right node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setRight(final Node node, final int index) {\n+            rightNode[index] = node;\n+        }\n+\n+        /**\n+         * Get the right node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the right node, may be null\n+         */\n+        private Node getRight(final int index) {\n+            return rightNode[index];\n+        }\n+\n+        /**\n+         * Set this node's parent node.\n+         *\n+         * @param node  the new parent node\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setParent(final Node node, final int index) {\n+            parentNode[index] = node;\n+        }\n+\n+        /**\n+         * Get the parent node.\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return the parent node, may be null\n+         */\n+        private Node getParent(final int index) {\n+            return parentNode[index];\n+        }\n+\n+        /**\n+         * Exchange colors with another node.\n+         *\n+         * @param node  the node to swap with\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void swapColors(final Node node, final int index) {\n+            // Swap colors -- old hacker's trick\n+            blackColor[index]      ^= node.blackColor[index];\n+            node.blackColor[index] ^= blackColor[index];\n+            blackColor[index]      ^= node.blackColor[index];\n+        }\n+\n+        /**\n+         * Is this node black?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if black (which is represented as a true boolean)\n+         */\n+        private boolean isBlack(final int index) {\n+            return blackColor[index];\n+        }\n+\n+        /**\n+         * Is this node red?\n+         *\n+         * @param index  the KEY or VALUE int\n+         * @return true if non-black\n+         */\n+        private boolean isRed(final int index) {\n+            return !blackColor[index];\n+        }\n+\n+        /**\n+         * Make this node black.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setBlack(final int index) {\n+            blackColor[index] = true;\n+        }\n+\n+        /**\n+         * Make this node red.\n+         *\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void setRed(final int index) {\n+            blackColor[index] = false;\n+        }\n+\n+        /**\n+         * Make this node the same color as another\n+         *\n+         * @param node  the node whose color we're adopting\n+         * @param index  the KEY or VALUE int\n+         */\n+        private void copyColor(final Node node, final int index) {\n+            blackColor[index] = node.blackColor[index];\n+        }\n+\n+        //-------------------------------------------------------------------\n+        /**\n+         * Gets the key.\n+         * \n+         * @return the key corresponding to this entry.\n+         */\n+        public Object getKey() {\n+            return data[KEY];\n+        }\n+\n+        /**\n+         * Gets the value.\n+         * \n+         * @return the value corresponding to this entry.\n+         */\n+        public Object getValue() {\n+            return data[VALUE];\n+        }\n+\n+        /**\n+         * Optional operation that is not permitted in this implementation\n+         *\n+         * @param ignored\n+         * @return does not return\n+         * @throws UnsupportedOperationException always\n+         */\n+        public Object setValue(final Object ignored)\n+                throws UnsupportedOperationException {\n+            throw new UnsupportedOperationException(\n+                \"Map.Entry.setValue is not supported\");\n+        }\n+\n+        /**\n+         * Compares the specified object with this entry for equality.\n+         * Returns true if the given object is also a map entry and\n+         * the two entries represent the same mapping.\n+         *\n+         * @param o object to be compared for equality with this map\n+         *          entry.\n+         * @return true if the specified object is equal to this map\n+         *         entry.\n+         */\n+        public boolean equals(final Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (!(obj instanceof Map.Entry)) {\n+                return false;\n+            }\n+            Map.Entry e = (Map.Entry) obj;\n+            return data[KEY].equals(e.getKey()) && data[VALUE].equals(e.getValue());\n+        }\n+\n+        /**\n+         * @return the hash code value for this map entry.\n+         */\n+        public int hashCode() {\n+            if (!calculatedHashCode) {\n+                hashcodeValue = data[KEY].hashCode() ^ data[VALUE].hashCode();\n+                calculatedHashCode = true;\n+            }\n+            return hashcodeValue;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A node used to store the data.\n+     */\n+    static class Inverse implements BidiMap {\n+        \n+        private final TreeBidiMap main;\n+        private Set keySet;\n+        private Set valuesSet;\n+        private Set entrySet;\n+        \n+        Inverse(final TreeBidiMap main) {\n+            super();\n+            this.main = main;\n+        }\n+\n+        public int size() {\n+            return main.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return main.isEmpty();\n+        }\n+\n+        public Object get(final Object key) {\n+            return main.getKey(key);\n+        }\n+\n+        public Object getKey(final Object value) {\n+            return main.get(value);\n+        }\n+\n+        public boolean containsKey(final Object key) {\n+            return main.containsValue(key);\n+        }\n+\n+        public boolean containsValue(final Object value) {\n+            return main.containsKey(value);\n+        }\n+\n+        public Object put(final Object key, final Object value) {\n+            return main.doPut((Comparable) value, (Comparable) key, VALUE);\n+        }\n+\n+        public void putAll(Map map) {\n+            Iterator it = map.entrySet().iterator();\n+            while (it.hasNext()) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        }\n+        \n+        public Object remove(final Object key) {\n+            return main.removeValue(key);\n+        }\n+\n+        public Object removeValue(final Object value) {\n+            return main.remove(value);\n+        }\n+\n+        public void clear() {\n+            main.clear();\n+        }\n+\n+        public Set keySet() {\n+            if (keySet == null) {\n+                keySet = new View(main, VALUE, VALUE);\n+            }\n+            return keySet;\n+        }\n+\n+        public Collection values() {\n+            if (valuesSet == null) {\n+                valuesSet = new View(main, VALUE, KEY);\n+            }\n+            return valuesSet;\n+        }\n+\n+        public Set entrySet() {\n+            if (entrySet == null) {\n+                return new EntryView(main, VALUE, INVERSEMAPENTRY);\n+            }\n+            return entrySet;\n+        }\n+        \n+        public MapIterator mapIterator() {\n+            if (isEmpty()) {\n+                return IteratorUtils.EMPTY_MAP_ITERATOR;\n+            }\n+            return new ViewMapIterator(main, VALUE);\n+        }\n+\n+        public BidiMap inverseBidiMap() {\n+            return main;\n+        }\n+        \n+        public boolean equals(Object obj) {\n+            return main.doEquals(obj, VALUE);\n+        }\n+    \n+        public int hashCode() {\n+            return main.doHashCode(VALUE);\n+        }\n+    \n+        public String toString() {\n+            return main.doToString(VALUE);\n+        }\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.52 2003/10/31 01:26:25 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.53 2003/11/08 18:52:51 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Entry point for all Collections package tests.\n  * \n- * @version $Revision: 1.52 $ $Date: 2003/10/31 01:26:25 $\n+ * @version $Revision: 1.53 $ $Date: 2003/11/08 18:52:51 $\n  * \n  * @author Rodney Waldhoff\n  * @author Stephen Colebourne\n         suite.addTest(TestSequencedHashMap.suite());\n         suite.addTest(TestStaticBucketMap.suite());\n         suite.addTest(TestTreeBag.suite());\n+        suite.addTest(TestTreeBidiMap.suite());\n         suite.addTest(TestUnboundedFifoBuffer.suite());\n         suite.addTest(TestEnumerationUtils.suite());\n         return suite;\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestTreeBidiMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestTreeBidiMap.java,v 1.1 2003/11/08 18:52:51 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/08 18:52:51 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestTreeBidiMap extends AbstractTestBidiMap {\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestTreeBidiMap.class);\n+    }\n+\n+    public TestTreeBidiMap(String testName) {\n+        super(testName);\n+    }\n+\n+    protected BidiMap makeEmptyBidiMap() {\n+        return new TreeBidiMap();\n+    }\n+    \n+    protected Map makeConfirmedMap() {\n+        return new TreeMap();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    protected String[] ignoredTests() {\n+        return new String[] {\"TestTreeBidiMap.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+    protected boolean isAllowNullKey() {\n+        return false;\n+    }\n+    \n+    protected boolean isAllowNullValue() {\n+        return false;\n+    }\n+    \n+    protected boolean isSetValueSupported() {\n+        return false;\n+    }\n+    \n+    public void testFirstKey() {\n+        TreeBidiMap bidi = (TreeBidiMap) makeEmptyMap();\n+        try {\n+            bidi.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        resetFull();\n+        bidi = (TreeBidiMap) map;\n+        Object confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, bidi.firstKey());\n+    }\n+    \n+    public void testLastKey() {\n+        TreeBidiMap bidi = (TreeBidiMap) makeEmptyMap();\n+        try {\n+            bidi.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+        \n+        resetFull();\n+        bidi = (TreeBidiMap) map;\n+        Object confirmedLast = null;\n+        for (Iterator it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, bidi.lastKey());\n+    }\n+    \n+    public void testNextKey() {\n+        TreeBidiMap bidi = (TreeBidiMap) makeEmptyMap();\n+        try {\n+            bidi.nextKey(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            bidi.nextKey(new Object());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        \n+        resetFull();\n+        bidi = (TreeBidiMap) map;\n+        Iterator it = confirmed.keySet().iterator();\n+        Object confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            Object confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.nextKey(confirmedLast));\n+        \n+        try {\n+            bidi.nextKey(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            bidi.nextKey(new Object());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+    public void testPreviousKey() {\n+        TreeBidiMap bidi = (TreeBidiMap) makeEmptyMap();\n+        try {\n+            bidi.previousKey(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            bidi.previousKey(new Object());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        \n+        resetFull();\n+        bidi = (TreeBidiMap) map;\n+        List list = new ArrayList(confirmed.keySet());\n+        Collections.reverse(list);\n+        Iterator it = list.iterator();\n+        Object confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            Object confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.previousKey(confirmedLast));\n+        \n+        try {\n+            bidi.previousKey(null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            bidi.previousKey(new Object());\n+            fail();\n+        } catch (ClassCastException ex) {}\n+    }\n+    \n+}", "timestamp": 1068317571, "metainfo": ""}