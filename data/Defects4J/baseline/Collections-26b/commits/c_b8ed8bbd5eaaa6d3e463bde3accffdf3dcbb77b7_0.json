{"sha": "b8ed8bbd5eaaa6d3e463bde3accffdf3dcbb77b7", "log": "committing several files from Peter Donald and Avalon   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ArrayEnumeration.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Enumeration wrapper for array.\n+ *\n+ * @author <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n+ */\n+public final class ArrayEnumeration\n+    implements Enumeration\n+{\n+    protected Object[]       m_elements;\n+    protected int            m_index;\n+\n+    public ArrayEnumeration( final List elements )\n+    {\n+        m_elements = elements.toArray();\n+    }\n+\n+    public ArrayEnumeration( final Object[] elements )\n+    {\n+        m_elements = elements;\n+    }\n+\n+    public boolean hasMoreElements()\n+    {\n+        return ( m_index < m_elements.length );\n+    }\n+\n+    public Object nextElement()\n+    {\n+        if( !hasMoreElements() )\n+        {\n+            throw new NoSuchElementException(\"No more elements exist\");\n+        }\n+\n+        return m_elements[ m_index++ ];\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/BinaryHeap.java\n+/* \n+ * Copyright (C) The Apache Software Foundation. All rights reserved. \n+ * \n+ * This software is published under the terms of the Apache Software License \n+ * version 1.1, a copy of which has been included with this distribution in \n+ * the LICENSE file. \n+ */ \n+package org.apache.commons.collections;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Iterface for priority queues.\n+ * This interface does not dictate whether it is min or max heap.\n+ *\n+ * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a> \n+ * @author  <a href=\"mailto:ram.chidambaram@telus.com\">Ram Chidambaram</a> \n+ */\n+public final class BinaryHeap \n+    implements PriorityQueue\n+{\n+    protected final static int      DEFAULT_CAPACITY   = 13;\n+\n+    protected int                   m_size;\n+    protected Comparable[]          m_elements;\n+    protected boolean               m_isMinHeap;\n+\n+    public BinaryHeap()\n+    {\n+        this( DEFAULT_CAPACITY, true );\n+    }\n+\n+    public BinaryHeap( final int capacity )\n+    {\n+        this( capacity, true );\n+    }\n+\n+    public BinaryHeap( final boolean isMinHeap )\n+    {\n+        this( DEFAULT_CAPACITY, isMinHeap );\n+    }\n+\n+    public BinaryHeap( final int capacity, final boolean isMinHeap )\n+    {\n+        m_isMinHeap = isMinHeap;\n+\n+        //+1 as 0 is noop\n+        m_elements = new Comparable[ capacity + 1 ];\n+    }\n+\n+    /**\n+     * Clear all elements from queue.\n+     */\n+    public void clear()\n+    {\n+        m_size = 0;\n+    }\n+\n+    /**\n+     * Test if queue is empty.\n+     *\n+     * @return true if queue is empty else false.\n+     */\n+    public boolean isEmpty()\n+    {\n+        return ( 0 == m_size );\n+    }\n+\n+    /**\n+     * Test if queue is full.\n+     *\n+     * @return true if queue is full else false.\n+     */\n+    public boolean isFull()\n+    {\n+        //+1 as element 0 is noop\n+        return ( m_elements.length == m_size+1 );\n+    }\n+\n+    /**\n+     * Insert an element into queue.\n+     *\n+     * @param element the element to be inserted\n+     */\n+    public void insert( final Comparable element )\n+    {\n+        if( isFull() ) grow();\n+\n+        //percolate element to it's place in tree\n+        if( m_isMinHeap ) percolateUpMinHeap( element );\n+        else percolateUpMaxHeap( element );\n+    }\n+\n+    /**\n+     * Return element on top of heap but don't remove it.\n+     *\n+     * @return the element at top of heap\n+     * @exception NoSuchElementException if isEmpty() == true\n+     */\n+    public Comparable peek() throws NoSuchElementException\n+    {\n+        if( isEmpty() ) throw new NoSuchElementException();\n+        else return m_elements[ 1 ];\n+    }\n+\n+    /**\n+     * Return element on top of heap and remove it.\n+     *\n+     * @return the element at top of heap\n+     * @exception NoSuchElementException if isEmpty() == true\n+     */\n+    public Comparable pop() throws NoSuchElementException\n+    {\n+        final Comparable result = peek();\n+        m_elements[ 1 ] = m_elements[ m_size-- ];\n+\n+        //set the unused element to 'null' so that the garbage collector \n+        //can free the object if not used anywhere else.(remove reference)\n+        m_elements[ m_size + 1 ] = null;\n+\n+        if( m_size != 0 )\n+        {\n+            //percolate top element to it's place in tree\n+            if( m_isMinHeap ) percolateDownMinHeap( 1 );\n+            else percolateDownMaxHeap( 1 );\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Percolate element down heap from top. \n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateDownMinHeap( final int index )\n+    {\n+        final Comparable element = m_elements[ index ];\n+\n+        int hole = index;\n+\n+        while( (hole * 2) <= m_size )\n+        {\n+            int child = hole * 2;\n+\n+            //if we have a right child and that child can not be percolated\n+            //up then move onto other child\n+            if( child != m_size && \n+                m_elements[ child + 1 ].compareTo( m_elements[ child ] ) < 0 )\n+            {\n+                child++;\n+            }\n+\n+            //if we found resting place of bubble then terminate search\n+            if( m_elements[ child ].compareTo( element ) >= 0 )\n+            {\n+                break;\n+            }\n+\n+            m_elements[ hole ] = m_elements[ child ];\n+            hole = child;\n+        }\n+        \n+        m_elements[ hole ] = element;\n+    }\n+\n+    /**\n+     * Percolate element down heap from top. \n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateDownMaxHeap( final int index )\n+    {\n+        final Comparable element = m_elements[ index ];\n+\n+        int hole = index;\n+\n+        while( (hole * 2) <= m_size )\n+        {\n+            int child = hole * 2;\n+\n+            //if we have a right child and that child can not be percolated\n+            //up then move onto other child\n+            if( child != m_size && \n+                m_elements[ child + 1 ].compareTo( m_elements[ child ] ) > 0 )\n+            {\n+                child++;\n+            }\n+\n+            //if we found resting place of bubble then terminate search\n+            if( m_elements[ child ].compareTo( element ) <= 0 )\n+            {\n+                break;\n+            }\n+\n+            m_elements[ hole ] = m_elements[ child ];\n+            hole = child;\n+        }\n+        \n+        m_elements[ hole ] = element;\n+    }\n+\n+    /**\n+     * Percolate element up heap from bottom. \n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMinHeap( final Comparable element )\n+    {\n+        int hole = ++m_size;\n+        \n+        m_elements[ hole ] = element;\n+\n+        while( hole > 1 &&\n+               element.compareTo( m_elements[ hole / 2 ] ) < 0 )\n+        {\n+            //save element that is being pushed down\n+            //as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            m_elements[ hole ] = m_elements[ next ];\n+            hole = next;\n+        }\n+\n+        m_elements[ hole ] = element;\n+    }\n+\n+    /**\n+     * Percolate element up heap from bottom. \n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMaxHeap( final Comparable element )\n+    {\n+        int hole = ++m_size;\n+\n+        while( hole > 1 &&\n+               element.compareTo( m_elements[ hole / 2 ] ) > 0 )\n+        {\n+            //save element that is being pushed down\n+            //as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            m_elements[ hole ] = m_elements[ next ];\n+            hole = next;\n+        }\n+\n+        m_elements[ hole ] = element;\n+    }\n+\n+    protected void grow()\n+    {\n+        final Comparable[] elements = \n+            new Comparable[ m_elements.length * 2 ]; \n+        System.arraycopy( m_elements, 0, elements, 0, m_elements.length );\n+        m_elements = elements;\n+    }\n+\n+    public String toString()\n+    {\n+        final StringBuffer sb = new StringBuffer();\n+\n+        sb.append( \"[ \" );\n+\n+        for( int i = 1; i < m_size + 1; i++ )\n+        {\n+            if( i != 1 ) sb.append( \", \" );\n+            sb.append( m_elements[ i ] );\n+        }\n+\n+        sb.append( \" ]\" );\n+\n+        return sb.toString();\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE file.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Miscelaneous utilities to manipulate Lists.\n+ *\n+ * @author  <a href=\"mailto:fede@apache.org\">Federico Barbieri</a>\n+ * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n+ */\n+public class ListUtils\n+{\n+    public static List intersection( final List list1, final List list2 ) \n+    {\n+        final ArrayList result = new ArrayList();\n+        final Iterator iterator = list2.iterator();\n+\n+        while( iterator.hasNext() ) \n+        {\n+            final Object o = iterator.next();\n+\n+            if ( list1.contains( o ) ) \n+            {\n+                result.add( o );\n+            }\n+        }\n+\n+        return result;\n+    }\n+    \n+    public static List subtract( final List list1, final List list2 ) \n+    {\n+        final ArrayList result = new ArrayList( list1 );\n+        final Iterator iterator = list2.iterator();\n+\n+        while( iterator.hasNext() ) \n+        {\n+            result.remove( iterator.next() );\n+        }\n+\n+        return result;\n+    }\n+    \n+    public static List sum( final List list1, final List list2 ) \n+    {\n+        return subtract( union( list1, list2 ), \n+                         intersection( list1, list2 ) );\n+    }\n+    \n+    public static List union( final List list1, final List list2 ) \n+    {\n+        final ArrayList result = new ArrayList( list1 );\n+        result.addAll( list2 );\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/PriorityQueue.java\n+/* \n+ * Copyright (C) The Apache Software Foundation. All rights reserved. \n+ * \n+ * This software is published under the terms of the Apache Software License \n+ * version 1.1, a copy of which has been included with this distribution in \n+ * the LICENSE file. \n+ */ \n+package org.apache.commons.collections;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Iterface for priority queues.\n+ * This interface does not dictate whether it is min or max heap.\n+ *\n+ * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a> \n+ */\n+public interface PriorityQueue\n+{\n+    /**\n+     * Clear all elements from queue.\n+     */\n+    void clear();\n+\n+    /**\n+     * Test if queue is empty.\n+     *\n+     * @return true if queue is empty else false.\n+     */\n+    boolean isEmpty();\n+\n+    /**\n+     * Insert an element into queue.\n+     *\n+     * @param element the element to be inserted\n+     */\n+    void insert( Comparable element );\n+\n+    /**\n+     * Return element on top of heap but don't remove it.\n+     *\n+     * @return the element at top of heap\n+     * @exception NoSuchElementException if isEmpty() == true\n+     */\n+    Comparable peek() throws NoSuchElementException;\n+\n+    /**\n+     * Return element on top of heap and remove it.\n+     *\n+     * @return the element at top of heap\n+     * @exception NoSuchElementException if isEmpty() == true\n+     */\n+    Comparable pop() throws NoSuchElementException;\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/SynchronizedPriorityQueue.java\n+/* \n+ * Copyright (C) The Apache Software Foundation. All rights reserved. \n+ * \n+ * This software is published under the terms of the Apache Software License \n+ * version 1.1, a copy of which has been included with this distribution in \n+ * the LICENSE file. \n+ */ \n+package org.apache.commons.collections;\n+\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * A thread safe version of the PriorityQueue.\n+ * Provides synchronized wrapper methods for all the methods \n+ * defined in the PriorityQueue interface.\n+ *\n+ * @author  <a href=\"mailto:ram.chidambaram@telus.com\">Ram Chidambaram</a> \n+ */\n+public final class SynchronizedPriorityQueue \n+    implements PriorityQueue\n+{\n+    protected final PriorityQueue   m_priorityQueue;\n+\n+    public SynchronizedPriorityQueue( final PriorityQueue priorityQueue )\n+    {\n+        m_priorityQueue = priorityQueue;\n+    }\n+\n+    /**\n+     * Clear all elements from queue.\n+     */\n+    public synchronized void clear()\n+    {\n+        m_priorityQueue.clear();\n+    }\n+\n+    /**\n+     * Test if queue is empty.\n+     *\n+     * @return true if queue is empty else false.\n+     */\n+    public synchronized boolean isEmpty()\n+    {\n+        return m_priorityQueue.isEmpty();\n+    }\n+\n+    /**\n+     * Insert an element into queue.\n+     *\n+     * @param element the element to be inserted\n+     */\n+    public synchronized void insert( final Comparable element )\n+    {\n+        m_priorityQueue.insert( element );\n+    }\n+\n+    /**\n+     * Return element on top of heap but don't remove it.\n+     *\n+     * @return the element at top of heap\n+     * @exception NoSuchElementException if isEmpty() == true\n+     */\n+    public synchronized Comparable peek() throws NoSuchElementException\n+    {\n+        return m_priorityQueue.peek();\n+    }\n+\n+    /**\n+     * Return element on top of heap and remove it.\n+     *\n+     * @return the element at top of heap\n+     * @exception NoSuchElementException if isEmpty() == true\n+     */\n+    public synchronized Comparable pop() throws NoSuchElementException\n+    {\n+        return m_priorityQueue.pop();\n+    }\n+\n+    public synchronized String toString()\n+    {\n+        return m_priorityQueue.toString();\n+    }\n+}", "timestamp": 987969397, "metainfo": ""}