{"sha": "2c15f6008092297ef89e29bbbfcc44765abd882e", "log": "Update licence Javadoc improvements Layout changes   ", "commit": "\n--- a/src/java/org/apache/commons/collections/FastHashMap.java\n+++ b/src/java/org/apache/commons/collections/FastHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.10 2002/10/12 22:15:18 scolebourne Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/10/12 22:15:18 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.11 2003/01/18 12:47:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  * <http://www.apache.org/>.\n  *\n  */\n-\n-\n package org.apache.commons.collections;\n-\n \n import java.util.Collection;\n import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n-\n \n /**\n  * <p>A customized implementation of <code>java.util.HashMap</code> designed\n  * <A Href=\"http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html\">\n  * Double-Checked Locking Idiom Is Broken Declartion</A>.</P>\n  *\n- * @since 1.0\n+ * @since Commons Collections 1.0\n+ * @version $Revision: 1.11 $ $Date: 2003/01/18 12:47:34 $\n+ * \n  * @author Craig R. McClanahan\n- * @version $Revision: 1.10 $ $Date: 2002/10/12 22:15:18 $\n  */\n-\n public class FastHashMap extends HashMap {\n \n-\n-    // ----------------------------------------------------------- Constructors\n-\n-\n-    /**\n-     * Construct a an empty map.\n+    /**\n+     * The underlying map we are managing.\n+     */\n+    protected HashMap map = null;\n+\n+    /**\n+     * Are we currently operating in \"fast\" mode?\n+     */\n+    protected boolean fast = false;\n+\n+    // Constructors\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Construct an empty map.\n      */\n     public FastHashMap() {\n-\n         super();\n         this.map = new HashMap();\n-\n-    }\n-\n+    }\n \n     /**\n      * Construct an empty map with the specified capacity.\n      *\n-     * @param capacity The initial capacity of the empty map\n+     * @param capacity  the initial capacity of the empty map\n      */\n     public FastHashMap(int capacity) {\n-\n         super();\n         this.map = new HashMap(capacity);\n-\n-    }\n-\n+    }\n \n     /**\n      * Construct an empty map with the specified capacity and load factor.\n      *\n-     * @param capacity The initial capacity of the empty map\n-     * @param factor The load factor of the new map\n+     * @param capacity  the initial capacity of the empty map\n+     * @param factor  the load factor of the new map\n      */\n     public FastHashMap(int capacity, float factor) {\n-\n         super();\n         this.map = new HashMap(capacity, factor);\n-\n-    }\n-\n+    }\n \n     /**\n      * Construct a new map with the same mappings as the specified map.\n      *\n-     * @param map The map whose mappings are to be copied\n+     * @param map  the map whose mappings are to be copied\n      */\n     public FastHashMap(Map map) {\n-\n         super();\n         this.map = new HashMap(map);\n-\n-    }\n-\n-\n-    // ----------------------------------------------------- Instance Variables\n-\n-\n-    /**\n-     * The underlying map we are managing.\n-     */\n-    protected HashMap map = null;\n-\n-\n-    // ------------------------------------------------------------- Properties\n-\n-\n-    /**\n-     * Are we operating in \"fast\" mode?\n-     */\n-    protected boolean fast = false;\n+    }\n+\n+\n+    // Property access\n+    // ----------------------------------------------------------------------\n \n     /**\n      *  Returns true if this map is operating in fast mode.\n     }\n \n \n-    // --------------------------------------------------------- Public Methods\n-\n+    // Map access\n+    // ----------------------------------------------------------------------\n+    // These methods can forward straight to the wrapped Map in 'fast' mode.\n+    // (because they are query methods)\n+\n+    /**\n+     * Return the value to which this map maps the specified key.  Returns\n+     * <code>null</code> if the map contains no mapping for this key, or if\n+     * there is a mapping with a value of <code>null</code>.  Use the\n+     * <code>containsKey()</code> method to disambiguate these cases.\n+     *\n+     * @param key  the key whose value is to be returned\n+     * @return the value mapped to that key, or null\n+     */\n+    public Object get(Object key) {\n+        if (fast) {\n+            return (map.get(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.get(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the number of key-value mappings in this map.\n+     * \n+     * @return the current size of the map\n+     */\n+    public int size() {\n+        if (fast) {\n+            return (map.size());\n+        } else {\n+            synchronized (map) {\n+                return (map.size());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this map contains no mappings.\n+     * \n+     * @return is the map currently empty\n+     */\n+    public boolean isEmpty() {\n+        if (fast) {\n+            return (map.isEmpty());\n+        } else {\n+            synchronized (map) {\n+                return (map.isEmpty());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this map contains a mapping for the\n+     * specified key.\n+     *\n+     * @param key  the key to be searched for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        if (fast) {\n+            return (map.containsKey(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsKey(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this map contains one or more keys mapping\n+     * to the specified value.\n+     *\n+     * @param value  the value to be searched for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        if (fast) {\n+            return (map.containsValue(value));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsValue(value));\n+            }\n+        }\n+    }\n+\n+    // Map modification\n+    // ----------------------------------------------------------------------\n+    // These methods perform special behaviour in 'fast' mode.\n+    // The map is cloned, updated and then assigned back.\n+    // See the comments at the top as to why this won't always work.\n+\n+    /**\n+     * Associate the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for this key, the old\n+     * value is replaced and returned.\n+     *\n+     * @param key  the key with which the value is to be associated\n+     * @param value  the value to be associated with this key\n+     * @return the value previously mapped to the key, or null\n+     */\n+    public Object put(Object key, Object value) {\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                Object result = temp.put(key, value);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.put(key, value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy all of the mappings from the specified map to this one, replacing\n+     * any mappings with the same keys.\n+     *\n+     * @param in  the map whose mappings are to be copied\n+     */\n+    public void putAll(Map in) {\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                temp.putAll(in);\n+                map = temp;\n+            }\n+        } else {\n+            synchronized (map) {\n+                map.putAll(in);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove any mapping for this key, and return any previously\n+     * mapped value.\n+     *\n+     * @param key  the key whose mapping is to be removed\n+     * @return the value removed, or null\n+     */\n+    public Object remove(Object key) {\n+        if (fast) {\n+            synchronized (this) {\n+                HashMap temp = (HashMap) map.clone();\n+                Object result = temp.remove(key);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.remove(key));\n+            }\n+        }\n+    }\n \n     /**\n      * Remove all mappings from this map.\n      */\n     public void clear() {\n-\n         if (fast) {\n             synchronized (this) {\n                 HashMap temp = (HashMap) map.clone();\n                 map.clear();\n             }\n         }\n-\n-    }\n-\n-\n-    /**\n-     * Return a shallow copy of this <code>FastHashMap</code> instance.\n-     * The keys and values themselves are not copied.\n-     */\n-    public Object clone() {\n-\n-        FastHashMap results = null;\n-        if (fast) {\n-            results = new FastHashMap(map);\n-        } else {\n-            synchronized (map) {\n-                results = new FastHashMap(map);\n-            }\n-        }\n-        results.setFast(getFast());\n-        return (results);\n-\n-    }\n-\n-\n-    /**\n-     * Return <code>true</code> if this map contains a mapping for the\n-     * specified key.\n-     *\n-     * @param key Key to be searched for\n-     */\n-    public boolean containsKey(Object key) {\n-\n-        if (fast) {\n-            return (map.containsKey(key));\n-        } else {\n-            synchronized (map) {\n-                return (map.containsKey(key));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return <code>true</code> if this map contains one or more keys mapping\n-     * to the specified value.\n-     *\n-     * @param value Value to be searched for\n-     */\n-    public boolean containsValue(Object value) {\n-\n-        if (fast) {\n-            return (map.containsValue(value));\n-        } else {\n-            synchronized (map) {\n-                return (map.containsValue(value));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return a collection view of the mappings contained in this map.  Each\n-     * element in the returned collection is a <code>Map.Entry</code>.\n-     */\n-    public Set entrySet() {\n-        return new EntrySet();\n-    }\n-\n-\n+    }\n+\n+    // Basic object methods\n+    // ----------------------------------------------------------------------\n+    \n     /**\n      * Compare the specified object with this list for equality.  This\n      * implementation uses exactly the code that is used to define the\n      * list equals function in the documentation for the\n      * <code>Map.equals</code> method.\n      *\n-     * @param o Object to be compared to this list\n+     * @param o  the object to be compared to this list\n+     * @return true if the two maps are equal\n      */\n     public boolean equals(Object o) {\n-\n         // Simple tests that require no synchronization\n-        if (o == this)\n+        if (o == this) {\n             return (true);\n-        else if (!(o instanceof Map))\n+        } else if (!(o instanceof Map)) {\n             return (false);\n+        }\n         Map mo = (Map) o;\n \n         // Compare the two maps for equality\n         if (fast) {\n-            if (mo.size() != map.size())\n+            if (mo.size() != map.size()) {\n                 return (false);\n-            java.util.Iterator i = map.entrySet().iterator();\n+            }\n+            Iterator i = map.entrySet().iterator();\n             while (i.hasNext()) {\n                 Map.Entry e = (Map.Entry) i.next();\n                 Object key = e.getKey();\n                 Object value = e.getValue();\n                 if (value == null) {\n-                    if (!(mo.get(key) == null && mo.containsKey(key)))\n+                    if (!(mo.get(key) == null && mo.containsKey(key))) {\n                         return (false);\n+                    }\n                 } else {\n-                    if (!value.equals(mo.get(key)))\n+                    if (!value.equals(mo.get(key))) {\n                         return (false);\n+                    }\n                 }\n             }\n             return (true);\n-        } else {\n-            synchronized (map) {\n-                if (mo.size() != map.size())\n+            \n+        } else {\n+            synchronized (map) {\n+                if (mo.size() != map.size()) {\n                     return (false);\n-                java.util.Iterator i = map.entrySet().iterator();\n+                }\n+                Iterator i = map.entrySet().iterator();\n                 while (i.hasNext()) {\n                     Map.Entry e = (Map.Entry) i.next();\n                     Object key = e.getKey();\n                     Object value = e.getValue();\n                     if (value == null) {\n-                        if (!(mo.get(key) == null && mo.containsKey(key)))\n+                        if (!(mo.get(key) == null && mo.containsKey(key))) {\n                             return (false);\n+                        }\n                     } else {\n-                        if (!value.equals(mo.get(key)))\n+                        if (!value.equals(mo.get(key))) {\n                             return (false);\n+                        }\n                     }\n                 }\n                 return (true);\n             }\n         }\n-\n-    }\n-\n-\n-    /**\n-     * Return the value to which this map maps the specified key.  Returns\n-     * <code>null</code> if the map contains no mapping for this key, or if\n-     * there is a mapping with a value of <code>null</code>.  Use the\n-     * <code>containsKey()</code> method to disambiguate these cases.\n-     *\n-     * @param key Key whose value is to be returned\n-     */\n-    public Object get(Object key) {\n-\n-        if (fast) {\n-            return (map.get(key));\n-        } else {\n-            synchronized (map) {\n-                return (map.get(key));\n-            }\n-        }\n-\n-    }\n-\n+    }\n \n     /**\n      * Return the hash code value for this map.  This implementation uses\n      * exactly the code that is used to define the list hash function in the\n      * documentation for the <code>Map.hashCode</code> method.\n+     * \n+     * @return suitable integer hashcode\n      */\n     public int hashCode() {\n-\n         if (fast) {\n             int h = 0;\n-            java.util.Iterator i = map.entrySet().iterator();\n-            while (i.hasNext())\n+            Iterator i = map.entrySet().iterator();\n+            while (i.hasNext()) {\n                 h += i.next().hashCode();\n+            }\n             return (h);\n         } else {\n             synchronized (map) {\n                 int h = 0;\n-                java.util.Iterator i = map.entrySet().iterator();\n-                while (i.hasNext())\n+                Iterator i = map.entrySet().iterator();\n+                while (i.hasNext()) {\n                     h += i.next().hashCode();\n+                }\n                 return (h);\n             }\n         }\n-\n-    }\n-\n-\n-    /**\n-     * Return <code>true</code> if this map contains no mappings.\n-     */\n-    public boolean isEmpty() {\n-\n-        if (fast) {\n-            return (map.isEmpty());\n-        } else {\n-            synchronized (map) {\n-                return (map.isEmpty());\n-            }\n-        }\n-\n-    }\n-\n+    }\n+\n+    /**\n+     * Return a shallow copy of this <code>FastHashMap</code> instance.\n+     * The keys and values themselves are not copied.\n+     * \n+     * @return a clone of this map\n+     */\n+    public Object clone() {\n+        FastHashMap results = null;\n+        if (fast) {\n+            results = new FastHashMap(map);\n+        } else {\n+            synchronized (map) {\n+                results = new FastHashMap(map);\n+            }\n+        }\n+        results.setFast(getFast());\n+        return (results);\n+    }\n+\n+    // Map views\n+    // ----------------------------------------------------------------------\n+    \n+    /**\n+     * Return a collection view of the mappings contained in this map.  Each\n+     * element in the returned collection is a <code>Map.Entry</code>.\n+     */\n+    public Set entrySet() {\n+        return new EntrySet();\n+    }\n \n     /**\n      * Return a set view of the keys contained in this map.\n         return new KeySet();\n     }\n \n-\n-    /**\n-     * Associate the specified value with the specified key in this map.\n-     * If the map previously contained a mapping for this key, the old\n-     * value is replaced and returned.\n-     *\n-     * @param key The key with which the value is to be associated\n-     * @param value The value to be associated with this key\n-     */\n-    public Object put(Object key, Object value) {\n-\n-        if (fast) {\n-            synchronized (this) {\n-                HashMap temp = (HashMap) map.clone();\n-                Object result = temp.put(key, value);\n-                map = temp;\n-                return (result);\n-            }\n-        } else {\n-            synchronized (map) {\n-                return (map.put(key, value));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Copy all of the mappings from the specified map to this one, replacing\n-     * any mappings with the same keys.\n-     *\n-     * @param in Map whose mappings are to be copied\n-     */\n-    public void putAll(Map in) {\n-\n-        if (fast) {\n-            synchronized (this) {\n-                HashMap temp = (HashMap) map.clone();\n-                temp.putAll(in);\n-                map = temp;\n-            }\n-        } else {\n-            synchronized (map) {\n-                map.putAll(in);\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Remove any mapping for this key, and return any previously\n-     * mapped value.\n-     *\n-     * @param key Key whose mapping is to be removed\n-     */\n-    public Object remove(Object key) {\n-\n-        if (fast) {\n-            synchronized (this) {\n-                HashMap temp = (HashMap) map.clone();\n-                Object result = temp.remove(key);\n-                map = temp;\n-                return (result);\n-            }\n-        } else {\n-            synchronized (map) {\n-                return (map.remove(key));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return the number of key-value mappings in this map.\n-     */\n-    public int size() {\n-\n-        if (fast) {\n-            return (map.size());\n-        } else {\n-            synchronized (map) {\n-                return (map.size());\n-            }\n-        }\n-\n-    }\n-\n-\n     /**\n      * Return a collection view of the values contained in this map.\n      */\n         return new Values();\n     }\n \n-\n+    // Map view inner classes\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Abstract collection implementation shared by ketSet(), values() and entrySet().\n+     */\n     private abstract class CollectionView implements Collection {\n \n         public CollectionView() {\n                 }\n             }\n         }\n-   }\n-\n-\n-   private class KeySet extends CollectionView implements Set {\n-\n-       protected Collection get(Map map) {\n-           return map.keySet();\n-       }\n-\n-       protected Object iteratorNext(Map.Entry entry) {\n-           return entry.getKey();\n-       }       \n-\n-   }\n-\n-\n-   private class Values extends CollectionView {\n-\n-       protected Collection get(Map map) {\n-           return map.values();\n-       }\n-\n-       protected Object iteratorNext(Map.Entry entry) {\n-           return entry.getValue();\n-       }\n-   }\n-\n-\n-   private class EntrySet extends CollectionView implements Set {\n-\n-       protected Collection get(Map map) {\n-           return map.entrySet();\n-       }\n-\n-\n-       protected Object iteratorNext(Map.Entry entry) {\n-           return entry;\n-       }\n-\n-   }\n+    }\n+\n+    /**\n+     * Set implementation over the keys of the FastHashMap\n+     */\n+    private class KeySet extends CollectionView implements Set {\n+    \n+        protected Collection get(Map map) {\n+            return map.keySet();\n+        }\n+    \n+        protected Object iteratorNext(Map.Entry entry) {\n+            return entry.getKey();\n+        }\n+    \n+    }\n+    \n+    /**\n+     * Collection implementation over the values of the FastHashMap\n+     */\n+    private class Values extends CollectionView {\n+    \n+        protected Collection get(Map map) {\n+            return map.values();\n+        }\n+    \n+        protected Object iteratorNext(Map.Entry entry) {\n+            return entry.getValue();\n+        }\n+    }\n+    \n+    /**\n+     * Set implementation over the entries of the FastHashMap\n+     */\n+    private class EntrySet extends CollectionView implements Set {\n+    \n+        protected Collection get(Map map) {\n+            return map.entrySet();\n+        }\n+    \n+        protected Object iteratorNext(Map.Entry entry) {\n+            return entry;\n+        }\n+    \n+    }\n \n }", "timestamp": 1042894054, "metainfo": ""}