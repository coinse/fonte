{"sha": "4433733ff18fe814d1c4de8e8b3902c797ac5992", "log": "Extract AbstractReferenceMap from ReferenceMap   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n+/*\n+ *  Copyright 2002-2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+\n+/**\n+ * An abstract implementation of a hash-based map that allows the entries to\n+ * be removed by the garbage collector.\n+ * <p>\n+ * This class implements all the features necessary for a subclass reference\n+ * hash-based map. Key-value entries are stored in instances of the\n+ * <code>ReferenceEntry</code> class which can be overridden and replaced.\n+ * The iterators can similarly be replaced, without the need to replace the KeySet,\n+ * EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * When you construct an <code>AbstractReferenceMap</code>, you can specify what\n+ * kind of references are used to store the map's keys and values.\n+ * If non-hard references are used, then the garbage collector can remove\n+ * mappings if a key or value becomes unreachable, or if the JVM's memory is\n+ * running low. For information on how the different reference types behave,\n+ * see {@link Reference}.\n+ * <p>\n+ * Different types of references can be specified for keys and values.\n+ * The keys can be configured to be weak but the values hard,\n+ * in which case this class will behave like a\n+ * <a href=\"http://java.sun.com/j2se/1.4/docs/api/java/util/WeakHashMap.html\">\n+ * <code>WeakHashMap</code></a>. However, you can also specify hard keys and\n+ * weak values, or any other combination. The default constructor uses\n+ * hard keys and soft values, providing a memory-sensitive cache.\n+ * <p>\n+ * This {@link Map} implementation does <i>not</i> allow null elements.\n+ * Attempting to add a null key or value to the map will raise a\n+ * <code>NullPointerException</code>.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * This implementation is not synchronized.\n+ * You can use {@link java.util.Collections#synchronizedMap} to \n+ * provide synchronized access to a <code>ReferenceMap</code>.\n+ *\n+ * @see java.lang.ref.Reference\n+ * @since Commons Collections 3.1 (from ReferenceMap in 3.0)\n+ * @version $Revision: 1.1 $ $Date: 2004/04/09 22:18:18 $\n+ * \n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractReferenceMap extends AbstractHashedMap {\n+\n+    /** Constant indicating that hard references should be used */\n+    public static final int HARD = 0;\n+\n+    /** Constant indicating that soft references should be used */\n+    public static final int SOFT = 1;\n+\n+    /** Constant indicating that weak references should be used */\n+    public static final int WEAK = 2;\n+\n+    /**\n+     * The reference type for keys.  Must be HARD, SOFT, WEAK.\n+     * @serial\n+     */\n+    private int keyType;\n+\n+    /**\n+     * The reference type for values.  Must be HARD, SOFT, WEAK.\n+     * @serial\n+     */\n+    private int valueType;\n+\n+    /**\n+     * Should the value be automatically purged when the associated key has been collected?\n+     */\n+    private boolean purgeValues;\n+\n+    /**\n+     * ReferenceQueue used to eliminate stale mappings.\n+     * See purge.\n+     */\n+    private transient ReferenceQueue queue = new ReferenceQueue();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor used during deserialization.\n+     */\n+    protected AbstractReferenceMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructs a new empty map with the specified reference types,\n+     * load factor and initial capacity.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n+     *   key is garbage collected \n+     */\n+    protected AbstractReferenceMap(\n+            int keyType, int valueType, int capacity, \n+            float loadFactor, boolean purgeValues) {\n+        super(capacity, loadFactor);\n+        verify(\"keyType\", keyType);\n+        verify(\"valueType\", valueType);\n+        this.keyType = keyType;\n+        this.valueType = valueType;\n+        this.purgeValues = purgeValues;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the type int is a valid value.\n+     * \n+     * @param name  the name for error messages\n+     * @param type  the type value to check\n+     * @throws IllegalArgumentException if the value if invalid\n+     */\n+    private static void verify(String name, int type) {\n+        if ((type < HARD) || (type > WEAK)) {\n+            throw new IllegalArgumentException(name + \" must be HARD, SOFT, WEAK.\");\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    /**\n+//     * Writes this object to the given output stream.\n+//     *\n+//     * @param out  the output stream to write to\n+//     * @throws IOException  if the stream raises it\n+//     */\n+//    private void writeObject(ObjectOutputStream out) throws IOException {\n+//        out.defaultWriteObject();\n+//        out.writeInt(data.length);\n+//\n+//        // Have to use null-terminated list because size might shrink\n+//        // during iteration\n+//\n+//        for (Iterator iter = entrySet().iterator(); iter.hasNext();) {\n+//            Map.Entry entry = (Map.Entry)iter.next();\n+//            out.writeObject(entry.getKey());\n+//            out.writeObject(entry.getValue());\n+//        }\n+//        out.writeObject(null);\n+//    }\n+//\n+//\n+//    /**\n+//     * Reads the contents of this object from the given input stream.\n+//     *\n+//     * @param in  the input stream to read from\n+//     * @throws IOException  if the stream raises it\n+//     * @throws ClassNotFoundException  if the stream raises it\n+//     */\n+//    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+//        in.defaultReadObject();\n+//        data = new HashEntry[in.readInt()];\n+//        threshold = calculateThreshold(data.length, loadFactor);\n+//        queue = new ReferenceQueue();\n+//        Object key = in.readObject();\n+//        while (key != null) {\n+//            Object value = in.readObject();\n+//            put(key, value);\n+//            key = in.readObject();\n+//        }\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the size of the map.\n+     * \n+     * @return the size\n+     */\n+    public int size() {\n+        purgeBeforeRead();\n+        return super.size();\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     * \n+     * @return true if the map is currently size zero\n+     */\n+    public boolean isEmpty() {\n+        purgeBeforeRead();\n+        return super.isEmpty();\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        purgeBeforeRead();\n+        Entry entry = getEntry(key);\n+        if (entry == null) {\n+            return false;\n+        }\n+        return (entry.getValue() != null);\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        purgeBeforeRead();\n+        if (value == null) {\n+            return false;\n+        }\n+        return super.containsValue(value);\n+    }\n+\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key) {\n+        purgeBeforeRead();\n+        Entry entry = getEntry(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+\n+\n+    /**\n+     * Puts a key-value mapping into this map.\n+     * Neither the key nor the value may be null.\n+     * \n+     * @param key  the key to add, must not be null\n+     * @param value  the value to add, must not be null\n+     * @return the value previously mapped to this key, null if none\n+     * @throws NullPointerException if either the key or value is null\n+     */\n+    public Object put(Object key, Object value) {\n+        if (key == null) {\n+            throw new NullPointerException(\"null keys not allowed\");\n+        }\n+        if (value == null) {\n+            throw new NullPointerException(\"null values not allowed\");\n+        }\n+\n+        purgeBeforeWrite();\n+        return super.put(key, value);\n+    }\n+    \n+    /**\n+     * Removes the specified mapping from this map.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key) {\n+        if (key == null) {\n+            return null;\n+        }\n+        purgeBeforeWrite();\n+        return super.remove(key);\n+    }\n+\n+    /**\n+     * Clears this map.\n+     */\n+    public void clear() {\n+        super.clear();\n+        while (queue.poll() != null) {} // drain the queue\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets a MapIterator over the reference map.\n+     * The iterator only returns valid key/value pairs.\n+     * \n+     * @return a map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        return new ReferenceMapIterator(this);\n+    }\n+\n+    /**\n+     * Returns a set view of this map's entries.\n+     * An iterator returned entry is valid until <code>next()</code> is called again.\n+     * The <code>setValue()</code> method on the <code>toArray</code> entries has no effect.\n+     *\n+     * @return a set view of this map's entries\n+     */\n+    public Set entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new ReferenceEntrySet(this);\n+        }\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Returns a set view of this map's keys.\n+     *\n+     * @return a set view of this map's keys\n+     */\n+    public Set keySet() {\n+        if (keySet == null) {\n+            keySet = new ReferenceKeySet(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Returns a collection view of this map's values.\n+     *\n+     * @return a set view of this map's values\n+     */\n+    public Collection values() {\n+        if (values == null) {\n+            values = new ReferenceValues(this);\n+        }\n+        return values;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Purges stale mappings from this map before read operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     */\n+    protected void purgeBeforeRead() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map before write operations.\n+     * <p>\n+     * This implementation calls {@link #purge()} to maintain a consistent state.\n+     */\n+    protected void purgeBeforeWrite() {\n+        purge();\n+    }\n+\n+    /**\n+     * Purges stale mappings from this map.\n+     * <p>\n+     * Note that this method is not synchronized!  Special\n+     * care must be taken if, for instance, you want stale\n+     * mappings to be removed on a periodic basis by some\n+     * background thread.\n+     */\n+    protected void purge() {\n+        Reference ref = queue.poll();\n+        while (ref != null) {\n+            purge(ref);\n+            ref = queue.poll();\n+        }\n+    }\n+\n+    /**\n+     * Purges the specified reference.\n+     * \n+     * @param ref  the reference to purge\n+     */\n+    protected void purge(Reference ref) {\n+        // The hashCode of the reference is the hashCode of the\n+        // mapping key, even if the reference refers to the \n+        // mapping value...\n+        int hash = ref.hashCode();\n+        int index = hashIndex(hash, data.length);\n+        HashEntry previous = null;\n+        HashEntry entry = data[index];\n+        while (entry != null) {\n+            if (((ReferenceEntry) entry).purge(ref)) {\n+                if (previous == null) {\n+                    data[index] = entry.next;\n+                } else {\n+                    previous.next = entry.next;\n+                }\n+                this.size--;\n+                return;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    protected HashEntry getEntry(Object key) {\n+        if (key == null) {\n+            return null;\n+        } else {\n+            return super.getEntry(key);\n+        }\n+    }\n+\n+    /**\n+     * Compares two keys, in internal converted form, to see if they are equal.\n+     * <p>\n+     * This implementation converts the key from the entry to a real reference\n+     * before comparison.\n+     * \n+     * @param key1  the first key to compare passed in from outside\n+     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n+     * @return true if equal\n+     * @since Commons Collections 3.1\n+     */\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n+        return (key1 == key2 || key1.equals(key2));\n+    }\n+    \n+    /**\n+     * Creates a ReferenceEntry instead of a HashEntry.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     * @since Commons Collections 3.1\n+     */\n+    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n+        return new ReferenceEntry(this, next, hashCode, key, value);\n+    }\n+\n+    /**\n+     * Creates an entry set iterator.\n+     * \n+     * @return the entrySet iterator\n+     * @since Commons Collections 3.1\n+     */\n+    protected Iterator createEntrySetIterator() {\n+        return new ReferenceEntrySetIterator(this);\n+    }\n+\n+    /**\n+     * Creates an key set iterator.\n+     * \n+     * @return the keySet iterator\n+     * @since Commons Collections 3.1\n+     */\n+    protected Iterator createKeySetIterator() {\n+        return new ReferenceKeySetIterator(this);\n+    }\n+\n+    /**\n+     * Creates an values iterator.\n+     * \n+     * @return the values iterator\n+     * @since Commons Collections 3.1\n+     */\n+    protected Iterator createValuesIterator() {\n+        return new ReferenceValuesIterator(this);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * EntrySet implementation.\n+     */\n+    static class ReferenceEntrySet extends EntrySet {\n+        \n+        protected ReferenceEntrySet(AbstractHashedMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        public Object[] toArray(Object[] arr) {\n+            // special implementation to handle disappearing entries\n+            ArrayList list = new ArrayList();\n+            Iterator iterator = iterator();\n+            while (iterator.hasNext()) {\n+                Entry e = (Entry) iterator.next();\n+                list.add(new DefaultMapEntry(e.getKey(), e.getValue()));\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * KeySet implementation.\n+     */\n+    static class ReferenceKeySet extends KeySet {\n+        \n+        protected ReferenceKeySet(AbstractHashedMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        public Object[] toArray(Object[] arr) {\n+            // special implementation to handle disappearing keys\n+            List list = new ArrayList(parent.size());\n+            for (Iterator it = iterator(); it.hasNext(); ) {\n+                list.add(it.next());\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Values implementation.\n+     */\n+    static class ReferenceValues extends Values {\n+        \n+        protected ReferenceValues(AbstractHashedMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object[] toArray() {\n+            return toArray(new Object[0]);\n+        }\n+\n+        public Object[] toArray(Object[] arr) {\n+            // special implementation to handle disappearing values\n+            List list = new ArrayList(parent.size());\n+            for (Iterator it = iterator(); it.hasNext(); ) {\n+                list.add(it.next());\n+            }\n+            return list.toArray(arr);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * A MapEntry implementation for the map.\n+     * <p>\n+     * If getKey() or getValue() returns null, it means\n+     * the mapping is stale and should be removed.\n+     */\n+    protected static class ReferenceEntry extends HashEntry {\n+        /** The parent map */\n+        protected final AbstractReferenceMap parent;\n+\n+        /**\n+         * Creates a new entry object for the ReferenceMap.\n+         * \n+         * @param parent  the parent map\n+         * @param next  the next entry in the hash bucket\n+         * @param hashCode  the hash code of the key\n+         * @param key  the key\n+         * @param value  the value\n+         */\n+        public ReferenceEntry(AbstractReferenceMap parent, HashEntry next, int hashCode, Object key, Object value) {\n+            super(next, hashCode, null, null);\n+            this.parent = parent;\n+            this.key = toReference(parent.keyType, key, hashCode);\n+            this.value = toReference(parent.valueType, value, hashCode);\n+        }\n+\n+        public Object getKey() {\n+            return (parent.keyType > HARD) ? ((Reference) key).get() : key;\n+        }\n+\n+        public Object getValue() {\n+            return (parent.valueType > HARD) ? ((Reference) value).get() : value;\n+        }\n+\n+        public Object setValue(Object obj) {\n+            Object old = getValue();\n+            if (parent.valueType > HARD) {\n+                ((Reference)value).clear();\n+            }\n+            value = toReference(parent.valueType, obj, hashCode);\n+            return old;\n+        }\n+\n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            \n+            Map.Entry entry = (Map.Entry)obj;\n+            Object key = entry.getKey();\n+            Object value = entry.getValue();\n+            if ((key == null) || (value == null)) {\n+                return false;\n+            }\n+            return key.equals(getKey()) && value.equals(getValue());\n+        }\n+\n+        /**\n+         * Constructs a reference of the given type to the given referent.\n+         * The reference is registered with the queue for later purging.\n+         *\n+         * @param type  HARD, SOFT or WEAK\n+         * @param referent  the object to refer to\n+         * @param hash  the hash code of the <i>key</i> of the mapping;\n+         *    this number might be different from referent.hashCode() if\n+         *    the referent represents a value and not a key\n+         * @since Commons Collections 3.1\n+         */\n+        protected Object toReference(int type, Object referent, int hash) {\n+            switch (type) {\n+                case HARD: return referent;\n+                case SOFT: return new SoftRef(hash, referent, parent.queue);\n+                case WEAK: return new WeakRef(hash, referent, parent.queue);\n+                default: throw new Error();\n+            }\n+        }\n+\n+        /**\n+         * Purges the specified reference\n+         * @param ref  the reference to purge\n+         * @return true or false\n+         */\n+        boolean purge(Reference ref) {\n+            boolean r = (parent.keyType > HARD) && (key == ref);\n+            r = r || ((parent.valueType > HARD) && (value == ref));\n+            if (r) {\n+                if (parent.keyType > HARD) {\n+                    ((Reference)key).clear();\n+                }\n+                if (parent.valueType > HARD) {\n+                    ((Reference)value).clear();\n+                } else if (parent.purgeValues) {\n+                    value = null;\n+                }\n+            }\n+            return r;\n+        }\n+\n+        /**\n+         * Gets the next entry in the bucket.\n+         * \n+         * @return the next entry in the bucket\n+         */\n+        protected ReferenceEntry next() {\n+            return (ReferenceEntry) next;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The EntrySet iterator.\n+     */\n+    static class ReferenceEntrySetIterator implements Iterator {\n+        /** The parent map */\n+        final AbstractReferenceMap parent;\n+        \n+        // These fields keep track of where we are in the table.\n+        int index;\n+        ReferenceEntry entry;\n+        ReferenceEntry previous;\n+\n+        // These Object fields provide hard references to the\n+        // current and next entry; this assures that if hasNext()\n+        // returns true, next() will actually return a valid element.\n+        Object nextKey, nextValue;\n+        Object currentKey, currentValue;\n+\n+        int expectedModCount;\n+\n+        public ReferenceEntrySetIterator(AbstractReferenceMap parent) {\n+            super();\n+            this.parent = parent;\n+            index = (parent.size() != 0 ? parent.data.length : 0);\n+            // have to do this here!  size() invocation above\n+            // may have altered the modCount.\n+            expectedModCount = parent.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            checkMod();\n+            while (nextNull()) {\n+                ReferenceEntry e = entry;\n+                int i = index;\n+                while ((e == null) && (i > 0)) {\n+                    i--;\n+                    e = (ReferenceEntry) parent.data[i];\n+                }\n+                entry = e;\n+                index = i;\n+                if (e == null) {\n+                    currentKey = null;\n+                    currentValue = null;\n+                    return false;\n+                }\n+                nextKey = e.getKey();\n+                nextValue = e.getValue();\n+                if (nextNull()) {\n+                    entry = entry.next();\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private void checkMod() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        private boolean nextNull() {\n+            return (nextKey == null) || (nextValue == null);\n+        }\n+\n+        protected ReferenceEntry nextEntry() {    \n+            checkMod();\n+            if (nextNull() && !hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            previous = entry;\n+            entry = entry.next();\n+            currentKey = nextKey;\n+            currentValue = nextValue;\n+            nextKey = null;\n+            nextValue = null;\n+            return previous;\n+        }\n+\n+        protected ReferenceEntry currentEntry() {\n+            checkMod();\n+            return previous;\n+        }\n+        \n+        public Object next() {\n+            return nextEntry();\n+        }\n+\n+        public void remove() {\n+            checkMod();\n+            if (previous == null) {\n+                throw new IllegalStateException();\n+            }\n+            parent.remove(currentKey);\n+            previous = null;\n+            currentKey = null;\n+            currentValue = null;\n+            expectedModCount = parent.modCount;\n+        }\n+    }\n+\n+    /**\n+     * The keySet iterator.\n+     */\n+    static class ReferenceKeySetIterator extends ReferenceEntrySetIterator {\n+        \n+        ReferenceKeySetIterator(AbstractReferenceMap parent) {\n+            super(parent);\n+        }\n+        \n+        public Object next() {\n+            return nextEntry().getKey();\n+        }\n+    }\n+\n+    /**\n+     * The values iterator.\n+     */\n+    static class ReferenceValuesIterator extends ReferenceEntrySetIterator {\n+        \n+        ReferenceValuesIterator(AbstractReferenceMap parent) {\n+            super(parent);\n+        }\n+        \n+        public Object next() {\n+            return nextEntry().getValue();\n+        }\n+    }\n+\n+    /**\n+     * The MapIterator implementation.\n+     */\n+    static class ReferenceMapIterator extends ReferenceEntrySetIterator implements MapIterator {\n+        \n+        protected ReferenceMapIterator(AbstractReferenceMap parent) {\n+            super(parent);\n+        }\n+\n+        public Object next() {\n+            return nextEntry().getKey();\n+        }\n+\n+        public Object getKey() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public Object getValue() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public Object setValue(Object value) {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    // These two classes store the hashCode of the key of\n+    // of the mapping, so that after they're dequeued a quick\n+    // lookup of the bucket in the table can occur.\n+\n+    /**\n+     * A soft reference holder.\n+     */\n+    static class SoftRef extends SoftReference {\n+        private int hash;\n+\n+        public SoftRef(int hash, Object r, ReferenceQueue q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+    /**\n+     * A weak reference holder.\n+     */\n+    static class WeakRef extends WeakReference {\n+        private int hash;\n+\n+        public WeakRef(int hash, Object r, ReferenceQueue q) {\n+            super(r, q);\n+            this.hash = hash;\n+        }\n+\n+        public int hashCode() {\n+            return hash;\n+        }\n+    }\n+\n+\n+}\n--- a/src/java/org/apache/commons/collections/map/ReferenceMap.java\n+++ b/src/java/org/apache/commons/collections/map/ReferenceMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.ConcurrentModificationException;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-\n-import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n \n /**\n  * A <code>Map</code> implementation that allows mappings to be\n  * This {@link Map} implementation does <i>not</i> allow null elements.\n  * Attempting to add a null key or value to the map will raise a <code>NullPointerException</code>.\n  * <p>\n- * As usual, this implementation is not synchronized.\n+ * This implementation is not synchronized.\n  * You can use {@link java.util.Collections#synchronizedMap} to \n  * provide synchronized access to a <code>ReferenceMap</code>.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n  * <p>\n  * NOTE: As from Commons Collections 3.1 this map extends <code>AbstractHashedMap</code>\n  * (previously it extended AbstractMap). As a result, the implementation is now\n  * @see java.lang.ref.Reference\n  * \n  * @since Commons Collections 3.0 (previously in main package v2.1)\n- * @version $Revision: 1.11 $ $Date: 2004/04/01 00:07:48 $\n+ * @version $Revision: 1.12 $ $Date: 2004/04/09 22:18:18 $\n  * \n  * @author Paul Jack\n  * @author Stephen Colebourne\n  */\n-public class ReferenceMap extends AbstractHashedMap {\n+public class ReferenceMap extends AbstractReferenceMap {\n \n     /**\n-     *  For serialization.\n-     */\n-    private static final long serialVersionUID = -3370601314380922368L;\n-\n-    /**\n-     *  Constant indicating that hard references should be used.\n-     */\n-    public static final int HARD = 0;\n-\n-    /**\n-     *  Constant indicating that soft references should be used.\n-     */\n-    public static final int SOFT = 1;\n-\n-    /**\n-     *  Constant indicating that weak references should be used.\n-     */\n-    public static final int WEAK = 2;\n-\n-    // --- serialized instance variables:\n-\n-    /**\n-     *  The reference type for keys.  Must be HARD, SOFT, WEAK.\n-     *  Note: I originally marked this field as final, but then this class\n-     *   didn't compile under JDK1.2.2.\n-     *  @serial\n-     */\n-    private int keyType;\n-\n-    /**\n-     *  The reference type for values.  Must be HARD, SOFT, WEAK.\n-     *  Note: I originally marked this field as final, but then this class\n-     *   didn't compile under JDK1.2.2.\n-     *  @serial\n-     */\n-    private int valueType;\n-\n-    /**\n-     *  The threshold variable is calculated by multiplying\n-     *  table.length and loadFactor.  \n-     *  Note: I originally marked this field as final, but then this class\n-     *   didn't compile under JDK1.2.2.\n-     *  @serial\n-     */\n-    private float loadFactor;\n-    \n-    /**\n-     * Should the value be automatically purged when the associated key has been collected?\n-     */\n-    private boolean purgeValues = false;\n-\n-    // -- Non-serialized instance variables\n-\n-    /**\n-     *  ReferenceQueue used to eliminate stale mappings.\n-     *  See purge.\n-     */\n-    private transient ReferenceQueue queue = new ReferenceQueue();\n-\n-    /**\n-     *  Constructs a new <code>ReferenceMap</code> that will\n-     *  use hard references to keys and soft references to values.\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use hard references to keys and soft references to values.\n      */\n     public ReferenceMap() {\n-        this(HARD, SOFT);\n+        super(HARD, SOFT, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n     }\n \n     /**\n-     *  Constructs a new <code>ReferenceMap</code> that will\n-     *  use the specified types of references.\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use the specified types of references.\n      *\n-     *  @param keyType  the type of reference to use for keys;\n+     * @param keyType  the type of reference to use for keys;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param valueType  the type of reference to use for values;\n+     * @param valueType  the type of reference to use for values;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param purgeValues should the value be automatically purged when the \n+     */\n+    public ReferenceMap(int keyType, int valueType) {\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, false);\n+    }\n+\n+    /**\n+     * Constructs a new <code>ReferenceMap</code> that will\n+     * use the specified types of references.\n+     *\n+     * @param keyType  the type of reference to use for keys;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param valueType  the type of reference to use for values;\n+     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param purgeValues should the value be automatically purged when the \n      *   key is garbage collected \n      */\n     public ReferenceMap(int keyType, int valueType, boolean purgeValues) {\n-        this(keyType, valueType);\n-        this.purgeValues = purgeValues;\n+        super(keyType, valueType, DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, purgeValues);\n     }\n \n     /**\n-     *  Constructs a new <code>ReferenceMap</code> that will\n-     *  use the specified types of references.\n+     * Constructs a new <code>ReferenceMap</code> with the\n+     * specified reference types, load factor and initial\n+     * capacity.\n      *\n-     *  @param keyType  the type of reference to use for keys;\n+     * @param keyType  the type of reference to use for keys;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param valueType  the type of reference to use for values;\n+     * @param valueType  the type of reference to use for values;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n      */\n-    public ReferenceMap(int keyType, int valueType) {\n-        this(keyType, valueType, 16, 0.75f);\n+    public ReferenceMap(int keyType, int valueType, int capacity, float loadFactor) {\n+        super(keyType, valueType, capacity, loadFactor, false);\n     }\n \n     /**\n-     *  Constructs a new <code>ReferenceMap</code> with the\n-     *  specified reference types, load factor and initial\n-     *  capacity.\n+     * Constructs a new <code>ReferenceMap</code> with the\n+     * specified reference types, load factor and initial\n+     * capacity.\n      *\n-     *  @param keyType  the type of reference to use for keys;\n+     * @param keyType  the type of reference to use for keys;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param valueType  the type of reference to use for values;\n+     * @param valueType  the type of reference to use for values;\n      *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param capacity  the initial capacity for the map\n-     *  @param loadFactor  the load factor for the map\n-     *  @param purgeValues should the value be automatically purged when the \n+     * @param capacity  the initial capacity for the map\n+     * @param loadFactor  the load factor for the map\n+     * @param purgeValues  should the value be automatically purged when the \n      *   key is garbage collected \n      */\n-    public ReferenceMap(int keyType, int valueType, int capacity, \n+    public ReferenceMap(int keyType, int valueType, int capacity,\n                         float loadFactor, boolean purgeValues) {\n-        this(keyType, valueType, capacity, loadFactor);\n-        this.purgeValues = purgeValues;\n+        super(keyType, valueType, capacity, loadFactor, purgeValues);\n     }\n \n-    /**\n-     *  Constructs a new <code>ReferenceMap</code> with the\n-     *  specified reference types, load factor and initial\n-     *  capacity.\n-     *\n-     *  @param keyType  the type of reference to use for keys;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param valueType  the type of reference to use for values;\n-     *   must be {@link #HARD}, {@link #SOFT}, {@link #WEAK}\n-     *  @param capacity  the initial capacity for the map\n-     *  @param loadFactor  the load factor for the map\n-     */\n-    public ReferenceMap(int keyType, int valueType, int capacity, float loadFactor) {\n-        super(capacity, loadFactor);\n-\n-        verify(\"keyType\", keyType);\n-        verify(\"valueType\", valueType);\n-        this.keyType = keyType;\n-        this.valueType = valueType;\n-    }\n-\n-    /**\n-     * Checks the type int is a valid value.\n-     * \n-     * @param name  the name for error messages\n-     * @param type  the type value to check\n-     * @throws IllegalArgumentException if the value if invalid\n-     */\n-    private static void verify(String name, int type) {\n-        if ((type < HARD) || (type > WEAK)) {\n-            throw new IllegalArgumentException(name + \" must be HARD, SOFT, WEAK.\");\n-        }\n-    }\n-\n-    /**\n-     *  Writes this object to the given output stream.\n-     *\n-     *  @param out  the output stream to write to\n-     *  @throws IOException  if the stream raises it\n-     */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n-        out.defaultWriteObject();\n-        out.writeInt(data.length);\n-\n-        // Have to use null-terminated list because size might shrink\n-        // during iteration\n-\n-        for (Iterator iter = entrySet().iterator(); iter.hasNext();) {\n-            Map.Entry entry = (Map.Entry)iter.next();\n-            out.writeObject(entry.getKey());\n-            out.writeObject(entry.getValue());\n-        }\n-        out.writeObject(null);\n-    }\n-\n-\n-    /**\n-     *  Reads the contents of this object from the given input stream.\n-     *\n-     *  @param in  the input stream to read from\n-     *  @throws IOException  if the stream raises it\n-     *  @throws ClassNotFoundException  if the stream raises it\n-     */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        data = new HashEntry[in.readInt()];\n-        threshold = calculateThreshold(data.length, loadFactor);\n-        queue = new ReferenceQueue();\n-        Object key = in.readObject();\n-        while (key != null) {\n-            Object value = in.readObject();\n-            put(key, value);\n-            key = in.readObject();\n-        }\n-    }\n-\n-    /**\n-     * Gets the entry mapped to the key specified.\n-     * \n-     * @param key  the key\n-     * @return the entry, null if no match\n-     * @since Commons Collections 3.1\n-     */\n-    protected HashEntry getEntry(Object key) {\n-        if (key == null) {\n-            return null;\n-        } else {\n-            return super.getEntry(key);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Purges stale mappings from this map before read operations.\n-     * <p>\n-     * This implementation calls {@link #purge()} to maintain a consistent state.\n-     * \n-     * @since Commons Collections 3.1\n-     */\n-    protected void purgeBeforeRead() {\n-        purge();\n-    }\n-\n-    /**\n-     * Purges stale mappings from this map before write operations.\n-     * <p>\n-     * This implementation calls {@link #purge()} to maintain a consistent state.\n-     * \n-     * @since Commons Collections 3.1\n-     */\n-    protected void purgeBeforeWrite() {\n-        purge();\n-    }\n-\n-    /**\n-     * Purges stale mappings from this map.\n-     * <p>\n-     * Note that this method is not synchronized!  Special\n-     * care must be taken if, for instance, you want stale\n-     * mappings to be removed on a periodic basis by some\n-     * background thread.\n-     * \n-     * @since Commons Collections 3.1\n-     */\n-    protected void purge() {\n-        Reference ref = queue.poll();\n-        while (ref != null) {\n-            purge(ref);\n-            ref = queue.poll();\n-        }\n-    }\n-\n-    private void purge(Reference ref) {\n-        // The hashCode of the reference is the hashCode of the\n-        // mapping key, even if the reference refers to the \n-        // mapping value...\n-        int hash = ref.hashCode();\n-        int index = hashIndex(hash, data.length);\n-        HashEntry previous = null;\n-        HashEntry entry = data[index];\n-        while (entry != null) {\n-            if (((ReferenceEntry) entry).purge(ref)) {\n-                if (previous == null) {\n-                    data[index] = entry.next;\n-                } else {\n-                    previous.next = entry.next;\n-                }\n-                this.size--;\n-                return;\n-            }\n-            previous = entry;\n-            entry = entry.next;\n-        }\n-\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the size of the map.\n-     * \n-     * @return the size\n-     */\n-    public int size() {\n-        purgeBeforeRead();\n-        return super.size();\n-    }\n-\n-    /**\n-     * Checks whether the map is currently empty.\n-     * \n-     * @return true if the map is currently size zero\n-     */\n-    public boolean isEmpty() {\n-        purgeBeforeRead();\n-        return super.isEmpty();\n-    }\n-\n-    /**\n-     * Checks whether the map contains the specified key.\n-     * \n-     * @param key  the key to search for\n-     * @return true if the map contains the key\n-     */\n-    public boolean containsKey(Object key) {\n-        purgeBeforeRead();\n-        Entry entry = getEntry(key);\n-        if (entry == null) {\n-            return false;\n-        }\n-        return (entry.getValue() != null);\n-    }\n-\n-    /**\n-     * Checks whether the map contains the specified value.\n-     * \n-     * @param value  the value to search for\n-     * @return true if the map contains the value\n-     */\n-    public boolean containsValue(Object value) {\n-        purgeBeforeRead();\n-        if (value == null) {\n-            return false;\n-        }\n-        return super.containsValue(value);\n-    }\n-\n-    /**\n-     * Gets the value mapped to the key specified.\n-     * \n-     * @param key  the key\n-     * @return the mapped value, null if no match\n-     */\n-    public Object get(Object key) {\n-        purgeBeforeRead();\n-        Entry entry = getEntry(key);\n-        if (entry == null) {\n-            return null;\n-        }\n-        return entry.getValue();\n-    }\n-\n-\n-    /**\n-     * Puts a key-value mapping into this map.\n-     * Neither the key nor the value may be null.\n-     * \n-     * @param key  the key to add, must not be null\n-     * @param value  the value to add, must not be null\n-     * @return the value previously mapped to this key, null if none\n-     * @throws NullPointerException if either the key or value is null\n-     */\n-    public Object put(Object key, Object value) {\n-        if (key == null) {\n-            throw new NullPointerException(\"null keys not allowed\");\n-        }\n-        if (value == null) {\n-            throw new NullPointerException(\"null values not allowed\");\n-        }\n-\n-        purgeBeforeWrite();\n-        return super.put(key, value);\n-    }\n-    \n-    /**\n-     * Removes the specified mapping from this map.\n-     * \n-     * @param key  the mapping to remove\n-     * @return the value mapped to the removed key, null if key not in map\n-     */\n-    public Object remove(Object key) {\n-        if (key == null) {\n-            return null;\n-        }\n-        purgeBeforeWrite();\n-        return super.remove(key);\n-    }\n-\n-    /**\n-     * Clears this map.\n-     */\n-    public void clear() {\n-        super.clear();\n-        while (queue.poll() != null) {} // drain the queue\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Compares two keys, in internal converted form, to see if they are equal.\n-     * <p>\n-     * This implementation converts the key from the entry to a real reference\n-     * before comparison.\n-     * \n-     * @param key1  the first key to compare passed in from outside\n-     * @param key2  the second key extracted from the entry via <code>entry.key</code>\n-     * @return true if equal\n-     * @since Commons Collections 3.1\n-     */\n-    protected boolean isEqualKey(Object key1, Object key2) {\n-        key2 = (keyType > HARD ? ((Reference) key2).get() : key2);\n-        return (key1 == key2 || key1.equals(key2));\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Creates a ReferenceEntry instead of a HashEntry.\n-     * \n-     * @param next  the next entry in sequence\n-     * @param hashCode  the hash code to use\n-     * @param key  the key to store\n-     * @param value  the value to store\n-     * @return the newly created entry\n-     * @since Commons Collections 3.1\n-     */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new ReferenceEntry(this, next, hashCode, key, value);\n-    }\n-\n-    /**\n-     * Creates an entry set iterator.\n-     * \n-     * @return the entrySet iterator\n-     * @since Commons Collections 3.1\n-     */\n-    protected Iterator createEntrySetIterator() {\n-        return new ReferenceEntrySetIterator(this);\n-    }\n-\n-    /**\n-     * Creates an key set iterator.\n-     * \n-     * @return the keySet iterator\n-     * @since Commons Collections 3.1\n-     */\n-    protected Iterator createKeySetIterator() {\n-        return new ReferenceKeySetIterator(this);\n-    }\n-\n-    /**\n-     * Creates an values iterator.\n-     * \n-     * @return the values iterator\n-     * @since Commons Collections 3.1\n-     */\n-    protected Iterator createValuesIterator() {\n-        return new ReferenceValuesIterator(this);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a set view of this map's entries.\n-     * The <code>setValue()</code> method on the entries has no effect.\n-     *\n-     * @return a set view of this map's entries\n-     */\n-    public Set entrySet() {\n-        if (entrySet == null) {\n-            entrySet = new ReferenceEntrySet(this);\n-        }\n-        return entrySet;\n-    }\n-    \n-    /**\n-     * EntrySet implementation.\n-     */\n-    static class ReferenceEntrySet extends EntrySet {\n-        \n-        protected ReferenceEntrySet(AbstractHashedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object[] toArray() {\n-            return toArray(new Object[0]);\n-        }\n-\n-        public Object[] toArray(Object[] arr) {\n-            // special implementation to handle disappearing entries\n-            ArrayList list = new ArrayList();\n-            Iterator iterator = iterator();\n-            while (iterator.hasNext()) {\n-                Entry e = (Entry) iterator.next();\n-                list.add(new DefaultMapEntry(e.getKey(), e.getValue()));\n-            }\n-            return list.toArray(arr);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a set view of this map's keys.\n-     *\n-     * @return a set view of this map's keys\n-     */\n-    public Set keySet() {\n-        if (keySet == null) {\n-            keySet = new ReferenceKeySet(this);\n-        }\n-        return keySet;\n-    }\n-    \n-    /**\n-     * KeySet implementation.\n-     */\n-    static class ReferenceKeySet extends KeySet {\n-        \n-        protected ReferenceKeySet(AbstractHashedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object[] toArray() {\n-            return toArray(new Object[0]);\n-        }\n-\n-        public Object[] toArray(Object[] arr) {\n-            // special implementation to handle disappearing keys\n-            List list = new ArrayList(parent.size());\n-            for (Iterator it = iterator(); it.hasNext(); ) {\n-                list.add(it.next());\n-            }\n-            return list.toArray(arr);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Returns a collection view of this map's values.\n-     *\n-     * @return a set view of this map's values\n-     */\n-    public Collection values() {\n-        if (values == null) {\n-            values = new ReferenceValues(this);\n-        }\n-        return values;\n-    }\n-    \n-    /**\n-     * Values implementation.\n-     */\n-    static class ReferenceValues extends Values {\n-        \n-        protected ReferenceValues(AbstractHashedMap parent) {\n-            super(parent);\n-        }\n-\n-        public Object[] toArray() {\n-            return toArray(new Object[0]);\n-        }\n-\n-        public Object[] toArray(Object[] arr) {\n-            // special implementation to handle disappearing values\n-            List list = new ArrayList(parent.size());\n-            for (Iterator it = iterator(); it.hasNext(); ) {\n-                list.add(it.next());\n-            }\n-            return list.toArray(arr);\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * A MapEntry implementation for the map.\n-     * <p>\n-     * If getKey() or getValue() returns null, it means\n-     * the mapping is stale and should be removed.\n-     */\n-    protected static class ReferenceEntry extends HashEntry {\n-        /** The parent map */\n-        protected final ReferenceMap parent;\n-\n-        /**\n-         * Creates a new entry object for the ReferenceMap.\n-         * \n-         * @param parent  the parent map\n-         * @param next  the next entry in the hash bucket\n-         * @param hashCode  the hash code of the key\n-         * @param key  the key\n-         * @param value  the value\n-         */\n-        public ReferenceEntry(ReferenceMap parent, HashEntry next, int hashCode, Object key, Object value) {\n-            super(next, hashCode, null, null);\n-            this.parent = parent;\n-            this.key = toReference(parent.keyType, key, hashCode);\n-            this.value = toReference(parent.valueType, value, hashCode);\n-        }\n-\n-        public Object getKey() {\n-            return (parent.keyType > HARD) ? ((Reference) key).get() : key;\n-        }\n-\n-        public Object getValue() {\n-            return (parent.valueType > HARD) ? ((Reference) value).get() : value;\n-        }\n-\n-        public Object setValue(Object obj) {\n-            Object old = getValue();\n-            if (parent.valueType > HARD) {\n-                ((Reference)value).clear();\n-            }\n-            value = toReference(parent.valueType, obj, hashCode);\n-            return old;\n-        }\n-\n-        public boolean equals(Object obj) {\n-            if (obj == this) {\n-                return true;\n-            }\n-            if (obj instanceof Map.Entry == false) {\n-                return false;\n-            }\n-            \n-            Map.Entry entry = (Map.Entry)obj;\n-            Object key = entry.getKey();\n-            Object value = entry.getValue();\n-            if ((key == null) || (value == null)) {\n-                return false;\n-            }\n-            return key.equals(getKey()) && value.equals(getValue());\n-        }\n-\n-        /**\n-         * Constructs a reference of the given type to the given referent.\n-         * The reference is registered with the queue for later purging.\n-         *\n-         * @param type  HARD, SOFT or WEAK\n-         * @param referent  the object to refer to\n-         * @param hash  the hash code of the <i>key</i> of the mapping;\n-         *    this number might be different from referent.hashCode() if\n-         *    the referent represents a value and not a key\n-         * @since Commons Collections 3.1\n-         */\n-        protected Object toReference(int type, Object referent, int hash) {\n-            switch (type) {\n-                case HARD: return referent;\n-                case SOFT: return new SoftRef(hash, referent, parent.queue);\n-                case WEAK: return new WeakRef(hash, referent, parent.queue);\n-                default: throw new Error();\n-            }\n-        }\n-\n-        boolean purge(Reference ref) {\n-            boolean r = (parent.keyType > HARD) && (key == ref);\n-            r = r || ((parent.valueType > HARD) && (value == ref));\n-            if (r) {\n-                if (parent.keyType > HARD) {\n-                    ((Reference)key).clear();\n-                }\n-                if (parent.valueType > HARD) {\n-                    ((Reference)value).clear();\n-                } else if (parent.purgeValues) {\n-                    value = null;\n-                }\n-            }\n-            return r;\n-        }\n-        \n-        ReferenceEntry next() {\n-            return (ReferenceEntry) next;\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * The EntrySet iterator.\n-     */\n-    static class ReferenceEntrySetIterator implements Iterator {\n-        /** The parent map */\n-        final ReferenceMap parent;\n-        \n-        // These fields keep track of where we are in the table.\n-        int index;\n-        ReferenceEntry entry;\n-        ReferenceEntry previous;\n-\n-        // These Object fields provide hard references to the\n-        // current and next entry; this assures that if hasNext()\n-        // returns true, next() will actually return a valid element.\n-        Object nextKey, nextValue;\n-        Object currentKey, currentValue;\n-\n-        int expectedModCount;\n-\n-        public ReferenceEntrySetIterator(ReferenceMap parent) {\n-            super();\n-            this.parent = parent;\n-            index = (parent.size() != 0 ? parent.data.length : 0);\n-            // have to do this here!  size() invocation above\n-            // may have altered the modCount.\n-            expectedModCount = parent.modCount;\n-        }\n-\n-        public boolean hasNext() {\n-            checkMod();\n-            while (nextNull()) {\n-                ReferenceEntry e = entry;\n-                int i = index;\n-                while ((e == null) && (i > 0)) {\n-                    i--;\n-                    e = (ReferenceEntry) parent.data[i];\n-                }\n-                entry = e;\n-                index = i;\n-                if (e == null) {\n-                    currentKey = null;\n-                    currentValue = null;\n-                    return false;\n-                }\n-                nextKey = e.getKey();\n-                nextValue = e.getValue();\n-                if (nextNull()) {\n-                    entry = entry.next();\n-                }\n-            }\n-            return true;\n-        }\n-\n-        private void checkMod() {\n-            if (parent.modCount != expectedModCount) {\n-                throw new ConcurrentModificationException();\n-            }\n-        }\n-\n-        private boolean nextNull() {\n-            return (nextKey == null) || (nextValue == null);\n-        }\n-\n-        protected Entry nextEntry() {    \n-            checkMod();\n-            if (nextNull() && !hasNext()) {\n-                throw new NoSuchElementException();\n-            }\n-            previous = entry;\n-            entry = entry.next();\n-            currentKey = nextKey;\n-            currentValue = nextValue;\n-            nextKey = null;\n-            nextValue = null;\n-            return previous;\n-        }\n-\n-        public Object next() {\n-            return nextEntry();\n-        }\n-\n-        public void remove() {\n-            checkMod();\n-            if (previous == null) {\n-                throw new IllegalStateException();\n-            }\n-            parent.remove(currentKey);\n-            previous = null;\n-            currentKey = null;\n-            currentValue = null;\n-            expectedModCount = parent.modCount;\n-        }\n-    }\n-\n-    /**\n-     * The keySet iterator.\n-     */\n-    static class ReferenceKeySetIterator extends ReferenceEntrySetIterator {\n-        \n-        ReferenceKeySetIterator(ReferenceMap parent) {\n-            super(parent);\n-        }\n-        \n-        public Object next() {\n-            return nextEntry().getKey();\n-        }\n-    }\n-\n-    /**\n-     * The values iterator.\n-     */\n-    static class ReferenceValuesIterator extends ReferenceEntrySetIterator {\n-        \n-        ReferenceValuesIterator(ReferenceMap parent) {\n-            super(parent);\n-        }\n-        \n-        public Object next() {\n-            return nextEntry().getValue();\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    // These two classes store the hashCode of the key of\n-    // of the mapping, so that after they're dequeued a quick\n-    // lookup of the bucket in the table can occur.\n-\n-    /**\n-     * A soft reference holder.\n-     */\n-    static class SoftRef extends SoftReference {\n-        private int hash;\n-\n-        public SoftRef(int hash, Object r, ReferenceQueue q) {\n-            super(r, q);\n-            this.hash = hash;\n-        }\n-\n-        public int hashCode() {\n-            return hash;\n-        }\n-    }\n-\n-    /**\n-     * A weak reference holder.\n-     */\n-    static class WeakRef extends WeakReference {\n-        private int hash;\n-\n-        public WeakRef(int hash, Object r, ReferenceQueue q) {\n-            super(r, q);\n-            this.hash = hash;\n-        }\n-\n-        public int hashCode() {\n-            return hash;\n-        }\n-    }\n-\n-\n }\n--- a/src/test/org/apache/commons/collections/map/TestReferenceMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestReferenceMap.java\n /**\n  * Tests for ReferenceMap. \n  * \n- * @version $Revision: 1.4 $ $Date: 2004/04/01 00:07:48 $\n+ * @version $Revision: 1.5 $ $Date: 2004/04/09 22:18:17 $\n  *\n  * @author Paul Jack\n  */\n         }\n \n     }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        System.gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            System.gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n */\n-\n \n /*\n     // Uncomment to create test files in /data/test", "timestamp": 1081549098, "metainfo": ""}