{"sha": "056d81fe40dbb2481713a96f94dc34ff143f2e54", "log": "Renamed unit tests for keyvalue package.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/AbstractMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Abstract tests that can be extended to test any Map.Entry implementation.\n+ * Subclasses must implement {@link #makeMapEntry(Object, Object)} to return\n+ * a new Map.Entry of the type being tested. Subclasses must also implement\n+ * {@link #testConstructors()} to test the constructors of the Map.Entry\n+ * type being tested.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractMapEntryTest<K, V> extends TestCase {\n+    \n+    protected final String key = \"name\";\n+    protected final String value = \"duke\";\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public AbstractMapEntryTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * This implementation simply calls {@link #makeMapEntry(Object, Object)}\n+     * with null for key and value. Subclasses can override this method if desired.\n+     */\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return makeMapEntry(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    public abstract Map.Entry<K, V> makeMapEntry(K key, V value);\n+\n+    /**\n+     * Makes a Map.Entry of a type that's known to work correctly.\n+     */\n+    public Map.Entry<K, V> makeKnownMapEntry() {\n+        return makeKnownMapEntry(null, null);\n+    }\n+\n+    /**\n+     * Makes a Map.Entry of a type that's known to work correctly.\n+     */\n+    public Map.Entry<K, V> makeKnownMapEntry(K key, V value) {\n+        Map<K, V> map = new HashMap<K, V>(1);\n+        map.put(key, value);\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+        return entry;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+\n+        assertTrue(entry.getKey() == key);\n+\n+        entry.setValue((V) value);\n+        assertTrue(entry.getValue() == value);\n+\n+        // check that null doesn't do anything funny\n+        entry = makeMapEntry(null, null);\n+        assertTrue(entry.getKey() == null);\n+\n+        entry.setValue(null);\n+        assertTrue(entry.getValue() == null);\n+    }\n+\n+    /**\n+     * Subclasses should override this method to test the\n+     * desired behaviour of the class with respect to\n+     * handling of self-references.\n+     *\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        // test that #setValue does not permit\n+        //  the MapEntry to contain itself (and thus cause infinite recursion\n+        //  in #hashCode and #toString)\n+\n+        Map.Entry<K, V> entry = makeMapEntry();\n+\n+        try {\n+            entry.setValue((V) entry);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(entry.getKey() == null && entry.getValue() == null);\n+        }\n+    }\n+\n+    /**\n+     * Subclasses should provide tests for their constructors.\n+     *\n+     */\n+    public abstract void testConstructors();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        // 1. test with object data\n+        Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);\n+        Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);\n+\n+        assertTrue(e1.equals(e1));\n+        assertTrue(e2.equals(e1));\n+        assertTrue(e1.equals(e2));\n+        assertTrue(e1.hashCode() == e2.hashCode());\n+\n+        // 2. test with nulls\n+        e1 = makeMapEntry();\n+        e2 = makeKnownMapEntry();\n+\n+        assertTrue(e1.equals(e1));\n+        assertTrue(e2.equals(e1));\n+        assertTrue(e1.equals(e2));\n+        assertTrue(e1.hashCode() == e2.hashCode());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToString() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+        assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n+\n+        // test with nulls\n+        entry = makeMapEntry();\n+        assertTrue(entry.toString().equals(entry.getKey() + \"=\" + entry.getValue()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/DefaultKeyValueTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test the DefaultKeyValue class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DefaultKeyValueTest<K, V> extends TestCase {\n+    \n+    private final String key = \"name\";\n+    private final String value = \"duke\";\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public DefaultKeyValueTest(String testName) {\n+        super(testName);\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of DefaultKeyValue with the default (null) key and value.\n+     * Subclasses should override this method to return a DefaultKeyValue\n+     * of the type being tested.\n+     */\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue() {\n+        return new DefaultKeyValue<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of DefaultKeyValue with the specified key and value.\n+     * Subclasses should override this method to return a DefaultKeyValue\n+     * of the type being tested.\n+     */\n+    protected DefaultKeyValue<K, V> makeDefaultKeyValue(K key, V value) {\n+        return new DefaultKeyValue<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        kv.setKey((K) key);\n+        assertTrue(kv.getKey() == key);\n+\n+        kv.setValue((V) value);\n+        assertTrue(kv.getValue() == value);\n+\n+        // check that null doesn't do anything funny\n+        kv.setKey(null);\n+        assertTrue(kv.getKey() == null);\n+\n+        kv.setValue(null);\n+        assertTrue(kv.getValue() == null);\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        // test that #setKey and #setValue do not permit\n+        //  the KVP to contain itself (and thus cause infinite recursion\n+        //  in #hashCode and #toString)\n+\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue();\n+\n+        try {\n+            kv.setKey((K) kv);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(kv.getKey() == null && kv.getValue() == null);\n+        }\n+\n+        try {\n+            kv.setValue((V) kv);\n+            fail(\"Should throw an IllegalArgumentException\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected to happen...\n+\n+            // check that the KVP's state has not changed\n+            assertTrue(kv.getKey() == null && kv.getValue() == null);\n+        }\n+    }\n+\n+    /**\n+     * Subclasses should override this method to test their own constructors.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test default constructor\n+        DefaultKeyValue<K, V> kv = new DefaultKeyValue<K, V>();\n+        assertTrue(kv.getKey() == null && kv.getValue() == null);\n+\n+        // 2. test key-value constructor\n+        kv = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        assertTrue(kv.getKey() == key && kv.getValue() == value);\n+\n+        // 3. test copy constructor\n+        DefaultKeyValue<K, V> kv2 = new DefaultKeyValue<K, V>(kv);\n+        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n+\n+        // test that the KVPs are independent\n+        kv.setKey(null);\n+        kv.setValue(null);\n+\n+        assertTrue(kv2.getKey() == key && kv2.getValue() == value);\n+\n+        // 4. test Map.Entry constructor\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) key, (V) value);\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        kv = new DefaultKeyValue<K, V>(entry);\n+        assertTrue(kv.getKey() == key && kv.getValue() == value);\n+\n+        // test that the KVP is independent of the Map.Entry\n+        entry.setValue(null);\n+        assertTrue(kv.getValue() == value);\n+\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEqualsAndHashCode() {\n+        // 1. test with object data\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        DefaultKeyValue<K, V> kv2 = makeDefaultKeyValue((K) key, (V) value);\n+\n+        assertTrue(kv.equals(kv));\n+        assertTrue(kv.equals(kv2));\n+        assertTrue(kv.hashCode() == kv2.hashCode());\n+\n+        // 2. test with nulls\n+        kv = makeDefaultKeyValue(null, null);\n+        kv2 = makeDefaultKeyValue(null, null);\n+\n+        assertTrue(kv.equals(kv));\n+        assertTrue(kv.equals(kv2));\n+        assertTrue(kv.hashCode() == kv2.hashCode());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToString() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+        assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n+\n+        // test with nulls\n+        kv = makeDefaultKeyValue(null, null);\n+        assertTrue(kv.toString().equals(kv.getKey() + \"=\" + kv.getValue()));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testToMapEntry() {\n+        DefaultKeyValue<K, V> kv = makeDefaultKeyValue((K) key, (V) value);\n+\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put(kv.getKey(), kv.getValue());\n+        Map.Entry<K, V> entry = map.entrySet().iterator().next();\n+\n+        assertTrue(entry.equals(kv.toMapEntry()));\n+        assertTrue(entry.hashCode() == kv.hashCode());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/DefaultMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+\n+/**\n+ * Test the DefaultMapEntry class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class DefaultMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n+\n+    public DefaultMapEntryTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new DefaultMapEntry<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        return new DefaultMapEntry<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Subclasses should override this method.\n+     *\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test key-value constructor\n+        Map.Entry<K, V> entry = new DefaultMapEntry<K, V>((K) key, (V) value);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 2. test pair constructor\n+        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        assertSame(key, pair.getKey());\n+        assertSame(value, pair.getValue());\n+\n+        // 3. test copy constructor\n+        Map.Entry<K, V> entry2 = new DefaultMapEntry<K, V>(entry);\n+        assertSame(key, entry2.getKey());\n+        assertSame(value, entry2.getValue());\n+\n+        // test that the objects are independent\n+        entry.setValue(null);\n+        assertSame(value, entry2.getValue());\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSelfReferenceHandling() {\n+        Map.Entry<K, V> entry = makeMapEntry();\n+\n+        try {\n+            entry.setValue((V) entry);\n+            assertSame(entry, entry.getValue());\n+\n+        } catch (Exception e) {\n+            fail(\"This Map.Entry implementation supports value self-reference.\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/MultiKeyTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Assert;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link org.apache.commons.collections.keyvalue.MultiKey}.\n+ *\n+ * @version $Id$\n+ */\n+public class MultiKeyTest extends TestCase {\n+\n+    Integer ONE = new Integer(1);\n+    Integer TWO = new Integer(2);\n+    Integer THREE = new Integer(3);\n+    Integer FOUR = new Integer(4);\n+    Integer FIVE = new Integer(5);\n+\n+    public MultiKeyTest(String name) {\n+        super(name);\n+    }\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+    }\n+\n+    @Override\n+    protected void tearDown() throws Exception {\n+        super.tearDown();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testConstructors() throws Exception {\n+        MultiKey<Integer> mk = null;\n+        mk = new MultiKey<Integer>(ONE, TWO);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE, FOUR);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(ONE, TWO, THREE, FOUR, FIVE);\n+        Assert.assertTrue(Arrays.equals(new Object[] { ONE, TWO, THREE, FOUR, FIVE }, mk.getKeys()));\n+\n+        mk = new MultiKey<Integer>(new Integer[] { THREE, FOUR, ONE, TWO }, false);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+    }\n+\n+    public void testConstructorsByArray() throws Exception {\n+        MultiKey<Integer> mk = null;\n+        Integer[] keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+\n+        keys = new Integer[] {};\n+        mk = new MultiKey<Integer>(keys);\n+        Assert.assertTrue(Arrays.equals(new Object[] {}, mk.getKeys()));\n+\n+        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys, true);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        keys[3] = FIVE;  // no effect\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+\n+        keys = new Integer[] { THREE, FOUR, ONE, TWO };\n+        mk = new MultiKey<Integer>(keys, false);\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, TWO }, mk.getKeys()));\n+        // change key - don't do this!\n+        // the hashcode of the MultiKey is now broken\n+        keys[3] = FIVE;\n+        Assert.assertTrue(Arrays.equals(new Object[] { THREE, FOUR, ONE, FIVE }, mk.getKeys()));\n+    }\n+\n+    public void testConstructorsByArrayNull() throws Exception {\n+        Integer[] keys = null;\n+        try {\n+            new MultiKey<Integer>(keys);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey<Integer>(keys, true);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+        try {\n+            new MultiKey<Integer>(keys, false);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    public void testSize() {\n+        Assert.assertEquals(2, new MultiKey<Integer>(ONE, TWO).size());\n+        Assert.assertEquals(2, new MultiKey<Object>(null, null).size());\n+        Assert.assertEquals(3, new MultiKey<Integer>(ONE, TWO, THREE).size());\n+        Assert.assertEquals(3, new MultiKey<Object>(null, null, null).size());\n+        Assert.assertEquals(4, new MultiKey<Integer>(ONE, TWO, THREE, FOUR).size());\n+        Assert.assertEquals(4, new MultiKey<Object>(null, null, null, null).size());\n+        Assert.assertEquals(5, new MultiKey<Integer>(ONE, TWO, THREE, FOUR, FIVE).size());\n+        Assert.assertEquals(5, new MultiKey<Object>(null, null, null, null, null).size());\n+\n+        Assert.assertEquals(0, new MultiKey<Object>(new Object[] {}).size());\n+        Assert.assertEquals(1, new MultiKey<Integer>(new Integer[] { ONE }).size());\n+        Assert.assertEquals(2, new MultiKey<Integer>(new Integer[] { ONE, TWO }).size());\n+        Assert.assertEquals(7, new MultiKey<Integer>(new Integer[] { ONE, TWO, ONE, TWO, ONE, TWO, ONE }).size());\n+    }\n+\n+    public void testGetIndexed() {\n+        MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        Assert.assertSame(ONE, mk.getKey(0));\n+        Assert.assertSame(TWO, mk.getKey(1));\n+        try {\n+            mk.getKey(-1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            mk.getKey(2);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+\n+    public void testGetKeysSimpleConstructor() {\n+        MultiKey<Integer> mk = new MultiKey<Integer>(ONE, TWO);\n+        Object[] array = mk.getKeys();\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+\n+    public void testGetKeysArrayConstructorCloned() {\n+        Integer[] keys = new Integer[] { ONE, TWO };\n+        MultiKey<Integer> mk = new MultiKey<Integer>(keys, true);\n+        Object[] array = mk.getKeys();\n+        Assert.assertTrue(array != keys);\n+        Assert.assertTrue(Arrays.equals(array, keys));\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+\n+    public void testGetKeysArrayConstructorNonCloned() {\n+        Integer[] keys = new Integer[] { ONE, TWO };\n+        MultiKey<Integer> mk = new MultiKey<Integer>(keys, false);\n+        Object[] array = mk.getKeys();\n+        Assert.assertTrue(array != keys);  // still not equal\n+        Assert.assertTrue(Arrays.equals(array, keys));\n+        Assert.assertSame(ONE, array[0]);\n+        Assert.assertSame(TWO, array[1]);\n+        Assert.assertEquals(2, array.length);\n+    }\n+\n+    public void testHashCode() {\n+        MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+\n+        Assert.assertTrue(mk1.hashCode() == mk1.hashCode());\n+        Assert.assertTrue(mk1.hashCode() == mk2.hashCode());\n+        Assert.assertTrue(mk1.hashCode() != mk3.hashCode());\n+\n+        int total = (0 ^ ONE.hashCode()) ^ TWO.hashCode();\n+        Assert.assertEquals(total, mk1.hashCode());\n+    }\n+\n+    public void testEquals() {\n+        MultiKey<Integer> mk1 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Integer> mk2 = new MultiKey<Integer>(ONE, TWO);\n+        MultiKey<Object> mk3 = new MultiKey<Object>(ONE, \"TWO\");\n+\n+        Assert.assertEquals(mk1, mk1);\n+        Assert.assertEquals(mk1, mk2);\n+        Assert.assertTrue(mk1.equals(mk3) == false);\n+        Assert.assertTrue(mk1.equals(\"\") == false);\n+        Assert.assertTrue(mk1.equals(null) == false);\n+    }\n+\n+    static class SystemHashCodeSimulatingKey implements Serializable {\n+\n+        private static final long serialVersionUID = -1736147315703444603L;\n+        private final String name;\n+        private int hashCode = 1;\n+\n+        public SystemHashCodeSimulatingKey(String name)\n+        {\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj)\n+        {\n+            return obj instanceof SystemHashCodeSimulatingKey \n+                && name.equals(((SystemHashCodeSimulatingKey)obj).name);\n+        }\n+\n+        @Override\n+        public int hashCode()\n+        {\n+            return hashCode;\n+        }\n+\n+        private Object readResolve() {\n+            hashCode=2; // simulate different hashCode after deserialization in another process\n+            return this;\n+        }\n+    }\n+    \n+    public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException\n+    {\n+        SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n+        MultiKey mk = new MultiKey(ONE, sysKey);\n+        Map map = new HashMap();\n+        map.put(mk, TWO);\n+\n+        // serialize\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(baos);\n+        out.writeObject(sysKey);\n+        out.writeObject(map);\n+        out.close();\n+\n+        // deserialize\n+        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());\n+        ObjectInputStream in = new ObjectInputStream(bais);\n+        sysKey = (SystemHashCodeSimulatingKey)in.readObject(); // simulate deserialization in another process\n+        Map map2 = (Map) in.readObject();\n+        in.close();\n+\n+        assertEquals(2, sysKey.hashCode()); // different hashCode now\n+\n+        MultiKey mk2 = new MultiKey(ONE, sysKey);\n+        assertEquals(TWO, map2.get(mk2));        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/TiedMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Test the TiedMapEntry class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class TiedMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n+\n+    public TiedMapEntryTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the instance to test\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put(key, value);\n+        return new TiedMapEntry<K, V>(map, key);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests the constructors.\n+     */\n+    @Override\n+    public void testConstructors() {\n+        // ignore\n+    }\n+\n+    /**\n+     * Tests the constructors.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValue() {\n+        Map<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"A\", (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        map.put((K) \"C\", (V) \"c\");\n+        Map.Entry<K, V> entry = new TiedMapEntry<K, V>(map, (K) \"A\");\n+        assertSame(\"A\", entry.getKey());\n+        assertSame(\"a\", entry.getValue());\n+        assertSame(\"a\", entry.setValue((V) \"x\"));\n+        assertSame(\"A\", entry.getKey());\n+        assertSame(\"x\", entry.getValue());\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"B\");\n+        assertSame(\"B\", entry.getKey());\n+        assertSame(\"b\", entry.getValue());\n+        assertSame(\"b\", entry.setValue((V) \"y\"));\n+        assertSame(\"B\", entry.getKey());\n+        assertSame(\"y\", entry.getValue());\n+\n+        entry = new TiedMapEntry<K, V>(map, (K) \"C\");\n+        assertSame(\"C\", entry.getKey());\n+        assertSame(\"c\", entry.getValue());\n+        assertSame(\"c\", entry.setValue((V) \"z\"));\n+        assertSame(\"C\", entry.getKey());\n+        assertSame(\"z\", entry.getValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/keyvalue/UnmodifiableMapEntryTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.keyvalue;\n+\n+import java.util.Map;\n+\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Test the UnmodifiableMapEntry class.\n+ *\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableMapEntryTest<K, V> extends AbstractMapEntryTest<K, V> {\n+\n+    public UnmodifiableMapEntryTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Make an instance of Map.Entry with the default (null) key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry() {\n+        return new UnmodifiableMapEntry<K, V>(null, null);\n+    }\n+\n+    /**\n+     * Make an instance of Map.Entry with the specified key and value.\n+     * Subclasses should override this method to return a Map.Entry\n+     * of the type being tested.\n+     */\n+    @Override\n+    public Map.Entry<K, V> makeMapEntry(K key, V value) {\n+        return new UnmodifiableMapEntry<K, V>(key, value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Subclasses should override this method.\n+     *\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testConstructors() {\n+        // 1. test key-value constructor\n+        Map.Entry<K, V> entry = new UnmodifiableMapEntry<K, V>((K) key, (V) value);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 2. test pair constructor\n+        KeyValue<K, V> pair = new DefaultKeyValue<K, V>((K) key, (V) value);\n+        entry = new UnmodifiableMapEntry<K, V>(pair);\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // 3. test copy constructor\n+        Map.Entry<K, V> entry2 = new UnmodifiableMapEntry<K, V>(entry);\n+        assertSame(key, entry2.getKey());\n+        assertSame(value, entry2.getValue());\n+\n+        assertTrue(entry instanceof Unmodifiable);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAccessorsAndMutators() {\n+        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n+\n+        assertSame(key, entry.getKey());\n+        assertSame(value, entry.getValue());\n+\n+        // check that null doesn't do anything funny\n+        entry = makeMapEntry(null, null);\n+        assertSame(null, entry.getKey());\n+        assertSame(null, entry.getValue());\n+    }\n+\n+    @Override\n+    public void testSelfReferenceHandling() {\n+        // block\n+    }\n+\n+    public void testUnmodifiable() {\n+        Map.Entry<K, V> entry = makeMapEntry();\n+        try {\n+            entry.setValue(null);\n+            fail();\n+        } catch (UnsupportedOperationException ex) {}\n+    }\n+\n+}", "timestamp": 1345151456, "metainfo": ""}