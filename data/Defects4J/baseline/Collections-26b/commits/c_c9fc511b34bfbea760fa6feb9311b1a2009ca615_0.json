{"sha": "c9fc511b34bfbea760fa6feb9311b1a2009ca615", "log": "Refactor HashedMap and LinkedMap into Abstract superclasses Adjust subclasses appropriately   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractHashedMap.java,v 1.1 2003/12/07 23:59:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.MapIterator;\n+\n+/**\n+ * An abstract implementation of a hash-based map which provides numerous points for\n+ * subclasses to override.\n+ * <p>\n+ * This class implements all the features necessary for a subclass hash-based map.\n+ * Key-value entries are stored in instances of the <code>HashEntry</code> class,\n+ * which can be overridden and replaced. The iterators can similarly be replaced,\n+ * without the need to replace the KeySet, EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/07 23:59:13 $\n+ *\n+ * @author java util HashMap\n+ * @author Stephen Colebourne\n+ */\n+public class AbstractHashedMap implements IterableMap {\n+    \n+    protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n+    protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n+    protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n+    protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n+    protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n+    protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n+    \n+    /** The default capacity to use */\n+    protected static final int DEFAULT_CAPACITY = 16;\n+    /** The default threshold to use */\n+    protected static final int DEFAULT_THRESHOLD = 12;\n+    /** The default load factor to use */\n+    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+    /** The maximum capacity allowed */\n+    protected static final int MAXIMUM_CAPACITY = 1 << 30;\n+    /** An object for masking null */\n+    protected static final Object NULL = new Object();\n+    \n+    /** Load factor, normally 0.75 */\n+    protected transient float loadFactor;\n+    /** The size of the map */\n+    protected transient int size;\n+    /** Map entries */\n+    protected transient HashEntry[] data;\n+    /** Size at which to rehash */\n+    protected transient int threshold;\n+    /** Modification count for iterators */\n+    protected transient int modCount;\n+    /** Entry set */\n+    protected transient EntrySet entrySet;\n+    /** Key set */\n+    protected transient KeySet keySet;\n+    /** Values */\n+    protected transient Values values;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractHashedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which performs no validation on the passed in parameters.\n+     * \n+     * @param initialCapacity  the initial capacity, must be a power of two\n+     * @param loadFactor  the load factor, must be > 0.0f and generally < 1.0f\n+     * @param threshhold  the threshold, must be sensible\n+     */\n+    protected AbstractHashedMap(int initialCapacity, float loadFactor, int threshhold) {\n+        super();\n+        this.loadFactor = loadFactor;\n+        this.data = new HashEntry[initialCapacity];\n+        this.threshold = threshhold;\n+        init();\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * default load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     */\n+    protected AbstractHashedMap(int initialCapacity) {\n+        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+    }\n+    \n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    protected AbstractHashedMap(int initialCapacity, float loadFactor) {\n+        super();\n+        if (initialCapacity < 1) {\n+            throw new IllegalArgumentException(\"Initial capacity must be greater than 0\");\n+        }\n+        if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n+            throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n+        }\n+        this.loadFactor = loadFactor;\n+        this.threshold = calculateThreshold(initialCapacity, loadFactor);\n+        initialCapacity = calculateNewCapacity(initialCapacity);\n+        this.data = new HashEntry[initialCapacity];\n+        init();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    protected AbstractHashedMap(Map map) {\n+        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n+        putAll(map);\n+    }\n+\n+    /**\n+     * Initialise subclasses during construction, cloning or deserialization.\n+     */\n+    protected void init() {\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map.\n+     * \n+     * @return the size\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     * \n+     * @return true if the map is currently size zero\n+     */\n+    public boolean isEmpty() {\n+        return (size == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        if (value == null) {\n+            for (int i = 0, isize = data.length; i < isize; i++) {\n+                HashEntry entry = data[i];\n+                while (entry != null) {\n+                    if (entry.getValue() == null) {\n+                        return true;\n+                    }\n+                    entry = entry.next;\n+                }\n+            }\n+        } else {\n+            for (int i = 0, isize = data.length; i < isize; i++) {\n+                HashEntry entry = data[i];\n+                while (entry != null) {\n+                    if (isEqualValue(value, entry.getValue())) {\n+                        return true;\n+                    }\n+                    entry = entry.next;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map.\n+     * \n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    public Object put(Object key, Object value) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                Object oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        \n+        addMapping(index, hashCode, key, value);\n+        return null;\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     * \n+     * @param map  the map to add\n+     * @throws NullPointerException if the map is null\n+     */\n+    public void putAll(Map map) {\n+        int mapSize = map.size();\n+        if (mapSize == 0) {\n+            return;\n+        }\n+        ensureCapacity(calculateNewCapacity(size + mapSize));\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        HashEntry previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                Object oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    public void clear() {\n+        modCount++;\n+        HashEntry[] data = this.data;\n+        for (int i = data.length - 1; i >= 0; i--) {\n+            data[i] = null;\n+        }\n+        size = 0;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Converts input keys to another object for storage in the map.\n+     * This implementation masks nulls.\n+     * Subclasses can override this to perform alternate key conversions.\n+     * <p>\n+     * The reverse conversion can be changed, if required, by overriding the\n+     * getKey() method in the hash entry.\n+     * \n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    protected Object convertKey(Object key) {\n+        return (key == null ? NULL : key);\n+    }\n+    \n+    /**\n+     * Gets the hash code for the key specified.\n+     * This implementation uses the additional hashing routine from JDK1.4.\n+     * Subclasses can override this to return alternate hash codes.\n+     * \n+     * @param key  the key to get a hash code for\n+     * @return the hash code\n+     */\n+    protected int hash(Object key) {\n+        // same as JDK 1.4\n+        int h = key.hashCode();\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+    \n+    /**\n+     * Compares two keys for equals.\n+     * This implementation uses the equals method.\n+     * Subclasses can override this to match differently.\n+     * \n+     * @param key1  the first key to compare\n+     * @param key2  the second key to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualKey(Object key1, Object key2) {\n+        return (key1 == key2 || key1.equals(key2));\n+    }\n+    \n+    /**\n+     * Compares two values for equals.\n+     * This implementation uses the equals method.\n+     * Subclasses can override this to match differently.\n+     * \n+     * @param value1  the first value to compare\n+     * @param value2  the second value to compare\n+     * @return true if equal\n+     */\n+    protected boolean isEqualValue(Object value1, Object value2) {\n+        return (value1 == value2 || value1.equals(value2));\n+    }\n+    \n+    /**\n+     * Gets the index into the data storage for the hashCode specified.\n+     * This implementation uses the least significant bits of the hashCode.\n+     * Subclasses can override this to return alternate bucketing.\n+     * \n+     * @param hashCode  the hash code to use\n+     * @param dataSize  the size of the data to pick a bucket from\n+     * @return the bucket index\n+     */\n+    protected int hashIndex(int hashCode, int dataSize) {\n+        return hashCode & (dataSize - 1);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the entry mapped to the key specified.\n+     * <p>\n+     * This method exists for subclasses that may need to perform a multi-step\n+     * process accessing the entry. The public methods in this class don't use this\n+     * method to gain a small performance boost.\n+     * \n+     * @param key  the key\n+     * @return the entry, null if no match\n+     */\n+    protected HashEntry getEntry(Object key) {\n+        key = convertKey(key);\n+        int hashCode = hash(key);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n+                return entry;\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates an existing key-value mapping to change the value.\n+     * <p>\n+     * This implementation calls <code>setValue()</code> on the entry.\n+     * Subclasses could override to handle changes to the map.\n+     * \n+     * @param entry  the entry to update\n+     * @param newValue  the new value to store\n+     * @return value  the previous value\n+     */\n+    protected void updateEntry(HashEntry entry, Object newValue) {\n+        entry.setValue(newValue);\n+    }\n+    \n+    /**\n+     * Reuses an existing key-value mapping, storing completely new data.\n+     * <p>\n+     * This implementation sets all the data fields on the entry.\n+     * Subclasses could populate additional entry fields.\n+     * \n+     * @param entry  the entry to update, not null\n+     * @param hashIndex  the index in the data array\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     */\n+    protected void reuseEntry(HashEntry entry, int hashIndex, int hashCode, Object key, Object value) {\n+        entry.next = data[hashIndex];\n+        entry.hashCode = hashCode;\n+        entry.key = key;\n+        entry.value = value;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds a new key-value mapping into this map.\n+     * <p>\n+     * This implementation calls <code>createEntry()</code>, <code>addEntry()</code>\n+     * and <code>checkCapacity()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control adds to the map.\n+     * \n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n+        modCount++;\n+        HashEntry entry = createEntry(data[hashIndex], hashCode, key, value);\n+        addEntry(entry, hashIndex);\n+        size++;\n+        checkCapacity();\n+    }\n+    \n+    /**\n+     * Creates an entry to store the key-value data.\n+     * <p>\n+     * This implementation creates a new HashEntry instance.\n+     * Subclasses can override this to return a different storage class,\n+     * or implement caching.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n+        return new HashEntry(next, hashCode, key, value);\n+    }\n+    \n+    /**\n+     * Adds an entry into this map.\n+     * <p>\n+     * This implementation adds the entry to the data storage table.\n+     * Subclasses could override to handle changes to the map.\n+     * \n+     * @param hashIndex  the index into the data array to store at\n+     * @param hashCode  the hash code of the key to add\n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    protected void addEntry(HashEntry entry, int hashIndex) {\n+        data[hashIndex] = entry;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes a mapping from the map.\n+     * <p>\n+     * This implementation calls <code>removeEntry()</code> and <code>destroyEntry()</code>.\n+     * It also handles changes to <code>modCount</code> and <code>size</code>.\n+     * Subclasses could override to fully control removals from the map.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeMapping(HashEntry entry, int hashIndex, HashEntry previous) {\n+        modCount++;\n+        removeEntry(entry, hashIndex, previous);\n+        size--;\n+        destroyEntry(entry);\n+    }\n+    \n+    /**\n+     * Removes an entry from the chain stored in a particular index.\n+     * <p>\n+     * This implementation removes the entry from the data storage table.\n+     * The size is not updated.\n+     * Subclasses could override to handle changes to the map.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n+        if (previous == null) {\n+            data[hashIndex] = entry.next;\n+        } else {\n+            previous.next = entry.next;\n+        }\n+    }\n+    \n+    /**\n+     * Kills an entry ready for the garbage collector.\n+     * <p>\n+     * This implementation prepares the HashEntry for garbage collection.\n+     * Subclasses can override this to implement caching (override clear as well).\n+     * \n+     * @param entry  the entry to destroy\n+     */\n+    protected void destroyEntry(HashEntry entry) {\n+        entry.next = null;\n+        entry.key = null;\n+        entry.value = null;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks the capacity of the map and enlarges it if necessary.\n+     * <p>\n+     * This implementation uses the threshold to check if the map needs enlarging\n+     */\n+    protected void checkCapacity() {\n+        if (size >= threshold) {\n+            ensureCapacity(data.length * 2);\n+        }\n+    }\n+    \n+    /**\n+     * Changes the size of the data structure to the capacity proposed.\n+     * \n+     * @param newCapacity  the new capacity of the array\n+     */\n+    protected void ensureCapacity(int newCapacity) {\n+        int oldCapacity = data.length;\n+        if (newCapacity <= oldCapacity) {\n+            return;\n+        }\n+        HashEntry oldEntries[] = data;\n+        HashEntry newEntries[] = new HashEntry[newCapacity];\n+\n+        modCount++;\n+        for (int i = oldCapacity - 1; i >= 0; i--) {\n+            HashEntry entry = oldEntries[i];\n+            if (entry != null) {\n+                oldEntries[i] = null;  // gc\n+                do {\n+                    HashEntry next = entry.next;\n+                    int index = hashIndex(entry.hashCode, newCapacity);  \n+                    entry.next = newEntries[index];\n+                    newEntries[index] = entry;\n+                    entry = next;\n+                } while (entry != null);\n+            }\n+        }\n+        threshold = calculateThreshold(newCapacity, loadFactor);\n+        data = newEntries;\n+    }\n+\n+    /**\n+     * Calculates the new capacity of the map.\n+     * This implementation normalizes the capacity to a power of two.\n+     * \n+     * @param proposedCapacity  the proposed capacity\n+     * @return the normalized new capacity\n+     */\n+    protected int calculateNewCapacity(int proposedCapacity) {\n+        int newCapacity = 1;\n+        if (proposedCapacity > MAXIMUM_CAPACITY) {\n+            newCapacity = MAXIMUM_CAPACITY;\n+        } else {\n+            while (newCapacity < proposedCapacity) {\n+                newCapacity <<= 1;  // multiply by two\n+            }\n+            if (proposedCapacity > MAXIMUM_CAPACITY) {\n+                newCapacity = MAXIMUM_CAPACITY;\n+            }\n+        }\n+        return newCapacity;\n+    }\n+    \n+    /**\n+     * Calculates the new threshold of the map, where it will be resized.\n+     * This implementation uses the load factor.\n+     * \n+     * @param newCapacity  the new capacity\n+     * @param factor  the load factor\n+     * @return the new resize threshold\n+     */\n+    protected int calculateThreshold(int newCapacity, float factor) {\n+        return (int) (newCapacity * factor);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Mep Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        if (size == 0) {\n+            return IteratorUtils.EMPTY_MAP_ITERATOR;\n+        }\n+        return new HashMapIterator(this);\n+    }\n+\n+    /**\n+     * MapIterator\n+     */\n+    static class HashMapIterator extends HashIterator implements MapIterator {\n+        \n+        HashMapIterator(AbstractHashedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public Object getKey() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public Object getValue() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public Object setValue(Object value) {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made to the view affect this map.\n+     * The Map Entry is not an independent object and changes as the \n+     * iterator progresses.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     * \n+     * @return the entrySet view\n+     */\n+    public Set entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet(this);\n+        }\n+        return entrySet;\n+    }\n+    \n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the entrySet iterator\n+     */\n+    protected Iterator createEntrySetIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ITERATOR;\n+        }\n+        return new EntrySetIterator(this);\n+    }\n+\n+    /**\n+     * EntrySet\n+     */\n+    static class EntrySet extends AbstractSet {\n+        private final AbstractHashedMap map;\n+        \n+        EntrySet(AbstractHashedMap map) {\n+            super();\n+            this.map = map;\n+        }\n+\n+        public int size() {\n+            return map.size();\n+        }\n+        \n+        public void clear() {\n+            map.clear();\n+        }\n+        \n+        public boolean contains(Object entry) {\n+            if (entry instanceof Map.Entry) {\n+                return map.containsKey(((Map.Entry) entry).getKey());\n+            }\n+            return false;\n+        }\n+        \n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            Object key = entry.getKey();\n+            boolean result = map.containsKey(key);\n+            map.remove(key);\n+            return result;\n+        }\n+\n+        public Iterator iterator() {\n+            return map.createEntrySetIterator();\n+        }\n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator extends HashIterator {\n+        \n+        EntrySetIterator(AbstractHashedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Gets the keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     * \n+     * @return the keySet view\n+     */\n+    public Set keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet(this);\n+        }\n+        return keySet;\n+    }\n+\n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the keySet iterator\n+     */\n+    protected Iterator createKeySetIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ITERATOR;\n+        }\n+        return new KeySetIterator(this);\n+    }\n+\n+    /**\n+     * KeySet\n+     */\n+    static class KeySet extends AbstractSet {\n+        private final AbstractHashedMap map;\n+        \n+        KeySet(AbstractHashedMap map) {\n+            super();\n+            this.map = map;\n+        }\n+\n+        public int size() {\n+            return map.size();\n+        }\n+        \n+        public void clear() {\n+            map.clear();\n+        }\n+        \n+        public boolean contains(Object key) {\n+            return map.containsKey(key);\n+        }\n+        \n+        public boolean remove(Object key) {\n+            boolean result = map.containsKey(key);\n+            map.remove(key);\n+            return result;\n+        }\n+\n+        public Iterator iterator() {\n+            return map.createKeySetIterator();\n+        }\n+    }\n+\n+    /**\n+     * KeySetIterator\n+     */\n+    static class KeySetIterator extends EntrySetIterator {\n+        \n+        KeySetIterator(AbstractHashedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getKey();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Gets the values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     * \n+     * @return the values view\n+     */\n+    public Collection values() {\n+        if (values == null) {\n+            values = new Values(this);\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the values iterator\n+     */\n+    protected Iterator createValuesIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ITERATOR;\n+        }\n+        return new ValuesIterator(this);\n+    }\n+\n+    /**\n+     * Values\n+     */\n+    static class Values extends AbstractCollection {\n+        private final AbstractHashedMap map;\n+        \n+        Values(AbstractHashedMap map) {\n+            super();\n+            this.map = map;\n+        }\n+\n+        public int size() {\n+            return map.size();\n+        }\n+        \n+        public void clear() {\n+            map.clear();\n+        }\n+        \n+        public boolean contains(Object value) {\n+            return map.containsValue(value);\n+        }\n+        \n+        public Iterator iterator() {\n+            return map.createValuesIterator();\n+        }\n+    }\n+\n+    /**\n+     * ValuesIterator\n+     */\n+    static class ValuesIterator extends HashIterator {\n+        \n+        ValuesIterator(AbstractHashedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getValue();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * HashEntry\n+     */\n+    protected static class HashEntry implements Map.Entry, KeyValue {\n+        protected HashEntry next;\n+        protected int hashCode;\n+        protected Object key;\n+        protected Object value;\n+        \n+        protected HashEntry(HashEntry next, int hashCode, Object key, Object value) {\n+            super();\n+            this.next = next;\n+            this.hashCode = hashCode;\n+            this.key = key;\n+            this.value = value;\n+        }\n+        \n+        public Object getKey() {\n+            return (key == NULL ? null : key);\n+        }\n+        \n+        public Object getValue() {\n+            return value;\n+        }\n+        \n+        public Object setValue(Object value) {\n+            Object old = this.value;\n+            this.value = value;\n+            return old;\n+        }\n+        \n+        public boolean equals(Object obj) {\n+            if (obj == this) {\n+                return true;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry other = (Map.Entry) obj;\n+            return\n+                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n+                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n+        }\n+        \n+        public int hashCode() {\n+            return (getKey() == null ? 0 : getKey().hashCode()) ^\n+                   (getValue() == null ? 0 : getValue().hashCode()); \n+        }\n+        \n+        public String toString() {\n+            return new StringBuffer().append(getKey()).append('=').append(getValue()).toString();\n+        }\n+    }\n+    \n+    /**\n+     * Base Iterator\n+     */\n+    protected static abstract class HashIterator implements Iterator {\n+        protected final AbstractHashedMap map;\n+        protected int hashIndex;\n+        protected HashEntry current;\n+        protected HashEntry next;\n+        protected int expectedModCount;\n+        \n+        protected HashIterator(AbstractHashedMap map) {\n+            super();\n+            this.map = map;\n+            HashEntry[] data = map.data;\n+            int i = data.length;\n+            HashEntry next = null;\n+            while (i > 0 && next == null) {\n+                next = data[--i];\n+            }\n+            this.next = next;\n+            this.hashIndex = i;\n+            this.expectedModCount = map.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return (next != null);\n+        }\n+\n+        protected HashEntry nextEntry() { \n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            HashEntry newCurrent = next;\n+            if (newCurrent == null)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            HashEntry[] data = map.data;\n+            int i = hashIndex;\n+            HashEntry n = newCurrent.next;\n+            while (n == null && i > 0) {\n+                n = data[--i];\n+            }\n+            next = n;\n+            hashIndex = i;\n+            current = newCurrent;\n+            return newCurrent;\n+        }\n+\n+        protected HashEntry currentEntry() {\n+            return current;\n+        }\n+        \n+        public void remove() {\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            map.remove(current.getKey());\n+            current = null;\n+            expectedModCount = map.modCount;\n+        }\n+\n+        public String toString() {\n+            if (current != null) {\n+                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n+            } else {\n+                return \"Iterator[]\";\n+            }\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Writes the map data to the stream. This method must be overridden if a\n+     * subclass must be setup before <code>put()</code> is used.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to serialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>writeObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if they have a specific field that must be present\n+     * on read before this implementation will work. Generally, the read determines\n+     * what must be serialized here, if anything.\n+     * \n+     * @param out  the output stream\n+     */\n+    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n+        out.writeFloat(loadFactor);\n+        out.writeInt(data.length);\n+        out.writeInt(size);\n+        for (MapIterator it = mapIterator(); it.hasNext();) {\n+            out.writeObject(it.next());\n+            out.writeObject(it.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Reads the map data from the stream. This method must be overridden if a\n+     * subclass must be setup before <code>put()</code> is used.\n+     * <p>\n+     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n+     * initialise the superclass before the subclass. Sometimes however, this isn't\n+     * what you want, as in this case the <code>put()</code> method on read can be\n+     * affected by subclass state.\n+     * <p>\n+     * The solution adopted here is to deserialize the state data of this class in\n+     * this protected method. This method must be called by the\n+     * <code>readObject()</code> of the first serializable subclass.\n+     * <p>\n+     * Subclasses may override if the subclass has a specific field that must be present\n+     * before <code>put()</code> or <code>calculateThreshold()</code> will work correctly.\n+     * \n+     * @param in  the input stream\n+     */\n+    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        loadFactor = in.readFloat();\n+        int capacity = in.readInt();\n+        int size = in.readInt();\n+        init();\n+        data = new HashEntry[capacity];\n+        for (int i = 0; i < size; i++) {\n+            Object key = in.readObject();\n+            Object value = in.readObject();\n+            put(key, value);\n+        }\n+        threshold = calculateThreshold(data.length, loadFactor);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     * <p>\n+     * To implement <code>clone()</code>, a subclass must implement the\n+     * <code>Cloneable</code> interface and make this method public.\n+     *\n+     * @return a shallow clone\n+     */\n+    protected Object clone() {\n+        try {\n+            AbstractHashedMap cloned = (AbstractHashedMap) super.clone();\n+            cloned.data = new HashEntry[data.length];\n+            cloned.entrySet = null;\n+            cloned.keySet = null;\n+            cloned.values = null;\n+            cloned.modCount = 0;\n+            cloned.size = 0;\n+            init();\n+            cloned.putAll(this);\n+            return cloned;\n+            \n+        } catch (CloneNotSupportedException ex) {\n+            return null;  // should never happen\n+        }\n+    }\n+    \n+    /**\n+     * Compares this map with another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map map = (Map) obj;\n+        if (map.size() != size()) {\n+            return false;\n+        }\n+        MapIterator it = mapIterator();\n+        try {\n+            while (it.hasNext()) {\n+                Object key = it.next();\n+                Object value = it.getValue();\n+                if (value == null) {\n+                    if (map.get(key) != null || map.containsKey(key) == false) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (value.equals(map.get(key)) == false) {\n+                        return false;\n+                    }\n+                }\n+            }\n+        } catch (ClassCastException ignored)   {\n+            return false;\n+        } catch (NullPointerException ignored) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     * \n+     * @return the hashcode defined in the Map interface\n+     */\n+    public int hashCode() {\n+        int total = 0;\n+        Iterator it = createEntrySetIterator();\n+        while (it.hasNext()) {\n+            total += it.next().hashCode();\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     * \n+     * @return a string version of the map\n+     */\n+    public String toString() {\n+        if (size() == 0) {\n+            return \"{}\";\n+        }\n+        StringBuffer buf = new StringBuffer(32 * size());\n+        buf.append('{');\n+\n+        MapIterator it = mapIterator();\n+        boolean hasNext = it.hasNext();\n+        while (hasNext) {\n+            Object key = it.next();\n+            Object value = it.getValue();\n+            buf.append(key == this ? \"(this Map)\" : key)\n+               .append('=')\n+               .append(value == this ? \"(this Map)\" : value);\n+\n+            hasNext = it.hasNext();\n+            if (hasNext) {\n+                buf.append(',').append(' ');\n+            }\n+        }\n+\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/AbstractLinkedMap.java,v 1.1 2003/12/07 23:59:13 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * An abstract implementation of a hash-based map that links entries to create an\n+ * ordered map and which provides numerous points for subclasses to override.\n+ * <p>\n+ * This class implements all the features necessary for a subclass linked\n+ * hash-based map. Key-value entries are stored in instances of the\n+ * <code>LinkEntry</code> class which can be overridden and replaced.\n+ * The iterators can similarly be replaced, without the need to replace the KeySet,\n+ * EntrySet and Values view classes.\n+ * <p>\n+ * Overridable methods are provided to change the default hashing behaviour, and\n+ * to change how entries are added to and removed from the map. Hopefully, all you\n+ * need for unusual subclasses is here.\n+ * <p>\n+ * This implementation maintains order by original insertion, but subclasses\n+ * may work differently. The <code>OrderedMap</code> interface is implemented\n+ * to provide access to bidirectional iteration and extra convenience methods.\n+ * <p>\n+ * The <code>orderedMapIterator()</code> method provides direct access to a\n+ * bidirectional iterator. The iterators from the other views can also be cast\n+ * to <code>OrderedIterator</code> if required.\n+ * <p>\n+ * All the available iterators can be reset back to the start by casting to\n+ * <code>ResettableIterator</code> and calling <code>reset()</code>.\n+ * <p>\n+ * The implementation is also designed to be subclassed, with lots of useful\n+ * methods exposed.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/07 23:59:13 $\n+ *\n+ * @author java util LinkedHashMap\n+ * @author Stephen Colebourne\n+ */\n+public class AbstractLinkedMap extends AbstractHashedMap implements OrderedMap {\n+    \n+    /** Header in the linked list */\n+    protected transient LinkEntry header;\n+\n+    /**\n+     * Constructor only used in deserialization, do not use otherwise.\n+     */\n+    protected AbstractLinkedMap() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor which performs no validation on the passed in parameters.\n+     * \n+     * @param initialCapacity  the initial capacity, must be a power of two\n+     * @param loadFactor  the load factor, must be > 0.0f and generally < 1.0f\n+     * @param threshhold  the threshold, must be sensible\n+     */\n+    protected AbstractLinkedMap(int initialCapacity, float loadFactor, int threshhold) {\n+        super(initialCapacity, loadFactor, threshhold);\n+    }\n+    \n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     */\n+    protected AbstractLinkedMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    protected AbstractLinkedMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    protected AbstractLinkedMap(Map map) {\n+        super(map);\n+    }\n+\n+    /**\n+     * Initialise this subclass during construction.\n+     */\n+    protected void init() {\n+        header = new LinkEntry(null, -1, null, null);\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        // override uses faster iterator\n+        if (value == null) {\n+            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n+                if (entry.getValue() == null) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n+                if (isEqualValue(value, entry.getValue())) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    public void clear() {\n+        // override to reset the linked list\n+        super.clear();\n+        header.before = header.after = header;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the first key in the map, which is the most recently inserted.\n+     * \n+     * @return the most recently inserted key\n+     */\n+    public Object firstKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.after.getKey();\n+    }\n+\n+    /**\n+     * Gets the last key in the map, which is the first inserted.\n+     * \n+     * @return the eldest key\n+     */\n+    public Object lastKey() {\n+        if (size == 0) {\n+            throw new NoSuchElementException(\"Map is empty\");\n+        }\n+        return header.before.getKey();\n+    }\n+\n+    /**\n+     * Gets the next key in sequence.\n+     * \n+     * @param key  the key to get after\n+     * @return the next key\n+     */\n+    public Object nextKey(Object key) {\n+        LinkEntry entry = (LinkEntry) getEntry(key);\n+        return (entry == null || entry.after == header ? null : entry.after.getKey());\n+    }\n+\n+    /**\n+     * Gets the previous key in sequence.\n+     * \n+     * @param key  the key to get before\n+     * @return the previous key\n+     */\n+    public Object previousKey(Object key) {\n+        LinkEntry entry = (LinkEntry) getEntry(key);\n+        return (entry == null || entry.before == header ? null : entry.before.getKey());\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Adds an entry into this map, maintaining insertion order.\n+     * <p>\n+     * This implementation adds the entry to the data storage table and\n+     * to the end of the linked list.\n+     * \n+     * @param entry  the entry to add\n+     * @param hashIndex  the index into the data array to store at\n+     */\n+    protected void addEntry(HashEntry entry, int hashIndex) {\n+        LinkEntry link = (LinkEntry) entry;\n+        link.after  = header;\n+        link.before = header.before;\n+        header.before.after = link;\n+        header.before = link;\n+        data[hashIndex] = entry;\n+    }\n+    \n+    /**\n+     * Creates an entry to store the data.\n+     * <p>\n+     * This implementation creates a new LinkEntry instance.\n+     * \n+     * @param next  the next entry in sequence\n+     * @param hashCode  the hash code to use\n+     * @param key  the key to store\n+     * @param value  the value to store\n+     * @return the newly created entry\n+     */\n+    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n+        return new LinkEntry(next, hashCode, key, value);\n+    }\n+    \n+    /**\n+     * Removes an entry from the map and the linked list.\n+     * <p>\n+     * This implementation removes the entry from the linked list chain, then\n+     * calls the superclass implementation.\n+     * \n+     * @param entry  the entry to remove\n+     * @param hashIndex  the index into the data structure\n+     * @param previous  the previous entry in the chain\n+     */\n+    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n+        LinkEntry link = (LinkEntry) entry;\n+        link.before.after = link.after;\n+        link.after.before = link.before;\n+        link.after = null;\n+        link.before = null;\n+        super.removeEntry(entry, hashIndex, previous);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Mep Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        if (size == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+        }\n+        return new LinkMapIterator(this);\n+    }\n+\n+    /**\n+     * Gets a bidirectional iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Mep Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public OrderedMapIterator orderedMapIterator() {\n+        if (size == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n+        }\n+        return new LinkMapIterator(this);\n+    }\n+\n+    /**\n+     * MapIterator\n+     */\n+    static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n+        \n+        LinkMapIterator(AbstractLinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry().getKey();\n+        }\n+\n+        public Object getKey() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n+            }\n+            return current.getKey();\n+        }\n+\n+        public Object getValue() {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n+            }\n+            return current.getValue();\n+        }\n+\n+        public Object setValue(Object value) {\n+            HashEntry current = currentEntry();\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n+            }\n+            return current.setValue(value);\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates an entry set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the entrySet iterator\n+     */\n+    protected Iterator createEntrySetIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n+        }\n+        return new EntrySetIterator(this);\n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator extends LinkIterator {\n+        \n+        EntrySetIterator(AbstractLinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a key set iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the keySet iterator\n+     */\n+    protected Iterator createKeySetIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n+        }\n+        return new KeySetIterator(this);\n+    }\n+\n+    /**\n+     * KeySetIterator\n+     */\n+    static class KeySetIterator extends EntrySetIterator {\n+        \n+        KeySetIterator(AbstractLinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getKey();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry().getKey();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Creates a values iterator.\n+     * Subclasses can override this to return iterators with different properties.\n+     * \n+     * @return the values iterator\n+     */\n+    protected Iterator createValuesIterator() {\n+        if (size() == 0) {\n+            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n+        }\n+        return new ValuesIterator(this);\n+    }\n+\n+    /**\n+     * ValuesIterator\n+     */\n+    static class ValuesIterator extends LinkIterator {\n+        \n+        ValuesIterator(AbstractLinkedMap map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            return super.nextEntry().getValue();\n+        }\n+\n+        public Object previous() {\n+            return super.previousEntry().getValue();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * LinkEntry\n+     */\n+    protected static class LinkEntry extends HashEntry {\n+        \n+        protected LinkEntry before;\n+        protected LinkEntry after;\n+        \n+        protected LinkEntry(HashEntry next, int hashCode, Object key, Object value) {\n+            super(next, hashCode, key, value);\n+        }\n+    }\n+    \n+    /**\n+     * Base Iterator\n+     */\n+    protected static abstract class LinkIterator\n+            implements OrderedIterator, ResettableIterator {\n+                \n+        protected final AbstractLinkedMap map;\n+        protected LinkEntry current;\n+        protected LinkEntry next;\n+        protected int expectedModCount;\n+        \n+        protected LinkIterator(AbstractLinkedMap map) {\n+            super();\n+            this.map = map;\n+            this.next = map.header.after;\n+            this.expectedModCount = map.modCount;\n+        }\n+\n+        public boolean hasNext() {\n+            return (next != map.header);\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (next.before != map.header);\n+        }\n+\n+        protected LinkEntry nextEntry() {\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            if (next == map.header)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n+            }\n+            current = next;\n+            next = next.after;\n+            return current;\n+        }\n+\n+        protected LinkEntry previousEntry() {\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            LinkEntry previous = next.before;\n+            if (previous == map.header)  {\n+                throw new NoSuchElementException(AbstractHashedMap.NO_PREVIOUS_ENTRY);\n+            }\n+            next = previous;\n+            current = previous;\n+            return current;\n+        }\n+        \n+        protected LinkEntry currentEntry() {\n+            return current;\n+        }\n+        \n+        public void remove() {\n+            if (current == null) {\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n+            }\n+            if (map.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            map.remove(current.getKey());\n+            current = null;\n+            expectedModCount = map.modCount;\n+        }\n+        \n+        public void reset() {\n+            current = null;\n+            next = map.header.after;\n+        }\n+\n+        public String toString() {\n+            if (current != null) {\n+                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n+            } else {\n+                return \"Iterator[]\";\n+            }\n+        }\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/collections/map/Flat3Map.java\n+++ b/src/java/org/apache/commons/collections/map/Flat3Map.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Flat3Map.java,v 1.7 2003/12/06 14:02:11 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/Flat3Map.java,v 1.8 2003/12/07 23:59:13 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Do not use <code>Flat3Map</code> if the size is likely to grow beyond 3.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.7 $ $Date: 2003/12/06 14:02:11 $\n+ * @version $Revision: 1.8 $ $Date: 2003/12/07 23:59:13 $\n  *\n  * @author Stephen Colebourne\n  */\n \n         public Object next() {\n             if (hasNext() == false) {\n-                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n             iCanRemove = true;\n             iIndex++;\n \n         public void remove() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n             iFlatMap.remove(getKey());\n             iIndex--;\n \n         public Object getKey() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object getValue() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object setValue(Object value) {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             Object old = getValue();\n             switch (iIndex) {\n \n         public Object next() {\n             if (hasNext() == false) {\n-                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n+                throw new NoSuchElementException(AbstractHashedMap.NO_NEXT_ENTRY);\n             }\n             iCanRemove = true;\n             iIndex++;\n \n         public void remove() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n             iFlatMap.remove(getKey());\n             iIndex--;\n \n         public Object getKey() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object getValue() {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             switch (iIndex) {\n                 case 3:\n \n         public Object setValue(Object value) {\n             if (iCanRemove == false) {\n-                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             Object old = getValue();\n             switch (iIndex) {\n--- a/src/java/org/apache/commons/collections/map/HashedMap.java\n+++ b/src/java/org/apache/commons/collections/map/HashedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.8 2003/12/07 01:23:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/HashedMap.java,v 1.9 2003/12/07 23:59:13 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n-import java.util.AbstractCollection;\n-import java.util.AbstractSet;\n-import java.util.Collection;\n-import java.util.ConcurrentModificationException;\n-import java.util.Iterator;\n import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-\n-import org.apache.commons.collections.IterableMap;\n-import org.apache.commons.collections.IteratorUtils;\n-import org.apache.commons.collections.KeyValue;\n-import org.apache.commons.collections.MapIterator;\n \n /**\n  * A <code>Map</code> implementation that is a general purpose replacement\n  * {@link org.apache.commons.collections.iterators.MapIterator MapIterator}\n  * functionality and improving performance of <code>putAll</code>.\n  * <p>\n- * The implementation is also designed to be subclassed, with lots of useful\n- * methods exposed.\n- * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.8 $ $Date: 2003/12/07 01:23:54 $\n+ * @version $Revision: 1.9 $ $Date: 2003/12/07 23:59:13 $\n  *\n- * @author java util HashMap\n  * @author Stephen Colebourne\n  */\n-public class HashedMap implements IterableMap, Serializable, Cloneable {\n-    \n-    protected static final String NO_NEXT_ENTRY = \"No next() entry in the iteration\";\n-    protected static final String NO_PREVIOUS_ENTRY = \"No previous() entry in the iteration\";\n-    protected static final String REMOVE_INVALID = \"remove() can only be called once after next()\";\n-    protected static final String GETKEY_INVALID = \"getKey() can only be called after next() and before remove()\";\n-    protected static final String GETVALUE_INVALID = \"getValue() can only be called after next() and before remove()\";\n-    protected static final String SETVALUE_INVALID = \"setValue() can only be called after next() and before remove()\";\n+public class HashedMap extends AbstractHashedMap implements Serializable, Cloneable {\n     \n     /** Serialisation version */\n-    static final long serialVersionUID = -1593250834999590599L;\n-    /** The default capacity to use */\n-    protected static final int DEFAULT_CAPACITY = 16;\n-    /** The default load factor to use */\n-    protected static final float DEFAULT_LOAD_FACTOR = 0.75f;\n-    /** The maximum capacity allowed */\n-    protected static final int MAXIMUM_CAPACITY = 1 << 30;\n-    /** An object for masking null */\n-    protected static final Object NULL = new Object();\n+    private static final long serialVersionUID = -1788199231038721040L;\n     \n-    /** Load factor, normally 0.75 */\n-    protected transient float loadFactor;\n-    /** The size of the map */\n-    protected transient int size;\n-    /** Map entries */\n-    protected transient HashEntry[] data;\n-    /** Size at which to rehash */\n-    protected transient int threshold;\n-    /** Modification count for iterators */\n-    protected transient int modCount;\n-    /** Entry set */\n-    protected transient EntrySet entrySet;\n-    /** Key set */\n-    protected transient KeySet keySet;\n-    /** Values */\n-    protected transient Values values;\n-\n     /**\n      * Constructs a new empty map with default size and load factor.\n      */\n     public HashedMap() {\n-        super();\n-        this.loadFactor = DEFAULT_LOAD_FACTOR;\n-        this.threshold = calculateThreshold(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR);\n-        this.data = new HashEntry[DEFAULT_CAPACITY];\n-        init();\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the initial capacity is less than one\n      */\n     public HashedMap(int initialCapacity) {\n-        this(initialCapacity, DEFAULT_LOAD_FACTOR);\n+        super(initialCapacity);\n     }\n \n     /**\n      * @throws IllegalArgumentException if the load factor is less than zero\n      */\n     public HashedMap(int initialCapacity, float loadFactor) {\n-        super();\n-        if (initialCapacity < 1) {\n-            throw new IllegalArgumentException(\"Initial capacity must be greater than 0\");\n-        }\n-        if (loadFactor <= 0.0f || Float.isNaN(loadFactor)) {\n-            throw new IllegalArgumentException(\"Load factor must be greater than 0\");\n-        }\n-        this.loadFactor = loadFactor;\n-        this.threshold = calculateThreshold(initialCapacity, loadFactor);\n-        initialCapacity = calculateNewCapacity(initialCapacity);\n-        this.data = new HashEntry[initialCapacity];\n-        init();\n+        super(initialCapacity, loadFactor);\n     }\n \n     /**\n      * @throws NullPointerException if the map is null\n      */\n     public HashedMap(Map map) {\n-        this(Math.max(2 * map.size(), DEFAULT_CAPACITY), DEFAULT_LOAD_FACTOR);\n-        putAll(map);\n-    }\n-\n-    /**\n-     * Initialise subclasses during construction.\n-     */\n-    protected void init() {\n+        super(map);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Gets the value mapped to the key specified.\n-     * \n-     * @param key  the key\n-     * @return the mapped value, null if no match\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n      */\n-    public Object get(Object key) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n-        while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                return entry.getValue();\n-            }\n-            entry = entry.next;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Gets the size of the map.\n-     * \n-     * @return the size\n-     */\n-    public int size() {\n-        return size;\n-    }\n-\n-    /**\n-     * Checks whether the map is currently empty.\n-     * \n-     * @return true if the map is currently size zero\n-     */\n-    public boolean isEmpty() {\n-        return (size == 0);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Checks whether the map contains the specified key.\n-     * \n-     * @param key  the key to search for\n-     * @return true if the map contains the key\n-     */\n-    public boolean containsKey(Object key) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n-        while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                return true;\n-            }\n-            entry = entry.next;\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * Checks whether the map contains the specified value.\n-     * \n-     * @param value  the value to search for\n-     * @return true if the map contains the value\n-     */\n-    public boolean containsValue(Object value) {\n-        if (value == null) {\n-            for (int i = 0, isize = data.length; i < isize; i++) {\n-                HashEntry entry = data[i];\n-                while (entry != null) {\n-                    if (entry.getValue() == null) {\n-                        return true;\n-                    }\n-                    entry = entry.next;\n-                }\n-            }\n-        } else {\n-            for (int i = 0, isize = data.length; i < isize; i++) {\n-                HashEntry entry = data[i];\n-                while (entry != null) {\n-                    if (isEqualValue(value, entry.getValue())) {\n-                        return true;\n-                    }\n-                    entry = entry.next;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Puts a key-value mapping into this map.\n-     * \n-     * @param key  the key to add\n-     * @param value  the value to add\n-     * @return the value previously mapped to this key, null if none\n-     */\n-    public Object put(Object key, Object value) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                Object oldValue = entry.getValue();\n-                updateEntry(entry, value);\n-                return oldValue;\n-            }\n-            entry = entry.next;\n-        }\n-        \n-        addMapping(index, hashCode, key, value);\n-        return null;\n-    }\n-\n-    /**\n-     * Puts all the values from the specified map into this map.\n-     * \n-     * @param map  the map to add\n-     * @throws NullPointerException if the map is null\n-     */\n-    public void putAll(Map map) {\n-        int mapSize = map.size();\n-        if (mapSize == 0) {\n-            return;\n-        }\n-        ensureCapacity(calculateNewCapacity(size + mapSize));\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            put(entry.getKey(), entry.getValue());\n-        }\n-    }\n-\n-    /**\n-     * Removes the specified mapping from this map.\n-     * \n-     * @param key  the mapping to remove\n-     * @return the value mapped to the removed key, null if key not in map\n-     */\n-    public Object remove(Object key) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        HashEntry previous = null;\n-        while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                Object oldValue = entry.getValue();\n-                removeMapping(entry, index, previous);\n-                return oldValue;\n-            }\n-            previous = entry;\n-            entry = entry.next;\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Clears the map, resetting the size to zero and nullifying references\n-     * to avoid garbage collection issues.\n-     */\n-    public void clear() {\n-        modCount++;\n-        HashEntry[] data = this.data;\n-        for (int i = data.length - 1; i >= 0; i--) {\n-            data[i] = null;\n-        }\n-        size = 0;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Converts input keys to another object for storage in the map.\n-     * This implementation masks nulls.\n-     * Subclasses can override this to perform alternate key conversions.\n-     * <p>\n-     * The reverse conversion can be changed, if required, by overriding the\n-     * getKey() method in the hash entry.\n-     * \n-     * @param key  the key to get a hash code for\n-     * @return the hash code\n-     */\n-    protected Object convertKey(Object key) {\n-        return (key == null ? NULL : key);\n-    }\n-    \n-    /**\n-     * Gets the hash code for the key specified.\n-     * This implementation uses the additional hashing routine from JDK1.4.\n-     * Subclasses can override this to return alternate hash codes.\n-     * \n-     * @param key  the key to get a hash code for\n-     * @return the hash code\n-     */\n-    protected int hash(Object key) {\n-        // same as JDK 1.4\n-        int h = key.hashCode();\n-        h += ~(h << 9);\n-        h ^=  (h >>> 14);\n-        h +=  (h << 4);\n-        h ^=  (h >>> 10);\n-        return h;\n-    }\n-    \n-    /**\n-     * Compares two keys for equals.\n-     * This implementation uses the equals method.\n-     * Subclasses can override this to match differently.\n-     * \n-     * @param key1  the first key to compare\n-     * @param key2  the second key to compare\n-     * @return true if equal\n-     */\n-    protected boolean isEqualKey(Object key1, Object key2) {\n-        return (key1 == key2 || key1.equals(key2));\n-    }\n-    \n-    /**\n-     * Compares two values for equals.\n-     * This implementation uses the equals method.\n-     * Subclasses can override this to match differently.\n-     * \n-     * @param value1  the first value to compare\n-     * @param value2  the second value to compare\n-     * @return true if equal\n-     */\n-    protected boolean isEqualValue(Object value1, Object value2) {\n-        return (value1 == value2 || value1.equals(value2));\n-    }\n-    \n-    /**\n-     * Gets the index into the data storage for the hashCode specified.\n-     * This implementation uses the least significant bits of the hashCode.\n-     * Subclasses can override this to return alternate bucketing.\n-     * \n-     * @param hashCode  the hash code to use\n-     * @param dataSize  the size of the data to pick a bucket from\n-     * @return the bucket index\n-     */\n-    protected int hashIndex(int hashCode, int dataSize) {\n-        return hashCode & (dataSize - 1);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the entry mapped to the key specified.\n-     * <p>\n-     * This method exists for subclasses that may need to perform a multi-step\n-     * process accessing the entry. The public methods in this class don't use this\n-     * method to gain a small performance boost.\n-     * \n-     * @param key  the key\n-     * @return the entry, null if no match\n-     */\n-    protected HashEntry getEntry(Object key) {\n-        key = convertKey(key);\n-        int hashCode = hash(key);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)]; // no local for hash index\n-        while (entry != null) {\n-            if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) {\n-                return entry;\n-            }\n-            entry = entry.next;\n-        }\n-        return null;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Updates an existing key-value mapping to change the value.\n-     * <p>\n-     * This implementation calls <code>setValue()</code> on the entry.\n-     * Subclasses could override to handle changes to the map.\n-     * \n-     * @param entry  the entry to update\n-     * @param newValue  the new value to store\n-     * @return value  the previous value\n-     */\n-    protected void updateEntry(HashEntry entry, Object newValue) {\n-        entry.setValue(newValue);\n-    }\n-    \n-    /**\n-     * Reuses an existing key-value mapping, storing completely new data.\n-     * <p>\n-     * This implementation sets all the data fields on the entry.\n-     * Subclasses could populate additional entry fields.\n-     * \n-     * @param entry  the entry to update, not null\n-     * @param hashIndex  the index in the data array\n-     * @param hashCode  the hash code of the key to add\n-     * @param key  the key to add\n-     * @param value  the value to add\n-     */\n-    protected void reuseEntry(HashEntry entry, int hashIndex, int hashCode, Object key, Object value) {\n-        entry.next = data[hashIndex];\n-        entry.hashCode = hashCode;\n-        entry.key = key;\n-        entry.value = value;\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Adds a new key-value mapping into this map.\n-     * <p>\n-     * This implementation calls <code>createEntry()</code>, <code>addEntry()</code>\n-     * and <code>checkCapacity</code>.\n-     * It also handles changes to <code>modCount</code> and <code>size</code>.\n-     * Subclasses could override to fully control adds to the map.\n-     * \n-     * @param hashIndex  the index into the data array to store at\n-     * @param hashCode  the hash code of the key to add\n-     * @param key  the key to add\n-     * @param value  the value to add\n-     * @return the value previously mapped to this key, null if none\n-     */\n-    protected void addMapping(int hashIndex, int hashCode, Object key, Object value) {\n-        modCount++;\n-        HashEntry entry = createEntry(data[hashIndex], hashCode, key, value);\n-        addEntry(entry, hashIndex);\n-        size++;\n-        checkCapacity();\n-    }\n-    \n-    /**\n-     * Creates an entry to store the key-value data.\n-     * <p>\n-     * This implementation creates a new HashEntry instance.\n-     * Subclasses can override this to return a different storage class,\n-     * or implement caching.\n-     * \n-     * @param next  the next entry in sequence\n-     * @param hashCode  the hash code to use\n-     * @param key  the key to store\n-     * @param value  the value to store\n-     * @return the newly created entry\n-     */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new HashEntry(next, hashCode, key, value);\n-    }\n-    \n-    /**\n-     * Adds an entry into this map.\n-     * <p>\n-     * This implementation adds the entry to the data storage table.\n-     * Subclasses could override to handle changes to the map.\n-     * \n-     * @param hashIndex  the index into the data array to store at\n-     * @param hashCode  the hash code of the key to add\n-     * @param key  the key to add\n-     * @param value  the value to add\n-     * @return the value previously mapped to this key, null if none\n-     */\n-    protected void addEntry(HashEntry entry, int hashIndex) {\n-        data[hashIndex] = entry;\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Removes a mapping from the map.\n-     * <p>\n-     * This implementation calls <code>removeEntry()</code> and <code>destroyEntry()</code>.\n-     * It also handles changes to <code>modCount</code> and <code>size</code>.\n-     * Subclasses could override to fully control removals from the map.\n-     * \n-     * @param entry  the entry to remove\n-     * @param hashIndex  the index into the data structure\n-     * @param previous  the previous entry in the chain\n-     */\n-    protected void removeMapping(HashEntry entry, int hashIndex, HashEntry previous) {\n-        modCount++;\n-        removeEntry(entry, hashIndex, previous);\n-        size--;\n-        destroyEntry(entry);\n-    }\n-    \n-    /**\n-     * Removes an entry from the chain stored in a particular index.\n-     * <p>\n-     * This implementation removes the entry from the data storage table.\n-     * The size is not updated.\n-     * Subclasses could override to handle changes to the map.\n-     * \n-     * @param entry  the entry to remove\n-     * @param hashIndex  the index into the data structure\n-     * @param previous  the previous entry in the chain\n-     */\n-    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n-        if (previous == null) {\n-            data[hashIndex] = entry.next;\n-        } else {\n-            previous.next = entry.next;\n-        }\n-    }\n-    \n-    /**\n-     * Kills an entry ready for the garbage collector.\n-     * <p>\n-     * This implementation prepares the HashEntry for garbage collection.\n-     * Subclasses can override this to implement caching (override clear as well).\n-     * \n-     * @param entry  the entry to destroy\n-     */\n-    protected void destroyEntry(HashEntry entry) {\n-        entry.next = null;\n-        entry.key = null;\n-        entry.value = null;\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Checks the capacity of the map and enlarges it if necessary.\n-     * <p>\n-     * This implementation uses the threshold to check if the map needs enlarging\n-     */\n-    protected void checkCapacity() {\n-        if (size >= threshold) {\n-            ensureCapacity(data.length * 2);\n-        }\n-    }\n-    \n-    /**\n-     * Changes the size of the data structure to the capacity proposed.\n-     * \n-     * @param newCapacity  the new capacity of the array\n-     */\n-    protected void ensureCapacity(int newCapacity) {\n-        int oldCapacity = data.length;\n-        if (newCapacity <= oldCapacity) {\n-            return;\n-        }\n-        HashEntry oldEntries[] = data;\n-        HashEntry newEntries[] = new HashEntry[newCapacity];\n-\n-        modCount++;\n-        for (int i = oldCapacity - 1; i >= 0; i--) {\n-            HashEntry entry = oldEntries[i];\n-            if (entry != null) {\n-                oldEntries[i] = null;  // gc\n-                do {\n-                    HashEntry next = entry.next;\n-                    int index = hashIndex(entry.hashCode, newCapacity);  \n-                    entry.next = newEntries[index];\n-                    newEntries[index] = entry;\n-                    entry = next;\n-                } while (entry != null);\n-            }\n-        }\n-        threshold = calculateThreshold(newCapacity, loadFactor);\n-        data = newEntries;\n-    }\n-\n-    /**\n-     * Calculates the new capacity of the map.\n-     * This implementation normalizes the capacity to a power of two.\n-     * \n-     * @param proposedCapacity  the proposed capacity\n-     * @return the normalized new capacity\n-     */\n-    protected int calculateNewCapacity(int proposedCapacity) {\n-        int newCapacity = 1;\n-        if (proposedCapacity > MAXIMUM_CAPACITY) {\n-            newCapacity = MAXIMUM_CAPACITY;\n-        } else {\n-            while (newCapacity < proposedCapacity) {\n-                newCapacity <<= 1;  // multiply by two\n-            }\n-            if (proposedCapacity > MAXIMUM_CAPACITY) {\n-                newCapacity = MAXIMUM_CAPACITY;\n-            }\n-        }\n-        return newCapacity;\n-    }\n-    \n-    /**\n-     * Calculates the new threshold of the map, where it will be resized.\n-     * This implementation uses the load factor.\n-     * \n-     * @param newCapacity  the new capacity\n-     * @param factor  the load factor\n-     * @return the new resize threshold\n-     */\n-    protected int calculateThreshold(int newCapacity, float factor) {\n-        return (int) (newCapacity * factor);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an iterator over the map.\n-     * Changes made to the iterator affect this map.\n-     * <p>\n-     * A MapIterator returns the keys in the map. It also provides convenient\n-     * methods to get the key and value, and set the value.\n-     * It avoids the need to create an entrySet/keySet/values object.\n-     * It also avoids creating the Mep Entry object.\n-     * \n-     * @return the map iterator\n-     */\n-    public MapIterator mapIterator() {\n-        if (size == 0) {\n-            return IteratorUtils.EMPTY_MAP_ITERATOR;\n-        }\n-        return new HashMapIterator(this);\n-    }\n-\n-    /**\n-     * MapIterator\n-     */\n-    static class HashMapIterator extends HashIterator implements MapIterator {\n-        \n-        HashMapIterator(HashedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry().getKey();\n-        }\n-\n-        public Object getKey() {\n-            HashEntry current = currentEntry();\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n-            }\n-            return current.getKey();\n-        }\n-\n-        public Object getValue() {\n-            HashEntry current = currentEntry();\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n-            }\n-            return current.getValue();\n-        }\n-\n-        public Object setValue(Object value) {\n-            HashEntry current = currentEntry();\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n-            }\n-            return current.setValue(value);\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Gets the entrySet view of the map.\n-     * Changes made to the view affect this map.\n-     * The Map Entry is not an independent object and changes as the \n-     * iterator progresses.\n-     * To simply iterate through the entries, use {@link #mapIterator()}.\n-     * \n-     * @return the entrySet view\n-     */\n-    public Set entrySet() {\n-        if (entrySet == null) {\n-            entrySet = new EntrySet(this);\n-        }\n-        return entrySet;\n-    }\n-    \n-    /**\n-     * Creates an entry set iterator.\n-     * Subclasses can override this to return iterators with different properties.\n-     * \n-     * @return the entrySet iterator\n-     */\n-    protected Iterator createEntrySetIterator() {\n-        if (size() == 0) {\n-            return IteratorUtils.EMPTY_ITERATOR;\n-        }\n-        return new EntrySetIterator(this);\n-    }\n-\n-    /**\n-     * EntrySet\n-     */\n-    static class EntrySet extends AbstractSet {\n-        private final HashedMap map;\n-        \n-        EntrySet(HashedMap map) {\n-            super();\n-            this.map = map;\n-        }\n-\n-        public int size() {\n-            return map.size();\n-        }\n-        \n-        public void clear() {\n-            map.clear();\n-        }\n-        \n-        public boolean contains(Object entry) {\n-            if (entry instanceof Map.Entry) {\n-                return map.containsKey(((Map.Entry) entry).getKey());\n-            }\n-            return false;\n-        }\n-        \n-        public boolean remove(Object obj) {\n-            if (obj instanceof Map.Entry == false) {\n-                return false;\n-            }\n-            Map.Entry entry = (Map.Entry) obj;\n-            Object key = entry.getKey();\n-            boolean result = map.containsKey(key);\n-            map.remove(key);\n-            return result;\n-        }\n-\n-        public Iterator iterator() {\n-            return map.createEntrySetIterator();\n-        }\n-    }\n-\n-    /**\n-     * EntrySetIterator and MapEntry\n-     */\n-    static class EntrySetIterator extends HashIterator {\n-        \n-        EntrySetIterator(HashedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry();\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Gets the keySet view of the map.\n-     * Changes made to the view affect this map.\n-     * To simply iterate through the keys, use {@link #mapIterator()}.\n-     * \n-     * @return the keySet view\n-     */\n-    public Set keySet() {\n-        if (keySet == null) {\n-            keySet = new KeySet(this);\n-        }\n-        return keySet;\n-    }\n-\n-    /**\n-     * Creates a key set iterator.\n-     * Subclasses can override this to return iterators with different properties.\n-     * \n-     * @return the keySet iterator\n-     */\n-    protected Iterator createKeySetIterator() {\n-        if (size() == 0) {\n-            return IteratorUtils.EMPTY_ITERATOR;\n-        }\n-        return new KeySetIterator(this);\n-    }\n-\n-    /**\n-     * KeySet\n-     */\n-    static class KeySet extends AbstractSet {\n-        private final HashedMap map;\n-        \n-        KeySet(HashedMap map) {\n-            super();\n-            this.map = map;\n-        }\n-\n-        public int size() {\n-            return map.size();\n-        }\n-        \n-        public void clear() {\n-            map.clear();\n-        }\n-        \n-        public boolean contains(Object key) {\n-            return map.containsKey(key);\n-        }\n-        \n-        public boolean remove(Object key) {\n-            boolean result = map.containsKey(key);\n-            map.remove(key);\n-            return result;\n-        }\n-\n-        public Iterator iterator() {\n-            return map.createKeySetIterator();\n-        }\n-    }\n-\n-    /**\n-     * KeySetIterator\n-     */\n-    static class KeySetIterator extends EntrySetIterator {\n-        \n-        KeySetIterator(HashedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry().getKey();\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Gets the values view of the map.\n-     * Changes made to the view affect this map.\n-     * To simply iterate through the values, use {@link #mapIterator()}.\n-     * \n-     * @return the values view\n-     */\n-    public Collection values() {\n-        if (values == null) {\n-            values = new Values(this);\n-        }\n-        return values;\n-    }\n-\n-    /**\n-     * Creates a values iterator.\n-     * Subclasses can override this to return iterators with different properties.\n-     * \n-     * @return the values iterator\n-     */\n-    protected Iterator createValuesIterator() {\n-        if (size() == 0) {\n-            return IteratorUtils.EMPTY_ITERATOR;\n-        }\n-        return new ValuesIterator(this);\n-    }\n-\n-    /**\n-     * Values\n-     */\n-    static class Values extends AbstractCollection {\n-        private final HashedMap map;\n-        \n-        Values(HashedMap map) {\n-            super();\n-            this.map = map;\n-        }\n-\n-        public int size() {\n-            return map.size();\n-        }\n-        \n-        public void clear() {\n-            map.clear();\n-        }\n-        \n-        public boolean contains(Object value) {\n-            return map.containsValue(value);\n-        }\n-        \n-        public Iterator iterator() {\n-            return map.createValuesIterator();\n-        }\n-    }\n-\n-    /**\n-     * ValuesIterator\n-     */\n-    static class ValuesIterator extends HashIterator {\n-        \n-        ValuesIterator(HashedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry().getValue();\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * HashEntry\n-     */\n-    protected static class HashEntry implements Map.Entry, KeyValue {\n-        protected HashEntry next;\n-        protected int hashCode;\n-        protected Object key;\n-        protected Object value;\n-        \n-        protected HashEntry(HashEntry next, int hashCode, Object key, Object value) {\n-            super();\n-            this.next = next;\n-            this.hashCode = hashCode;\n-            this.key = key;\n-            this.value = value;\n-        }\n-        \n-        public Object getKey() {\n-            return (key == NULL ? null : key);\n-        }\n-        \n-        public Object getValue() {\n-            return value;\n-        }\n-        \n-        public Object setValue(Object value) {\n-            Object old = this.value;\n-            this.value = value;\n-            return old;\n-        }\n-        \n-        public boolean equals(Object obj) {\n-            if (obj == this) {\n-                return true;\n-            }\n-            if (obj instanceof Map.Entry == false) {\n-                return false;\n-            }\n-            Map.Entry other = (Map.Entry) obj;\n-            return\n-                (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n-                (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n-        }\n-        \n-        public int hashCode() {\n-            return (getKey() == null ? 0 : getKey().hashCode()) ^\n-                   (getValue() == null ? 0 : getValue().hashCode()); \n-        }\n-        \n-        public String toString() {\n-            return new StringBuffer().append(getKey()).append('=').append(getValue()).toString();\n-        }\n-    }\n-    \n-    /**\n-     * Base Iterator\n-     */\n-    protected static abstract class HashIterator implements Iterator {\n-        protected final HashedMap map;\n-        protected int hashIndex;\n-        protected HashEntry current;\n-        protected HashEntry next;\n-        protected int expectedModCount;\n-        \n-        protected HashIterator(HashedMap map) {\n-            super();\n-            this.map = map;\n-            HashEntry[] data = map.data;\n-            int i = data.length;\n-            HashEntry next = null;\n-            while (i > 0 && next == null) {\n-                next = data[--i];\n-            }\n-            this.next = next;\n-            this.hashIndex = i;\n-            this.expectedModCount = map.modCount;\n-        }\n-\n-        public boolean hasNext() {\n-            return (next != null);\n-        }\n-\n-        protected HashEntry nextEntry() { \n-            if (map.modCount != expectedModCount) {\n-                throw new ConcurrentModificationException();\n-            }\n-            HashEntry newCurrent = next;\n-            if (newCurrent == null)  {\n-                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n-            }\n-            HashEntry[] data = map.data;\n-            int i = hashIndex;\n-            HashEntry n = newCurrent.next;\n-            while (n == null && i > 0) {\n-                n = data[--i];\n-            }\n-            next = n;\n-            hashIndex = i;\n-            current = newCurrent;\n-            return newCurrent;\n-        }\n-\n-        protected HashEntry currentEntry() {\n-            return current;\n-        }\n-        \n-        public void remove() {\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n-            }\n-            if (map.modCount != expectedModCount) {\n-                throw new ConcurrentModificationException();\n-            }\n-            map.remove(current.getKey());\n-            current = null;\n-            expectedModCount = map.modCount;\n-        }\n-\n-        public String toString() {\n-            if (current != null) {\n-                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n-            } else {\n-                return \"Iterator[]\";\n-            }\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Write the data of subclasses.\n-     * <p>\n-     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n-     * not load subclass fields until this object is setup. In other words the readObject\n-     * on this class is performed before that on the subclass. Unfortunately, data setup in\n-     * the subclass may affect the ability of methods such as put() to work properly.\n-     * <p>\n-     * The solution adopted here is to have a method called by this class as part of the\n-     * serialization and deserialization process. Override this method if the subclass\n-     * stores additional data needed for put() to work.\n-     * A sub-subclass must call super.doWriteObject().\n-     */\n-    protected void doWriteObject(ObjectOutputStream out) throws IOException {\n-        // do nothing\n-    }\n-\n-    /**\n-     * Read the data of subclasses.\n-     * <p>\n-     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n-     * not load subclass fields until this object is setup. In other words the readObject\n-     * on this class is performed before that on the subclass. Unfortunately, data setup in\n-     * the subclass may affect the ability of methods such as put() to work properly.\n-     * <p>\n-     * The solution adopted here is to have a method called by this class as part of the\n-     * serialization and deserialization process. Override this method if the subclass\n-     * stores additional data needed for put() to work.\n-     * A sub-subclass must call super.doReadObject().\n-     */\n-    protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        // do nothing\n+    public Object clone() {\n+        return super.clone();\n     }\n     \n     /**\n      */\n     private void writeObject(ObjectOutputStream out) throws IOException {\n         out.defaultWriteObject();\n-        out.writeFloat(loadFactor);\n-        out.writeInt(data.length);\n-        out.writeInt(size);\n         doWriteObject(out);\n-        for (MapIterator it = mapIterator(); it.hasNext();) {\n-            out.writeObject(it.next());\n-            out.writeObject(it.getValue());\n-        }\n     }\n \n     /**\n      */\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n-        loadFactor = in.readFloat();\n-        int capacity = in.readInt();\n-        int size = in.readInt();\n         doReadObject(in);\n-        init();\n-        data = new HashEntry[capacity];\n-        for (int i = 0; i < size; i++) {\n-            Object key = in.readObject();\n-            Object value = in.readObject();\n-            put(key, value);\n-        }\n-        threshold = calculateThreshold(data.length, loadFactor);\n     }\n     \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Clones the map without cloning the keys or values.\n-     *\n-     * @return a shallow clone\n-     */\n-    public Object clone() {\n-        try {\n-            HashedMap cloned = (HashedMap) super.clone();\n-            cloned.data = new HashEntry[data.length];\n-            cloned.entrySet = null;\n-            cloned.keySet = null;\n-            cloned.values = null;\n-            cloned.modCount = 0;\n-            cloned.size = 0;\n-            init();\n-            cloned.putAll(this);\n-            return cloned;\n-            \n-        } catch (CloneNotSupportedException ex) {\n-            return null;  // should never happen\n-        }\n-    }\n-    \n-    /**\n-     * Compares this map with another.\n-     * \n-     * @param obj  the object to compare to\n-     * @return true if equal\n-     */\n-    public boolean equals(Object obj) {\n-        if (obj == this) {\n-            return true;\n-        }\n-        if (obj instanceof Map == false) {\n-            return false;\n-        }\n-        Map map = (Map) obj;\n-        if (map.size() != size()) {\n-            return false;\n-        }\n-        MapIterator it = mapIterator();\n-        try {\n-            while (it.hasNext()) {\n-                Object key = it.next();\n-                Object value = it.getValue();\n-                if (value == null) {\n-                    if (map.get(key) != null || map.containsKey(key) == false) {\n-                        return false;\n-                    }\n-                } else {\n-                    if (value.equals(map.get(key)) == false) {\n-                        return false;\n-                    }\n-                }\n-            }\n-        } catch (ClassCastException ignored)   {\n-            return false;\n-        } catch (NullPointerException ignored) {\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Gets the standard Map hashCode.\n-     * \n-     * @return the hashcode defined in the Map interface\n-     */\n-    public int hashCode() {\n-        int total = 0;\n-        Iterator it = createEntrySetIterator();\n-        while (it.hasNext()) {\n-            total += it.next().hashCode();\n-        }\n-        return total;\n-    }\n-\n-    /**\n-     * Gets the map as a String.\n-     * \n-     * @return a string version of the map\n-     */\n-    public String toString() {\n-        if (size() == 0) {\n-            return \"{}\";\n-        }\n-        StringBuffer buf = new StringBuffer(32 * size());\n-        buf.append('{');\n-\n-        MapIterator it = mapIterator();\n-        boolean hasNext = it.hasNext();\n-        while (hasNext) {\n-            Object key = it.next();\n-            Object value = it.getValue();\n-            buf.append(key == this ? \"(this Map)\" : key)\n-               .append('=')\n-               .append(value == this ? \"(this Map)\" : value);\n-\n-            hasNext = it.hasNext();\n-            if (hasNext) {\n-                buf.append(',').append(' ');\n-            }\n-        }\n-\n-        buf.append('}');\n-        return buf.toString();\n-    }\n }\n--- a/src/java/org/apache/commons/collections/map/IdentityMap.java\n+++ b/src/java/org/apache/commons/collections/map/IdentityMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/IdentityMap.java,v 1.1 2003/12/02 21:57:08 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/IdentityMap.java,v 1.2 2003/12/07 23:59:13 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.map;\n \n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.Map;\n \n /**\n  * As a general rule, don't compare this map to other maps.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/12/02 21:57:08 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/07 23:59:13 $\n  *\n  * @author java util HashMap\n  * @author Stephen Colebourne\n  */\n-public class IdentityMap extends HashedMap {\n+public class IdentityMap extends AbstractHashedMap implements Serializable, Cloneable {\n     \n     /** Serialisation version */\n+    private static final long serialVersionUID = 2028493495224302329L;\n \n     /**\n      * Constructs a new empty map with default size and load factor.\n      */\n     public IdentityMap() {\n-        super();\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n     }\n \n     /**\n      * @param initialCapacity  the initial capacity\n      * @param loadFactor  the load factor\n      * @throws IllegalArgumentException if the initial capacity is less than one\n-     * @throws IllegalArgumentException if the load factor is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n      */\n     public IdentityMap(int initialCapacity, float loadFactor) {\n         super(initialCapacity, loadFactor);\n         }\n     }\n     \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    public Object clone() {\n+        return super.clone();\n+    }\n+    \n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/java/org/apache/commons/collections/map/LRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LRUMap.java,v 1.1 2003/12/07 01:23:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LRUMap.java,v 1.2 2003/12/07 23:59:13 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.io.IOException;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.Map;\n-\n-import org.apache.commons.collections.OrderedMap;\n \n /**\n  * A <code>Map</code> implementation with a fixed maximum size which removes\n  * to least recently used.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/12/07 01:23:54 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/07 23:59:13 $\n  *\n  * @author James Strachan\n  * @author Morgan Delagrange\n  * @author Stephen Colebourne\n  */\n-public class LRUMap extends LinkedMap implements OrderedMap {\n+public class LRUMap extends AbstractLinkedMap implements Serializable, Cloneable {\n     \n     /** Serialisation version */\n-    static final long serialVersionUID = -2848625157350244215L;\n+    static final long serialVersionUID = -612114643488955218L;\n     /** Default maximum size */\n     protected static final int DEFAULT_MAX_SIZE = 100;\n     \n \n     //-----------------------------------------------------------------------\n     /**\n-     * Write the data of subclasses.\n-     * A sub-subclass must call super.doWriteObject().\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    public Object clone() {\n+        return super.clone();\n+    }\n+    \n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+    \n+    /**\n+     * Writes the data necessary for <code>put()</code> to work in deserialization.\n      */\n     protected void doWriteObject(ObjectOutputStream out) throws IOException {\n         out.writeInt(maxSize);\n     }\n \n     /**\n-     * Read the data of subclasses.\n-     * A sub-subclass must call super.doReadObject().\n+     * Reads the data necessary for <code>put()</code> to work in the superclass.\n      */\n     protected void doReadObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         maxSize = in.readInt();\n--- a/src/java/org/apache/commons/collections/map/LinkedMap.java\n+++ b/src/java/org/apache/commons/collections/map/LinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.3 2003/12/07 01:23:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/LinkedMap.java,v 1.4 2003/12/07 23:59:13 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.map;\n \n-import java.util.ConcurrentModificationException;\n-import java.util.Iterator;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.Map;\n-import java.util.NoSuchElementException;\n-\n-import org.apache.commons.collections.IteratorUtils;\n-import org.apache.commons.collections.MapIterator;\n-import org.apache.commons.collections.OrderedIterator;\n-import org.apache.commons.collections.OrderedMap;\n-import org.apache.commons.collections.OrderedMapIterator;\n-import org.apache.commons.collections.ResettableIterator;\n \n /**\n  * A <code>Map</code> implementation that maintains the order of the entries.\n- * In this implementation order is maintained is by original insertion, but\n- * subclasses may work differently.\n+ * In this implementation order is maintained is by original insertion.\n  * <p>\n  * This implementation improves on the JDK1.4 LinkedHashMap by adding the \n  * {@link org.apache.commons.collections.iterators.MapIterator MapIterator}\n  * methods exposed.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/12/07 01:23:54 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/07 23:59:13 $\n  *\n- * @author java util LinkedHashMap\n  * @author Stephen Colebourne\n  */\n-public class LinkedMap extends HashedMap implements OrderedMap {\n+public class LinkedMap extends AbstractLinkedMap implements Serializable, Cloneable {\n     \n     /** Serialisation version */\n-    static final long serialVersionUID = -1954063410665686469L;\n+    private static final long serialVersionUID = 9077234323521161066L;\n     \n-    /** Header in the linked list */\n-    protected transient LinkEntry header;\n-\n     /**\n      * Constructs a new empty map with default size and load factor.\n      */\n     public LinkedMap() {\n-        super();\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n     }\n \n     /**\n         super(map);\n     }\n \n-    /**\n-     * Initialise this subclass during construction.\n-     */\n-    protected void init() {\n-        header = new LinkEntry(null, -1, null, null);\n-        header.before = header.after = header;\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n-     * Checks whether the map contains the specified value.\n-     * \n-     * @param value  the value to search for\n-     * @return true if the map contains the value\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n      */\n-    public boolean containsValue(Object value) {\n-        // override uses faster iterator\n-        if (value == null) {\n-            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n-                if (entry.getValue() == null) {\n-                    return true;\n-                }\n-            }\n-        } else {\n-            for (LinkEntry entry = header.after; entry != header; entry = entry.after) {\n-                if (isEqualValue(value, entry.getValue())) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n+    public Object clone() {\n+        return super.clone();\n+    }\n+    \n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n     }\n \n     /**\n-     * Clears the map, resetting the size to zero and nullifying references\n-     * to avoid garbage collection issues.\n+     * Read the map in using a custom routine.\n      */\n-    public void clear() {\n-        // override to reset the linked list\n-        super.clear();\n-        header.before = header.after = header;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets the first key in the map, which is the most recently inserted.\n-     * \n-     * @return the most recently inserted key\n-     */\n-    public Object firstKey() {\n-        if (size == 0) {\n-            throw new NoSuchElementException(\"Map is empty\");\n-        }\n-        return header.after.getKey();\n-    }\n-\n-    /**\n-     * Gets the last key in the map, which is the first inserted.\n-     * \n-     * @return the eldest key\n-     */\n-    public Object lastKey() {\n-        if (size == 0) {\n-            throw new NoSuchElementException(\"Map is empty\");\n-        }\n-        return header.before.getKey();\n-    }\n-\n-    /**\n-     * Gets the next key in sequence.\n-     * \n-     * @param key  the key to get after\n-     * @return the next key\n-     */\n-    public Object nextKey(Object key) {\n-        LinkEntry entry = (LinkEntry) getEntry(key);\n-        return (entry == null || entry.after == header ? null : entry.after.getKey());\n-    }\n-\n-    /**\n-     * Gets the previous key in sequence.\n-     * \n-     * @param key  the key to get before\n-     * @return the previous key\n-     */\n-    public Object previousKey(Object key) {\n-        LinkEntry entry = (LinkEntry) getEntry(key);\n-        return (entry == null || entry.before == header ? null : entry.before.getKey());\n-    }\n-\n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Adds an entry into this map, maintaining insertion order.\n-     * <p>\n-     * This implementation adds the entry to the data storage table and\n-     * to the end of the linked list.\n-     * \n-     * @param entry  the entry to add\n-     * @param hashIndex  the index into the data array to store at\n-     */\n-    protected void addEntry(HashEntry entry, int hashIndex) {\n-        LinkEntry link = (LinkEntry) entry;\n-        link.after  = header;\n-        link.before = header.before;\n-        header.before.after = link;\n-        header.before = link;\n-        data[hashIndex] = entry;\n-    }\n-    \n-    /**\n-     * Creates an entry to store the data.\n-     * <p>\n-     * This implementation creates a new LinkEntry instance.\n-     * \n-     * @param next  the next entry in sequence\n-     * @param hashCode  the hash code to use\n-     * @param key  the key to store\n-     * @param value  the value to store\n-     * @return the newly created entry\n-     */\n-    protected HashEntry createEntry(HashEntry next, int hashCode, Object key, Object value) {\n-        return new LinkEntry(next, hashCode, key, value);\n-    }\n-    \n-    /**\n-     * Removes an entry from the map and the linked list.\n-     * <p>\n-     * This implementation removes the entry from the linked list chain, then\n-     * calls the superclass implementation.\n-     * \n-     * @param entry  the entry to remove\n-     * @param hashIndex  the index into the data structure\n-     * @param previous  the previous entry in the chain\n-     */\n-    protected void removeEntry(HashEntry entry, int hashIndex, HashEntry previous) {\n-        LinkEntry link = (LinkEntry) entry;\n-        link.before.after = link.after;\n-        link.after.before = link.before;\n-        link.after = null;\n-        link.before = null;\n-        super.removeEntry(entry, hashIndex, previous);\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Gets an iterator over the map.\n-     * Changes made to the iterator affect this map.\n-     * <p>\n-     * A MapIterator returns the keys in the map. It also provides convenient\n-     * methods to get the key and value, and set the value.\n-     * It avoids the need to create an entrySet/keySet/values object.\n-     * It also avoids creating the Mep Entry object.\n-     * \n-     * @return the map iterator\n-     */\n-    public MapIterator mapIterator() {\n-        if (size == 0) {\n-            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n-        }\n-        return new LinkMapIterator(this);\n-    }\n-\n-    /**\n-     * Gets a bidirectional iterator over the map.\n-     * Changes made to the iterator affect this map.\n-     * <p>\n-     * A MapIterator returns the keys in the map. It also provides convenient\n-     * methods to get the key and value, and set the value.\n-     * It avoids the need to create an entrySet/keySet/values object.\n-     * It also avoids creating the Mep Entry object.\n-     * \n-     * @return the map iterator\n-     */\n-    public OrderedMapIterator orderedMapIterator() {\n-        if (size == 0) {\n-            return IteratorUtils.EMPTY_ORDERED_MAP_ITERATOR;\n-        }\n-        return new LinkMapIterator(this);\n-    }\n-\n-    /**\n-     * MapIterator\n-     */\n-    static class LinkMapIterator extends LinkIterator implements OrderedMapIterator {\n-        \n-        LinkMapIterator(LinkedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry().getKey();\n-        }\n-\n-        public Object previous() {\n-            return super.previousEntry().getKey();\n-        }\n-\n-        public Object getKey() {\n-            HashEntry current = currentEntry();\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n-            }\n-            return current.getKey();\n-        }\n-\n-        public Object getValue() {\n-            HashEntry current = currentEntry();\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n-            }\n-            return current.getValue();\n-        }\n-\n-        public Object setValue(Object value) {\n-            HashEntry current = currentEntry();\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n-            }\n-            return current.setValue(value);\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Creates an entry set iterator.\n-     * Subclasses can override this to return iterators with different properties.\n-     * \n-     * @return the entrySet iterator\n-     */\n-    protected Iterator createEntrySetIterator() {\n-        if (size() == 0) {\n-            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n-        }\n-        return new EntrySetIterator(this);\n-    }\n-\n-    /**\n-     * EntrySetIterator and MapEntry\n-     */\n-    static class EntrySetIterator extends LinkIterator {\n-        \n-        EntrySetIterator(LinkedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry();\n-        }\n-\n-        public Object previous() {\n-            return super.previousEntry();\n-        }\n-    }\n-\n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Creates a key set iterator.\n-     * Subclasses can override this to return iterators with different properties.\n-     * \n-     * @return the keySet iterator\n-     */\n-    protected Iterator createKeySetIterator() {\n-        if (size() == 0) {\n-            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n-        }\n-        return new KeySetIterator(this);\n-    }\n-\n-    /**\n-     * KeySetIterator\n-     */\n-    static class KeySetIterator extends EntrySetIterator {\n-        \n-        KeySetIterator(LinkedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry().getKey();\n-        }\n-\n-        public Object previous() {\n-            return super.previousEntry().getKey();\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------    \n-    /**\n-     * Creates a values iterator.\n-     * Subclasses can override this to return iterators with different properties.\n-     * \n-     * @return the values iterator\n-     */\n-    protected Iterator createValuesIterator() {\n-        if (size() == 0) {\n-            return IteratorUtils.EMPTY_ORDERED_ITERATOR;\n-        }\n-        return new ValuesIterator(this);\n-    }\n-\n-    /**\n-     * ValuesIterator\n-     */\n-    static class ValuesIterator extends LinkIterator {\n-        \n-        ValuesIterator(LinkedMap map) {\n-            super(map);\n-        }\n-\n-        public Object next() {\n-            return super.nextEntry().getValue();\n-        }\n-\n-        public Object previous() {\n-            return super.previousEntry().getValue();\n-        }\n-    }\n-    \n-    //-----------------------------------------------------------------------\n-    /**\n-     * LinkEntry\n-     */\n-    protected static class LinkEntry extends HashEntry {\n-        \n-        protected LinkEntry before;\n-        protected LinkEntry after;\n-        \n-        protected LinkEntry(HashEntry next, int hashCode, Object key, Object value) {\n-            super(next, hashCode, key, value);\n-        }\n-    }\n-    \n-    /**\n-     * Base Iterator\n-     */\n-    protected static abstract class LinkIterator\n-            implements OrderedIterator, ResettableIterator {\n-                \n-        protected final LinkedMap map;\n-        protected LinkEntry current;\n-        protected LinkEntry next;\n-        protected int expectedModCount;\n-        \n-        protected LinkIterator(LinkedMap map) {\n-            super();\n-            this.map = map;\n-            this.next = map.header.after;\n-            this.expectedModCount = map.modCount;\n-        }\n-\n-        public boolean hasNext() {\n-            return (next != map.header);\n-        }\n-\n-        public boolean hasPrevious() {\n-            return (next.before != map.header);\n-        }\n-\n-        protected LinkEntry nextEntry() {\n-            if (map.modCount != expectedModCount) {\n-                throw new ConcurrentModificationException();\n-            }\n-            if (next == map.header)  {\n-                throw new NoSuchElementException(HashedMap.NO_NEXT_ENTRY);\n-            }\n-            current = next;\n-            next = next.after;\n-            return current;\n-        }\n-\n-        protected LinkEntry previousEntry() {\n-            if (map.modCount != expectedModCount) {\n-                throw new ConcurrentModificationException();\n-            }\n-            LinkEntry previous = next.before;\n-            if (previous == map.header)  {\n-                throw new NoSuchElementException(HashedMap.NO_PREVIOUS_ENTRY);\n-            }\n-            next = previous;\n-            current = previous;\n-            return current;\n-        }\n-        \n-        protected LinkEntry currentEntry() {\n-            return current;\n-        }\n-        \n-        public void remove() {\n-            if (current == null) {\n-                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n-            }\n-            if (map.modCount != expectedModCount) {\n-                throw new ConcurrentModificationException();\n-            }\n-            map.remove(current.getKey());\n-            current = null;\n-            expectedModCount = map.modCount;\n-        }\n-        \n-        public void reset() {\n-            current = null;\n-            next = map.header.after;\n-        }\n-\n-        public String toString() {\n-            if (current != null) {\n-                return \"Iterator[\" + current.getKey() + \"=\" + current.getValue() + \"]\";\n-            } else {\n-                return \"Iterator[]\";\n-            }\n-        }\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n     }\n     \n }\n--- a/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n+++ b/src/java/org/apache/commons/collections/map/ListOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.7 2003/12/06 14:02:11 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/ListOrderedMap.java,v 1.8 2003/12/07 23:59:13 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * original position in the iteration.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.7 $ $Date: 2003/12/06 14:02:11 $\n+ * @version $Revision: 1.8 $ $Date: 2003/12/07 23:59:13 $\n  * \n  * @author Henri Yandell\n  * @author Stephen Colebourne\n         \n         public void remove() {\n             if (readable == false) {\n-                throw new IllegalStateException(HashedMap.REMOVE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.REMOVE_INVALID);\n             }\n             iterator.remove();\n             parent.map.remove(last);\n         \n         public Object getKey() {\n             if (readable == false) {\n-                throw new IllegalStateException(HashedMap.GETKEY_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.GETKEY_INVALID);\n             }\n             return last;\n         }\n \n         public Object getValue() {\n             if (readable == false) {\n-                throw new IllegalStateException(HashedMap.GETVALUE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.GETVALUE_INVALID);\n             }\n             return parent.get(last);\n         }\n         \n         public Object setValue(Object value) {\n             if (readable == false) {\n-                throw new IllegalStateException(HashedMap.SETVALUE_INVALID);\n+                throw new IllegalStateException(AbstractHashedMap.SETVALUE_INVALID);\n             }\n             return parent.map.put(last, value);\n         }\n--- a/src/test/org/apache/commons/collections/map/TestHashedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestHashedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestHashedMap.java,v 1.3 2003/12/07 01:22:50 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestHashedMap.java,v 1.4 2003/12/07 23:59:12 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/12/07 01:22:50 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/07 23:59:12 $\n  * \n  * @author Stephen Colebourne\n  */\n \n //    public void testCreate() throws Exception {\n //        resetEmpty();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n //        resetFull();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n //    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestIdentityMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestIdentityMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestIdentityMap.java,v 1.3 2003/12/07 01:22:50 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestIdentityMap.java,v 1.4 2003/12/07 23:59:12 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.map;\n \n+import java.io.IOException;\n+import java.io.Serializable;\n import java.util.Iterator;\n import java.util.Map;\n \n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.3 $ $Date: 2003/12/07 01:22:50 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/07 23:59:12 $\n  * \n  * @author Stephen Colebourne\n  */\n         assertEquals(false, entry1.equals(entry3));\n     }\n     \n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in CVS.\n+     */\n+    public void testEmptyMapCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        Map map = (Map) makeObject();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertEquals(\"Map is empty\", 0, map2.size());\n+        }\n+    }\n+\n //    public void testCreate() throws Exception {\n //        Map map = new IdentityMap();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/IdentityMap.emptyCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.emptyCollection.version3.obj\");\n //        map = new IdentityMap();\n //        map.put(I1A, I2A);\n //        map.put(I1B, I2A);\n //        map.put(I2A, I2B);\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/IdentityMap.fullCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.fullCollection.version3.obj\");\n //    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLRUMap.java,v 1.1 2003/12/07 01:23:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLRUMap.java,v 1.2 2003/12/07 23:59:12 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.1 $ $Date: 2003/12/07 01:23:54 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/07 23:59:12 $\n  * \n  * @author Stephen Colebourne\n  */\n     \n //    public void testCreate() throws Exception {\n //        resetEmpty();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LRUMap.emptyCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.emptyCollection.version3.obj\");\n //        resetFull();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LRUMap.fullCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.fullCollection.version3.obj\");\n //    }\n }\n--- a/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestLinkedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLinkedMap.java,v 1.2 2003/12/07 01:22:50 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestLinkedMap.java,v 1.3 2003/12/07 23:59:12 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.2 $ $Date: 2003/12/07 01:22:50 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/07 23:59:12 $\n  * \n  * @author Stephen Colebourne\n  */\n     \n //    public void testCreate() throws Exception {\n //        resetEmpty();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n //        resetFull();\n-//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/LinkedMap.fullCollection.version3.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.fullCollection.version3.obj\");\n //    }\n }", "timestamp": 1070841553, "metainfo": ""}