{"sha": "245554d88898209c2de5a6bef686d83ba4e42971", "log": "Fix formatting issues from previous commit  ", "commit": "\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n /**\n  * Decorates another <code>Buffer</code> to make {@link #get()} and\n  * {@link #remove()} block when the <code>Buffer</code> is empty.\n- * <p/>\n+ * <p>\n  * If either <code>get</code> or <code>remove</code> is called on an empty\n  * <code>Buffer</code>, the calling thread waits for notification that\n  * an <code>add</code> or <code>addAll</code> operation has completed.\n- * <p/>\n+ * <p>\n  * When one or more entries are added to an empty <code>Buffer</code>,\n  * all threads blocked in <code>get</code> or <code>remove</code> are notified.\n  * There is no guarantee that concurrent blocked <code>get</code> or\n  * <code>remove</code> requests will be \"unblocked\" and receive data in the\n  * order that they arrive.\n- * <p/>\n+ * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  *\n  * @author Stephen Colebourne\n \n     //-----------------------------------------------------------------------\n     public boolean add(Object o) {\n-        synchronized(lock) {\n+        synchronized (lock) {\n             boolean result = collection.add(o);\n             notifyAll();\n             return result;\n     }\n \n     public boolean addAll(Collection c) {\n-        synchronized(lock) {\n+        synchronized (lock) {\n             boolean result = collection.addAll(c);\n             notifyAll();\n             return result;\n     }\n \n     public Object get() {\n-        synchronized(lock) {\n-            while(collection.isEmpty()) {\n+        synchronized (lock) {\n+            while (collection.isEmpty()) {\n                 try {\n                     wait();\n-                }\n-                catch(InterruptedException e) {\n+                } catch (InterruptedException e) {\n                     PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n     }\n \n     public Object get(final long timeout) {\n-        synchronized(lock) {\n+        synchronized (lock) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while(timeLeft > 0 && collection.isEmpty()) {\n+            while (timeLeft > 0 && collection.isEmpty()) {\n                 try {\n                     wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                }\n-                catch(InterruptedException e) {\n+                } catch(InterruptedException e) {\n                     PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n-            if(collection.isEmpty()) {\n+            if (collection.isEmpty()) {\n                 throw new BufferUnderflowException(\"Timeout expired.\");\n             }\n             return getBuffer().get();\n     }\n \n     public Object remove() {\n-        synchronized(lock) {\n-            while(collection.isEmpty()) {\n+        synchronized (lock) {\n+            while (collection.isEmpty()) {\n                 try {\n                     wait();\n-                }\n-                catch(InterruptedException e) {\n+                } catch (InterruptedException e) {\n                     PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n     }\n \n     public Object remove(final long timeout) {\n-        synchronized(lock) {\n+        synchronized (lock) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while(timeLeft > 0 && collection.isEmpty()) {\n+            while (timeLeft > 0 && collection.isEmpty()) {\n                 try {\n                     wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                }\n-                catch(InterruptedException e) {\n+                } catch(InterruptedException e) {\n                     PrintWriter out = new PrintWriter(new StringWriter());\n                     e.printStackTrace(out);\n                     throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n-            if(collection.isEmpty()) {\n+            if (collection.isEmpty()) {\n                 throw new BufferUnderflowException(\"Timeout expired.\");\n             }\n             return getBuffer().remove();\n         }\n     }\n+\n }", "timestamp": 1116541030, "metainfo": ""}