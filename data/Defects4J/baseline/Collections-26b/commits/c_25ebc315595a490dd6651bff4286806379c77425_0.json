{"sha": "25ebc315595a490dd6651bff4286806379c77425", "log": "Fixed indentation.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n+++ b/src/main/java/org/apache/commons/collections/list/SetUniqueList.java\n  */\n public class SetUniqueList<E> extends AbstractSerializableListDecorator<E> {\n \n-\t/** Serialization version */\n-\tprivate static final long serialVersionUID = 7196982186153478694L;\n-\n-\t/**\n-\t * Internal Set to maintain uniqueness.\n-\t */\n-\tprotected final Set<E> set;\n-\n-\t/**\n-\t * Factory method to create a SetList using the supplied list to retain\n-\t * order.\n-\t * <p>\n-\t * If the list contains duplicates, these are removed (first indexed one\n-\t * kept). A <code>HashSet</code> is used for the set behaviour.\n-\t * \n-\t * @param <E>\n-\t *            the element type\n-\t * @param list\n-\t *            the list to decorate, must not be null\n-\t * @return a new {@link SetUniqueList}\n-\t * @throws IllegalArgumentException\n-\t *             if list is null\n-\t */\n-\tpublic static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n-\t\tif (list == null) {\n-\t\t\tthrow new IllegalArgumentException(\"List must not be null\");\n-\t\t}\n-\t\tif (list.isEmpty()) {\n-\t\t\treturn new SetUniqueList<E>(list, new HashSet<E>());\n-\t\t}\n-\t\tList<E> temp = new ArrayList<E>(list);\n-\t\tlist.clear();\n-\t\tSetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n-\t\tsl.addAll(temp);\n-\t\treturn sl;\n-\t}\n-\n-\t// -----------------------------------------------------------------------\n-\t/**\n-\t * Constructor that wraps (not copies) the List and specifies the set to\n-\t * use.\n-\t * <p>\n-\t * The set and list must both be correctly initialised to the same elements.\n-\t * \n-\t * @param set\n-\t *            the set to decorate, must not be null\n-\t * @param list\n-\t *            the list to decorate, must not be null\n-\t * @throws IllegalArgumentException\n-\t *             if set or list is null\n-\t */\n-\tprotected SetUniqueList(List<E> list, Set<E> set) {\n-\t\tsuper(list);\n-\t\tif (set == null) {\n-\t\t\tthrow new IllegalArgumentException(\"Set must not be null\");\n-\t\t}\n-\t\tthis.set = set;\n-\t}\n-\n-\t// -----------------------------------------------------------------------\n-\t/**\n-\t * Gets an unmodifiable view as a Set.\n-\t * \n-\t * @return an unmodifiable set view\n-\t */\n-\tpublic Set<E> asSet() {\n-\t\treturn UnmodifiableSet.unmodifiableSet(set);\n-\t}\n-\n-\t// -----------------------------------------------------------------------\n-\t/**\n-\t * Adds an element to the list if it is not already present.\n-\t * <p>\n-\t * <i>(Violation)</i> The <code>List</code> interface requires that this\n-\t * method returns <code>true</code> always. However this class may return\n-\t * <code>false</code> because of the <code>Set</code> behaviour.\n-\t * \n-\t * @param object\n-\t *            the object to add\n-\t * @return true if object was added\n-\t */\n-\t@Override\n-\tpublic boolean add(E object) {\n-\t\t// gets initial size\n-\t\tfinal int sizeBefore = size();\n-\n-\t\t// adds element if unique\n-\t\tadd(size(), object);\n-\n-\t\t// compares sizes to detect if collection changed\n-\t\treturn (sizeBefore != size());\n-\t}\n-\n-\t/**\n-\t * Adds an element to a specific index in the list if it is not already\n-\t * present.\n-\t * <p>\n-\t * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n-\t * that the element is always inserted. This may not happen with this\n-\t * implementation.\n-\t * \n-\t * @param index\n-\t *            the index to insert at\n-\t * @param object\n-\t *            the object to add\n-\t */\n-\t@Override\n-\tpublic void add(int index, E object) {\n-\t\t// adds element if it is not contained already\n-\t\tif (set.contains(object) == false) {\n-\t\t\tsuper.add(index, object);\n-\t\t\tset.add(object);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Adds a collection of objects to the end of the list avoiding duplicates.\n-\t * <p>\n-\t * Only elements that are not already in this list will be added, and\n-\t * duplicates from the specified collection will be ignored.\n-\t * <p>\n-\t * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n-\t * that the elements are always inserted. This may not happen with this\n-\t * implementation.\n-\t * \n-\t * @param coll\n-\t *            the collection to add in iterator order\n-\t * @return true if this collection changed\n-\t */\n-\t@Override\n-\tpublic boolean addAll(Collection<? extends E> coll) {\n-\t\treturn addAll(size(), coll);\n-\t}\n-\n-\t/**\n-\t * Adds a collection of objects a specific index in the list avoiding\n-\t * duplicates.\n-\t * <p>\n-\t * Only elements that are not already in this list will be added, and\n-\t * duplicates from the specified collection will be ignored.\n-\t * <p>\n-\t * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n-\t * that the elements are always inserted. This may not happen with this\n-\t * implementation.\n-\t * \n-\t * @param index\n-\t *            the index to insert at\n-\t * @param coll\n-\t *            the collection to add in iterator order\n-\t * @return true if this collection changed\n-\t */\n-\t@Override\n-\tpublic boolean addAll(int index, Collection<? extends E> coll) {\n-\t\tfinal List<E> temp = new ArrayList<E>();\n-\t\tfor (E e : coll) {\n-\t\t\tif (set.add(e)) {\n-\t\t\t\ttemp.add(e);\n-\t\t\t}\n-\t\t}\n-\t\treturn super.addAll(index, temp);\n-\t}\n-\n-\t// -----------------------------------------------------------------------\n-\t/**\n-\t * Sets the value at the specified index avoiding duplicates.\n-\t * <p>\n-\t * The object is set into the specified index. Afterwards, any previous\n-\t * duplicate is removed If the object is not already in the list then a\n-\t * normal set occurs. If it is present, then the old version is removed.\n-\t * \n-\t * @param index\n-\t *            the index to insert at\n-\t * @param object\n-\t *            the object to set\n-\t * @return the previous object\n-\t */\n-\t@Override\n-\tpublic E set(int index, E object) {\n-\t\tint pos = indexOf(object);\n-\t\tE removed = super.set(index, object);\n-\n-\t\tif (pos != -1 && pos != index) {\n-\t\t\t// the object is already in the uniq list\n-\t\t\t// (and it hasn't been swapped with itself)\n-\t\t\tsuper.remove(pos); // remove the duplicate by index\n-\t\t}\n-\n-\t\tset.add(object); // add the new item to the unique set\n-\t\tset.remove(removed); // remove the item deleted by the set\n-\n-\t\treturn removed; // return the item deleted by the set\n-\t}\n-\n-\t@Override\n-\tpublic boolean remove(Object object) {\n-\t\tboolean result = set.remove(object);\n-\t\tif (result) {\n-\t\t\tsuper.remove(object);\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic E remove(int index) {\n-\t\tE result = super.remove(index);\n-\t\tset.remove(result);\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic boolean removeAll(Collection<?> coll) {\n-\t\tboolean result = false;\n-\t\tfor (Iterator<?> it = coll.iterator(); it.hasNext();) {\n-\t\t\tresult |= remove(it.next());\n-\t\t}\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic boolean retainAll(Collection<?> coll) {\n-\t\tSet<Object> setRetainAll = new HashSet<Object>();\n-\t\tfor (Iterator<?> it = coll.iterator(); it.hasNext();) {\n-\t\t\tObject next = it.next();\n-\t\t\tif (set.contains(next)) {\n-\t\t\t\tsetRetainAll.add(next);\n-\t\t\t}\n-\t\t}\n-\t\tif (setRetainAll.size() == set.size()) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (setRetainAll.size() == 0) {\n-\t\t\tclear();\n-\t\t} else {\n-\t\t\tfor (Iterator<E> it = iterator(); it.hasNext();) {\n-\t\t\t\tif (!setRetainAll.contains(it.next())) {\n-\t\t\t\t\tit.remove();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn true;\n-\t}\n-\n-\t@Override\n-\tpublic void clear() {\n-\t\tsuper.clear();\n-\t\tset.clear();\n-\t}\n-\n-\t@Override\n-\tpublic boolean contains(Object object) {\n-\t\treturn set.contains(object);\n-\t}\n-\n-\t@Override\n-\tpublic boolean containsAll(Collection<?> coll) {\n-\t\treturn set.containsAll(coll);\n-\t}\n-\n-\t@Override\n-\tpublic Iterator<E> iterator() {\n-\t\treturn new SetListIterator<E>(super.iterator(), set);\n-\t}\n-\n-\t@Override\n-\tpublic ListIterator<E> listIterator() {\n-\t\treturn new SetListListIterator<E>(super.listIterator(), set);\n-\t}\n-\n-\t@Override\n-\tpublic ListIterator<E> listIterator(int index) {\n-\t\treturn new SetListListIterator<E>(super.listIterator(index), set);\n-\t}\n-\n-\t@Override\n-\tpublic List<E> subList(int fromIndex, int toIndex) {\n-\t\tList<E> superSubList = super.subList(fromIndex, toIndex);\n-\t\tSet<E> subSet = createSetBasedOnList(set, superSubList);\n-\t\treturn new SetUniqueList<E>(superSubList, subSet);\n-\t}\n-\n-\t/**\n-\t * Create a new {@link Set} with the same type as the provided {@code set}\n-\t * and populate it with all elements of {@code list}.\n-\t * \n-\t * @param set\n-\t *            the {@link Set} to be used as return type, must not be null\n-\t * @param list\n-\t *            the {@link List} to populate the {@link Set}\n-\t * @return a new {@link Set} populated with all elements of the provided\n-\t *         {@link List}\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\tprotected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n-\t\tSet<E> subSet;\n-\t\tif (set.getClass().equals(HashSet.class)) {\n-\t\t\tsubSet = new HashSet<E>(list.size());\n-\t\t} else {\n-\t\t\ttry {\n-\t\t\t\tsubSet = set.getClass().newInstance();\n-\t\t\t} catch (InstantiationException ie) {\n-\t\t\t\tsubSet = new HashSet<E>();\n-\t\t\t} catch (IllegalAccessException iae) {\n-\t\t\t\tsubSet = new HashSet<E>();\n-\t\t\t}\n-\t\t}\n-\t\tsubSet.addAll(list);\n-\t\treturn subSet;\n-\t}\n-\n-\t// -----------------------------------------------------------------------\n-\t/**\n-\t * Inner class iterator.\n-\t */\n-\tstatic class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n-\n-\t\tprotected final Set<E> set;\n-\t\tprotected E last = null;\n-\n-\t\tprotected SetListIterator(Iterator<E> it, Set<E> set) {\n-\t\t\tsuper(it);\n-\t\t\tthis.set = set;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic E next() {\n-\t\t\tlast = super.next();\n-\t\t\treturn last;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void remove() {\n-\t\t\tsuper.remove();\n-\t\t\tset.remove(last);\n-\t\t\tlast = null;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Inner class iterator.\n-\t */\n-\tstatic class SetListListIterator<E> extends\n-\t\t\tAbstractListIteratorDecorator<E> {\n-\n-\t\tprotected final Set<E> set;\n-\t\tprotected E last = null;\n-\n-\t\tprotected SetListListIterator(ListIterator<E> it, Set<E> set) {\n-\t\t\tsuper(it);\n-\t\t\tthis.set = set;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic E next() {\n-\t\t\tlast = super.next();\n-\t\t\treturn last;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic E previous() {\n-\t\t\tlast = super.previous();\n-\t\t\treturn last;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void remove() {\n-\t\t\tsuper.remove();\n-\t\t\tset.remove(last);\n-\t\t\tlast = null;\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void add(E object) {\n-\t\t\tif (set.contains(object) == false) {\n-\t\t\t\tsuper.add(object);\n-\t\t\t\tset.add(object);\n-\t\t\t}\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void set(E object) {\n-\t\t\tthrow new UnsupportedOperationException(\n-\t\t\t\t\t\"ListIterator does not support set\");\n-\t\t}\n-\t}\n+    /** Serialization version. */\n+    private static final long serialVersionUID = 7196982186153478694L;\n+\n+    /** Internal Set to maintain uniqueness. */\n+    protected final Set<E> set;\n+\n+    /**\n+     * Factory method to create a SetList using the supplied list to retain\n+     * order.\n+     * <p>\n+     * If the list contains duplicates, these are removed (first indexed one\n+     * kept). A <code>HashSet</code> is used for the set behaviour.\n+     * \n+     * @param <E>\n+     *            the element type\n+     * @param list\n+     *            the list to decorate, must not be null\n+     * @return a new {@link SetUniqueList}\n+     * @throws IllegalArgumentException\n+     *             if list is null\n+     */\n+    public static <E> SetUniqueList<E> setUniqueList(List<E> list) {\n+        if (list == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (list.isEmpty()) {\n+            return new SetUniqueList<E>(list, new HashSet<E>());\n+        }\n+        List<E> temp = new ArrayList<E>(list);\n+        list.clear();\n+        SetUniqueList<E> sl = new SetUniqueList<E>(list, new HashSet<E>());\n+        sl.addAll(temp);\n+        return sl;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies) the List and specifies the set to\n+     * use.\n+     * <p>\n+     * The set and list must both be correctly initialised to the same elements.\n+     * \n+     * @param set\n+     *            the set to decorate, must not be null\n+     * @param list\n+     *            the list to decorate, must not be null\n+     * @throws IllegalArgumentException\n+     *             if set or list is null\n+     */\n+    protected SetUniqueList(List<E> list, Set<E> set) {\n+        super(list);\n+        if (set == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        this.set = set;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Gets an unmodifiable view as a Set.\n+     * \n+     * @return an unmodifiable set view\n+     */\n+    public Set<E> asSet() {\n+        return UnmodifiableSet.unmodifiableSet(set);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Adds an element to the list if it is not already present.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface requires that this\n+     * method returns <code>true</code> always. However this class may return\n+     * <code>false</code> because of the <code>Set</code> behaviour.\n+     * \n+     * @param object\n+     *            the object to add\n+     * @return true if object was added\n+     */\n+    @Override\n+    public boolean add(E object) {\n+        // gets initial size\n+        final int sizeBefore = size();\n+\n+        // adds element if unique\n+        add(size(), object);\n+\n+        // compares sizes to detect if collection changed\n+        return (sizeBefore != size());\n+    }\n+\n+    /**\n+     * Adds an element to a specific index in the list if it is not already\n+     * present.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+     * that the element is always inserted. This may not happen with this\n+     * implementation.\n+     * \n+     * @param index\n+     *            the index to insert at\n+     * @param object\n+     *            the object to add\n+     */\n+    @Override\n+    public void add(int index, E object) {\n+        // adds element if it is not contained already\n+        if (set.contains(object) == false) {\n+            super.add(index, object);\n+            set.add(object);\n+        }\n+    }\n+\n+    /**\n+     * Adds a collection of objects to the end of the list avoiding duplicates.\n+     * <p>\n+     * Only elements that are not already in this list will be added, and\n+     * duplicates from the specified collection will be ignored.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+     * that the elements are always inserted. This may not happen with this\n+     * implementation.\n+     * \n+     * @param coll\n+     *            the collection to add in iterator order\n+     * @return true if this collection changed\n+     */\n+    @Override\n+    public boolean addAll(Collection<? extends E> coll) {\n+        return addAll(size(), coll);\n+    }\n+\n+    /**\n+     * Adds a collection of objects a specific index in the list avoiding\n+     * duplicates.\n+     * <p>\n+     * Only elements that are not already in this list will be added, and\n+     * duplicates from the specified collection will be ignored.\n+     * <p>\n+     * <i>(Violation)</i> The <code>List</code> interface makes the assumption\n+     * that the elements are always inserted. This may not happen with this\n+     * implementation.\n+     * \n+     * @param index\n+     *            the index to insert at\n+     * @param coll\n+     *            the collection to add in iterator order\n+     * @return true if this collection changed\n+     */\n+    @Override\n+    public boolean addAll(int index, Collection<? extends E> coll) {\n+        final List<E> temp = new ArrayList<E>();\n+        for (E e : coll) {\n+            if (set.add(e)) {\n+                temp.add(e);\n+            }\n+        }\n+        return super.addAll(index, temp);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Sets the value at the specified index avoiding duplicates.\n+     * <p>\n+     * The object is set into the specified index. Afterwards, any previous\n+     * duplicate is removed If the object is not already in the list then a\n+     * normal set occurs. If it is present, then the old version is removed.\n+     * \n+     * @param index\n+     *            the index to insert at\n+     * @param object\n+     *            the object to set\n+     * @return the previous object\n+     */\n+    @Override\n+    public E set(int index, E object) {\n+        int pos = indexOf(object);\n+        E removed = super.set(index, object);\n+\n+        if (pos != -1 && pos != index) {\n+            // the object is already in the uniq list\n+            // (and it hasn't been swapped with itself)\n+            super.remove(pos); // remove the duplicate by index\n+        }\n+\n+        set.add(object); // add the new item to the unique set\n+        set.remove(removed); // remove the item deleted by the set\n+\n+        return removed; // return the item deleted by the set\n+    }\n+\n+    @Override\n+    public boolean remove(Object object) {\n+        boolean result = set.remove(object);\n+        if (result) {\n+            super.remove(object);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public E remove(int index) {\n+        E result = super.remove(index);\n+        set.remove(result);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> coll) {\n+        boolean result = false;\n+        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n+            result |= remove(it.next());\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> coll) {\n+        Set<Object> setRetainAll = new HashSet<Object>();\n+        for (Iterator<?> it = coll.iterator(); it.hasNext();) {\n+            Object next = it.next();\n+            if (set.contains(next)) {\n+                setRetainAll.add(next);\n+            }\n+        }\n+        if (setRetainAll.size() == set.size()) {\n+            return false;\n+        }\n+        if (setRetainAll.size() == 0) {\n+            clear();\n+        } else {\n+            for (Iterator<E> it = iterator(); it.hasNext();) {\n+                if (!setRetainAll.contains(it.next())) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        set.clear();\n+    }\n+\n+    @Override\n+    public boolean contains(Object object) {\n+        return set.contains(object);\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> coll) {\n+        return set.containsAll(coll);\n+    }\n+\n+    @Override\n+    public Iterator<E> iterator() {\n+        return new SetListIterator<E>(super.iterator(), set);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator() {\n+        return new SetListListIterator<E>(super.listIterator(), set);\n+    }\n+\n+    @Override\n+    public ListIterator<E> listIterator(int index) {\n+        return new SetListListIterator<E>(super.listIterator(index), set);\n+    }\n+\n+    @Override\n+    public List<E> subList(int fromIndex, int toIndex) {\n+        List<E> superSubList = super.subList(fromIndex, toIndex);\n+        Set<E> subSet = createSetBasedOnList(set, superSubList);\n+        return new SetUniqueList<E>(superSubList, subSet);\n+    }\n+\n+    /**\n+     * Create a new {@link Set} with the same type as the provided {@code set}\n+     * and populate it with all elements of {@code list}.\n+     * \n+     * @param set\n+     *            the {@link Set} to be used as return type, must not be null\n+     * @param list\n+     *            the {@link List} to populate the {@link Set}\n+     * @return a new {@link Set} populated with all elements of the provided\n+     *         {@link List}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Set<E> createSetBasedOnList(Set<E> set, List<E> list) {\n+        Set<E> subSet;\n+        if (set.getClass().equals(HashSet.class)) {\n+            subSet = new HashSet<E>(list.size());\n+        } else {\n+            try {\n+                subSet = set.getClass().newInstance();\n+            } catch (InstantiationException ie) {\n+                subSet = new HashSet<E>();\n+            } catch (IllegalAccessException iae) {\n+                subSet = new HashSet<E>();\n+            }\n+        }\n+        subSet.addAll(list);\n+        return subSet;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Inner class iterator.\n+     */\n+    static class SetListIterator<E> extends AbstractIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListIterator(Iterator<E> it, Set<E> set) {\n+            super(it);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+    }\n+\n+    /**\n+     * Inner class iterator.\n+     */\n+    static class SetListListIterator<E> extends\n+            AbstractListIteratorDecorator<E> {\n+\n+        protected final Set<E> set;\n+        protected E last = null;\n+\n+        protected SetListListIterator(ListIterator<E> it, Set<E> set) {\n+            super(it);\n+            this.set = set;\n+        }\n+\n+        @Override\n+        public E next() {\n+            last = super.next();\n+            return last;\n+        }\n+\n+        @Override\n+        public E previous() {\n+            last = super.previous();\n+            return last;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            super.remove();\n+            set.remove(last);\n+            last = null;\n+        }\n+\n+        @Override\n+        public void add(E object) {\n+            if (set.contains(object) == false) {\n+                super.add(object);\n+                set.add(object);\n+            }\n+        }\n+\n+        @Override\n+        public void set(E object) {\n+            throw new UnsupportedOperationException(\"ListIterator does not support set\");\n+        }\n+    }\n \n }", "timestamp": 1346008876, "metainfo": ""}