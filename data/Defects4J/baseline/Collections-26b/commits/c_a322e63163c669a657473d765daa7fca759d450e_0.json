{"sha": "a322e63163c669a657473d765daa7fca759d450e", "log": "Refactor implementation to act as more of a decorator Fixed some bugs too   ", "commit": "\n--- a/src/java/org/apache/commons/collections/HashBidiMap.java\n+++ b/src/java/org/apache/commons/collections/HashBidiMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/HashBidiMap.java,v 1.3 2003/09/29 23:24:18 matth Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/HashBidiMap.java,v 1.4 2003/10/05 20:40:52 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n-import java.io.Serializable;\n-import java.util.AbstractMap;\n-import java.util.AbstractSet;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.commons.collections.decorators.AbstractCollectionDecorator;\n+import org.apache.commons.collections.decorators.AbstractIteratorDecorator;\n+import org.apache.commons.collections.decorators.AbstractMapEntryDecorator;\n+\n /**\n  * Default implementation of <code>BidiMap</code>.\n  * \n  * @since Commons Collections 3.0\n- * @version $Id: HashBidiMap.java,v 1.3 2003/09/29 23:24:18 matth Exp $\n+ * @version $Id: HashBidiMap.java,v 1.4 2003/10/05 20:40:52 scolebourne Exp $\n  * \n  * @author Matthew Hawthorne\n  */\n-public class HashBidiMap extends AbstractMap implements BidiMap, Serializable {\n+public class HashBidiMap implements BidiMap {\n \n     /**\n      * Delegate map array.  The first map contains standard entries, and the \n      * second contains inverses.\n      */\n-    final Map[] maps = new Map[] { new HashMap(), new HashMap()};\n-\n+    protected final Map[] maps = new Map[2];\n     /**\n      * Inverse view of this map.\n      */\n-    private final BidiMap inverseBidiMap = new InverseBidiMap();\n+    protected BidiMap inverseBidiMap = null;\n+    /**\n+     * View of the keys.\n+     */\n+    protected Set keySet = null;\n+    /**\n+     * View of the values.\n+     */\n+    protected Collection values = null;\n+    /**\n+     * View of the entries.\n+     */\n+    protected Set entrySet = null;\n \n     /**\n      * Creates an empty <code>HashBidiMap</code>\n      */\n-    public HashBidiMap() {}\n+    public HashBidiMap() {\n+        super();\n+        maps[0] = new HashMap();\n+        maps[1] = new HashMap();\n+    }\n \n     /** \n-     * Constructs a new <tt>HashMap</tt> with the same mappings as the\n-     * specified <tt>Map</tt>.  \n+     * Constructs a <code>HashBidiMap</code> and copies the mappings from\n+     * specified <code>Map</code>.  \n      *\n-     * @param   m the map whose mappings are to be placed in this map.\n-     */\n-    public HashBidiMap(Map m) {\n-        putAll(m);\n-    }\n-\n+     * @param map  the map whose mappings are to be placed in this map\n+     */\n+    public HashBidiMap(Map map) {\n+        super();\n+        maps[0] = new HashMap();\n+        maps[1] = new HashMap();\n+        putAll(map);\n+    }\n+\n+    /** \n+     * Constructs a <code>HashBidiMap</code> that decorates the specified maps.\n+     *\n+     * @param normalMap  the normal direction map\n+     * @param reverseMap  the reverse direction map\n+     * @param inverseBidiMap  the inverse BidiMap\n+     */\n+    protected HashBidiMap(Map normalMap, Map reverseMap, BidiMap inverseBidiMap) {\n+        super();\n+        maps[0] = normalMap;\n+        maps[1] = reverseMap;\n+        this.inverseBidiMap = inverseBidiMap;\n+    }\n+\n+    // Map delegation\n+    //-----------------------------------------------------------------------\n+    public Object get(Object key) {\n+        return maps[0].get(key);\n+    }\n+\n+    public int size() {\n+        return maps[0].size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return maps[0].isEmpty();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return maps[0].containsKey(key);\n+    }\n+\n+    public boolean equals(Object obj) {\n+        return maps[0].equals(obj);\n+    }\n+\n+    public int hashCode() {\n+        return maps[0].hashCode();\n+    }\n+\n+    public String toString() {\n+        return maps[0].toString();\n+    }\n+\n+    // BidiMap changes\n+    //-----------------------------------------------------------------------\n+    public Object put(Object key, Object value) {\n+        if (maps[0].containsKey(key)) {\n+            maps[1].remove(maps[0].get(key));\n+        }\n+        if (maps[1].containsKey(value)) {\n+            maps[0].remove(maps[1].get(value));\n+        }\n+        final Object obj = maps[0].put(key, value);\n+        maps[1].put(value, key);\n+        return obj;\n+    }\n+    \n+    public void putAll(Map map) {\n+        for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    public Object remove(Object key) {\n+        Object value = null;\n+        if (maps[0].containsKey(key)) {\n+            value = maps[0].remove(key);\n+            maps[1].remove(value);\n+        }\n+        return value;\n+    }\n+\n+    public void clear() {\n+        maps[0].clear();\n+        maps[1].clear();\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return maps[1].containsKey(value);\n+    }\n+\n+    // BidiMap\n+    //-----------------------------------------------------------------------\n     public Object getKey(Object value) {\n         return maps[1].get(value);\n     }\n \n+    public Object removeKey(Object value) {\n+        Object key = null;\n+        if (maps[1].containsKey(value)) {\n+            key = maps[1].remove(value);\n+            maps[0].remove(key);\n+        }\n+        return key;\n+    }\n+\n     public BidiMap inverseBidiMap() {\n+        if (inverseBidiMap == null) {\n+            inverseBidiMap = new HashBidiMap(maps[1], maps[0], this);\n+        }\n         return inverseBidiMap;\n     }\n \n-    public Object removeKey(Object value) {\n-        final Object key = maps[1].get(value);\n-        return remove(key);\n-    }\n-\n-    public Object put(Object key, Object value) {\n-        // Removes pair from standard map if a previous inverse entry exists\n-        final Object oldValue = maps[1].put(value, key);\n-        if (oldValue != null) {\n-            maps[0].remove(oldValue);\n-        }\n-\n-        final Object obj = maps[0].put(key, value);\n-        return obj;\n+    // Map views\n+    //-----------------------------------------------------------------------\n+    public Set keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet(this);\n+        }\n+        return keySet;\n+    }\n+\n+    public Collection values() {\n+        if (values == null) {\n+            values = new Values(this);\n+        }\n+        return values;\n     }\n \n     public Set entrySet() {\n-        // The entrySet is the root of most Map methods, care must be taken not \n-        // to reference instance methods like size()\n-\n-        // Creates anonymous AbstractSet\n-        return new AbstractSet() {\n-\n-            public Iterator iterator() {\n-                // Creates anonymous Iterator\n-                return new Iterator() {\n-\n-                    // Delegate iterator.\n-                    final Iterator it = maps[0].entrySet().iterator();\n-\n-                    // Current iterator entry\n-                    Map.Entry currentEntry;\n-\n-                    public void remove() {\n-                        // Removes from standard and inverse Maps.\n-\n-                        // Object must be removed using the iterator or a \n-                        // ConcurrentModificationException is thrown\n-                        it.remove();\n-                        HashBidiMap.this.maps[1].remove(\n-                            currentEntry.getValue());\n-                    }\n-\n-                    public boolean hasNext() {\n-                        return it.hasNext();\n-                    }\n-\n-                    public Object next() {\n-                        currentEntry = (Map.Entry)it.next();\n-\n-                        // returns anonymous Map.Entry\n-                        return new Map.Entry() {\n-\n-                            public Object getKey() {\n-                                return currentEntry.getKey();\n-                            }\n-\n-                            public Object getValue() {\n-                                return currentEntry.getValue();\n-                            }\n-\n-                            public Object setValue(Object value) {\n-                                final Object oldValue =\n-                                    currentEntry.setValue(value);\n-\n-                                // Gets old key and pairs with new value\n-                                final Object inverseKey =\n-                                    HashBidiMap.this.maps[1].remove(oldValue);\n-                                HashBidiMap.this.maps[1].put(value, inverseKey);\n-\n-                                return oldValue;\n-                            }\n-\n-                        }; // anonymous Map.Entry\n-                    };\n-                }; // anonymous Iterator\n-            }\n-\n-            public boolean remove(Object obj) {\n-                // XXX Throws ClassCastException if obj is not a Map.Entry.\n-                // Is this acceptable?\n-                final Object removed =\n-                    HashBidiMap.this.remove(((Map.Entry)obj).getKey());\n-                return removed != null;\n-            }\n-\n-            public int size() {\n-                return HashBidiMap.this.maps[0].size();\n-            }\n-\n-        }; // anonymous AbstractSet\n-\n-    } // entrySet()\n-\n-    /**\n-     * Inverse view of this BidiMap.\n-     */\n-    private final class InverseBidiMap extends AbstractMap implements BidiMap {\n-\n-        public Object getKey(Object value) {\n-            return HashBidiMap.this.get(value);\n-        }\n-\n-        public BidiMap inverseBidiMap() {\n-            return HashBidiMap.this;\n-        }\n-\n-        public Object removeKey(Object value) {\n-            return HashBidiMap.this.remove(value);\n-        }\n-\n-        public Set entrySet() {\n-            // Gets entry set from outer class\n-            final Set entrySet = HashBidiMap.this.entrySet();\n-\n-            // Returns anonymous Set\n-            return new AbstractSet() {\n-\n-                public int size() {\n-                    return HashBidiMap.this.size();\n-                }\n-\n-                public Iterator iterator() {\n-                    final Iterator delegate = entrySet.iterator();\n-\n-                    // Returns anonymous Iterator\n-                    return new Iterator() {\n-\n-                        public boolean hasNext() {\n-                            return delegate.hasNext();\n-                        }\n-\n-                        public Object next() {\n-                            final Map.Entry entry = (Map.Entry)delegate.next();\n-\n-                            // Returns anonymous Map.Entry\n-                            return new Map.Entry() {\n-\n-                                public Object getKey() {\n-                                    return entry.getValue();\n-                                }\n-\n-                                public Object getValue() {\n-                                    return entry.getKey();\n-                                }\n-\n-                                public Object setValue(Object value) {\n-                                    // This is confusing.  Basically, we are \n-                                    // setting a new key for existing value\n-                                    \n-                                    // Gets value for current key\n-                                    final Object oldValue =\n-                                        HashBidiMap.this.maps[0].remove(getValue());\n-                                    \n-                                    // Puts new key and value into map    \n-                                    HashBidiMap.this.maps[0].put(\n-                                        value,\n-                                        oldValue);\n-                                        \n-                                    // Returns old value\n-                                    return oldValue;\n-                                }\n-\n-                            }; // anonymous Map.Entry\n-\n-                        }\n-\n-                        public void remove() {\n-                            delegate.remove();\n-                        }\n-\n-                    }; // anonymous Iterator\n-                }\n-\n-            }; // anonymous AbstractSet\n-\n-        } // entrySet()\n-\n-    } // InverseBidiMap\n-\n-} // HashBidiMap\n+        if (entrySet == null) {\n+            entrySet = new EntrySet(this);\n+        }\n+        return entrySet;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Inner class View.\n+     */\n+    protected static abstract class View extends AbstractCollectionDecorator {\n+        \n+        protected final HashBidiMap map;\n+        \n+        protected View(Collection coll, HashBidiMap map) {\n+            super(coll);\n+            this.map = map;\n+        }\n+\n+        public boolean removeAll(Collection coll) {\n+            boolean modified = false;\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next())) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        public boolean retainAll(Collection coll) {\n+            boolean modified = false;\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                if (coll.contains(it.next()) == false) {\n+                    it.remove();\n+                    modified = true;\n+                }\n+            }\n+            return modified;\n+        }\n+\n+        public void clear() {\n+            map.clear();\n+        }\n+    }\n+    \n+    /**\n+     * Inner class KeySet.\n+     */\n+    protected static class KeySet extends View implements Set {\n+        \n+        protected KeySet(HashBidiMap map) {\n+            super(map.maps[0].keySet(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new AbstractIteratorDecorator(super.iterator()) {\n+                private Object last;\n+                \n+                public Object next() {\n+                    last = super.next();\n+                    return last;\n+                }\n+\n+                public void remove() {\n+                    Object value = map.maps[0].get(last);\n+                    super.remove();\n+                    map.maps[1].remove(value);\n+                }\n+            };\n+        }\n+        \n+        public boolean remove(Object key) {\n+            if (contains(key)) {\n+                Object value = map.maps[0].remove(key);\n+                map.maps[1].remove(value);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Inner class Values.\n+     */\n+    protected static class Values extends View {\n+        \n+        protected Values(HashBidiMap map) {\n+            super(map.maps[0].values(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new AbstractIteratorDecorator(super.iterator()) {\n+                private Object last;\n+                \n+                public Object next() {\n+                    last = super.next();\n+                    return last;\n+                }\n+\n+                public void remove() {\n+                    super.remove();\n+                    map.maps[1].remove(last);\n+                }\n+            };\n+        }\n+        \n+        public boolean remove(Object value) {\n+            if (contains(value)) {\n+                Object key = map.maps[1].remove(value);\n+                map.maps[0].remove(key);\n+                return true;\n+            }\n+            return false;\n+        }\n+        \n+    }\n+    \n+    /**\n+     * Inner class EntrySet.\n+     */\n+    protected static class EntrySet extends View implements Set {\n+        \n+        protected EntrySet(HashBidiMap map) {\n+            super(map.maps[0].entrySet(), map);\n+        }\n+\n+        public Iterator iterator() {\n+            return new AbstractIteratorDecorator(super.iterator()) {\n+                private Map.Entry last;\n+                \n+                public Object next() {\n+                    last = new MapEntry((Map.Entry) super.next(), map);\n+                    return last;\n+                }\n+\n+                public void remove() {\n+                    super.remove();\n+                    map.maps[0].remove(last.getValue());\n+                }\n+            };\n+        }\n+        \n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            if (map.containsKey(entry.getKey())) {\n+                Object value = map.maps[0].remove(entry.getKey());\n+                map.maps[1].remove(value);\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    protected static class MapEntry extends AbstractMapEntryDecorator {\n+        \n+        protected final HashBidiMap map;\n+        \n+        protected MapEntry(Map.Entry entry, HashBidiMap map) {\n+            super(entry);\n+            this.map = map;\n+        }\n+        \n+        public Object setValue(Object value) {\n+            final Object oldValue = super.setValue(value);\n+\n+            // Gets old key and pairs with new value\n+            final Object inverseKey = map.maps[1].remove(oldValue);\n+            map.maps[1].put(value, inverseKey);\n+\n+            return oldValue;\n+        }\n+    }\n+    \n+}", "timestamp": 1065386452, "metainfo": ""}