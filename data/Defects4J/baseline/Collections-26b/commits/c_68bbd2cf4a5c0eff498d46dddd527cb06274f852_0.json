{"sha": "68bbd2cf4a5c0eff498d46dddd527cb06274f852", "log": "[COLLECTIONS-570] Consistently use a NullPointerException if a required input is null.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/BagUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/BagUtils.java\n      * @param <E> the element type\n      * @param bag the bag to synchronize, must not be null\n      * @return a synchronized bag backed by that bag\n-     * @throws IllegalArgumentException if the Bag is null\n+     * @throws NullPointerException if the Bag is null\n      */\n     public static <E> Bag<E> synchronizedBag(final Bag<E> bag) {\n         return SynchronizedBag.synchronizedBag(bag);\n      * @param <E> the element type\n      * @param bag the bag whose unmodifiable view is to be returned, must not be null\n      * @return an unmodifiable view of that bag\n-     * @throws IllegalArgumentException if the Bag is null\n+     * @throws NullPointerException if the Bag is null\n      */\n     public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n         return UnmodifiableBag.unmodifiableBag(bag);\n      * @param bag the bag to predicate, must not be null\n      * @param predicate the predicate for the bag, must not be null\n      * @return a predicated bag backed by the given bag\n-     * @throws IllegalArgumentException if the Bag or Predicate is null\n+     * @throws NullPointerException if the Bag or Predicate is null\n      */\n     public static <E> Bag<E> predicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n         return PredicatedBag.predicatedBag(bag, predicate);\n      * @param bag the bag to predicate, must not be null\n      * @param transformer the transformer for the bag, must not be null\n      * @return a transformed bag backed by the given bag\n-     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     * @throws NullPointerException if the Bag or Transformer is null\n      */\n     public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         return TransformedBag.transformingBag(bag, transformer);\n      * @param <E> the element type\n      * @param bag the bag to decorate, must not be null\n      * @return a Bag that complies to the Collection contract\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      * @since 4.0\n      */\n     public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n      * @param <E> the element type\n      * @param bag the bag to synchronize, must not be null\n      * @return a synchronized bag backed by that bag\n-     * @throws IllegalArgumentException if the SortedBag is null\n+     * @throws NullPointerException if the SortedBag is null\n      */\n     public static <E> SortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n         return SynchronizedSortedBag.synchronizedSortedBag(bag);\n      * @param <E> the element type\n      * @param bag the bag whose unmodifiable view is to be returned, must not be null\n      * @return an unmodifiable view of that bag\n-     * @throws IllegalArgumentException if the SortedBag is null\n+     * @throws NullPointerException if the SortedBag is null\n      */\n     public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n         return UnmodifiableSortedBag.unmodifiableSortedBag(bag);\n      * @param bag the sorted bag to predicate, must not be null\n      * @param predicate the predicate for the bag, must not be null\n      * @return a predicated bag backed by the given bag\n-     * @throws IllegalArgumentException if the SortedBag or Predicate is null\n+     * @throws NullPointerException if the SortedBag or Predicate is null\n      */\n     public static <E> SortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n             final Predicate<? super E> predicate) {\n      * @param bag the bag to predicate, must not be null\n      * @param transformer the transformer for the bag, must not be null\n      * @return a transformed bag backed by the given bag\n-     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     * @throws NullPointerException if the Bag or Transformer is null\n      */\n     public static <E> SortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n                                                          final Transformer<? super E, ? extends E> transformer) {\n--- a/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ClosureUtils.java\n      * @param predicate  the predicate to use as an end of loop test, not null\n      * @param closure  the closure to call repeatedly, not null\n      * @return the <code>while</code> closure\n-     * @throws IllegalArgumentException if either argument is null\n+     * @throws NullPointerException if either argument is null\n      */\n     public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate, final Closure<? super E> closure) {\n         return WhileClosure.<E>whileClosure(predicate, closure, false);\n      * @param closure  the closure to call repeatedly, not null\n      * @param predicate  the predicate to use as an end of loop test, not null\n      * @return the <code>do-while</code> closure\n-     * @throws IllegalArgumentException if either argument is null\n+     * @throws NullPointerException if either argument is null\n      */\n     public static <E> Closure<E> doWhileClosure(final Closure<? super E> closure,\n                                                 final Predicate<? super E> predicate) {\n      * @param <E>  the type that the closure acts on\n      * @param methodName  the name of the method\n      * @return the <code>invoker</code> closure\n-     * @throws IllegalArgumentException if the method name is null\n+     * @throws NullPointerException if the method name is null\n      */\n     public static <E> Closure<E> invokerClosure(final String methodName) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n      * @param paramTypes  the parameter types\n      * @param args  the arguments\n      * @return the <code>invoker</code> closure\n-     * @throws IllegalArgumentException if the method name is null\n+     * @throws NullPointerException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n     public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes,\n      * @param <E>  the type that the closure acts on\n      * @param closures  an array of closures to chain\n      * @return the <code>chained</code> closure\n-     * @throws IllegalArgumentException if the closures array is null\n-     * @throws IllegalArgumentException if any closure in the array is null\n+     * @throws NullPointerException if the closures array is null\n+     * @throws NullPointerException if any closure in the array is null\n      */\n     public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n         return ChainedClosure.chainedClosure(closures);\n      * @param <E>  the type that the closure acts on\n      * @param closures  a collection of closures to chain\n      * @return the <code>chained</code> closure\n-     * @throws IllegalArgumentException if the closures collection is null\n+     * @throws NullPointerException if the closures collection is null\n+     * @throws NullPointerException if any closure in the collection is null\n      * @throws IllegalArgumentException if the closures collection is empty\n-     * @throws IllegalArgumentException if any closure in the collection is null\n      */\n     public static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n         return ChainedClosure.chainedClosure(closures);\n      * @param predicate  the validating predicate\n      * @param trueClosure  the closure called if the predicate is true\n      * @return the <code>if</code> closure\n-     * @throws IllegalArgumentException if the predicate is null\n-     * @throws IllegalArgumentException if the closure is null\n+     * @throws NullPointerException if the predicate or closure is null\n      * @since 3.2\n      */\n     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n      * @param trueClosure  the closure called if the predicate is true\n      * @param falseClosure  the closure called if the predicate is false\n      * @return the <code>switch</code> closure\n-     * @throws IllegalArgumentException if the predicate is null\n-     * @throws IllegalArgumentException if either closure is null\n+     * @throws NullPointerException if the predicate or either closure is null\n      */\n     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n                                            final Closure<? super E> trueClosure,\n      * @param predicates  an array of predicates to check, not null\n      * @param closures  an array of closures to call, not null\n      * @return the <code>switch</code> closure\n-     * @throws IllegalArgumentException if the either array is null\n-     * @throws IllegalArgumentException if any element in the arrays is null\n-     * @throws IllegalArgumentException if the arrays are different sizes\n+     * @throws NullPointerException if the either array is null\n+     * @throws NullPointerException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays have different sizes\n      */\n     public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n                                                final Closure<? super E>[] closures) {\n      * @param closures  an array of closures to call, not null\n      * @param defaultClosure  the default to call if no predicate matches\n      * @return the <code>switch</code> closure\n-     * @throws IllegalArgumentException if the either array is null\n-     * @throws IllegalArgumentException if any element in the arrays is null\n+     * @throws NullPointerException if the either array is null\n+     * @throws NullPointerException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n     public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n      * @param <E>  the type that the closure acts on\n      * @param predicatesAndClosures  a map of predicates to closures\n      * @return the <code>switch</code> closure\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n+     * @throws NullPointerException if any closure in the map is null\n      * @throws IllegalArgumentException if the map is empty\n-     * @throws IllegalArgumentException if any closure in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n      * @param <E>  the type that the closure acts on\n      * @param objectsAndClosures  a map of objects to closures\n      * @return the closure\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n+     * @throws NullPointerException if any closure in the map is null\n      * @throws IllegalArgumentException if the map is empty\n-     * @throws IllegalArgumentException if any closure in the map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Closure<E> switchMapClosure(final Map<? extends E, Closure<E>> objectsAndClosures) {\n         if (objectsAndClosures == null) {\n-            throw new IllegalArgumentException(\"The object and closure map must not be null\");\n+            throw new NullPointerException(\"The object and closure map must not be null\");\n         }\n         final Closure<? super E> def = objectsAndClosures.remove(null);\n         final int size = objectsAndClosures.size();\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n      * @param b  the second collection, must not be null\n      * @param equator  the Equator used for testing equality\n      * @return <code>true</code> iff the collections contain the same elements with the same cardinalities.\n-     * @throws IllegalArgumentException if the equator is null\n+     * @throws NullPointerException if the equator is null\n      * @since 4.0\n      */\n     public static <E> boolean isEqualCollection(final Collection<? extends E> a,\n                                                 final Collection<? extends E> b,\n                                                 final Equator<? super E> equator) {\n         if (equator == null) {\n-            throw new IllegalArgumentException(\"equator may not be null\");\n+            throw new NullPointerException(\"Equator must not be null.\");\n         }\n \n         if(a.size() != b.size()) {\n      * @param a  the first collection, must not be null\n      * @param b  the second collection, must not be null\n      * @return a new sorted List, containing the elements of Collection a and b\n-     * @throws IllegalArgumentException if either collection is null\n+     * @throws NullPointerException if either collection is null\n      * @since 4.0\n      */\n     public static <O extends Comparable<? super O>> List<O> collate(Iterable<? extends O> a,\n      * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n      *   they will be removed in the output collection\n      * @return a new sorted List, containing the elements of Collection a and b\n-     * @throws IllegalArgumentException if either collection is null\n+     * @throws NullPointerException if either collection is null\n      * @since 4.0\n      */\n     public static <O extends Comparable<? super O>> List<O> collate(final Iterable<? extends O> a,\n      * @param b  the second collection, must not be null\n      * @param c  the comparator to use for the merge.\n      * @return a new sorted List, containing the elements of Collection a and b\n-     * @throws IllegalArgumentException if either collection or the comparator is null\n+     * @throws NullPointerException if either collection or the comparator is null\n      * @since 4.0\n      */\n     public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,\n      * @param includeDuplicates  if {@code true} duplicate elements will be retained, otherwise\n      *   they will be removed in the output collection\n      * @return a new sorted List, containing the elements of Collection a and b\n-     * @throws IllegalArgumentException if either collection or the comparator is null\n+     * @throws NullPointerException if either collection or the comparator is null\n      * @since 4.0\n      */\n     public static <O> List<O> collate(final Iterable<? extends O> a, final Iterable<? extends O> b,\n                                       final Comparator<? super O> c, final boolean includeDuplicates) {\n \n         if (a == null || b == null) {\n-            throw new IllegalArgumentException(\"The collections must not be null\");\n+            throw new NullPointerException(\"The collections must not be null\");\n         }\n         if (c == null) {\n-            throw new IllegalArgumentException(\"The comparator must not be null\");\n+            throw new NullPointerException(\"The comparator must not be null\");\n         }\n \n         // if both Iterables are a Collection, we can estimate the size\n      * @param <C>  the type of object the {@link Collection} contains\n      * @param collection  the collection to synchronize, must not be null\n      * @return a synchronized collection backed by the given collection\n-     * @throws IllegalArgumentException  if the collection is null\n+     * @throws NullPointerException if the collection is null\n      * @deprecated since 4.1, use {@link java.util.Collections#synchronizedCollection(Collection)} instead\n      */\n     @Deprecated\n      * @param <C>  the type of object the {@link Collection} contains\n      * @param collection  the collection to make unmodifiable, must not be null\n      * @return an unmodifiable collection backed by the given collection\n-     * @throws IllegalArgumentException  if the collection is null\n+     * @throws NullPointerException if the collection is null\n      * @deprecated since 4.1, use {@link java.util.Collections#unmodifiableCollection(Collection)} instead\n      */\n     @Deprecated\n      * It is important not to use the original collection after invoking this method,\n      * as it is a backdoor for adding invalid objects.\n      *\n+     * @param <C> the type of objects in the Collection.\n      * @param collection  the collection to predicate, must not be null\n      * @param predicate  the predicate for the collection, must not be null\n-     * @param <C> the type of objects in the Collection.\n      * @return a predicated collection backed by the given collection\n-     * @throws IllegalArgumentException  if the Collection is null\n+     * @throws NullPointerException if the Collection is null\n      */\n     public static <C> Collection<C> predicatedCollection(final Collection<C> collection,\n                                                          final Predicate<? super C> predicate) {\n      * Existing entries in the specified collection will not be transformed.\n      * If you want that behaviour, see {@link TransformedCollection#transformedCollection}.\n      *\n-     * @param <E>  the type of object the {@link Collection} contains\n+     * @param <E> the type of object the {@link Collection} contains\n      * @param collection  the collection to predicate, must not be null\n      * @param transformer  the transformer for the collection, must not be null\n      * @return a transformed collection backed by the given collection\n-     * @throws IllegalArgumentException  if the Collection or Transformer is null\n+     * @throws NullPointerException if the Collection or Transformer is null\n      */\n     public static <E> Collection<E> transformingCollection(final Collection<E> collection,\n             final Transformer<? super E, ? extends E> transformer) {\n      * @param <E> collection type\n      * @param collection to read\n      * @return sole member of collection\n-     * @throws IllegalArgumentException if collection is null/empty or contains more than one element\n+     * @throws NullPointerException if collection is null\n+     * @throws IllegalArgumentException if collection is empty or contains more than one element\n      * @since 4.0\n      */\n     public static <E> E extractSingleton(final Collection<E> collection) {\n-        if (collection == null || collection.size() != 1) {\n+        if (collection == null) {\n+            throw new NullPointerException(\"Collection must not be null.\");\n+        }\n+        if (collection.size() != 1) {\n             throw new IllegalArgumentException(\"Can extract singleton only when collection size == 1\");\n         }\n         return collection.iterator().next();\n--- a/src/main/java/org/apache/commons/collections4/FactoryUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/FactoryUtils.java\n      * @param <T> the type that the factory creates\n      * @param classToInstantiate  the Class to instantiate each time in the factory\n      * @return the <code>reflection</code> factory\n-     * @throws IllegalArgumentException if the classToInstantiate is null\n+     * @throws NullPointerException if the classToInstantiate is null\n      */\n     public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate) {\n         return InstantiateFactory.instantiateFactory(classToInstantiate, null, null);\n      * @param paramTypes  parameter types for the constructor, can be null\n      * @param args  the arguments to pass to the constructor, can be null\n      * @return the <code>reflection</code> factory\n-     * @throws IllegalArgumentException if the classToInstantiate is null\n+     * @throws NullPointerException if the classToInstantiate is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      * @throws IllegalArgumentException if the constructor doesn't exist\n      */\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n      * @param iterator  the iterator to decorate\n      * @param max  the maximum number of elements returned by this iterator\n      * @return a new bounded iterator\n-     * @throws IllegalArgumentException if the iterator is null or max is negative\n+     * @throws NullPointerException if the iterator is null\n+     * @throws IllegalArgumentException if max is negative\n      * @since 4.1\n      */\n     public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n      * @param offset  the index of the first element of the decorated iterator to return\n      * @param max  the maximum number of elements returned by this iterator\n      * @return a new bounded iterator\n-     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n+     * @throws NullPointerException if the iterator is null\n+     * @throws IllegalArgumentException if either offset or max is negative\n      * @since 4.1\n      */\n     public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n--- a/src/main/java/org/apache/commons/collections4/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/ListUtils.java\n      * Returns a new list containing all elements that are contained in\n      * both given lists.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list1  the first list\n      * @param list2  the second list\n      * @return  the intersection of those two lists\n      * contains one occurrence, then the returned list will still contain\n      * one occurrence.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list1  the list to subtract from\n      * @param list2  the list to subtract\n-     * @return  a new list containing the results\n+     * @return a new list containing the results\n      * @throws NullPointerException if either list is null\n      */\n     public static <E> List<E> subtract(final List<E> list1, final List<? extends E> list2) {\n      * Returns the sum of the given lists.  This is their intersection\n      * subtracted from their union.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list1  the first list\n      * @param list2  the second list\n      * @return  a new list containing the sum of those lists\n      * first list.  The {@link List#addAll(Collection)} operation is\n      * used to append the two given lists into a new list.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list1  the first list\n      * @param list2  the second list\n-     * @return  a new list containing the union of those lists\n+     * @return a new list containing the union of those lists\n      * @throws NullPointerException if either list is null\n      */\n     public static <E> List<E> union(final List<? extends E> list1, final List<? extends E> list2) {\n      * <p>\n      * A <code>null</code> predicate matches no elements.\n      *\n-     * @param <E>  the element type\n-     * @param inputCollection\n-     *            the collection to get the input from, may not be null\n-     * @param predicate\n-     *            the predicate to use, may be null\n+     * @param <E> the element type\n+     * @param inputCollection  the collection to get the input from, may not be null\n+     * @param predicate  the predicate to use, may be null\n      * @return the elements matching the predicate (new list)\n-     * @throws NullPointerException\n-     *             if the input list is null\n+     * @throws NullPointerException if the input list is null\n      *\n      * @since 4.0\n      * @see CollectionUtils#select(Iterable, Predicate)\n      * Selects all elements from inputCollection which don't match the given\n      * predicate into an output collection.\n      * <p>\n-     * If the input predicate is <code>null</code>, the result is an empty\n-     * list.\n-     *\n-     * @param <E>  the element type\n-     * @param inputCollection\n-     *            the collection to get the input from, may not be null\n-     * @param predicate\n-     *            the predicate to use, may be null\n+     * If the input predicate is <code>null</code>, the result is an empty list.\n+     *\n+     * @param <E> the element type\n+     * @param inputCollection the collection to get the input from, may not be null\n+     * @param predicate the predicate to use, may be null\n      * @return the elements <b>not</b> matching the predicate (new list)\n-     * @throws NullPointerException\n-     *             if the input collection is null\n+     * @throws NullPointerException if the input collection is null\n      *\n      * @since 4.0\n      * @see CollectionUtils#selectRejected(Iterable, Predicate)\n      *\n      * This method is just a wrapper for {@link Collections#synchronizedList(List)}.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list  the list to synchronize, must not be null\n      * @return a synchronized list backed by the given list\n-     * @throws IllegalArgumentException  if the list is null\n+     * @throws NullPointerException if the list is null\n      */\n     public static <E> List<E> synchronizedList(final List<E> list) {\n         return Collections.synchronizedList(list);\n      * @param <E>  the element type\n      * @param list  the list to make unmodifiable, must not be null\n      * @return an unmodifiable list backed by the given list\n-     * @throws IllegalArgumentException  if the list is null\n+     * @throws NullPointerException if the list is null\n      */\n     public static <E> List<E> unmodifiableList(final List<? extends E> list) {\n         return UnmodifiableList.unmodifiableList(list);\n      * It is important not to use the original list after invoking this method,\n      * as it is a backdoor for adding invalid objects.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list  the list to predicate, must not be null\n      * @param predicate  the predicate for the list, must not be null\n      * @return a predicated list backed by the given list\n-     * @throws IllegalArgumentException  if the List or Predicate is null\n+     * @throws NullPointerException if the List or Predicate is null\n      */\n     public static <E> List<E> predicatedList(final List<E> list, final Predicate<E> predicate) {\n         return PredicatedList.predicatedList(list, predicate);\n      * Existing entries in the specified list will not be transformed.\n      * If you want that behaviour, see {@link TransformedList#transformedList}.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list  the list to predicate, must not be null\n      * @param transformer  the transformer for the list, must not be null\n      * @return a transformed list backed by the given list\n-     * @throws IllegalArgumentException  if the List or Transformer is null\n+     * @throws NullPointerException if the List or Transformer is null\n      */\n     public static <E> List<E> transformedList(final List<E> list,\n                                               final Transformer<? super E, ? extends E> transformer) {\n      * instance is the fourth element in the list.  The first, second,\n      * and third element are all set to <code>null</code>.\n      *\n-     * @param <E>  the element type\n+     * @param <E> the element type\n      * @param list  the list to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n      * @return a lazy list backed by the given list\n-     * @throws IllegalArgumentException  if the List or Factory is null\n+     * @throws NullPointerException if the List or Factory is null\n      */\n     public static <E> List<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n         return LazyList.lazyList(list, factory);\n      * @param <E>  the element type\n      * @param list  the list whose size to fix, must not be null\n      * @return a fixed-size list backed by that list\n-     * @throws IllegalArgumentException  if the List is null\n+     * @throws NullPointerException  if the List is null\n      */\n     public static <E> List<E> fixedSizeList(final List<E> list) {\n         return FixedSizeList.fixedSizeList(list);\n      * @param a  the first list\n      * @param b  the second list\n      * @return the longest common subsequence\n-     * @throws IllegalArgumentException if either list is {@code null}\n+     * @throws NullPointerException if either list is {@code null}\n      * @since 4.0\n      */\n     public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b) {\n      * @param b  the second list\n      * @param equator  the equator used to test object equality\n      * @return the longest common subsequence\n-     * @throws IllegalArgumentException if either list or the equator is {@code null}\n+     * @throws NullPointerException if either list or the equator is {@code null}\n      * @since 4.0\n      */\n     public static <E> List<E> longestCommonSubsequence(final List<E> a, final List<E> b,\n                                                        final Equator<? super E> equator) {\n         if (a == null || b == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n+            throw new NullPointerException(\"List must not be null\");\n         }\n         if (equator == null) {\n-          throw new IllegalArgumentException(\"Equator must not be null\");\n+          throw new NullPointerException(\"Equator must not be null\");\n         }\n \n         final SequencesComparator<E> comparator = new SequencesComparator<E>(a, b, equator);\n      * @param a  the first sequence\n      * @param b  the second sequence\n      * @return the longest common subsequence as {@link String}\n-     * @throws IllegalArgumentException if either sequence is {@code null}\n+     * @throws NullPointerException if either sequence is {@code null}\n      * @since 4.0\n      */\n     public static String longestCommonSubsequence(final CharSequence a, final CharSequence b) {\n         if (a == null || b == null) {\n-            throw new IllegalArgumentException(\"CharSequence must not be null\");\n+            throw new NullPointerException(\"CharSequence must not be null\");\n         }\n         final List<Character> lcs = longestCommonSubsequence(new CharSequenceAsList( a ), new CharSequenceAsList( b ));\n         final StringBuilder sb = new StringBuilder();\n      * <p>\n      * Adapted from http://code.google.com/p/guava-libraries/\n      *\n-     * @param <T>  the element type\n+     * @param <T> the element type\n      * @param list  the list to return consecutive sublists of\n      * @param size  the desired size of each sublist (the last may be smaller)\n      * @return a list of consecutive sublists\n-     * @throws IllegalArgumentException if list is {@code null} or size is not strictly positive\n+     * @throws NullPointerException if list is null\n+     * @throws IllegalArgumentException if size is not strictly positive\n      * @since 4.0\n      */\n     public static <T> List<List<T>> partition(final List<T> list, final int size) {\n         if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n+            throw new NullPointerException(\"List must not be null\");\n         }\n         if (size <= 0) {\n             throw new IllegalArgumentException(\"Size must be greater than 0\");\n--- a/src/main/java/org/apache/commons/collections4/MapUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/MapUtils.java\n      * @param <V>  the value type\n      * @param map  the map to make unmodifiable, must not be null\n      * @return an unmodifiable map backed by the given map\n-     * @throws IllegalArgumentException  if the map is null\n+     * @throws NullPointerException  if the map is null\n      */\n     public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n         return UnmodifiableMap.unmodifiableMap(map);\n      * @param keyPred  the predicate for keys, null means no check\n      * @param valuePred  the predicate for values, null means no check\n      * @return a predicated map backed by the given map\n-     * @throws IllegalArgumentException  if the Map is null\n+     * @throws NullPointerException  if the Map is null\n      */\n     public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred,\n                                                          final Predicate<? super V> valuePred) {\n      * @param keyTransformer  the transformer for the map keys, null means no transformation\n      * @param valueTransformer  the transformer for the map values, null means no transformation\n      * @return a transformed map backed by the given map\n-     * @throws IllegalArgumentException  if the Map is null\n+     * @throws NullPointerException  if the Map is null\n      */\n     public static <K, V> IterableMap<K, V> transformedMap(final Map<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n      * @param <V>  the value type\n      * @param map  the map whose size to fix, must not be null\n      * @return a fixed-size map backed by that map\n-     * @throws IllegalArgumentException  if the Map is null\n+     * @throws NullPointerException  if the Map is null\n      */\n     public static <K, V> IterableMap<K, V> fixedSizeMap(final Map<K, V> map) {\n         return FixedSizeMap.fixedSizeMap(map);\n      * @param map  the map to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n-     * @throws IllegalArgumentException  if the Map or Factory is null\n+     * @throws NullPointerException  if the Map or Factory is null\n      */\n     public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Factory<? extends V> factory) {\n         return LazyMap.lazyMap(map, factory);\n      * @param map  the map to make lazy, must not be null\n      * @param transformerFactory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n-     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     * @throws NullPointerException  if the Map or Transformer is null\n      */\n     public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map,\n             final Transformer<? super K, ? extends V> transformerFactory) {\n      * @param <V>  the value type\n      * @param map  the map to order, must not be null\n      * @return an ordered map backed by the given map\n-     * @throws IllegalArgumentException  if the Map is null\n+     * @throws NullPointerException  if the Map is null\n      */\n     public static <K, V> OrderedMap<K, V> orderedMap(final Map<K, V> map) {\n         return ListOrderedMap.listOrderedMap(map);\n      * @param <V>  the value type\n      * @param map  the map to synchronize, must not be null\n      * @return a synchronized map backed by the given map\n-     * @throws IllegalArgumentException  if the map is null\n+     * @throws NullPointerException  if the map is null\n      */\n     public static <K, V> SortedMap<K, V> synchronizedSortedMap(final SortedMap<K, V> map) {\n         return Collections.synchronizedSortedMap(map);\n      * @param <V>  the value type\n      * @param map  the sorted map to make unmodifiable, must not be null\n      * @return an unmodifiable map backed by the given map\n-     * @throws IllegalArgumentException  if the map is null\n+     * @throws NullPointerException  if the map is null\n      */\n     public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n         return UnmodifiableSortedMap.unmodifiableSortedMap(map);\n      * @param keyPred  the predicate for keys, null means no check\n      * @param valuePred  the predicate for values, null means no check\n      * @return a predicated map backed by the given map\n-     * @throws IllegalArgumentException  if the SortedMap is null\n+     * @throws NullPointerException  if the SortedMap is null\n      */\n     public static <K, V> SortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n             final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n      * @param keyTransformer  the transformer for the map keys, null means no transformation\n      * @param valueTransformer  the transformer for the map values, null means no transformation\n      * @return a transformed map backed by the given map\n-     * @throws IllegalArgumentException  if the SortedMap is null\n+     * @throws NullPointerException  if the SortedMap is null\n      */\n     public static <K, V> SortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n      * @param <V>  the value type\n      * @param map  the map whose size to fix, must not be null\n      * @return a fixed-size map backed by that map\n-     * @throws IllegalArgumentException  if the SortedMap is null\n+     * @throws NullPointerException  if the SortedMap is null\n      */\n     public static <K, V> SortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n         return FixedSizeSortedMap.fixedSizeSortedMap(map);\n      * @param map  the map to make lazy, must not be null\n      * @param factory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n-     * @throws IllegalArgumentException  if the SortedMap or Factory is null\n+     * @throws NullPointerException  if the SortedMap or Factory is null\n      */\n     public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n         return LazySortedMap.lazySortedMap(map, factory);\n      * @param map  the map to make lazy, must not be null\n      * @param transformerFactory  the factory for creating new objects, must not be null\n      * @return a lazy map backed by the given map\n-     * @throws IllegalArgumentException  if the Map or Transformer is null\n+     * @throws NullPointerException  if the Map or Transformer is null\n      */\n     public static <K, V> SortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n             final Transformer<? super K, ? extends V> transformerFactory) {\n      * @param <V>  the value type\n      * @param map to wrap if necessary.\n      * @return IterableMap<K, V>\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> IterableMap<K, V> iterableMap(final Map<K, V> map) {\n         if (map == null) {\n-            throw new IllegalArgumentException(\"Map must not be null\");\n+            throw new NullPointerException(\"Map must not be null\");\n         }\n         return map instanceof IterableMap ? (IterableMap<K, V>) map : new AbstractMapDecorator<K, V>(map) {};\n     }\n      * @param <V>  the value type\n      * @param sortedMap to wrap if necessary\n      * @return {@link IterableSortedMap}<K, V>\n+     * @throws NullPointerException if sortedMap is null\n      * @since 4.0\n      */\n     public static <K, V> IterableSortedMap<K, V> iterableSortedMap(final SortedMap<K, V> sortedMap) {\n         if (sortedMap == null) {\n-            throw new IllegalArgumentException(\"Map must not be null\");\n+            throw new NullPointerException(\"Map must not be null\");\n         }\n         return sortedMap instanceof IterableSortedMap ? (IterableSortedMap<K, V>) sortedMap :\n                                                         new AbstractSortedMapDecorator<K, V>(sortedMap) {};\n--- a/src/main/java/org/apache/commons/collections4/PredicateUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/PredicateUtils.java\n      *\n      * @param type  the type to check for, may not be null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the class is null\n+     * @throws NullPointerException if the class is null\n      * @see InstanceofPredicate\n      */\n     public static Predicate<Object> instanceofPredicate(final Class<?> type) {\n      * @param <T>  the type that the predicate queries\n      * @param methodName  the method name to call on the input object, may not be null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the methodName is null.\n+     * @throws NullPointerException if the methodName is null.\n      * @see InvokerTransformer\n      * @see TransformerPredicate\n      */\n      * @param paramTypes  the parameter types\n      * @param args  the arguments\n      * @return the predicate\n-     * @throws IllegalArgumentException if the method name is null\n+     * @throws NullPointerException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      * @see InvokerTransformer\n      * @see TransformerPredicate\n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n      * @return the <code>and</code> predicate\n-     * @throws IllegalArgumentException if either predicate is null\n+     * @throws NullPointerException if either predicate is null\n      * @see AndPredicate\n      */\n     public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n      * @param <T>  the type that the predicate queries\n      * @param predicates  an array of predicates to check, may not be null\n      * @return the <code>all</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      * @see AllPredicate\n      */\n     public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n      * @param <T>  the type that the predicate queries\n      * @param predicates  a collection of predicates to check, may not be null\n      * @return the <code>all</code> predicate\n-     * @throws IllegalArgumentException if the predicates collection is null\n-     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @throws NullPointerException if the predicates collection is null\n+     * @throws NullPointerException if any predicate in the collection is null\n      * @see AllPredicate\n      */\n     public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n      * @return the <code>or</code> predicate\n-     * @throws IllegalArgumentException if either predicate is null\n+     * @throws NullPointerException if either predicate is null\n      * @see OrPredicate\n      */\n     public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n      * @param <T>  the type that the predicate queries\n      * @param predicates  an array of predicates to check, may not be null\n      * @return the <code>any</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      * @see AnyPredicate\n      */\n     public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n      * @param <T>  the type that the predicate queries\n      * @param predicates  a collection of predicates to check, may not be null\n      * @return the <code>any</code> predicate\n-     * @throws IllegalArgumentException if the predicates collection is null\n-     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @throws NullPointerException if the predicates collection is null\n+     * @throws NullPointerException if any predicate in the collection is null\n      * @see AnyPredicate\n      */\n     public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n      * @return the <code>either</code> predicate\n-     * @throws IllegalArgumentException if either predicate is null\n+     * @throws NullPointerException if either predicate is null\n      * @see OnePredicate\n      */\n     public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1,\n      * @param <T>  the type that the predicate queries\n      * @param predicates  an array of predicates to check, may not be null\n      * @return the <code>one</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      * @see OnePredicate\n      */\n     public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n      * @param <T>  the type that the predicate queries\n      * @param predicates  a collection of predicates to check, may not be null\n      * @return the <code>one</code> predicate\n-     * @throws IllegalArgumentException if the predicates collection is null\n-     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @throws NullPointerException if the predicates collection is null\n+     * @throws NullPointerException if any predicate in the collection is null\n      * @see OnePredicate\n      */\n     public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n      * @param predicate1  the first predicate, may not be null\n      * @param predicate2  the second predicate, may not be null\n      * @return the <code>neither</code> predicate\n-     * @throws IllegalArgumentException if either predicate is null\n+     * @throws NullPointerException if either predicate is null\n      * @see NonePredicate\n      */\n     public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1,\n      * @param <T>  the type that the predicate queries\n      * @param predicates  an array of predicates to check, may not be null\n      * @return the <code>none</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      * @see NonePredicate\n      */\n     public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n      * @param <T>  the type that the predicate queries\n      * @param predicates  a collection of predicates to check, may not be null\n      * @return the <code>none</code> predicate\n-     * @throws IllegalArgumentException if the predicates collection is null\n-     * @throws IllegalArgumentException if any predicate in the collection is null\n+     * @throws NullPointerException if the predicates collection is null\n+     * @throws NullPointerException if any predicate in the collection is null\n      * @see NonePredicate\n      */\n     public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n      * @param <T>  the type that the predicate queries\n      * @param predicate  the predicate to not\n      * @return the <code>not</code> predicate\n-     * @throws IllegalArgumentException if the predicate is null\n+     * @throws NullPointerException if the predicate is null\n      * @see NotPredicate\n      */\n     public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n      * @param <T>  the type that the predicate queries\n      * @param transformer  the transformer to wrap, may not be null\n      * @return the transformer wrapping predicate\n-     * @throws IllegalArgumentException if the transformer is null\n+     * @throws NullPointerException if the transformer is null\n      * @see TransformerPredicate\n      */\n     public static <T> Predicate<T> asPredicate(final Transformer<? super T, Boolean> transformer) {\n      * @param <T>  the type that the predicate queries\n      * @param predicate  the predicate to wrap, may not be null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null.\n+     * @throws NullPointerException if the predicate is null.\n      * @see NullIsExceptionPredicate\n      */\n     public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate){\n      * @param <T>  the type that the predicate queries\n      * @param predicate  the predicate to wrap, may not be null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null.\n+     * @throws NullPointerException if the predicate is null.\n      * @see NullIsFalsePredicate\n      */\n     public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate){\n      * @param <T>  the type that the predicate queries\n      * @param predicate  the predicate to wrap, may not be null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null.\n+     * @throws NullPointerException if the predicate is null.\n      * @see NullIsTruePredicate\n      */\n     public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate){\n      * @param transformer  the transformer to call first\n      * @param predicate  the predicate to call with the result of the transform\n      * @return the predicate\n-     * @throws IllegalArgumentException if the transformer or the predicate is null\n+     * @throws NullPointerException if the transformer or the predicate is null\n      * @see TransformedPredicate\n      * @since 3.1\n      */\n--- a/src/main/java/org/apache/commons/collections4/QueueUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/QueueUtils.java\n      * @param <E> the type of the elements in the queue\n      * @param queue  the queue to make unmodifiable, must not be null\n      * @return an unmodifiable queue backed by that queue\n-     * @throws IllegalArgumentException  if the Queue is null\n+     * @throws NullPointerException if the queue is null\n      */\n     public static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n         return UnmodifiableQueue.unmodifiableQueue(queue);\n      * @param queue  the queue to predicate, must not be null\n      * @param predicate  the predicate used to evaluate new elements, must not be null\n      * @return a predicated queue\n-     * @throws IllegalArgumentException  if the Queue or Predicate is null\n+     * @throws NullPointerException if the queue or predicate is null\n      */\n     public static <E> Queue<E> predicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n         return PredicatedQueue.predicatedQueue(queue, predicate);\n      * @param queue  the queue to predicate, must not be null\n      * @param transformer  the transformer for the queue, must not be null\n      * @return a transformed queue backed by the given queue\n-     * @throws IllegalArgumentException  if the Queue or Transformer is null\n+     * @throws NullPointerException if the queue or transformer is null\n      */\n     public static <E> Queue<E> transformingQueue(final Queue<E> queue,\n                                                  final Transformer<? super E, ? extends E> transformer) {\n--- a/src/main/java/org/apache/commons/collections4/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n      * @param <E> the element type\n      * @param set  the set to synchronize, must not be null\n      * @return a synchronized set backed by the given set\n-     * @throws IllegalArgumentException  if the set is null\n+     * @throws NullPointerException if the set is null\n      */\n     public static <E> Set<E> synchronizedSet(final Set<E> set) {\n         return Collections.synchronizedSet(set);\n      * @param <E> the element type\n      * @param set  the set to make unmodifiable, must not be null\n      * @return an unmodifiable set backed by the given set\n-     * @throws IllegalArgumentException  if the set is null\n+     * @throws NullPointerException if the set is null\n      */\n     public static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n         return UnmodifiableSet.unmodifiableSet(set);\n      * @param set  the set to predicate, must not be null\n      * @param predicate  the predicate for the set, must not be null\n      * @return a predicated set backed by the given set\n-     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     * @throws NullPointerException if the set or predicate is null\n      */\n     public static <E> Set<E> predicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n         return PredicatedSet.predicatedSet(set, predicate);\n      * @param set  the set to transform, must not be null\n      * @param transformer  the transformer for the set, must not be null\n      * @return a transformed set backed by the given set\n-     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     * @throws NullPointerException if the set or transformer is null\n      */\n     public static <E> Set<E> transformedSet(final Set<E> set,\n                                             final Transformer<? super E, ? extends E> transformer) {\n      * @param <E> the element type\n      * @param set  the set to order, must not be null\n      * @return an ordered set backed by the given set\n-     * @throws IllegalArgumentException  if the Set is null\n+     * @throws NullPointerException if the set is null\n      */\n     public static <E> Set<E> orderedSet(final Set<E> set) {\n         return ListOrderedSet.listOrderedSet(set);\n      * @param <E> the element type\n      * @param set  the sorted set to synchronize, must not be null\n      * @return a synchronized set backed by the given set\n-     * @throws IllegalArgumentException  if the set is null\n+     * @throws NullPointerException if the set is null\n      */\n     public static <E> SortedSet<E> synchronizedSortedSet(final SortedSet<E> set) {\n         return Collections.synchronizedSortedSet(set);\n      * @param <E> the element type\n      * @param set  the sorted set to make unmodifiable, must not be null\n      * @return an unmodifiable set backed by the given set\n-     * @throws IllegalArgumentException  if the set is null\n+     * @throws NullPointerException if the set is null\n      */\n     public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n         return UnmodifiableSortedSet.unmodifiableSortedSet(set);\n      * @param set  the sorted set to predicate, must not be null\n      * @param predicate  the predicate for the sorted set, must not be null\n      * @return a predicated sorted set backed by the given sorted set\n-     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     * @throws NullPointerException if the set or predicate is null\n      */\n     public static <E> SortedSet<E> predicatedSortedSet(final SortedSet<E> set,\n                                                        final Predicate<? super E> predicate) {\n      * @param set  the set to transform, must not be null\n      * @param transformer  the transformer for the set, must not be null\n      * @return a transformed set backed by the given set\n-     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     * @throws NullPointerException if the set or transformer is null\n      */\n     public static <E> SortedSet<E> transformedSortedSet(final SortedSet<E> set,\n                                                         final Transformer<? super E, ? extends E> transformer) {\n      * @param <E> the element type\n      * @param set  the navigable set to make unmodifiable, must not be null\n      * @return an unmodifiable set backed by the given set\n-     * @throws IllegalArgumentException  if the set is null\n+     * @throws NullPointerException if the set is null\n      * @since 4.1\n      */\n     public static <E> SortedSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n      * @param set  the navigable set to predicate, must not be null\n      * @param predicate  the predicate for the navigable set, must not be null\n      * @return a predicated navigable set backed by the given navigable set\n-     * @throws IllegalArgumentException  if the Set or Predicate is null\n+     * @throws NullPointerException if the set or predicate is null\n      * @since 4.1\n      */\n     public static <E> SortedSet<E> predicatedNavigableSet(final NavigableSet<E> set,\n      * @param set  the navigable set to transform, must not be null\n      * @param transformer  the transformer for the set, must not be null\n      * @return a transformed set backed by the given set\n-     * @throws IllegalArgumentException  if the Set or Transformer is null\n+     * @throws NullPointerException if the set or transformer is null\n      * @since 4.1\n      */\n     public static <E> SortedSet<E> transformedNavigableSet(final NavigableSet<E> set,\n--- a/src/main/java/org/apache/commons/collections4/SplitMapUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SplitMapUtils.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n import org.apache.commons.collections4.map.EntrySetToMapIteratorAdapter;\n import org.apache.commons.collections4.map.UnmodifiableEntrySet;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Utilities for working with \"split maps:\" objects that implement {@link Put}\n      * @param <V> the value type\n      * @param get to wrap, must not be null\n      * @return {@link IterableMap}\n+     * @throws NullPointerException if the argument is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <K, V> IterableMap<K, V> readableMap(final Get<K, V> get) {\n         if (get == null) {\n-            throw new IllegalArgumentException(\"Get must not be null\");\n+            throw new NullPointerException(\"Get must not be null\");\n         }\n         if (get instanceof Map) {\n-            return get instanceof IterableMap ? ((IterableMap<K, V>) get) : MapUtils\n-                    .iterableMap((Map<K, V>) get);\n+            return get instanceof IterableMap ?\n+                    ((IterableMap<K, V>) get) :\n+                    MapUtils.iterableMap((Map<K, V>) get);\n         }\n         return new WrappedGet<K, V>(get);\n     }\n      * @param <V> the element type\n      * @param put to wrap, must not be null\n      * @return {@link Map}\n+     * @throws NullPointerException if the argument is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <K, V> Map<K, V> writableMap(final Put<K, V> put) {\n         if (put == null) {\n-            throw new IllegalArgumentException(\"Put must not be null\");\n+            throw new NullPointerException(\"Put must not be null\");\n         }\n         if (put instanceof Map) {\n             return (Map<K, V>) put;\n--- a/src/main/java/org/apache/commons/collections4/TransformerUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/TransformerUtils.java\n      * @param <T>  the input/output type\n      * @param closure  the closure to run each time in the transformer, not null\n      * @return the transformer\n-     * @throws IllegalArgumentException if the closure is null\n+     * @throws NullPointerException if the closure is null\n      * @see ClosureTransformer\n      */\n     public static <T> Transformer<T, T> asTransformer(final Closure<? super T> closure) {\n      * @param <T>  the input type\n      * @param predicate  the predicate to run each time in the transformer, not null\n      * @return the transformer\n-     * @throws IllegalArgumentException if the predicate is null\n+     * @throws NullPointerException if the predicate is null\n      * @see PredicateTransformer\n      */\n     public static <T> Transformer<T, Boolean> asTransformer(final Predicate<? super T> predicate) {\n      * @param <O>  the output type\n      * @param factory  the factory to run each time in the transformer, not null\n      * @return the transformer\n-     * @throws IllegalArgumentException if the factory is null\n+     * @throws NullPointerException if the factory is null\n      * @see FactoryTransformer\n      */\n     public static <I, O> Transformer<I, O> asTransformer(final Factory<? extends O> factory) {\n      * @param <T>  the input/output type\n      * @param transformers  an array of transformers to chain\n      * @return the transformer\n-     * @throws IllegalArgumentException if the transformers array or any of the transformers is null\n+     * @throws NullPointerException if the transformers array or any of the transformers is null\n      * @see ChainedTransformer\n      */\n     public static <T> Transformer<T, T> chainedTransformer(\n      * @param <T>  the input/output type\n      * @param transformers  a collection of transformers to chain\n      * @return the transformer\n-     * @throws IllegalArgumentException if the transformers collection or any of the transformers is null\n+     * @throws NullPointerException if the transformers collection or any of the transformers is null\n      * @see ChainedTransformer\n      */\n     public static <T> Transformer<T, T> chainedTransformer(\n      * @param predicate  the predicate to switch on\n      * @param trueTransformer  the transformer called if the predicate is true\n      * @return the transformer\n-     * @throws IllegalArgumentException if either the predicate or transformer is null\n+     * @throws NullPointerException if either the predicate or transformer is null\n      * @see IfTransformer\n      * @since 4.1\n      */\n      * @param trueTransformer  the transformer called if the predicate is true\n      * @param falseTransformer  the transformer called if the predicate is false\n      * @return the transformer\n-     * @throws IllegalArgumentException if either the predicate or transformer is null\n+     * @throws NullPointerException if either the predicate or transformer is null\n      * @see IfTransformer\n      * @since 4.1\n      */\n      * @param trueTransformer  the transformer called if the predicate is true\n      * @param falseTransformer  the transformer called if the predicate is false\n      * @return the transformer\n-     * @throws IllegalArgumentException if either the predicate or transformer is null\n+     * @throws NullPointerException if either the predicate or transformer is null\n      * @see SwitchTransformer\n      * @deprecated as of 4.1, use {@link #ifTransformer(Predicate, Transformer, Transformer))\n      */\n      * @param predicates  an array of predicates to check\n      * @param transformers  an array of transformers to call\n      * @return the transformer\n-     * @throws IllegalArgumentException if the either array is null or empty\n-     * @throws IllegalArgumentException if any element in the arrays is null\n-     * @throws IllegalArgumentException if the arrays are different sizes\n+     * @throws NullPointerException if the either array is null\n+     * @throws NullPointerException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays have different sizes\n      * @see SwitchTransformer\n      */\n     public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n      * @param transformers  an array of transformers to call\n      * @param defaultTransformer  the default to call if no predicate matches, null means return null\n      * @return the transformer\n-     * @throws IllegalArgumentException if the either array is null or empty\n-     * @throws IllegalArgumentException if any element in the arrays is null\n-     * @throws IllegalArgumentException if the arrays are different sizes\n+     * @throws NullPointerException if the either array is null\n+     * @throws NullPointerException if any element in the arrays is null\n+     * @throws IllegalArgumentException if the arrays have different sizes\n      * @see SwitchTransformer\n      */\n     public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n      * @param <O>  the output type\n      * @param predicatesAndTransformers  a map of predicates to transformers\n      * @return the transformer\n-     * @throws IllegalArgumentException if the map is null or empty\n-     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws NullPointerException if the map is null\n+     * @throws NullPointerException if any transformer in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      * @see SwitchTransformer\n      */\n      * @param <O>  the output type\n      * @param objectsAndTransformers  a map of objects to transformers\n      * @return the transformer\n-     * @throws IllegalArgumentException if the map is null or empty\n-     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws NullPointerException if the map is null\n+     * @throws NullPointerException if any transformer in the map is null\n      * @see SwitchTransformer\n      */\n     @SuppressWarnings(\"unchecked\")\n             final Map<I, Transformer<I, O>> objectsAndTransformers) {\n \n         if (objectsAndTransformers == null) {\n-            throw new IllegalArgumentException(\"The object and transformer map must not be null\");\n+            throw new NullPointerException(\"The object and transformer map must not be null\");\n         }\n         final Transformer<? super I, ? extends O> def = objectsAndTransformers.remove(null);\n         final int size = objectsAndTransformers.size();\n      * @param <O>  the output type\n      * @param methodName  the method name to call on the input object, may not be null\n      * @return the transformer\n-     * @throws IllegalArgumentException if the methodName is null.\n+     * @throws NullPointerException if the methodName is null.\n      * @see InvokerTransformer\n      */\n     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n      * @param paramTypes  the parameter types\n      * @param args  the arguments\n      * @return the transformer\n-     * @throws IllegalArgumentException if the method name is null or the paramTypes and args don't match\n+     * @throws NullPointerException if the method name is null\n+     * @throws IllegalArgumentException if the paramTypes and args don't match\n      * @see InvokerTransformer\n      */\n     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,\n--- a/src/main/java/org/apache/commons/collections4/TrieUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/TrieUtils.java\n      * @param <V>  the value type\n      * @param trie  the trie to make unmodifiable, must not be null\n      * @return an unmodifiable trie backed by the given trie\n+     * @throws NullPointerException if trie is null\n      *\n      * @see java.util.Collections#unmodifiableMap(java.util.Map)\n      */\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if bag is null\n      */\n     protected AbstractBagDecorator(final Bag<E> bag) {\n         super(bag);\n--- a/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if bag is null\n      */\n     protected AbstractSortedBagDecorator(final SortedBag<E> bag) {\n         super(bag);\n--- a/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/CollectionBag.java\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return a Bag that complies to the Collection contract\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     public static <E> Bag<E> collectionBag(final Bag<E> bag) {\n         return new CollectionBag<E>(bag);\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     public CollectionBag(final Bag<E> bag) {\n         super(bag);\n--- a/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/CollectionSortedBag.java\n      * @param <E> the type of the elements in the bag\n      * @param bag  the sorted bag to decorate, must not be null\n      * @return a SortedBag that complies to the Collection contract\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     public static <E> SortedBag<E> collectionSortedBag(final SortedBag<E> bag) {\n         return new CollectionSortedBag<E>(bag);\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the sorted bag to decorate, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     public CollectionSortedBag(final SortedBag<E> bag) {\n         super(bag);\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedBag.java\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated Bag\n-     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws NullPointerException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws NullPointerException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n     protected PredicatedBag(final Bag<E> bag, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/PredicatedSortedBag.java\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated SortedBag\n-     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws NullPointerException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param bag  the bag to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if bag or predicate is null\n+     * @throws NullPointerException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n     protected PredicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedBag.java\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return a new synchronized Bag\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      * @since 4.0\n      */\n     public static <E> SynchronizedBag<E> synchronizedBag(final Bag<E> bag) {\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     protected SynchronizedBag(final Bag<E> bag) {\n         super(bag);\n      *\n      * @param bag  the bag to decorate, must not be null\n      * @param lock  the lock to use, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag or lock is null\n      */\n     protected SynchronizedBag(final Bag<E> bag, final Object lock) {\n         super(bag, lock);\n--- a/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/SynchronizedSortedBag.java\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return a new synchronized SortedBag\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      * @since 4.0\n      */\n     public static <E> SynchronizedSortedBag<E> synchronizedSortedBag(final SortedBag<E> bag) {\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     protected SynchronizedSortedBag(final SortedBag<E> bag) {\n         super(bag);\n      *\n      * @param bag  the bag to decorate, must not be null\n      * @param lock  the lock to use, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag or lock is null\n      */\n     protected SynchronizedSortedBag(final Bag<E> bag, final Object lock) {\n         super(bag, lock);\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedBag.java\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Bag\n-     * @throws IllegalArgumentException if bag or transformer is null\n+     * @throws NullPointerException if bag or transformer is null\n      * @since 4.0\n      */\n     public static <E> Bag<E> transformingBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Bag\n-     * @throws IllegalArgumentException if bag or transformer is null\n+     * @throws NullPointerException if bag or transformer is null\n      * @since 4.0\n      */\n     public static <E> Bag<E> transformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         final TransformedBag<E> decorated = new TransformedBag<E>(bag, transformer);\n-        if (transformer != null && bag != null && bag.size() > 0) {\n+        if (bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // Bag is of type E\n             final E[] values = (E[]) bag.toArray(); // NOPMD - false positive for generics\n             bag.clear();\n      *\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if bag or transformer is null\n+     * @throws NullPointerException if bag or transformer is null\n      */\n     protected TransformedBag(final Bag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         super(bag, transformer);\n--- a/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/TransformedSortedBag.java\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed SortedBag\n-     * @throws IllegalArgumentException if bag or transformer is null\n+     * @throws NullPointerException if bag or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed SortedBag\n-     * @throws IllegalArgumentException if bag or transformer is null\n+     * @throws NullPointerException if bag or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag,\n             final Transformer<? super E, ? extends E> transformer) {\n \n         final TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n-        if (transformer != null && bag != null && bag.size() > 0) {\n+        if (bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // bag is type E\n             final E[] values = (E[]) bag.toArray(); // NOPMD - false positive for generics\n             bag.clear();\n      *\n      * @param bag  the bag to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if bag or transformer is null\n+     * @throws NullPointerException if bag or transformer is null\n      */\n     protected TransformedSortedBag(final SortedBag<E> bag, final Transformer<? super E, ? extends E> transformer) {\n         super(bag, transformer);\n--- a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableBag.java\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return an unmodifiable Bag\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      * @since 4.0\n      */\n     public static <E> Bag<E> unmodifiableBag(final Bag<? extends E> bag) {\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableBag(final Bag<? extends E> bag) {\n--- a/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections4/bag/UnmodifiableSortedBag.java\n      * @param <E> the type of the elements in the bag\n      * @param bag  the bag to decorate, must not be null\n      * @return an unmodifiable SortedBag\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      * @since 4.0\n      */\n     public static <E> SortedBag<E> unmodifiableSortedBag(final SortedBag<E> bag) {\n      * Constructor that wraps (not copies).\n      *\n      * @param bag  the bag to decorate, must not be null\n-     * @throws IllegalArgumentException if bag is null\n+     * @throws NullPointerException if bag is null\n      */\n     private UnmodifiableSortedBag(final SortedBag<E> bag) {\n         super(bag);\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection is null\n      */\n     protected AbstractBidiMapDecorator(final BidiMap<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection is null\n      */\n     protected AbstractOrderedBidiMapDecorator(final OrderedBidiMap<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection is null\n      */\n     public AbstractSortedBidiMapDecorator(final SortedBidiMap<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMap.java\n      * @param <V> the value type\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable BidiMap\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> BidiMap<K, V> unmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableBidiMap(final BidiMap<? extends K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMap.java\n      * @param <V> the value type\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable OrderedBidiMap\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> OrderedBidiMap<K, V> unmodifiableOrderedBidiMap(\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableOrderedBidiMap(final OrderedBidiMap<? extends K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMap.java\n      * @param <V> the value type\n      * @param map  the map to decorate, must not be null\n      * @return an unmodifiable SortedBidiMap\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> SortedBidiMap<K, V> unmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableSortedBidiMap(final SortedBidiMap<K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param coll  the collection to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection is null\n      */\n     protected AbstractCollectionDecorator(final Collection<E> coll) {\n         if (coll == null) {\n-            throw new IllegalArgumentException(\"Collection must not be null\");\n+            throw new NullPointerException(\"Collection must not be null.\");\n         }\n         this.collection = coll;\n     }\n--- a/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/PredicatedCollection.java\n      * @param coll  the collection to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated collection\n-     * @throws IllegalArgumentException if collection or predicate is null\n+     * @throws NullPointerException if collection or predicate is null\n      * @throws IllegalArgumentException if the collection contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param coll  the collection to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if collection or predicate is null\n+     * @throws NullPointerException if collection or predicate is null\n      * @throws IllegalArgumentException if the collection contains invalid elements\n      */\n     protected PredicatedCollection(final Collection<E> coll, final Predicate<? super E> predicate) {\n         super(coll);\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null.\");\n         }\n         this.predicate = predicate;\n         for (final E item : coll) {\n          * Constructs a PredicatedCollectionBuilder with the specified Predicate.\n          *\n          * @param predicate  the predicate to use\n-         * @throws IllegalArgumentException if predicate is null\n+         * @throws NullPointerException if predicate is null\n          */\n         public Builder(final Predicate<? super E> predicate) {\n             if (predicate == null) {\n-                throw new IllegalArgumentException(\"Predicate must not be null\");\n+                throw new NullPointerException(\"Predicate must not be null\");\n             }\n             this.predicate = predicate;\n         }\n          *\n          * @param list  the List to decorate, must not be null\n          * @return the decorated list.\n-         * @throws IllegalArgumentException if list is null or contains invalid elements\n+         * @throws NullPointerException if list is null\n+         * @throws IllegalArgumentException if list contains invalid elements\n          */\n         public List<E> createPredicatedList(final List<E> list) {\n             if (list == null) {\n-                throw new IllegalArgumentException(\"list must not be null\");\n+                throw new NullPointerException(\"List must not be null.\");\n             }\n             final List<E> predicatedList = PredicatedList.predicatedList(list, predicate);\n             predicatedList.addAll(accepted);\n          *\n          * @param set  the set to decorate, must not be null\n          * @return the decorated set.\n-         * @throws IllegalArgumentException if set is null or contains invalid elements\n+         * @throws NullPointerException if set is null\n+         * @throws IllegalArgumentException if set contains invalid elements\n          */\n         public Set<E> createPredicatedSet(final Set<E> set) {\n             if (set == null) {\n-                throw new IllegalArgumentException(\"set must not be null\");\n+                throw new NullPointerException(\"Set must not be null.\");\n             }\n             final PredicatedSet<E> predicatedSet = PredicatedSet.predicatedSet(set, predicate);\n             predicatedSet.addAll(accepted);\n          *\n          * @param bag  the bag to decorate, must not be null\n          * @return the decorated bag.\n-         * @throws IllegalArgumentException if bag is null or contains invalid elements\n+         * @throws NullPointerException if bag is null\n+         * @throws IllegalArgumentException if bag contains invalid elements\n          */\n         public Bag<E> createPredicatedBag(final Bag<E> bag) {\n             if (bag == null) {\n-                throw new IllegalArgumentException(\"bag must not be null\");\n+                throw new NullPointerException(\"Bag must not be null.\");\n             }\n             final PredicatedBag<E> predicatedBag = PredicatedBag.predicatedBag(bag, predicate);\n             predicatedBag.addAll(accepted);\n          *\n          * @param queue  the queue to decorate, must not be null\n          * @return the decorated queue.\n-         * @throws IllegalArgumentException if queue is null or contains invalid elements\n+         * @throws NullPointerException if queue is null\n+         * @throws IllegalArgumentException if queue contains invalid elements\n          */\n         public Queue<E> createPredicatedQueue(final Queue<E> queue) {\n             if (queue == null) {\n-                throw new IllegalArgumentException(\"queue must not be null\");\n+                throw new NullPointerException(\"queue must not be null\");\n             }\n             final PredicatedQueue<E> predicatedQueue = PredicatedQueue.predicatedQueue(queue, predicate);\n             predicatedQueue.addAll(accepted);\n--- a/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/SynchronizedCollection.java\n      * @param <T> the type of the elements in the collection\n      * @param coll  the collection to decorate, must not be null\n      * @return a new synchronized collection\n-     * @throws IllegalArgumentException if collection is null\n+     * @throws NullPointerException if collection is null\n      * @since 4.0\n      */\n     public static <T> SynchronizedCollection<T> synchronizedCollection(final Collection<T> coll) {\n      * Constructor that wraps (not copies).\n      *\n      * @param collection  the collection to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection is null\n      */\n     protected SynchronizedCollection(final Collection<E> collection) {\n         if (collection == null) {\n-            throw new IllegalArgumentException(\"Collection must not be null\");\n+            throw new NullPointerException(\"Collection must not be null.\");\n         }\n         this.collection = collection;\n         this.lock = this;\n      *\n      * @param collection  the collection to decorate, must not be null\n      * @param lock  the lock object to use, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection or lock is null\n      */\n     protected SynchronizedCollection(final Collection<E> collection, final Object lock) {\n         if (collection == null) {\n-            throw new IllegalArgumentException(\"Collection must not be null\");\n+            throw new NullPointerException(\"Collection must not be null.\");\n+        }\n+        if (lock == null) {\n+            throw new NullPointerException(\"Lock must not be null.\");\n         }\n         this.collection = collection;\n         this.lock = lock;\n--- a/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/TransformedCollection.java\n      * @param coll  the collection to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed collection\n-     * @throws IllegalArgumentException if collection or transformer is null\n+     * @throws NullPointerException if collection or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll,\n      * @param collection  the collection to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Collection\n-     * @throws IllegalArgumentException if collection or transformer is null\n+     * @throws NullPointerException if collection or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection,\n      *\n      * @param coll  the collection to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if collection or transformer is null\n+     * @throws NullPointerException if collection or transformer is null\n      */\n     protected TransformedCollection(final Collection<E> coll, final Transformer<? super E, ? extends E> transformer) {\n         super(coll);\n         if (transformer == null) {\n-            throw new IllegalArgumentException(\"Transformer must not be null\");\n+            throw new NullPointerException(\"Transformer must not be null\");\n         }\n         this.transformer = transformer;\n     }\n--- a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollection.java\n      * @param <E> the type of the elements in the collection\n      * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n      * @return a new unmodifiable bounded collection\n-     * @throws IllegalArgumentException if {@code coll} is {@code null}\n+     * @throws NullPointerException if {@code coll} is {@code null}\n      * @since 4.0\n      */\n     public static <E> BoundedCollection<E> unmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n      * @param <E> the type of the elements in the collection\n      * @param coll  the <code>BoundedCollection</code> to decorate, must not be null\n      * @return a new unmodifiable bounded collection\n-     * @throws IllegalArgumentException if {@code coll} is {@code null}\n+     * @throws NullPointerException if coll is null\n+     * @throws IllegalArgumentException if coll is not a {@code BoundedCollection}\n      * @since 4.0\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> BoundedCollection<E> unmodifiableBoundedCollection(Collection<? extends E> coll) {\n         if (coll == null) {\n-            throw new IllegalArgumentException(\"The collection must not be null\");\n+            throw new NullPointerException(\"Collection must not be null.\");\n         }\n \n         // handle decorators\n         }\n \n         if (coll instanceof BoundedCollection == false) {\n-            throw new IllegalArgumentException(\"The collection is not a bounded collection\");\n+            throw new IllegalArgumentException(\"Collection is not a bounded collection.\");\n         }\n         return new UnmodifiableBoundedCollection<E>((BoundedCollection<E>) coll);\n     }\n      * Constructor that wraps (not copies).\n      *\n      * @param coll  the collection to decorate, must not be null\n-     * @throws IllegalArgumentException if coll is null\n+     * @throws NullPointerException if coll is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableBoundedCollection(final BoundedCollection<? extends E> coll) {\n--- a/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java\n+++ b/src/main/java/org/apache/commons/collections4/collection/UnmodifiableCollection.java\n      * @param <T> the type of the elements in the collection\n      * @param coll  the collection to decorate, must not be null\n      * @return an unmodifiable collection\n-     * @throws IllegalArgumentException if collection is null\n+     * @throws NullPointerException if collection is null\n      * @since 4.0\n      */\n     public static <T> Collection<T> unmodifiableCollection(final Collection<? extends T> coll) {\n      * Constructor that wraps (not copies).\n      *\n      * @param coll  the collection to decorate, must not be null\n-     * @throws IllegalArgumentException if collection is null\n+     * @throws NullPointerException if collection is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableCollection(final Collection<? extends E> coll) {\n--- a/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n+++ b/src/main/java/org/apache/commons/collections4/comparators/FixedOrderComparator.java\n      * The array is copied, so later changes will not affect the comparator.\n      *\n      * @param items  the items that the comparator can compare in order\n-     * @throws IllegalArgumentException if the array is null\n+     * @throws NullPointerException if the array is null\n      */\n     public FixedOrderComparator(final T... items) {\n         super();\n         if (items == null) {\n-            throw new IllegalArgumentException(\"The list of items must not be null\");\n+            throw new NullPointerException(\"The list of items must not be null\");\n         }\n         for (final T item : items) {\n             add(item);\n      * The list is copied, so later changes will not affect the comparator.\n      *\n      * @param items  the items that the comparator can compare in order\n-     * @throws IllegalArgumentException if the list is null\n+     * @throws NullPointerException if the list is null\n      */\n     public FixedOrderComparator(final List<T> items) {\n         super();\n         if (items == null) {\n-            throw new IllegalArgumentException(\"The list of items must not be null\");\n+            throw new NullPointerException(\"The list of items must not be null\");\n         }\n         for (final T t : items) {\n             add(t);\n      * @param unknownObjectBehavior  the flag for unknown behaviour -\n      * UNKNOWN_AFTER, UNKNOWN_BEFORE or UNKNOWN_THROW_EXCEPTION\n      * @throws UnsupportedOperationException if a comparison has been performed\n-     * @throws IllegalArgumentException if the unknown flag is not valid\n+     * @throws NullPointerException if unknownObjectBehavior is null\n      */\n     public void setUnknownObjectBehavior(final UnknownObjectBehavior unknownObjectBehavior) {\n         checkLocked();\n         if (unknownObjectBehavior == null) {\n-            throw new IllegalArgumentException(\"Unknown object behavior must not be null\");\n+            throw new NullPointerException(\"Unknown object behavior must not be null\");\n         }\n         this.unknownObjectBehavior = unknownObjectBehavior;\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/AllPredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>all</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> allPredicate(final Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>all</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> allPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n         final Predicate<? super T>[] preds = validate(predicates);\n--- a/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/AndPredicate.java\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      * @return the <code>and</code> predicate\n-     * @throws IllegalArgumentException if either predicate is null\n+     * @throws NullPointerException if either predicate is null\n      */\n     public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n                                                 final Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         return new AndPredicate<T>(predicate1, predicate2);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/AnyPredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>any</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> Predicate<T> anyPredicate(final Predicate<? super T>... predicates) {\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>all</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> Predicate<T> anyPredicate(final Collection<? extends Predicate<? super T>> predicates) {\n--- a/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/ChainedClosure.java\n      * @param <E> the type that the closure acts on\n      * @param closures  the closures to chain, copied, no nulls\n      * @return the <code>chained</code> closure\n-     * @throws IllegalArgumentException if the closures array is null\n-     * @throws IllegalArgumentException if any closure in the array is null\n+     * @throws NullPointerException if the closures array is null\n+     * @throws NullPointerException if any closure in the array is null\n      */\n     public static <E> Closure<E> chainedClosure(final Closure<? super E>... closures) {\n         FunctorUtils.validate(closures);\n      * @param <E> the type that the closure acts on\n      * @param closures  a collection of closures to chain\n      * @return the <code>chained</code> closure\n-     * @throws IllegalArgumentException if the closures collection is null\n-     * @throws IllegalArgumentException if any closure in the collection is null\n+     * @throws NullPointerException if the closures collection is null\n+     * @throws NullPointerException if any closure in the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Closure<E> chainedClosure(final Collection<? extends Closure<? super E>> closures) {\n         if (closures == null) {\n-            throw new IllegalArgumentException(\"Closure collection must not be null\");\n+            throw new NullPointerException(\"Closure collection must not be null\");\n         }\n         if (closures.size() == 0) {\n             return NOPClosure.<E>nopClosure();\n--- a/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/ChainedTransformer.java\n      * @param <T>  the object type\n      * @param transformers  the transformers to chain, copied, no nulls\n      * @return the <code>chained</code> transformer\n-     * @throws IllegalArgumentException if the transformers array is null\n-     * @throws IllegalArgumentException if any transformer in the array is null\n+     * @throws NullPointerException if the transformers array is null\n+     * @throws NullPointerException if any transformer in the array is null\n      */\n     public static <T> Transformer<T, T> chainedTransformer(final Transformer<? super T, ? extends T>... transformers) {\n         FunctorUtils.validate(transformers);\n      * @param <T>  the object type\n      * @param transformers  a collection of transformers to chain\n      * @return the <code>chained</code> transformer\n-     * @throws IllegalArgumentException if the transformers collection is null\n-     * @throws IllegalArgumentException if any transformer in the collection is null\n+     * @throws NullPointerException if the transformers collection is null\n+     * @throws NullPointerException if any transformer in the collection is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> Transformer<T, T> chainedTransformer(\n             final Collection<? extends Transformer<? super T, ? extends T>> transformers) {\n         if (transformers == null) {\n-            throw new IllegalArgumentException(\"Transformer collection must not be null\");\n+            throw new NullPointerException(\"Transformer collection must not be null\");\n         }\n         if (transformers.size() == 0) {\n             return NOPTransformer.<T>nopTransformer();\n--- a/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/ClosureTransformer.java\n      * @param <T>  the type of the object to transform\n      * @param closure  the closure to call, not null\n      * @return the <code>closure</code> transformer\n-     * @throws IllegalArgumentException if the closure is null\n+     * @throws NullPointerException if the closure is null\n      */\n     public static <T> Transformer<T, T> closureTransformer(final Closure<? super T> closure) {\n         if (closure == null) {\n-            throw new IllegalArgumentException(\"Closure must not be null\");\n+            throw new NullPointerException(\"Closure must not be null\");\n         }\n         return new ClosureTransformer<T>(closure);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/ComparatorPredicate.java\n      * @param object  the object to compare to\n      * @param comparator  the comparator to use for comparison\n      * @return the predicate\n-     * @throws IllegalArgumentException if comparator is null\n+     * @throws NullPointerException if comparator is null\n      */\n     public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator) {\n         return comparatorPredicate(object, comparator, Criterion.EQUAL);\n      * @param comparator  the comparator to use for comparison\n      * @param criterion  the criterion to use to evaluate comparison\n      * @return the predicate\n-     * @throws IllegalArgumentException if comparator is null of criterion is invalid\n+     * @throws NullPointerException if comparator or criterion is null\n      */\n     public static <T> Predicate<T> comparatorPredicate(final T object, final Comparator<T> comparator,\n                                                        final Criterion criterion) {\n         if (comparator == null) {\n-            throw new IllegalArgumentException(\"Comparator must not be null.\");\n+            throw new NullPointerException(\"Comparator must not be null.\");\n         }\n         if (criterion == null) {\n-            throw new IllegalArgumentException(\"Criterion must not be null.\");\n+            throw new NullPointerException(\"Criterion must not be null.\");\n         }\n         return new ComparatorPredicate<T>(object, comparator, criterion);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/FactoryTransformer.java\n      * @param <O>  the output type\n      * @param factory  the factory to call, not null\n      * @return the <code>factory</code> transformer\n-     * @throws IllegalArgumentException if the factory is null\n+     * @throws NullPointerException if the factory is null\n      */\n     public static <I, O> Transformer<I, O> factoryTransformer(final Factory<? extends O> factory) {\n         if (factory == null) {\n-            throw new IllegalArgumentException(\"Factory must not be null\");\n+            throw new NullPointerException(\"Factory must not be null\");\n         }\n         return new FactoryTransformer<I, O>(factory);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/FunctorUtils.java\n      */\n     static void validate(final Predicate<?>... predicates) {\n         if (predicates == null) {\n-            throw new IllegalArgumentException(\"The predicate array must not be null\");\n+            throw new NullPointerException(\"The predicate array must not be null\");\n         }\n         for (int i = 0; i < predicates.length; i++) {\n             if (predicates[i] == null) {\n-                throw new IllegalArgumentException(\n+                throw new NullPointerException(\n                         \"The predicate array must not contain a null predicate, index \" + i + \" was null\");\n             }\n         }\n      */\n     static <T> Predicate<? super T>[] validate(final Collection<? extends Predicate<? super T>> predicates) {\n         if (predicates == null) {\n-            throw new IllegalArgumentException(\"The predicate collection must not be null\");\n+            throw new NullPointerException(\"The predicate collection must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n         @SuppressWarnings(\"unchecked\") // OK\n         for (final Predicate<? super T> predicate : predicates) {\n             preds[i] = predicate;\n             if (preds[i] == null) {\n-                throw new IllegalArgumentException(\n+                throw new NullPointerException(\n                         \"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n             }\n             i++;\n      */\n     static void validate(final Closure<?>... closures) {\n         if (closures == null) {\n-            throw new IllegalArgumentException(\"The closure array must not be null\");\n+            throw new NullPointerException(\"The closure array must not be null\");\n         }\n         for (int i = 0; i < closures.length; i++) {\n             if (closures[i] == null) {\n-                throw new IllegalArgumentException(\n+                throw new NullPointerException(\n                         \"The closure array must not contain a null closure, index \" + i + \" was null\");\n             }\n         }\n      */\n     static void validate(final Transformer<?, ?>... transformers) {\n         if (transformers == null) {\n-            throw new IllegalArgumentException(\"The transformer array must not be null\");\n+            throw new NullPointerException(\"The transformer array must not be null\");\n         }\n         for (int i = 0; i < transformers.length; i++) {\n             if (transformers[i] == null) {\n-                throw new IllegalArgumentException(\n+                throw new NullPointerException(\n                     \"The transformer array must not contain a null transformer, index \" + i + \" was null\");\n             }\n         }\n--- a/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/IdentityPredicate.java\n      * @param <T> the type that the predicate queries\n      * @param object  the object to compare to\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null\n      */\n     public static <T> Predicate<T> identityPredicate(final T object) {\n         if (object == null) {\n--- a/src/main/java/org/apache/commons/collections4/functors/IfClosure.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/IfClosure.java\n      * @param predicate  predicate to switch on\n      * @param trueClosure  closure used if true\n      * @return the <code>if</code> closure\n-     * @throws IllegalArgumentException if either argument is null\n+     * @throws NullPointerException if either argument is null\n      * @since 3.2\n      */\n     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n      * @param trueClosure  closure used if true\n      * @param falseClosure  closure used if false\n      * @return the <code>if</code> closure\n-     * @throws IllegalArgumentException if any argument is null\n+     * @throws NullPointerException if any argument is null\n      */\n     public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n                                            final Closure<? super E> trueClosure,\n                                            final Closure<? super E> falseClosure) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         if (trueClosure == null || falseClosure == null) {\n-            throw new IllegalArgumentException(\"Closures must not be null\");\n+            throw new NullPointerException(\"Closures must not be null\");\n         }\n         return new IfClosure<E>(predicate, trueClosure, falseClosure);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/IfTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/IfTransformer.java\n  */\n package org.apache.commons.collections4.functors;\n \n+import java.io.Serializable;\n+\n import org.apache.commons.collections4.Predicate;\n import org.apache.commons.collections4.Transformer;\n-\n-import java.io.Serializable;\n \n /**\n  * Transformer implementation that will call one of two closures based on whether a predicate evaluates\n      * @param trueTransformer  transformer used if true\n      * @param falseTransformer  transformer used if false\n      * @return the <code>if</code> transformer\n+     * @throws NullPointerException if either argument is null\n      */\n     public static <I, O> Transformer<I, O> ifTransformer(final Predicate<? super I> predicate,\n                                                          final Transformer<? super I, ? extends O> trueTransformer,\n                                                          final Transformer<? super I, ? extends O> falseTransformer) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         if (trueTransformer == null || falseTransformer == null) {\n-            throw new IllegalArgumentException(\"Transformers must not be null\");\n+            throw new NullPointerException(\"Transformers must not be null\");\n         }\n \n         return new IfTransformer<I, O>(predicate, trueTransformer, falseTransformer);\n      * @param predicate  predicate to switch on\n      * @param trueTransformer  transformer used if true\n      * @return the <code>if</code> transformer\n+     * @throws NullPointerException if either argument is null\n      */\n     public static <T> Transformer<T, T> ifTransformer(\n             final Predicate<? super T> predicate,\n             final Transformer<? super T, ? extends T> trueTransformer) {\n \n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         if (trueTransformer == null) {\n-            throw new IllegalArgumentException(\"Transformer must not be null\");\n+            throw new NullPointerException(\"Transformer must not be null\");\n         }\n \n         return new IfTransformer<T, T>(predicate, trueTransformer, NOPTransformer.<T>nopTransformer());\n--- a/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/InstanceofPredicate.java\n      *\n      * @param type  the type to check for, may not be null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the class is null\n+     * @throws NullPointerException if the class is null\n      */\n     public static Predicate<Object> instanceOfPredicate(final Class<?> type) {\n         if (type == null) {\n-            throw new IllegalArgumentException(\"The type to check instanceof must not be null\");\n+            throw new NullPointerException(\"The type to check instanceof must not be null\");\n         }\n         return new InstanceofPredicate(type);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/InstantiateFactory.java\n      * @param paramTypes  the constructor parameter types, cloned\n      * @param args  the constructor arguments, cloned\n      * @return a new instantiate factory\n+     * @throws NullPointerException if classToInstantiate is null\n+     * @throws IllegalArgumentException if paramTypes does not match args\n      */\n     public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate,\n                                                     final Class<?>[] paramTypes,\n                                                     final Object[] args) {\n         if (classToInstantiate == null) {\n-            throw new IllegalArgumentException(\"Class to instantiate must not be null\");\n+            throw new NullPointerException(\"Class to instantiate must not be null\");\n         }\n         if (paramTypes == null && args != null\n             || paramTypes != null && args == null\n--- a/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/InstantiateTransformer.java\n      * @param paramTypes  the constructor parameter types\n      * @param args  the constructor arguments\n      * @return an instantiate transformer\n+     * @throws IllegalArgumentException if paramTypes does not match args\n      */\n     public static <T> Transformer<Class<? extends T>, T> instantiateTransformer(final Class<?>[] paramTypes,\n                                                                                 final Object[] args) {\n--- a/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/InvokerTransformer.java\n      * @param <O>  the output type\n      * @param methodName  the method name to call\n      * @return an invoker transformer\n+     * @throws NullPointerException if methodName is null\n      * @since 3.1\n      */\n     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n         if (methodName == null) {\n-            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+            throw new NullPointerException(\"The method to invoke must not be null\");\n         }\n         return new InvokerTransformer<I, O>(methodName);\n     }\n      * @param paramTypes  the parameter types of the method\n      * @param args  the arguments to pass to the method\n      * @return an invoker transformer\n+     * @throws NullPointerException if methodName is null\n+     * @throws IllegalArgumentException if paramTypes does not match args\n      */\n     public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,\n                                                               final Object[] args) {\n         if (methodName == null) {\n-            throw new IllegalArgumentException(\"The method to invoke must not be null\");\n+            throw new NullPointerException(\"The method to invoke must not be null\");\n         }\n         if (((paramTypes == null) && (args != null))\n             || ((paramTypes != null) && (args == null))\n--- a/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/NonePredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>any</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> nonePredicate(final Predicate<? super T>... predicates) {\n         FunctorUtils.validate(predicates);\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>one</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> nonePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n         final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n--- a/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/NotPredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicate  the predicate to decorate, not null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null\n+     * @throws NullPointerException if the predicate is null\n      */\n     public static <T> Predicate<T> notPredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         return new NotPredicate<T>(predicate);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsExceptionPredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicate  the predicate to decorate, not null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null\n+     * @throws NullPointerException if the predicate is null\n      */\n     public static <T> Predicate<T> nullIsExceptionPredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         return new NullIsExceptionPredicate<T>(predicate);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsFalsePredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicate  the predicate to decorate, not null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null\n+     * @throws NullPointerException if the predicate is null\n      */\n     public static <T> Predicate<T> nullIsFalsePredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         return new NullIsFalsePredicate<T>(predicate);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/NullIsTruePredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicate  the predicate to decorate, not null\n      * @return the predicate\n-     * @throws IllegalArgumentException if the predicate is null\n+     * @throws NullPointerException if the predicate is null\n      */\n     public static <T> Predicate<T> nullIsTruePredicate(final Predicate<? super T> predicate) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         return new NullIsTruePredicate<T>(predicate);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/OnePredicate.java\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>any</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <T> Predicate<T> onePredicate(final Predicate<? super T>... predicates) {\n      * @param <T> the type that the predicate queries\n      * @param predicates  the predicates to check, cloned, not null\n      * @return the <code>one</code> predicate\n-     * @throws IllegalArgumentException if the predicates array is null\n-     * @throws IllegalArgumentException if any predicate in the array is null\n+     * @throws NullPointerException if the predicates array is null\n+     * @throws NullPointerException if any predicate in the array is null\n      */\n     public static <T> Predicate<T> onePredicate(final Collection<? extends Predicate<? super T>> predicates) {\n         final Predicate<? super T>[] preds = FunctorUtils.validate(predicates);\n--- a/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/OrPredicate.java\n      * @param predicate1  the first predicate to check, not null\n      * @param predicate2  the second predicate to check, not null\n      * @return the <code>and</code> predicate\n-     * @throws IllegalArgumentException if either predicate is null\n+     * @throws NullPointerException if either predicate is null\n      */\n     public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n                                                final Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         return new OrPredicate<T>(predicate1, predicate2);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/SwitchClosure.java\n      * @param closures  matching array of closures, cloned, no nulls\n      * @param defaultClosure  the closure to use if no match, null means nop\n      * @return the <code>chained</code> closure\n-     * @throws IllegalArgumentException if array is null\n-     * @throws IllegalArgumentException if any element in the array is null\n+     * @throws NullPointerException if array is null\n+     * @throws NullPointerException if any element in the array is null\n+     * @throws IllegalArgumentException if the array lengths of predicates and closures do not match\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n      * @param <E> the type that the closure acts on\n      * @param predicatesAndClosures  a map of predicates to closures\n      * @return the <code>switch</code> closure\n-     * @throws IllegalArgumentException if the map is null\n-     * @throws IllegalArgumentException if any closure in the map is null\n+     * @throws NullPointerException if the map is null\n+     * @throws NullPointerException if any closure in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Closure<E> switchClosure(final Map<Predicate<E>, Closure<E>> predicatesAndClosures) {\n         if (predicatesAndClosures == null) {\n-            throw new IllegalArgumentException(\"The predicate and closure map must not be null\");\n+            throw new NullPointerException(\"The predicate and closure map must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n         final Closure<? super E> defaultClosure = predicatesAndClosures.remove(null);\n--- a/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/SwitchTransformer.java\n      * @param transformers  matching array of transformers, cloned, no nulls\n      * @param defaultTransformer  the transformer to use if no match, null means return null\n      * @return the <code>chained</code> transformer\n-     * @throws IllegalArgumentException if array is null\n-     * @throws IllegalArgumentException if any element in the array is null\n+     * @throws NullPointerException if array is null\n+     * @throws NullPointerException if any element in the array is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <I, O> Transformer<I, O> switchTransformer(final Predicate<? super I>[] predicates,\n      * @param <O>  the output type\n      * @param map  a map of predicates to transformers\n      * @return the <code>switch</code> transformer\n-     * @throws IllegalArgumentException if the map is null\n-     * @throws IllegalArgumentException if any transformer in the map is null\n+     * @throws NullPointerException if the map is null\n+     * @throws NullPointerException if any transformer in the map is null\n      * @throws ClassCastException  if the map elements are of the wrong type\n      */\n     @SuppressWarnings(\"unchecked\")\n             final Map<? extends Predicate<? super I>, ? extends Transformer<? super I, ? extends O>> map) {\n \n         if (map == null) {\n-            throw new IllegalArgumentException(\"The predicate and transformer map must not be null\");\n+            throw new NullPointerException(\"The predicate and transformer map must not be null\");\n         }\n         if (map.size() == 0) {\n             return ConstantTransformer.<I, O>nullTransformer();\n--- a/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/TransformedPredicate.java\n      * @param transformer  the transformer to call\n      * @param predicate  the predicate to call with the result of the transform\n      * @return the predicate\n-     * @throws IllegalArgumentException if the transformer or the predicate is null\n+     * @throws NullPointerException if the transformer or the predicate is null\n      */\n     public static <T> Predicate<T> transformedPredicate(final Transformer<? super T, ? extends T> transformer,\n                                                         final Predicate<? super T> predicate) {\n         if (transformer == null) {\n-            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+            throw new NullPointerException(\"The transformer to call must not be null\");\n         }\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"The predicate to call must not be null\");\n+            throw new NullPointerException(\"The predicate to call must not be null\");\n         }\n         return new TransformedPredicate<T>(transformer, predicate);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/TransformerPredicate.java\n      * @param <T> the type that the predicate queries\n      * @param transformer  the transformer to decorate\n      * @return the predicate\n-     * @throws IllegalArgumentException if the transformer is null\n+     * @throws NullPointerException if the transformer is null\n      */\n     public static <T> Predicate<T> transformerPredicate(final Transformer<? super T, Boolean> transformer) {\n         if (transformer == null) {\n-            throw new IllegalArgumentException(\"The transformer to call must not be null\");\n+            throw new NullPointerException(\"The transformer to call must not be null\");\n         }\n         return new TransformerPredicate<T>(transformer);\n     }\n--- a/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java\n+++ b/src/main/java/org/apache/commons/collections4/functors/WhileClosure.java\n      * @param closure  the closure the execute, not null\n      * @param doLoop  true to act as a do-while loop, always executing the closure once\n      * @return the <code>while</code> closure\n-     * @throws IllegalArgumentException if the predicate or closure is null\n+     * @throws NullPointerException if the predicate or closure is null\n      */\n     public static <E> Closure<E> whileClosure(final Predicate<? super E> predicate,\n                                               final Closure<? super E> closure, final boolean doLoop) {\n         if (predicate == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null\");\n+            throw new NullPointerException(\"Predicate must not be null\");\n         }\n         if (closure == null) {\n-            throw new IllegalArgumentException(\"Closure must not be null\");\n+            throw new NullPointerException(\"Closure must not be null\");\n         }\n         return new WhileClosure<E>(predicate, closure, doLoop);\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java\n      * Constructor that decorates the specified iterator.\n      *\n      * @param iterator  the iterator to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     protected AbstractIteratorDecorator(final Iterator<E> iterator) {\n         super(iterator);\n--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractListIteratorDecorator.java\n      * Constructor that decorates the specified iterator.\n      *\n      * @param iterator  the iterator to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public AbstractListIteratorDecorator(final ListIterator<E> iterator) {\n         super();\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"ListIterator must not be null\");\n+            throw new NullPointerException(\"ListIterator must not be null\");\n         }\n         this.iterator = iterator;\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractMapIteratorDecorator.java\n      * Constructor that decorates the specified iterator.\n      *\n      * @param iterator  the iterator to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public AbstractMapIteratorDecorator(final MapIterator<K, V> iterator) {\n         super();\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+            throw new NullPointerException(\"MapIterator must not be null\");\n         }\n         this.iterator = iterator;\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorDecorator.java\n      * Constructor that decorates the specified iterator.\n      *\n      * @param iterator  the iterator to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public AbstractOrderedMapIteratorDecorator(final OrderedMapIterator<K, V> iterator) {\n         super();\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n+            throw new NullPointerException(\"OrderedMapIterator must not be null\");\n         }\n         this.iterator = iterator;\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java\n      * Create a new AbstractUntypedIteratorDecorator.\n      *\n      * @param iterator  the iterator to decorate\n+     * @throws NullPointerException if the iterator is null\n      */\n     protected AbstractUntypedIteratorDecorator(final Iterator<I> iterator) {\n         super();\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"Iterator must not be null\");\n+            throw new NullPointerException(\"Iterator must not be null\");\n         }\n         this.iterator = iterator;\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java\n      * @param iterator  the iterator to be decorated\n      * @param offset  the index of the first element of the decorated iterator to return\n      * @param max  the maximum number of elements of the decorated iterator to return\n-     * @throws IllegalArgumentException if iterator is null, or either offset or max is negative\n+     * @throws NullPointerException if iterator is null\n+     * @throws IllegalArgumentException if either offset or max is negative\n      */\n     public BoundedIterator(final Iterator<? extends E> iterator, final long offset, final long max) {\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"Iterator must not be null\");\n+            throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (offset < 0) {\n             throw new IllegalArgumentException(\"Offset parameter must not be negative.\");\n--- a/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/NodeListIterator.java\n \n import java.util.Iterator;\n import java.util.NoSuchElementException;\n+\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n \n      * the specified node's childNodes.\n      *\n      * @param node Node, who's child nodes are wrapped by this class. Must not be null\n-     * @throws IllegalArgumentException if node is null\n+     * @throws NullPointerException if node is null\n      */\n     public NodeListIterator(final Node node) {\n         if (node == null) {\n-            throw new IllegalArgumentException(\"node must not be null!\");\n+            throw new NullPointerException(\"Node must not be null.\");\n         }\n         this.nodeList = node.getChildNodes();\n     }\n      * <code>org.w3c.NodeList</code>\n      *\n      * @param nodeList node list, which is wrapped by this class. Must not be null\n-     * @throws IllegalArgumentException if nodeList is null\n+     * @throws NullPointerException if nodeList is null\n      */\n     public NodeListIterator(final NodeList nodeList) {\n         if (nodeList == null) {\n-            throw new IllegalArgumentException(\"nodeList must not be null!\");\n+            throw new NullPointerException(\"NodeList must not be null.\");\n         }\n         this.nodeList = nodeList;\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/PeekingIterator.java\n      * @param <E>  the element type\n      * @param iterator  the iterator to decorate\n      * @return a new peeking iterator\n-     * @throws IllegalArgumentException if the iterator is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public static <E> PeekingIterator<E> peekingIterator(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"Iterator must not be null\");\n+            throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (iterator instanceof PeekingIterator<?>) {\n             @SuppressWarnings(\"unchecked\") // safe cast\n--- a/src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/PushbackIterator.java\n      * @param <E>  the element type\n      * @param iterator  the iterator to decorate\n      * @return a new peeking iterator\n-     * @throws IllegalArgumentException if the iterator is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public static <E> PushbackIterator<E> pushbackIterator(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"Iterator must not be null\");\n+            throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (iterator instanceof PushbackIterator<?>) {\n             @SuppressWarnings(\"unchecked\") // safe cast\n--- a/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/ReverseListIterator.java\n      */\n     public ReverseListIterator(final List<E> list) {\n         super();\n+        if (list == null) {\n+            throw new NullPointerException(\"List must not be null.\");\n+        }\n         this.list = list;\n         iterator = list.listIterator(list.size());\n     }\n--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableIterator.java\n      * @param <E>  the element type\n      * @param iterator  the iterator to decorate\n      * @return a new unmodifiable iterator\n-     * @throws IllegalArgumentException if the iterator is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public static <E> Iterator<E> unmodifiableIterator(final Iterator<? extends E> iterator) {\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"Iterator must not be null\");\n+            throw new NullPointerException(\"Iterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             @SuppressWarnings(\"unchecked\") // safe to upcast\n--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableListIterator.java\n      * @param <E>  the element type\n      * @param iterator  the iterator to decorate\n      * @return a new unmodifiable list iterator\n-     * @throws IllegalArgumentException if the iterator is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public static <E> ListIterator<E> umodifiableListIterator(final ListIterator<? extends E> iterator) {\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"ListIterator must not be null\");\n+            throw new NullPointerException(\"ListIterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             @SuppressWarnings(\"unchecked\") // safe to upcast\n--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableMapIterator.java\n      * @param <V>  the value type\n      * @param iterator  the iterator to decorate\n      * @return a new unmodifiable map iterator\n-     * @throws IllegalArgumentException if the iterator is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public static <K, V> MapIterator<K, V> unmodifiableMapIterator(\n             final MapIterator<? extends K, ? extends V> iterator) {\n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"MapIterator must not be null\");\n+            throw new NullPointerException(\"MapIterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             @SuppressWarnings(\"unchecked\") // safe to upcast\n--- a/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java\n+++ b/src/main/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIterator.java\n      * @param <V>  the value type\n      * @param iterator  the iterator to decorate\n      * @return a new unmodifiable ordered map iterator\n-     * @throws IllegalArgumentException if the iterator is null\n+     * @throws NullPointerException if the iterator is null\n      */\n     public static <K, V> OrderedMapIterator<K, V> unmodifiableOrderedMapIterator(\n             final OrderedMapIterator<K, ? extends V> iterator) {\n \n         if (iterator == null) {\n-            throw new IllegalArgumentException(\"OrderedMapIterator must not be null\");\n+            throw new NullPointerException(\"OrderedMapIterator must not be null\");\n         }\n         if (iterator instanceof Unmodifiable) {\n             @SuppressWarnings(\"unchecked\") // safe to upcast\n--- a/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param entry  the <code>Map.Entry</code> to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the collection is null\n      */\n     public AbstractMapEntryDecorator(final Map.Entry<K, V> entry) {\n         if (entry == null) {\n-            throw new IllegalArgumentException(\"Map Entry must not be null\");\n+            throw new NullPointerException(\"Map Entry must not be null.\");\n         }\n         this.entry = entry;\n     }\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      */\n     protected AbstractListDecorator(final List<E> list) {\n         super(list);\n--- a/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      */\n     protected AbstractSerializableListDecorator(final List<E> list) {\n         super(list);\n--- a/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/FixedSizeList.java\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @return a new fixed size list\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      * @since 4.0\n      */\n     public static <E> FixedSizeList<E> fixedSizeList(final List<E> list) {\n      * Constructor that wraps (not copies).\n      *\n      * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      */\n     protected FixedSizeList(final List<E> list) {\n         super(list);\n--- a/src/main/java/org/apache/commons/collections4/list/GrowthList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/GrowthList.java\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @return a new growth list\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      * @since 4.0\n      */\n     public static <E> GrowthList<E> growthList(final List<E> list) {\n      * Constructor that wraps (not copies).\n      *\n      * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      */\n     protected GrowthList(final List<E> list) {\n         super(list);\n--- a/src/main/java/org/apache/commons/collections4/list/LazyList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/LazyList.java\n      * @param list  the list to decorate, must not be null\n      * @param factory  the factory to use for creation, must not be null\n      * @return a new lazy list\n-     * @throws IllegalArgumentException if list or factory is null\n+     * @throws NullPointerException if list or factory is null\n      * @since 4.0\n      */\n     public static <E> LazyList<E> lazyList(final List<E> list, final Factory<? extends E> factory) {\n      *\n      * @param list  the list to decorate, must not be null\n      * @param factory  the factory to use for creation, must not be null\n-     * @throws IllegalArgumentException if list or factory is null\n+     * @throws NullPointerException if list or factory is null\n      */\n     protected LazyList(final List<E> list, final Factory<? extends E> factory) {\n         super(list);\n--- a/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/PredicatedList.java\n      * @param list  the list to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated list\n-     * @throws IllegalArgumentException if list or predicate is null\n+     * @throws NullPointerException if list or predicate is null\n      * @throws IllegalArgumentException if the list contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param list  the list to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if list or predicate is null\n+     * @throws NullPointerException if list or predicate is null\n      * @throws IllegalArgumentException if the list contains invalid elements\n      */\n     protected PredicatedList(final List<E> list, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/SetUniqueList.java\n      * @param <E>  the element type\n      * @param list  the list to decorate, must not be null\n      * @return a new {@link SetUniqueList}\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      * @since 4.0\n      */\n     public static <E> SetUniqueList<E> setUniqueList(final List<E> list) {\n         if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n+            throw new NullPointerException(\"List must not be null\");\n         }\n         if (list.isEmpty()) {\n             return new SetUniqueList<E>(list, new HashSet<E>());\n      *\n      * @param set  the set to decorate, must not be null\n      * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if set or list is null\n+     * @throws NullPointerException if set or list is null\n      */\n     protected SetUniqueList(final List<E> list, final Set<E> set) {\n         super(list);\n         if (set == null) {\n-            throw new IllegalArgumentException(\"Set must not be null\");\n+            throw new NullPointerException(\"Set must not be null\");\n         }\n         this.set = set;\n     }\n--- a/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TransformedList.java\n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed list\n-     * @throws IllegalArgumentException if list or transformer is null\n+     * @throws NullPointerException if list or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedList<E> transformingList(final List<E> list,\n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed List\n-     * @throws IllegalArgumentException if list or transformer is null\n+     * @throws NullPointerException if list or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedList<E> transformedList(final List<E> list,\n                                                          final Transformer<? super E, ? extends E> transformer) {\n         final TransformedList<E> decorated = new TransformedList<E>(list, transformer);\n-        if (transformer != null && list != null && list.size() > 0) {\n+        if (list.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // list is of type E\n             final E[] values = (E[]) list.toArray(); // NOPMD - false positive for generics\n             list.clear();\n      *\n      * @param list  the list to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if list or transformer is null\n+     * @throws NullPointerException if list or transformer is null\n      */\n     protected TransformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n         super(list, transformer);\n--- a/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/UnmodifiableList.java\n      * @param <E> the type of the elements in the list\n      * @param list  the list to decorate, must not be null\n      * @return a new unmodifiable list\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      * @since 4.0\n      */\n     public static <E> List<E> unmodifiableList(final List<? extends E> list) {\n      * Constructor that wraps (not copies).\n      *\n      * @param list  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     public UnmodifiableList(final List<? extends E> list) {\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.AbstractSetDecorator;\n import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;\n+import org.apache.commons.collections4.set.AbstractSetDecorator;\n \n /**\n  * An abstract base class that simplifies the task of creating map decorators.\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     protected AbstractInputCheckedMapDecorator(final Map<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the map is null\n      */\n     protected AbstractMapDecorator(final Map<K, V> map) {\n         if (map == null) {\n-            throw new IllegalArgumentException(\"Map must not be null\");\n+            throw new NullPointerException(\"Map must not be null.\");\n         }\n         this.map = map;\n     }\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the map is null\n      */\n     public AbstractOrderedMapDecorator(final OrderedMap<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws NullPointerException if the map is null\n      */\n     public AbstractSortedMapDecorator(final SortedMap<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/DefaultedMap.java\n      * @param map  the map to decorate, must not be null\n      * @param defaultValue  the default value to return when the key is not found\n      * @return a new defaulting map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final V defaultValue) {\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use to create entries, must not be null\n      * @return a new defaulting map\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      * @since 4.0\n      */\n     public static <K, V> DefaultedMap<K, V> defaultedMap(final Map<K, V> map, final Factory<? extends V> factory) {\n      * @param map  the map to decorate, must not be null\n      * @param transformer  the transformer to use as a factory to create entries, must not be null\n      * @return a new defaulting map\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      * @since 4.0\n      */\n     public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map,\n      *\n      * @param map  the map to decorate, must not be null\n      * @param defaultValueTransformer  the value transformer to use\n-     * @throws IllegalArgumentException if map or transformer is null\n+     * @throws NullPointerException if map or transformer is null\n      */\n     protected DefaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> defaultValueTransformer) {\n         super(map);\n         if (defaultValueTransformer == null) {\n-            throw new IllegalArgumentException(\"transformer must not be null\");\n+            throw new NullPointerException(\"Transformer must not be null.\");\n         }\n         this.value = defaultValueTransformer;\n     }\n--- a/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeMap.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.BoundedMap;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another <code>Map</code> to fix the size, preventing add/remove.\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new fixed size map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> FixedSizeMap<K, V> fixedSizeMap(final Map<K, V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     protected FixedSizeMap(final Map<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/FixedSizeSortedMap.java\n import java.util.Set;\n import java.util.SortedMap;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.BoundedMap;\n import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another <code>SortedMap</code> to fix the size blocking add/remove.\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new fixed size sorted map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> FixedSizeSortedMap<K, V> fixedSizeSortedMap(final SortedMap<K, V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     protected FixedSizeSortedMap(final SortedMap<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/map/LazyMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/LazyMap.java\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @return a new lazy map\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      * @since 4.0\n      */\n     public static <K, V> LazyMap<K, V> lazyMap(final Map<K, V> map, final Factory< ? extends V> factory) {\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @return a new lazy map\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      * @since 4.0\n      */\n     public static <V, K> LazyMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> factory) {\n      *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      */\n     protected LazyMap(final Map<K,V> map, final Factory<? extends V> factory) {\n         super(map);\n         if (factory == null) {\n-            throw new IllegalArgumentException(\"Factory must not be null\");\n+            throw new NullPointerException(\"Factory must not be null\");\n         }\n         this.factory = FactoryTransformer.factoryTransformer(factory);\n     }\n      *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      */\n     protected LazyMap(final Map<K,V> map, final Transformer<? super K, ? extends V> factory) {\n         super(map);\n         if (factory == null) {\n-            throw new IllegalArgumentException(\"Factory must not be null\");\n+            throw new NullPointerException(\"Factory must not be null\");\n         }\n         this.factory = factory;\n     }\n--- a/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/LazySortedMap.java\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @return a new lazy sorted map\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      * @since 4.0\n      */\n     public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n      * @return a new lazy sorted map\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      * @since 4.0\n      */\n     public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n      *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      */\n     protected LazySortedMap(final SortedMap<K,V> map, final Factory<? extends V> factory) {\n         super(map, factory);\n      *\n      * @param map  the map to decorate, must not be null\n      * @param factory  the factory to use, must not be null\n-     * @throws IllegalArgumentException if map or factory is null\n+     * @throws NullPointerException if map or factory is null\n      */\n     protected LazySortedMap(final SortedMap<K,V> map, final Transformer<? super K, ? extends V> factory) {\n         super(map, factory);\n--- a/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/ListOrderedMap.java\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new list ordered map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> ListOrderedMap<K, V> listOrderedMap(final Map<K, V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     protected ListOrderedMap(final Map<K, V> map) {\n         super(map);\n--- a/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/MultiKeyMap.java\n      * @param <V>  the value type\n      * @param map  the map to decorate, not null\n      * @return a new multi key map\n-     * @throws IllegalArgumentException if the map is null or not empty\n+     * @throws NullPointerException if map is null\n+     * @throws IllegalArgumentException if the map is not empty\n      * @since 4.0\n      */\n     public static <K, V> MultiKeyMap<K, V> multiKeyMap(final AbstractHashedMap<MultiKey<? extends K>, V> map) {\n         if (map == null) {\n-            throw new IllegalArgumentException(\"Map must not be null\");\n+            throw new NullPointerException(\"Map must not be null\");\n         }\n         if (map.size() > 0) {\n             throw new IllegalArgumentException(\"Map must be empty\");\n--- a/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PassiveExpiringMap.java\n          *        expire.\n          * @param timeUnit the unit of time for the <code>timeToLive</code>\n          *        parameter, must not be null.\n-         * @throws IllegalArgumentException if the time unit is null.\n+         * @throws NullPointerException if the time unit is null.\n          */\n         public ConstantTimeToLiveExpirationPolicy(final long timeToLive,\n                                                   final TimeUnit timeUnit) {\n     /**\n      * First validate the input parameters. If the parameters are valid, convert\n      * the given time measured in the given units to the same time measured in\n-     * milliseconds. If the parameters are invalid, an\n-     * {@link IllegalArgumentException} is thrown.\n+     * milliseconds.\n      *\n      * @param timeToLive the constant amount of time an entry is available\n      *        before it expires. A negative value results in entries that NEVER\n      *        expire. A zero value results in entries that ALWAYS expire.\n      * @param timeUnit the unit of time for the <code>timeToLive</code>\n      *        parameter, must not be null.\n-     * @throws IllegalArgumentException if the time unit is null.\n+     * @throws NullPointerException if the time unit is null.\n      */\n     private static long validateAndConvertToMillis(final long timeToLive,\n                                                    final TimeUnit timeUnit) {\n         if (timeUnit == null) {\n-            throw new IllegalArgumentException(\"Time unit must not be null\");\n+            throw new NullPointerException(\"Time unit must not be null\");\n         }\n         return TimeUnit.MILLISECONDS.convert(timeToLive, timeUnit);\n     }\n      *\n      * @param expiringPolicy the policy used to determine expiration times of\n      *        entries as they are added.\n+     * @throws NullPointerException if expiringPolicy is null\n      */\n     public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy) {\n         this(expiringPolicy, new HashMap<K, V>());\n      * @param expiringPolicy the policy used to determine expiration times of\n      *        entries as they are added.\n      * @param map the map to decorate, must not be null.\n-     * @throws IllegalArgumentException if the map is null.\n+     * @throws NullPointerException if the map or expiringPolicy is null.\n      */\n     public PassiveExpiringMap(final ExpirationPolicy<K, V> expiringPolicy,\n                               final Map<K, V> map) {\n         super(map);\n         if (expiringPolicy == null) {\n-            throw new IllegalArgumentException(\"Policy must not be null.\");\n+            throw new NullPointerException(\"Policy must not be null.\");\n         }\n         this.expiringPolicy = expiringPolicy;\n     }\n      *        entries that NEVER expire. A zero value results in entries that\n      *        ALWAYS expire.\n      * @param map the map to decorate, must not be null.\n-     * @throws IllegalArgumentException if the map is null.\n+     * @throws NullPointerException if the map is null.\n      */\n     public PassiveExpiringMap(final long timeToLiveMillis, final Map<K, V> map) {\n         this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n      *        expire. A zero value results in entries that ALWAYS expire.\n      * @param timeUnit the unit of time for the <code>timeToLive</code>\n      *        parameter, must not be null.\n-     * @throws IllegalArgumentException if the time unit is null.\n+     * @throws NullPointerException if the time unit is null.\n      */\n     public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit) {\n         this(validateAndConvertToMillis(timeToLive, timeUnit));\n      * @param timeUnit the unit of time for the <code>timeToLive</code>\n      *        parameter, must not be null.\n      * @param map the map to decorate, must not be null.\n-     * @throws IllegalArgumentException if the time unit is null.\n-     * @throws IllegalArgumentException if the map is null.\n+     * @throws NullPointerException if the map or time unit is null.\n      */\n     public PassiveExpiringMap(final long timeToLive, final TimeUnit timeUnit, final Map<K, V> map) {\n         this(validateAndConvertToMillis(timeToLive, timeUnit), map);\n      * being decorated, they also will NEVER expire.\n      *\n      * @param map the map to decorate, must not be null.\n-     * @throws IllegalArgumentException if the map is null.\n+     * @throws NullPointerException if the map is null.\n      */\n     public PassiveExpiringMap(final Map<K, V> map) {\n         this(-1L, map);\n--- a/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedMap.java\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @return a new predicated map\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n      * @since 4.0\n      */\n     public static <K, V> PredicatedMap<K, V> predicatedMap(final Map<K, V> map,\n      * @param map  the map to decorate, must not be null\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n      */\n     protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n                             final Predicate<? super V> valuePredicate) {\n--- a/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/PredicatedSortedMap.java\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @return a new predicated sorted map\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n      * @since 4.0\n      */\n     public static <K, V> PredicatedSortedMap<K, V> predicatedSortedMap(final SortedMap<K, V> map,\n      * @param map  the map to decorate, must not be null\n      * @param keyPredicate  the predicate to validate the keys, null means no check\n      * @param valuePredicate  the predicate to validate to values, null means no check\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n      */\n     protected PredicatedSortedMap(final SortedMap<K, V> map, final Predicate<? super K> keyPredicate,\n             final Predicate<? super V> valuePredicate) {\n--- a/src/main/java/org/apache/commons/collections4/map/SingletonMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/SingletonMap.java\n  * <p>\n  * If trying to remove or clear the map, an UnsupportedOperationException is thrown.\n  * If trying to put a new mapping into the map, an  IllegalArgumentException is thrown.\n- * The put method will only suceed if the key specified is the same as the\n+ * The put method will only succeed if the key specified is the same as the\n  * singleton key.\n  * <p>\n  * The key and value can be obtained by:\n--- a/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @return a new transformed map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> TransformedMap<K, V> transformingMap(final Map<K, V> map,\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @return a new transformed map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> TransformedMap<K, V> transformedMap(final Map<K, V> map,\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n      * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     protected TransformedMap(final Map<K, V> map, final Transformer<? super K, ? extends K> keyTransformer,\n             final Transformer<? super V, ? extends V> valueTransformer) {\n--- a/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedSortedMap.java\n      * @param keyTransformer  the predicate to validate the keys, null means no transformation\n      * @param valueTransformer  the predicate to validate to values, null means no transformation\n      * @return a new transformed sorted map\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n      * @since 4.0\n      */\n     public static <K, V> TransformedSortedMap<K, V> transformingSortedMap(final SortedMap<K, V> map,\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @return a new transformed sorted map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the predicate to validate the keys, null means no transformation\n      * @param valueTransformer  the predicate to validate to values, null means no transformation\n-     * @throws IllegalArgumentException if the map is null\n+     * @throws NullPointerException if the map is null\n      */\n     protected TransformedSortedMap(final SortedMap<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableEntrySet.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.AbstractSetDecorator;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.iterators.AbstractIteratorDecorator;\n import org.apache.commons.collections4.keyvalue.AbstractMapEntryDecorator;\n+import org.apache.commons.collections4.set.AbstractSetDecorator;\n \n /**\n  * Decorates a map entry <code>Set</code> to ensure it can't be altered.\n      * @param <V>  the value type\n      * @param set  the set to decorate, must not be null\n      * @return a new unmodifiable entry set\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      * @since 4.0\n      */\n     public static <K, V> Set<Map.Entry<K, V>> unmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     private UnmodifiableEntrySet(final Set<Map.Entry<K, V>> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableMap.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.IterableMap;\n import org.apache.commons.collections4.MapIterator;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n import org.apache.commons.collections4.iterators.EntrySetMapIterator;\n import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another <code>Map</code> to ensure it can't be altered.\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new unmodifiable map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> Map<K, V> unmodifiableMap(final Map<? extends K, ? extends V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableMap(final Map<? extends K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableOrderedMap.java\n import java.util.Map;\n import java.util.Set;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.OrderedMap;\n import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another <code>OrderedMap</code> to ensure it can't be altered.\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new ordered map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> OrderedMap<K, V> unmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableOrderedMap(final OrderedMap<? extends K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/UnmodifiableSortedMap.java\n import java.util.Set;\n import java.util.SortedMap;\n \n-import org.apache.commons.collections4.set.UnmodifiableSet;\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n  * Decorates another <code>SortedMap</code> to ensure it can't be altered.\n      * @param <V>  the value type\n      * @param map  the map to decorate, must not be null\n      * @return a new unmodifiable sorted map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <K, V> SortedMap<K, V> unmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n      * Constructor that wraps (not copies).\n      *\n      * @param map  the map to decorate, must not be null\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableSortedMap(final SortedMap<K, ? extends V> map) {\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n      * progress.\n      *\n      * @param map mappings to be stored in this map, may not be null\n+     * @return true if the map changed as a result of this operation\n      * @throws NullPointerException if map is null\n      */\n     @Override\n      * while the operation is in progress.\n      *\n      * @param map mappings to be stored in this map, may not be null\n+     * @return true if the map changed as a result of this operation\n      * @throws NullPointerException if map is null\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param multiset  the multiset to decorate, must not be null\n-     * @throws IllegalArgumentException if multiset is null\n+     * @throws NullPointerException if multiset is null\n      */\n     protected AbstractMultiSetDecorator(final MultiSet<E> multiset) {\n         super(multiset);\n--- a/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param queue  the queue to decorate, must not be null\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if queue is null\n      */\n     protected AbstractQueueDecorator(final Queue<E> queue) {\n         super(queue);\n--- a/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java\n+++ b/src/main/java/org/apache/commons/collections4/queue/PredicatedQueue.java\n      * @param Queue  the queue to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated queue\n-     * @throws IllegalArgumentException if queue or predicate is null\n+     * @throws NullPointerException if queue or predicate is null\n      * @throws IllegalArgumentException if the queue contains invalid elements\n      */\n     public static <E> PredicatedQueue<E> predicatedQueue(final Queue<E> Queue,\n      *\n      * @param queue  the queue to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if Queue or predicate is null\n+     * @throws NullPointerException if queue or predicate is null\n      * @throws IllegalArgumentException if the Queue contains invalid elements\n      */\n     protected PredicatedQueue(final Queue<E> queue, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java\n+++ b/src/main/java/org/apache/commons/collections4/queue/TransformedQueue.java\n      * @param queue  the queue to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Queue\n-     * @throws IllegalArgumentException if queue or transformer is null\n+     * @throws NullPointerException if queue or transformer is null\n      */\n     public static <E> TransformedQueue<E> transformingQueue(final Queue<E> queue,\n                                                             final Transformer<? super E, ? extends E> transformer) {\n      * @param queue  the queue to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed Queue\n-     * @throws IllegalArgumentException if queue or transformer is null\n+     * @throws NullPointerException if queue or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedQueue<E> transformedQueue(final Queue<E> queue,\n      *\n      * @param queue  the queue to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if queue or transformer is null\n+     * @throws NullPointerException if queue or transformer is null\n      */\n     protected TransformedQueue(final Queue<E> queue, final Transformer<? super E, ? extends E> transformer) {\n         super(queue, transformer);\n--- a/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java\n+++ b/src/main/java/org/apache/commons/collections4/queue/UnmodifiableQueue.java\n      * @param <E> the type of the elements in the queue\n      * @param queue  the queue to decorate, must not be null\n      * @return an unmodifiable Queue\n-     * @throws IllegalArgumentException if queue is null\n+     * @throws NullPointerException if queue is null\n      */\n     public static <E> Queue<E> unmodifiableQueue(final Queue<? extends E> queue) {\n         if (queue instanceof Unmodifiable) {\n      * Constructor that wraps (not copies).\n      *\n      * @param queue  the queue to decorate, must not be null\n-     * @throws IllegalArgumentException if queue is null\n+     * @throws NullPointerException if queue is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableQueue(final Queue<? extends E> queue) {\n--- a/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     protected AbstractNavigableSetDecorator(final NavigableSet<E> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java\n      * Constructor.\n      *\n      * @param set  the list to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     protected AbstractSerializableSetDecorator(final Set<E> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     protected AbstractSetDecorator(final Set<E> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     protected AbstractSortedSetDecorator(final Set<E> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/ListOrderedSet.java\n      * @param set the set to decorate, must be empty and not null\n      * @param list the list to decorate, must be empty and not null\n      * @return a new ordered set\n-     * @throws IllegalArgumentException if set or list is null\n+     * @throws NullPointerException if set or list is null\n      * @throws IllegalArgumentException if either the set or list is not empty\n      * @since 4.0\n      */\n     public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set, final List<E> list) {\n         if (set == null) {\n-            throw new IllegalArgumentException(\"Set must not be null\");\n+            throw new NullPointerException(\"Set must not be null\");\n         }\n         if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n+            throw new NullPointerException(\"List must not be null\");\n         }\n         if (set.size() > 0 || list.size() > 0) {\n             throw new IllegalArgumentException(\"Set and List must be empty\");\n      * @param <E> the element type\n      * @param set the set to decorate, must not be null\n      * @return a new ordered set\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      * @since 4.0\n      */\n     public static <E> ListOrderedSet<E> listOrderedSet(final Set<E> set) {\n      * @param <E> the element type\n      * @param list the list to decorate, must not be null\n      * @return a new ordered set\n-     * @throws IllegalArgumentException if list is null\n+     * @throws NullPointerException if list is null\n      * @since 4.0\n      */\n     public static <E> ListOrderedSet<E> listOrderedSet(final List<E> list) {\n         if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n+            throw new NullPointerException(\"List must not be null\");\n         }\n         CollectionUtils.filter(list, UniquePredicate.uniquePredicate());\n         final Set<E> set = new HashSet<E>(list);\n      *\n      * @param set the set to decorate, must not be null\n      * @param list the list to decorate, must not be null\n-     * @throws IllegalArgumentException if set or list is null\n+     * @throws NullPointerException if set or list is null\n      */\n     protected ListOrderedSet(final Set<E> set, final List<E> list) {\n         super(set);\n         if (list == null) {\n-            throw new IllegalArgumentException(\"List must not be null\");\n+            throw new NullPointerException(\"List must not be null\");\n         }\n         setOrder = list;\n     }\n--- a/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/MapBackedSet.java\n      * @param <V> the dummy value type in the map\n      * @param map  the map to decorate, must not be null\n      * @return a new map backed set\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map) {\n      * @param map  the map to decorate, must not be null\n      * @param dummyValue  the dummy value to use\n      * @return a new map backed set\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      * @since 4.0\n      */\n     public static <E, V> MapBackedSet<E, V> mapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n-        if (map == null) {\n-            throw new IllegalArgumentException(\"The map must not be null\");\n-        }\n         return new MapBackedSet<E, V>(map, dummyValue);\n     }\n \n      *\n      * @param map  the map to decorate, must not be null\n      * @param dummyValue  the dummy value to use\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     private MapBackedSet(final Map<E, ? super V> map, final V dummyValue) {\n         super();\n+        if (map == null) {\n+            throw new NullPointerException(\"The map must not be null\");\n+        }\n         this.map = map;\n         this.dummyValue = dummyValue;\n     }\n--- a/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedNavigableSet.java\n      * @param set  the set to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated navigable set.\n-     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws NullPointerException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param set  the set to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws NullPointerException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n     protected PredicatedNavigableSet(final NavigableSet<E> set, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSet.java\n      * @param set  the set to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a decorated set\n-     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws NullPointerException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param set  the set to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws NullPointerException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n     protected PredicatedSet(final Set<E> set, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/PredicatedSortedSet.java\n      * @param set  the set to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n      * @return a new predicated sorted set.\n-     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws NullPointerException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      * @since 4.0\n      */\n      *\n      * @param set  the set to decorate, must not be null\n      * @param predicate  the predicate to use for validation, must not be null\n-     * @throws IllegalArgumentException if set or predicate is null\n+     * @throws NullPointerException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n     protected PredicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n--- a/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedNavigableSet.java\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed {@link NavigableSet}\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      */\n     public static <E> TransformedNavigableSet<E> transformingNavigableSet(final NavigableSet<E> set,\n             final Transformer<? super E, ? extends E> transformer) {\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed {@link NavigableSet}\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      */\n     public static <E> TransformedNavigableSet<E> transformedNavigableSet(final NavigableSet<E> set,\n             final Transformer<? super E, ? extends E> transformer) {\n \n         final TransformedNavigableSet<E> decorated = new TransformedNavigableSet<E>(set, transformer);\n-        if (transformer != null && set != null && set.size() > 0) {\n+        if (set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n             final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n             set.clear();\n      *\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      */\n     protected TransformedNavigableSet(final NavigableSet<E> set,\n                                       final Transformer<? super E, ? extends E> transformer) {\n--- a/src/main/java/org/apache/commons/collections4/set/TransformedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSet.java\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed set\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedSet<E> transformingSet(final Set<E> set,\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed set\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      * @since 4.0\n      */\n     public static <E> Set<E> transformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n         final TransformedSet<E> decorated = new TransformedSet<E>(set, transformer);\n-        if (transformer != null && set != null && set.size() > 0) {\n+        if (set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n             final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n             set.clear();\n      *\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      */\n     protected TransformedSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n         super(set, transformer);\n--- a/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/TransformedSortedSet.java\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed {@link SortedSet}\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set,\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n      * @return a new transformed {@link SortedSet}\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      * @since 4.0\n      */\n     public static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set,\n             final Transformer<? super E, ? extends E> transformer) {\n \n         final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n-        if (transformer != null && set != null && set.size() > 0) {\n+        if (set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n             final E[] values = (E[]) set.toArray(); // NOPMD - false positive for generics\n             set.clear();\n      *\n      * @param set  the set to decorate, must not be null\n      * @param transformer  the transformer to use for conversion, must not be null\n-     * @throws IllegalArgumentException if set or transformer is null\n+     * @throws NullPointerException if set or transformer is null\n      */\n     protected TransformedSortedSet(final SortedSet<E> set, final Transformer<? super E, ? extends E> transformer) {\n         super(set, transformer);\n--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableNavigableSet.java\n      * @param <E> the element type\n      * @param set  the set to decorate, must not be null\n      * @return a new unmodifiable {@link NavigableSet}\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     public static <E> NavigableSet<E> unmodifiableNavigableSet(final NavigableSet<E> set) {\n         if (set instanceof Unmodifiable) {\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     private UnmodifiableNavigableSet(final NavigableSet<E> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSet.java\n      * @param <E> the element type\n      * @param set  the set to decorate, must not be null\n      * @return a new unmodifiable set\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      * @since 4.0\n      */\n     public static <E> Set<E> unmodifiableSet(final Set<? extends E> set) {\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     @SuppressWarnings(\"unchecked\") // safe to upcast\n     private UnmodifiableSet(final Set<? extends E> set) {\n--- a/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections4/set/UnmodifiableSortedSet.java\n      * @param <E> the element type\n      * @param set  the set to decorate, must not be null\n      * @return a new unmodifiable {@link SortedSet}\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      * @since 4.0\n      */\n     public static <E> SortedSet<E> unmodifiableSortedSet(final SortedSet<E> set) {\n      * Constructor that wraps (not copies).\n      *\n      * @param set  the set to decorate, must not be null\n-     * @throws IllegalArgumentException if set is null\n+     * @throws NullPointerException if set is null\n      */\n     private UnmodifiableSortedSet(final SortedSet<E> set) {\n         super(set);\n--- a/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/AbstractIterableGetMapDecorator.java\n \n     /**\n      * Create a new AbstractSplitMapDecorator.\n-     * @param decorated the Map to decorate\n+     * @param map the map to decorate, must not be null\n+     * @throws NullPointerException if map is null\n      */\n-    public AbstractIterableGetMapDecorator(final Map<K, V> decorated) {\n-        this.map = decorated;\n+    public AbstractIterableGetMapDecorator(final Map<K, V> map) {\n+        if (map == null) {\n+            throw new NullPointerException(\"Map must not be null.\");\n+        }\n+        this.map = map;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java\n  * @since 4.0\n  * @version $Id$\n  *\n- * @see org.apache.commons.collections4.SplitMapUtils#readableMap(Get)\n+ * @see org.apache.commons.collections4.SplitMapUtils#readableMap(org.apache.commons.collections4.Get)\n  * @see org.apache.commons.collections4.SplitMapUtils#writableMap(Put)\n  */\n public class TransformedSplitMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V>\n      * @param <U>  the input value type\n      * @param <V>  the output value type\n      * @param map the map to decorate, must not be null\n-     * @param keyTransformer the transformer to use for key conversion, null\n-     *   means no transformation\n-     * @param valueTransformer the transformer to use for value conversion, null\n-     *   means no transformation\n+     * @param keyTransformer the transformer to use for key conversion, must not be null\n+     * @param valueTransformer the transformer to use for value conversion, must not be null\n      * @return a new transformed map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map or either of the transformers is null\n      */\n     public static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map,\n             final Transformer<? super J, ? extends K> keyTransformer,\n      * are NOT transformed.\n      *\n      * @param map the map to decorate, must not be null\n-     * @param keyTransformer the transformer to use for key conversion, null\n-     * means no conversion\n-     * @param valueTransformer the transformer to use for value conversion, null\n-     * means no conversion\n-     * @throws IllegalArgumentException if map is null\n+     * @param keyTransformer the transformer to use for key conversion, must not be null\n+     * @param valueTransformer the transformer to use for value conversion, must not be null\n+     * @throws NullPointerException if map or either of the transformers is null\n      */\n     protected TransformedSplitMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer,\n             final Transformer<? super U, ? extends V> valueTransformer) {\n         super(map);\n         if (keyTransformer == null) {\n-            throw new IllegalArgumentException(\"keyTransformer cannot be null\");\n+            throw new NullPointerException(\"KeyTransformer must not be null.\");\n         }\n         this.keyTransformer = keyTransformer;\n         if (valueTransformer == null) {\n-            throw new IllegalArgumentException(\"valueTransformer cannot be null\");\n+            throw new NullPointerException(\"ValueTransformer must not be null.\");\n         }\n         this.valueTransformer = valueTransformer;\n     }\n--- a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n      * @param <V>  the value type\n      * @param trie  the trie to decorate, must not be null\n      * @return a new unmodifiable trie\n-     * @throws IllegalArgumentException if trie is null\n+     * @throws NullPointerException if trie is null\n      */\n     public static <K, V> Trie<K, V> unmodifiableTrie(final Trie<K, ? extends V> trie) {\n         if (trie instanceof Unmodifiable) {\n      * Constructor that wraps (not copies).\n      *\n      * @param trie  the trie to decorate, must not be null\n-     * @throws IllegalArgumentException if trie is null\n+     * @throws NullPointerException if trie is null\n      */\n     public UnmodifiableTrie(final Trie<K, ? extends V> trie) {\n         if (trie == null) {\n-            throw new IllegalArgumentException(\"Trie must not be null\");\n+            throw new NullPointerException(\"Trie must not be null\");\n         }\n         @SuppressWarnings(\"unchecked\") // safe to upcast\n         final Trie<K, V> tmpTrie = (Trie<K, V>) trie;\n--- a/src/test/java/org/apache/commons/collections4/BagUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/BagUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import org.apache.commons.collections4.bag.HashBag;\n import org.apache.commons.collections4.bag.PredicatedBag;\n             bag instanceof SynchronizedBag);\n         try {\n             BagUtils.synchronizedBag(null);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n             bag instanceof UnmodifiableBag);\n         try {\n             BagUtils.unmodifiableBag(null);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         \n             bag instanceof PredicatedBag);\n         try {\n             BagUtils.predicatedBag(null,truePredicate);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             BagUtils.predicatedBag(new HashBag<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null predicate.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n             bag instanceof TransformedBag);\n         try {\n             BagUtils.transformingBag(null, nopTransformer);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             BagUtils.transformingBag(new HashBag<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null transformer.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n             bag instanceof SynchronizedSortedBag);\n         try {\n             BagUtils.synchronizedSortedBag(null);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n             bag instanceof UnmodifiableSortedBag);\n         try {\n             BagUtils.unmodifiableSortedBag(null);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         \n             bag instanceof PredicatedSortedBag);\n         try {\n             BagUtils.predicatedSortedBag(null, truePredicate);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             BagUtils.predicatedSortedBag(new TreeBag<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null predicate.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n             bag instanceof TransformedSortedBag);\n         try {\n             BagUtils.transformingSortedBag(null, nopTransformer);\n-            fail(\"Expecting IllegalArgumentException for null bag.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null bag.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             BagUtils.transformingSortedBag(new TreeBag<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null transformer.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/ClosureUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/ClosureUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n import java.util.Collection;\n         try {\n             ClosureUtils.whileClosure(null, ClosureUtils.nopClosure());\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.whileClosure(FalsePredicate.falsePredicate(), null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.whileClosure(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // doWhileClosure\n         try {\n             ClosureUtils.doWhileClosure(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // chainedClosure\n         try {\n             ClosureUtils.chainedClosure(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<Object>chainedClosure((Closure[]) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<Object>chainedClosure((Collection<Closure<Object>>) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<Object>chainedClosure(new Closure[] {null, null});\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             coll = new ArrayList<Closure<Object>>();\n             coll.add(null);\n             coll.add(null);\n             ClosureUtils.chainedClosure(coll);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // ifClosure\n         try {\n             ClosureUtils.switchClosure(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure((Predicate<String>[]) null, (Closure<String>[]) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure((Map<Predicate<String>, Closure<String>>) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure(new Predicate[2], new Closure[2]);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             ClosureUtils.<String>switchClosure(\n                     new Predicate[] { TruePredicate.<String>truePredicate() },\n         try {\n             ClosureUtils.switchMapClosure(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // asClosure\n--- a/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n         assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testIsEqualCollectionNullEquator() {\n         CollectionUtils.isEqualCollection(collectionA, collectionA, null);\n     }\n         assertTrue(\"returned object should be a PredicatedCollection\", collection instanceof PredicatedCollection);\n         try {\n             CollectionUtils.predicatedCollection(new ArrayList<Number>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null predicate.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             CollectionUtils.predicatedCollection(null, predicate);\n-            fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null collection.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n         assertTrue(\"returned object should be a TransformedCollection\", collection instanceof TransformedCollection);\n         try {\n             CollectionUtils.transformingCollection(new ArrayList<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null transformer.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             CollectionUtils.transformingCollection(null, transformer);\n-            fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null collection.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n         assertTrue(\"Returned object should be a UnmodifiableCollection.\", col instanceof UnmodifiableCollection);\n         try {\n             CollectionUtils.unmodifiableCollection(null);\n-            fail(\"Expecting IllegalArgumentException for null collection.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null collection.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n         ArrayList<String> coll = null;\n         try {\n             CollectionUtils.extractSingleton(coll);\n-            fail(\"expected IllegalArgumentException from extractSingleton(null)\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"expected NullPointerException from extractSingleton(null)\");\n+        } catch (final NullPointerException e) {\n         }\n         coll = new ArrayList<String>();\n         try {\n         expect(iterator.next()).andReturn(t);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void collateException1() {\n         CollectionUtils.collate(collectionA, null);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void collateException2() {\n         CollectionUtils.collate(collectionA, collectionC, null);\n     }\n--- a/src/test/java/org/apache/commons/collections4/FactoryUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/FactoryUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.io.ByteArrayInputStream;\n import java.io.ByteArrayOutputStream;\n     // instantiateFactory\n     //------------------------------------------------------------------\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void instantiateFactoryNull() {\n         FactoryUtils.instantiateFactory(null);\n     }\n--- a/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n         try {\n             ListUtils.predicatedList(new ArrayList<Object>(), null);\n             fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             ListUtils.predicatedList(null, predicate);\n             fail(\"Expecting IllegalArgumentException for null list.\");\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n         try {\n             ListUtils.longestCommonSubsequence((List<?>) null, null);\n             fail(\"failed to check for null argument\");\n-        } catch (final IllegalArgumentException e) {}\n+        } catch (final NullPointerException e) {}\n \n         try {\n             ListUtils.longestCommonSubsequence(Arrays.asList('A'), null);\n             fail(\"failed to check for null argument\");\n-        } catch (final IllegalArgumentException e) {}\n+        } catch (final NullPointerException e) {}\n \n         try {\n             ListUtils.longestCommonSubsequence(null, Arrays.asList('A'));\n             fail(\"failed to check for null argument\");\n-        } catch (final IllegalArgumentException e) {}\n+        } catch (final NullPointerException e) {}\n \n         @SuppressWarnings(\"unchecked\")\n         List<Character> lcs = ListUtils.longestCommonSubsequence(Collections.EMPTY_LIST, Collections.EMPTY_LIST);\n       try {\n           ListUtils.longestCommonSubsequence((String) null, null);\n           fail(\"failed to check for null argument\");\n-      } catch (final IllegalArgumentException e) {}\n+      } catch (final NullPointerException e) {}\n \n       try {\n           ListUtils.longestCommonSubsequence(\"A\", null);\n           fail(\"failed to check for null argument\");\n-      } catch (final IllegalArgumentException e) {}\n+      } catch (final NullPointerException e) {}\n \n       try {\n           ListUtils.longestCommonSubsequence(null, \"A\");\n           fail(\"failed to check for null argument\");\n-      } catch (final IllegalArgumentException e) {}\n+      } catch (final NullPointerException e) {}\n \n       String lcs = ListUtils.longestCommonSubsequence(\"\", \"\");\n       assertEquals(0, lcs.length());\n         try {\n             ListUtils.partition(null, 3);\n             fail(\"failed to check for null argument\");\n-        } catch (final IllegalArgumentException e) {}\n+        } catch (final NullPointerException e) {}\n \n         try {\n             ListUtils.partition(strings, 0);\n--- a/src/test/java/org/apache/commons/collections4/MapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/MapUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotSame;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.io.ByteArrayOutputStream;\n import java.io.PrintStream;\n+import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.Iterator;\n+import java.util.List;\n import java.util.ListResourceBundle;\n import java.util.Map;\n import java.util.ResourceBundle;\n import java.util.Set;\n import java.util.TreeMap;\n-import java.util.List;\n-import java.util.ArrayList;\n \n import org.apache.commons.collections4.collection.TransformedCollectionTest;\n import org.apache.commons.collections4.keyvalue.DefaultKeyValue;\n         assertTrue(\"returned object should be a PredicatedMap\", map instanceof PredicatedMap);\n         try {\n             MapUtils.predicatedMap(null, p, p);\n-            fail(\"Expecting IllegalArgumentException for null map.\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null map.\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n     }\n         assertTrue(map instanceof LazyMap);\n         try {\n             map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Factory<Object>) null);\n-            fail(\"Expecting IllegalArgumentException for null factory\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null factory\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n         try {\n             map = MapUtils.lazyMap((Map<Object, Object>) null, factory);\n-            fail(\"Expecting IllegalArgumentException for null map\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null map\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n         final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(factory);\n         assertTrue(map instanceof LazyMap);\n         try {\n             map = MapUtils.lazyMap(new HashMap<Object, Object>(), (Transformer<Object, Object>) null);\n-            fail(\"Expecting IllegalArgumentException for null transformer\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null transformer\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n         try {\n             map = MapUtils.lazyMap((Map<Object, Object>) null, transformer);\n-            fail(\"Expecting IllegalArgumentException for null map\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null map\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n     }\n     public void testIterableMap() {\n         try {\n             MapUtils.iterableMap(null);\n-            fail(\"Should throw IllegalArgumentException\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Should throw NullPointerException\");\n+        } catch (final NullPointerException e) {\n         }\n         final HashMap<String, String> map = new HashMap<String, String>();\n         map.put(\"foo\", \"foov\");\n     public void testIterableSortedMap() {\n         try {\n             MapUtils.iterableSortedMap(null);\n-            fail(\"Should throw IllegalArgumentException\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Should throw NullPointerException\");\n+        } catch (final NullPointerException e) {\n         }\n         final TreeMap<String, String> map = new TreeMap<String, String>();\n         map.put(\"foo\", \"foov\");\n--- a/src/test/java/org/apache/commons/collections4/PredicateUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/PredicateUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.apache.commons.collections4.functors.NullPredicate.nullPredicate;\n-import static org.apache.commons.collections4.functors.TruePredicate.truePredicate;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.fail;\n+import static org.apache.commons.collections4.functors.NullPredicate.*;\n+import static org.apache.commons.collections4.functors.TruePredicate.*;\n+import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n import java.util.Collection;\n         assertEquals(false, PredicateUtils.notPredicate(TruePredicate.truePredicate()).evaluate(cInteger));\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testNotPredicateEx() {\n         PredicateUtils.notPredicate(null);\n     }\n         assertEquals(false, PredicateUtils.andPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAndPredicateEx() {\n         PredicateUtils.andPredicate(null, null);\n     }\n         assertTrue(AllPredicate.allPredicate(coll), null);\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAllPredicateEx1() {\n         AllPredicate.allPredicate((Predicate<Object>[]) null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAllPredicateEx2() {\n         AllPredicate.<Object>allPredicate(new Predicate[] { null });\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAllPredicateEx3() {\n         AllPredicate.allPredicate(new Predicate[] { null, null });\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAllPredicateEx4() {\n         AllPredicate.allPredicate((Collection<Predicate<Object>>) null);\n     }\n         AllPredicate.allPredicate(Collections.<Predicate<Object>>emptyList());\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAllPredicateEx6() {\n         final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         assertEquals(false, PredicateUtils.orPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testOrPredicateEx() {\n         PredicateUtils.orPredicate(null, null);\n     }\n         assertFalse(PredicateUtils.anyPredicate(coll), null);\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAnyPredicateEx1() {\n         PredicateUtils.anyPredicate((Predicate<Object>[]) null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAnyPredicateEx2() {\n         PredicateUtils.anyPredicate(new Predicate[] {null});\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAnyPredicateEx3() {\n         PredicateUtils.anyPredicate(new Predicate[] {null, null});\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAnyPredicateEx4() {\n         PredicateUtils.anyPredicate((Collection<Predicate<Object>>) null);\n     }\n         PredicateUtils.anyPredicate(Collections.<Predicate<Object>>emptyList());\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testAnyPredicateEx6() {\n         final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         assertEquals(false, PredicateUtils.eitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testEitherPredicateEx() {\n         PredicateUtils.eitherPredicate(null, null);\n     }\n         assertFalse(PredicateUtils.onePredicate(coll), null);\n     }\n \n-    @Test(expected=IllegalArgumentException.class) \n+    @Test(expected=NullPointerException.class) \n     public void testOnePredicateEx1() {\n         PredicateUtils.onePredicate((Predicate<Object>[]) null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testOnePredicateEx2() {\n         PredicateUtils.onePredicate(new Predicate[] {null});\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testOnePredicateEx3() {\n         PredicateUtils.onePredicate(new Predicate[] {null, null});\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testOnePredicateEx4() {\n         PredicateUtils.onePredicate((Collection<Predicate<Object>>) null);\n     }\n         PredicateUtils.onePredicate(Collections.EMPTY_LIST);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testOnePredicateEx6() {\n         final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         assertEquals(true, PredicateUtils.neitherPredicate(FalsePredicate.falsePredicate(), FalsePredicate.falsePredicate()).evaluate(null));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNeitherPredicateEx() {\n         PredicateUtils.neitherPredicate(null, null);\n     }\n         assertTrue(PredicateUtils.nonePredicate(coll), null);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNonePredicateEx1() {\n         PredicateUtils.nonePredicate((Predicate<Object>[]) null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNonePredicateEx2() {\n         PredicateUtils.nonePredicate(new Predicate[] {null});\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNonePredicateEx3() {\n         PredicateUtils.nonePredicate(new Predicate[] {null, null});\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNonePredicateEx4() {\n         PredicateUtils.nonePredicate((Collection<Predicate<Object>>) null);\n     }\n         PredicateUtils.nonePredicate(Collections.<Predicate<Object>>emptyList());\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNonePredicateEx6() {\n         final Collection<Predicate<Object>> coll = new ArrayList<Predicate<Object>>();\n         coll.add(null);\n         assertEquals(true, PredicateUtils.asPredicate(TransformerUtils.<Boolean>nopTransformer()).evaluate(true));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testAsPredicateTransformerEx1() {\n         PredicateUtils.asPredicate(null);\n     }\n         assertEquals(false, PredicateUtils.invokerPredicate(\"isEmpty\").evaluate(list));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testInvokerPredicateEx1() {\n         PredicateUtils.invokerPredicate(null);\n     }\n             \"contains\", new Class[] {Object.class}, new Object[] {cString}).evaluate(list));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testInvokerPredicate2Ex1() {\n         PredicateUtils.invokerPredicate(null, null, null);\n     }\n         PredicateUtils.nullIsExceptionPredicate(TruePredicate.truePredicate()).evaluate(null);\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNullIsExceptionPredicateEx1() {\n         PredicateUtils.nullIsExceptionPredicate(null);\n     }\n         assertEquals(false, PredicateUtils.nullIsTruePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNullIsTruePredicateEx1() {\n         PredicateUtils.nullIsTruePredicate(null);\n     }\n         assertEquals(false, PredicateUtils.nullIsFalsePredicate(FalsePredicate.falsePredicate()).evaluate(new Object()));\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected=NullPointerException.class)\n     public void testNullIsFalsePredicateEx1() {\n         PredicateUtils.nullIsFalsePredicate(null);\n     }\n         try {\n             PredicateUtils.transformedPredicate(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // misc tests\n--- a/src/test/java/org/apache/commons/collections4/QueueUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/QueueUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.util.LinkedList;\n import java.util.Queue;\n         assertTrue(\"Returned object should be an UnmodifiableQueue.\", queue instanceof UnmodifiableQueue);\n         try {\n             QueueUtils.unmodifiableQueue(null);\n-            fail(\"Expecting IllegalArgumentException for null queue.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null queue.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         \n         assertTrue(\"Returned object should be a PredicatedQueue.\", queue instanceof PredicatedQueue);\n         try {\n             QueueUtils.predicatedQueue(null, truePredicate);\n-            fail(\"Expecting IllegalArgumentException for null queue.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null queue.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             QueueUtils.predicatedQueue(new LinkedList<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null predicate.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n         assertTrue(\"Returned object should be an TransformedQueue.\", queue instanceof TransformedQueue);\n         try {\n             QueueUtils.transformingQueue(null, nopTransformer);\n-            fail(\"Expecting IllegalArgumentException for null queue.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null queue.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             QueueUtils.transformingQueue(new LinkedList<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null transformer.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null transformer.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.util.Arrays;\n import java.util.Collection;\n         assertTrue(\"returned object should be a PredicatedSet\", set instanceof PredicatedSet);\n         try {\n             SetUtils.predicatedSet(new HashSet<Object>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null predicate.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         try {\n             SetUtils.predicatedSet(null, predicate);\n-            fail(\"Expecting IllegalArgumentException for null set.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null set.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/TransformerUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/TransformerUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n import java.util.Collection;\n         assertEquals(cInteger, TransformerUtils.asTransformer(ClosureUtils.nopClosure()).transform(cInteger));\n         try {\n             TransformerUtils.asTransformer((Closure<Object>) null);\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             return;\n         }\n         fail();\n         assertEquals(null, TransformerUtils.asTransformer(FactoryUtils.nullFactory()).transform(cInteger));\n         try {\n             TransformerUtils.asTransformer((Factory<Object>) null);\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             return;\n         }\n         fail();\n         try {\n             TransformerUtils.chainedTransformer(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.chainedTransformer((Transformer[]) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.chainedTransformer((Collection<Transformer<Object, Object>>) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.chainedTransformer(new Transformer[] {null, null});\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             coll = new ArrayList<Transformer<Object, Object>>();\n             coll.add(null);\n             coll.add(null);\n             TransformerUtils.chainedTransformer(coll);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // ifTransformer\n         try {\n             TransformerUtils.ifTransformer(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.ifTransformer(TruePredicate.truePredicate(), null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.ifTransformer(null, ConstantTransformer.constantTransformer(\"A\"));\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.ifTransformer(null, null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n     \n     // switchTransformer\n         try {\n             TransformerUtils.switchTransformer(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.switchTransformer((Predicate[]) null, (Transformer[]) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.switchTransformer((Map<Predicate<Object>, Transformer<Object, Object>>) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.switchTransformer(new Predicate[2], new Transformer[2]);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.switchTransformer(\n                     new Predicate[] { TruePredicate.truePredicate() },\n         try {\n             TransformerUtils.switchMapTransformer(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     // invokerTransformer\n         try {\n             TransformerUtils.invokerTransformer(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"noSuchMethod\").transform(new Object());\n             fail();\n         try {\n             TransformerUtils.invokerTransformer(null, null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n         try {\n             TransformerUtils.invokerTransformer(\"noSuchMethod\", new Class[] { Object.class },\n                     new Object[] { cString }).transform(new Object());\n--- a/src/test/java/org/apache/commons/collections4/TrieUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/TrieUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.assertSame;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n+import static org.junit.Assert.*;\n \n import org.apache.commons.collections4.trie.PatriciaTrie;\n import org.apache.commons.collections4.trie.UnmodifiableTrie;\n             trie instanceof UnmodifiableTrie);\n         try {\n             TrieUtils.unmodifiableTrie(null);\n-            fail(\"Expecting IllegalArgumentException for null trie.\");\n-        } catch (final IllegalArgumentException ex) {\n+            fail(\"Expecting NullPointerException for null trie.\");\n+        } catch (final NullPointerException ex) {\n             // expected\n         }\n         \n--- a/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/PredicatedBagTest.java\n         }\n         try {\n             decorateBag(new HashBag<T>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate.\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null predicate.\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/PredicatedSortedBagTest.java\n         ((PredicatedSortedBag<T>) bag).decorated();\n         try {\n             decorateBag(new TreeBag<T>(), null);\n-            fail(\"Expecting IllegalArgumentException for null predicate\");\n-        } catch (final IllegalArgumentException e) {}\n+            fail(\"Expecting NullPointerException for null predicate\");\n+        } catch (final NullPointerException e) {}\n         try {\n             decorateBag(nullBag, stringPredicate());\n-            fail(\"Expecting IllegalArgumentException for null bag\");\n-        } catch (final IllegalArgumentException e) {}\n+            fail(\"Expecting NullPointerException for null bag\");\n+        } catch (final NullPointerException e) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n--- a/src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/UnmodifiableBagTest.java\n         try {\n             UnmodifiableBag.unmodifiableBag(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/UnmodifiableSortedBagTest.java\n         try {\n             UnmodifiableSortedBag.unmodifiableSortedBag(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableBidiMapTest.java\n         try {\n             UnmodifiableBidiMap.unmodifiableBidiMap(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n     \n }\n--- a/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableOrderedBidiMapTest.java\n         try {\n             UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n }\n--- a/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/UnmodifiableSortedBidiMapTest.java\n         try {\n             UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/UnmodifiableBoundedCollectionTest.java\n         try {\n             UnmodifiableBoundedCollection.unmodifiableBoundedCollection(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n     \n }\n--- a/src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/UnmodifiableCollectionTest.java\n         try {\n             UnmodifiableCollection.unmodifiableCollection(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java\n  */\n package org.apache.commons.collections4.functors;\n \n-import org.apache.commons.collections4.Predicate;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n+\n+import org.apache.commons.collections4.Predicate;\n+import org.junit.Assert;\n+import org.junit.Test;\n \n /**\n  * Base class for tests of composite predicates.\n     /**\n      * Tests <code>getInstance</code> with a null predicate array.\n      */\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test(expected = NullPointerException.class)\n     public final void nullArrayToGetInstance() {\n         getPredicateInstance((Predicate<T>[]) null);\n     }\n      * Tests <code>getInstance</code> with a single null element in the predicate array.\n      */\n     @SuppressWarnings({\"unchecked\"})\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test(expected = NullPointerException.class)\n     public final void nullElementInArrayToGetInstance() {\n         getPredicateInstance(new Predicate[] { null });\n     }\n      * Tests <code>getInstance</code> with two null elements in the predicate array.\n      */\n     @SuppressWarnings({\"unchecked\"})\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test(expected = NullPointerException.class)\n     public final void nullElementsInArrayToGetInstance() {\n         getPredicateInstance(new Predicate[] { null, null });\n     }\n     /**\n      * Tests <code>getInstance</code> with a null predicate collection\n      */\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test(expected = NullPointerException.class)\n     public final void nullCollectionToGetInstance() {\n         getPredicateInstance((Collection<Predicate<T>>) null);\n     }\n     /**\n      * Tests <code>getInstance</code> with a predicate collection that contains null elements\n      */\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test(expected = NullPointerException.class)\n     public final void nullElementsInCollectionToGetInstance() {\n         final Collection<Predicate<T>> coll = new ArrayList<Predicate<T>>();\n         coll.add(null);\n--- a/src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java\n  */\n package org.apache.commons.collections4.iterators;\n \n+import static org.easymock.EasyMock.*;\n+\n import java.util.Iterator;\n \n import org.w3c.dom.Element;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n import org.w3c.dom.Text;\n-\n-import static org.easymock.EasyMock.createMock;\n-import static org.easymock.EasyMock.expect;\n-import static org.easymock.EasyMock.replay;\n \n /**\n  * Tests the NodeListIterator.\n     public void testNullConstructor(){\n         try{\n             new NodeListIterator((Node) null);\n-            fail(\"IllegalArgumentException expected!\");\n-        }catch(final IllegalArgumentException e){\n+            fail(\"NullPointerException expected!\");\n+        }catch(final NullPointerException e){\n             // expected.\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableIteratorTest.java\n         try {\n             UnmodifiableIterator.unmodifiableIterator(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableListIteratorTest.java\n         try {\n             UnmodifiableListIterator.umodifiableListIterator(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableMapIteratorTest.java\n         try {\n             UnmodifiableMapIterator.unmodifiableMapIterator(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/UnmodifiableOrderedMapIteratorTest.java\n         try {\n             UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/UnmodifiableListTest.java\n         try {\n             UnmodifiableList.unmodifiableList(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     @SuppressWarnings(\"unchecked\")\n--- a/src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java\n  */\n package org.apache.commons.collections4.map;\n \n-import static org.apache.commons.collections4.map.LazySortedMap.lazySortedMap;\n+import static org.apache.commons.collections4.map.LazySortedMap.*;\n \n import java.util.Comparator;\n import java.util.Map;\n         assertTrue(map instanceof LazySortedMap);\n          try {\n             map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n-            fail(\"Expecting IllegalArgumentException for null transformer\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null transformer\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n         try {\n             map = lazySortedMap((SortedMap<Integer,Number>) null, transformer);\n-            fail(\"Expecting IllegalArgumentException for null map\");\n-        } catch (final IllegalArgumentException e) {\n+            fail(\"Expecting NullPointerException for null map\");\n+        } catch (final NullPointerException e) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java\n             final Map<String, String> map = null;\n             new PassiveExpiringMap<String, String>(map);\n             fail(\"constructor - exception should have been thrown.\");\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             // success\n         }\n \n             final ExpirationPolicy<String, String> policy = null;\n             new PassiveExpiringMap<String, String>(policy);\n             fail(\"constructor - exception should have been thrown.\");\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             // success\n         }\n \n             final TimeUnit unit = null;\n             new PassiveExpiringMap<String, String>(10L, unit);\n             fail(\"constructor - exception should have been thrown.\");\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n             // success\n         }\n     }\n--- a/src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/UnmodifiableMapTest.java\n         try {\n             UnmodifiableMap.unmodifiableMap(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/UnmodifiableOrderedMapTest.java\n         try {\n             UnmodifiableOrderedMap.unmodifiableOrderedMap(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/UnmodifiableSortedMapTest.java\n         try {\n             UnmodifiableSortedMap.unmodifiableSortedMap(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java\n+++ b/src/test/java/org/apache/commons/collections4/queue/UnmodifiableQueueTest.java\n         try {\n             UnmodifiableQueue.unmodifiableQueue(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/ListOrderedSetTest.java\n         try {\n             ListOrderedSet.listOrderedSet((List<E>) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet((Set<E>) null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet(null, null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet(new HashSet<E>(), null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n         try {\n             ListOrderedSet.listOrderedSet(null, new ArrayList<E>());\n             fail();\n-        } catch (final IllegalArgumentException ex) {\n+        } catch (final NullPointerException ex) {\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/UnmodifiableNavigableSetTest.java\n         try {\n             UnmodifiableNavigableSet.unmodifiableNavigableSet(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/UnmodifiableSetTest.java\n         try {\n             UnmodifiableSet.unmodifiableSet(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------\n--- a/src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/UnmodifiableSortedSetTest.java\n         try {\n             UnmodifiableSortedSet.unmodifiableSortedSet(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java\n+++ b/src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java\n         try {\n             UnmodifiableTrie.unmodifiableTrie(null);\n             fail();\n-        } catch (final IllegalArgumentException ex) {}\n+        } catch (final NullPointerException ex) {}\n     }\n \n     //-----------------------------------------------------------------------", "timestamp": 1434978027, "metainfo": ""}