{"sha": "9314193c8c6e08b1b6ec1f8d8ae1380c4b7d0585", "log": "[COLLECTIONS-572] Add set operations to SetUtils.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/SetUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/SetUtils.java\n  */\n package org.apache.commons.collections4;\n \n+import java.util.AbstractSet;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.IdentityHashMap;\n+import java.util.Iterator;\n import java.util.NavigableSet;\n import java.util.Set;\n import java.util.SortedSet;\n      */\n     @SuppressWarnings(\"unchecked\") // empty set is OK for any type\n     public static <E> SortedSet<E> emptySortedSet() {\n-        return (SortedSet<E>) EMPTY_SORTED_SET;\n+        return EMPTY_SORTED_SET;\n     }\n \n     /**\n         return TransformedNavigableSet.transformingNavigableSet(set, transformer);\n     }\n \n+    // Set operations\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Returns a unmodifiable <b>view</b> of the union of the given {@link Set}s.\n+     * <p>\n+     * The returned view contains all elements of {@code a} and {@code b}.\n+     *\n+     * @param <E> the generic type that is able to represent the types contained\n+     *   in both input sets.\n+     * @param a  the first set, must not be null\n+     * @param b  the second set, must not be null\n+     * @return a view of the union of the two set\n+     * @throws NullPointerException if either input set is null\n+     * @since 4.1\n+     */\n+    public static <E> SetView<E> union(final Set<? extends E> a, final Set<? extends E> b) {\n+        if (a == null || b == null) {\n+            throw new NullPointerException(\"Sets must not be null.\");\n+        }\n+\n+        final SetView<E> bMinusA = difference(b, a);\n+\n+        return new SetView<E>() {\n+            @Override\n+            public boolean contains(Object o) {\n+                return a.contains(o) || b.contains(o);\n+            }\n+\n+            @Override\n+            public Iterator<E> createIterator() {\n+                return IteratorUtils.chainedIterator(a.iterator(), bMinusA.iterator());\n+            }\n+\n+            @Override\n+            public boolean isEmpty() {\n+                return a.isEmpty() && b.isEmpty();\n+            }\n+\n+            @Override\n+            public int size() {\n+                return a.size() + bMinusA.size();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns a unmodifiable <b>view</b> containing the difference of the given\n+     * {@link Set}s, denoted by {@code a \\ b} (or {@code a - b}).\n+     * <p>\n+     * The returned view contains all elements of {@code a} that are not a member\n+     * of {@code b}.\n+     *\n+     * @param <E> the generic type that is able to represent the types contained\n+     *   in both input sets.\n+     * @param a  the set to subtract from, must not be null\n+     * @param b  the set to subtract, must not be null\n+     * @return a view of the relative complement of  of the two sets\n+     * @since 4.1\n+     */\n+    public static <E> SetView<E> difference(final Set<? extends E> a, final Set<? extends E> b) {\n+        if (a == null || b == null) {\n+            throw new NullPointerException(\"Sets must not be null.\");\n+        }\n+\n+        final Predicate<E> notContainedInB = new Predicate<E>() {\n+            @Override\n+            public boolean evaluate(E object) {\n+                return !b.contains(object);\n+            }\n+        };\n+\n+        return new SetView<E>() {\n+            @Override\n+            public boolean contains(Object o) {\n+                return a.contains(o) && !b.contains(o);\n+            }\n+\n+            @Override\n+            public Iterator<E> createIterator() {\n+                return IteratorUtils.filteredIterator(a.iterator(), notContainedInB);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns a unmodifiable <b>view</b> of the intersection of the given {@link Set}s.\n+     * <p>\n+     * The returned view contains all elements that are members of both input sets\n+     * ({@code a} and {@code b}).\n+     *\n+     * @param <E> the generic type that is able to represent the types contained\n+     *   in both input sets.\n+     * @param a  the first set, must not be null\n+     * @param b  the second set, must not be null\n+     * @return a view of the intersection of the two sets\n+     * @since 4.1\n+     */\n+    public static <E> SetView<E> intersection(final Set<? extends E> a, final Set<? extends E> b) {\n+        if (a == null || b == null) {\n+            throw new NullPointerException(\"Sets must not be null.\");\n+        }\n+\n+        final Predicate<E> containedInB = new Predicate<E>() {\n+            @Override\n+            public boolean evaluate(E object) {\n+                return b.contains(object);\n+            }\n+        };\n+\n+        return new SetView<E>() {\n+            @Override\n+            public boolean contains(Object o) {\n+                return a.contains(o) && b.contains(o);\n+            }\n+\n+            @Override\n+            public Iterator<E> createIterator() {\n+                return IteratorUtils.filteredIterator(a.iterator(), containedInB);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Returns a unmodifiable <b>view</b> of the symmetric difference of the given\n+     * {@link Set}s.\n+     * <p>\n+     * The returned view contains all elements of {@code a} and {@code b} that are\n+     * not a member of the other set.\n+     * <p>\n+     * This is equivalent to {@code union(difference(a, b), difference(b, a))}.\n+     *\n+     * @param <E> the generic type that is able to represent the types contained\n+     *   in both input sets.\n+     * @param a  the first set, must not be null\n+     * @param b  the second set, must not be null\n+     * @return a view of the symmetric difference of the two sets\n+     * @since 4.1\n+     */\n+    public static <E> SetView<E> disjunction(final Set<? extends E> a, final Set<? extends E> b) {\n+        if (a == null || b == null) {\n+            throw new NullPointerException(\"Sets must not be null.\");\n+        }\n+\n+        final SetView<E> aMinusB = difference(a, b);\n+        final SetView<E> bMinusA = difference(b, a);\n+\n+        return new SetView<E>() {\n+            @Override\n+            public boolean contains(Object o) {\n+                return a.contains(o) ^ b.contains(o);\n+            }\n+\n+            @Override\n+            public Iterator<E> createIterator() {\n+                return IteratorUtils.chainedIterator(aMinusB.iterator(), bMinusA.iterator());\n+            }\n+\n+            @Override\n+            public boolean isEmpty() {\n+                return aMinusB.isEmpty() && bMinusA.isEmpty();\n+            }\n+\n+            @Override\n+            public int size() {\n+                return aMinusB.size() + bMinusA.size();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * An unmodifiable <b>view</b> of a set that may be backed by other sets.\n+     * <p>\n+     * If the decorated sets change, this view will change as well. The contents\n+     * of this view can be transferred to another instance via the {@link #copyInto(Set)}\n+     * and {@link #toSet()} methods.\n+     * \n+     * @param <E> the element type\n+     * @since 4.1\n+     */\n+    public static abstract class SetView<E> extends AbstractSet<E> {\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return IteratorUtils.unmodifiableIterator(createIterator());\n+        }\n+\n+        /**\n+         * Return an iterator for this view; the returned iterator is\n+         * not required to be unmodifiable.\n+         * @return a new iterator for this view\n+         */\n+        protected abstract Iterator<E> createIterator();\n+\n+        @Override\n+        public int size() {\n+            return IteratorUtils.size(iterator());\n+        }\n+\n+        /**\n+         * Copies the contents of this view into the provided set.\n+         *\n+         * @param set  the set for copying the contents\n+         */\n+        public <S extends Set<E>> void copyInto(final S set) {\n+            CollectionUtils.addAll(set, this);\n+        }\n+\n+        /**\n+         * Returns a new set containing the contents of this view.\n+         *\n+         * @return a new set containing all elements of this view\n+         */\n+        public Set<E> toSet() {\n+            final Set<E> set = new HashSet<E>(size());\n+            copyInto(set);\n+            return set;\n+        }\n+    }\n }\n--- a/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n  */\n package org.apache.commons.collections4;\n \n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n import java.util.Arrays;\n import java.util.Collection;\n import java.util.HashSet;\n import java.util.Set;\n \n+import org.apache.commons.collections4.SetUtils.SetView;\n import org.apache.commons.collections4.set.PredicatedSet;\n+import org.junit.Before;\n import org.junit.Test;\n \n /**\n  */\n public class SetUtilsTest {\n \n+    private Set<Integer> setA;\n+    private Set<Integer> setB;\n+\n+    @Before\n+    public void setUp() {\n+        setA = new HashSet<Integer>();\n+        setA.add(1);\n+        setA.add(2);\n+        setA.add(3);\n+        setA.add(4);\n+        setA.add(5);\n+\n+        setB = new HashSet<Integer>();\n+        setB.add(3);\n+        setB.add(4);\n+        setB.add(5);\n+        setB.add(6);\n+        setB.add(7);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n     @Test\n     public void testpredicatedSet() {\n         final Predicate<Object> predicate = new Predicate<Object>() {\n+            @Override\n             public boolean evaluate(final Object o) {\n                 return o instanceof String;\n             }\n         set.remove(a);\n         assertEquals(2, set.size());\n     }\n+\n+    @Test\n+    public void union() {\n+        final SetView<Integer> set = SetUtils.union(setA, setB);\n+        assertEquals(7, set.size());\n+        assertTrue(set.containsAll(setA));\n+        assertTrue(set.containsAll(setB));\n+\n+        final Set<Integer> set2 = SetUtils.union(setA, SetUtils.<Integer>emptySet());\n+        assertEquals(setA, set2);\n+\n+        try {\n+            SetUtils.union(setA, null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n+        try {\n+            SetUtils.union(null, setA);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void difference() {\n+        final SetView<Integer> set = SetUtils.difference(setA, setB);\n+        assertEquals(2, set.size());\n+        assertTrue(set.contains(1));\n+        assertTrue(set.contains(2));\n+        for (Integer i : setB) {\n+            assertFalse(set.contains(i));\n+        }\n+\n+        final Set<Integer> set2 = SetUtils.difference(setA, SetUtils.<Integer>emptySet());\n+        assertEquals(setA, set2);\n+\n+        try {\n+            SetUtils.difference(setA, null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n+        try {\n+            SetUtils.difference(null, setA);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void intersection() {\n+        final SetView<Integer> set = SetUtils.intersection(setA, setB);\n+        assertEquals(3, set.size());\n+        assertTrue(set.contains(3));\n+        assertTrue(set.contains(4));\n+        assertTrue(set.contains(5));\n+        assertFalse(set.contains(1));\n+        assertFalse(set.contains(2));\n+        assertFalse(set.contains(6));\n+        assertFalse(set.contains(7));\n+\n+        final Set<Integer> set2 = SetUtils.intersection(setA, SetUtils.<Integer>emptySet());\n+        assertEquals(SetUtils.<Integer>emptySet(), set2);\n+\n+        try {\n+            SetUtils.intersection(setA, null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n+        try {\n+            SetUtils.intersection(null, setA);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void disjunction() {\n+        final SetView<Integer> set = SetUtils.disjunction(setA, setB);\n+        assertEquals(4, set.size());\n+        assertTrue(set.contains(1));\n+        assertTrue(set.contains(2));\n+        assertTrue(set.contains(6));\n+        assertTrue(set.contains(7));\n+        assertFalse(set.contains(3));\n+        assertFalse(set.contains(4));\n+        assertFalse(set.contains(5));\n+\n+        final Set<Integer> set2 = SetUtils.disjunction(setA, SetUtils.<Integer>emptySet());\n+        assertEquals(setA, set2);\n+\n+        try {\n+            SetUtils.disjunction(setA, null);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n+        try {\n+            SetUtils.disjunction(null, setA);\n+            fail(\"Expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+    }\n+\n }", "timestamp": 1435009767, "metainfo": ""}