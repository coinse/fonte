{"sha": "5df60bb0e65f30d0c79615f53e988076ef1bfb96", "log": "Trailing spaces  ", "commit": "\n--- a/src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java\n             // This is correct\n         }\n         verify();\n-        \n+\n         resetFull();\n         final Object last = getCollection().getLast();\n         final Object confirmedLast = getConfirmedLinkedList().getLast();\n             // This is correct\n         }\n         verify();\n-        \n+\n         resetFull();\n         final Object first = getCollection().removeFirst();\n         final Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n--- a/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java\n+++ b/src/test/java/org/apache/commons/collections4/AbstractObjectTest.java\n \n     /** Current major release for Collections */\n     public static final int COLLECTIONS_MAJOR_VERSION = 4;\n-    \n+\n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractObjectTest(final String testName) {\n     //-----------------------------------------------------------------------\n     /**\n      * Implement this method to return the object to test.\n-     * \n+     *\n      * @return the object to test\n      */\n     public abstract Object makeObject();\n      * Override this method if a subclass is testing an object\n      * that cannot serialize an \"empty\" Collection.\n      * (e.g. Comparators have no contents)\n-     * \n+     *\n      * @return true\n      */\n     public boolean supportsEmptyCollections() {\n      * Override this method if a subclass is testing an object\n      * that cannot serialize a \"full\" Collection.\n      * (e.g. Comparators have no contents)\n-     * \n+     *\n      * @return true\n      */\n     public boolean supportsFullCollections() {\n \n     /**\n      * Sanity check method, makes sure that any Serializable\n-     * class can be serialized and de-serialized in memory, \n+     * class can be serialized and de-serialized in memory,\n      * using the handy makeObject() method\n-     * \n+     *\n      * @throws IOException\n      * @throws ClassNotFoundException\n      */\n      * Get the version of Collections that this object tries to\n      * maintain serialization compatibility with. Defaults to 4, due to\n      * the package change to collections4 introduced in version 4.\n-     * \n+     *\n      * This constant makes it possible for TestMap (and other subclasses,\n      * if necessary) to automatically check SVN for a versionX copy of a\n      * Serialized object, so we can make sure that compatibility is maintained.\n      * See, for example, TestMap.getCanonicalFullMapName(Map map).\n      * Subclasses can override this variable, indicating compatibility\n      * with earlier Collections versions.\n-     * \n+     *\n      * @return The version, or <code>null</code> if this object shouldn't be\n      * tested for compatibility with previous versions.\n      */\n      * for creating disk-based objects in SVN that can become\n      * the basis for compatibility tests using\n      * readExternalFormFromDisk(String path)\n-     * \n+     *\n      * @param o Object to serialize\n      * @param path path to write the serialized Object\n      * @exception IOException\n     /**\n      * Converts a Serializable or Externalizable object to\n      * bytes.  Useful for in-memory tests of serialization\n-     * \n+     *\n      * @param o Object to convert to bytes\n      * @return serialized form of the Object\n      * @exception IOException\n      * Reads a Serialized or Externalized Object from disk.\n      * Useful for creating compatibility tests between\n      * different SVN versions of the same class\n-     * \n+     *\n      * @param path path to the serialized Object\n      * @return the Object at the given path\n      * @exception IOException\n     /**\n      * Read a Serialized or Externalized Object from bytes.\n      * Useful for verifying serialization in memory.\n-     * \n+     *\n      * @param b byte array containing a serialized Object\n      * @return Object contained in the bytes\n      * @exception IOException\n--- a/src/test/java/org/apache/commons/collections4/ArrayStackTest.java\n+++ b/src/test/java/org/apache/commons/collections4/ArrayStackTest.java\n  */\n @SuppressWarnings(\"deprecation\") // we test a deprecated class\n public class ArrayStackTest<E> extends AbstractArrayListTest<E> {\n-    \n+\n     public ArrayStackTest(final String testName) {\n         super(testName);\n     }\n                      -1, stack.search(\"Missing Item\"));\n \n     }\n-    \n+\n     @Override\n     public String getCompatibilityVersion() {\n         return \"4\";\n--- a/src/test/java/org/apache/commons/collections4/BulkTest.java\n+++ b/src/test/java/org/apache/commons/collections4/BulkTest.java\n /**\n  * A {@link TestCase} that can define both simple and bulk test methods.\n  * <p>\n- * A <I>simple test method</I> is the type of test traditionally \n- * supplied by by {@link TestCase}.  To define a simple test, create a public \n+ * A <I>simple test method</I> is the type of test traditionally\n+ * supplied by by {@link TestCase}.  To define a simple test, create a public\n  * no-argument method whose name starts with \"test\".  You can specify the\n  * the name of simple test in the constructor of <code>BulkTest</code>;\n  * a subsequent call to {@link TestCase#run} will run that simple test.\n  * <p>\n  * A <I>bulk test method</I>, on the other hand, returns a new instance\n  * of <code>BulkTest</code>, which can itself define new simple and bulk\n- * test methods.  By using the {@link #makeSuite} method, you can \n+ * test methods.  By using the {@link #makeSuite} method, you can\n  * automatically create a hierarchical suite of tests and child bulk tests.\n  * <p>\n  * For instance, consider the following two classes:\n  *  In the above examples, <code>SetTest</code> defines two\n  *  simple test methods and no bulk test methods; <code>HashMapTest</code>\n  *  defines one simple test method and two bulk test methods.  When\n- *  <code>makeSuite(HashMapTest.class).run</code> is executed, \n+ *  <code>makeSuite(HashMapTest.class).run</code> is executed,\n  *  <I>five</I> simple test methods will be run, in this order:<P>\n  *\n  *  <Ol>\n  *\n  *  Note that if you want to use the bulk test methods, you <I>must</I>\n  *  define your <code>suite()</code> method to use {@link #makeSuite}.\n- *  The ordinary {@link TestSuite} constructor doesn't know how to \n+ *  The ordinary {@link TestSuite} constructor doesn't know how to\n  *  interpret bulk test methods.\n  *\n  *  @version $Id$\n public class BulkTest extends TestCase implements Cloneable {\n \n \n-    // Note:  BulkTest is Cloneable to make it easier to construct \n-    // BulkTest instances for simple test methods that are defined in \n+    // Note:  BulkTest is Cloneable to make it easier to construct\n+    // BulkTest instances for simple test methods that are defined in\n     // anonymous inner classes.  Basically we don't have to worry about\n     // finding weird constructors.  (And even if we found them, technically\n-    // it'd be illegal for anyone but the outer class to invoke them).  \n-    // Given one BulkTest instance, we can just clone it and reset the \n-    // method name for every simple test it defines.  \n+    // it'd be illegal for anyone but the outer class to invoke them).\n+    // Given one BulkTest instance, we can just clone it and reset the\n+    // method name for every simple test it defines.\n \n \n     /** Path to test data resources */\n \n     /** List of ignored simple test names. */\n     private List<String> ignored;\n-   \n+\n     /** The TestSuite we're currently populating.  Can change over time. */\n     private TestSuite result;\n \n-    /** \n-     * The prefix for simple test methods.  Used to check if a test is in \n+    /**\n+     * The prefix for simple test methods.  Used to check if a test is in\n      * the ignored list.\n-     */ \n+     */\n     private String prefix;\n \n-    /** \n+    /**\n      * Constructor.\n      *\n      * @param startingClass  the starting class\n-     */     \n+     */\n     public BulkTestSuiteMaker(final Class<? extends BulkTest> startingClass) {\n         this.startingClass = startingClass;\n     }\n         if (ignored.contains(verboseName)) {\n             return;\n         }\n-        \n+\n         BulkTest bulk2;\n         try {\n             bulk2 = (BulkTest)m.invoke(bulk, (Object[]) null);\n--- a/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n         collectionC2 = new LinkedList<Number>(collectionC);\n         iterableA2 = collectionA2;\n         iterableB2 = collectionB2;\n-        \n+\n         collectionD = new ArrayList<Integer>();\n         collectionD.add(1);\n         collectionD.add(3);\n                 return n.longValue() > 3L;\n             }\n         };\n-        \n+\n         final Collection<Number> col = CollectionUtils.subtract(iterableA, collectionC, predicate);\n         final Map<Number, Integer> freq2 = CollectionUtils.getCardinalityMap(col);\n         assertEquals(Integer.valueOf(1), freq2.get(1));\n                 return o.intValue() % 2 == 0 ? Integer.valueOf(0).hashCode() : Integer.valueOf(1).hashCode();\n             }\n         };\n-        \n+\n         assertTrue(CollectionUtils.isEqualCollection(collectionA, collectionA, e));\n         assertTrue(CollectionUtils.isEqualCollection(collectionA, collB, e));\n         assertTrue(CollectionUtils.isEqualCollection(collB, collectionA, e));\n-        \n+\n         final Equator<Number> defaultEquator = DefaultEquator.defaultEquator();\n         assertFalse(CollectionUtils.isEqualCollection(collectionA, collectionB, defaultEquator));\n-        assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));        \n+        assertFalse(CollectionUtils.isEqualCollection(collectionA, collB, defaultEquator));\n     }\n \n     @Test(expected=IllegalArgumentException.class)\n         // null should be OK\n         CollectionUtils.forAllDo(col.iterator(), testClosure);\n     }\n-    \n+\n     @Test(expected = FunctorException.class)\n     public void forAllDoFailure() {\n         final Closure<String> testClosure = ClosureUtils.invokerClosure(\"clear\");\n         List<? extends Number> lastElement = CollectionUtils.forAllButLastDo(col.iterator(), testClosure);\n         assertSame(lastElement, collectionB);\n         assertTrue(collectionA.isEmpty() && !collectionB.isEmpty());\n-        \n+\n         assertNull(CollectionUtils.forAllButLastDo(col.iterator(), null));\n         assertNull(CollectionUtils.forAllButLastDo((Collection<?>) null, null));\n     }\n-    \n+\n     @Test\n     public void getFromMap() {\n         // Unordered map, entries exist\n         assertEquals(3, (int) ints.get(1));\n         assertEquals(3, (int) ints.get(2));\n     }\n-        \n+\n     @Test\n     public void filterInverseNullParameters() throws Exception {\n         final List<Long> longs = Collections.nCopies(4, 10L);\n         final Collection<Object> collection = new ArrayList<Object>();\n         assertSame(collection, CollectionUtils.emptyIfNull(collection));\n     }\n-    \n+\n     /**\n      * This test ensures that {@link Iterable}s are supported by {@link CollectionUtils}.\n      * Specifically, it uses mocks to ensure that if the passed in\n         expect(iterator.hasNext()).andReturn(true);\n         expect(iterator.next()).andReturn(t);\n     }\n-        \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void collateException1() {\n         CollectionUtils.collate(collectionA, null);\n         List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE);\n         List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD);\n         assertEquals(\"Merge two lists 1\", result1, result2);\n-        \n+\n         List<Integer> combinedList = new ArrayList<Integer>();\n         combinedList.addAll(collectionD);\n         combinedList.addAll(collectionE);\n         assertEquals(\"Comparator Merge two lists 1\", result1, result2);\n         assertEquals(\"Comparator Merge two lists 2\", combinedList, result2);\n     }\n-    \n+\n     @Test\n     public void testCollateIgnoreDuplicates() {\n         List<Integer> result1 = CollectionUtils.collate(collectionD, collectionE, false);\n         List<Integer> result2 = CollectionUtils.collate(collectionE, collectionD, false);\n         assertEquals(\"Merge two lists 1 - ignore duplicates\", result1, result2);\n-        \n+\n         Set<Integer> combinedSet = new HashSet<Integer>();\n         combinedSet.addAll(collectionD);\n         combinedSet.addAll(collectionE);\n \n         assertEquals(\"Merge two lists 2 - ignore duplicates\", combinedList, result2);\n     }\n-    \n+\n     @Test(expected=NullPointerException.class)\n     public void testPermutationsWithNullCollection() {\n         CollectionUtils.permutations(null);\n     }\n-    \n+\n     @Test\n     public void testPermutations() {\n         List<Integer> sample = collectionA.subList(0, 5);\n         Collection<List<Integer>> permutations = CollectionUtils.permutations(sample);\n-        \n+\n         // result size = n!\n         int collSize = sample.size();\n         int factorial = 1;\n         }\n         assertEquals(factorial, permutations.size());\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/collections4/EnumerationUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/EnumerationUtilsTest.java\n     }\n \n     public static final String TO_LIST_FIXTURE = \"this is a test\";\n-    \n+\n     public void testToListWithStringTokenizer() {\n         final List<String> expectedList1 = new ArrayList<String>();\n         final StringTokenizer st = new StringTokenizer(TO_LIST_FIXTURE);\n--- a/src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java\n         list.add(Integer.valueOf(1));\n         list.add(Integer.valueOf(2));\n         final Iterator<Integer> iterator = list.iterator();\n-        \n+\n         final Iterable<Integer> iterable = IteratorUtils.asIterable(iterator);\n         int expected = 0;\n         for(final Integer actual : iterable) {\n         // single use iterator\n         assertFalse(\"should not be able to iterate twice\", IteratorUtils.asIterable(iterator).iterator().hasNext());\n     }\n-    \n+\n     public void testAsIterableNull() {\n         try {\n             IteratorUtils.asIterable(null);\n         list.add(Integer.valueOf(1));\n         list.add(Integer.valueOf(2));\n         final Iterator<Integer> iterator = list.iterator();\n-        \n+\n         final Iterable<Integer> iterable = IteratorUtils.asMultipleUseIterable(iterator);\n         int expected = 0;\n         for(final Integer actual : iterable) {\n             // success\n         }\n     }\n-    \n+\n     public void testToList() {\n         final List<Object> list = new ArrayList<Object>();\n         list.add(Integer.valueOf(1));\n     public void testNodeListIterator() {\n         final Node[] nodes = createNodes();\n         final NodeList nodeList = createNodeList(nodes);\n-        \n+\n         final Iterator<Node> iterator = IteratorUtils.nodeListIterator(nodeList);\n         int expectedNodeIndex = 0;\n         for (final Node actual : IteratorUtils.asIterable(iterator)) {\n         final Node parentNode = createMock(Node.class);\n         expect(parentNode.getChildNodes()).andStubReturn(nodeList);\n         replay(parentNode);\n-        \n+\n         final Iterator<Node> iterator = IteratorUtils.nodeListIterator(parentNode);\n         int expectedNodeIndex = 0;\n         for (final Node actual : IteratorUtils.asIterable(iterator)) {\n         // single use iterator\n         assertFalse(\"should not be able to iterate twice\", IteratorUtils.asIterable(iterator).iterator().hasNext());\n     }\n-    \n+\n     /**\n      * creates an array of four Node instances, mocked by EasyMock.\n-     * @return \n+     * @return\n      */\n     private Node[] createNodes() {\n         final Node node1 = createMock(Node.class);\n--- a/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/ListUtilsTest.java\n \n     public void testEmptyIfNull() {\n         assertTrue(ListUtils.emptyIfNull(null).isEmpty());\n-        \n+\n         final List<Long> list = new ArrayList<Long>();\n         assertSame(list, ListUtils.emptyIfNull(list));\n     }\n \n     public void testDefaultIfNull() {\n         assertTrue(ListUtils.defaultIfNull(null, Collections.emptyList()).isEmpty());\n-        \n+\n         final List<Long> list = new ArrayList<Long>();\n         assertSame(list, ListUtils.defaultIfNull(list, Collections.<Long>emptyList()));\n     }\n \n         final List<String> result = ListUtils.subtract(list, sub);\n         assertTrue(result.size() == 3);\n-        \n+\n         final List<String> expected = new ArrayList<String>();\n         expected.add(b);\n         expected.add(a);\n         expected.add(x);\n \n         assertEquals(expected, result);\n-        \n+\n         try {\n             ListUtils.subtract(list, null);\n             fail(\"expecting NullPointerException\");\n \n         final List<String> result = ListUtils.subtract(list, sub);\n         assertTrue(result.size() == 3);\n-        \n+\n         final List<String> expected = new ArrayList<String>();\n         expected.add(a);\n         expected.add(null);\n         testPredicate = EqualPredicate.equalPredicate(\"de\");\n         index = ListUtils.indexOf(fullList, testPredicate);\n         assertEquals(index, -1);\n-        \n+\n         assertEquals(ListUtils.indexOf(null,testPredicate), -1);\n         assertEquals(ListUtils.indexOf(fullList, null), -1);\n     }\n-    \n+\n     public void testLongestCommonSubsequence() {\n-        \n+\n         try {\n             ListUtils.longestCommonSubsequence((List<?>) null, null);\n             fail(\"failed to check for null argument\");\n         List<Character> list1 = Arrays.asList('B', 'A', 'N', 'A', 'N', 'A');\n         List<Character> list2 = Arrays.asList('A', 'N', 'A', 'N', 'A', 'S');\n         lcs = ListUtils.longestCommonSubsequence(list1, list2);\n-        \n+\n         List<Character> expected = Arrays.asList('A', 'N', 'A', 'N', 'A');\n         assertEquals(expected, lcs);\n \n         List<Character> list3 = Arrays.asList('A', 'T', 'A', 'N', 'A');\n         lcs = ListUtils.longestCommonSubsequence(list1, list3);\n-        \n+\n         expected = Arrays.asList('A', 'A', 'N', 'A');\n         assertEquals(expected, lcs);\n \n         List<Character> listZorro = Arrays.asList('Z', 'O', 'R', 'R', 'O');\n         lcs = ListUtils.longestCommonSubsequence(list1, listZorro);\n-        \n+\n         assertTrue(lcs.isEmpty());\n     }\n \n     public void testLongestCommonSubsequenceWithString() {\n-      \n+\n       try {\n           ListUtils.longestCommonSubsequence((String) null, null);\n           fail(\"failed to check for null argument\");\n       String banana = \"BANANA\";\n       String ananas = \"ANANAS\";\n       lcs = ListUtils.longestCommonSubsequence(banana, ananas);\n-      \n+\n       assertEquals(\"ANANA\", lcs);\n \n       String atana = \"ATANA\";\n       lcs = ListUtils.longestCommonSubsequence(banana, atana);\n-      \n+\n       assertEquals(\"AANA\", lcs);\n \n       String zorro = \"ZORRO\";\n       lcs = ListUtils.longestCommonSubsequence(banana, zorro);\n-      \n+\n       assertEquals(0, lcs.length());\n   }\n \n         for (int i = 0; i <= 6; i++) {\n             strings.add(i);\n         }\n-        \n+\n         final List<List<Integer>> partition = ListUtils.partition(strings, 3);\n \n         assertNotNull(partition);\n         assertEquals(3, partition.size());\n         assertEquals(1, partition.get(2).size());\n-        \n+\n         try {\n             ListUtils.partition(null, 3);\n             fail(\"failed to check for null argument\");\n         } catch (final IllegalArgumentException e) {}\n-        \n+\n         try {\n             ListUtils.partition(strings, 0);\n             fail(\"failed to check for size argument\");\n         } catch (final IllegalArgumentException e) {}\n-        \n+\n         try {\n             ListUtils.partition(strings, -10);\n             fail(\"failed to check for size argument\");\n         } catch (final IllegalArgumentException e) {}\n-        \n-    }\n-    \n+\n+    }\n+\n     private static Predicate<Number> EQUALS_TWO = new Predicate<Number>() {\n         public boolean evaluate(final Number input) {\n             return input.intValue() == 2;\n--- a/src/test/java/org/apache/commons/collections4/MapPerformance.java\n+++ b/src/test/java/org/apache/commons/collections4/MapPerformance.java\n \n import org.apache.commons.collections4.map.Flat3Map;\n \n-/** \n+/**\n  * <code>MapPerformanceTest</code> is designed to perform basic Map performance tests.\n- * \n+ *\n  * @version $Id$\n  */\n public class MapPerformance {\n \n-    /** The total number of runs for each test */    \n+    /** The total number of runs for each test */\n     private static final int RUNS = 20000000;\n-    \n+\n     /**\n      * Main method\n      */\n     public static void main(final String[] args) {\n         testAll();\n     }\n-    \n+\n     private static void testAll() {\n         final Map<String, String> dummyMap = new DummyMap<String, String>();\n         final Map<String, String> hashMap = new HashMap<String, String>();\n //        Map bucketMap = new StaticBucketMap();\n //        bucketMap.putAll(hashMap);\n //        Map doubleMap = new DoubleOrderedMap(hashMap);\n-        \n+\n         // dummy is required as the VM seems to hotspot the first call to the\n         // test method with the given type\n         test(dummyMap,      \"         Dummy \");\n         test(dummyMap,      \"         Dummy \");\n         test(flatMap,       \"         Flat3 \");\n         test(hashMap,       \"       HashMap \");\n-        \n+\n         test(flatMap,       \"         Flat3 \");\n         test(flatMap,       \"         Flat3 \");\n         test(flatMap,       \"         Flat3 \");\n-        \n+\n         test(hashMap,       \"       HashMap \");\n         test(hashMap,       \"       HashMap \");\n         test(hashMap,       \"       HashMap \");\n-        \n+\n //        test(treeMap,       \"       TreeMap \");\n //        test(treeMap,       \"       TreeMap \");\n //        test(treeMap,       \"       TreeMap \");\n-        \n+\n //        test(unmodHashMap,  \"Unmod(HashMap) \");\n //        test(unmodHashMap,  \"Unmod(HashMap) \");\n //        test(unmodHashMap,  \"Unmod(HashMap) \");\n-//        \n+//\n //        test(syncMap,       \" Sync(HashMap) \");\n //        test(syncMap,       \" Sync(HashMap) \");\n //        test(syncMap,       \" Sync(HashMap) \");\n-//        \n+//\n //        test(fastHashMap,   \"   FastHashMap \");\n //        test(fastHashMap,   \"   FastHashMap \");\n //        test(fastHashMap,   \"   FastHashMap \");\n-//        \n+//\n //        test(seqMap,        \"    SeqHashMap \");\n //        test(seqMap,        \"    SeqHashMap \");\n //        test(seqMap,        \"    SeqHashMap \");\n-//        \n+//\n //        test(linkedMap,     \" LinkedHashMap \");\n //        test(linkedMap,     \" LinkedHashMap \");\n //        test(linkedMap,     \" LinkedHashMap \");\n-//        \n+//\n //        test(bucketMap,     \"     BucketMap \");\n //        test(bucketMap,     \"     BucketMap \");\n //        test(bucketMap,     \"     BucketMap \");\n-//        \n+//\n //        test(doubleMap,     \"     DoubleMap \");\n //        test(doubleMap,     \"     DoubleMap \");\n //        test(doubleMap,     \"     DoubleMap \");\n             return null;\n         }\n     }\n-    \n+\n }\n \n--- a/src/test/java/org/apache/commons/collections4/MapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/MapUtilsTest.java\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     public void testEmptyIfNull() {\n         assertTrue(MapUtils.emptyIfNull(null).isEmpty());\n-        \n+\n         final Map<Long, Long> map = new HashMap<Long, Long>();\n         assertSame(map, MapUtils.emptyIfNull(map));\n     }\n-    \n+\n     public void testIsEmptyWithEmptyMap() {\n         final Map<Object, Object> map = new HashMap<Object, Object>();\n         assertEquals(true, MapUtils.isEmpty(map));\n     }\n \n     /**\n-     * Test class for populateMap(MultiMap). \n+     * Test class for populateMap(MultiMap).\n      */\n     public static class X implements Comparable<X> {\n         int key;\n         public int compareTo(X o) {\n             return key - o.key;\n         }\n-        \n+\n     }\n \n     public void testPopulateMultiMap() {\n         final List<X> list = new ArrayList<X>();\n         list.add(new X(1, \"x1\"));\n         list.add(new X(2, \"x2\"));\n-        list.add(new X(2, \"x3\"));        \n+        list.add(new X(2, \"x3\"));\n         list.add(new X(5, \"x4\"));\n         list.add(new X(5, \"x5\"));\n \n--- a/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/SetUtilsTest.java\n \n     public void testEmptyIfNull() {\n         assertTrue(SetUtils.emptyIfNull(null).isEmpty());\n-        \n+\n         final Set<Long> set = new HashSet<Long>();\n         assertSame(set, SetUtils.emptyIfNull(set));\n     }\n-    \n+\n     public void testEquals() {\n         final Collection<String> data = Arrays.asList( new String[] { \"a\", \"b\", \"c\" });\n \n--- a/src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractBagTest(final String testName) {\n     //-----------------------------------------------------------------------\n     /**\n      * Return a new, empty bag to used for testing.\n-     * \n+     *\n      * @return the bag to be tested\n      */\n     @Override\n         assertEquals(\"Should have count of 1\", 1, bag.getCount(\"C\"));\n         assertEquals(\"Should have count of 2\", 2, bag.size());\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testContains() {\n         final Bag<T> bag = makeObject();\n-        \n+\n         assertEquals(\"Bag does not have at least 1 'A'\", false, bag.contains(\"A\"));\n         assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n-        \n+\n         bag.add((T) \"A\");  // bag 1A\n         assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n         assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n-        \n+\n         bag.add((T) \"A\");  // bag 2A\n         assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n         assertEquals(\"Bag does not have at least 1 'B'\", false, bag.contains(\"B\"));\n-        \n+\n         bag.add((T) \"B\");  // bag 2A,1B\n         assertEquals(\"Bag has at least 1 'A'\", true, bag.contains(\"A\"));\n         assertEquals(\"Bag has at least 1 'B'\", true, bag.contains(\"B\"));\n         final List<String> known1A1B = new ArrayList<String>();\n         known1A1B.add(\"A\");\n         known1A1B.add(\"B\");\n-        \n+\n         assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n         assertEquals(\"Bag does not containsAll of 1 'A'\", false, bag.containsAll(known1A));\n         assertEquals(\"Bag does not containsAll of 2 'A'\", false, bag.containsAll(known2A));\n         assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n         assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n-        \n+\n         bag.add((T) \"A\");  // bag 1A\n         assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n         assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n         assertEquals(\"Bag does not containsAll of 2 'A'\", false, bag.containsAll(known2A));\n         assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n         assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n-        \n+\n         bag.add((T) \"A\");  // bag 2A\n         assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n         assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n         assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n         assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n         assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n-        \n+\n         bag.add((T) \"A\");  // bag 3A\n         assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n         assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n         assertEquals(\"Bag containsAll of 2 'A'\", true, bag.containsAll(known2A));\n         assertEquals(\"Bag does not containsAll of 1 'B'\", false, bag.containsAll(known1B));\n         assertEquals(\"Bag does not containsAll of 1 'A' 1 'B'\", false, bag.containsAll(known1A1B));\n-        \n+\n         bag.add((T) \"B\");  // bag 3A1B\n         assertEquals(\"Bag containsAll of empty\", true, bag.containsAll(known));\n         assertEquals(\"Bag containsAll of 1 'A'\", true, bag.containsAll(known1A));\n         bag.remove(\"B\");\n         assertEquals(\"Should have 1 total item\", 1, bag.size());\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testRetainAll() {\n         final Bag<T> bag = makeObject();\n         bag.add((T) \"B\");\n         assertEquals(\"Bag should have 3 items\", 3, bag.size());\n         final Iterator<T> i = bag.iterator();\n-    \n+\n         boolean foundA = false;\n         while (i.hasNext()) {\n             final String element = (String) i.next();\n                 }\n             }\n         }\n-    \n+\n         assertTrue(\"Bag should still contain 'A'\", bag.contains(\"A\"));\n         assertEquals(\"Bag should have 2 items\", 2, bag.size());\n         assertEquals(\"Bag should have 1 'A'\", 1, bag.getCount(\"A\"));\n             // expected\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorFailNoMore() {\n         final Bag<T> bag = makeObject();\n             // expected\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorFailDoubleRemove() {\n         final Bag<T> bag = makeObject();\n         it.remove();\n         assertEquals(1, bag.size());\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testIteratorRemoveProtectsInvariants() {\n         final Bag<T> bag = makeObject();\n         it.remove();\n         assertEquals(0, bag.size());\n         assertEquals(false, it.hasNext());\n-        \n+\n         final Iterator<T> it2 = bag.iterator();\n         assertEquals(false, it2.hasNext());\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testToArray() {\n         final Bag<T> bag = makeObject();\n         bag2.add((T) \"B\");\n         bag2.add((T) \"C\");\n         assertEquals(bag.hashCode(), bag2.hashCode());\n-        \n+\n         int total = 0;\n         total += \"A\".hashCode() ^ 2;\n         total += \"B\".hashCode() ^ 2;\n         if (!(bag instanceof Serializable && isTestSerialization())) {\n             return;\n         }\n-        \n+\n         final byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n         final Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n \n         if (!(bag instanceof Serializable && isTestSerialization())) {\n             return;\n         }\n-        \n+\n         final byte[] objekt = writeExternalFormToBytes((Serializable) bag);\n         final Bag<?> bag2 = (Bag<?>) readExternalFormFromBytes(objekt);\n \n--- a/src/test/java/org/apache/commons/collections4/bag/HashBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/HashBagTest.java\n  * @version $Id$\n  */\n public class HashBagTest<T> extends AbstractBagTest<T> {\n-    \n+\n     public HashBagTest(final String testName) {\n         super(testName);\n     }\n     public Bag<T> makeObject() {\n         return new HashBag<T>();\n     }\n-    \n+\n     @Override\n     public String getCompatibilityVersion() {\n         return \"4\";\n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        Bag bag = makeObject();\n //        writeExternalFormToDisk((java.io.Serializable) bag, \"src/test/resources/data/test/HashBag.emptyCollection.version4.obj\");\n--- a/src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/TransformedBagTest.java\n             assertEquals(true, bag.contains(Integer.valueOf((String) el)));\n             assertEquals(false, bag.contains(el));\n         }\n-        \n+\n         assertEquals(false, bag.remove(els[0]));\n         assertEquals(true, bag.remove(Integer.valueOf((String) els[0])));\n     }\n--- a/src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/TransformedSortedBagTest.java\n         for (final Object el : els) {\n             assertEquals(true, bag.contains(Integer.valueOf((String) el)));\n         }\n-        \n+\n         assertEquals(true, bag.remove(Integer.valueOf((String) els[0])));\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bag/TreeBagTest.java\n             // expected;\n         }\n     }\n-    \n+\n     public void testOrdering() {\n         final Bag<T> bag = setupBag();\n         assertEquals(\"Should get elements in correct order\", \"A\", bag.toArray()[0]);\n--- a/src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualHashBidiMapTest.java\n     public String[] ignoredTests() {\n         return new String[] { \"DualHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualHashBidiMap.emptyCollection.version4.obj\");\n--- a/src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualLinkedHashBidiMapTest.java\n     public String[] ignoredTests() {\n         return new String[] { \"DualLinkedHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n     }\n-    \n+\n //    public void testCreate() throws Exception {\n //        resetEmpty();\n //        writeExternalFormToDisk((java.io.Serializable) map, \"src/test/resources/data/test/DualLinkedHashBidiMap.emptyCollection.version4.obj\");\n--- a/src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMap2Test.java\n         dtbm.put(\"one\", 1);\n         assertEquals(\"one\", dtbm.firstKey());\n         assertEquals(\"two\", dtbm.lastKey());\n-        \n+\n     }\n \n     public void testSerializeDeserializeCheckComparator() throws Exception {\n         // there are several bugs in the following JVM:\n         // IBM J9 VM build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067\n         // thus disabling tests related to these bugs\n-        \n+\n         final String vmName = System.getProperty(\"java.vm.name\");\n         final String version = System.getProperty(\"java.version\");\n-        \n+\n         if (vmName == null || version == null) {\n             return new String[] { recursiveTest };\n         }\n--- a/src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/DualTreeBidiMapTest.java\n         // there are several bugs in the following JVM:\n         // IBM J9 VM build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067\n         // thus disabling tests related to these bugs\n-        \n+\n         final String vmName = System.getProperty(\"java.vm.name\");\n         final String version = System.getProperty(\"java.version\");\n-        \n+\n         if (vmName == null || version == null) {\n             return new String[] { recursiveTest };\n         }\n--- a/src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/bidimap/TreeBidiMapTest.java\n     public BidiMap<K, V> makeObject() {\n         return new TreeBidiMap<K, V>();\n     }\n-    \n+\n     @Override\n     public TreeMap<K, V> makeConfirmedMap() {\n         return new TreeMap<K, V>();\n     public String[] ignoredTests() {\n         return new String[] {\"TreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n     }\n-    \n+\n     @Override\n     public boolean isAllowNullKey() {\n         return false;\n     }\n-    \n+\n     @Override\n     public boolean isAllowNullValue() {\n         return false;\n     }\n-    \n+\n     @Override\n     public boolean isSetValueSupported() {\n         return false;\n     }\n-    \n+\n     @Override\n     public String getCompatibilityVersion() {\n         return \"4\";\n--- a/src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/CompositeCollectionTest.java\n     protected void setUpMutatorTest() {\n         setUpTest();\n         c.setMutator(new CompositeCollection.CollectionMutator<E>() {\n-            \n+\n             public boolean add(final CompositeCollection<E> composite, final List<Collection<E>> collections, final E obj) {\n                 for (final Collection<E> coll : collections) {\n                     coll.add(obj);\n--- a/src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/IndexedCollectionTest.java\n import org.apache.commons.collections4.collection.IndexedCollection;\n \n /**\n- * Extension of {@link AbstractCollectionTest} for exercising the \n+ * Extension of {@link AbstractCollectionTest} for exercising the\n  * {@link IndexedCollection} implementation.\n  *\n  * @since 4.0\n             return Integer.valueOf(input);\n         }\n     }\n-    \n+\n     @Override\n     public Collection<String> makeObject() {\n         return decorateCollection(new ArrayList<String>());\n     public Collection<String> makeUniqueTestCollection() {\n         return decorateUniqueCollection(new ArrayList<String>());\n     }\n-    \n+\n     @Override\n     protected boolean skipSerializedCanonicalTests() {\n         // FIXME: support canonical tests\n         coll.add(\"16\");\n         coll.add(\"1\");\n         coll.addAll(asList(\"2\",\"3\",\"4\"));\n-        \n+\n         @SuppressWarnings(\"unchecked\")\n         final IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;\n         assertEquals(\"12\", indexed.get(12));\n         assertEquals(\"3\", indexed.get(3));\n         assertEquals(\"4\", indexed.get(4));\n     }\n-    \n+\n     public void testEnsureDuplicateObjectsCauseException() throws Exception {\n         final Collection<String> coll = makeUniqueTestCollection();\n \n             // expected\n         }\n     }\n-    \n+\n     public void testDecoratedCollectionIsIndexedOnCreation() throws Exception {\n         final Collection<String> original = makeFullCollection();\n         final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n-        \n+\n         assertEquals(\"1\", indexed.get(1));\n         assertEquals(\"2\", indexed.get(2));\n         assertEquals(\"3\", indexed.get(3));\n     }\n-    \n+\n     public void testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately() throws Exception {\n         final Collection<String> original = new ArrayList<String>();\n         final IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n-        \n+\n         original.add(\"1\");\n         original.add(\"2\");\n         original.add(\"3\");\n--- a/src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections4/collection/TransformedCollectionTest.java\n  * @version $Id$\n  */\n public class TransformedCollectionTest extends AbstractCollectionTest<Object> {\n-    \n+\n     private static class StringToInteger implements Transformer<Object, Object> {\n         public Object transform(final Object input) {\n             return Integer.valueOf((String) input);\n         }\n     }\n-    \n+\n     public static final Transformer<Object, Object> NOOP_TRANSFORMER = TransformerUtils.nopTransformer();\n     public static final Transformer<Object, Object> STRING_TO_INTEGER_TRANSFORMER = new StringToInteger();\n \n         list.addAll(Arrays.asList(getFullElements()));\n         return list;\n     }\n-    \n+\n     @Override\n     public Collection<Object> makeObject() {\n         return TransformedCollection.transformingCollection(new ArrayList<Object>(), NOOP_TRANSFORMER);\n         list.addAll(Arrays.asList(getFullElements()));\n         return TransformedCollection.transformingCollection(list, NOOP_TRANSFORMER);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     @Override\n     public Object[] getFullElements() {\n             assertEquals(true, coll.contains(Integer.valueOf((String) els[i])));\n             assertEquals(false, coll.contains(els[i]));\n         }\n-        \n+\n         assertEquals(true, coll.remove(Integer.valueOf((String) els[0])));\n     }\n \n             assertEquals(true, collection.contains(Integer.valueOf((String) el)));\n             assertEquals(false, collection.contains(el));\n         }\n-        \n+\n         assertEquals(false, collection.remove(els[0]));\n         assertEquals(true, collection.remove(Integer.valueOf((String) els[0])));\n     }\n--- a/src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractComparatorTest(final String testName) {\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     /**\n      * Implement this method to return a list of sorted objects.\n-     * \n+     *\n      * @return sorted objects\n      */\n     public abstract List<T> getComparableObjectsOrdered();\n     //-----------------------------------------------------------------------\n     /**\n      * Implements the abstract superclass method to return the comparator.\n-     * \n+     *\n      * @return a full iterator\n      */\n     @Override\n \n         final List<T> orderedList = getComparableObjectsOrdered();\n \n-        /* debug \n+        /* debug\n         Iterator i = randomList.iterator();\n         while (i.hasNext()) {\n             System.out.println(i.next());\n     public void testComparatorCompatibility() throws IOException, ClassNotFoundException {\n         if (!skipSerializedCanonicalTests()) {\n             Comparator<T> comparator = null;\n-    \n+\n             // test to make sure the canonical form has been preserved\n             try {\n                 comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n             } catch (final FileNotFoundException exception) {\n-    \n+\n                 final boolean autoCreateSerialized = false;\n-    \n+\n                 if (autoCreateSerialized) {\n                     comparator = makeObject();\n                     final String fileName = getCanonicalComparatorName(comparator);\n                             + \"compatibility: \" + exception.getMessage());\n                 }\n             }\n-    \n-            \n+\n+\n             // make sure the canonical form produces the ordering we currently\n             // expect\n             final List<T> randomList = getComparableObjectsOrdered();\n             reverseObjects(randomList);\n             sortObjects(randomList, comparator);\n-    \n+\n             final List<T> orderedList = getComparableObjectsOrdered();\n-    \n+\n             assertTrue(\"Comparator did not reorder the List correctly\",\n                        orderedList.equals(randomList));\n         }\n--- a/src/test/java/org/apache/commons/collections4/comparators/AbstractNullComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/AbstractNullComparatorTest.java\n         public String getCanonicalComparatorName(final Object object) {\n             return super.getCanonicalComparatorName(object) + \"1\";\n         }\n-        \n+\n         @Override\n         public String getCompatibilityVersion() {\n             return \"4\";\n //        public void testCreate() throws Exception {\n //            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj1\");\n //        }\n-        \n+\n     }\n \n     /**\n         public String getCanonicalComparatorName(final Object object) {\n             return super.getCanonicalComparatorName(object) + \"2\";\n         }\n-        \n+\n         @Override\n         public String getCompatibilityVersion() {\n             return \"4\";\n //        public void testCreate() throws Exception {\n //            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj2\");\n //        }\n-        \n+\n     }\n }\n--- a/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ComparatorChainTest.java\n //    public void testCreate() throws Exception {\n //        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ComparatorChain.version4.obj\");\n //    }\n-    \n+\n     @Test\n     public void testNoopComparatorChain() {\n         final ComparatorChain<Integer> chain = new ComparatorChain<Integer>();\n--- a/src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/FixedOrderComparatorTest.java\n //    public void testCreate() throws Exception {\n //        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/FixedOrderComparator.version4.obj\");\n //    }\n-    \n+\n     //\n     // The tests\n     //\n--- a/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/comparators/ReverseComparatorTest.java\n //    public void testCreate() throws Exception {\n //        writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/ReverseComparator.version4.obj\");\n //    }\n-    \n+\n     @Override\n     public List<Integer> getComparableObjectsOrdered() {\n         final List<Integer> list = new LinkedList<Integer>();\n--- a/src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java\n      * Mock predicates created by a single test case which need to be verified after the test completes.\n      */\n     private List<Predicate<? super T>> mockPredicatesToVerify;\n-    \n+\n     /**\n      * The value to pass to mocks.\n      */\n--- a/src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java\n         cString = \"Hello\";\n         cInteger = Integer.valueOf(6);\n     }\n-    \n+\n     @Test\n     public void predicateSanityTests() throws Exception {\n         final Predicate<?> predicate = generatePredicate();\n--- a/src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/AllPredicateTest.java\n \n     /**\n      * {@inheritDoc}\n-     */    \n+     */\n     @Override\n     protected final Predicate<Integer> getPredicateInstance(final Collection<Predicate<Integer>> predicates) {\n         return AllPredicate.allPredicate(predicates);\n         // use the constructor directly, as getInstance() returns the original predicate when passed\n         // an array of size one.\n         final Predicate<Integer> predicate = createMockPredicate(true);\n-        \n+\n         assertTrue(\"single true predicate evaluated to false\",\n                 allPredicate(predicate).evaluate(getTestValue()));\n     }\n--- a/src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/CatchAndRethrowClosureTest.java\n     protected <T> Closure<T> generateClosure() {\n         return generateNoExceptionClosure();\n     }\n-    \n+\n     @Test\n     public void testThrowingClosure() {\n         Closure<Integer> closure = generateNoExceptionClosure();\n         } catch (final RuntimeException ex) {\n             Assert.fail();\n         }\n-        \n+\n         closure = generateIOExceptionClosure();\n         try {\n             closure.execute(Integer.valueOf(0));\n--- a/src/test/java/org/apache/commons/collections4/functors/ComparatorPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/ComparatorPredicateTest.java\n         assertTrue(p, Integer.valueOf(value.intValue()));\n         assertTrue(p, Integer.valueOf(value.intValue() + 1));\n     }\n-    \n+\n     @Override\n     protected Predicate<?> generatePredicate() {\n         return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());\n-    }    \n+    }\n }\n--- a/src/test/java/org/apache/commons/collections4/functors/EqualPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/EqualPredicateTest.java\n     protected Predicate<Object> generatePredicate() {\n        return equalPredicate(null);\n     }\n-    \n+\n     @Test\n     public void testNullArgumentEqualsNullPredicate() throws Exception {\n         assertSame(nullPredicate(), equalPredicate(null));\n     }\n-    \n+\n     @Test\n     public void objectFactoryUsesEqualsForTest() throws Exception {\n         final Predicate<EqualsTestObject> predicate = equalPredicate(FALSE_OBJECT);\n         assertFalse(predicate, FALSE_OBJECT);\n         assertTrue(equalPredicate(TRUE_OBJECT), TRUE_OBJECT);\n     }\n-    \n+\n     @SuppressWarnings(\"boxing\")\n     @Test\n     public void testPredicateTypeCanBeSuperClassOfObject() throws Exception {\n         public EqualsTestObject(final boolean b) {\n             this.b = b;\n         }\n-        \n+\n         @Override\n         public boolean equals(final Object obj) {\n             return b;\n--- a/src/test/java/org/apache/commons/collections4/functors/NullPredicateTest.java\n+++ b/src/test/java/org/apache/commons/collections4/functors/NullPredicateTest.java\n         assertSame(NullPredicate.nullPredicate(), NullPredicate.nullPredicate());\n         assertTrue(nullPredicate(), null);\n     }\n-    \n+\n     public void ensurePredicateCanBeTypedWithoutWarning() throws Exception {\n         final Predicate<String> predicate = NullPredicate.nullPredicate();\n         assertFalse(predicate, cString);\n     @Override\n     protected Predicate<?> generatePredicate() {\n         return nullPredicate();\n-    }    \n+    }\n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test class name\n      */\n     public AbstractIteratorTest(final String testName) {\n     //-----------------------------------------------------------------------\n     /**\n      * Implement this method to return an iterator over an empty collection.\n-     * \n+     *\n      * @return an empty iterator\n      */\n     public abstract Iterator<E> makeEmptyIterator();\n \n     /**\n      * Implements the abstract superclass method to return the full iterator.\n-     * \n+     *\n      * @return a full iterator\n      */\n     @Override\n     /**\n      * Whether or not we are testing an iterator that can be empty.\n      * Default is true.\n-     * \n+     *\n      * @return true if Iterator can be empty\n      */\n     public boolean supportsEmptyIterator() {\n     /**\n      * Whether or not we are testing an iterator that can contain elements.\n      * Default is true.\n-     * \n+     *\n      * @return true if Iterator can be full\n      */\n     public boolean supportsFullIterator() {\n     /**\n      * Whether or not we are testing an iterator that supports remove().\n      * Default is true.\n-     * \n+     *\n      * @return true if Iterator supports remove\n      */\n     public boolean supportsRemove() {\n         }\n \n         final Iterator<E> it = makeEmptyIterator();\n-        \n+\n         // hasNext() should return false\n         assertEquals(\"hasNext() should return false for empty iterators\", false, it.hasNext());\n-        \n+\n         // next() should throw a NoSuchElementException\n         try {\n             it.next();\n         } catch (final NoSuchElementException e) {\n         }\n         verify();\n-        \n+\n         assertNotNull(it.toString());\n     }\n \n             fail(\"NoSuchElementException must be thrown when Iterator is exhausted\");\n         } catch (final NoSuchElementException e) {\n         }\n-        \n+\n         assertNotNull(it.toString());\n     }\n \n      */\n     public void testRemove() {\n         final Iterator<E> it = makeObject();\n-        \n+\n         if (supportsRemove() == false) {\n             // check for UnsupportedOperationException if not supported\n             try {\n             } catch (final UnsupportedOperationException ex) {}\n             return;\n         }\n-        \n+\n         // should throw IllegalStateException before next() called\n         try {\n             it.remove();\n             fail();\n         } catch (final IllegalStateException ex) {}\n         verify();\n-        \n+\n         // remove after next should be fine\n         it.next();\n         it.remove();\n-        \n+\n         // should throw IllegalStateException for second remove()\n         try {\n             it.remove();\n             fail();\n         } catch (final IllegalStateException ex) {}\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/ArrayIteratorTest.java\n             // expected\n         }\n     }\n-    \n+\n     public void testReset() {\n         final ArrayIterator<E> it = makeObject();\n         it.next();\n--- a/src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/FilterListIteratorTest.java\n         }\n \n         truePred = new Predicate<Integer>() {\n-            public boolean evaluate(final Integer x) { \n+            public boolean evaluate(final Integer x) {\n                 return true;\n             }\n         };\n \n         falsePred = new Predicate<Integer>() {\n-            public boolean evaluate(final Integer x) { \n+            public boolean evaluate(final Integer x) {\n                 return true;\n             }\n         };\n \n         evenPred = new Predicate<Integer>() {\n-            public boolean evaluate(final Integer x) { \n+            public boolean evaluate(final Integer x) {\n                 return x % 2 == 0;\n             }\n         };\n \n         oddPred = new Predicate<Integer>() {\n-            public boolean evaluate(final Integer x) { \n+            public boolean evaluate(final Integer x) {\n                 return x % 2 != 0; //works for all numbers, not just >= 0 as is the case for \"x % 2 == 1\"\n             }\n         };\n \n         threePred = new Predicate<Integer>() {\n-            public boolean evaluate(final Integer x) { \n+            public boolean evaluate(final Integer x) {\n                 return x % 3 == 0;\n             }\n         };\n \n         fourPred = new Predicate<Integer>() {\n-            public boolean evaluate(final Integer x) { \n+            public boolean evaluate(final Integer x) {\n                 return x % 4 == 0;\n             }\n         };\n     public void testManual() {\n         // do this one \"by hand\" as a sanity check\n         final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n-        \n+\n         assertEquals(Integer.valueOf(0), filtered.next());\n         assertEquals(Integer.valueOf(3), filtered.next());\n         assertEquals(Integer.valueOf(6), filtered.next());\n         assertEquals(Integer.valueOf(6), filtered.previous());\n         assertEquals(Integer.valueOf(3), filtered.previous());\n         assertEquals(Integer.valueOf(0), filtered.previous());\n-    \n+\n         assertTrue(!filtered.hasPrevious());\n \n         assertEquals(Integer.valueOf(0), filtered.next());\n         final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n         walkLists(list, filtered);\n     }\n-    \n+\n     public void testFalsePredicate() {\n         final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), falsePred);\n         walkLists(new ArrayList<Integer>(), filtered);\n         final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), evenPred);\n         walkLists(evens, filtered);\n     }\n-    \n+\n     public void testOdds() {\n         final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), oddPred);\n         walkLists(odds, filtered);\n         walkLists(sixes, filtered);\n     }\n \n-    public void testNestedSixes3() {        \n+    public void testNestedSixes3() {\n         final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(\n                                         new FilterListIterator<Integer>(list.listIterator(), threePred),\n                                         evenPred\n             final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), threePred);\n             nextNextPrevious(threes.listIterator(), filtered);\n         }\n-    \n+\n         {\n             final FilterListIterator<Integer> filtered = new FilterListIterator<Integer>(list.listIterator(), truePred);\n             nextNextPrevious(list.listIterator(), filtered);\n--- a/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/IteratorChainTest.java\n         list2.add(\"Four\");\n         list3 = new ArrayList<String>();\n         list3.add(\"Five\");\n-        list3.add(\"Six\");        \n+        list3.add(\"Six\");\n     }\n \n     @Override\n         try {\n             iter.next();\n         } catch (final Exception e) {\n-            assertTrue(\"NoSuchElementException must be thrown\", \n+            assertTrue(\"NoSuchElementException must be thrown\",\n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n     }\n         assertEquals(0, list1.size());\n         assertEquals(1, list2.size());\n     }\n-    \n+\n     @Override\n     public void testRemove() {\n         final Iterator<String> iter = makeObject();\n         assertEquals(\"C\",chain.next());\n         assertTrue(\"should not have next\",!chain.hasNext());\n     }\n-    \n+\n     public void testEmptyChain() {\n         final IteratorChain<Object> chain = new IteratorChain<Object>();\n         assertEquals(false, chain.hasNext());\n             fail();\n         } catch (final IllegalStateException ex) {}\n     }\n-        \n+\n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/IteratorIterableTest.java\n \n /**\n  * Tests for IteratorIterable.\n- * \n+ *\n  * @version $Id$\n  */\n public class IteratorIterableTest extends BulkTest {\n     public void testIterator() {\n         final Iterator<Integer> iter = createIterator();\n         final Iterable<Number> iterable = new IteratorIterable<Number>(iter);\n-        \n+\n         // first use\n         verifyIteration(iterable);\n-        \n+\n         // second use\n         for (@SuppressWarnings(\"unused\") final Number actual : iterable) {\n             fail(\"should not be able to iterate twice\");\n         final Iterator<Integer> iter = createIterator();\n \n         final Iterable<Number> iterable = new IteratorIterable<Number>(iter, true);\n-        \n+\n         // first use\n         verifyIteration(iterable);\n-        \n+\n         // second use\n         verifyIteration(iterable);\n     }\n--- a/src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/LazyIteratorChainTest.java\n         list2.add(\"Four\");\n         list3 = new ArrayList<String>();\n         list3.add(\"Five\");\n-        list3.add(\"Six\");        \n+        list3.add(\"Six\");\n     }\n \n     @Override\n         try {\n             iter.next();\n         } catch (final Exception e) {\n-            assertTrue(\"NoSuchElementException must be thrown\", \n+            assertTrue(\"NoSuchElementException must be thrown\",\n                        e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n     }\n         assertEquals(0, list1.size());\n         assertEquals(1, list2.size());\n     }\n-    \n+\n     @Override\n     public void testRemove() {\n         final Iterator<String> iter = makeObject();\n         assertEquals(\"C\",chain.next());\n         assertTrue(\"should not have next\",!chain.hasNext());\n     }\n-    \n+\n     public void testEmptyChain() {\n         final LazyIteratorChain<String> chain = makeEmptyIterator();\n         assertEquals(false, chain.hasNext());\n--- a/src/test/java/org/apache/commons/collections4/iterators/LoopingIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/LoopingIteratorTest.java\n         } catch (final NullPointerException ex) {\n         }\n     }\n-    \n+\n     /**\n      * Tests whether an empty looping iterator works as designed.\n      * @throws Exception  If something unexpected occurs.\n         assertEquals(\"b\", loop.next());\n         assertEquals(\"c\", loop.next());\n     }\n-    \n+\n     /**\n      * Tests the size() method on a LoopingIterator wrapped ArrayList.\n      * @throws Exception  If something unexpected occurs.\n--- a/src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/LoopingListIteratorTest.java\n     public LoopingListIteratorTest(final String testName) {\n         super(testName);\n     }\n-    \n+\n     /**\n      * Tests constructor exception.\n      */\n         final LoopingListIterator<Object> loop = new LoopingListIterator<Object>(list);\n         assertFalse(loop.hasNext());\n         assertFalse(loop.hasPrevious());\n-        \n+\n         try {\n             loop.next();\n             fail();\n     public void testJoggingNotOverBoundary() {\n         final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n         final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n-    \n+\n         // Try jogging back and forth between the elements, but not\n         // over the begin/end boundary.\n         loop.reset();\n     public void testJoggingOverBoundary() {\n         final List<String> list = Arrays.asList(new String[] { \"a\", \"b\" });\n         final LoopingListIterator<String> loop = new LoopingListIterator<String>(list); // <a> b\n-    \n+\n         // Try jogging back and forth between the elements, but not\n         // over the begin/end boundary.\n         assertEquals(\"b\", loop.previous()); // a <b>\n         assertEquals(\"e\", loop.previous()); // a b c <e> f\n         assertEquals(\"c\", loop.previous()); // a b <c> e f\n         assertEquals(\"c\", loop.next());     // a b c <e> f\n-        \n+\n         loop.add(\"d\");                      // a b c d <e> f\n         loop.reset();                       // <a> b c d e f\n         assertEquals(\"a\", loop.next());     // a <b> c d e f\n         assertEquals(\"a\", loop.next());     // a <b> c d e f\n \n         list = new ArrayList<String>(Arrays.asList(new String[] { \"b\", \"e\", \"f\" }));\n-        loop = new LoopingListIterator<String>(list); // <b> e f        \n+        loop = new LoopingListIterator<String>(list); // <b> e f\n \n         loop.add(\"a\");                      // a <b> e f\n         assertEquals(\"a\", loop.previous()); // a b e <f>\n         loop.reset();                       // <q> r c\n         assertEquals(\"q\", loop.next());     // q <r> c\n         loop.set(\"a\");                      // a <r> c\n-        \n+\n         assertEquals(\"r\", loop.next());     // a r <c>\n         loop.set(\"b\");                      // a b <c>\n \n         assertEquals(\"b\", loop.next());     // a b <c>\n         assertEquals(\"c\", loop.next());     // <a> b c\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/NodeListIteratorTest.java\n  */\n public class NodeListIteratorTest extends AbstractIteratorTest<Node> {\n \n-    // Node array to be filled with mocked Node instances \n+    // Node array to be filled with mocked Node instances\n     private Node[] nodes;\n-    \n+\n     // NodeListIterator supports two constructors. This flag allows to\n     // control, which constructor to use in makeObject() and makeEmtpyIterator\n     private boolean createIteratorWithStandardConstr = true;\n-    \n+\n     /**\n-     * Constructor \n-     * @param testName \n+     * Constructor\n+     * @param testName\n      */\n     public NodeListIteratorTest(final String testName) {\n         super(testName);\n     }\n-    \n+\n     @Override\n     protected void setUp() throws Exception {\n-        super.setUp(); \n+        super.setUp();\n \n         // Default: use standard constr.\n         createIteratorWithStandardConstr = true;\n-        \n-        \n+\n+\n         // create mocked Node Instances and fill Node[] to be used by test cases\n         final Node node1 = createMock(Element.class);\n         final Node node2 = createMock(Element.class);\n         final Node node3 = createMock(Text.class);\n         final Node node4 = createMock(Element.class);\n         nodes = new Node[] {node1, node2, node3, node4};\n-        \n+\n         replay(node1);\n         replay(node2);\n         replay(node3);\n                 return 0;\n             }\n         };\n-        \n+\n         if (createIteratorWithStandardConstr) {\n             return new NodeListIterator(emptyNodeList);\n         } else {\n             final Node parentNode = createMock(Node.class);\n             expect(parentNode.getChildNodes()).andStubReturn(emptyNodeList);\n             replay(parentNode);\n-            \n+\n             return new NodeListIterator(parentNode);\n         }\n     }\n     public boolean supportsRemove() {\n         return false;\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testNullConstructor(){\n         try{\n--- a/src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/PermutationIteratorTest.java\n     }\n \n     //-----------------------------------------------------------------------\n-    \n+\n     @Override\n     public boolean supportsRemove() {\n         return false;\n     }\n-    \n+\n     @Override\n     public boolean supportsEmptyIterator() {\n         return false;\n         perm6.add('A');\n \n         List<List<Character>> results = new ArrayList<List<Character>>();\n-        \n+\n         PermutationIterator<Character> it = makeObject();\n         while (it.hasNext()) {\n             List<Character> next = it.next();\n \n     /**\n      * test checking that all the permutations are returned only once.\n-     */    \n+     */\n     public void testPermutationUnicity() {\n         List<List<Character>> resultsList = new ArrayList<List<Character>>();\n         Set<List<Character>> resultsSet = new HashSet<List<Character>>();\n-        \n+\n         PermutationIterator<Character> it = makeObject();\n         while (it.hasNext()) {\n             List<Character> permutation = it.next();\n \n     public void testPermutationException() {\n         List<List<Character>> resultsList = new ArrayList<List<Character>>();\n-        \n+\n         PermutationIterator<Character> it = makeObject();\n         while (it.hasNext()) {\n             List<Character> permutation = it.next();\n         PermutationIterator<Character> it = makeEmptyIterator();\n         // there is one permutation for an empty set: 0! = 1\n         assertTrue(it.hasNext());\n-        \n+\n         List<Character> nextPermutation = it.next();\n         assertEquals(0, nextPermutation.size());\n-        \n+\n         assertFalse(it.hasNext());\n     }\n }\n--- a/src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java\n+++ b/src/test/java/org/apache/commons/collections4/iterators/SingletonListIteratorTest.java\n public class SingletonListIteratorTest<E> extends AbstractListIteratorTest<E> {\n \n     private static final Object testValue = \"foo\";\n-    \n+\n     public SingletonListIteratorTest(final String testName) {\n         super(testName);\n     }\n-    \n+\n     /**\n-     * Returns a SingletonListIterator from which \n+     * Returns a SingletonListIterator from which\n      * the element has already been removed.\n      */\n     @Override\n         final SingletonListIterator<E> iter = makeObject();\n         iter.next();\n         iter.remove();\n-        iter.reset();        \n+        iter.reset();\n         return iter;\n     }\n \n         assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n         assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n         assertEquals( \"Iteration previous index\", -1, iter.previousIndex() );\n-        \n+\n         Object iterValue = iter.next();\n         assertEquals( \"Iteration value is correct\", testValue, iterValue );\n-        \n+\n         assertTrue( \"Iterator should have no next item\", !iter.hasNext() );\n         assertTrue( \"Iterator should have previous item\", iter.hasPrevious() );\n         assertEquals( \"Iteration next index\", 1, iter.nextIndex() );\n \n         iterValue = iter.previous();\n         assertEquals( \"Iteration value is correct\", testValue, iterValue );\n-        \n+\n         assertTrue( \"Iterator should have next item\", iter.hasNext() );\n         assertTrue( \"Iterator should have no previous item\", !iter.hasPrevious() );\n         assertEquals( \"Iteration next index\", 0, iter.nextIndex() );\n \n         iterValue = iter.next();\n         assertEquals( \"Iteration value is correct\", testValue, iterValue );\n-        \n+\n         assertTrue( \"Iterator should have no next item\", !iter.hasNext() );\n         assertTrue( \"Iterator should have previous item\", iter.hasPrevious() );\n         assertEquals( \"Iteration next index\", 1, iter.nextIndex() );\n         try {\n             iter.next();\n         } catch (final Exception e) {\n-          assertTrue(\"NoSuchElementException must be thrown\", \n+          assertTrue(\"NoSuchElementException must be thrown\",\n              e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n         iter.previous();\n         try {\n             iter.previous();\n         } catch (final Exception e) {\n-          assertTrue(\"NoSuchElementException must be thrown\", \n+          assertTrue(\"NoSuchElementException must be thrown\",\n              e.getClass().equals(new NoSuchElementException().getClass()));\n         }\n     }\n-    \n+\n     public void testReset() {\n         final ResettableListIterator<E> it = makeObject();\n-        \n+\n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n         assertEquals(testValue, it.next());\n         assertEquals(true, it.hasPrevious());\n \n         it.reset();\n-        \n+\n         assertEquals(true, it.hasNext());\n         assertEquals(false, it.hasPrevious());\n         assertEquals(testValue, it.next());\n         assertEquals(false, it.hasNext());\n         assertEquals(true, it.hasPrevious());\n-        \n+\n         it.reset();\n         it.reset();\n-        \n+\n         assertEquals(true, it.hasNext());\n     }\n-    \n+\n }\n \n--- a/src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java\n  * @version $Id$\n  */\n public abstract class AbstractMapEntryTest<K, V> extends TestCase {\n-    \n+\n     protected final String key = \"name\";\n     protected final String value = \"duke\";\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test name\n      */\n     public AbstractMapEntryTest(final String testName) {\n--- a/src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/DefaultKeyValueTest.java\n  * @version $Id$\n  */\n public class DefaultKeyValueTest<K, V> extends TestCase {\n-    \n+\n     private final String key = \"name\";\n     private final String value = \"duke\";\n \n     /**\n      * JUnit constructor.\n-     * \n+     *\n      * @param testName  the test name\n      */\n     public DefaultKeyValueTest(final String testName) {\n--- a/src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java\n+++ b/src/test/java/org/apache/commons/collections4/keyvalue/MultiKeyTest.java\n         @Override\n         public boolean equals(final Object obj)\n         {\n-            return obj instanceof SystemHashCodeSimulatingKey \n+            return obj instanceof SystemHashCodeSimulatingKey\n                 && name.equals(((SystemHashCodeSimulatingKey)obj).name);\n         }\n \n             return this;\n         }\n     }\n-    \n+\n     public void testEqualsAfterSerialization() throws IOException, ClassNotFoundException\n     {\n         SystemHashCodeSimulatingKey sysKey = new SystemHashCodeSimulatingKey(\"test\");\n         assertEquals(2, sysKey.hashCode()); // different hashCode now\n \n         final MultiKey<?> mk2 = new MultiKey<Object>(ONE, sysKey);\n-        assertEquals(TWO, map2.get(mk2));        \n+        assertEquals(TWO, map2.get(mk2));\n     }\n }\n--- a/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/SetUniqueListTest.java\n         4, list.size());\n       assertEquals(\"Third new element should be at index 0\", thirdNewElement, list.get(0));\n     }\n-    \n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public void testListSetByIndex() {\n         for (int i = 0; i < 10; ++i) {\n             uniqueList.add((E)Integer.valueOf(i));\n         }\n-        \n+\n         final Collection<E> retained = new ArrayList<E>(5);\n         for (int i = 0; i < 5; ++i) {\n             retained.add((E)Integer.valueOf(i * 2));\n         }\n-        \n+\n         assertTrue(uniqueList.retainAll(retained));\n         assertEquals(5, uniqueList.size());\n         assertTrue(uniqueList.contains(Integer.valueOf(0)));\n         for (int i = 5; i < 10; ++i) {\n             uniqueList.add((E)Integer.valueOf(i));\n         }\n-        \n+\n         final Collection<E> retained = new ArrayList<E>(5);\n         for (int i = 0; i < 5; ++i) {\n             retained.add((E)Integer.valueOf(i * 2));\n         }\n-        \n+\n         assertTrue(uniqueList.retainAll(retained));\n         assertEquals(5, uniqueList.size());\n         assertTrue(uniqueList.contains(Integer.valueOf(0)));\n         assertTrue(uniqueList.contains(Integer.valueOf(6)));\n         assertTrue(uniqueList.contains(Integer.valueOf(8)));\n     }\n-    \n+\n     /*\n      * test case for https://issues.apache.org/jira/browse/COLLECTIONS-427\n      */\n         final long start = System.currentTimeMillis();\n         uniqueList.retainAll(toRetain);\n         final long stop = System.currentTimeMillis();\n-        \n+\n         // make sure retainAll completes under 5 seconds\n         // TODO if test is migrated to JUnit 4, add a Timeout rule.\n         // http://kentbeck.github.com/junit/javadoc/latest/org/junit/rules/Timeout.html\n         assertTrue(stop - start < 5000);\n     }\n-    \n+\n     public void testSetCollections444() {\n         final SetUniqueList<Integer> lset = new SetUniqueList<Integer>(new ArrayList<Integer>(), new HashSet<Integer>());\n \n             super(list, set);\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     @Override\n     public String getCompatibilityVersion() {\n--- a/src/test/java/org/apache/commons/collections4/list/TransformedListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/TransformedListTest.java\n             assertEquals(true, list.contains(Integer.valueOf((String) el)));\n             assertEquals(false, list.contains(el));\n         }\n-        \n+\n         assertEquals(false, list.remove(els[0]));\n         assertEquals(true, list.remove(Integer.valueOf((String) els[0])));\n     }\n--- a/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n+++ b/src/test/java/org/apache/commons/collections4/list/TreeListTest.java\n         assertEquals(Integer.valueOf(4), li.next());\n         assertEquals(false, li.hasNext());\n     }\n-    \n+\n     public void testBugCollections447() {\n         final List<String> treeList = new TreeList<String>();\n         treeList.add(\"A\");\n         treeList.add(\"B\");\n         treeList.add(\"C\");\n         treeList.add(\"D\");\n-        \n+\n         final ListIterator<String> li = treeList.listIterator();\n         assertEquals(\"A\", li.next());\n         assertEquals(\"B\", li.next());\n-        \n+\n         assertEquals(\"B\", li.previous());\n-                \n+\n         li.remove(); // Deletes \"B\"\n-                \n+\n         // previous() after remove() should move to\n         // the element before the one just removed\n         assertEquals(\"A\", li.previous());\n     }\n-    \n+\n     public void testIterationOrder() {\n         // COLLECTIONS-433:\n         // ensure that the iteration order of elements is correct\n                 Integer val = it.next();\n                 assertEquals(i++, val.intValue());\n             }\n-            \n+\n             while (it.hasPrevious()) {\n                 Integer val = it.previous();\n                 assertEquals(--i, val.intValue());\n             }\n-        }        \n+        }\n     }\n \n     public void testIterationOrderAfterAddAll() {\n \n         // to simulate different cases in addAll, do different runs where\n         // the number of elements already in the list and being added by addAll differ\n-        \n+\n         int size = 1000;\n         for (int i = 0; i < 100; i++) {\n             List<Integer> other = new ArrayList<Integer>(size);\n             for (int j = 0; j < i; j++) {\n                 l.add(j);\n             }\n-            \n+\n             l.addAll(other);\n \n             ListIterator<Integer> it = l.listIterator();\n                 Integer val = it.next();\n                 assertEquals(cnt++, val.intValue());\n             }\n-            \n+\n             while (it.hasPrevious()) {\n                 Integer val = it.previous();\n                 assertEquals(--cnt, val.intValue());\n             }\n-        }        \n+        }\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java\n \n     public void verifyValues() {\n         final List<V> known = new ArrayList<V>(getConfirmed().values());\n-        \n+\n         // bug in IBM JDK: IBM J9 VM build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067\n         // a call to values() on an empty map retrieved via TreeMap#headMap or tailMap\n         // will render the values view unusable: resulting in NullPointerExceptions or missing values\n         // it will also not recover, as the value view is cached internally\n         values = getMap().values();\n-        \n+\n         final List<V> test = new ArrayList<V>(values);\n \n         final int size = getConfirmed().size();\n--- a/src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/CompositeMapTest.java\n import org.apache.commons.collections4.map.CompositeMap;\n \n /**\n- * Extension of {@link AbstractMapTest} for exercising the \n+ * Extension of {@link AbstractMapTest} for exercising the\n  * {@link CompositeMap} implementation.\n  *\n  * @since 3.0\n public class CompositeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n     /** used as a flag in MapMutator tests */\n     private boolean pass = false;\n-    \n+\n     public CompositeMapTest(final String testName) {\n         super(testName);\n     }\n-    \n+\n     @Override\n     public void setUp() throws Exception {\n         super.setUp();\n         this.pass = false;\n     }\n-    \n+\n     @Override\n     public CompositeMap<K, V> makeObject() {\n         final CompositeMap<K, V> map = new CompositeMap<K, V>();\n         map.setMutator( new EmptyMapMutator<K, V>() );\n         return map;\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     private Map<K, V> buildOne() {\n         final HashMap<K, V> map = new HashMap<K, V>();\n         map.put((K) \"2\", (V) \"two\");\n         return map;\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public Map<K, V> buildTwo() {\n         final HashMap<K, V> map = new HashMap<K, V>();\n         map.put((K) \"4\", (V) \"four\");\n         return map;\n     }\n-    \n+\n     public void testGet() {\n         final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n         assertEquals(\"one\", map.get(\"1\"));\n         assertEquals(\"four\", map.get(\"4\"));\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testAddComposited() {\n         final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n             // expected\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveComposited() {\n         final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n-        \n+\n         map.removeComposited(three);\n         assertFalse(map.containsKey(\"5\"));\n-        \n+\n         map.removeComposited(buildOne());\n         assertFalse(map.containsKey(\"2\"));\n-        \n-    }\n-    \n+\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveFromUnderlying() {\n         final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n-        \n+\n         //Now remove \"5\"\n         three.remove(\"5\");\n         assertFalse(map.containsKey(\"5\"));\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testRemoveFromComposited() {\n         final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n         three.put((K) \"5\", (V) \"five\");\n         map.addComposited(three);\n         assertTrue(map.containsKey(\"5\"));\n-        \n+\n         //Now remove \"5\"\n         map.remove(\"5\");\n         assertFalse(three.containsKey(\"5\"));\n     }\n-    \n+\n     public void testResolveCollision() {\n-        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(),\n             new CompositeMap.MapMutator<K, V>() {\n             private static final long serialVersionUID = 1L;\n \n             final Collection<K> intersect) {\n                 pass = true;\n             }\n-            \n-            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+\n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,\n                 final V value) {\n                 throw new UnsupportedOperationException();\n             }\n-            \n+\n             public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                 throw new UnsupportedOperationException();\n             }\n         });\n-        \n+\n         map.addComposited(buildOne());\n         assertTrue(pass);\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public void testPut() {\n-        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(),\n             new CompositeMap.MapMutator<K, V>() {\n             private static final long serialVersionUID = 1L;\n             public void resolveCollision(final CompositeMap<K, V> composite,\n             final Collection<K> intersect) {\n                 throw new UnsupportedOperationException();\n             }\n-            \n-            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+\n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,\n                 final V value) {\n                 pass = true;\n                 return (V) \"foo\";\n             }\n-            \n+\n             public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                 throw new UnsupportedOperationException();\n             }\n         });\n-        \n+\n         map.put((K) \"willy\", (V) \"wonka\");\n         assertTrue(pass);\n     }\n-    \n+\n     public void testPutAll() {\n-        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+        final CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(),\n             new CompositeMap.MapMutator<K, V>() {\n             private static final long serialVersionUID = 1L;\n             public void resolveCollision(final CompositeMap<K, V> composite,\n             final Collection<K> intersect) {\n                 throw new UnsupportedOperationException();\n             }\n-            \n-            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, \n+\n+            public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key,\n                 final V value) {\n                 throw new UnsupportedOperationException();\n             }\n-            \n+\n             public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n                 pass = true;\n             }\n         });\n-        \n+\n         map.putAll(null);\n         assertTrue(pass);\n     }\n--- a/src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java\n+++ b/src/test/java/org/apache/commons/collections4/map/EmptyMapMutator.java\n import org.apache.commons.collections4.map.CompositeMap;\n \n /**\n- * This class is used in TestCompositeMap. When testing serialization, \n- * the class has to be separate of TestCompositeMap, else the test \n- * class also has to be serialized. \n+ * This class is used in TestCompositeMap. When testing serialization,\n+ * the class has to be separate of TestCompositeMap, else the test\n+ * class also has to be serialized.\n  */\n class EmptyMapMutator<K,V> implements CompositeMap.MapMutator<K,V> {\n     /** Serialization version */\n     final Collection<K> intersect) {\n         // Do nothing\n     }\n-    \n+\n     public V put(final CompositeMap<K, V> map, final Map<K, V>[] composited, final K key, final V value) {\n         return composited[0].put(key, value);\n     }\n-    \n+\n     public void putAll(final CompositeMap<K, V> map, final Map<K, V>[] composited, final Map<? extends K, ? extends V> t) {\n         composited[0].putAll(t);\n     }\n--- a/src/test/java/org/apache/commons/collections4/map/LRUMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/LRUMapTest.java\n             fail();\n         } catch (final IndexOutOfBoundsException ex) {}\n     }\n-    \n+\n     public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {\n \n         final LRUMap<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n-        \n+\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n         }\n \n         assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n-        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \"\n                 + counter[0] + \" did succeed\", counter[0] >= threads.length);\n     }\n-    \n+\n     public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {\n \n         final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n-        \n+\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n         }\n \n         assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n-        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \"\n                 + counter[0] + \" did succeed\", counter[0] >= threads.length);\n     }\n-    \n+\n     public void testSynchronizedRemoveFromKeySet() throws InterruptedException {\n \n         final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n-        \n+\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n         }\n \n         assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n-        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \"\n                 + counter[0] + \" did succeed\", counter[0] >= threads.length);\n     }\n-    \n+\n     public void testSynchronizedRemoveFromValues() throws InterruptedException {\n \n         final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n-        \n+\n         final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n         final ThreadGroup tg = new ThreadGroup(getName()) {\n             @Override\n         }\n \n         assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n-        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \"\n                 + counter[0] + \" did succeed\", counter[0] >= threads.length);\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/LazySortedMapTest.java\n import org.junit.Test;\n \n /**\n- * Extension of {@link LazyMapTest} for exercising the \n+ * Extension of {@link LazyMapTest} for exercising the\n  * {@link LazySortedMap} implementation.\n  *\n  * @since 3.0\n  */\n @SuppressWarnings(\"boxing\")\n public class LazySortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n-    \n+\n     private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n-   \n+\n     public LazySortedMapTest(final String testName) {\n         super(testName);\n     }\n-    \n+\n     @Override\n     public SortedMap<K,V> makeObject() {\n         return lazySortedMap(new TreeMap<K,V>(), FactoryUtils.<V>nullFactory());\n     }\n-    \n+\n     @Override\n     public boolean isSubMapViewsSerializable() {\n         // TODO TreeMap sub map views have a bug in deserialization.\n     public void testMapGet() {\n         //TODO eliminate need for this via superclass - see svn history.\n     }\n-    \n+\n     @Test\n     public void mapGet() {\n         Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n         final Number o = map.get(5);\n         assertEquals(null,o);\n         assertEquals(1, map.size());\n-        \n+\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testSortOrder() {\n         final SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n         map.put(\"C\", 8);\n         assertEquals(\"First key should be A\", \"A\", map.firstKey());\n         assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n-        assertEquals(\"First key in tail map should be B\", \n+        assertEquals(\"First key in tail map should be B\",\n             \"B\", map.tailMap(\"B\").firstKey());\n-        assertEquals(\"Last key in head map should be B\", \n+        assertEquals(\"Last key in head map should be B\",\n             \"B\", map.headMap(\"C\").lastKey());\n         assertEquals(\"Last key in submap should be B\",\n             \"B\", map.subMap(\"A\",\"C\").lastKey());\n-        \n+\n         final Comparator<?> c = map.comparator();\n-        assertTrue(\"natural order, so comparator should be null\", \n-            c == null);      \n-    } \n-    \n+        assertTrue(\"natural order, so comparator should be null\",\n+            c == null);\n+    }\n+\n     public void testTransformerDecorate() {\n         final Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n-        SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n-        assertTrue(map instanceof LazySortedMap);  \n+        SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);\n+        assertTrue(map instanceof LazySortedMap);\n          try {\n             map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n             fail(\"Expecting IllegalArgumentException for null transformer\");\n             fail(\"Expecting IllegalArgumentException for null map\");\n         } catch (final IllegalArgumentException e) {\n             // expected\n-        } \n+        }\n     }\n-    \n+\n     @Override\n     public String getCompatibilityVersion() {\n         return \"4\";\n--- a/src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/ListOrderedMapTest.java\n         }\n \n         lom.putAll(3, map);\n-        \n+\n         final List<K> orderedList = lom.asList();\n         for (int i = 0; i < size; i++) {\n             assertEquals(i, orderedList.get(i));\n         }\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     public void testValueList_getByIndex() {\n         resetFull();\n--- a/src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/PassiveExpiringMapTest.java\n //    public void testCreate() throws Exception {\n //        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n //                \"src/test/resources/data/test/PassiveExpiringMap.emptyCollection.version4.obj\");\n-//    \n+//\n //        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n //                \"src/test/resources/data/test/PassiveExpiringMap.fullCollection.version4.obj\");\n //    }\n--- a/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/ReferenceMapTest.java\n //            (java.io.Serializable) map,\n //            \"src/test/resources/data/test/ReferenceMap.fullCollection.version4.obj\");\n //    }\n-    \n+\n     //-----------------------------------------------------------------------\n     @SuppressWarnings(\"unchecked\")\n     public void testNullHandling() {\n--- a/src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/map/TransformedSortedMapTest.java\n         // there are several bugs in the following JVM:\n         // IBM J9 VM build 2.4, JRE 1.6.0 IBM J9 2.4 Linux x86-32 jvmxi3260sr12-20121024_126067\n         // thus disabling tests related to these bugs\n-        \n+\n         final String vmName = System.getProperty(\"java.vm.name\");\n         final String version = System.getProperty(\"java.version\");\n-        \n+\n         if (vmName == null || version == null) {\n             return null;\n         }\n--- a/src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java\n+++ b/src/test/java/org/apache/commons/collections4/queue/CircularFifoQueueTest.java\n \n     public void testGetIndex() {\n         resetFull();\n-        \n+\n         final CircularFifoQueue<E> queue = getCollection();\n         final List<E> confirmed = (List<E>) getConfirmed();\n         for (int i = 0; i < confirmed.size(); i++) {\n         // remove the first two elements and check again\n         queue.remove();\n         queue.remove();\n-        \n+\n         for (int i = 0; i < queue.size(); i++) {\n             assertEquals(confirmed.get(i + 2), queue.get(i));\n-        }        \n+        }\n     }\n \n     @Override\n--- a/src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java\n+++ b/src/test/java/org/apache/commons/collections4/queue/PredicatedQueueTest.java\n     public Queue<E> makeObject() {\n         return decorateCollection(new LinkedList<E>(), truePredicate);\n     }\n-    \n+\n     @Override\n     public Queue<E> makeFullCollection() {\n         final Queue<E> queue = new LinkedList<E>();\n--- a/src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java\n+++ b/src/test/java/org/apache/commons/collections4/queue/TransformedQueueTest.java\n  * @version $Id$\n  */\n public class TransformedQueueTest<E> extends AbstractQueueTest<E> {\n-    \n+\n     public TransformedQueueTest(final String testName) {\n         super(testName);\n     }\n             assertEquals(true, queue.contains(Integer.valueOf((String) els[i])));\n             assertEquals(false, queue.contains(els[i]));\n         }\n-        \n+\n         assertEquals(false, queue.remove(els[0]));\n         assertEquals(true, queue.remove(Integer.valueOf((String) els[0])));\n-        \n+\n     }\n \n     @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n             assertEquals(true, queue.contains(Integer.valueOf((String) el)));\n             assertEquals(false, queue.contains(el));\n         }\n-        \n+\n         assertEquals(false, queue.remove(els[0]));\n         assertEquals(true, queue.remove(Integer.valueOf((String) els[0])));\n     }\n     public String getCompatibilityVersion() {\n         return \"4\";\n     }\n-    \n+\n //  public void testCreate() throws Exception {\n //      resetEmpty();\n //      writeExternalFormToDisk((java.io.Serializable) getCollection(), \"src/test/resources/data/test/TransformedQueue.emptyCollection.version4.obj\");\n--- a/src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java\n     @Override\n     public void verify() {\n         super.verify();\n-        \n+\n         assertEquals(\"Sets should be equal\", getConfirmed(), getCollection());\n-        assertEquals(\"Sets should have equal hashCodes\", \n+        assertEquals(\"Sets should have equal hashCodes\",\n                      getConfirmed().hashCode(), getCollection().hashCode());\n         final Collection<E> set = makeConfirmedCollection();\n         final Iterator<E> iterator = getCollection().iterator();\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Return the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.  \n+     * Return the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.\n      */\n     @Override\n     public Set<E> getCollection() {\n      */\n     public void testSetHashCode() {\n         resetEmpty();\n-        assertEquals(\"Empty sets have equal hashCodes\", \n+        assertEquals(\"Empty sets have equal hashCodes\",\n                 getCollection().hashCode(), getConfirmed().hashCode());\n \n         resetFull();\n-        assertEquals(\"Equal sets have equal hashCodes\", \n+        assertEquals(\"Equal sets have equal hashCodes\",\n                 getCollection().hashCode(), getConfirmed().hashCode());\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java\n     @Override\n     public void verify() {\n         super.verify();\n-        \n+\n         // Check that iterator returns elements in order and first() and last()\n         // are consistent\n         final Iterator<E> colliter = getCollection().iterator();\n                 last = first;\n             } else {\n               last = colliter.next();\n-            }  \n+            }\n             assertEquals(\"Element appears to be out of order.\", last, confiter.next());\n         }\n         if (getCollection().size() > 0) {\n         public SortedSet<E> makeFullCollection() {\n             return getSubSet(AbstractSortedSetTest.this.makeFullCollection());\n         }\n-        \n+\n         @Override\n         public boolean isTestSerialization() {\n             return false;\n         }\n-        \n+\n         @Override\n         public BulkTest bulkTestSortedSetSubSet() {\n             return null;  // prevent infinite recursion\n--- a/src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java\n+++ b/src/test/java/org/apache/commons/collections4/set/EmptySetMutator.java\n import java.util.Set;\n \n /**\n- * This class is used in CompositeSetTest. When testing serialization, \n- * the class has to be separate of CompositeSetTest, else the test \n- * class also has to be serialized. \n+ * This class is used in CompositeSetTest. When testing serialization,\n+ * the class has to be separate of CompositeSetTest, else the test\n+ * class also has to be serialized.\n  */\n class EmptySetMutator<E> implements CompositeSet.SetMutator<E> {\n \n     public void resolveCollision(final CompositeSet<E> comp, final Set<E> existing, final Set<E> added, final Collection<E> intersects) {\n         throw new IllegalArgumentException();\n     }\n-    \n+\n     public boolean add(final CompositeSet<E> composite, final List<Set<E>> collections, final E obj) {\n         return contained.add(obj);\n     }\n-    \n+\n     public boolean addAll(final CompositeSet<E> composite, final List<Set<E>> collections, final Collection<? extends E> coll) {\n         return contained.addAll(coll);\n-    }    \n+    }\n }\n--- a/src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/TransformedSetTest.java\n             assertEquals(true, set.contains(Integer.valueOf((String) el)));\n             assertEquals(false, set.contains(el));\n         }\n-        \n+\n         assertEquals(false, set.remove(els[0]));\n         assertEquals(true, set.remove(Integer.valueOf((String) els[0])));\n     }\n--- a/src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java\n+++ b/src/test/java/org/apache/commons/collections4/set/TransformedSortedSetTest.java\n         for (final Object el : els) {\n             assertEquals(true, set.contains(Integer.valueOf((String) el)));\n         }\n-        \n+\n         assertEquals(true, set.remove(Integer.valueOf((String) els[0])));\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/trie/ByteArrayKeyAnalyzerTest.java\n+++ b/src/test/java/org/apache/commons/collections4/trie/ByteArrayKeyAnalyzerTest.java\n public class ByteArrayKeyAnalyzerTest {\n \n     private static final int SIZE = 20000;\n-    \n+\n     @Test\n     public void bitSet() {\n         final byte[] key = toByteArray(\"10100110\", 2);\n         final ByteArrayKeyAnalyzer ka = new ByteArrayKeyAnalyzer(key.length * 8);\n         final int length = ka.lengthInBits(key);\n-        \n+\n         Assert.assertTrue(ka.isBitSet(key, 0, length));\n         Assert.assertFalse(ka.isBitSet(key, 1, length));\n         Assert.assertTrue(ka.isBitSet(key, 2, length));\n         Assert.assertTrue(ka.isBitSet(key, 6, length));\n         Assert.assertFalse(ka.isBitSet(key, 7, length));\n     }\n-    \n+\n     @Test\n     public void keys() {\n         final PatriciaTrie<byte[], BigInteger> trie\n             = new PatriciaTrie<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n-        \n-        final Map<byte[], BigInteger> map \n+\n+        final Map<byte[], BigInteger> map\n             = new TreeMap<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n-        \n+\n         for (int i = 0; i < SIZE; i++) {\n             final BigInteger value = BigInteger.valueOf(i);\n             final byte[] key = toByteArray(value);\n-            \n+\n             final BigInteger existing = trie.put(key, value);\n             Assert.assertNull(existing);\n-            \n+\n             map.put(key, value);\n         }\n-        \n+\n         Assert.assertEquals(map.size(), trie.size());\n-        \n+\n         for (final byte[] key : map.keySet()) {\n             final BigInteger expected = new BigInteger(1, key);\n             final BigInteger value = trie.get(key);\n-            \n+\n             Assert.assertEquals(expected, value);\n         }\n     }\n-    \n+\n     @Test\n     public void prefix() {\n         final byte[] prefix   = toByteArray(\"00001010\", 2);\n         final byte[] key1     = toByteArray(\"11001010\", 2);\n         final byte[] key2     = toByteArray(\"10101100\", 2);\n-        \n+\n         final ByteArrayKeyAnalyzer keyAnalyzer = new ByteArrayKeyAnalyzer(key1.length * 8);\n-        \n+\n         final int prefixLength = keyAnalyzer.lengthInBits(prefix);\n-            \n+\n         Assert.assertFalse(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key1));\n         Assert.assertTrue(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key2));\n     }\n-    \n+\n     private static byte[] toByteArray(final String value, final int radix) {\n         return toByteArray(Long.parseLong(value, radix));\n     }\n-    \n+\n     private static byte[] toByteArray(final long value) {\n         return toByteArray(BigInteger.valueOf(value));\n     }\n-    \n+\n     private static byte[] toByteArray(final BigInteger value) {\n         final byte[] src = value.toByteArray();\n         if (src.length <= 1) {\n             return src;\n         }\n-        \n+\n         if (src[0] != 0) {\n             return src;\n         }\n-        \n+\n         final byte[] dst = new byte[src.length-1];\n         System.arraycopy(src, 1, dst, 0, dst.length);\n         return dst;\n--- a/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n+++ b/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n  * @version $Id$\n  */\n public class PatriciaTrieTest {\n-    \n+\n     @Test\n     public void testSimple() {\n         final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n         Assert.assertTrue(intTrie.isEmpty());\n         Assert.assertEquals(0, intTrie.size());\n-        \n+\n         intTrie.put(1, \"One\");\n         Assert.assertFalse(intTrie.isEmpty());\n         Assert.assertEquals(1, intTrie.size());\n-        \n+\n         Assert.assertEquals(\"One\", intTrie.remove(1));\n         Assert.assertNull(intTrie.remove(1));\n         Assert.assertTrue(intTrie.isEmpty());\n         Assert.assertEquals(0, intTrie.size());\n-        \n+\n         intTrie.put(1, \"One\");\n         Assert.assertEquals(\"One\", intTrie.get(1));\n         Assert.assertEquals(\"One\", intTrie.put(1, \"NotOne\"));\n         Assert.assertEquals(\"NotOne\", intTrie.remove(1));\n         Assert.assertNull(intTrie.put(1, \"One\"));\n     }\n-    \n+\n     @Test\n     public void testCeilingEntry() {\n-        final PatriciaTrie<Character, String> charTrie \n+        final PatriciaTrie<Character, String> charTrie\n             = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('c', \"c\");\n         charTrie.put('p', \"p\");\n         charTrie.put('z', \"z\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n-        \n+\n         final Object[] results = new Object[] {\n             'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n             'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n             'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n             'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n             'z', \"z\"\n         };\n-        \n+\n         for(int i = 0; i < results.length; i++) {\n             final Map.Entry<Character, String> found = charTrie.ceilingEntry((Character)results[i]);\n             Assert.assertNotNull(found);\n             Assert.assertEquals(results[i], found.getKey());\n             Assert.assertEquals(results[++i], found.getValue());\n         }\n-        \n+\n         // Remove some & try again...\n         charTrie.remove('a');\n         charTrie.remove('z');\n         charTrie.remove('p');\n         charTrie.remove('m');\n         charTrie.remove('u');\n-        \n+\n         Map.Entry<Character, String> found = charTrie.ceilingEntry('u');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'v', found.getKey());\n-        \n+\n         found = charTrie.ceilingEntry('a');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'b', found.getKey());\n-        \n+\n         found = charTrie.ceilingEntry('z');\n         Assert.assertNull(found);\n-        \n+\n         found = charTrie.ceilingEntry('q');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'r', found.getKey());\n-        \n+\n         found = charTrie.ceilingEntry('l');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'n', found.getKey());\n-        \n+\n         found = charTrie.ceilingEntry('p');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'r', found.getKey());\n-        \n+\n         found = charTrie.ceilingEntry('m');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'n', found.getKey());\n-        \n+\n         found = charTrie.ceilingEntry('\\0');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'b', found.getKey());\n-        \n+\n         charTrie.put('\\0', \"\");\n         found = charTrie.ceilingEntry('\\0');\n         Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'\\0', found.getKey());      \n-    }\n-    \n+        Assert.assertEquals((Character)'\\0', found.getKey());\n+    }\n+\n     @Test\n     public void testLowerEntry() {\n         final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('z', \"z\");\n         charTrie.put('f', \"f\");\n         charTrie.put('d', \"d\");\n-        \n+\n         final Object[] results = new Object[] {\n             'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n             'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n             'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n             'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n             'z', \"z\"\n         };\n-        \n+\n         for(int i = 0; i < results.length; i+=2) {\n             //System.out.println(\"Looking for: \" + results[i]);\n             final Map.Entry<Character, String> found = charTrie.lowerEntry((Character)results[i]);\n         Map.Entry<Character, String> found = charTrie.lowerEntry((char)('z' + 1));\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'z', found.getKey());\n-        \n+\n         // Remove some & try again...\n         charTrie.remove('a');\n         charTrie.remove('z');\n         charTrie.remove('p');\n         charTrie.remove('m');\n         charTrie.remove('u');\n-        \n+\n         found = charTrie.lowerEntry('u');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'t', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('v');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'t', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('a');\n         Assert.assertNull(found);\n-        \n+\n         found = charTrie.lowerEntry('z');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'y', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry((char)('z'+1));\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'y', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('q');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'o', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('r');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'o', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('p');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'o', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('l');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'k', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('m');\n         Assert.assertNotNull(found);\n         Assert.assertEquals((Character)'k', found.getKey());\n-        \n+\n         found = charTrie.lowerEntry('\\0');\n         Assert.assertNull(found);\n-        \n+\n         charTrie.put('\\0', \"\");\n         found = charTrie.lowerEntry('\\0');\n-        Assert.assertNull(found);      \n-    }\n-    \n+        Assert.assertNull(found);\n+    }\n+\n     @Test\n     public void testIteration() {\n         final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n         intTrie.put(13, \"Thirteen\");\n         intTrie.put(14, \"Fourteen\");\n         intTrie.put(16, \"Sixteen\");\n-        \n+\n         TestCursor cursor = new TestCursor(\n                 1, \"One\", 2, \"Two\", 3, \"Three\", 4, \"Four\", 5, \"Five\", 13, \"Thirteen\",\n                 14, \"Fourteen\", 15, \"Fifteen\", 16, \"Sixteen\");\n         cursor.starting();\n         intTrie.traverse(cursor);\n         cursor.finished();\n-        \n+\n         cursor.starting();\n         for (final Map.Entry<Integer, String> entry : intTrie.entrySet()) {\n             cursor.select(entry);\n         }\n         cursor.finished();\n-        \n+\n         cursor.starting();\n         for (final Integer integer : intTrie.keySet()) {\n             cursor.checkKey(integer);\n         }\n         cursor.finished();\n-        \n+\n         cursor.starting();\n         for (final String string : intTrie.values()) {\n             cursor.checkValue(string);\n                 'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n                 'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n                 'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n                 'z', \"z\");\n-        \n+\n         cursor.starting();\n         charTrie.traverse(cursor);\n         cursor.finished();\n             cursor.select(entry);\n         }\n         cursor.finished();\n-        \n+\n         cursor.starting();\n         for (final Character character : charTrie.keySet()) {\n             cursor.checkKey(character);\n         }\n         cursor.finished();\n-        \n+\n         cursor.starting();\n         for (final String string : charTrie.values()) {\n             cursor.checkValue(string);\n         }\n         cursor.finished();\n     }\n-    \n+\n     @Test\n     public void testSelect() {\n         final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n         charTrie.put('d', \"d\");\n         final TestCursor cursor = new TestCursor(\n                 'd', \"d\", 'e', \"e\", 'f', \"f\", 'g', \"g\",\n-                'a', \"a\", 'b', \"b\", 'c', \"c\",  \n+                'a', \"a\", 'b', \"b\", 'c', \"c\",\n                 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-                'h', \"h\", 'i', \"i\", 'j', \"j\", 'k', \"k\", \n+                'h', \"h\", 'i', \"i\", 'j', \"j\", 'k', \"k\",\n                 't', \"t\", 'u', \"u\", 'v', \"v\", 'w', \"w\",\n-                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", \n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\",\n                 'x', \"x\", 'y', \"y\", 'z', \"z\");\n-                \n+\n         Assert.assertEquals(26, charTrie.size());\n-        \n+\n         cursor.starting();\n         charTrie.select('d', cursor);\n         cursor.finished();\n     }\n-    \n+\n     @Test\n     public void testTraverseCursorRemove() {\n         final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n                 'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n                 'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n                 'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n                 'z', \"z\");\n-        \n+\n         cursor.starting();\n         charTrie.traverse(cursor);\n         cursor.finished();\n-        \n+\n         // Test removing both an internal & external node.\n         // 'm' is an example External node in this Trie, and 'p' is an internal.\n-        \n+\n         Assert.assertEquals(26, charTrie.size());\n-        \n+\n         final Object[] toRemove = new Object[] { 'g', 'd', 'e', 'm', 'p', 'q', 'r', 's' };\n         cursor.addToRemove(toRemove);\n-        \n+\n         cursor.starting();\n         charTrie.traverse(cursor);\n         cursor.finished();\n-            \n+\n         Assert.assertEquals(26 - toRemove.length, charTrie.size());\n \n         cursor.starting();\n         charTrie.traverse(cursor);\n         cursor.finished();\n-        \n+\n         cursor.starting();\n         for (final Entry<Character, String> entry : charTrie.entrySet()) {\n             cursor.select(entry);\n         }\n         cursor.finished();\n     }\n-    \n+\n     @Test\n     public void testIteratorRemove() {\n         final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n                 'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n                 'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n                 'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n                 'z', \"z\");\n-        \n+\n         // Test removing both an internal & external node.\n         // 'm' is an example External node in this Trie, and 'p' is an internal.\n-        \n+\n         Assert.assertEquals(26, charTrie.size());\n-        \n+\n         final Object[] toRemove = new Object[] { 'e', 'm', 'p', 'q', 'r', 's' };\n-        \n+\n         cursor.starting();\n         for(final Iterator<Map.Entry<Character, String>> i = charTrie.entrySet().iterator(); i.hasNext(); ) {\n             final Map.Entry<Character,String> entry = i.next();\n             cursor.select(entry);\n             if(Arrays.asList(toRemove).contains(entry.getKey())) {\n-                i.remove();            \n-            }\n-        }\n-        cursor.finished();\n-            \n+                i.remove();\n+            }\n+        }\n+        cursor.finished();\n+\n         Assert.assertEquals(26 - toRemove.length, charTrie.size());\n-        \n+\n         cursor.remove(toRemove);\n \n         cursor.starting();\n         }\n         cursor.finished();\n     }\n-    \n+\n     @Test\n     public void testHamlet() throws Exception {\n         // Make sure that Hamlet is read & stored in the same order as a SortedSet.\n         final List<String> control = new ArrayList<String>();\n         final SortedMap<String, String> sortedControl = new TreeMap<String, String>();\n         final PatriciaTrie<String, String> trie = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n+\n         final InputStream in = getClass().getResourceAsStream(\"hamlet.txt\");\n         final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n-        \n+\n         String read = null;\n         while( (read = reader.readLine()) != null) {\n             final StringTokenizer st = new StringTokenizer(read);\n         for (final String aControl : control) {\n             Assert.assertEquals(aControl, iter.next());\n         }\n-        \n+\n         final Random rnd = new Random();\n         int item = 0;\n         iter = trie.values().iterator();\n                 removed++;\n             }\n         }\n-        \n+\n         Assert.assertEquals(control.size(), item);\n         Assert.assertTrue(removed > 0);\n         Assert.assertEquals(control.size(), trie.size() + removed);\n-        \n+\n         // reset hamlet\n         trie.clear();\n         for (final String anOriginal : original) {\n             trie.put(anOriginal, anOriginal);\n         }\n-        \n+\n         assertEqualArrays(sortedControl.values().toArray(), trie.values().toArray());\n         assertEqualArrays(sortedControl.keySet().toArray(), trie.keySet().toArray());\n         assertEqualArrays(sortedControl.entrySet().toArray(), trie.entrySet().toArray());\n-        \n+\n         Assert.assertEquals(sortedControl.firstKey(), trie.firstKey());\n         Assert.assertEquals(sortedControl.lastKey(), trie.lastKey());\n-        \n+\n         SortedMap<String, String> sub = trie.headMap(control.get(523));\n         Assert.assertEquals(523, sub.size());\n         for(int i = 0; i < control.size(); i++) {\n         Assert.assertTrue(sub.containsValue(control.get(522)));\n         Assert.assertFalse(sub.containsValue(control.get(523)));\n         Assert.assertFalse(sub.containsValue(control.get(524)));\n-        \n+\n         try {\n             sub.headMap(control.get(524));\n             Assert.fail(\"should have thrown IAE\");\n         } catch(final IllegalArgumentException expected) {}\n-        \n+\n         Assert.assertEquals(sub.lastKey(), control.get(522));\n         Assert.assertEquals(sub.firstKey(), control.get(0));\n-        \n+\n         sub = sub.tailMap(control.get(234));\n         Assert.assertEquals(289, sub.size());\n         Assert.assertEquals(control.get(234), sub.firstKey());\n             sub.tailMap(control.get(232));\n             Assert.fail(\"should have thrown IAE\");\n         } catch(final IllegalArgumentException expected) {}\n-        \n+\n         sub = sub.subMap(control.get(300), control.get(400));\n         Assert.assertEquals(100, sub.size());\n         Assert.assertEquals(control.get(300), sub.firstKey());\n         Assert.assertEquals(control.get(399), sub.lastKey());\n-        \n+\n         for(int i = 0; i < control.size(); i++) {\n             if(i < 400 && i > 299) {\n                 Assert.assertTrue(sub.containsKey(control.get(i)));\n             }\n         }\n     }\n-    \n+\n     @Test\n     public void testPrefixedBy() {\n-        final PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie\n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n+\n         final String[] keys = new String[]{\n-                \"\", \n+                \"\",\n                 \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n                 \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n                 \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n         for (final String key : keys) {\n             trie.put(key, key);\n         }\n-        \n+\n         SortedMap<String, String> map;\n         Iterator<String> iterator;\n         Iterator<Map.Entry<String, String>> entryIterator;\n         Map.Entry<String, String> entry;\n-        \n+\n         map = trie.getPrefixedBy(\"Al\");\n         Assert.assertEquals(8, map.size());\n         Assert.assertEquals(\"Alabama\", map.firstKey());\n         Assert.assertEquals(\"Allie\", iterator.next());\n         Assert.assertEquals(\"Alliese\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"Albert\");\n         iterator = map.keySet().iterator();\n         Assert.assertEquals(\"Albert\", iterator.next());\n         Assert.assertEquals(\"Albertz\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n         Assert.assertEquals(\"Albertz\", map.remove(\"Albertz\"));\n-        \n+\n         map = trie.getPrefixedBy(\"Alberto\");\n         Assert.assertEquals(2, map.size());\n         Assert.assertEquals(\"Alberto\", map.firstKey());\n         Assert.assertFalse(entryIterator.hasNext());\n         Assert.assertEquals(\"Albertoad\", trie.remove(\"Albertoad\"));\n         trie.put(\"Albertoo\", \"Albertoo\");\n-        \n+\n         map = trie.getPrefixedBy(\"X\");\n         Assert.assertEquals(2, map.size());\n         Assert.assertFalse(map.containsKey(\"Albert\"));\n         Assert.assertEquals(\"Xavier\", iterator.next());\n         Assert.assertEquals(\"XyZ\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"An\");\n         Assert.assertEquals(1, map.size());\n         Assert.assertEquals(\"Anna\", map.firstKey());\n         iterator = map.keySet().iterator();\n         Assert.assertEquals(\"Anna\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"Ban\");\n         Assert.assertEquals(1, map.size());\n         Assert.assertEquals(\"Banane\", map.firstKey());\n         iterator = map.keySet().iterator();\n         Assert.assertEquals(\"Banane\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"Am\");\n         Assert.assertFalse(map.isEmpty());\n         Assert.assertEquals(3, map.size());\n         } catch(final ConcurrentModificationException expected) {}\n         Assert.assertEquals(\"Amber\", map.firstKey());\n         Assert.assertEquals(\"Ammun\", map.lastKey());\n-        \n+\n         map = trie.getPrefixedBy(\"Ak\\0\");\n         Assert.assertTrue(map.isEmpty());\n-        \n+\n         map = trie.getPrefixedBy(\"Ak\");\n         Assert.assertEquals(2, map.size());\n         Assert.assertEquals(\"Akka\", map.firstKey());\n         Assert.assertEquals(\"Akko\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n         Assert.assertEquals(\"Al\", trie.remove(\"Al\"));\n-        \n+\n         map = trie.getPrefixedBy(\"Akka\");\n         Assert.assertEquals(1, map.size());\n         Assert.assertEquals(\"Akka\", map.firstKey());\n         iterator = map.keySet().iterator();\n         Assert.assertEquals(\"Akka\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"Ab\");\n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         } catch(final NoSuchElementException nsee) {}\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"Albertooo\");\n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         } catch(final NoSuchElementException nsee) {}\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"\");\n         Assert.assertSame(trie, map); // stricter than necessary, but a good check\n-        \n+\n         map = trie.getPrefixedBy(\"\\0\");\n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n     }\n-    \n+\n     @Test\n     public void testPrefixByOffsetAndLength() {\n-        final PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie\n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n+\n         final String[] keys = new String[]{\n                 \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n                 \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n                 \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n                 \"Amma\"\n         };\n-    \n+\n         for (final String key : keys) {\n             trie.put(key, key);\n         }\n-        \n+\n         SortedMap<String, String> map;\n         Iterator<String> iterator;\n-        \n+\n         map = trie.getPrefixedBy(\"Alice\", 2);\n         Assert.assertEquals(8, map.size());\n         Assert.assertEquals(\"Alabama\", map.firstKey());\n         Assert.assertEquals(\"Allie\", iterator.next());\n         Assert.assertEquals(\"Alliese\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"BAlice\", 1, 2);\n         Assert.assertEquals(8, map.size());\n         Assert.assertEquals(\"Alabama\", map.firstKey());\n         Assert.assertEquals(\"Alliese\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n     }\n-    \n+\n     @Test\n     public void testPrefixedByRemoval() {\n-        final PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie\n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n+\n         final String[] keys = new String[]{\n                 \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n                 \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n         for (final String key : keys) {\n             trie.put(key, key);\n         }\n-        \n+\n         SortedMap<String, String> map = trie.getPrefixedBy(\"Al\");\n         Assert.assertEquals(8, map.size());\n         Iterator<String> iter = map.keySet().iterator();\n         Assert.assertEquals(\"Allie\", iter.next());\n         Assert.assertEquals(\"Alliese\", iter.next());\n         Assert.assertFalse(iter.hasNext());\n-        \n+\n         map = trie.getPrefixedBy(\"Ak\");\n         Assert.assertEquals(2, map.size());\n         iter = map.keySet().iterator();\n \n     @Test\n     public void testTraverseWithAllNullBitKey() {\n-        final PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie\n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n+\n         //\n         // One entry in the Trie\n         // Entry is stored at the root\n         //\n-        \n+\n         // trie.put(\"\", \"All Bits Are Zero\");\n         trie.put(\"\\0\", \"All Bits Are Zero\");\n-        \n+\n         //\n         //  / (\"\")   <-- root\n         //  \\_/  \\\n         //       null\n         //\n-        \n+\n         final List<String> strings = new ArrayList<String>();\n         trie.traverse(new Cursor<String, String>() {\n             public Decision select(final Entry<? extends String, ? extends String> entry) {\n                 return Decision.CONTINUE;\n             }\n         });\n-        \n+\n         Assert.assertEquals(1, strings.size());\n-        \n+\n         strings.clear();\n         for (final String s : trie.values()) {\n             strings.add(s);\n         }\n         Assert.assertEquals(1, strings.size());\n     }\n-    \n+\n     @Test\n     public void testSelectWithAllNullBitKey() {\n-        final PatriciaTrie<String, String> trie \n+        final PatriciaTrie<String, String> trie\n             = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-        \n+\n         // trie.put(\"\", \"All Bits Are Zero\");\n         trie.put(\"\\0\", \"All Bits Are Zero\");\n-        \n+\n         final List<String> strings = new ArrayList<String>();\n         trie.select(\"Hello\", new Cursor<String, String>() {\n             public Decision select(final Entry<? extends String, ? extends String> entry) {\n         });\n         Assert.assertEquals(1, strings.size());\n     }\n-    \n+\n     private static class TestCursor implements Cursor<Object, Object> {\n         private final List<Object> keys;\n         private final List<Object> values;\n         private Object selectFor;\n         private List<Object> toRemove;\n         private int index = 0;\n-        \n+\n         TestCursor(final Object... objects) {\n             if(objects.length % 2 != 0) {\n                 throw new IllegalArgumentException(\"must be * 2\");\n             }\n-            \n+\n             keys = new ArrayList<Object>(objects.length / 2);\n             values = new ArrayList<Object>(keys.size());\n             toRemove = Collections.emptyList();\n                 values.add(objects[++i]);\n             }\n         }\n-        \n+\n         void selectFor(final Object object) {\n             selectFor = object;\n         }\n-        \n+\n         void addToRemove(final Object... objects) {\n             toRemove = new ArrayList<Object>(Arrays.asList(objects));\n         }\n-        \n+\n         void remove(final Object... objects) {\n             for (final Object object : objects) {\n                 final int idx = keys.indexOf(object);\n                 values.remove(idx);\n             }\n         }\n-        \n+\n         void starting() {\n             index = 0;\n         }\n-        \n+\n         public void checkKey(final Object k) {\n             Assert.assertEquals(keys.get(index++), k);\n         }\n-        \n+\n         public void checkValue(final Object o) {\n             Assert.assertEquals(values.get(index++), o);\n         }\n             Assert.assertEquals(keys.get(index), entry.getKey());\n             Assert.assertEquals(values.get(index), entry.getValue());\n             index++;\n-            \n+\n             if(toRemove.contains(entry.getKey())) {\n               // System.out.println(\"Removing: \" + entry.getKey());\n                 index--;\n                 values.remove(index);\n                 toRemove.remove(entry.getKey());\n                 return Decision.REMOVE;\n-            } \n-            \n+            }\n+\n             if(selectFor != null && selectFor.equals(entry.getKey())) {\n                 return Decision.EXIT;\n             } else {\n                 return Decision.CONTINUE;\n             }\n         }\n-        \n+\n         void finished() {\n             Assert.assertEquals(keys.size(), index);\n         }\n     }\n-    \n+\n     private static void assertEqualArrays(final Object[] a, final Object[] b) {\n         Assert.assertTrue(Arrays.equals(a, b));\n     }", "timestamp": 1367332055, "metainfo": ""}