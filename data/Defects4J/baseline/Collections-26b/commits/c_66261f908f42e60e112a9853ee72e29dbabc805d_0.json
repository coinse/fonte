{"sha": "66261f908f42e60e112a9853ee72e29dbabc805d", "log": "fix indentation  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PassiveExpiringMap.java\n  * synchronization.\n  * </p>\n  * \n- * @param <K>\n- *            the type of the keys in the map\n- * \n- * @param <V>\n- *            the type of the values in the map\n- * \n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n  * @since 4.0\n  * @version $Id: $\n  */\n-public class PassiveExpiringMap<K, V> extends AbstractMapDecorator<K, V>\n-\t\timplements Serializable {\n-\n-\t/**\n-\t * A {@link ExpirationPolicy} that returns a expiration time that is a\n-\t * constant about of time in the future from the current time.\n-\t * \n-\t * @param <K>\n-\t *            the type of the keys in the map\n-\t * @param <V>\n-\t *            the type of the values in the map\n-\t * \n-\t * @since 4.0\n-\t * @version $Id: $\n-\t */\n-\tpublic static class ConstantTimeToLiveExpirationPolicy<K, V> implements\n-\t\t\tExpirationPolicy<K, V> {\n-\n-\t\t/** Serialization version */\n-\t\tprivate static final long serialVersionUID = 1L;\n-\n-\t\t/** the constant time-to-live value measured in milliseconds. */\n-\t\tprivate final long timeToLiveMillis;\n-\n-\t\t/**\n-\t\t * Default constructor. Constructs a policy using a negative\n-\t\t * time-to-live value that results in entries never expiring.\n-\t\t */\n-\t\tpublic ConstantTimeToLiveExpirationPolicy() {\n-\t\t\tthis(-1L);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Construct a policy with the given time-to-live constant measured in\n-\t\t * milliseconds. A negative time-to-live value indicates entries never\n-\t\t * expire. A zero time-to-live value indicates entries expire (nearly)\n-\t\t * immediately.\n-\t\t * \n-\t\t * @param timeToLiveMillis\n-\t\t *            the constant amount of time (in milliseconds) an entry is\n-\t\t *            available before it expires. A negative value results in\n-\t\t *            entries that NEVER expire. A zero value results in entries\n-\t\t *            that ALWAYS expire.\n-\t\t */\n-\t\tpublic ConstantTimeToLiveExpirationPolicy(long timeToLiveMillis) {\n-\t\t\tsuper();\n-\t\t\tthis.timeToLiveMillis = timeToLiveMillis;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Construct a policy with the given time-to-live constant measured in\n-\t\t * the given time unit of measure.\n-\t\t * \n-\t\t * @param timeToLive\n-\t\t *            the constant amount of time an entry is available before\n-\t\t *            it expires. A negative value results in entries that NEVER\n-\t\t *            expire. A zero value results in entries that ALWAYS\n-\t\t *            expire.\n-\t\t * @param timeUnit\n-\t\t *            the unit of time for the <code>timeToLive</code>\n-\t\t *            parameter, must not be null.\n-\t\t * @throws IllegalArgumentException\n-\t\t *             if the time unit is null.\n-\t\t */\n-\t\tpublic ConstantTimeToLiveExpirationPolicy(long timeToLive,\n-\t\t\t\tTimeUnit timeUnit) {\n-\t\t\tthis(validateAndConvertToMillis(timeToLive, TimeUnit.MILLISECONDS));\n-\t\t}\n-\n-\t\t/**\n-\t\t * Determine the expiration time for the given key-value entry.\n-\t\t * \n-\t\t * @param key\n-\t\t *            the key for the entry (ignored).\n-\t\t * @param value\n-\t\t *            the value for the entry (ignored).\n-\t\t * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n-\t\t *         {@link #timeToLiveMillis} +\n-\t\t *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n-\t\t *         is returned indicating the entry never expires.\n-\t\t */\n-\t\tpublic long expirationTime(K key, V value) {\n-\t\t\tif (timeToLiveMillis >= 0L) {\n-\t\t\t\t// avoid numerical overflow\n-\t\t\t\tlong now = System.currentTimeMillis();\n-\t\t\t\tif (now > Long.MAX_VALUE - timeToLiveMillis) {\n-\t\t\t\t\t// expiration would be greater than Long.MAX_VALUE\n-\t\t\t\t\t// never expire\n-\t\t\t\t\treturn -1;\n-\t\t\t\t}\n-\n-\t\t\t\t// timeToLiveMillis in the future\n-\t\t\t\treturn now + timeToLiveMillis;\n-\t\t\t}\n-\t\t\t\n-\t\t\t// never expire\n-\t\t\treturn -1L;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * A policy to determine the expiration time for key-value entries.\n-\t * \n-\t * @param <K>\n-\t *            the key object type.\n-\t * @param <V>\n-\t *            the value object type\n-\t * \n-\t * @since 4.0\n-\t * @version $Id: $\n-\t */\n-\tpublic static interface ExpirationPolicy<K, V> extends Serializable {\n-\t\t/**\n-\t\t * Determine the expiration time for the given key-value entry.\n-\t\t * \n-\t\t * @param key\n-\t\t *            the key for the entry.\n-\t\t * @param value\n-\t\t *            the value for the entry.\n-\t\t * @return the expiration time value measured in milliseconds. A\n-\t\t *         negative return value indicates the entry never expires.\n-\t\t */\n-\t\tlong expirationTime(K key, V value);\n-\t}\n-\n-\t/** Serialization version */\n-\tprivate static final long serialVersionUID = 1L;\n-\n-\t/**\n-\t * First validate the input parameters. If the parameters are valid, convert\n-\t * the given time measured in the given units to the same time measured in\n-\t * milliseconds. If the parameters are invalid, an\n-\t * {@link IllegalArgumentException} is thrown.\n-\t * \n-\t * @param timeToLive\n-\t *            the constant amount of time an entry is available before it\n-\t *            expires. A negative value results in entries that NEVER\n-\t *            expire. A zero value results in entries that ALWAYS expire.\n-\t * @param timeUnit\n-\t *            the unit of time for the <code>timeToLive</code> parameter,\n-\t *            must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the time unit is null.\n-\t */\n-\tprivate static long validateAndConvertToMillis(long timeToLive,\n-\t\t\tTimeUnit timeUnit) {\n-\t\tif (timeUnit == null) {\n-\t\t\tthrow new IllegalArgumentException(\"Time unit must not be null\");\n-\t\t}\n-\t\treturn timeUnit.convert(timeToLive, TimeUnit.MILLISECONDS);\n-\t}\n-\n-\t/** map used to manage expiration times for the actual map entries. */\n-\tprivate final Map<Object, Long> expirationMap = new HashMap<Object, Long>();\n-\n-\t/** the policy used to determine time-to-live values for map entries. */\n-\tprivate final ExpirationPolicy<K, V> expiringPolicy;\n-\n-\t/**\n-\t * Default constructor. Constructs a map decorator that results in entries\n-\t * NEVER expiring.\n-\t */\n-\tpublic PassiveExpiringMap() {\n-\t\tthis(-1L);\n-\t}\n-\n-\t/**\n-\t * Construct a map decorator using the given expiration policy to determine\n-\t * expiration times.\n-\t * \n-\t * @param expiringPolicy\n-\t *            the policy used to determine expiration times of entries as\n-\t *            they are added.\n-\t */\n-\tpublic PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy) {\n-\t\tthis(expiringPolicy, new HashMap<K, V>());\n-\t}\n-\n-\t/**\n-\t * Construct a map decorator that decorates the given map and uses the given\n-\t * expiration policy to determine expiration times. If there are any\n-\t * elements already in the map being decorated, they will NEVER expire\n-\t * unless they are replaced.\n-\t * \n-\t * @param expiringPolicy\n-\t *            the policy used to determine expiration times of entries as\n-\t *            they are added.\n-\t * @param map\n-\t *            the map to decorate, must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the map is null.\n-\t */\n-\tpublic PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy,\n-\t\t\tMap<K, V> map) {\n-\t\tsuper(map);\n-\t\tif (expiringPolicy == null) {\n-\t\t\tthrow new IllegalArgumentException(\"Policy must not be null.\");\n-\t\t}\n-\t\tthis.expiringPolicy = expiringPolicy;\n-\t}\n-\n-\t/**\n-\t * Construct a map decorator that decorates the given map using the given\n-\t * time-to-live value measured in milliseconds to create and use a\n-\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n-\t * \n-\t * @param timeToLiveMillis\n-\t *            the constant amount of time (in milliseconds) an entry is\n-\t *            available before it expires. A negative value results in\n-\t *            entries that NEVER expire. A zero value results in entries\n-\t *            that ALWAYS expire.\n-\t */\n-\tpublic PassiveExpiringMap(long timeToLiveMillis) {\n-\t\tthis(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n-\t\t\t\tnew HashMap<K, V>());\n-\t}\n-\n-\t/**\n-\t * Construct a map decorator using the given time-to-live value measured in\n-\t * milliseconds to create and use a\n-\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. If there\n-\t * are any elements already in the map being decorated, they will NEVER\n-\t * expire unless they are replaced.\n-\t * \n-\t * @param timeToLiveMillis\n-\t *            the constant amount of time (in milliseconds) an entry is\n-\t *            available before it expires. A negative value results in\n-\t *            entries that NEVER expire. A zero value results in entries\n-\t *            that ALWAYS expire.\n-\t * @param map\n-\t *            the map to decorate, must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the map is null.\n-\t */\n-\tpublic PassiveExpiringMap(long timeToLiveMillis, Map<K, V> map) {\n-\t\tthis(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n-\t\t\t\tmap);\n-\t}\n-\n-\t/**\n-\t * Construct a map decorator using the given time-to-live value measured in\n-\t * the given time units of measure to create and use a\n-\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n-\t * \n-\t * @param timeToLive\n-\t *            the constant amount of time an entry is available before it\n-\t *            expires. A negative value results in entries that NEVER\n-\t *            expire. A zero value results in entries that ALWAYS expire.\n-\t * @param timeUnit\n-\t *            the unit of time for the <code>timeToLive</code> parameter,\n-\t *            must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the time unit is null.\n-\t */\n-\tpublic PassiveExpiringMap(long timeToLive, TimeUnit timeUnit) {\n-\t\tthis(validateAndConvertToMillis(timeToLive, timeUnit));\n-\t}\n-\n-\t/**\n-\t * Construct a map decorator that decorates the given map using the given\n-\t * time-to-live value measured in the given time units of measure to create\n-\t * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. This policy\n-\t * is used to determine expiration times. If there are any elements already\n-\t * in the map being decorated, they will NEVER expire unless they are\n-\t * replaced.\n-\t * \n-\t * @param timeToLive\n-\t *            the constant amount of time an entry is available before it\n-\t *            expires. A negative value results in entries that NEVER\n-\t *            expire. A zero value results in entries that ALWAYS expire.\n-\t * @param timeUnit\n-\t *            the unit of time for the <code>timeToLive</code> parameter,\n-\t *            must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the time unit is null.\n-\t * @param map\n-\t *            the map to decorate, must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the map is null.\n-\t */\n-\tpublic PassiveExpiringMap(long timeToLive, TimeUnit timeUnit, Map<K, V> map) {\n-\t\tthis(validateAndConvertToMillis(timeToLive, timeUnit), map);\n-\t}\n-\n-\t/**\n-\t * Constructs a map decorator that decorates the given map and results in\n-\t * entries NEVER expiring. If there are any elements already in the map\n-\t * being decorated, they also will NEVER expire.\n-\t * \n-\t * @param map\n-\t *            the map to decorate, must not be null.\n-\t * @throws IllegalArgumentException\n-\t *             if the map is null.\n-\t */\n-\tpublic PassiveExpiringMap(Map<K, V> map) {\n-\t\tthis(-1L, map);\n-\t}\n-\n-\t/**\n-\t * Normal {@link Map#clear()} behavior with the addition of clearing all\n-\t * expiration entries as well.\n-\t */\n-\t@Override\n-\tpublic void clear() {\n-\t\tsuper.clear();\n-\t\texpirationMap.clear();\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to determining the\n-\t * contains result.\n-\t */\n-\t@Override\n-\tpublic boolean containsKey(Object key) {\n-\t\tremoveIfExpired(key, now());\n-\t\treturn super.containsKey(key);\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to determining the\n-\t * contains result.\n-\t */\n-\t@Override\n-\tpublic boolean containsValue(Object value) {\n-\t\tremoveAllExpired(now());\n-\t\treturn super.containsValue(value);\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to returning the entry\n-\t * set.\n-\t */\n-\t@Override\n-\tpublic Set<Entry<K, V>> entrySet() {\n-\t\tremoveAllExpired(now());\n-\t\treturn super.entrySet();\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to returning the entry\n-\t * value.\n-\t */\n-\t@Override\n-\tpublic V get(Object key) {\n-\t\tremoveIfExpired(key, now());\n-\t\treturn super.get(key);\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to determining if it\n-\t * is empty.\n-\t */\n-\t@Override\n-\tpublic boolean isEmpty() {\n-\t\tremoveAllExpired(now());\n-\t\treturn super.isEmpty();\n-\t}\n-\n-\t/**\n-\t * Determines if the given expiration time is less than <code>now</code>\n-\t * \n-\t * @param now\n-\t *            the time in milliseconds used to compare against the\n-\t *            expiration time.\n-\t * @param expirationTimeObject\n-\t *            the expiration time value retrieved from\n-\t *            {@link #expirationMap}, can be null.\n-\t * @return <code>true</code> if <code>expirationTimeObject</code> is &ge; 0\n-\t *         and <code>expirationTimeObject</code> &lt; <code>now</code>.\n-\t *         <code>false</code> otherwise.\n-\t */\n-\tprivate boolean isExpired(long now, Long expirationTimeObject) {\n-\t\tif (expirationTimeObject != null) {\n-\t\t\tlong expirationTime = expirationTimeObject.longValue();\n-\t\t\treturn (expirationTime >= 0 && now >= expirationTime);\n-\t\t}\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to returning the key\n-\t * set.\n-\t */\n-\t@Override\n-\tpublic Set<K> keySet() {\n-\t\tremoveAllExpired(now());\n-\t\treturn super.keySet();\n-\t}\n-\n-\t/**\n-\t * The current time in milliseconds.\n-\t */\n-\tprivate long now() {\n-\t\treturn System.currentTimeMillis();\n-\t}\n-\n-\t@Override\n-\tpublic V put(K key, V value) {\n-\t\treturn put(key, value, now());\n-\t}\n-\n-\t/**\n-\t * Add the given key-value pair to this map as well as recording the entry's\n-\t * expiration time based on the current time in milliseconds,\n-\t * <code>now</code> and this map's {@link #expiringPolicy}.\n-\t */\n-\tprivate V put(K key, V value, long now) {\n-\t\t// record expiration time of new entry\n-\t\tlong expirationTime = expiringPolicy.expirationTime(key, value);\n-\t\texpirationMap.put(key, Long.valueOf(expirationTime));\n-\n-\t\treturn super.put(key, value);\n-\t}\n-\n-\t@Override\n-\tpublic void putAll(Map<? extends K, ? extends V> mapToCopy) {\n-\t\tfor (Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n-\t\t\tput(entry.getKey(), entry.getValue());\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Normal {@link Map#remove(Object)} behavior with the addition of removing\n-\t * any expiration entry as well.\n-\t */\n-\t@Override\n-\tpublic V remove(Object key) {\n-\t\texpirationMap.remove(key);\n-\t\treturn super.remove(key);\n-\t}\n-\n-\t/**\n-\t * Removes all entries in the map whose expiration time is less than\n-\t * <code>now</code>. The exceptions are entries with negative expiration\n-\t * times; those entries are never removed.\n-\t * \n-\t * @see #isExpired(long, Long)\n-\t */\n-\tprivate void removeAllExpired(long now) {\n-\t\tIterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet()\n-\t\t\t\t.iterator();\n-\t\twhile (iter.hasNext()) {\n-\t\t\tMap.Entry<Object, Long> expirationEntry = iter.next();\n-\t\t\tif (isExpired(now, expirationEntry.getValue())) {\n-\t\t\t\t// remove entry from collection\n-\t\t\t\tsuper.remove(expirationEntry.getKey());\n-\t\t\t\t// remove entry from expiration map\n-\t\t\t\titer.remove();\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Removes the entry with the given key if the entry's expiration time is\n-\t * less than <code>now</code>. If the entry has a negative expiration time,\n-\t * the entry is never removed.\n-\t */\n-\tprivate void removeIfExpired(Object key, long now) {\n-\t\tLong expirationTimeObject = expirationMap.get(key);\n-\t\tif (isExpired(now, expirationTimeObject)) {\n-\t\t\tremove(key);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to returning the size.\n-\t */\n-\t@Override\n-\tpublic int size() {\n-\t\tremoveAllExpired(now());\n-\t\treturn super.size();\n-\t}\n-\n-\t/**\n-\t * Read the map in using a custom routine.\n-\t * \n-\t * @param in\n-\t *            the input stream\n-\t * @throws IOException\n-\t * @throws ClassNotFoundException\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t// (1) should only fail if input stream is incorrect\n-\tprivate void readObject(ObjectInputStream in) throws IOException,\n-\t\t\tClassNotFoundException {\n-\t\tin.defaultReadObject();\n-\t\tmap = (Map<K, V>) in.readObject(); // (1)\n-\t}\n-\n-\t/**\n-\t * Write the map out using a custom routine.\n-\t * \n-\t * @param out\n-\t *            the output stream\n-\t * @throws IOException\n-\t */\n-\tprivate void writeObject(ObjectOutputStream out) throws IOException {\n-\t\tout.defaultWriteObject();\n-\t\tout.writeObject(map);\n-\t}\n-\n-\t/**\n-\t * All expired entries are removed from the map prior to returning the value\n-\t * collection.\n-\t */\n-\t@Override\n-\tpublic Collection<V> values() {\n-\t\tremoveAllExpired(now());\n-\t\treturn super.values();\n-\t}\n+public class PassiveExpiringMap<K, V>\n+    extends AbstractMapDecorator<K, V>\n+    implements Serializable {\n+\n+    /**\n+     * A {@link ExpirationPolicy} that returns a expiration time that is a\n+     * constant about of time in the future from the current time.\n+     * \n+     * @param <K> the type of the keys in the map\n+     * @param <V> the type of the values in the map\n+     * @since 4.0\n+     * @version $Id: $\n+     */\n+    public static class ConstantTimeToLiveExpirationPolicy<K, V>\n+        implements ExpirationPolicy<K, V> {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 1L;\n+\n+        /** the constant time-to-live value measured in milliseconds. */\n+        private final long timeToLiveMillis;\n+\n+        /**\n+         * Default constructor. Constructs a policy using a negative\n+         * time-to-live value that results in entries never expiring.\n+         */\n+        public ConstantTimeToLiveExpirationPolicy() {\n+            this(-1L);\n+        }\n+\n+        /**\n+         * Construct a policy with the given time-to-live constant measured in\n+         * milliseconds. A negative time-to-live value indicates entries never\n+         * expire. A zero time-to-live value indicates entries expire (nearly)\n+         * immediately.\n+         * \n+         * @param timeToLiveMillis the constant amount of time (in milliseconds)\n+         *        an entry is available before it expires. A negative value\n+         *        results in entries that NEVER expire. A zero value results in\n+         *        entries that ALWAYS expire.\n+         */\n+        public ConstantTimeToLiveExpirationPolicy(long timeToLiveMillis) {\n+            super();\n+            this.timeToLiveMillis = timeToLiveMillis;\n+        }\n+\n+        /**\n+         * Construct a policy with the given time-to-live constant measured in\n+         * the given time unit of measure.\n+         * \n+         * @param timeToLive the constant amount of time an entry is available\n+         *        before it expires. A negative value results in entries that\n+         *        NEVER expire. A zero value results in entries that ALWAYS\n+         *        expire.\n+         * @param timeUnit the unit of time for the <code>timeToLive</code>\n+         *        parameter, must not be null.\n+         * @throws IllegalArgumentException if the time unit is null.\n+         */\n+        public ConstantTimeToLiveExpirationPolicy(long timeToLive,\n+                                                  TimeUnit timeUnit) {\n+            this(validateAndConvertToMillis(timeToLive, TimeUnit.MILLISECONDS));\n+        }\n+\n+        /**\n+         * Determine the expiration time for the given key-value entry.\n+         * \n+         * @param key the key for the entry (ignored).\n+         * @param value the value for the entry (ignored).\n+         * @return if {@link #timeToLiveMillis} &ge; 0, an expiration time of\n+         *         {@link #timeToLiveMillis} +\n+         *         {@link System#currentTimeMillis()} is returned. Otherwise, -1\n+         *         is returned indicating the entry never expires.\n+         */\n+        public long expirationTime(K key, V value) {\n+            if (timeToLiveMillis >= 0L) {\n+                // avoid numerical overflow\n+                long now = System.currentTimeMillis();\n+                if (now > Long.MAX_VALUE - timeToLiveMillis) {\n+                    // expiration would be greater than Long.MAX_VALUE\n+                    // never expire\n+                    return -1;\n+                }\n+\n+                // timeToLiveMillis in the future\n+                return now + timeToLiveMillis;\n+            }\n+\n+            // never expire\n+            return -1L;\n+        }\n+    }\n+\n+    /**\n+     * A policy to determine the expiration time for key-value entries.\n+     * \n+     * @param <K> the key object type.\n+     * @param <V> the value object type\n+     * @since 4.0\n+     * @version $Id: $\n+     */\n+    public static interface ExpirationPolicy<K, V>\n+        extends Serializable {\n+\n+        /**\n+         * Determine the expiration time for the given key-value entry.\n+         * \n+         * @param key the key for the entry.\n+         * @param value the value for the entry.\n+         * @return the expiration time value measured in milliseconds. A\n+         *         negative return value indicates the entry never expires.\n+         */\n+        long expirationTime(K key, V value);\n+    }\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * First validate the input parameters. If the parameters are valid, convert\n+     * the given time measured in the given units to the same time measured in\n+     * milliseconds. If the parameters are invalid, an\n+     * {@link IllegalArgumentException} is thrown.\n+     * \n+     * @param timeToLive the constant amount of time an entry is available\n+     *        before it expires. A negative value results in entries that NEVER\n+     *        expire. A zero value results in entries that ALWAYS expire.\n+     * @param timeUnit the unit of time for the <code>timeToLive</code>\n+     *        parameter, must not be null.\n+     * @throws IllegalArgumentException if the time unit is null.\n+     */\n+    private static long validateAndConvertToMillis(long timeToLive,\n+                                                   TimeUnit timeUnit) {\n+        if (timeUnit == null) {\n+            throw new IllegalArgumentException(\"Time unit must not be null\");\n+        }\n+        return timeUnit.convert(timeToLive, TimeUnit.MILLISECONDS);\n+    }\n+\n+    /** map used to manage expiration times for the actual map entries. */\n+    private final Map<Object, Long> expirationMap = new HashMap<Object, Long>();\n+\n+    /** the policy used to determine time-to-live values for map entries. */\n+    private final ExpirationPolicy<K, V> expiringPolicy;\n+\n+    /**\n+     * Default constructor. Constructs a map decorator that results in entries\n+     * NEVER expiring.\n+     */\n+    public PassiveExpiringMap() {\n+        this(-1L);\n+    }\n+\n+    /**\n+     * Construct a map decorator using the given expiration policy to determine\n+     * expiration times.\n+     * \n+     * @param expiringPolicy the policy used to determine expiration times of\n+     *        entries as they are added.\n+     */\n+    public PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy) {\n+        this(expiringPolicy, new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * Construct a map decorator that decorates the given map and uses the given\n+     * expiration policy to determine expiration times. If there are any\n+     * elements already in the map being decorated, they will NEVER expire\n+     * unless they are replaced.\n+     * \n+     * @param expiringPolicy the policy used to determine expiration times of\n+     *        entries as they are added.\n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(ExpirationPolicy<K, V> expiringPolicy,\n+                              Map<K, V> map) {\n+        super(map);\n+        if (expiringPolicy == null) {\n+            throw new IllegalArgumentException(\"Policy must not be null.\");\n+        }\n+        this.expiringPolicy = expiringPolicy;\n+    }\n+\n+    /**\n+     * Construct a map decorator that decorates the given map using the given\n+     * time-to-live value measured in milliseconds to create and use a\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n+     * \n+     * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n+     *        entry is available before it expires. A negative value results in\n+     *        entries that NEVER expire. A zero value results in entries that\n+     *        ALWAYS expire.\n+     */\n+    public PassiveExpiringMap(long timeToLiveMillis) {\n+        this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n+             new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * Construct a map decorator using the given time-to-live value measured in\n+     * milliseconds to create and use a\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. If there\n+     * are any elements already in the map being decorated, they will NEVER\n+     * expire unless they are replaced.\n+     * \n+     * @param timeToLiveMillis the constant amount of time (in milliseconds) an\n+     *        entry is available before it expires. A negative value results in\n+     *        entries that NEVER expire. A zero value results in entries that\n+     *        ALWAYS expire.\n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(long timeToLiveMillis, Map<K, V> map) {\n+        this(new ConstantTimeToLiveExpirationPolicy<K, V>(timeToLiveMillis),\n+             map);\n+    }\n+\n+    /**\n+     * Construct a map decorator using the given time-to-live value measured in\n+     * the given time units of measure to create and use a\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy.\n+     * \n+     * @param timeToLive the constant amount of time an entry is available\n+     *        before it expires. A negative value results in entries that NEVER\n+     *        expire. A zero value results in entries that ALWAYS expire.\n+     * @param timeUnit the unit of time for the <code>timeToLive</code>\n+     *        parameter, must not be null.\n+     * @throws IllegalArgumentException if the time unit is null.\n+     */\n+    public PassiveExpiringMap(long timeToLive, TimeUnit timeUnit) {\n+        this(validateAndConvertToMillis(timeToLive, timeUnit));\n+    }\n+\n+    /**\n+     * Construct a map decorator that decorates the given map using the given\n+     * time-to-live value measured in the given time units of measure to create\n+     * {@link ConstantTimeToLiveExpirationPolicy} expiration policy. This policy\n+     * is used to determine expiration times. If there are any elements already\n+     * in the map being decorated, they will NEVER expire unless they are\n+     * replaced.\n+     * \n+     * @param timeToLive the constant amount of time an entry is available\n+     *        before it expires. A negative value results in entries that NEVER\n+     *        expire. A zero value results in entries that ALWAYS expire.\n+     * @param timeUnit the unit of time for the <code>timeToLive</code>\n+     *        parameter, must not be null.\n+     * @throws IllegalArgumentException if the time unit is null.\n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(long timeToLive, TimeUnit timeUnit, Map<K, V> map) {\n+        this(validateAndConvertToMillis(timeToLive, timeUnit), map);\n+    }\n+\n+    /**\n+     * Constructs a map decorator that decorates the given map and results in\n+     * entries NEVER expiring. If there are any elements already in the map\n+     * being decorated, they also will NEVER expire.\n+     * \n+     * @param map the map to decorate, must not be null.\n+     * @throws IllegalArgumentException if the map is null.\n+     */\n+    public PassiveExpiringMap(Map<K, V> map) {\n+        this(-1L, map);\n+    }\n+\n+    /**\n+     * Normal {@link Map#clear()} behavior with the addition of clearing all\n+     * expiration entries as well.\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        expirationMap.clear();\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to determining the\n+     * contains result.\n+     */\n+    @Override\n+    public boolean containsKey(Object key) {\n+        removeIfExpired(key, now());\n+        return super.containsKey(key);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to determining the\n+     * contains result.\n+     */\n+    @Override\n+    public boolean containsValue(Object value) {\n+        removeAllExpired(now());\n+        return super.containsValue(value);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the entry\n+     * set.\n+     */\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+        removeAllExpired(now());\n+        return super.entrySet();\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the entry\n+     * value.\n+     */\n+    @Override\n+    public V get(Object key) {\n+        removeIfExpired(key, now());\n+        return super.get(key);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to determining if it\n+     * is empty.\n+     */\n+    @Override\n+    public boolean isEmpty() {\n+        removeAllExpired(now());\n+        return super.isEmpty();\n+    }\n+\n+    /**\n+     * Determines if the given expiration time is less than <code>now</code>\n+     * \n+     * @param now the time in milliseconds used to compare against the\n+     *        expiration time.\n+     * @param expirationTimeObject the expiration time value retrieved from\n+     *        {@link #expirationMap}, can be null.\n+     * @return <code>true</code> if <code>expirationTimeObject</code> is &ge; 0\n+     *         and <code>expirationTimeObject</code> &lt; <code>now</code>.\n+     *         <code>false</code> otherwise.\n+     */\n+    private boolean isExpired(long now, Long expirationTimeObject) {\n+        if (expirationTimeObject != null) {\n+            long expirationTime = expirationTimeObject.longValue();\n+            return (expirationTime >= 0 && now >= expirationTime);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the key\n+     * set.\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        removeAllExpired(now());\n+        return super.keySet();\n+    }\n+\n+    /**\n+     * The current time in milliseconds.\n+     */\n+    private long now() {\n+        return System.currentTimeMillis();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        return put(key, value, now());\n+    }\n+\n+    /**\n+     * Add the given key-value pair to this map as well as recording the entry's\n+     * expiration time based on the current time in milliseconds,\n+     * <code>now</code> and this map's {@link #expiringPolicy}.\n+     */\n+    private V put(K key, V value, long now) {\n+        // record expiration time of new entry\n+        long expirationTime = expiringPolicy.expirationTime(key, value);\n+        expirationMap.put(key, Long.valueOf(expirationTime));\n+\n+        return super.put(key, value);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n+        for (Map.Entry<? extends K, ? extends V> entry : mapToCopy.entrySet()) {\n+            put(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Normal {@link Map#remove(Object)} behavior with the addition of removing\n+     * any expiration entry as well.\n+     */\n+    @Override\n+    public V remove(Object key) {\n+        expirationMap.remove(key);\n+        return super.remove(key);\n+    }\n+\n+    /**\n+     * Removes all entries in the map whose expiration time is less than\n+     * <code>now</code>. The exceptions are entries with negative expiration\n+     * times; those entries are never removed.\n+     * \n+     * @see #isExpired(long, Long)\n+     */\n+    private void removeAllExpired(long now) {\n+        Iterator<Map.Entry<Object, Long>> iter = expirationMap.entrySet()\n+            .iterator();\n+        while (iter.hasNext()) {\n+            Map.Entry<Object, Long> expirationEntry = iter.next();\n+            if (isExpired(now, expirationEntry.getValue())) {\n+                // remove entry from collection\n+                super.remove(expirationEntry.getKey());\n+                // remove entry from expiration map\n+                iter.remove();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Removes the entry with the given key if the entry's expiration time is\n+     * less than <code>now</code>. If the entry has a negative expiration time,\n+     * the entry is never removed.\n+     */\n+    private void removeIfExpired(Object key, long now) {\n+        Long expirationTimeObject = expirationMap.get(key);\n+        if (isExpired(now, expirationTimeObject)) {\n+            remove(key);\n+        }\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the size.\n+     */\n+    @Override\n+    public int size() {\n+        removeAllExpired(now());\n+        return super.size();\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     * \n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    // (1) should only fail if input stream is incorrect\n+    private void readObject(ObjectInputStream in)\n+        throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    /**\n+     * Write the map out using a custom routine.\n+     * \n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(ObjectOutputStream out)\n+        throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(map);\n+    }\n+\n+    /**\n+     * All expired entries are removed from the map prior to returning the value\n+     * collection.\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        removeAllExpired(now());\n+        return super.values();\n+    }\n }\n--- a/src/test/java/org/apache/commons/collections/map/TestPassiveExpiringMap.java\n+++ b/src/test/java/org/apache/commons/collections/map/TestPassiveExpiringMap.java\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.map.PassiveExpiringMap.ExpirationPolicy;\n \n-public class TestPassiveExpiringMap<K, V> extends AbstractTestMap<K, V> {\n-\n-\tprivate static class TestExpirationPolicy implements\n-\t\t\tExpirationPolicy<Integer, String> {\n-\n-\t\tprivate static final long serialVersionUID = 1L;\n-\n-\t\tpublic long expirationTime(Integer key, String value) {\n-\t\t\t// odd keys expire immediately, even keys never expire\n-\t\t\tif (key == null) {\n-\t\t\t\treturn 0;\n-\t\t\t}\n-\n-\t\t\tif (key.intValue() % 2 == 0) {\n-\t\t\t\treturn -1;\n-\t\t\t}\n-\n-\t\t\treturn 0;\n-\t\t}\n-\t}\n-\n-\tpublic static Test suite() {\n-\t\treturn BulkTest.makeSuite(TestPassiveExpiringMap.class);\n-\t}\n-\n-\tpublic TestPassiveExpiringMap(String testName) {\n-\t\tsuper(testName);\n-\t}\n-\n-\t// public void testCreate() throws Exception {\n-\t// writeExternalFormToDisk((java.io.Serializable) makeObject(),\n-\t// \"PassiveExpiringMap.emptyCollection.version4.obj\");\n-\t//\n-\t// writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n-\t// \"PassiveExpiringMap.fullCollection.version4.obj\");\n-\t// }\n-\n-\t@Override\n-\tpublic String getCompatibilityVersion() {\n-\t\treturn \"4\";\n-\t}\n-\n-\tprivate Map<Integer, String> makeDecoratedTestMap() {\n-\t\tMap<Integer, String> m = new HashMap<Integer, String>();\n-\t\tm.put(Integer.valueOf(1), \"one\");\n-\t\tm.put(Integer.valueOf(2), \"two\");\n-\t\tm.put(Integer.valueOf(3), \"three\");\n-\t\tm.put(Integer.valueOf(4), \"four\");\n-\t\tm.put(Integer.valueOf(5), \"five\");\n-\t\tm.put(Integer.valueOf(6), \"six\");\n-\t\treturn new PassiveExpiringMap<Integer, String>(\n-\t\t\t\tnew TestExpirationPolicy(), m);\n-\t}\n-\n-\t@Override\n-\tpublic Map<K, V> makeObject() {\n-\t\treturn new PassiveExpiringMap<K, V>();\n-\t}\n-\n-\tprivate Map<Integer, String> makeTestMap() {\n-\t\tMap<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n-\t\t\t\tnew TestExpirationPolicy());\n-\t\tm.put(Integer.valueOf(1), \"one\");\n-\t\tm.put(Integer.valueOf(2), \"two\");\n-\t\tm.put(Integer.valueOf(3), \"three\");\n-\t\tm.put(Integer.valueOf(4), \"four\");\n-\t\tm.put(Integer.valueOf(5), \"five\");\n-\t\tm.put(Integer.valueOf(6), \"six\");\n-\t\treturn m;\n-\t}\n-\n-\tpublic void testConstructors() {\n-\t\ttry {\n-\t\t\tMap<String, String> map = null;\n-\t\t\tnew PassiveExpiringMap<String, String>(map);\n-\t\t\tfail(\"constructor - exception should have been thrown.\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// success\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tExpirationPolicy<String, String> policy = null;\n-\t\t\tnew PassiveExpiringMap<String, String>(policy);\n-\t\t\tfail(\"constructor - exception should have been thrown.\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// success\n-\t\t}\n-\n-\t\ttry {\n-\t\t\tTimeUnit unit = null;\n-\t\t\tnew PassiveExpiringMap<String, String>(10L, unit);\n-\t\t\tfail(\"constructor - exception should have been thrown.\");\n-\t\t} catch (IllegalArgumentException ex) {\n-\t\t\t// success\n-\t\t}\n-\t}\n-\n-\tpublic void testContainsKey() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertFalse(m.containsKey(Integer.valueOf(1)));\n-\t\tassertFalse(m.containsKey(Integer.valueOf(3)));\n-\t\tassertFalse(m.containsKey(Integer.valueOf(5)));\n-\t\tassertTrue(m.containsKey(Integer.valueOf(2)));\n-\t\tassertTrue(m.containsKey(Integer.valueOf(4)));\n-\t\tassertTrue(m.containsKey(Integer.valueOf(6)));\n-\t}\n-\n-\tpublic void testContainsValue() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertFalse(m.containsValue(\"one\"));\n-\t\tassertFalse(m.containsValue(\"three\"));\n-\t\tassertFalse(m.containsValue(\"five\"));\n-\t\tassertTrue(m.containsValue(\"two\"));\n-\t\tassertTrue(m.containsValue(\"four\"));\n-\t\tassertTrue(m.containsValue(\"six\"));\n-\t}\n-\n-\tpublic void testDecoratedMap() {\n-\t\t// entries shouldn't expire\n-\t\tMap<Integer, String> m = makeDecoratedTestMap();\n-\t\tassertEquals(6, m.size());\n-\t\tassertEquals(\"one\", m.get(Integer.valueOf(1)));\n-\n-\t\t// removing a single item shouldn't affect any other items\n-\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n-\t\tm.remove(Integer.valueOf(2));\n-\t\tassertEquals(5, m.size());\n-\t\tassertEquals(\"one\", m.get(Integer.valueOf(1)));\n-\t\tassertNull(m.get(Integer.valueOf(2)));\n-\n-\t\t// adding a single, even item shouldn't affect any other items\n-\t\tassertNull(m.get(Integer.valueOf(2)));\n-\t\tm.put(Integer.valueOf(2), \"two\");\n-\t\tassertEquals(6, m.size());\n-\t\tassertEquals(\"one\", m.get(Integer.valueOf(1)));\n-\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n-\n-\t\t// adding a single, odd item (one that expires) shouldn't affect any\n-\t\t// other items\n-\t\t// put the entry expires immediately\n-\t\tm.put(Integer.valueOf(1), \"one-one\");\n-\t\tassertEquals(5, m.size());\n-\t\tassertNull(m.get(Integer.valueOf(1)));\n-\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n-\t}\n-\n-\tpublic void testEntrySet() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertEquals(3, m.entrySet().size());\n-\t}\n-\n-\tpublic void testGet() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertNull(m.get(Integer.valueOf(1)));\n-\t\tassertEquals(\"two\", m.get(Integer.valueOf(2)));\n-\t\tassertNull(m.get(Integer.valueOf(3)));\n-\t\tassertEquals(\"four\", m.get(Integer.valueOf(4)));\n-\t\tassertNull(m.get(Integer.valueOf(5)));\n-\t\tassertEquals(\"six\", m.get(Integer.valueOf(6)));\n-\t}\n-\n-\tpublic void testIsEmpty() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertFalse(m.isEmpty());\n-\n-\t\t// remove just evens\n-\t\tm = makeTestMap();\n-\t\tm.remove(Integer.valueOf(2));\n-\t\tm.remove(Integer.valueOf(4));\n-\t\tm.remove(Integer.valueOf(6));\n-\t\tassertTrue(m.isEmpty());\n-\t}\n-\n-\tpublic void testKeySet() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertEquals(3, m.keySet().size());\n-\t}\n-\n-\tpublic void testSize() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertEquals(3, m.size());\n-\t}\n-\n-\tpublic void testValues() {\n-\t\tMap<Integer, String> m = makeTestMap();\n-\t\tassertEquals(3, m.values().size());\n-\t}\n-\n-\tpublic void testZeroTimeToLive() {\n-\t\t// item should not be available\n-\t\tPassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n-\t\t\t\t0L);\n-\t\tm.put(\"a\", \"b\");\n-\t\tassertNull(m.get(\"a\"));\n-\t}\n+public class TestPassiveExpiringMap<K, V>\n+    extends AbstractTestMap<K, V> {\n+\n+    private static class TestExpirationPolicy\n+        implements ExpirationPolicy<Integer, String> {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        public long expirationTime(Integer key, String value) {\n+            // odd keys expire immediately, even keys never expire\n+            if (key == null) {\n+                return 0;\n+            }\n+\n+            if (key.intValue() % 2 == 0) {\n+                return -1;\n+            }\n+\n+            return 0;\n+        }\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestPassiveExpiringMap.class);\n+    }\n+\n+    public TestPassiveExpiringMap(String testName) {\n+        super(testName);\n+    }\n+\n+    // public void testCreate() throws Exception {\n+    // writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+    // \"PassiveExpiringMap.emptyCollection.version4.obj\");\n+    //\n+    // writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+    // \"PassiveExpiringMap.fullCollection.version4.obj\");\n+    // }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    private Map<Integer, String> makeDecoratedTestMap() {\n+        Map<Integer, String> m = new HashMap<Integer, String>();\n+        m.put(Integer.valueOf(1), \"one\");\n+        m.put(Integer.valueOf(2), \"two\");\n+        m.put(Integer.valueOf(3), \"three\");\n+        m.put(Integer.valueOf(4), \"four\");\n+        m.put(Integer.valueOf(5), \"five\");\n+        m.put(Integer.valueOf(6), \"six\");\n+        return new PassiveExpiringMap<Integer, String>(\n+                                                       new TestExpirationPolicy(),\n+                                                       m);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeObject() {\n+        return new PassiveExpiringMap<K, V>();\n+    }\n+\n+    private Map<Integer, String> makeTestMap() {\n+        Map<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n+                                                                         new TestExpirationPolicy());\n+        m.put(Integer.valueOf(1), \"one\");\n+        m.put(Integer.valueOf(2), \"two\");\n+        m.put(Integer.valueOf(3), \"three\");\n+        m.put(Integer.valueOf(4), \"four\");\n+        m.put(Integer.valueOf(5), \"five\");\n+        m.put(Integer.valueOf(6), \"six\");\n+        return m;\n+    }\n+\n+    public void testConstructors() {\n+        try {\n+            Map<String, String> map = null;\n+            new PassiveExpiringMap<String, String>(map);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        try {\n+            ExpirationPolicy<String, String> policy = null;\n+            new PassiveExpiringMap<String, String>(policy);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        try {\n+            TimeUnit unit = null;\n+            new PassiveExpiringMap<String, String>(10L, unit);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testContainsKey() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.containsKey(Integer.valueOf(1)));\n+        assertFalse(m.containsKey(Integer.valueOf(3)));\n+        assertFalse(m.containsKey(Integer.valueOf(5)));\n+        assertTrue(m.containsKey(Integer.valueOf(2)));\n+        assertTrue(m.containsKey(Integer.valueOf(4)));\n+        assertTrue(m.containsKey(Integer.valueOf(6)));\n+    }\n+\n+    public void testContainsValue() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.containsValue(\"one\"));\n+        assertFalse(m.containsValue(\"three\"));\n+        assertFalse(m.containsValue(\"five\"));\n+        assertTrue(m.containsValue(\"two\"));\n+        assertTrue(m.containsValue(\"four\"));\n+        assertTrue(m.containsValue(\"six\"));\n+    }\n+\n+    public void testDecoratedMap() {\n+        // entries shouldn't expire\n+        Map<Integer, String> m = makeDecoratedTestMap();\n+        assertEquals(6, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+\n+        // removing a single item shouldn't affect any other items\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+        m.remove(Integer.valueOf(2));\n+        assertEquals(5, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+        assertNull(m.get(Integer.valueOf(2)));\n+\n+        // adding a single, even item shouldn't affect any other items\n+        assertNull(m.get(Integer.valueOf(2)));\n+        m.put(Integer.valueOf(2), \"two\");\n+        assertEquals(6, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\n+        // adding a single, odd item (one that expires) shouldn't affect any\n+        // other items\n+        // put the entry expires immediately\n+        m.put(Integer.valueOf(1), \"one-one\");\n+        assertEquals(5, m.size());\n+        assertNull(m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+    }\n+\n+    public void testEntrySet() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.entrySet().size());\n+    }\n+\n+    public void testGet() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertNull(m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+        assertNull(m.get(Integer.valueOf(3)));\n+        assertEquals(\"four\", m.get(Integer.valueOf(4)));\n+        assertNull(m.get(Integer.valueOf(5)));\n+        assertEquals(\"six\", m.get(Integer.valueOf(6)));\n+    }\n+\n+    public void testIsEmpty() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.isEmpty());\n+\n+        // remove just evens\n+        m = makeTestMap();\n+        m.remove(Integer.valueOf(2));\n+        m.remove(Integer.valueOf(4));\n+        m.remove(Integer.valueOf(6));\n+        assertTrue(m.isEmpty());\n+    }\n+\n+    public void testKeySet() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.keySet().size());\n+    }\n+\n+    public void testSize() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.size());\n+    }\n+\n+    public void testValues() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.values().size());\n+    }\n+\n+    public void testZeroTimeToLive() {\n+        // item should not be available\n+        PassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n+                                                                                      0L);\n+        m.put(\"a\", \"b\");\n+        assertNull(m.get(\"a\"));\n+    }\n }", "timestamp": 1346009745, "metainfo": ""}