{"sha": "4e2452d2423f4f650e5bdac0b7352f6e09c5d03e", "log": "Javadoc improvements, especially exception descriptions   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BagUtils.java\n+++ b/src/java/org/apache/commons/collections/BagUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BagUtils.java,v 1.6 2002/10/12 22:15:18 scolebourne Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/10/12 22:15:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BagUtils.java,v 1.7 2002/10/13 00:38:36 scolebourne Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/10/13 00:38:36 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n-\n import java.util.Comparator;\n import java.util.Set;\n-\n-\n /**\n- *  Provides utility methods and decorators for {@link Bag} \n- *  and {@link SortedBag} instances.<P>\n- *\n- *  @author Paul Jack\n- *  @version $Id: BagUtils.java,v 1.6 2002/10/12 22:15:18 scolebourne Exp $\n- *  @since 2.1\n+ * Provides utility methods and decorators for {@link Bag} \n+ * and {@link SortedBag} instances.<P>\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @version $Id: BagUtils.java,v 1.7 2002/10/13 00:38:36 scolebourne Exp $\n+ * @since 2.1\n  */\n public class BagUtils {\n \n-\n     /**\n      *  Prevents instantiation.\n      */\n     }\n \n \n-    static class PredicatedBag extends CollectionUtils.PredicatedCollection \n-    implements Bag {\n+    static class PredicatedBag \n+            extends CollectionUtils.PredicatedCollection \n+            implements Bag {\n \n         public PredicatedBag(Bag b, Predicate p) {\n             super(b, p);\n \n \n     static class UnmodifiableBag \n-    extends CollectionUtils.UnmodifiableCollection\n-    implements Bag {\n+            extends CollectionUtils.UnmodifiableCollection\n+            implements Bag {\n \n         public UnmodifiableBag(Bag bag) {\n             super(bag);\n \n \n     static class SynchronizedBag\n-    extends CollectionUtils.SynchronizedCollection\n-    implements Bag {\n+            extends CollectionUtils.SynchronizedCollection\n+            implements Bag {\n \n         public SynchronizedBag(Bag bag) {\n             super(bag);\n     }\n \n \n-    static class PredicatedSortedBag extends PredicatedBag \n-    implements SortedBag {\n+    static class PredicatedSortedBag \n+            extends PredicatedBag \n+            implements SortedBag {\n \n         public PredicatedSortedBag(SortedBag sb, Predicate p) {\n             super(sb, p);\n     }\n \n \n-    static class SynchronizedSortedBag extends SynchronizedBag\n-    implements SortedBag {\n+    static class SynchronizedSortedBag \n+            extends SynchronizedBag\n+            implements SortedBag {\n \n         public SynchronizedSortedBag(SortedBag bag) {\n             super(bag);\n     }\n \n \n-    static class UnmodifiableSortedBag extends UnmodifiableBag\n-    implements SortedBag {\n+    static class UnmodifiableSortedBag \n+            extends UnmodifiableBag\n+            implements SortedBag {\n \n         public UnmodifiableSortedBag(SortedBag bag) {\n             super(bag);\n \n \n     /**\n-     *  Returns a predicated bag backed by the given bag.  Only objects\n-     *  that pass the test in the given predicate can be added to the bag.\n-     *  It is important not to use the original bag after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n-     *\n-     *  @param b  the bag to predicate\n-     *  @param p  the predicate for the bag\n-     *  @return  a predicated bag backed by the given bag\n-     */\n-    public static Bag predicatedBag(Bag b, Predicate p) {\n-        return new PredicatedBag(b, p);\n-    }\n-\n-\n-    /**\n-     *  Returns an unmodifiable view of the given bag.  Any modification\n-     *  attempts to the returned bag will raise an \n-     *  {@link UnsupportedOperationException}.\n-     *\n-     *  @param b  the bag whose unmodifiable view is to be returned\n-     *  @return  an unmodifiable view of that bag\n-     */\n-    public static Bag unmodifiableBag(Bag b) {\n-        return new UnmodifiableBag(b);\n-    }\n-\n-\n-    /**\n-     *  Returns a synchronized (thread-safe) bag backed by the given bag.\n-     *  In order to guarantee serial access, it is critical that all \n-     *  access to the backing bag is accomplished through the returned bag.\n-     *  <P>\n-     *  It is imperative that the user manually synchronize on the returned\n-     *  bag when iterating over it:\n-     *\n-     *  <Pre>\n-     *  Bag bag = BagUtils.synchronizedBag(new HashBag());\n-     *  ...\n-     *  synchronized(bag) {\n-     *      Iterator i = bag.iterator(); // Must be in synchronized block\n-     *      while (i.hasNext())\n-     *          foo(i.next());\n-     *      }\n-     *  }\n-     *  </Pre>\n-     *\n-     *  Failure to follow this advice may result in non-deterministic \n-     *  behavior.\n-     *\n-     *  @param b  the bag to synchronize\n-     *  @return  a synchronized bag backed by that bag\n-     */\n-    public static Bag synchronizedBag(Bag b) {\n-        return new SynchronizedBag(b);\n-    }\n-\n-\n-    /**\n-     *  Returns a predicated sorted bag backed by the given sorted bag.  \n-     *  Only objects that pass the test in the given predicate can be \n-     *  added to the bag.\n-     *  It is important not to use the original bag after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n-     *\n-     *  @param b  the sorted bag to predicate\n-     *  @param p  the predicate for the bag\n-     *  @return  a predicated bag backed by the given bag\n-     */\n-    public static SortedBag predicatedSortedBag(SortedBag b, Predicate p) {\n-        return new PredicatedSortedBag(b, p);\n-    }\n-\n-\n-    /**\n-     *  Returns an unmodifiable view of the given sorted bag.  Any modification\n-     *  attempts to the returned bag will raise an \n-     *  {@link UnsupportedOperationException}.\n-     *\n-     *  @param b  the bag whose unmodifiable view is to be returned\n-     *  @return  an unmodifiable view of that bag\n-     */\n-    public static SortedBag unmodifiableSortedBag(SortedBag b) {\n-        return new UnmodifiableSortedBag(b);\n-    }\n-\n-\n-    /**\n-     *  Returns a synchronized (thread-safe) sorted bag backed by the given \n-     *  sorted bag.\n-     *  In order to guarantee serial access, it is critical that all \n-     *  access to the backing bag is accomplished through the returned bag.\n-     *  <P>\n-     *  It is imperative that the user manually synchronize on the returned\n-     *  bag when iterating over it:\n-     *\n-     *  <Pre>\n-     *  SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n-     *  ...\n-     *  synchronized(bag) {\n-     *      Iterator i = bag.iterator(); // Must be in synchronized block\n-     *      while (i.hasNext())\n-     *          foo(i.next());\n-     *      }\n-     *  }\n-     *  </Pre>\n-     *\n-     *  Failure to follow this advice may result in non-deterministic \n-     *  behavior.\n-     *\n-     *  @param b  the bag to synchronize\n-     *  @return  a synchronized bag backed by that bag\n-     */\n-    public static SortedBag synchronizedSortedBag(SortedBag b) {\n-        return new SynchronizedSortedBag(b);\n-    }\n-\n+     * Returns a predicated bag backed by the given bag.  Only objects\n+     * that pass the test in the given predicate can be added to the bag.\n+     * It is important not to use the original bag after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     * @param bag  the bag to predicate, must not be null\n+     * @param predicate  the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException  if the Bag or Predicate is null\n+     */\n+    public static Bag predicatedBag(Bag bag, Predicate predicate) {\n+        return new PredicatedBag(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the given bag.  Any modification\n+     * attempts to the returned bag will raise an \n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @param bag  the bag whose unmodifiable view is to be returned, must not be null\n+     * @return an unmodifiable view of that bag\n+     * @throws IllegalArgumentException  if the Bag is null\n+     */\n+    public static Bag unmodifiableBag(Bag bag) {\n+        return new UnmodifiableBag(bag);\n+    }\n+\n+    /**\n+     * Returns a synchronized (thread-safe) bag backed by the given bag.\n+     * In order to guarantee serial access, it is critical that all \n+     * access to the backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned\n+     * bag when iterating over it:\n+     *\n+     * <pre>\n+     * Bag bag = BagUtils.synchronizedBag(new HashBag());\n+     * ...\n+     * synchronized(bag) {\n+     *     Iterator i = bag.iterator(); // Must be in synchronized block\n+     *     while (i.hasNext())\n+     *         foo(i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * Failure to follow this advice may result in non-deterministic \n+     * behavior.\n+     *\n+     * @param bag  the bag to synchronize, must not be null\n+     * @return a synchronized bag backed by that bag\n+     * @throws IllegalArgumentException  if the Bag is null\n+     */\n+    public static Bag synchronizedBag(Bag bag) {\n+        return new SynchronizedBag(bag);\n+    }\n+\n+    /**\n+     * Returns a predicated sorted bag backed by the given sorted bag.  \n+     * Only objects that pass the test in the given predicate can be \n+     * added to the bag.\n+     * It is important not to use the original bag after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     * @param bag  the sorted bag to predicate, must not be null\n+     * @param predicate  the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException  if the SortedBag or Predicate is null\n+     */\n+    public static SortedBag predicatedSortedBag(SortedBag bag, Predicate predicate) {\n+        return new PredicatedSortedBag(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns an unmodifiable view of the given sorted bag.  Any modification\n+     * attempts to the returned bag will raise an \n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @param bag  the bag whose unmodifiable view is to be returned, must not be null\n+     * @return an unmodifiable view of that bag\n+     * @throws IllegalArgumentException  if the SortedBag is null\n+     */\n+    public static SortedBag unmodifiableSortedBag(SortedBag bag) {\n+        return new UnmodifiableSortedBag(bag);\n+    }\n+\n+    /**\n+     * Returns a synchronized (thread-safe) sorted bag backed by the given \n+     * sorted bag.\n+     * In order to guarantee serial access, it is critical that all \n+     * access to the backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned\n+     * bag when iterating over it:\n+     *\n+     * <pre>\n+     * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n+     * ...\n+     * synchronized(bag) {\n+     *     Iterator i = bag.iterator(); // Must be in synchronized block\n+     *     while (i.hasNext())\n+     *         foo(i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * Failure to follow this advice may result in non-deterministic \n+     * behavior.\n+     *\n+     * @param bag  the bag to synchronize, must not be null\n+     * @return a synchronized bag backed by that bag\n+     * @throws IllegalArgumentException  if the SortedBag is null\n+     */\n+    public static SortedBag synchronizedSortedBag(SortedBag bag) {\n+        return new SynchronizedSortedBag(bag);\n+    }\n \n }\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUtils.java,v 1.8 2002/10/12 22:15:18 scolebourne Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/10/12 22:15:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUtils.java,v 1.9 2002/10/13 00:38:36 scolebourne Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/10/13 00:38:36 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n-\n import java.util.Collection;\n-\n-\n /**\n- *  Contains static utility methods for operating on {@link Buffer} objects.\n- *\n- *  @author Paul Jack\n- *  @version $Id: BufferUtils.java,v 1.8 2002/10/12 22:15:18 scolebourne Exp $\n- *  @since 2.1\n+ * Contains static utility methods for operating on {@link Buffer} objects.\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @version $Id: BufferUtils.java,v 1.9 2002/10/13 00:38:36 scolebourne Exp $\n+ * @since 2.1\n  */\n public class BufferUtils {\n \n-\n+    /**\n+     * Restrictive constructor\n+     */\n     private BufferUtils() {\n     }\n \n \n     /**\n-     *  Returns a synchronized buffer backed by the given buffer.\n-     *  Much like the synchronized collections returned by \n-     *  {@link java.util.Collections}, you must manually synchronize on \n-     *  the returned buffer's iterator to avoid non-deterministic behavior:\n+     * Returns a synchronized buffer backed by the given buffer.\n+     * Much like the synchronized collections returned by \n+     * {@link java.util.Collections}, you must manually synchronize on \n+     * the returned buffer's iterator to avoid non-deterministic behavior:\n      *  \n-     *  <Pre>\n-     *  Buffer b = BufferUtils.synchronizedBuffer(myBuffer);\n-     *  synchronized (b) {\n-     *      Iterator i = b.iterator();\n-     *      while (i.hasNext()) {\n-     *          process (i.next());\n-     *      }\n-     *  }\n-     *  </Pre>\n-     *\n-     *  @param b  the buffer to synchronize\n-     *  @return  a synchronized buffer backed by that buffer\n-     */\n-    public static Buffer synchronizedBuffer(final Buffer b) {\n-        return new SynchronizedBuffer(b);\n-    }\n-\n-\n-    /**\n-     *  Returns a synchronized buffer backed by the given buffer that will\n-     *  block on {@link Buffer#get()} and {@link Buffer#remove()} operations.\n-     *  If the buffer is empty, then the {@link Buffer#get()} and \n-     *  {@link Buffer#remove()} operations will block until new elements\n-     *  are added to the buffer, rather than immediately throwing a \n-     *  <Code>BufferUnderflowException</Code>.\n-     *\n-     *  @param buf  the buffer to synchronize\n-     *  @return  a blocking buffer backed by that buffer\n-     */\n-    public static Buffer blockingBuffer(Buffer buf) {\n-        return new SynchronizedBuffer(buf) {\n+     * <pre>\n+     * Buffer b = BufferUtils.synchronizedBuffer(myBuffer);\n+     * synchronized (b) {\n+     *     Iterator i = b.iterator();\n+     *     while (i.hasNext()) {\n+     *         process (i.next());\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param buffer  the buffer to synchronize, must not be null\n+     * @return a synchronized buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static Buffer synchronizedBuffer(final Buffer buffer) {\n+        return new SynchronizedBuffer(buffer);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#get()} and {@link Buffer#remove()} operations.\n+     * If the buffer is empty, then the {@link Buffer#get()} and \n+     * {@link Buffer#remove()} operations will block until new elements\n+     * are added to the buffer, rather than immediately throwing a \n+     * <code>BufferUnderflowException</code>.\n+     *\n+     * @param buffer  the buffer to synchronize, must not be null\n+     * @return a blocking buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static Buffer blockingBuffer(Buffer buffer) {\n+        return new SynchronizedBuffer(buffer) {\n \n             public synchronized boolean add(Object o) {\n                 boolean r = collection.add(o);\n         };\n     }\n \n-\n-    /**\n-     *  Returns an unmodifiable buffer backed by the given buffer.\n-     *\n-     *  @param b  the buffer to make unmodifiable\n-     *  @return  an unmodifiable buffer backed by that buffer\n-     */\n-    public static Buffer unmodifiableBuffer(Buffer b) {\n-        return new UnmodifiableBuffer(b);\n-    }\n-\n-\n-    /**\n-     *  Returns a predicated buffer backed by the given buffer.  Elements are\n-     *  evaluated with the given predicate before being added to the buffer.\n-     *  If the predicate evaluation returns false, then an \n-     *  IllegalArgumentException is raised and the element is not added to\n-     *  the buffer.\n-     *\n-     *  @param buf  the buffer to predicate\n-     *  @param p  the predicate used to evaluate new elements\n-     *  @return  a predicated buffer\n-     */\n-    public static Buffer predicatedBuffer(Buffer buf, final Predicate p) {\n-        return new PredicatedBuffer(buf, p);\n-    }\n-\n-\n-\n-    private static class SynchronizedBuffer \n-    extends CollectionUtils.SynchronizedCollection\n-    implements Buffer {\n+    /**\n+     * Returns an unmodifiable buffer backed by the given buffer.\n+     *\n+     * @param buffer  the buffer to make unmodifiable, must not be null\n+     * @return an unmodifiable buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static Buffer unmodifiableBuffer(Buffer buffer) {\n+        return new UnmodifiableBuffer(buffer);\n+    }\n+\n+    /**\n+     * Returns a predicated buffer backed by the given buffer.  Elements are\n+     * evaluated with the given predicate before being added to the buffer.\n+     * If the predicate evaluation returns false, then an \n+     * IllegalArgumentException is raised and the element is not added to\n+     * the buffer.\n+     *\n+     * @param buffer  the buffer to predicate, must not be null\n+     * @param predicate  the predicate used to evaluate new elements, must not be null\n+     * @return a predicated buffer\n+     * @throws IllegalArgumentException  if the Buffer or Predicate is null\n+     */\n+    public static Buffer predicatedBuffer(Buffer buffer, final Predicate predicate) {\n+        return new PredicatedBuffer(buffer, predicate);\n+    }\n+\n+\n+\n+    static class SynchronizedBuffer \n+            extends CollectionUtils.SynchronizedCollection\n+            implements Buffer {\n \n         public SynchronizedBuffer(Buffer b) {\n             super(b);\n     }\n \n \n-    private static class UnmodifiableBuffer \n-    extends CollectionUtils.UnmodifiableCollection\n-    implements Buffer {\n+    static class UnmodifiableBuffer \n+            extends CollectionUtils.UnmodifiableCollection\n+            implements Buffer {\n \n         public UnmodifiableBuffer(Buffer b) {\n             super(b);\n     }\n \n \n-    private static class PredicatedBuffer \n-    extends CollectionUtils.PredicatedCollection\n-    implements Buffer {\n+    static class PredicatedBuffer \n+            extends CollectionUtils.PredicatedCollection\n+            implements Buffer {\n \n         public PredicatedBuffer(Buffer b, Predicate p) {\n             super(b, p);\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.17 2002/10/12 21:59:45 scolebourne Exp $\n- * $Revision: 1.17 $\n- * $Date: 2002/10/12 21:59:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.18 2002/10/13 00:38:36 scolebourne Exp $\n+ * $Revision: 1.18 $\n+ * $Date: 2002/10/13 00:38:36 $\n  *\n  * ====================================================================\n  *\n \n import org.apache.commons.collections.iterators.ArrayIterator;\n import org.apache.commons.collections.iterators.EnumerationIterator;\n-\n /**\n  * A set of {@link Collection} related utility methods.\n  *\n  * @author Paul Jack\n  * @author Stephen Colebourne\n  * @author Steve Downey\n- * @version $Revision: 1.17 $ $Date: 2002/10/12 21:59:45 $\n+ * @version $Revision: 1.18 $ $Date: 2002/10/13 00:38:36 $\n  */\n public class CollectionUtils {\n \n     }\n \n     /**\n-     *  Base class for collection decorators.  I decided to do it this way\n-     *  because it seemed to result in the most reuse.  \n-     *\n-     *  Inner class tree looks like:\n+     * Base class for collection decorators.  I decided to do it this way\n+     * because it seemed to result in the most reuse.  \n+     * \n+     * Inner class tree looks like:\n+     * <pre>\n      *       CollectionWrapper\n      *          PredicatedCollection\n      *             PredicatedSet\n      *             PredicatedList\n      *             PredicatedBag\n-     *          BoundedCollection\n-     *             BoundedSet\n-     *             BoundedList\n-     *             BoundedBag\n+     *             PredicatedBuffer\n+     *          UnmodifiableCollection\n+     *             UnmodifiableBag\n+     *             UnmodifiableBuffer\n      *          LazyCollection\n      *             LazyList\n      *             LazyBag\n      *       SynchronizedCollection\n      *          SynchronizedBuffer\n      *          SynchronizedBag\n-     */\n-    static class CollectionWrapper implements Collection {\n-\n-        final protected Collection collection;\n+     *          SynchronizedBuffer\n+     * </pre>\n+     */\n+    static class CollectionWrapper \n+            implements Collection {\n+\n+        protected final Collection collection;\n \n         public CollectionWrapper(Collection collection) {\n             if (collection == null) {\n-                throw new IllegalArgumentException(\"Collection must not be null.\");\n+                throw new IllegalArgumentException(\"Collection must not be null\");\n             }\n             this.collection = collection;\n         }\n     }\n \n \n-    static class PredicatedCollection extends CollectionWrapper {\n-\n-        final protected Predicate predicate;\n+    static class PredicatedCollection \n+            extends CollectionWrapper {\n+\n+        protected final Predicate predicate;\n \n         public PredicatedCollection(Collection c, Predicate p) {\n             super(c);\n             if (p == null) {\n-                throw new IllegalArgumentException(\"Predicate must not be null.\");\n+                throw new IllegalArgumentException(\"Predicate must not be null\");\n             }\n             this.predicate = p;\n             for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n             return collection.add(o);\n         }\n \n-\n         public boolean addAll(Collection c2) {\n             for (Iterator iter = c2.iterator(); iter.hasNext(); ) {\n                 validate(iter.next());\n             return collection.addAll(c2);\n         }\n \n-\n         protected void validate(Object o) {\n             if (!predicate.evaluate(o)) {\n-                throw new IllegalArgumentException(\"Object failed predicate.\");\n-            }\n-        }\n-\n-    }\n-\n-\n-    static class UnmodifiableCollection extends CollectionWrapper {\n-\n+                throw new IllegalArgumentException(\"Cannot add Object - Predicate rejected it\");\n+            }\n+        }\n+\n+    }\n+\n+\n+    static class UnmodifiableCollection \n+            extends CollectionWrapper {\n \n         public UnmodifiableCollection(Collection c) {\n             super(c);\n \n     static class SynchronizedCollection {\n \n-        final protected Collection collection;\n+        protected final Collection collection;\n \n         public SynchronizedCollection(Collection collection) {\n             if (collection == null) {\n-                throw new IllegalArgumentException(\"Collection must not be null.\");\n+                throw new IllegalArgumentException(\"Collection must not be null\");\n             }\n             this.collection = collection;\n         }\n     }\n \n \n-    static class UnmodifiableIterator implements Iterator {\n-\n-        final protected Iterator iterator;\n+    static class UnmodifiableIterator \n+            implements Iterator {\n+\n+        protected final Iterator iterator;\n \n         public UnmodifiableIterator(Iterator iterator) {\n+            if (iterator == null) {\n+                throw new IllegalArgumentException(\"Iterator must not be null\");\n+            }\n             this.iterator = iterator;\n         }\n \n \n \n     /**\n-     *  Returns a predicated collection backed by the given collection.\n-     *  Only objects that pass the test in the given predicate can be \n-     *  added to the collection.\n-     *  It is important not to use the original collection after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n+     * Returns a predicated collection backed by the given collection.\n+     * Only objects that pass the test in the given predicate can be \n+     * added to the collection.\n+     * It is important not to use the original collection after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n      *\n-     *  @param b  the collection to predicate\n-     *  @param p  the predicate for the collection\n-     *  @return  a predicated collection backed by the given collection\n-     */\n-    public static Collection predicatedCollection(Collection c, Predicate p) {\n-        return new PredicatedCollection(c, p);\n-    }\n-\n+     * @param collection  the collection to predicate, must not be null\n+     * @param predicate  the predicate for the collection, must not be null\n+     * @return a predicated collection backed by the given collection\n+     * @throws IllegalArgumentException  if the Collection is null\n+     */\n+    public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n+        return new PredicatedCollection(collection, predicate);\n+    }\n \n }\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ListUtils.java,v 1.10 2002/08/18 20:11:37 pjack Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/08/18 20:11:37 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ListUtils.java,v 1.11 2002/10/13 00:38:36 scolebourne Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/10/13 00:38:36 $\n  *\n  * ====================================================================\n  *\n import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n-\n /**\n  * Contains static utility methods and decorators for {@link List} \n  * instances.\n  * @author  <a href=\"mailto:fede@apache.org\">Federico Barbieri</a>\n  * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n  * @author Paul Jack\n+ * @author Stephen Colebourne\n  */\n-public class ListUtils\n-{\n+public class ListUtils {\n \n     /**\n      *  Please don't ever instantiate a <Code>ListUtils</Code>.\n     }\n \n     /**\n-     *  Returns a new list containing all elements that are contained in\n-     *  both given lists.\n-     *\n-     *  @param list1  the first list\n-     *  @param list2  the second list\n-     *  @return  the intersection of those two lists\n-     *  @throws NullPointerException if either list is null\n-     */\n-    public static List intersection( final List list1, final List list2 )\n-    {\n+     * Returns a new list containing all elements that are contained in\n+     * both given lists.\n+     *\n+     * @param list1  the first list\n+     * @param list2  the second list\n+     * @return  the intersection of those two lists\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static List intersection(final List list1, final List list2) {\n         final ArrayList result = new ArrayList();\n         final Iterator iterator = list2.iterator();\n \n-        while( iterator.hasNext() )\n-        {\n+        while (iterator.hasNext()) {\n             final Object o = iterator.next();\n \n-            if ( list1.contains( o ) )\n-            {\n-                result.add( o );\n+            if (list1.contains(o)) {\n+                result.add(o);\n             }\n         }\n \n         return result;\n     }\n \n-\n-    /**\n-     *  Subtracts all elements in the second list from the first list,\n-     *  placing the results in a new list.\n-     *  This differs from {@link List#removeAll(Collection)} in that\n-     *  cardinality is respected; if <Code>list1</Code> contains two\n-     *  occurrences of <Code>null</Code> and <Code>list2</Code> only\n-     *  contains one occurrence, then the returned list will still contain\n-     *  one occurrence.\n-     *\n-     *  @param list1  the list to subtract from\n-     *  @param list2  the lsit to subtract\n-     *  @return  a new list containing the results\n-     *  @throws NullPointerException if either list is null\n-     */\n-    public static List subtract( final List list1, final List list2 )\n-    {\n-        final ArrayList result = new ArrayList( list1 );\n+    /**\n+     * Subtracts all elements in the second list from the first list,\n+     * placing the results in a new list.\n+     * This differs from {@link List#removeAll(Collection)} in that\n+     * cardinality is respected; if <Code>list1</Code> contains two\n+     * occurrences of <Code>null</Code> and <Code>list2</Code> only\n+     * contains one occurrence, then the returned list will still contain\n+     * one occurrence.\n+     *\n+     * @param list1  the list to subtract from\n+     * @param list2  the lsit to subtract\n+     * @return  a new list containing the results\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static List subtract(final List list1, final List list2) {\n+        final ArrayList result = new ArrayList(list1);\n         final Iterator iterator = list2.iterator();\n \n-        while( iterator.hasNext() )\n-        {\n-            result.remove( iterator.next() );\n+        while (iterator.hasNext()) {\n+            result.remove(iterator.next());\n         }\n \n         return result;\n     }\n \n     /**\n-     *  Returns the sum of the given lists.  This is their intersection\n-     *  subtracted from their union.\n-     *\n-     *  @param list1  the first list \n-     *  @param list2  the second list\n-     *  @return  a new list containing the sum of those lists\n-     *  @throws NullPointerException if either list is null\n+     * Returns the sum of the given lists.  This is their intersection\n+     * subtracted from their union.\n+     *\n+     * @param list1  the first list \n+     * @param list2  the second list\n+     * @return  a new list containing the sum of those lists\n+     * @throws NullPointerException if either list is null\n      */ \n-    public static List sum( final List list1, final List list2 )\n-    {\n-        return subtract( union( list1, list2 ),\n-                         intersection( list1, list2 ) );\n-    }\n-\n-\n-    /**\n-     *  Returns a new list containing the second list appended to the\n-     *  first list.  The {@link List#addAll(Collection)} operation is\n-     *  used to append the two given lists into a new list.\n-     *\n-     *  @param list1  the first list \n-     *  @param list2  the second list\n-     *  @return  a new list containing the union of those lists\n-     *  @throws NullPointerException if either list is null\n-     */\n-    public static List union( final List list1, final List list2 )\n-    {\n-        final ArrayList result = new ArrayList( list1 );\n-        result.addAll( list2 );\n+    public static List sum(final List list1, final List list2) {\n+        return subtract(union(list1, list2), intersection(list1, list2));\n+    }\n+\n+    /**\n+     * Returns a new list containing the second list appended to the\n+     * first list.  The {@link List#addAll(Collection)} operation is\n+     * used to append the two given lists into a new list.\n+     *\n+     * @param list1  the first list \n+     * @param list2  the second list\n+     * @return  a new list containing the union of those lists\n+     * @throws NullPointerException if either list is null\n+     */\n+    public static List union(final List list1, final List list2) {\n+        final ArrayList result = new ArrayList(list1);\n+        result.addAll(list2);\n         return result;\n     }\n \n \n-    static class ListIteratorWrapper implements ListIterator {\n+    static class ListIteratorWrapper \n+            implements ListIterator {\n \n         final protected ListIterator iterator;\n \n     }\n \n \n-    static class PredicatedList extends CollectionUtils.PredicatedCollection\n-    implements List {\n+    static class PredicatedList \n+            extends CollectionUtils.PredicatedCollection\n+            implements List {\n \n         public PredicatedList(List list, Predicate p) {\n             super(list, p);\n     }\n \n \n-    static class FixedSizeList extends CollectionUtils.UnmodifiableCollection\n-    implements List {\n+    static class FixedSizeList \n+            extends CollectionUtils.UnmodifiableCollection\n+            implements List {\n \n         public FixedSizeList(List list) {\n             super(list);\n     }\n \n \n-    static class LazyList extends CollectionUtils.CollectionWrapper \n-    implements List {\n-\n-        final protected Factory factory;\n+    static class LazyList \n+            extends CollectionUtils.CollectionWrapper \n+            implements List {\n+\n+        protected final Factory factory;\n \n         public LazyList(List list, Factory factory) {\n             super(list);\n             if (factory == null) {\n-                throw new IllegalArgumentException(\"factory may not be null\");\n+                throw new IllegalArgumentException(\"Factory must not be null\");\n             }\n             this.factory = factory;\n         }\n \n \n     /**\n-     *  Returns a predicated list backed by the given list.  Only objects\n-     *  that pass the test in the given predicate can be added to the list.\n-     *  It is important not to use the original list after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n-     *\n-     *  @param list  the list to predicate\n-     *  @param p  the predicate for the list\n-     *  @return  a predicated list backed by the given list\n-     */\n-    public static List predicatedList(List list, Predicate p) {\n-        return new PredicatedList(list, p);\n-    }\n-\n-\n-    /**\n-     *  Returns a \"lazy\" list whose elements will be created on demand.<P>\n-     *  <P>\n-     *  When the index passed to the returned list's {@link List#get(int) get}\n-     *  method is greater than the list's size, then the factory will be used\n-     *  to create a new object and that object will be inserted at that index.\n-     *  <P>\n-     *  For instance:\n-     *\n-     *  <Pre>\n-     *  Factory factory = new Factory() {\n-     *      public Object create() {\n-     *          return new Date();\n-     *      }\n-     *  }\n-     *  List lazy = ListUtils.lazyList(new ArrayList(), factory);\n-     *  Object obj = lazy.get(3);\n-     *  </Pre>\n-     *\n-     *  After the above code is executed, <Code>obj</Code> will contain\n-     *  a new <Code>Date</Code> instance.  Furthermore, that <Code>Date</Code>\n-     *  instance is the fourth element in the list.  The first, second, \n-     *  and third element are all set to <Code>null</Code>.<P>\n-     *\n-     *  @param list  the list to make lazy\n-     *  @param factory  the factory for creating new objects\n-     *  @return a lazy list backed by the given list\n+     * Returns a predicated list backed by the given list.  Only objects\n+     * that pass the test in the given predicate can be added to the list.\n+     * It is important not to use the original list after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     * @param list  the list to predicate, must not be null\n+     * @param predicate  the predicate for the list, must not be null\n+     * @return a predicated list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Predicate is null\n+     */\n+    public static List predicatedList(List list, Predicate predicate) {\n+        return new PredicatedList(list, predicate);\n+    }\n+\n+    /**\n+     * Returns a \"lazy\" list whose elements will be created on demand.<P>\n+     * <p>\n+     * When the index passed to the returned list's {@link List#get(int) get}\n+     * method is greater than the list's size, then the factory will be used\n+     * to create a new object and that object will be inserted at that index.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * List lazy = ListUtils.lazyList(new ArrayList(), factory);\n+     * Object obj = lazy.get(3);\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the fourth element in the list.  The first, second, \n+     * and third element are all set to <code>null</code>.\n+     *\n+     * @param list  the list to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy list backed by the given list\n+     * @throws IllegalArgumentException  if the List or Factory is null\n      */\n     public static List lazyList(List list, Factory factory) {\n         return new LazyList(list, factory);\n     }\n \n-\n-    /**\n-     *  Returns a fixed-sized list backed by the given list.\n-     *  Elements may not be added or removed from the returned list, but \n-     *  existing elements can be changed (for instance, via the \n-     *  {@link List#set(int,Object)} method).\n-     *\n-     *  @param list  the list whose size to fix\n-     *  @return  a fixed-size list backed by that list\n+    /**\n+     * Returns a fixed-sized list backed by the given list.\n+     * Elements may not be added or removed from the returned list, but \n+     * existing elements can be changed (for instance, via the \n+     * {@link List#set(int,Object)} method).\n+     *\n+     * @param list  the list whose size to fix, must not be null\n+     * @return a fixed-size list backed by that list\n+     * @throws IllegalArgumentException  if the List is null\n      */\n     public static List fixedSizeList(List list) {\n         return new FixedSizeList(list);\n     }\n \n-\n }\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.12 2002/08/19 21:56:18 pjack Exp $\n- * $Revision: 1.12 $\n- * $Date: 2002/08/19 21:56:18 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.13 2002/10/13 00:38:36 scolebourne Exp $\n+ * $Revision: 1.13 $\n+ * $Date: 2002/10/13 00:38:36 $\n  *\n  * ====================================================================\n  *\n import java.text.*;\n import java.text.NumberFormat;\n import java.util.*;\n-\n-/** A helper class for using {@link Map Map} instances.<P>\n-  *\n-  * It contains various typesafe methods\n-  * as well as other useful features like deep copying.<P>\n-  *\n-  * It also provides the following decorators:\n-  *\n-  *  <UL>\n-  *  <LI>{@link #fixedSizeMap(Map)}\n-  *  <LI>{@link #fixedSizeSortedMap(SortedMap)}\n-  *  <LI>{@link #lazyMap(Map,Factory)}\n-  *  <LI>{@link #lazySortedMap(SortedMap,Factory)}\n-  *  <LI>{@link #predicatedMap(Map,Predicate,Predicate)}\n-  *  <LI>{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}\n-  *  </UL>\n-  *\n-  * @since 1.0\n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n-  * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n-  * @author Paul Jack\n-  */\n+/** \n+ * A helper class for using {@link Map Map} instances.<P>\n+ *\n+ * It contains various typesafe methods\n+ * as well as other useful features like deep copying.<P>\n+ *\n+ * It also provides the following decorators:\n+ *\n+ *  <UL>\n+ *  <LI>{@link #fixedSizeMap(Map)}\n+ *  <LI>{@link #fixedSizeSortedMap(SortedMap)}\n+ *  <LI>{@link #lazyMap(Map,Factory)}\n+ *  <LI>{@link #lazySortedMap(SortedMap,Factory)}\n+ *  <LI>{@link #predicatedMap(Map,Predicate,Predicate)}\n+ *  <LI>{@link #predicatedSortedMap(SortedMap,Predicate,Predicate)}\n+ *  </UL>\n+ *\n+ * @since 1.0\n+ * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+ * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n+ * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n public class MapUtils {\n \n     private static int debugIndent = 0;\n     }\n \n \n-    static class PredicatedMap extends ProxyMap {\n-\n-        final protected Predicate keyPredicate;\n-        final protected Predicate valuePredicate;\n-\n+    static class PredicatedMap \n+            extends ProxyMap {\n+\n+        protected final Predicate keyPredicate;\n+        protected final Predicate valuePredicate;\n \n         public PredicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n             super(map);\n             if (map == null) {\n-                throw new IllegalArgumentException(\"map may not be null.\");\n+                throw new IllegalArgumentException(\"Map must not be null\");\n             }\n             if (keyPred == null) {\n-                throw new IllegalArgumentException(\"keyPred may not be null.\");\n+                throw new IllegalArgumentException(\"Key Predicate must not be null\");\n             }\n             if (valuePred == null) {\n-                throw new IllegalArgumentException(\"valuePred may not be null.\");\n+                throw new IllegalArgumentException(\"Value Predicate must not be null\");\n             }\n             this.keyPredicate = keyPred;\n             this.valuePredicate = valuePred;\n \n         private void validate(Object key, Object value) {\n             if (!keyPredicate.evaluate(key)) {\n-                throw new IllegalArgumentException(\"Invalid key.\");\n+                throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n             }\n             if (!valuePredicate.evaluate(value)) {\n-                throw new IllegalArgumentException(\"Invalid value.\");\n+                throw new IllegalArgumentException(\"Cannot add value - Predicate rejected it\");\n             }\n         }\n     }\n \n \n     static class PredicatedMapEntrySet \n-    extends CollectionUtils.CollectionWrapper\n-    implements Set {\n-\n-        final private Predicate predicate;\n+            extends CollectionUtils.CollectionWrapper\n+            implements Set {\n+\n+        private final Predicate predicate;\n \n         public PredicatedMapEntrySet(Set set, Predicate p) {\n             super(set);\n     }\n \n \n-    static class PredicatedMapEntry implements Map.Entry {\n-\n-        final private Map.Entry entry;\n-        final private Predicate predicate;\n+    static class PredicatedMapEntry \n+            implements Map.Entry {\n+\n+        private final Map.Entry entry;\n+        private final Predicate predicate;\n \n \n         public PredicatedMapEntry(Map.Entry entry, Predicate p) {\n+            if (entry == null) {\n+                throw new IllegalArgumentException(\"Map.Entry must not be null\");\n+            }\n+            if (p == null) {\n+                throw new IllegalArgumentException(\"Predicate must not be null\");\n+            }\n             this.entry = entry;\n             this.predicate = p;\n         }\n \n         public Object setValue(Object o) {\n             if (!predicate.evaluate(o)) {\n-                throw new IllegalArgumentException(\"Invalid value.\");\n+                throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n             }\n             return entry.setValue(o);\n         }\n     }\n \n \n-    static class FixedSizeMap extends ProxyMap {\n+    static class FixedSizeMap \n+            extends ProxyMap {\n \n         public FixedSizeMap(Map map) {\n             super(map);\n             if (map == null) {\n-                throw new IllegalArgumentException(\"map may not be null.\");\n+                throw new IllegalArgumentException(\"Map must not be null\");\n             }\n         }\n \n \n         public Object put(Object key, Object value) {\n             if (!map.containsKey(key)) {\n-                throw new IllegalArgumentException(\"Can't add new keys.\");\n+                throw new IllegalArgumentException(\"Cannot put new key/value pair - List is fixed size\");\n             }\n             return map.put(key, value);\n         }\n         public void putAll(Map m) {\n             for (Iterator iter = m.keySet().iterator(); iter.hasNext(); ) {\n                 if (!map.containsKey(iter.next())) {\n-                    throw new IllegalArgumentException(\"Can't add new keys.\");\n+                    throw new IllegalArgumentException(\"Cannot put new key/value pair - List is fixed size\");\n                 }\n             }\n             map.putAll(m);\n     }\n \n \n-    static class LazyMap extends ProxyMap {\n-\n-        final protected Factory factory;\n-\n+    static class LazyMap \n+            extends ProxyMap {\n+\n+        protected final Factory factory;\n \n         public LazyMap(Map map, Factory factory) {\n             super(map);\n             if (map == null) {\n-                throw new IllegalArgumentException(\"map may not be null.\");\n+                throw new IllegalArgumentException(\"Map must not be null\");\n             }\n             if (factory == null) {\n-                throw new IllegalArgumentException(\"factory may not be null.\");\n+                throw new IllegalArgumentException(\"Factory must not be null\");\n             }\n             this.factory = factory;\n         }\n \n \n \n-    static class PredicatedSortedMap extends PredicatedMap \n-    implements SortedMap {\n+    static class PredicatedSortedMap \n+            extends PredicatedMap \n+            implements SortedMap {\n \n         public PredicatedSortedMap(SortedMap map, Predicate k, Predicate v) {\n             super(map, k, v);\n     }\n \n \n-    static class FixedSizeSortedMap extends FixedSizeMap implements SortedMap {\n+    static class FixedSizeSortedMap \n+            extends FixedSizeMap \n+            implements SortedMap {\n \n         public FixedSizeSortedMap(SortedMap m) {\n             super(m);\n     }\n \n \n-    static class LazySortedMap extends LazyMap implements SortedMap {\n+    static class LazySortedMap \n+            extends LazyMap \n+            implements SortedMap {\n \n         public LazySortedMap(SortedMap m, Factory factory) {\n             super(m, factory);\n \n \n     /**\n-     *  Returns a predicated map backed by the given map.  Only keys and\n-     *  values that pass the given predicates can be added to the map.\n-     *  It is important not to use the original map after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n-     *\n-     *  @param map  the map to predicate\n-     *  @param keyPred  the predicate for keys\n-     *  @param valuePred  the predicate for values\n-     *  @return  a predicated map backed by the given map\n+     * Returns a predicated map backed by the given map.  Only keys and\n+     * values that pass the given predicates can be added to the map.\n+     * It is important not to use the original map after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     * @param map  the map to predicate, must not be null\n+     * @param keyPred  the predicate for keys, must not be null\n+     * @param valuePred  the predicate for values, must not be null\n+     * @return a predicated map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Predicates are null\n      */\n     public static Map predicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n         return new PredicatedMap(map, keyPred, valuePred);\n     }\n \n-\n-    /**\n-     *  Returns a fixed-sized map backed by the given map.\n-     *  Elements may not be added or removed from the returned map, but \n-     *  existing elements can be changed (for instance, via the \n-     *  {@link Map#put(Object,Object)} method).\n-     *\n-     *  @param map  the map whose size to fix\n-     *  @return  a fixed-size map backed by that map\n+    /**\n+     * Returns a fixed-sized map backed by the given map.\n+     * Elements may not be added or removed from the returned map, but \n+     * existing elements can be changed (for instance, via the \n+     * {@link Map#put(Object,Object)} method).\n+     *\n+     * @param map  the map whose size to fix, must not be null\n+     * @return a fixed-size map backed by that map\n+     * @throws IllegalArgumentException  if the Map is null\n      */\n     public static Map fixedSizeMap(Map map) {\n         return new FixedSizeMap(map);\n     }\n \n-\n-    /**\n-     *  Returns a \"lazy\" map whose values will be created on demand.<P>\n-     *  <P>\n-     *  When the key passed to the returned map's {@link Map#get(Object)}\n-     *  method is not present in the map, then the factory will be used\n-     *  to create a new object and that object will become the value\n-     *  associated with that key.\n-     *  <P>\n-     *  For instance:\n-     *\n-     *  <Pre>\n-     *  Factory factory = new Factory() {\n-     *      public Object create() {\n-     *          return new Date();\n-     *      }\n-     *  }\n-     *  Map lazy = MapUtils.lazyMap(new HashMap(), factory);\n-     *  Object obj = lazy.get(\"test\");\n-     *  </Pre>\n-     *\n-     *  After the above code is executed, <Code>obj</Code> will contain\n-     *  a new <Code>Date</Code> instance.  Furthermore, that <Code>Date</Code>\n-     *  instance is the value for the <Code>test</Code> key.<P>\n-     *\n-     *  @param map  the map to make lazy\n-     *  @param factory  the factory for creating new objects\n-     *  @return a lazy map backed by the given map\n+    /**\n+     * Returns a \"lazy\" map whose values will be created on demand.<P>\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * Map lazy = MapUtils.lazyMap(new HashMap(), factory);\n+     * Object obj = lazy.get(\"test\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the value for the <code>test</code> key.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the Map or Factory is null\n      */\n     public static Map lazyMap(Map map, Factory factory) {\n         return new LazyMap(map, factory);\n     }\n \n-\n-    /**\n-     *  Returns a predicated sorted map backed by the given map.  Only keys and\n-     *  values that pass the given predicates can be added to the map.\n-     *  It is important not to use the original map after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n-     *\n-     *  @param map  the map to predicate\n-     *  @param keyPred  the predicate for keys\n-     *  @param valuePred  the predicate for values\n-     *  @return  a predicated map backed by the given map\n+    /**\n+     * Returns a predicated sorted map backed by the given map.  Only keys and\n+     * values that pass the given predicates can be added to the map.\n+     * It is important not to use the original map after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     * @param map  the map to predicate, must not be null\n+     * @param keyPred  the predicate for keys, must not be null\n+     * @param valuePred  the predicate for values, must not be null\n+     * @return a predicated map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap or Predicates are null\n      */\n     public static SortedMap predicatedSortedMap(SortedMap map, Predicate keyPred, Predicate valuePred) {\n         return new PredicatedSortedMap(map, keyPred, valuePred);\n     }\n \n-\n-    /**\n-     *  Returns a fixed-sized sorted map backed by the given sorted map.\n-     *  Elements may not be added or removed from the returned map, but \n-     *  existing elements can be changed (for instance, via the \n-     *  {@link Map#put(Object,Object)} method).\n-     *\n-     *  @param map  the map whose size to fix\n-     *  @return  a fixed-size map backed by that map\n+    /**\n+     * Returns a fixed-sized sorted map backed by the given sorted map.\n+     * Elements may not be added or removed from the returned map, but \n+     * existing elements can be changed (for instance, via the \n+     * {@link Map#put(Object,Object)} method).\n+     *\n+     * @param map  the map whose size to fix, must not be null\n+     * @return a fixed-size map backed by that map\n+     * @throws IllegalArgumentException  if the SortedMap is null\n      */\n     public static SortedMap fixedSizeSortedMap(SortedMap map) {\n         return new FixedSizeSortedMap(map);\n     }\n \n-\n-    /**\n-     *  Returns a \"lazy\" sorted map whose values will be created on demand.\n-     *  <P>\n-     *  When the key passed to the returned map's {@link Map#get(Object)}\n-     *  method is not present in the map, then the factory will be used\n-     *  to create a new object and that object will become the value\n-     *  associated with that key.\n-     *  <P>\n-     *  For instance:\n-     *\n-     *  <Pre>\n-     *  Factory factory = new Factory() {\n-     *      public Object create() {\n-     *          return new Date();\n-     *      }\n-     *  }\n-     *  SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n-     *  Object obj = lazy.get(\"test\");\n-     *  </Pre>\n-     *\n-     *  After the above code is executed, <Code>obj</Code> will contain\n-     *  a new <Code>Date</Code> instance.  Furthermore, that <Code>Date</Code>\n-     *  instance is the value for the <Code>test</Code> key.<P>\n-     *\n-     *  @param map  the map to make lazy\n-     *  @param factory  the factory for creating new objects\n-     *  @return a lazy map backed by the given map\n+    /**\n+     * Returns a \"lazy\" sorted map whose values will be created on demand.\n+     * <p>\n+     * When the key passed to the returned map's {@link Map#get(Object)}\n+     * method is not present in the map, then the factory will be used\n+     * to create a new object and that object will become the value\n+     * associated with that key.\n+     * <p>\n+     * For instance:\n+     *\n+     * <pre>\n+     * Factory factory = new Factory() {\n+     *     public Object create() {\n+     *         return new Date();\n+     *     }\n+     * }\n+     * SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n+     * Object obj = lazy.get(\"test\");\n+     * </pre>\n+     *\n+     * After the above code is executed, <code>obj</code> will contain\n+     * a new <code>Date</code> instance.  Furthermore, that <code>Date</code>\n+     * instance is the value for the <code>test</code> key.\n+     *\n+     * @param map  the map to make lazy, must not be null\n+     * @param factory  the factory for creating new objects, must not be null\n+     * @return a lazy map backed by the given map\n+     * @throws IllegalArgumentException  if the SortedMap or Factory is null\n      */\n     public static SortedMap lazySortedMap(SortedMap map, Factory factory) {\n         return new LazySortedMap(map, factory);\n     }\n+    \n }\n--- a/src/java/org/apache/commons/collections/SetUtils.java\n+++ b/src/java/org/apache/commons/collections/SetUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SetUtils.java,v 1.6 2002/10/12 22:15:19 scolebourne Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/10/12 22:15:19 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SetUtils.java,v 1.7 2002/10/13 00:38:36 scolebourne Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/10/13 00:38:36 $\n  *\n  * ====================================================================\n  *\n  */\n package org.apache.commons.collections;\n \n-\n import java.util.Comparator;\n import java.util.Set;\n import java.util.SortedSet;\n-\n-\n /**\n- *  Provides static utility methods and decorators for {@link Set} \n- *  and {@link SortedSet} instances.\n+ * Provides static utility methods and decorators for {@link Set} \n+ * and {@link SortedSet} instances.\n  *\n- *  @author Paul Jack\n- *  @version $Id: SetUtils.java,v 1.6 2002/10/12 22:15:19 scolebourne Exp $\n- *  @since 2.1\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @version $Id: SetUtils.java,v 1.7 2002/10/13 00:38:36 scolebourne Exp $\n+ * @since 2.1\n  */\n public class SetUtils {\n \n-\n     /**\n-     *  Prevents instantiation.\n+     * Prevents instantiation.\n      */\n     private SetUtils() {\n     }\n \n \n-    static class PredicatedSet extends CollectionUtils.PredicatedCollection\n-    implements Set {\n+    static class PredicatedSet \n+            extends CollectionUtils.PredicatedCollection\n+            implements Set {\n \n-        public PredicatedSet(Set set, Predicate p) {\n-            super(set, p);\n+        public PredicatedSet(Set set, Predicate predicate) {\n+            super(set, predicate);\n         }\n \n     }\n \n \n-    static class PredicatedSortedSet extends PredicatedSet \n-    implements SortedSet {\n+    static class PredicatedSortedSet \n+            extends PredicatedSet \n+            implements SortedSet {\n \n-        public PredicatedSortedSet(SortedSet s, Predicate p) {\n-            super(s, p);\n+        public PredicatedSortedSet(SortedSet set, Predicate predicate) {\n+            super(set, predicate);\n         }\n \n         public SortedSet subSet(Object o1, Object o2) {\n     }\n \n     /**\n-     *  Returns a predicated set backed by the given set.  Only objects\n-     *  that pass the test in the given predicate can be added to the set.\n-     *  It is important not to use the original set after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n+     * Returns a predicated set backed by the given set.  Only objects\n+     * that pass the test in the given predicate can be added to the set.\n+     * It is important not to use the original set after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n      *\n-     *  @param set  the set to predicate\n-     *  @param p  the predicate for the set\n-     *  @return  a predicated set backed by the given set\n+     * @param set  the set to predicate, must not be null\n+     * @param predicate  the predicate for the set, must not be null\n+     * @return a predicated set backed by the given set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n-    public static Set predicatedSet(Set set, Predicate p) {\n-        return new PredicatedSet(set, p);\n+    public static Set predicatedSet(Set set, Predicate predicate) {\n+        return new PredicatedSet(set, predicate);\n     }\n \n-\n-\n     /**\n-     *  Returns a predicated sorted set backed by the given sorted set.  \n-     *  Only objects that pass the test in the given predicate can be added\n-     *  to the sorted set.\n-     *  It is important not to use the original sorted set after invoking this \n-     *  method, as it is a backdoor for adding unvalidated objects.\n+     * Returns a predicated sorted set backed by the given sorted set.  \n+     * Only objects that pass the test in the given predicate can be added\n+     * to the sorted set.\n+     * It is important not to use the original sorted set after invoking this \n+     * method, as it is a backdoor for adding unvalidated objects.\n      *\n-     *  @param set  the sorted set to predicate\n-     *  @param p  the predicate for the sorted set\n-     *  @return  a predicated sorted set backed by the given sorted set\n+     * @param set  the sorted set to predicate, must not be null\n+     * @param predicate  the predicate for the sorted set, must not be null\n+     * @return a predicated sorted set backed by the given sorted set\n+     * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n-    public static SortedSet predicatedSortedSet(SortedSet set, Predicate p) {\n-        return new PredicatedSortedSet(set, p);\n+    public static SortedSet predicatedSortedSet(SortedSet set, Predicate predicate) {\n+        return new PredicatedSortedSet(set, predicate);\n     }\n \n }", "timestamp": 1034469516, "metainfo": ""}