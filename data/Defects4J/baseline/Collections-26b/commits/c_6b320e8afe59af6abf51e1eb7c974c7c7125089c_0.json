{"sha": "6b320e8afe59af6abf51e1eb7c974c7c7125089c", "log": "Fixed to have SequencedHashMap throw a ConcurrentModificationException from its iterators if the map is modified through something other than the iterator.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/SequencedHashMap.java\n+++ b/src/java/org/apache/commons/collections/SequencedHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.8 2002/02/22 04:58:17 mas Exp $\n- * $Revision: 1.8 $\n- * $Date: 2002/02/22 04:58:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SequencedHashMap.java,v 1.9 2002/05/09 03:20:59 mas Exp $\n+ * $Revision: 1.9 $\n+ * $Date: 2002/05/09 03:20:59 $\n  *\n  * ====================================================================\n  *\n import java.util.Map;\n import java.util.Set;\n import java.util.NoSuchElementException;\n+import java.util.ConcurrentModificationException;\n \n /**\n  *  A map of objects whose mapping entries are sequenced based on the order in\n   private HashMap entries;\n \n   /**\n+   *  Holds the number of modifications that have occurred to the map,\n+   *  excluding modifications made through a collection view's iterator\n+   *  (e.g. entrySet().iterator().remove()).  This is used to create a\n+   *  fail-fast behavior with the iterators.\n+   **/\n+  private transient long modCount = 0;\n+\n+  /**\n    *  Construct a new sequenced hash map with default initial size and load\n    *  factor.\n    **/\n \n   // per Map.put(Object,Object)\n   public Object put(Object key, Object value) {\n+    modCount++;\n \n     Object oldValue = null;\n \n \n   // per Map.remove(Object)\n   public Object remove(Object key) {\n+    modCount++;\n+    return removeImpl(key);\n+  }\n+  \n+  /**\n+   *  Removed an entry without changing the map's modification count.  This\n+   *  method should only be called from a collection view's iterator\n+   **/\n+  private Object removeImpl(Object key) {\n     Entry e = (Entry)entries.remove(key);\n     if(e == null) return null;\n     removeEntry(e);\n \n   // per Map.clear()\n   public void clear() {\n+    modCount++;\n+\n     // remove all from the underlying map\n     entries.clear();\n \n     private int returnType;\n \n     /**\n-     *  Holds the \"current\" position in the iterator.  when pos.next is the\n+     *  Holds the \"current\" position in the iterator.  When pos.next is the\n      *  sentinel, we've reached the end of the list.\n      **/\n     private Entry pos = sentinel;\n+\n+    /**\n+     *  Holds the expected modification count.  If the actual modification\n+     *  count of the map differs from this value, then a concurrent\n+     *  modification has occurred.\n+     **/\n+    private transient long expectedModCount = modCount;\n     \n     /**\n      *  Construct an iterator over the sequenced elements in the order in which\n      *\n      *  @exception NoSuchElementException if there are no more elements in the\n      *  iterator.\n+     *\n+     *  @exception ConcurrentModificationException if a modification occurs in\n+     *  the underlying map.\n      **/\n     public Object next() {\n+      if(modCount != expectedModCount) {\n+        throw new ConcurrentModificationException();\n+      }\n       if(pos.next == sentinel) {\n         throw new NoSuchElementException();\n       }\n      *  @exception IllegalStateException if there isn't a \"last element\" to be\n      *  removed.  That is, if {@link #next()} has never been called, or if\n      *  {@link #remove()} was already called on the element.\n+     *\n+     *  @exception ConcurrentModificationException if a modification occurs in\n+     *  the underlying map.\n      **/\n     public void remove() {\n       if((returnType & REMOVED_MASK) != 0) {\n         throw new IllegalStateException(\"remove() must follow next()\");\n       }\n-\n-      // remove the entry\n-      SequencedHashMap.this.remove(pos.getKey());\n+      if(modCount != expectedModCount) {\n+        throw new ConcurrentModificationException();\n+      }\n+\n+      // remove the entry by calling the removeImpl method which does not\n+      // update the mod count.  This allows the iterator to remain valid.\n+      SequencedHashMap.this.removeImpl(pos.getKey());\n \n       // set the removed flag\n       returnType = returnType | REMOVED_MASK;\n--- a/src/test/org/apache/commons/collections/TestLRUMap.java\n+++ b/src/test/org/apache/commons/collections/TestLRUMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.19 2002/05/08 17:34:17 morgand Exp $\n- * $Revision: 1.19 $\n- * $Date: 2002/05/08 17:34:17 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestLRUMap.java,v 1.20 2002/05/09 03:20:59 mas Exp $\n+ * $Revision: 1.20 $\n+ * $Date: 2002/05/09 03:20:59 $\n  *\n  * ====================================================================\n  *\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n- * @version $Id: TestLRUMap.java,v 1.19 2002/05/08 17:34:17 morgand Exp $\n+ * @version $Id: TestLRUMap.java,v 1.20 2002/05/09 03:20:59 mas Exp $\n  */\n public class TestLRUMap extends TestSequencedHashMap\n {\n     public Map makeEmptyMap() {\n         LRUMap map = new LRUMap();\n         return map;\n-    }\n-\n-    // had to override from TestSequencedHashMap, because the test performs a get\n-    // inside a loop.  Since get() alter the Map in this class, an infinite loop\n-    // is produced\n-    public void testSequenceMap() {\n-        fail(\"trying to work out an infinite loop bug\");\n     }\n \n     public void testRemoveLRU() {\n--- a/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n         SequencedHashMap clone = (SequencedHashMap) labRat.clone();\n         assertEquals(\"Size of clone does not match original\",\n                      labRat.size(), clone.size());\n-        Iterator origKeys = labRat.keySet().iterator();\n-        Iterator copiedKeys = clone.keySet().iterator();\n-        while (origKeys.hasNext()) {\n-            Object origKey = origKeys.next();\n-            Object copiedKey = copiedKeys.next();\n-            assertEquals(\"Cloned key does not match orginal\",\n-                         origKey, copiedKey);\n+        Iterator origEntries = labRat.entrySet().iterator();\n+        Iterator copiedEntries = clone.entrySet().iterator();\n+        while (origEntries.hasNext()) {\n+            Map.Entry origEntry = (Map.Entry)origEntries.next();\n+            Map.Entry copiedEntry = (Map.Entry)copiedEntries.next();\n+            assertEquals(\"Cloned key does not match original\",\n+                         origEntry.getKey(), copiedEntry.getKey());\n             assertEquals(\"Cloned value does not match original\",\n-                         labRat.get(origKey), clone.get(copiedKey));\n+                         origEntry.getValue(), copiedEntry.getValue());\n+            assertEquals(\"Cloned entry does not match orginal\",\n+                         origEntry, copiedEntry);\n         }\n         assertTrue(\"iterator() returned different number of elements than keys()\",\n-               !copiedKeys.hasNext());\n+               !copiedEntries.hasNext());\n \n         // Test sequence()\n         List seq = labRat.sequence();", "timestamp": 1020914459, "metainfo": ""}