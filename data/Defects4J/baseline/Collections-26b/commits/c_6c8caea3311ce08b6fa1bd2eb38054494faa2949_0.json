{"sha": "6c8caea3311ce08b6fa1bd2eb38054494faa2949", "log": "[COLLECTIONS-551] Move forAllButLastDo methods, add unmodifiableIterable.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n      * @param closure  the closure to perform, may be null\n      * @return the last element in the collection, or null if either collection or closure is null\n      * @since 4.0\n-     */\n+     * @deprecated since 4.1, use {@link IterableUtils#applyForAllButLast(Iterable, Closure)} instead\n+     */\n+    @Deprecated\n     public static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterable<T> collection,\n                                                                       final C closure) {\n-        return collection != null && closure != null ? forAllButLastDo(collection.iterator(), closure) : null;\n+        return closure != null ? IterableUtils.applyForAllButLast(collection, closure) : null;\n     }\n \n     /**\n      * @param closure  the closure to perform, may be null\n      * @return the last element in the collection, or null if either iterator or closure is null\n      * @since 4.0\n-     */\n+     * @deprecated since 4.1, use {@link IteratorUtils#applyForAllButLast(Iterator, Closure)} instead\n+     */\n+    @Deprecated\n     public static <T, C extends Closure<? super T>> T forAllButLastDo(final Iterator<T> iterator, final C closure) {\n-        if (iterator != null && closure != null) {\n-            while (iterator.hasNext()) {\n-                final T element = iterator.next();\n-                if (iterator.hasNext()) {\n-                    closure.execute(element);\n-                } else {\n-                    return element;\n-                }\n-            }\n-        }\n-        return null;\n+        return closure != null ? IteratorUtils.applyForAllButLast(iterator, closure) : null;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/collections4/FluentIterable.java\n+++ b/src/main/java/org/apache/commons/collections4/FluentIterable.java\n     }\n \n     /**\n+     * Returns a new FluentIterable whose iterator will return an unmodifiable\n+     * view of this iterable.\n+     *\n+     * @return a new iterable, providing an unmodifiable view of this iterable\n+     */\n+    public FluentIterable<E> unmodifiable() {\n+        return of(IterableUtils.unmodifiableIterable(iterable));\n+    }\n+\n+    /**\n      * Returns a new FluentIterable whose iterator will traverse\n      * the elements of this iterable and the other iterable in\n      * alternating order.\n--- a/src/main/java/org/apache/commons/collections4/IterableUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IterableUtils.java\n      * Returns a view of the given iterable that only contains elements matching\n      * the provided predicate.\n      * <p>\n-     * The returned iterable's iterator does not supports {@code remove()}.\n+     * The returned iterable's iterator does not support {@code remove()}.\n      *\n      * @param <E>  the element type\n      * @param iterable  the iterable to filter, may be null\n      * @param <I>  the input element type\n      * @param <O>  the output element type\n      * @param iterable  the iterable to transform, may be null\n-     * @param transformer  the transformer , must not be null\n+     * @param transformer  the transformer, must not be null\n      * @return a transformed view of the specified iterable\n      * @throws NullPointerException if transformer is null\n      */\n     /**\n      * Returns a unique view of the given iterable.\n      * <p>\n-     * The returned iterable's iterator does not supports {@code remove()}.\n-     *\n-     * @param <E>  the element type\n-     * @param iterable  the iterable to transform, may be null\n+     * The returned iterable's iterator does not support {@code remove()}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to use, may be null\n      * @return a unique view of the specified iterable\n      */\n     public static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n                 return new UniqueFilterIterator<E>(emptyIteratorIfNull(iterable));\n             }\n         };\n+    }\n+\n+    // Unmodifiable\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Returns an unmodifiable view of the given iterable.\n+     * <p>\n+     * The returned iterable's iterator does not support {@code remove()}.\n+     *\n+     * @param <E>  the element type\n+     * @param iterable  the iterable to use, may be null\n+     * @return an unmodifiable view of the specified iterable\n+     */\n+    public static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n+        if (iterable instanceof UnmodifiableIterable<?>) {\n+            return iterable;\n+        }\n+        @SuppressWarnings(\"unchecked\") // safe\n+        final Iterable<E> it = iterable != null ? iterable : EMPTY_ITERABLE;\n+        return new UnmodifiableIterable<E>(it);\n+    }\n+\n+    /**\n+     * Inner class to distinguish unmodifiable instances.\n+     */\n+    private static final class UnmodifiableIterable<E> extends FluentIterable<E> {\n+        private final Iterable<E> unmodifiable;\n+\n+        public UnmodifiableIterable(final Iterable<E> iterable) {\n+            super();\n+            this.unmodifiable = iterable;\n+        }\n+\n+        @Override\n+        public Iterator<E> iterator() {\n+            return IteratorUtils.unmodifiableIterator(unmodifiable.iterator());\n+        }\n     }\n \n     // Zipping\n      */\n     public static <E> void apply(final Iterable<E> iterable, final Closure<? super E> closure) {\n         IteratorUtils.apply(emptyIteratorIfNull(iterable), closure);\n+    }\n+\n+    /**\n+     * Executes the given closure on each but the last element in the iterable.\n+     * <p>\n+     * If the input iterable is null no change is made.\n+     *\n+     * @param <E>  the type of object the {@link Iterable} contains\n+     * @param <C>  the closure type\n+     * @param iterable  the iterable to get the input from, may be null\n+     * @param closure  the closure to perform, may not be null\n+     * @return the last element in the iterable, or null if iterable is null or empty\n+     */\n+    public static <E, C extends Closure<? super E>> E applyForAllButLast(final Iterable<E> iterable,\n+                                                                         final C closure) {\n+        return IteratorUtils.applyForAllButLast(emptyIteratorIfNull(iterable), closure);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n     }\n \n     /**\n+     * Executes the given closure on each but the last element in the iterator.\n+     * <p>\n+     * If the input iterator is null no change is made.\n+     *\n+     * @param <E>  the type of object the {@link Iterator} contains\n+     * @param <C>  the closure type\n+     * @param iterator  the iterator to get the input from, may be null\n+     * @param closure  the closure to perform, may not be null\n+     * @return the last element in the iterator, or null if iterator is null or empty\n+     * @throws NullPointerException if closure is null\n+     * @since 4.1\n+     */\n+    public static <E, C extends Closure<? super E>> E applyForAllButLast(final Iterator<E> iterator,\n+                                                                         final C closure) {\n+        if (closure == null) {\n+            throw new NullPointerException(\"Closure must not be null.\");\n+        }\n+        if (iterator != null) {\n+            while (iterator.hasNext()) {\n+                final E element = iterator.next();\n+                if (iterator.hasNext()) {\n+                    closure.execute(element);\n+                } else {\n+                    return element;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n      * Finds the first element in the given iterator which matches the given predicate.\n      * <p>\n      * A <code>null</code> or empty iterator returns null.\n--- a/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n     }\n \n     @Test\n+    @Deprecated\n     public void forAllButLastDoIterator() {\n         final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n         final Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n--- a/src/test/java/org/apache/commons/collections4/FluentIterableTest.java\n+++ b/src/test/java/org/apache/commons/collections4/FluentIterableTest.java\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n \n     }\n \n     @Test\n+    public void unmodifiable() {\n+        FluentIterable<Integer> iterable1 = FluentIterable.of(iterableA).unmodifiable();\n+        Iterator<Integer> it = iterable1.iterator();\n+        assertEquals(1, it.next().intValue());\n+        try {\n+            it.remove();\n+            fail(\"expecting UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException ise) {\n+            // expected\n+        }\n+\n+        // calling unmodifiable on an already unmodifiable iterable shall return the same instance\n+        FluentIterable<Integer> iterable2 = iterable1.unmodifiable();\n+        assertSame(iterable1, iterable2);\n+    }\n+\n+    @Test\n     public void zip() {\n         List<Integer> result = FluentIterable.of(iterableOdd).zip(iterableEven).toList();\n         List<Integer> combinedList = new ArrayList<Integer>();\n--- a/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n     }\n \n     @Test\n+    public void applyForAllButLast() {\n+        final List<Integer> listA = new ArrayList<Integer>();\n+        listA.add(1);\n+\n+        final List<Integer> listB = new ArrayList<Integer>();\n+        listB.add(2);\n+\n+        final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<List<Integer>> col = new ArrayList<List<Integer>>();\n+        col.add(listA);\n+        col.add(listB);\n+        List<Integer> last = IterableUtils.applyForAllButLast(col, testClosure);\n+        assertTrue(listA.isEmpty() && !listB.isEmpty());\n+        assertSame(listB, last);\n+\n+        try {\n+            IterableUtils.apply(col, null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n+        IterableUtils.apply(null, testClosure);\n+\n+        // null should be OK\n+        col.add(null);\n+        col.add(null);\n+        last = IterableUtils.applyForAllButLast(col, testClosure);\n+        assertNull(last);\n+    }\n+\n+    @Test\n     public void containsWithEquator() {\n         final List<String> base = new ArrayList<String>();\n         base.add(\"AC\");\n--- a/src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/IteratorUtilsTest.java\n     }\n \n     @Test\n+    public void applyForAllButLast() {\n+        final List<Integer> listA = new ArrayList<Integer>();\n+        listA.add(1);\n+\n+        final List<Integer> listB = new ArrayList<Integer>();\n+        listB.add(2);\n+\n+        final Closure<List<Integer>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n+        final Collection<List<Integer>> col = new ArrayList<List<Integer>>();\n+        col.add(listA);\n+        col.add(listB);\n+        List<Integer> last = IteratorUtils.applyForAllButLast(col.iterator(), testClosure);\n+        assertTrue(listA.isEmpty() && !listB.isEmpty());\n+        assertSame(listB, last);\n+\n+        try {\n+            IteratorUtils.apply(col.iterator(), null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n+        IteratorUtils.apply(null, testClosure);\n+\n+        // null should be OK\n+        col.add(null);\n+        col.add(null);\n+        last = IteratorUtils.applyForAllButLast(col.iterator(), testClosure);\n+        assertNull(last);\n+    }\n+\n+    @Test\n     public void find() {\n         Predicate<Number> testPredicate = equalPredicate((Number) 4);\n         Integer test = IteratorUtils.find(iterableA.iterator(), testPredicate);", "timestamp": 1433592046, "metainfo": ""}