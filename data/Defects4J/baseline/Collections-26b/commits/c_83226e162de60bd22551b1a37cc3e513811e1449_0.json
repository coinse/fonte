{"sha": "83226e162de60bd22551b1a37cc3e513811e1449", "log": "Refactor trie package: reduce interface by extending IterableSortedMap and only adding prefixMap method, remove all key analyzers but the StringKeyAnalyzer, refactor PatriciaTrie class by moving all remaining methods to AbstractPatriciaTrie and fixing the key type to String, integrating the test classes into the framework.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java\n  * @since 4.0\n  * @version $Id$\n  */\n-abstract class AbstractBitwiseTrie<K, V> extends AbstractMap<K, V>\n+public abstract class AbstractBitwiseTrie<K, V> extends AbstractMap<K, V>\n         implements Trie<K, V>, Serializable {\n \n     private static final long serialVersionUID = 5826987063535505652L;\n \n-    // TODO Privatise fields?\n-\n     /**\n      * The {@link KeyAnalyzer} that's being used to build the PATRICIA {@link Trie}.\n      */\n-    protected final KeyAnalyzer<? super K> keyAnalyzer;\n+    private final KeyAnalyzer<? super K> keyAnalyzer;\n \n     /**\n      * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n-     */\n-    public AbstractBitwiseTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n+     *\n+     * @param keyAnalyzer  the {@link KeyAnalyzer} to use\n+     */\n+    protected AbstractBitwiseTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n         if (keyAnalyzer == null) {\n             throw new NullPointerException(\"keyAnalyzer\");\n         }\n \n     /**\n      * Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n-     */\n-    public KeyAnalyzer<? super K> getKeyAnalyzer() {\n+     * @return the {@link KeyAnalyzer} used by this {@link Trie}\n+     */\n+    protected KeyAnalyzer<? super K> getKeyAnalyzer() {\n         return keyAnalyzer;\n     }\n-\n-    /**\n-     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n-     * metric to the given key. This is NOT lexicographic closeness.\n-     * For example, given the keys:\n-     *\n-     * <ol>\n-     * <li>D = 1000100\n-     * <li>H = 1001000\n-     * <li>L = 1001100\n-     * </ol>\n-     *\n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n-     * return 'L', because the XOR distance between D &amp; L is smaller\n-     * than the XOR distance between D &amp; H.\n-     *\n-     * @param key  the key to use in the search\n-     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n-     *   to the provided key\n-     */\n-    public abstract Map.Entry<K, V> select(K key);\n-\n-    /**\n-     * Returns the key that is closest in a bitwise XOR metric to the\n-     * provided key. This is NOT lexicographic closeness!\n-     *\n-     * For example, given the keys:\n-     *\n-     * <ol>\n-     * <li>D = 1000100\n-     * <li>H = 1001000\n-     * <li>L = 1001100\n-     * </ol>\n-     *\n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n-     * return 'L', because the XOR distance between D &amp; L is smaller\n-     * than the XOR distance between D &amp; H.\n-     *\n-     * @param key  the key to use in the search\n-     * @return the key that is closest in a bitwise XOR metric to the provided key\n-     */\n-    public K selectKey(final K key) {\n-        final Map.Entry<K, V> entry = select(key);\n-        if (entry == null) {\n-            return null;\n-        }\n-        return entry.getKey();\n-    }\n-\n-    /**\n-     * Returns the value whose key is closest in a bitwise XOR metric to\n-     * the provided key. This is NOT lexicographic closeness!\n-     *\n-     * For example, given the keys:\n-     *\n-     * <ol>\n-     * <li>D = 1000100\n-     * <li>H = 1001000\n-     * <li>L = 1001100\n-     * </ol>\n-     *\n-     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n-     * return 'L', because the XOR distance between D &amp; L is smaller\n-     * than the XOR distance between D &amp; H.\n-     *\n-     * @param key  the key to use in the search\n-     * @return the value whose key is closest in a bitwise XOR metric\n-     * to the provided key\n-     */\n-    public V selectValue(final K key) {\n-        final Map.Entry<K, V> entry = select(key);\n-        if (entry == null) {\n-            return null;\n-        }\n-        return entry.getValue();\n-    }\n-\n-    /**\n-     * Iterates through the {@link Trie}, starting with the entry whose bitwise\n-     * value is closest in an XOR metric to the given key. After the closest\n-     * entry is found, the {@link Trie} will call select on that entry and continue\n-     * calling select for each entry (traversing in order of XOR closeness,\n-     * NOT lexicographically) until the cursor returns {@link Cursor.Decision#EXIT}.\n-     * <p>\n-     * The cursor can return {@link Cursor.Decision#CONTINUE} to continue traversing.\n-     * <p>\n-     * {@link Cursor.Decision#REMOVE_AND_EXIT} is used to remove the current element\n-     * and stop traversing.\n-     * <p>\n-     * Note: The {@link Cursor.Decision#REMOVE} operation is not supported.\n-     *\n-     * @param key  the key to use in the search\n-     * @param cursor  the cursor used throughout the search\n-     * @return the entry the cursor returned {@link Cursor.Decision#EXIT} on, or null\n-     * if it continued till the end\n-     */\n-    public abstract Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n \n     @Override\n     public String toString() {\n \n         protected V value;\n \n-        private final int hashCode;\n-\n         public BasicEntry(final K key) {\n             this.key = key;\n-            this.hashCode = key != null ? key.hashCode() : 0;\n         }\n \n         public BasicEntry(final K key, final V value) {\n             this.key = key;\n             this.value = value;\n-            this.hashCode = (key != null ? key.hashCode() : 0) ^ (value != null ? value.hashCode() : 0);\n         }\n \n         /**\n \n         @Override\n         public int hashCode() {\n-            return hashCode;\n+            return (getKey() == null ? 0 : getKey().hashCode()) ^\n+                   (getValue() == null ? 0 : getValue().hashCode());\n         }\n \n         @Override\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.AbstractCollection;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.collections4.OrderedMapIterator;\n+\n+/**\n+ * This class implements the base PATRICIA algorithm and everything that\n+ * is related to the {@link Map} interface.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n+\n+    private static final long serialVersionUID = 5155253417231339498L;\n+\n+    /** The root node of the {@link Trie}. */\n+    private transient TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n+\n+    /**\n+     * Each of these fields are initialized to contain an instance of the\n+     * appropriate view the first time this view is requested. The views are\n+     * stateless, so there's no reason to create more than one of each.\n+     */\n+    private transient volatile Set<K> keySet;\n+    private transient volatile Collection<V> values;\n+    private transient volatile Set<Map.Entry<K,V>> entrySet;\n+\n+    /** The current size of the {@link Trie}. */\n+    private transient int size = 0;\n+\n+    /**\n+     * The number of times this {@link Trie} has been modified.\n+     * It's used to detect concurrent modifications and fail-fast the {@link Iterator}s.\n+     */\n+    protected transient int modCount = 0;\n+\n+    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n+        super(keyAnalyzer);\n+    }\n+\n+    /**\n+     * Constructs a new {@link org.apache.commons.collections4.Trie Trie} using the given\n+     * {@link KeyAnalyzer} and initializes the {@link org.apache.commons.collections4.Trie Trie}\n+     * with the values from the provided {@link Map}.\n+     */\n+    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer,\n+                                   final Map<? extends K, ? extends V> map) {\n+        super(keyAnalyzer);\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void clear() {\n+        root.key = null;\n+        root.bitIndex = -1;\n+        root.value = null;\n+\n+        root.parent = null;\n+        root.left = root;\n+        root.right = null;\n+        root.predecessor = root;\n+\n+        size = 0;\n+        incrementModCount();\n+    }\n+\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * A helper method to increment the {@link Trie} size and the modification counter.\n+     */\n+    void incrementSize() {\n+        size++;\n+        incrementModCount();\n+    }\n+\n+    /**\n+     * A helper method to decrement the {@link Trie} size and increment the modification counter.\n+     */\n+    void decrementSize() {\n+        size--;\n+        incrementModCount();\n+    }\n+\n+    /**\n+     * A helper method to increment the modification counter.\n+     */\n+    private void incrementModCount() {\n+        ++modCount;\n+    }\n+\n+    @Override\n+    public V put(final K key, final V value) {\n+        if (key == null) {\n+            throw new NullPointerException(\"Key cannot be null\");\n+        }\n+\n+        final int lengthInBits = lengthInBits(key);\n+\n+        // The only place to store a key with a length\n+        // of zero bits is the root node\n+        if (lengthInBits == 0) {\n+            if (root.isEmpty()) {\n+                incrementSize();\n+            } else {\n+                incrementModCount();\n+            }\n+            return root.setKeyValue(key, value);\n+        }\n+\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            if (found.isEmpty()) { // <- must be the root\n+                incrementSize();\n+            } else {\n+                incrementModCount();\n+            }\n+            return found.setKeyValue(key, value);\n+        }\n+\n+        final int bitIndex = bitIndex(key, found.key);\n+        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n+            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n+                /* NEW KEY+VALUE TUPLE */\n+                final TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n+                addEntry(t, lengthInBits);\n+                incrementSize();\n+                return null;\n+            } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n+                // A bits of the Key are zero. The only place to\n+                // store such a Key is the root Node!\n+\n+                /* NULL BIT KEY */\n+                if (root.isEmpty()) {\n+                    incrementSize();\n+                } else {\n+                    incrementModCount();\n+                }\n+                return root.setKeyValue(key, value);\n+\n+            } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n+                // This is a very special and rare case.\n+\n+                /* REPLACE OLD KEY+VALUE */\n+                if (found != root) {\n+                    incrementModCount();\n+                    return found.setKeyValue(key, value);\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n+    }\n+\n+    /**\n+     * Adds the given {@link TrieEntry} to the {@link Trie}.\n+     */\n+    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex >= entry.bitIndex\n+                    || current.bitIndex <= path.bitIndex) {\n+                entry.predecessor = entry;\n+\n+                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n+                    entry.left = entry;\n+                    entry.right = current;\n+                } else {\n+                    entry.left = current;\n+                    entry.right = entry;\n+                }\n+\n+                entry.parent = path;\n+                if (current.bitIndex >= entry.bitIndex) {\n+                    current.parent = entry;\n+                }\n+\n+                // if we inserted an uplink, set the predecessor on it\n+                if (current.bitIndex <= path.bitIndex) {\n+                    current.predecessor = entry;\n+                }\n+\n+                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n+                    path.left = entry;\n+                } else {\n+                    path.right = entry;\n+                }\n+\n+                return entry;\n+            }\n+\n+            path = current;\n+\n+            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public V get(final Object k) {\n+        final TrieEntry<K, V> entry = getEntry(k);\n+        return entry != null ? entry.getValue() : null;\n+    }\n+\n+    /**\n+     * Returns the entry associated with the specified key in the\n+     * PatriciaTrieBase.  Returns null if the map contains no mapping\n+     * for this key.\n+     * <p>\n+     * This may throw ClassCastException if the object is not of type K.\n+     */\n+    TrieEntry<K,V> getEntry(final Object k) {\n+        final K key = castKey(k);\n+        if (key == null) {\n+            return null;\n+        }\n+\n+        final int lengthInBits = lengthInBits(key);\n+        final TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n+        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n+    }\n+\n+    /**\n+     * Returns the {@link Entry} whose key is closest in a bitwise XOR\n+     * metric to the given key. This is NOT lexicographic closeness.\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n+     * @param key  the key to use in the search\n+     * @return the {@link Entry} whose key is closest in a bitwise XOR metric\n+     *   to the provided key\n+     */\n+    public Map.Entry<K, V> select(final K key) {\n+        final int lengthInBits = lengthInBits(key);\n+        final Reference<Map.Entry<K, V>> reference = new Reference<Map.Entry<K,V>>();\n+        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n+            return reference.get();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the key that is closest in a bitwise XOR metric to the\n+     * provided key. This is NOT lexicographic closeness!\n+     *\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n+     * @param key  the key to use in the search\n+     * @return the key that is closest in a bitwise XOR metric to the provided key\n+     */\n+    public K selectKey(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getKey();\n+    }\n+\n+    /**\n+     * Returns the value whose key is closest in a bitwise XOR metric to\n+     * the provided key. This is NOT lexicographic closeness!\n+     *\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     *\n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would\n+     * return 'L', because the XOR distance between D &amp; L is smaller\n+     * than the XOR distance between D &amp; H.\n+     *\n+     * @param key  the key to use in the search\n+     * @return the value whose key is closest in a bitwise XOR metric\n+     * to the provided key\n+     */\n+    public V selectValue(final K key) {\n+        final Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+\n+    /**\n+     * This is equivalent to the other {@link #selectR(TrieEntry, int, Object, int, Cursor, Reference)}\n+     * method but without its overhead because we're selecting only one best matching Entry from the {@link Trie}.\n+     */\n+    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex,\n+                            final K key, final int lengthInBits,\n+                            final Reference<Map.Entry<K, V>> reference) {\n+\n+        if (h.bitIndex <= bitIndex) {\n+            // If we hit the root Node and it is empty\n+            // we have to look for an alternative best\n+            // matching node.\n+            if (!h.isEmpty()) {\n+                reference.set(h);\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n+            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n+                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n+            }\n+        } else {\n+            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n+                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean containsKey(final Object k) {\n+        if (k == null) {\n+            return false;\n+        }\n+\n+        final K key = castKey(k);\n+        final int lengthInBits = lengthInBits(key);\n+        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n+        return !entry.isEmpty() && compareKeys(key, entry.key);\n+    }\n+\n+    @Override\n+    public Set<Map.Entry<K,V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet();\n+        }\n+        return entrySet;\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet();\n+        }\n+        return keySet;\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values();\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws ClassCastException if provided key is of an incompatible type\n+     */\n+    @Override\n+    public V remove(final Object k) {\n+        if (k == null) {\n+            return null;\n+        }\n+\n+        final K key = castKey(k);\n+        final int lengthInBits = lengthInBits(key);\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while (true) {\n+            if (current.bitIndex <= path.bitIndex) {\n+                if (!current.isEmpty() && compareKeys(key, current.key)) {\n+                    return removeEntry(current);\n+                } else {\n+                    return null;\n+                }\n+            }\n+\n+            path = current;\n+\n+            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the nearest entry for a given key.  This is useful\n+     * for finding knowing if a given key exists (and finding the value\n+     * for it), or for inserting the key.\n+     *\n+     * The actual get implementation. This is very similar to\n+     * selectR but with the exception that it might return the\n+     * root Entry even if it's empty.\n+     */\n+    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex <= path.bitIndex) {\n+                return current;\n+            }\n+\n+            path = current;\n+            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Removes a single entry from the {@link Trie}.\n+     *\n+     * If we found a Key (Entry h) then figure out if it's\n+     * an internal (hard to remove) or external Entry (easy\n+     * to remove)\n+     */\n+    V removeEntry(final TrieEntry<K, V> h) {\n+        if (h != root) {\n+            if (h.isInternalNode()) {\n+                removeInternalEntry(h);\n+            } else {\n+                removeExternalEntry(h);\n+            }\n+        }\n+\n+        decrementSize();\n+        return h.setKeyValue(null, null);\n+    }\n+\n+    /**\n+     * Removes an external entry from the {@link Trie}.\n+     *\n+     * If it's an external Entry then just remove it.\n+     * This is very easy and straight forward.\n+     */\n+    private void removeExternalEntry(final TrieEntry<K, V> h) {\n+        if (h == root) {\n+            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n+        } else if (!h.isExternalNode()) {\n+            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n+        }\n+\n+        final TrieEntry<K, V> parent = h.parent;\n+        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n+\n+        if (parent.left == h) {\n+            parent.left = child;\n+        } else {\n+            parent.right = child;\n+        }\n+\n+        // either the parent is changing, or the predecessor is changing.\n+        if (child.bitIndex > parent.bitIndex) {\n+            child.parent = parent;\n+        } else {\n+            child.predecessor = parent;\n+        }\n+\n+    }\n+\n+    /**\n+     * Removes an internal entry from the {@link Trie}.\n+     *\n+     * If it's an internal Entry then \"good luck\" with understanding\n+     * this code. The Idea is essentially that Entry p takes Entry h's\n+     * place in the trie which requires some re-wiring.\n+     */\n+    private void removeInternalEntry(final TrieEntry<K, V> h) {\n+        if (h == root) {\n+            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n+        } else if (!h.isInternalNode()) {\n+            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n+        }\n+\n+        final TrieEntry<K, V> p = h.predecessor;\n+\n+        // Set P's bitIndex\n+        p.bitIndex = h.bitIndex;\n+\n+        // Fix P's parent, predecessor and child Nodes\n+        {\n+            final TrieEntry<K, V> parent = p.parent;\n+            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n+\n+            // if it was looping to itself previously,\n+            // it will now be pointed from it's parent\n+            // (if we aren't removing it's parent --\n+            //  in that case, it remains looping to itself).\n+            // otherwise, it will continue to have the same\n+            // predecessor.\n+            if (p.predecessor == p && p.parent != h) {\n+                p.predecessor = p.parent;\n+            }\n+\n+            if (parent.left == p) {\n+                parent.left = child;\n+            } else {\n+                parent.right = child;\n+            }\n+\n+            if (child.bitIndex > parent.bitIndex) {\n+                child.parent = parent;\n+            }\n+        }\n+\n+        // Fix H's parent and child Nodes\n+        {\n+            // If H is a parent of its left and right child\n+            // then change them to P\n+            if (h.left.parent == h) {\n+                h.left.parent = p;\n+            }\n+\n+            if (h.right.parent == h) {\n+                h.right.parent = p;\n+            }\n+\n+            // Change H's parent\n+            if (h.parent.left == h) {\n+                h.parent.left = p;\n+            } else {\n+                h.parent.right = p;\n+            }\n+        }\n+\n+        // Copy the remaining fields from H to P\n+        //p.bitIndex = h.bitIndex;\n+        p.parent = h.parent;\n+        p.left = h.left;\n+        p.right = h.right;\n+\n+        // Make sure that if h was pointing to any uplinks,\n+        // p now points to them.\n+        if (isValidUplink(p.left, p)) {\n+            p.left.predecessor = p;\n+        }\n+\n+        if (isValidUplink(p.right, p)) {\n+            p.right.predecessor = p;\n+        }\n+    }\n+\n+    /**\n+     * Returns the entry lexicographically after the given entry.\n+     * If the given entry is null, returns the first node.\n+     */\n+    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n+        if (node == null) {\n+            return firstEntry();\n+        } else {\n+            return nextEntryImpl(node.predecessor, node, null);\n+        }\n+    }\n+\n+    /**\n+     * Scans for the next node, starting at the specified point, and using 'previous'\n+     * as a hint that the last node we returned was 'previous' (so we know not to return\n+     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n+     *\n+     * The basic premise is that each iteration can follow the following steps:\n+     *\n+     * 1) Scan all the way to the left.\n+     *   a) If we already started from this node last time, proceed to Step 2.\n+     *   b) If a valid uplink is found, use it.\n+     *   c) If the result is an empty node (root not set), break the scan.\n+     *   d) If we already returned the left node, break the scan.\n+     *\n+     * 2) Check the right.\n+     *   a) If we already returned the right node, proceed to Step 3.\n+     *   b) If it is a valid uplink, use it.\n+     *   c) Do Step 1 from the right node.\n+     *\n+     * 3) Back up through the parents until we encounter find a parent\n+     *    that we're not the right child of.\n+     *\n+     * 4) If there's no right child of that parent, the iteration is finished.\n+     *    Otherwise continue to Step 5.\n+     *\n+     * 5) Check to see if the right child is a valid uplink.\n+     *    a) If we already returned that child, proceed to Step 6.\n+     *       Otherwise, use it.\n+     *\n+     * 6) If the right child of the parent is the parent itself, we've\n+     *    already found & returned the end of the Trie, so exit.\n+     *\n+     * 7) Do Step 1 on the parent's right child.\n+     */\n+    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n+            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n+\n+        TrieEntry<K, V> current = start;\n+\n+        // Only look at the left if this was a recursive or\n+        // the first check, otherwise we know we've already looked\n+        // at the left.\n+        if (previous == null || start != previous.predecessor) {\n+            while (!current.left.isEmpty()) {\n+                // stop traversing if we've already\n+                // returned the left of this node.\n+                if (previous == current.left) {\n+                    break;\n+                }\n+\n+                if (isValidUplink(current.left, current)) {\n+                    return current.left;\n+                }\n+\n+                current = current.left;\n+            }\n+        }\n+\n+        // If there's no data at all, exit.\n+        if (current.isEmpty()) {\n+            return null;\n+        }\n+\n+        // If we've already returned the left,\n+        // and the immediate right is null,\n+        // there's only one entry in the Trie\n+        // which is stored at the root.\n+        //\n+        //  / (\"\")   <-- root\n+        //  \\_/  \\\n+        //       null <-- 'current'\n+        //\n+        if (current.right == null) {\n+            return null;\n+        }\n+\n+        // If nothing valid on the left, try the right.\n+        if (previous != current.right) {\n+            // See if it immediately is valid.\n+            if (isValidUplink(current.right, current)) {\n+                return current.right;\n+            }\n+\n+            // Must search on the right's side if it wasn't initially valid.\n+            return nextEntryImpl(current.right, previous, tree);\n+        }\n+\n+        // Neither left nor right are valid, find the first parent\n+        // whose child did not come from the right & traverse it.\n+        while (current == current.parent.right) {\n+            // If we're going to traverse to above the subtree, stop.\n+            if (current == tree) {\n+                return null;\n+            }\n+\n+            current = current.parent;\n+        }\n+\n+        // If we're on the top of the subtree, we can't go any higher.\n+        if (current == tree) {\n+            return null;\n+        }\n+\n+        // If there's no right, the parent must be root, so we're done.\n+        if (current.parent.right == null) {\n+            return null;\n+        }\n+\n+        // If the parent's right points to itself, we've found one.\n+        if (previous != current.parent.right\n+                && isValidUplink(current.parent.right, current.parent)) {\n+            return current.parent.right;\n+        }\n+\n+        // If the parent's right is itself, there can't be any more nodes.\n+        if (current.parent.right == current.parent) {\n+            return null;\n+        }\n+\n+        // We need to traverse down the parent's right's path.\n+        return nextEntryImpl(current.parent.right, previous, tree);\n+    }\n+\n+    /**\n+     * Returns the first entry the {@link Trie} is storing.\n+     * <p>\n+     * This is implemented by going always to the left until\n+     * we encounter a valid uplink. That uplink is the first key.\n+     */\n+    TrieEntry<K, V> firstEntry() {\n+        // if Trie is empty, no first node.\n+        if (isEmpty()) {\n+            return null;\n+        }\n+\n+        return followLeft(root);\n+    }\n+\n+    /**\n+     * Goes left through the tree until it finds a valid node.\n+     */\n+    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n+        while(true) {\n+            TrieEntry<K, V> child = node.left;\n+            // if we hit root and it didn't have a node, go right instead.\n+            if (child.isEmpty()) {\n+                child = node.right;\n+            }\n+\n+            if (child.bitIndex <= node.bitIndex) {\n+                return child;\n+            }\n+\n+            node = child;\n+        }\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     *\n+     * @return the hash code defined in the Map interface\n+     */\n+    @Override\n+    public int hashCode() {\n+        int total = 0;\n+        final Iterator<Entry<K, V>> it = new MyEntryIterator();\n+\n+        while (it.hasNext()) {\n+            total += it.next().hashCode();\n+        }\n+        return total;\n+    }\n+\n+    private class MyEntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+        public Map.Entry<K,V> next() {\n+            return nextEntry();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public Comparator<? super K> comparator() {\n+        return getKeyAnalyzer();\n+    }\n+\n+    public K firstKey() {\n+        if (size() == 0) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return firstEntry().getKey();\n+        }\n+    }\n+\n+    public K lastKey() {\n+        final TrieEntry<K, V> entry = lastEntry();\n+        if (entry != null) {\n+            return entry.getKey();\n+        } else {\n+            throw new NoSuchElementException();\n+        }\n+    }\n+\n+    public K nextKey(final K key) {\n+        if (key == null) {\n+            throw new NullPointerException();\n+        }\n+        final TrieEntry<K, V> entry = getEntry(key);\n+        if (entry != null) {\n+            final TrieEntry<K, V> nextEntry = nextEntry(entry);\n+            return nextEntry != null ? nextEntry.getKey() : null;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public K previousKey(final K key) {\n+        if (key == null) {\n+            throw new NullPointerException();\n+        }\n+        final TrieEntry<K, V> entry = getEntry(key);\n+        if (entry != null) {\n+            final TrieEntry<K, V> prevEntry = previousEntry(entry);\n+            return prevEntry != null ? prevEntry.getKey() : null;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new TrieMapIterator();\n+    }\n+\n+    public SortedMap<K, V> prefixMap(final K key) {\n+        return getPrefixMapByBits(key, 0, lengthInBits(key));\n+    }\n+\n+    /**\n+     * Returns a view of this {@link Trie} of all elements that are prefixed\n+     * by the number of bits in the given Key.\n+     * <p>\n+     * The view that this returns is optimized to have a very efficient\n+     * {@link Iterator}. The {@link SortedMap#firstKey()},\n+     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n+     * iterate over all possible values in order to determine the results.\n+     * This information is cached until the PATRICIA {@link Trie} changes.\n+     * All other methods (except {@link Iterator}) must compare the given\n+     * key to the prefix to ensure that it is within the range of the view.\n+     * The {@link Iterator}'s remove method must also relocate the subtree\n+     * that contains the prefixes if the entry holding the subtree is\n+     * removed or changes. Changing the subtree takes O(K) time.\n+     *\n+     * @param key  the key to use in the search\n+     * @param offsetInBits  the prefix offset\n+     * @param lengthInBits  the number of significant prefix bits\n+     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n+     *   key is prefixed by the search key\n+     */\n+    private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {\n+\n+        final int offsetLength = offsetInBits + lengthInBits;\n+        if (offsetLength > lengthInBits(key)) {\n+            throw new IllegalArgumentException(offsetInBits + \" + \"\n+                    + lengthInBits + \" > \" + lengthInBits(key));\n+        }\n+\n+        if (offsetLength == 0) {\n+            return this;\n+        }\n+\n+        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n+    }\n+\n+    public SortedMap<K, V> headMap(final K toKey) {\n+        return new RangeEntryMap(null, toKey);\n+    }\n+\n+    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+        return new RangeEntryMap(fromKey, toKey);\n+    }\n+\n+    public SortedMap<K, V> tailMap(final K fromKey) {\n+        return new RangeEntryMap(fromKey, null);\n+    }\n+\n+    /**\n+     * Returns an entry strictly higher than the given key,\n+     * or null if no such entry exists.\n+     */\n+    TrieEntry<K,V> higherEntry(final K key) {\n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined\n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+\n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                // If data in root, and more after -- return it.\n+                if (size() > 1) {\n+                    return nextEntry(root);\n+                } else { // If no more after, no higher entry.\n+                    return null;\n+                }\n+            } else {\n+                // Root is empty & we want something after empty, return first.\n+                return firstEntry();\n+            }\n+        }\n+\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return nextEntry(found);\n+        }\n+\n+        final int bitIndex = bitIndex(key, found.key);\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> ceil = nextEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return ceil;\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return firstEntry();\n+            } else if (size() > 1) {\n+                return nextEntry(firstEntry());\n+            } else {\n+                return null;\n+            }\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return nextEntry(found);\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+\n+    /**\n+     * Returns a key-value mapping associated with the least key greater\n+     * than or equal to the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> ceilingEntry(final K key) {\n+        // Basically:\n+        // Follow the steps of adding an entry, but instead...\n+        //\n+        // - If we ever encounter a situation where we found an equal\n+        //   key, we return it immediately.\n+        //\n+        // - If we hit an empty root, return the first iterable item.\n+        //\n+        // - If we have to add a new item, we temporarily add it,\n+        //   find the successor to it, then remove the added item.\n+        //\n+        // These steps ensure that the returned value is either the\n+        // entry for the key itself, or the first entry directly after\n+        // the key.\n+\n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined\n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+\n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return firstEntry();\n+            }\n+        }\n+\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return found;\n+        }\n+\n+        final int bitIndex = bitIndex(key, found.key);\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> ceil = nextEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return ceil;\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return firstEntry();\n+            }\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return found;\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+\n+    /**\n+     * Returns a key-value mapping associated with the greatest key\n+     * strictly less than the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> lowerEntry(final K key) {\n+        // Basically:\n+        // Follow the steps of adding an entry, but instead...\n+        //\n+        // - If we ever encounter a situation where we found an equal\n+        //   key, we return it's previousEntry immediately.\n+        //\n+        // - If we hit root (empty or not), return null.\n+        //\n+        // - If we have to add a new item, we temporarily add it,\n+        //   find the previousEntry to it, then remove the added item.\n+        //\n+        // These steps ensure that the returned value is always just before\n+        // the key or null (if there was nothing before it).\n+\n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined\n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+\n+        if (lengthInBits == 0) {\n+            return null; // there can never be anything before root.\n+        }\n+\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return previousEntry(found);\n+        }\n+\n+        final int bitIndex = bitIndex(key, found.key);\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> prior = previousEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return prior;\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n+            return null;\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return previousEntry(found);\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+\n+    /**\n+     * Returns a key-value mapping associated with the greatest key\n+     * less than or equal to the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> floorEntry(final K key) {\n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined\n+        //       functions to perform the search.)\n+        final int lengthInBits = lengthInBits(key);\n+\n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return found;\n+        }\n+\n+        final int bitIndex = bitIndex(key, found.key);\n+        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            final TrieEntry<K, V> floor = previousEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return floor;\n+        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return null;\n+            }\n+        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return found;\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+\n+    /**\n+     * Finds the subtree that contains the prefix.\n+     *\n+     * This is very similar to getR but with the difference that\n+     * we stop the lookup if h.bitIndex > lengthInBits.\n+     */\n+    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex <= path.bitIndex || lengthInBits < current.bitIndex) {\n+                break;\n+            }\n+\n+            path = current;\n+            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+\n+        // Make sure the entry is valid for a subtree.\n+        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n+\n+        // If entry is root, it can't be empty.\n+        if (entry.isEmpty()) {\n+            return null;\n+        }\n+\n+        final int endIndexInBits = offsetInBits + lengthInBits;\n+\n+        // if root && length of root is less than length of lookup,\n+        // there's nothing.\n+        // (this prevents returning the whole subtree if root has an empty\n+        //  string and we want to lookup things with \"\\0\")\n+        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n+            return null;\n+        }\n+\n+        // Found key's length-th bit differs from our key\n+        // which means it cannot be the prefix...\n+        if (isBitSet(prefix, endIndexInBits, endIndexInBits)\n+                != isBitSet(entry.key, lengthInBits, lengthInBits(entry.key))) {\n+            return null;\n+        }\n+\n+        // ... or there are less than 'length' equal bits\n+        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,\n+                                                       entry.key, 0, lengthInBits(entry.getKey()));\n+\n+        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n+            return null;\n+        }\n+\n+        return entry;\n+    }\n+\n+    /**\n+     * Returns the last entry the {@link Trie} is storing.\n+     *\n+     * <p>This is implemented by going always to the right until\n+     * we encounter a valid uplink. That uplink is the last key.\n+     */\n+    TrieEntry<K, V> lastEntry() {\n+        return followRight(root.left);\n+    }\n+\n+    /**\n+     * Traverses down the right path until it finds an uplink.\n+     */\n+    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n+        // if Trie is empty, no last entry.\n+        if (node.right == null) {\n+            return null;\n+        }\n+\n+        // Go as far right as possible, until we encounter an uplink.\n+        while (node.right.bitIndex > node.bitIndex) {\n+            node = node.right;\n+        }\n+\n+        return node.right;\n+    }\n+\n+    /**\n+     * Returns the node lexicographically before the given node (or null if none).\n+     *\n+     * This follows four simple branches:\n+     *  - If the uplink that returned us was a right uplink:\n+     *      - If predecessor's left is a valid uplink from predecessor, return it.\n+     *      - Else, follow the right path from the predecessor's left.\n+     *  - If the uplink that returned us was a left uplink:\n+     *      - Loop back through parents until we encounter a node where\n+     *        node != node.parent.left.\n+     *          - If node.parent.left is uplink from node.parent:\n+     *              - If node.parent.left is not root, return it.\n+     *              - If it is root & root isEmpty, return null.\n+     *              - If it is root & root !isEmpty, return root.\n+     *          - If node.parent.left is not uplink from node.parent:\n+     *              - Follow right path for first right child from node.parent.left\n+     *\n+     * @param start  the start entry\n+     */\n+    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n+        if (start.predecessor == null) {\n+            throw new IllegalArgumentException(\"must have come from somewhere!\");\n+        }\n+\n+        if (start.predecessor.right == start) {\n+            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n+                return start.predecessor.left;\n+            } else {\n+                return followRight(start.predecessor.left);\n+            }\n+        } else {\n+            TrieEntry<K, V> node = start.predecessor;\n+            while (node.parent != null && node == node.parent.left) {\n+                node = node.parent;\n+            }\n+\n+            if (node.parent == null) { // can be null if we're looking up root.\n+                return null;\n+            }\n+\n+            if (isValidUplink(node.parent.left, node.parent)) {\n+                if (node.parent.left == root) {\n+                    if (root.isEmpty()) {\n+                        return null;\n+                    } else {\n+                        return root;\n+                    }\n+\n+                } else {\n+                    return node.parent.left;\n+                }\n+            } else {\n+                return followRight(node.parent.left);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns the entry lexicographically after the given entry.\n+     * If the given entry is null, returns the first node.\n+     *\n+     * This will traverse only within the subtree.  If the given node\n+     * is not within the subtree, this will have undefined results.\n+     */\n+    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n+            final TrieEntry<K, V> parentOfSubtree) {\n+        if (node == null) {\n+            return firstEntry();\n+        } else {\n+            return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if 'next' is a valid uplink coming from 'from'.\n+     */\n+    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n+        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n+    }\n+\n+    /**\n+     * A {@link Reference} allows us to return something through a Method's\n+     * argument list. An alternative would be to an Array with a length of\n+     * one (1) but that leads to compiler warnings. Computationally and memory\n+     * wise there's no difference (except for the need to load the\n+     * {@link Reference} Class but that happens only once).\n+     */\n+    private static class Reference<E> {\n+\n+        private E item;\n+\n+        public void set(final E item) {\n+            this.item = item;\n+        }\n+\n+        public E get() {\n+            return item;\n+        }\n+    }\n+\n+    /**\n+     *  A {@link Trie} is a set of {@link TrieEntry} nodes.\n+     */\n+    protected static class TrieEntry<K,V> extends BasicEntry<K, V> {\n+\n+        private static final long serialVersionUID = 4596023148184140013L;\n+\n+        /** The index this entry is comparing. */\n+        protected int bitIndex;\n+\n+        /** The parent of this entry. */\n+        protected TrieEntry<K,V> parent;\n+\n+        /** The left child of this entry. */\n+        protected TrieEntry<K,V> left;\n+\n+        /** The right child of this entry. */\n+        protected TrieEntry<K,V> right;\n+\n+        /** The entry who uplinks to this entry. */\n+        protected TrieEntry<K,V> predecessor;\n+\n+        public TrieEntry(final K key, final V value, final int bitIndex) {\n+            super(key, value);\n+\n+            this.bitIndex = bitIndex;\n+\n+            this.parent = null;\n+            this.left = this;\n+            this.right = null;\n+            this.predecessor = this;\n+        }\n+\n+        /**\n+         * Whether or not the entry is storing a key.\n+         * Only the root can potentially be empty, all other\n+         * nodes must have a key.\n+         */\n+        public boolean isEmpty() {\n+            return key == null;\n+        }\n+\n+        /**\n+         * Neither the left nor right child is a loopback.\n+         */\n+        public boolean isInternalNode() {\n+            return left != this && right != this;\n+        }\n+\n+        /**\n+         * Either the left or right child is a loopback.\n+         */\n+        public boolean isExternalNode() {\n+            return !isInternalNode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final StringBuilder buffer = new StringBuilder();\n+\n+            if (bitIndex == -1) {\n+                buffer.append(\"RootEntry(\");\n+            } else {\n+                buffer.append(\"Entry(\");\n+            }\n+\n+            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n+            buffer.append(\"value=\").append(getValue()).append(\", \");\n+            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n+\n+            if (parent != null) {\n+                if (parent.bitIndex == -1) {\n+                    buffer.append(\"parent=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"parent=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+\n+            if (left != null) {\n+                if (left.bitIndex == -1) {\n+                    buffer.append(\"left=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"left=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+\n+            if (right != null) {\n+                if (right.bitIndex == -1) {\n+                    buffer.append(\"right=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"right=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+\n+            if (predecessor != null) {\n+                if(predecessor.bitIndex == -1) {\n+                    buffer.append(\"predecessor=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n+                           append(predecessor.bitIndex).append(\"]\");\n+                }\n+            }\n+\n+            buffer.append(\")\");\n+            return buffer.toString();\n+        }\n+    }\n+\n+\n+    /**\n+     * This is a entry set view of the {@link Trie} as returned by {@link Map#entrySet()}.\n+     */\n+    private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n+\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            return new EntryIterator();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            final TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n+            return candidate != null && candidate.equals(o);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            if (contains(obj) == false) {\n+                return false;\n+            }\n+            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n+            AbstractPatriciaTrie.this.remove(entry.getKey());\n+            return true;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return AbstractPatriciaTrie.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            AbstractPatriciaTrie.this.clear();\n+        }\n+\n+        /**\n+         * An {@link Iterator} that returns {@link Entry} Objects.\n+         */\n+        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+            public Map.Entry<K,V> next() {\n+                return nextEntry();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This is a key set view of the {@link Trie} as returned by {@link Map#keySet()}.\n+     */\n+    private class KeySet extends AbstractSet<K> {\n+\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new KeyIterator();\n+        }\n+\n+        @Override\n+        public int size() {\n+            return AbstractPatriciaTrie.this.size();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object o) {\n+            return containsKey(o);\n+        }\n+\n+        @Override\n+        public boolean remove(final Object o) {\n+            final int size = size();\n+            AbstractPatriciaTrie.this.remove(o);\n+            return size != size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            AbstractPatriciaTrie.this.clear();\n+        }\n+\n+        /**\n+         * An {@link Iterator} that returns Key Objects.\n+         */\n+        private class KeyIterator extends TrieIterator<K> {\n+            public K next() {\n+                return nextEntry().getKey();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This is a value view of the {@link Trie} as returned by {@link Map#values()}.\n+     */\n+    private class Values extends AbstractCollection<V> {\n+\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new ValueIterator();\n+        }\n+\n+        @Override\n+        public int size() {\n+            return AbstractPatriciaTrie.this.size();\n+        }\n+\n+        @Override\n+        public boolean contains(final Object o) {\n+            return containsValue(o);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            AbstractPatriciaTrie.this.clear();\n+        }\n+\n+        @Override\n+        public boolean remove(final Object o) {\n+            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n+                final V value = it.next();\n+                if (compare(value, o)) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * An {@link Iterator} that returns Value Objects.\n+         */\n+        private class ValueIterator extends TrieIterator<V> {\n+            public V next() {\n+                return nextEntry().getValue();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * An iterator for the entries.\n+     */\n+    abstract class TrieIterator<E> implements Iterator<E> {\n+\n+        /** For fast-fail. */\n+        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;\n+\n+        protected TrieEntry<K, V> next; // the next node to return\n+        protected TrieEntry<K, V> current; // the current entry we're on\n+\n+        /**\n+         * Starts iteration from the root.\n+         */\n+        protected TrieIterator() {\n+            next = AbstractPatriciaTrie.this.nextEntry(null);\n+        }\n+\n+        /**\n+         * Starts iteration at the given entry.\n+         */\n+        protected TrieIterator(final TrieEntry<K, V> firstEntry) {\n+            next = firstEntry;\n+        }\n+\n+        /**\n+         * Returns the next {@link TrieEntry}.\n+         */\n+        protected TrieEntry<K,V> nextEntry() {\n+            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+\n+            final TrieEntry<K,V> e = next;\n+            if (e == null) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            next = findNext(e);\n+            current = e;\n+            return e;\n+        }\n+\n+        /**\n+         * @see PatriciaTrie#nextEntry(TrieEntry)\n+         */\n+        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n+            return AbstractPatriciaTrie.this.nextEntry(prior);\n+        }\n+\n+        public boolean hasNext() {\n+            return next != null;\n+        }\n+\n+        public void remove() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+\n+            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+\n+            final TrieEntry<K, V> node = current;\n+            current = null;\n+            AbstractPatriciaTrie.this.removeEntry(node);\n+\n+            expectedModCount = AbstractPatriciaTrie.this.modCount;\n+        }\n+    }\n+\n+    /**\n+     * An {@link OrderedMapIterator} for a {@link Trie}.\n+     */\n+    private class TrieMapIterator extends TrieIterator<K> implements OrderedMapIterator<K, V> {\n+\n+        protected TrieEntry<K, V> previous; // the previous node to return\n+\n+        public K next() {\n+            return nextEntry().getKey();\n+        }\n+\n+        public K getKey() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current.getKey();\n+        }\n+\n+        public V getValue() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current.getValue();\n+        }\n+\n+        public V setValue(final V value) {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            return current.setValue(value);\n+        }\n+\n+        public boolean hasPrevious() {\n+            return previous != null;\n+        }\n+\n+        public K previous() {\n+            return previousEntry().getKey();\n+        }\n+\n+        @Override\n+        protected TrieEntry<K, V> nextEntry() {\n+            final TrieEntry<K, V> nextEntry = super.nextEntry();\n+            previous = nextEntry;\n+            return nextEntry;\n+        }\n+\n+        protected TrieEntry<K,V> previousEntry() {\n+            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+\n+            final TrieEntry<K,V> e = previous;\n+            if (e == null) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            previous = AbstractPatriciaTrie.this.previousEntry(e);\n+            next = current;\n+            current = e;\n+            return current;\n+        }\n+\n+    }\n+\n+    /**\n+     * A range view of the {@link Trie}.\n+     */\n+    private abstract class RangeMap extends AbstractMap<K, V>\n+            implements SortedMap<K, V> {\n+\n+        /** The {@link #entrySet()} view. */\n+        private transient volatile Set<Map.Entry<K, V>> entrySet;\n+\n+        /**\n+         * Creates and returns an {@link #entrySet()} view of the {@link RangeMap}.\n+         */\n+        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n+\n+        /**\n+         * Returns the FROM Key.\n+         */\n+        protected abstract K getFromKey();\n+\n+        /**\n+         * Whether or not the {@link #getFromKey()} is in the range.\n+         */\n+        protected abstract boolean isFromInclusive();\n+\n+        /**\n+         * Returns the TO Key.\n+         */\n+        protected abstract K getToKey();\n+\n+        /**\n+         * Whether or not the {@link #getToKey()} is in the range.\n+         */\n+        protected abstract boolean isToInclusive();\n+\n+        public Comparator<? super K> comparator() {\n+            return AbstractPatriciaTrie.this.comparator();\n+        }\n+\n+        @Override\n+        public boolean containsKey(final Object key) {\n+            if (!inRange(castKey(key))) {\n+                return false;\n+            }\n+\n+            return AbstractPatriciaTrie.this.containsKey(key);\n+        }\n+\n+        @Override\n+        public V remove(final Object key) {\n+            if (!inRange(castKey(key))) {\n+                return null;\n+            }\n+\n+            return AbstractPatriciaTrie.this.remove(key);\n+        }\n+\n+        @Override\n+        public V get(final Object key) {\n+            if (!inRange(castKey(key))) {\n+                return null;\n+            }\n+\n+            return AbstractPatriciaTrie.this.get(key);\n+        }\n+\n+        @Override\n+        public V put(final K key, final V value) {\n+            if (!inRange(key)) {\n+                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n+            }\n+            return AbstractPatriciaTrie.this.put(key, value);\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> entrySet() {\n+            if (entrySet == null) {\n+                entrySet = createEntrySet();\n+            }\n+            return entrySet;\n+        }\n+\n+        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n+            if (!inRange2(fromKey)) {\n+                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n+            }\n+\n+            if (!inRange2(toKey)) {\n+                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n+            }\n+\n+            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n+        }\n+\n+        public SortedMap<K, V> headMap(final K toKey) {\n+            if (!inRange2(toKey)) {\n+                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n+            }\n+            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n+        }\n+\n+        public SortedMap<K, V> tailMap(final K fromKey) {\n+            if (!inRange2(fromKey)) {\n+                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n+            }\n+            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n+        }\n+\n+        /**\n+         * Returns true if the provided key is greater than TO and less than FROM.\n+         */\n+        protected boolean inRange(final K key) {\n+            final K fromKey = getFromKey();\n+            final K toKey = getToKey();\n+\n+            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n+        }\n+\n+        /**\n+         * This form allows the high endpoint (as well as all legit keys).\n+         */\n+        protected boolean inRange2(final K key) {\n+            final K fromKey = getFromKey();\n+            final K toKey = getToKey();\n+\n+            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the FROM range of the {@link RangeMap}.\n+         */\n+        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n+            final K fromKey = getFromKey();\n+            final boolean fromInclusive = isFromInclusive();\n+\n+            final int ret = getKeyAnalyzer().compare(key, fromKey);\n+            if (fromInclusive || forceInclusive) {\n+                return ret >= 0;\n+            } else {\n+                return ret > 0;\n+            }\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the TO range of the {@link RangeMap}.\n+         */\n+        protected boolean inToRange(final K key, final boolean forceInclusive) {\n+            final K toKey = getToKey();\n+            final boolean toInclusive = isToInclusive();\n+\n+            final int ret = getKeyAnalyzer().compare(key, toKey);\n+            if (toInclusive || forceInclusive) {\n+                return ret <= 0;\n+            } else {\n+                return ret < 0;\n+            }\n+        }\n+\n+        /**\n+         * Creates and returns a sub-range view of the current {@link RangeMap}.\n+         */\n+        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n+                                                          K toKey, boolean toInclusive);\n+    }\n+\n+   /**\n+    * A {@link RangeMap} that deals with {@link Entry}s.\n+    */\n+   private class RangeEntryMap extends RangeMap {\n+\n+       /** The key to start from, null if the beginning. */\n+       private final K fromKey;\n+\n+       /** The key to end at, null if till the end. */\n+       private final K toKey;\n+\n+       /** Whether or not the 'from' is inclusive. */\n+       private final boolean fromInclusive;\n+\n+       /** Whether or not the 'to' is inclusive. */\n+       private final boolean toInclusive;\n+\n+       /**\n+        * Creates a {@link RangeEntryMap} with the fromKey included and\n+        * the toKey excluded from the range.\n+        */\n+       protected RangeEntryMap(final K fromKey, final K toKey) {\n+           this(fromKey, true, toKey, false);\n+       }\n+\n+       /**\n+        * Creates a {@link RangeEntryMap}.\n+        */\n+       protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n+                               final K toKey, final boolean toInclusive) {\n+\n+           if (fromKey == null && toKey == null) {\n+               throw new IllegalArgumentException(\"must have a from or to!\");\n+           }\n+\n+           if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n+               throw new IllegalArgumentException(\"fromKey > toKey\");\n+           }\n+\n+           this.fromKey = fromKey;\n+           this.fromInclusive = fromInclusive;\n+           this.toKey = toKey;\n+           this.toInclusive = toInclusive;\n+       }\n+\n+       public K firstKey() {\n+           Map.Entry<K,V> e = null;\n+           if (fromKey == null) {\n+               e = firstEntry();\n+           } else {\n+               if (fromInclusive) {\n+                   e = ceilingEntry(fromKey);\n+               } else {\n+                   e = higherEntry(fromKey);\n+               }\n+           }\n+\n+           final K first = e != null ? e.getKey() : null;\n+           if (e == null || toKey != null && !inToRange(first, false)) {\n+               throw new NoSuchElementException();\n+           }\n+           return first;\n+       }\n+\n+       public K lastKey() {\n+           Map.Entry<K,V> e;\n+           if (toKey == null) {\n+               e = lastEntry();\n+           } else {\n+               if (toInclusive) {\n+                   e = floorEntry(toKey);\n+               } else {\n+                   e = lowerEntry(toKey);\n+               }\n+           }\n+\n+           final K last = e != null ? e.getKey() : null;\n+           if (e == null || fromKey != null && !inFromRange(last, false)) {\n+               throw new NoSuchElementException();\n+           }\n+           return last;\n+       }\n+\n+       @Override\n+       protected Set<Entry<K, V>> createEntrySet() {\n+           return new RangeEntrySet(this);\n+       }\n+\n+       @Override\n+       public K getFromKey() {\n+           return fromKey;\n+       }\n+\n+       @Override\n+       public K getToKey() {\n+           return toKey;\n+       }\n+\n+       @Override\n+       public boolean isFromInclusive() {\n+           return fromInclusive;\n+       }\n+\n+       @Override\n+       public boolean isToInclusive() {\n+           return toInclusive;\n+       }\n+\n+       @Override\n+       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n+                                                final K toKey, final boolean toInclusive) {\n+           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n+       }\n+   }\n+\n+    /**\n+     * A {@link Set} view of a {@link RangeMap}.\n+     */\n+    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n+\n+        private final RangeMap delegate;\n+\n+        private transient int size = -1;\n+\n+        private transient int expectedModCount;\n+\n+        /**\n+         * Creates a {@link RangeEntrySet}.\n+         */\n+        public RangeEntrySet(final RangeMap delegate) {\n+            if (delegate == null) {\n+                throw new NullPointerException(\"delegate\");\n+            }\n+\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            final K fromKey = delegate.getFromKey();\n+            final K toKey = delegate.getToKey();\n+\n+            TrieEntry<K, V> first = null;\n+            if (fromKey == null) {\n+                first = firstEntry();\n+            } else {\n+                first = ceilingEntry(fromKey);\n+            }\n+\n+            TrieEntry<K, V> last = null;\n+            if (toKey != null) {\n+                last = ceilingEntry(toKey);\n+            }\n+\n+            return new EntryIterator(first, last);\n+        }\n+\n+        @Override\n+        public int size() {\n+            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n+                size = 0;\n+\n+                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n+                    ++size;\n+                }\n+\n+                expectedModCount = AbstractPatriciaTrie.this.modCount;\n+            }\n+            return size;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return !iterator().hasNext();\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public boolean contains(final Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            final K key = entry.getKey();\n+            if (!delegate.inRange(key)) {\n+                return false;\n+            }\n+\n+            final TrieEntry<K, V> node = getEntry(key);\n+            return node != null && compare(node.getValue(), entry.getValue());\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public boolean remove(final Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            final K key = entry.getKey();\n+            if (!delegate.inRange(key)) {\n+                return false;\n+            }\n+\n+            final TrieEntry<K, V> node = getEntry(key);\n+            if (node != null && compare(node.getValue(), entry.getValue())) {\n+                removeEntry(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        /**\n+         * An {@link Iterator} for {@link RangeEntrySet}s.\n+         */\n+        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+\n+            private final K excludedKey;\n+\n+            /**\n+             * Creates a {@link EntryIterator}.\n+             */\n+            private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n+                super(first);\n+                this.excludedKey = last != null ? last.getKey() : null;\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return next != null && !compare(next.key, excludedKey);\n+            }\n+\n+            public Map.Entry<K,V> next() {\n+                if (next == null || compare(next.key, excludedKey)) {\n+                    throw new NoSuchElementException();\n+                }\n+                return nextEntry();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A submap used for prefix views over the {@link Trie}.\n+     */\n+    private class PrefixRangeMap extends RangeMap {\n+\n+        private final K prefix;\n+\n+        private final int offsetInBits;\n+\n+        private final int lengthInBits;\n+\n+        private K fromKey = null;\n+\n+        private K toKey = null;\n+\n+        private transient int expectedModCount = 0;\n+\n+        private int size = -1;\n+\n+        /**\n+         * Creates a {@link PrefixRangeMap}.\n+         */\n+        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n+            this.prefix = prefix;\n+            this.offsetInBits = offsetInBits;\n+            this.lengthInBits = lengthInBits;\n+        }\n+\n+        /**\n+         * This method does two things. It determines the FROM\n+         * and TO range of the {@link PrefixRangeMap} and the number\n+         * of elements in the range. This method must be called every\n+         * time the {@link Trie} has changed.\n+         */\n+        private int fixup() {\n+            // The trie has changed since we last found our toKey / fromKey\n+            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n+                final Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n+                size = 0;\n+\n+                Map.Entry<K, V> entry = null;\n+                if (it.hasNext()) {\n+                    entry = it.next();\n+                    size = 1;\n+                }\n+\n+                fromKey = entry == null ? null : entry.getKey();\n+                if (fromKey != null) {\n+                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n+                    fromKey = prior == null ? null : prior.getKey();\n+                }\n+\n+                toKey = fromKey;\n+\n+                while (it.hasNext()) {\n+                    ++size;\n+                    entry = it.next();\n+                }\n+\n+                toKey = entry == null ? null : entry.getKey();\n+\n+                if (toKey != null) {\n+                    entry = nextEntry((TrieEntry<K, V>)entry);\n+                    toKey = entry == null ? null : entry.getKey();\n+                }\n+\n+                expectedModCount = AbstractPatriciaTrie.this.modCount;\n+            }\n+\n+            return size;\n+        }\n+\n+        public K firstKey() {\n+            fixup();\n+\n+            Map.Entry<K,V> e = null;\n+            if (fromKey == null) {\n+                e = firstEntry();\n+            } else {\n+                e = higherEntry(fromKey);\n+            }\n+\n+            final K first = e != null ? e.getKey() : null;\n+            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            return first;\n+        }\n+\n+        public K lastKey() {\n+            fixup();\n+\n+            Map.Entry<K,V> e = null;\n+            if (toKey == null) {\n+                e = lastEntry();\n+            } else {\n+                e = lowerEntry(toKey);\n+            }\n+\n+            final K last = e != null ? e.getKey() : null;\n+            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            return last;\n+        }\n+\n+        /**\n+         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n+         */\n+        @Override\n+        protected boolean inRange(final K key) {\n+            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+\n+        /**\n+         * Same as {@link #inRange(Object)}.\n+         */\n+        @Override\n+        protected boolean inRange2(final K key) {\n+            return inRange(key);\n+        }\n+\n+        /**\n+         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n+         */\n+        @Override\n+        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n+            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+\n+        /**\n+         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n+         */\n+        @Override\n+        protected boolean inToRange(final K key, final boolean forceInclusive) {\n+            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+\n+        @Override\n+        protected Set<Map.Entry<K, V>> createEntrySet() {\n+            return new PrefixRangeEntrySet(this);\n+        }\n+\n+        @Override\n+        public K getFromKey() {\n+            return fromKey;\n+        }\n+\n+        @Override\n+        public K getToKey() {\n+            return toKey;\n+        }\n+\n+        @Override\n+        public boolean isFromInclusive() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isToInclusive() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n+                                                 final K toKey, final boolean toInclusive) {\n+            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n+        }\n+    }\n+\n+    /**\n+     * A prefix {@link RangeEntrySet} view of the {@link Trie}.\n+     */\n+    private final class PrefixRangeEntrySet extends RangeEntrySet {\n+\n+        private final PrefixRangeMap delegate;\n+\n+        private TrieEntry<K, V> prefixStart;\n+\n+        private int expectedModCount = 0;\n+\n+        /**\n+         * Creates a {@link PrefixRangeEntrySet}.\n+         */\n+        public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n+            super(delegate);\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return delegate.fixup();\n+        }\n+\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n+                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n+                expectedModCount = AbstractPatriciaTrie.this.modCount;\n+            }\n+\n+            if (prefixStart == null) {\n+                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n+                return empty.iterator();\n+            } else if (delegate.lengthInBits >= prefixStart.bitIndex) {\n+                return new SingletonIterator(prefixStart);\n+            } else {\n+                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n+            }\n+        }\n+\n+        /**\n+         * An {@link Iterator} that holds a single {@link TrieEntry}.\n+         */\n+        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n+\n+            private final TrieEntry<K, V> entry;\n+\n+            private int hit = 0;\n+\n+            public SingletonIterator(final TrieEntry<K, V> entry) {\n+                this.entry = entry;\n+            }\n+\n+            public boolean hasNext() {\n+                return hit == 0;\n+            }\n+\n+            public Map.Entry<K, V> next() {\n+                if (hit != 0) {\n+                    throw new NoSuchElementException();\n+                }\n+\n+                ++hit;\n+                return entry;\n+            }\n+\n+            public void remove() {\n+                if (hit != 1) {\n+                    throw new IllegalStateException();\n+                }\n+\n+                ++hit;\n+                AbstractPatriciaTrie.this.removeEntry(entry);\n+            }\n+        }\n+\n+        /**\n+         * An {@link Iterator} for iterating over a prefix search.\n+         */\n+        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n+\n+            // values to reset the subtree if we remove it.\n+            private final K prefix;\n+            private final int offset;\n+            private final int lengthInBits;\n+            private boolean lastOne;\n+\n+            private TrieEntry<K, V> subtree; // the subtree to search within\n+\n+            /**\n+             * Starts iteration at the given entry & search only\n+             * within the given subtree.\n+             */\n+            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n+                    final int offset, final int lengthInBits) {\n+                subtree = startScan;\n+                next = AbstractPatriciaTrie.this.followLeft(startScan);\n+                this.prefix = prefix;\n+                this.offset = offset;\n+                this.lengthInBits = lengthInBits;\n+            }\n+\n+            public Map.Entry<K,V> next() {\n+                final Map.Entry<K, V> entry = nextEntry();\n+                if (lastOne) {\n+                    next = null;\n+                }\n+                return entry;\n+            }\n+\n+            @Override\n+            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n+                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n+            }\n+\n+            @Override\n+            public void remove() {\n+                // If the current entry we're removing is the subtree\n+                // then we need to find a new subtree parent.\n+                boolean needsFixing = false;\n+                final int bitIdx = subtree.bitIndex;\n+                if (current == subtree) {\n+                    needsFixing = true;\n+                }\n+\n+                super.remove();\n+\n+                // If the subtree changed its bitIndex or we\n+                // removed the old subtree, get a new one.\n+                if (bitIdx != subtree.bitIndex || needsFixing) {\n+                    subtree = subtree(prefix, offset, lengthInBits);\n+                }\n+\n+                // If the subtree's bitIndex is less than the\n+                // length of our prefix, it's the last item\n+                // in the prefix tree.\n+                if (lengthInBits >= subtree.bitIndex) {\n+                    lastOne = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Reads the content of the stream.\n+     */\n+    @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n+    private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException{\n+        stream.defaultReadObject();\n+        root = new TrieEntry<K, V>(null, null, -1);\n+        int size = stream.readInt();\n+        for(int i = 0; i < size; i++){\n+            K k = (K) stream.readObject();\n+            V v = (V) stream.readObject();\n+            put(k, v);\n+        }\n+    }\n+\n+    /**\n+     * Writes the content to the stream for serialization.\n+     */\n+    private void writeObject(final ObjectOutputStream stream) throws IOException{\n+        stream.defaultWriteObject();\n+        stream.writeInt(this.size());\n+        for (final Entry<K, V> entry : entrySet()) {\n+            stream.writeObject(entry.getKey());\n+            stream.writeObject(entry.getValue());\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/PatriciaTrie.java\n  */\n package org.apache.commons.collections4.trie;\n \n-import java.util.AbstractMap;\n-import java.util.AbstractSet;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.Iterator;\n import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Set;\n-import java.util.SortedMap;\n \n import org.apache.commons.collections4.Trie;\n+import org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer;\n \n /**\n  * Implementation of a PATRICIA Trie (Practical Algorithm to Retrieve Information\n  * the given key, instead of comparing the entire key to another key.\n  * <p>\n  * The {@link Trie} can return operations in lexicographical order using the\n- * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The\n- * {@link Trie} can also scan for items that are 'bitwise' (using an XOR\n- * metric) by the 'select' method. Bitwise closeness is determined by the\n- * {@link KeyAnalyzer} returning true or false for a bit being set or not in\n- * a given key.\n+ * 'prefixMap', 'submap', or 'iterator' methods. The {@link Trie} can also\n+ * scan for items that are 'bitwise' (using an XOR metric) by the 'select' method.\n+ * Bitwise closeness is determined by the {@link KeyAnalyzer} returning true or\n+ * false for a bit being set or not in a given key.\n  * <p>\n  * This PATRICIA {@link Trie} supports both variable length & fixed length\n- * keys. Some methods, such as {@link #getPrefixedBy(Object)} are suited only\n- * to variable length keys, whereas {@link #getPrefixedByBits(Object, int)} is\n- * suited to fixed-size keys.\n- * <p>\n- * Any methods here that take an {@link Object} argument may throw a\n- * {@link ClassCastException} if the method is expecting an instance of K\n- * and it isn't K.\n+ * keys. Some methods, such as {@link #prefixMap(Object)} are suited only\n+ * to variable length keys.\n  *\n  * @see <a href=\"http://en.wikipedia.org/wiki/Radix_tree\">Radix Tree</a>\n  * @see <a href=\"http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA\">PATRICIA</a>\n  * @since 4.0\n  * @version $Id$\n  */\n-public class PatriciaTrie<K, V> extends PatriciaTrieBase<K, V> implements Trie<K, V> {\n+public class PatriciaTrie<E> extends AbstractPatriciaTrie<String, E> implements Trie<String, E> {\n \n     private static final long serialVersionUID = 4446367780901817838L;\n \n-    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n-        super(keyAnalyzer);\n+    public PatriciaTrie() {\n+        super(new StringKeyAnalyzer());\n     }\n \n-    public PatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> m) {\n-        super(keyAnalyzer, m);\n+    public PatriciaTrie(final Map<? extends String, ? extends E> m) {\n+        super(new StringKeyAnalyzer(), m);\n     }\n \n-    public Comparator<? super K> comparator() {\n-        return keyAnalyzer;\n-    }\n-\n-    public SortedMap<K, V> getPrefixedBy(final K key) {\n-        return getPrefixedByBits(key, 0, lengthInBits(key));\n-    }\n-\n-    public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n-        return getPrefixedByBits(key, 0, length * bitsPerElement());\n-    }\n-\n-    public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n-        final int bitsPerElement = bitsPerElement();\n-        return getPrefixedByBits(key, offset*bitsPerElement, length*bitsPerElement);\n-    }\n-\n-    public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n-        return getPrefixedByBits(key, 0, lengthInBits);\n-    }\n-\n-    public K firstKey() {\n-        return firstEntry().getKey();\n-    }\n-\n-    public K lastKey() {\n-        final TrieEntry<K, V> entry = lastEntry();\n-        if (entry != null) {\n-            return entry.getKey();\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     *\n-     * The view that this returns is optimized to have a very efficient\n-     * {@link Iterator}. The {@link SortedMap#firstKey()},\n-     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n-     * iterate over all possible values in order to determine the results.\n-     * This information is cached until the PATRICIA {@link Trie} changes.\n-     * All other methods (except {@link Iterator}) must compare the given\n-     * key to the prefix to ensure that it is within the range of the view.\n-     * The {@link Iterator}'s remove method must also relocate the subtree\n-     * that contains the prefixes if the entry holding the subtree is\n-     * removed or changes. Changing the subtree takes O(K) time.\n-     */\n-    public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n-\n-        final int offsetLength = offsetInBits + lengthInBits;\n-        if (offsetLength > lengthInBits(key)) {\n-            throw new IllegalArgumentException(offsetInBits + \" + \"\n-                    + lengthInBits + \" > \" + lengthInBits(key));\n-        }\n-\n-        if (offsetLength == 0) {\n-            return this;\n-        }\n-\n-        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n-    }\n-\n-    public SortedMap<K, V> headMap(final K toKey) {\n-        return new RangeEntryMap(null, toKey);\n-    }\n-\n-    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n-        return new RangeEntryMap(fromKey, toKey);\n-    }\n-\n-    public SortedMap<K, V> tailMap(final K fromKey) {\n-        return new RangeEntryMap(fromKey, null);\n-    }\n-\n-    /**\n-     * Returns an entry strictly higher than the given key,\n-     * or null if no such entry exists.\n-     */\n-    TrieEntry<K,V> higherEntry(final K key) {\n-        // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined\n-        //       functions to perform the search.)\n-        final int lengthInBits = lengthInBits(key);\n-\n-        if (lengthInBits == 0) {\n-            if (!root.isEmpty()) {\n-                // If data in root, and more after -- return it.\n-                if (size() > 1) {\n-                    return nextEntry(root);\n-                } else { // If no more after, no higher entry.\n-                    return null;\n-                }\n-            } else {\n-                // Root is empty & we want something after empty, return first.\n-                return firstEntry();\n-            }\n-        }\n-\n-        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n-        if (compareKeys(key, found.key)) {\n-            return nextEntry(found);\n-        }\n-\n-        final int bitIndex = bitIndex(key, found.key);\n-        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n-            addEntry(added, lengthInBits);\n-            incrementSize(); // must increment because remove will decrement\n-            final TrieEntry<K, V> ceil = nextEntry(added);\n-            removeEntry(added);\n-            modCount -= 2; // we didn't really modify it.\n-            return ceil;\n-        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n-            if (!root.isEmpty()) {\n-                return firstEntry();\n-            } else if (size() > 1) {\n-                return nextEntry(firstEntry());\n-            } else {\n-                return null;\n-            }\n-        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n-            return nextEntry(found);\n-        }\n-\n-        // we should have exited above.\n-        throw new IllegalStateException(\"invalid lookup: \" + key);\n-    }\n-\n-    /**\n-     * Returns a key-value mapping associated with the least key greater\n-     * than or equal to the given key, or null if there is no such key.\n-     */\n-    TrieEntry<K,V> ceilingEntry(final K key) {\n-        // Basically:\n-        // Follow the steps of adding an entry, but instead...\n-        //\n-        // - If we ever encounter a situation where we found an equal\n-        //   key, we return it immediately.\n-        //\n-        // - If we hit an empty root, return the first iterable item.\n-        //\n-        // - If we have to add a new item, we temporarily add it,\n-        //   find the successor to it, then remove the added item.\n-        //\n-        // These steps ensure that the returned value is either the\n-        // entry for the key itself, or the first entry directly after\n-        // the key.\n-\n-        // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined\n-        //       functions to perform the search.)\n-        final int lengthInBits = lengthInBits(key);\n-\n-        if (lengthInBits == 0) {\n-            if (!root.isEmpty()) {\n-                return root;\n-            } else {\n-                return firstEntry();\n-            }\n-        }\n-\n-        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n-        if (compareKeys(key, found.key)) {\n-            return found;\n-        }\n-\n-        final int bitIndex = bitIndex(key, found.key);\n-        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n-            addEntry(added, lengthInBits);\n-            incrementSize(); // must increment because remove will decrement\n-            final TrieEntry<K, V> ceil = nextEntry(added);\n-            removeEntry(added);\n-            modCount -= 2; // we didn't really modify it.\n-            return ceil;\n-        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n-            if (!root.isEmpty()) {\n-                return root;\n-            } else {\n-                return firstEntry();\n-            }\n-        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n-            return found;\n-        }\n-\n-        // we should have exited above.\n-        throw new IllegalStateException(\"invalid lookup: \" + key);\n-    }\n-\n-    /**\n-     * Returns a key-value mapping associated with the greatest key\n-     * strictly less than the given key, or null if there is no such key.\n-     */\n-    TrieEntry<K,V> lowerEntry(final K key) {\n-        // Basically:\n-        // Follow the steps of adding an entry, but instead...\n-        //\n-        // - If we ever encounter a situation where we found an equal\n-        //   key, we return it's previousEntry immediately.\n-        //\n-        // - If we hit root (empty or not), return null.\n-        //\n-        // - If we have to add a new item, we temporarily add it,\n-        //   find the previousEntry to it, then remove the added item.\n-        //\n-        // These steps ensure that the returned value is always just before\n-        // the key or null (if there was nothing before it).\n-\n-        // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined\n-        //       functions to perform the search.)\n-        final int lengthInBits = lengthInBits(key);\n-\n-        if (lengthInBits == 0) {\n-            return null; // there can never be anything before root.\n-        }\n-\n-        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n-        if (compareKeys(key, found.key)) {\n-            return previousEntry(found);\n-        }\n-\n-        final int bitIndex = bitIndex(key, found.key);\n-        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n-            addEntry(added, lengthInBits);\n-            incrementSize(); // must increment because remove will decrement\n-            final TrieEntry<K, V> prior = previousEntry(added);\n-            removeEntry(added);\n-            modCount -= 2; // we didn't really modify it.\n-            return prior;\n-        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n-            return null;\n-        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n-            return previousEntry(found);\n-        }\n-\n-        // we should have exited above.\n-        throw new IllegalStateException(\"invalid lookup: \" + key);\n-    }\n-\n-    /**\n-     * Returns a key-value mapping associated with the greatest key\n-     * less than or equal to the given key, or null if there is no such key.\n-     */\n-    TrieEntry<K,V> floorEntry(final K key) {\n-        // TODO: Cleanup so that we don't actually have to add/remove from the\n-        //       tree.  (We do it here because there are other well-defined\n-        //       functions to perform the search.)\n-        final int lengthInBits = lengthInBits(key);\n-\n-        if (lengthInBits == 0) {\n-            if (!root.isEmpty()) {\n-                return root;\n-            } else {\n-                return null;\n-            }\n-        }\n-\n-        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n-        if (compareKeys(key, found.key)) {\n-            return found;\n-        }\n-\n-        final int bitIndex = bitIndex(key, found.key);\n-        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n-            final TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n-            addEntry(added, lengthInBits);\n-            incrementSize(); // must increment because remove will decrement\n-            final TrieEntry<K, V> floor = previousEntry(added);\n-            removeEntry(added);\n-            modCount -= 2; // we didn't really modify it.\n-            return floor;\n-        } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n-            if (!root.isEmpty()) {\n-                return root;\n-            } else {\n-                return null;\n-            }\n-        } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n-            return found;\n-        }\n-\n-        // we should have exited above.\n-        throw new IllegalStateException(\"invalid lookup: \" + key);\n-    }\n-\n-    /**\n-     * Finds the subtree that contains the prefix.\n-     *\n-     * This is very similar to getR but with the difference that\n-     * we stop the lookup if h.bitIndex > lengthInBits.\n-     */\n-    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n-        TrieEntry<K, V> current = root.left;\n-        TrieEntry<K, V> path = root;\n-        while(true) {\n-            if (current.bitIndex <= path.bitIndex || lengthInBits < current.bitIndex) {\n-                break;\n-            }\n-\n-            path = current;\n-            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n-                current = current.left;\n-            } else {\n-                current = current.right;\n-            }\n-        }\n-\n-        // Make sure the entry is valid for a subtree.\n-        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n-\n-        // If entry is root, it can't be empty.\n-        if (entry.isEmpty()) {\n-            return null;\n-        }\n-\n-        final int endIndexInBits = offsetInBits + lengthInBits;\n-\n-        // if root && length of root is less than length of lookup,\n-        // there's nothing.\n-        // (this prevents returning the whole subtree if root has an empty\n-        //  string and we want to lookup things with \"\\0\")\n-        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n-            return null;\n-        }\n-\n-        // Found key's length-th bit differs from our key\n-        // which means it cannot be the prefix...\n-        if (isBitSet(prefix, endIndexInBits, endIndexInBits)\n-                != isBitSet(entry.key, lengthInBits, lengthInBits(entry.key))) {\n-            return null;\n-        }\n-\n-        // ... or there are less than 'length' equal bits\n-        final int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits,\n-                lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));\n-\n-        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n-            return null;\n-        }\n-\n-        return entry;\n-    }\n-\n-    /**\n-     * Returns the last entry the {@link Trie} is storing.\n-     *\n-     * <p>This is implemented by going always to the right until\n-     * we encounter a valid uplink. That uplink is the last key.\n-     */\n-    TrieEntry<K, V> lastEntry() {\n-        return followRight(root.left);\n-    }\n-\n-    /**\n-     * Traverses down the right path until it finds an uplink.\n-     */\n-    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n-        // if Trie is empty, no last entry.\n-        if (node.right == null) {\n-            return null;\n-        }\n-\n-        // Go as far right as possible, until we encounter an uplink.\n-        while (node.right.bitIndex > node.bitIndex) {\n-            node = node.right;\n-        }\n-\n-        return node.right;\n-    }\n-\n-    /**\n-     * Returns the node lexicographically before the given node (or null if none).\n-     *\n-     * This follows four simple branches:\n-     *  - If the uplink that returned us was a right uplink:\n-     *      - If predecessor's left is a valid uplink from predecessor, return it.\n-     *      - Else, follow the right path from the predecessor's left.\n-     *  - If the uplink that returned us was a left uplink:\n-     *      - Loop back through parents until we encounter a node where\n-     *        node != node.parent.left.\n-     *          - If node.parent.left is uplink from node.parent:\n-     *              - If node.parent.left is not root, return it.\n-     *              - If it is root & root isEmpty, return null.\n-     *              - If it is root & root !isEmpty, return root.\n-     *          - If node.parent.left is not uplink from node.parent:\n-     *              - Follow right path for first right child from node.parent.left\n-     *\n-     * @param start  the start entry\n-     */\n-    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n-        if (start.predecessor == null) {\n-            throw new IllegalArgumentException(\"must have come from somewhere!\");\n-        }\n-\n-        if (start.predecessor.right == start) {\n-            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n-                return start.predecessor.left;\n-            } else {\n-                return followRight(start.predecessor.left);\n-            }\n-        } else {\n-            TrieEntry<K, V> node = start.predecessor;\n-            while (node.parent != null && node == node.parent.left) {\n-                node = node.parent;\n-            }\n-\n-            if (node.parent == null) { // can be null if we're looking up root.\n-                return null;\n-            }\n-\n-            if (isValidUplink(node.parent.left, node.parent)) {\n-                if (node.parent.left == root) {\n-                    if (root.isEmpty()) {\n-                        return null;\n-                    } else {\n-                        return root;\n-                    }\n-\n-                } else {\n-                    return node.parent.left;\n-                }\n-            } else {\n-                return followRight(node.parent.left);\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns the entry lexicographically after the given entry.\n-     * If the given entry is null, returns the first node.\n-     *\n-     * This will traverse only within the subtree.  If the given node\n-     * is not within the subtree, this will have undefined results.\n-     */\n-    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n-            final TrieEntry<K, V> parentOfSubtree) {\n-        if (node == null) {\n-            return firstEntry();\n-        } else {\n-            return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n-        }\n-    }\n-\n-    /**\n-     * A range view of the {@link Trie}.\n-     */\n-    private abstract class RangeMap extends AbstractMap<K, V>\n-            implements SortedMap<K, V> {\n-\n-        /** The {@link #entrySet()} view. */\n-        private transient volatile Set<Map.Entry<K, V>> entrySet;\n-\n-        /**\n-         * Creates and returns an {@link #entrySet()} view of the {@link RangeMap}.\n-         */\n-        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n-\n-        /**\n-         * Returns the FROM Key.\n-         */\n-        protected abstract K getFromKey();\n-\n-        /**\n-         * Whether or not the {@link #getFromKey()} is in the range.\n-         */\n-        protected abstract boolean isFromInclusive();\n-\n-        /**\n-         * Returns the TO Key.\n-         */\n-        protected abstract K getToKey();\n-\n-        /**\n-         * Whether or not the {@link #getToKey()} is in the range.\n-         */\n-        protected abstract boolean isToInclusive();\n-\n-        public Comparator<? super K> comparator() {\n-            return PatriciaTrie.this.comparator();\n-        }\n-\n-        @Override\n-        public boolean containsKey(final Object key) {\n-            if (!inRange(castKey(key))) {\n-                return false;\n-            }\n-\n-            return PatriciaTrie.this.containsKey(key);\n-        }\n-\n-        @Override\n-        public V remove(final Object key) {\n-            if (!inRange(castKey(key))) {\n-                return null;\n-            }\n-\n-            return PatriciaTrie.this.remove(key);\n-        }\n-\n-        @Override\n-        public V get(final Object key) {\n-            if (!inRange(castKey(key))) {\n-                return null;\n-            }\n-\n-            return PatriciaTrie.this.get(key);\n-        }\n-\n-        @Override\n-        public V put(final K key, final V value) {\n-            if (!inRange(key)) {\n-                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n-            }\n-            return PatriciaTrie.this.put(key, value);\n-        }\n-\n-        @Override\n-        public Set<Map.Entry<K, V>> entrySet() {\n-            if (entrySet == null) {\n-                entrySet = createEntrySet();\n-            }\n-            return entrySet;\n-        }\n-\n-        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n-            if (!inRange2(fromKey)) {\n-                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n-            }\n-\n-            if (!inRange2(toKey)) {\n-                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n-            }\n-\n-            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n-        }\n-\n-        public SortedMap<K, V> headMap(final K toKey) {\n-            if (!inRange2(toKey)) {\n-                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n-            }\n-            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n-        }\n-\n-        public SortedMap<K, V> tailMap(final K fromKey) {\n-            if (!inRange2(fromKey)) {\n-                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n-            }\n-            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n-        }\n-\n-        /**\n-         * Returns true if the provided key is greater than TO and less than FROM.\n-         */\n-        protected boolean inRange(final K key) {\n-            final K fromKey = getFromKey();\n-            final K toKey = getToKey();\n-\n-            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n-        }\n-\n-        /**\n-         * This form allows the high endpoint (as well as all legit keys).\n-         */\n-        protected boolean inRange2(final K key) {\n-            final K fromKey = getFromKey();\n-            final K toKey = getToKey();\n-\n-            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n-        }\n-\n-        /**\n-         * Returns true if the provided key is in the FROM range of the {@link RangeMap}.\n-         */\n-        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n-            final K fromKey = getFromKey();\n-            final boolean fromInclusive = isFromInclusive();\n-\n-            final int ret = keyAnalyzer.compare(key, fromKey);\n-            if (fromInclusive || forceInclusive) {\n-                return ret >= 0;\n-            } else {\n-                return ret > 0;\n-            }\n-        }\n-\n-        /**\n-         * Returns true if the provided key is in the TO range of the {@link RangeMap}.\n-         */\n-        protected boolean inToRange(final K key, final boolean forceInclusive) {\n-            final K toKey = getToKey();\n-            final boolean toInclusive = isToInclusive();\n-\n-            final int ret = keyAnalyzer.compare(key, toKey);\n-            if (toInclusive || forceInclusive) {\n-                return ret <= 0;\n-            } else {\n-                return ret < 0;\n-            }\n-        }\n-\n-        /**\n-         * Creates and returns a sub-range view of the current {@link RangeMap}.\n-         */\n-        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n-                                                          K toKey, boolean toInclusive);\n-    }\n-\n-   /**\n-    * A {@link RangeMap} that deals with {@link Entry}s.\n-    */\n-   private class RangeEntryMap extends RangeMap {\n-\n-       /** The key to start from, null if the beginning. */\n-       private final K fromKey;\n-\n-       /** The key to end at, null if till the end. */\n-       private final K toKey;\n-\n-       /** Whether or not the 'from' is inclusive. */\n-       private final boolean fromInclusive;\n-\n-       /** Whether or not the 'to' is inclusive. */\n-       private final boolean toInclusive;\n-\n-       /**\n-        * Creates a {@link RangeEntryMap} with the fromKey included and\n-        * the toKey excluded from the range.\n-        */\n-       protected RangeEntryMap(final K fromKey, final K toKey) {\n-           this(fromKey, true, toKey, false);\n-       }\n-\n-       /**\n-        * Creates a {@link RangeEntryMap}.\n-        */\n-       protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n-                               final K toKey, final boolean toInclusive) {\n-\n-           if (fromKey == null && toKey == null) {\n-               throw new IllegalArgumentException(\"must have a from or to!\");\n-           }\n-\n-           if (fromKey != null && toKey != null\n-                   && keyAnalyzer.compare(fromKey, toKey) > 0) {\n-               throw new IllegalArgumentException(\"fromKey > toKey\");\n-           }\n-\n-           this.fromKey = fromKey;\n-           this.fromInclusive = fromInclusive;\n-           this.toKey = toKey;\n-           this.toInclusive = toInclusive;\n-       }\n-\n-       public K firstKey() {\n-           Map.Entry<K,V> e = null;\n-           if (fromKey == null) {\n-               e = firstEntry();\n-           } else {\n-               if (fromInclusive) {\n-                   e = ceilingEntry(fromKey);\n-               } else {\n-                   e = higherEntry(fromKey);\n-               }\n-           }\n-\n-           final K first = e != null ? e.getKey() : null;\n-           if (e == null || toKey != null && !inToRange(first, false)) {\n-               throw new NoSuchElementException();\n-           }\n-           return first;\n-       }\n-\n-       public K lastKey() {\n-           Map.Entry<K,V> e;\n-           if (toKey == null) {\n-               e = lastEntry();\n-           } else {\n-               if (toInclusive) {\n-                   e = floorEntry(toKey);\n-               } else {\n-                   e = lowerEntry(toKey);\n-               }\n-           }\n-\n-           final K last = e != null ? e.getKey() : null;\n-           if (e == null || fromKey != null && !inFromRange(last, false)) {\n-               throw new NoSuchElementException();\n-           }\n-           return last;\n-       }\n-\n-       @Override\n-       protected Set<Entry<K, V>> createEntrySet() {\n-           return new RangeEntrySet(this);\n-       }\n-\n-       @Override\n-       public K getFromKey() {\n-           return fromKey;\n-       }\n-\n-       @Override\n-       public K getToKey() {\n-           return toKey;\n-       }\n-\n-       @Override\n-       public boolean isFromInclusive() {\n-           return fromInclusive;\n-       }\n-\n-       @Override\n-       public boolean isToInclusive() {\n-           return toInclusive;\n-       }\n-\n-       @Override\n-       protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n-               final K toKey, final boolean toInclusive) {\n-           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n-       }\n-   }\n-\n-    /**\n-     * A {@link Set} view of a {@link RangeMap}.\n-     */\n-    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n-\n-        private final RangeMap delegate;\n-\n-        private transient int size = -1;\n-\n-        private transient int expectedModCount;\n-\n-        /**\n-         * Creates a {@link RangeEntrySet}.\n-         */\n-        public RangeEntrySet(final RangeMap delegate) {\n-            if (delegate == null) {\n-                throw new NullPointerException(\"delegate\");\n-            }\n-\n-            this.delegate = delegate;\n-        }\n-\n-        @Override\n-        public Iterator<Map.Entry<K, V>> iterator() {\n-            final K fromKey = delegate.getFromKey();\n-            final K toKey = delegate.getToKey();\n-\n-            TrieEntry<K, V> first = null;\n-            if (fromKey == null) {\n-                first = firstEntry();\n-            } else {\n-                first = ceilingEntry(fromKey);\n-            }\n-\n-            TrieEntry<K, V> last = null;\n-            if (toKey != null) {\n-                last = ceilingEntry(toKey);\n-            }\n-\n-            return new EntryIterator(first, last);\n-        }\n-\n-        @Override\n-        public int size() {\n-            if (size == -1 || expectedModCount != PatriciaTrie.this.modCount) {\n-                size = 0;\n-\n-                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n-                    ++size;\n-                }\n-\n-                expectedModCount = PatriciaTrie.this.modCount;\n-            }\n-            return size;\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            return !iterator().hasNext();\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        @Override\n-        public boolean contains(final Object o) {\n-            if (!(o instanceof Map.Entry)) {\n-                return false;\n-            }\n-\n-            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n-            final K key = entry.getKey();\n-            if (!delegate.inRange(key)) {\n-                return false;\n-            }\n-\n-            final TrieEntry<K, V> node = getEntry(key);\n-            return node != null && compare(node.getValue(), entry.getValue());\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        @Override\n-        public boolean remove(final Object o) {\n-            if (!(o instanceof Map.Entry)) {\n-                return false;\n-            }\n-\n-            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n-            final K key = entry.getKey();\n-            if (!delegate.inRange(key)) {\n-                return false;\n-            }\n-\n-            final TrieEntry<K, V> node = getEntry(key);\n-            if (node != null && compare(node.getValue(), entry.getValue())) {\n-                removeEntry(node);\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        /**\n-         * An {@link Iterator} for {@link RangeEntrySet}s.\n-         */\n-        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n-\n-            private final K excludedKey;\n-\n-            /**\n-             * Creates a {@link EntryIterator}.\n-             */\n-            private EntryIterator(final TrieEntry<K,V> first, final TrieEntry<K,V> last) {\n-                super(first);\n-                this.excludedKey = last != null ? last.getKey() : null;\n-            }\n-\n-            @Override\n-            public boolean hasNext() {\n-                return next != null && !compare(next.key, excludedKey);\n-            }\n-\n-            public Map.Entry<K,V> next() {\n-                if (next == null || compare(next.key, excludedKey)) {\n-                    throw new NoSuchElementException();\n-                }\n-                return nextEntry();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * A submap used for prefix views over the {@link Trie}.\n-     */\n-    private class PrefixRangeMap extends RangeMap {\n-\n-        private final K prefix;\n-\n-        private final int offsetInBits;\n-\n-        private final int lengthInBits;\n-\n-        private K fromKey = null;\n-\n-        private K toKey = null;\n-\n-        private transient int expectedModCount = 0;\n-\n-        private int size = -1;\n-\n-        /**\n-         * Creates a {@link PrefixRangeMap}.\n-         */\n-        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n-            this.prefix = prefix;\n-            this.offsetInBits = offsetInBits;\n-            this.lengthInBits = lengthInBits;\n-        }\n-\n-        /**\n-         * This method does two things. It determinates the FROM\n-         * and TO range of the {@link PrefixRangeMap} and the number\n-         * of elements in the range. This method must be called every\n-         * time the {@link Trie} has changed.\n-         */\n-        private int fixup() {\n-            // The trie has changed since we last\n-            // found our toKey / fromKey\n-            if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount) {\n-                final Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n-                size = 0;\n-\n-                Map.Entry<K, V> entry = null;\n-                if (it.hasNext()) {\n-                    entry = it.next();\n-                    size = 1;\n-                }\n-\n-                fromKey = entry == null ? null : entry.getKey();\n-                if (fromKey != null) {\n-                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n-                    fromKey = prior == null ? null : prior.getKey();\n-                }\n-\n-                toKey = fromKey;\n-\n-                while (it.hasNext()) {\n-                    ++size;\n-                    entry = it.next();\n-                }\n-\n-                toKey = entry == null ? null : entry.getKey();\n-\n-                if (toKey != null) {\n-                    entry = nextEntry((TrieEntry<K, V>)entry);\n-                    toKey = entry == null ? null : entry.getKey();\n-                }\n-\n-                expectedModCount = PatriciaTrie.this.modCount;\n-            }\n-\n-            return size;\n-        }\n-\n-        public K firstKey() {\n-            fixup();\n-\n-            Map.Entry<K,V> e = null;\n-            if (fromKey == null) {\n-                e = firstEntry();\n-            } else {\n-                e = higherEntry(fromKey);\n-            }\n-\n-            final K first = e != null ? e.getKey() : null;\n-            if (e == null || !keyAnalyzer.isPrefix(prefix,\n-                    offsetInBits, lengthInBits, first)) {\n-                throw new NoSuchElementException();\n-            }\n-\n-            return first;\n-        }\n-\n-        public K lastKey() {\n-            fixup();\n-\n-            Map.Entry<K,V> e = null;\n-            if (toKey == null) {\n-                e = lastEntry();\n-            } else {\n-                e = lowerEntry(toKey);\n-            }\n-\n-            final K last = e != null ? e.getKey() : null;\n-            if (e == null || !keyAnalyzer.isPrefix(prefix,\n-                    offsetInBits, lengthInBits, last)) {\n-                throw new NoSuchElementException();\n-            }\n-\n-            return last;\n-        }\n-\n-        /**\n-         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n-         */\n-        @Override\n-        protected boolean inRange(final K key) {\n-            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n-        }\n-\n-        /**\n-         * Same as {@link #inRange(Object)}.\n-         */\n-        @Override\n-        protected boolean inRange2(final K key) {\n-            return inRange(key);\n-        }\n-\n-        /**\n-         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n-         */\n-        @Override\n-        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n-            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n-        }\n-\n-        /**\n-         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n-         */\n-        @Override\n-        protected boolean inToRange(final K key, final boolean forceInclusive) {\n-            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n-        }\n-\n-        @Override\n-        protected Set<Map.Entry<K, V>> createEntrySet() {\n-            return new PrefixRangeEntrySet(this);\n-        }\n-\n-        @Override\n-        public K getFromKey() {\n-            return fromKey;\n-        }\n-\n-        @Override\n-        public K getToKey() {\n-            return toKey;\n-        }\n-\n-        @Override\n-        public boolean isFromInclusive() {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isToInclusive() {\n-            return false;\n-        }\n-\n-        @Override\n-        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n-                                                 final K toKey, final boolean toInclusive) {\n-            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n-        }\n-    }\n-\n-    /**\n-     * A prefix {@link RangeEntrySet} view of the {@link Trie}.\n-     */\n-    private final class PrefixRangeEntrySet extends RangeEntrySet {\n-\n-        private final PrefixRangeMap delegate;\n-\n-        private TrieEntry<K, V> prefixStart;\n-\n-        private int expectedModCount = 0;\n-\n-        /**\n-         * Creates a {@link PrefixRangeEntrySet}.\n-         */\n-        public PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n-            super(delegate);\n-            this.delegate = delegate;\n-        }\n-\n-        @Override\n-        public int size() {\n-            return delegate.fixup();\n-        }\n-\n-        @Override\n-        public Iterator<Map.Entry<K,V>> iterator() {\n-            if (PatriciaTrie.this.modCount != expectedModCount) {\n-                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n-                expectedModCount = PatriciaTrie.this.modCount;\n-            }\n-\n-            if (prefixStart == null) {\n-                final Set<Map.Entry<K,V>> empty = Collections.emptySet();\n-                return empty.iterator();\n-            } else if (delegate.lengthInBits >= prefixStart.bitIndex) {\n-                return new SingletonIterator(prefixStart);\n-            } else {\n-                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n-            }\n-        }\n-\n-        /**\n-         * An {@link Iterator} that holds a single {@link TrieEntry}.\n-         */\n-        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n-\n-            private final TrieEntry<K, V> entry;\n-\n-            private int hit = 0;\n-\n-            public SingletonIterator(final TrieEntry<K, V> entry) {\n-                this.entry = entry;\n-            }\n-\n-            public boolean hasNext() {\n-                return hit == 0;\n-            }\n-\n-            public Map.Entry<K, V> next() {\n-                if (hit != 0) {\n-                    throw new NoSuchElementException();\n-                }\n-\n-                ++hit;\n-                return entry;\n-            }\n-\n-            public void remove() {\n-                if (hit != 1) {\n-                    throw new IllegalStateException();\n-                }\n-\n-                ++hit;\n-                PatriciaTrie.this.removeEntry(entry);\n-            }\n-        }\n-\n-        /**\n-         * An {@link Iterator} for iterating over a prefix search.\n-         */\n-        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n-\n-            // values to reset the subtree if we remove it.\n-            private final K prefix;\n-            private final int offset;\n-            private final int lengthInBits;\n-            private boolean lastOne;\n-\n-            private TrieEntry<K, V> subtree; // the subtree to search within\n-\n-            /**\n-             * Starts iteration at the given entry & search only\n-             * within the given subtree.\n-             */\n-            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n-                    final int offset, final int lengthInBits) {\n-                subtree = startScan;\n-                next = PatriciaTrie.this.followLeft(startScan);\n-                this.prefix = prefix;\n-                this.offset = offset;\n-                this.lengthInBits = lengthInBits;\n-            }\n-\n-            public Map.Entry<K,V> next() {\n-                final Map.Entry<K, V> entry = nextEntry();\n-                if (lastOne) {\n-                    next = null;\n-                }\n-                return entry;\n-            }\n-\n-            @Override\n-            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n-                return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n-            }\n-\n-            @Override\n-            public void remove() {\n-                // If the current entry we're removing is the subtree\n-                // then we need to find a new subtree parent.\n-                boolean needsFixing = false;\n-                final int bitIdx = subtree.bitIndex;\n-                if (current == subtree) {\n-                    needsFixing = true;\n-                }\n-\n-                super.remove();\n-\n-                // If the subtree changed its bitIndex or we\n-                // removed the old subtree, get a new one.\n-                if (bitIdx != subtree.bitIndex || needsFixing) {\n-                    subtree = subtree(prefix, offset, lengthInBits);\n-                }\n-\n-                // If the subtree's bitIndex is less than the\n-                // length of our prefix, it's the last item\n-                // in the prefix tree.\n-                if (lengthInBits >= subtree.bitIndex) {\n-                    lastOne = true;\n-                }\n-            }\n-        }\n-    }\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/SynchronizedTrie.java\n import java.util.Set;\n import java.util.SortedMap;\n \n+import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.Trie;\n import org.apache.commons.collections4.collection.SynchronizedCollection;\n \n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n         this.delegate = trie;\n-    }\n-\n-    public synchronized Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n-        return delegate.traverse(cursor);\n     }\n \n     public synchronized Set<Entry<K, V>> entrySet() {\n         return delegate.remove(key);\n     }\n \n+    public synchronized int size() {\n+        return delegate.size();\n+    }\n+\n     public synchronized K lastKey() {\n         return delegate.lastKey();\n     }\n         return Collections.synchronizedSortedMap(delegate.headMap(toKey));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n-        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, offset, length));\n+    public synchronized SortedMap<K, V> prefixMap(final K key) {\n+        return Collections.synchronizedSortedMap(delegate.prefixMap(key));\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n-        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, length));\n+    //-----------------------------------------------------------------------\n+    public synchronized OrderedMapIterator<K, V> mapIterator() {\n+        // TODO: make ordered map iterator synchronized too\n+        final OrderedMapIterator<K, V> it = delegate.mapIterator();\n+        return it;\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedBy(final K key) {\n-        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key));\n+    public synchronized K nextKey(K key) {\n+        return delegate.nextKey(key);\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n-        return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n+    public synchronized K previousKey(K key) {\n+        return delegate.previousKey(key);\n     }\n \n-    public synchronized SortedMap<K, V> getPrefixedByBits(final K key,\n-            final int offsetInBits, final int lengthInBits) {\n-        return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n-    }\n-\n-    public synchronized int size() {\n-        return delegate.size();\n-    }\n-\n+    //-----------------------------------------------------------------------\n     @Override\n     public synchronized int hashCode() {\n         return delegate.hashCode();\n     public synchronized String toString() {\n         return delegate.toString();\n     }\n+\n }\n--- a/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/UnmodifiableTrie.java\n import java.util.Set;\n import java.util.SortedMap;\n \n+import org.apache.commons.collections4.OrderedMapIterator;\n import org.apache.commons.collections4.Trie;\n import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.iterators.UnmodifiableOrderedMapIterator;\n \n /**\n  * An unmodifiable {@link Trie}.\n  */\n public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable, Unmodifiable {\n \n+    /** Serialization version */\n     private static final long serialVersionUID = -7156426030315945159L;\n \n     private final Trie<K, V> delegate;\n         this.delegate = trie;\n     }\n \n-    public Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n-        final Cursor<K, V> c = new Cursor<K, V>() {\n-            public Decision select(final Map.Entry<? extends K, ? extends V> entry) {\n-                final Decision decision = cursor.select(entry);\n-                switch (decision) {\n-                    case REMOVE:\n-                    case REMOVE_AND_EXIT:\n-                        throw new UnsupportedOperationException();\n-                    default:\n-                        // other decisions are fine\n-                        break;\n-                }\n-\n-                return decision;\n-            }\n-        };\n-\n-        return delegate.traverse(c);\n-    }\n+    //-----------------------------------------------------------------------\n \n     public Set<Entry<K, V>> entrySet() {\n         return Collections.unmodifiableSet(delegate.entrySet());\n         throw new UnsupportedOperationException();\n     }\n \n+    public int size() {\n+        return delegate.size();\n+    }\n+\n     public K firstKey() {\n         return delegate.firstKey();\n     }\n         return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n     }\n \n-    public SortedMap<K, V> getPrefixedBy(final K key, final int offset, final int length) {\n-        return Collections.unmodifiableSortedMap(delegate.getPrefixedBy(key, offset, length));\n-    }\n-\n-    public SortedMap<K, V> getPrefixedBy(final K key, final int length) {\n-        return Collections.unmodifiableSortedMap(delegate.getPrefixedBy(key, length));\n-    }\n-\n-    public SortedMap<K, V> getPrefixedBy(final K key) {\n-        return Collections.unmodifiableSortedMap(delegate.getPrefixedBy(key));\n-    }\n-\n-    public SortedMap<K, V> getPrefixedByBits(final K key, final int lengthInBits) {\n-        return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n-    }\n-\n-    public SortedMap<K, V> getPrefixedByBits(final K key, final int offsetInBits, final int lengthInBits) {\n-        return Collections.unmodifiableSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n+    public SortedMap<K, V> prefixMap(final K key) {\n+        return Collections.unmodifiableSortedMap(delegate.prefixMap(key));\n     }\n \n     public Comparator<? super K> comparator() {\n         return delegate.comparator();\n     }\n \n-    public int size() {\n-        return delegate.size();\n+    //-----------------------------------------------------------------------\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        final OrderedMapIterator<K, V> it = delegate.mapIterator();\n+        return UnmodifiableOrderedMapIterator.unmodifiableOrderedMapIterator(it);\n     }\n \n+    public K nextKey(K key) {\n+        return delegate.nextKey(key);\n+    }\n+\n+    public K previousKey(K key) {\n+        return delegate.previousKey(key);\n+    }\n+\n+    //-----------------------------------------------------------------------\n     @Override\n     public int hashCode() {\n         return delegate.hashCode();\n     public String toString() {\n         return delegate.toString();\n     }\n+\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/trie/PatriciaTrie2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.OrderedMap;\n+import org.apache.commons.collections4.map.AbstractOrderedMapTest;\n+\n+/**\n+ * JUnit test of the OrderedMap interface of a PatriciaTrie.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PatriciaTrie2Test<V> extends AbstractOrderedMapTest<String, V> {\n+\n+    public PatriciaTrie2Test(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(PatriciaTrie2Test.class);\n+    }\n+\n+    @Override\n+    public OrderedMap<String, V> makeObject() {\n+        return new PatriciaTrie<V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n+++ b/src/test/java/org/apache/commons/collections4/trie/PatriciaTrieTest.java\n  */\n package org.apache.commons.collections4.trie;\n \n-import java.io.BufferedReader;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n-import java.util.List;\n import java.util.Map;\n import java.util.NoSuchElementException;\n-import java.util.Random;\n import java.util.SortedMap;\n-import java.util.StringTokenizer;\n-import java.util.TreeMap;\n-import java.util.Map.Entry;\n-\n-import org.apache.commons.collections4.Trie.Cursor;\n-import org.apache.commons.collections4.trie.analyzer.CharacterKeyAnalyzer;\n-import org.apache.commons.collections4.trie.analyzer.IntegerKeyAnalyzer;\n-import org.apache.commons.collections4.trie.analyzer.StringKeyAnalyzer;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.map.AbstractSortedMapTest;\n+import org.apache.commons.collections4.trie.PatriciaTrie;\n \n import org.junit.Assert;\n-import org.junit.Test;\n \n /**\n- * JUnit tests.\n- *\n- * FIXME: add serialization support\n- * TODO: integrate into test framework, utilize existing map tests\n+ * JUnit tests for the PatriciaTrie.\n  *\n  * @since 4.0\n  * @version $Id$\n  */\n-public class PatriciaTrieTest {\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testSimple() {\n-        final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n-        Assert.assertTrue(intTrie.isEmpty());\n-        Assert.assertEquals(0, intTrie.size());\n-\n-        intTrie.put(1, \"One\");\n-        Assert.assertFalse(intTrie.isEmpty());\n-        Assert.assertEquals(1, intTrie.size());\n-\n-        Assert.assertEquals(\"One\", intTrie.remove(1));\n-        Assert.assertNull(intTrie.remove(1));\n-        Assert.assertTrue(intTrie.isEmpty());\n-        Assert.assertEquals(0, intTrie.size());\n-\n-        intTrie.put(1, \"One\");\n-        Assert.assertEquals(\"One\", intTrie.get(1));\n-        Assert.assertEquals(\"One\", intTrie.put(1, \"NotOne\"));\n-        Assert.assertEquals(1, intTrie.size());\n-        Assert.assertEquals(\"NotOne\", intTrie.get(1));\n-        Assert.assertEquals(\"NotOne\", intTrie.remove(1));\n-        Assert.assertNull(intTrie.put(1, \"One\"));\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testCeilingEntry() {\n-        final PatriciaTrie<Character, String> charTrie\n-            = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n-        charTrie.put('c', \"c\");\n-        charTrie.put('p', \"p\");\n-        charTrie.put('l', \"l\");\n-        charTrie.put('t', \"t\");\n-        charTrie.put('k', \"k\");\n-        charTrie.put('a', \"a\");\n-        charTrie.put('y', \"y\");\n-        charTrie.put('r', \"r\");\n-        charTrie.put('u', \"u\");\n-        charTrie.put('o', \"o\");\n-        charTrie.put('w', \"w\");\n-        charTrie.put('i', \"i\");\n-        charTrie.put('e', \"e\");\n-        charTrie.put('x', \"x\");\n-        charTrie.put('q', \"q\");\n-        charTrie.put('b', \"b\");\n-        charTrie.put('j', \"j\");\n-        charTrie.put('s', \"s\");\n-        charTrie.put('n', \"n\");\n-        charTrie.put('v', \"v\");\n-        charTrie.put('g', \"g\");\n-        charTrie.put('h', \"h\");\n-        charTrie.put('m', \"m\");\n-        charTrie.put('z', \"z\");\n-        charTrie.put('f', \"f\");\n-        charTrie.put('d', \"d\");\n-\n-        final Object[] results = new Object[] {\n-            'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n-            'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n-            'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-            'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n-            'z', \"z\"\n-        };\n-\n-        for(int i = 0; i < results.length; i++) {\n-            final Map.Entry<Character, String> found = charTrie.ceilingEntry((Character)results[i]);\n-            Assert.assertNotNull(found);\n-            Assert.assertEquals(results[i], found.getKey());\n-            Assert.assertEquals(results[++i], found.getValue());\n-        }\n-\n-        // Remove some & try again...\n-        charTrie.remove('a');\n-        charTrie.remove('z');\n-        charTrie.remove('q');\n-        charTrie.remove('l');\n-        charTrie.remove('p');\n-        charTrie.remove('m');\n-        charTrie.remove('u');\n-\n-        Map.Entry<Character, String> found = charTrie.ceilingEntry('u');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'v', found.getKey());\n-\n-        found = charTrie.ceilingEntry('a');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'b', found.getKey());\n-\n-        found = charTrie.ceilingEntry('z');\n-        Assert.assertNull(found);\n-\n-        found = charTrie.ceilingEntry('q');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'r', found.getKey());\n-\n-        found = charTrie.ceilingEntry('l');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'n', found.getKey());\n-\n-        found = charTrie.ceilingEntry('p');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'r', found.getKey());\n-\n-        found = charTrie.ceilingEntry('m');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'n', found.getKey());\n-\n-        found = charTrie.ceilingEntry('\\0');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'b', found.getKey());\n-\n-        charTrie.put('\\0', \"\");\n-        found = charTrie.ceilingEntry('\\0');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'\\0', found.getKey());\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testLowerEntry() {\n-        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n-        charTrie.put('c', \"c\");\n-        charTrie.put('p', \"p\");\n-        charTrie.put('l', \"l\");\n-        charTrie.put('t', \"t\");\n-        charTrie.put('k', \"k\");\n-        charTrie.put('a', \"a\");\n-        charTrie.put('y', \"y\");\n-        charTrie.put('r', \"r\");\n-        charTrie.put('u', \"u\");\n-        charTrie.put('o', \"o\");\n-        charTrie.put('w', \"w\");\n-        charTrie.put('i', \"i\");\n-        charTrie.put('e', \"e\");\n-        charTrie.put('x', \"x\");\n-        charTrie.put('q', \"q\");\n-        charTrie.put('b', \"b\");\n-        charTrie.put('j', \"j\");\n-        charTrie.put('s', \"s\");\n-        charTrie.put('n', \"n\");\n-        charTrie.put('v', \"v\");\n-        charTrie.put('g', \"g\");\n-        charTrie.put('h', \"h\");\n-        charTrie.put('m', \"m\");\n-        charTrie.put('z', \"z\");\n-        charTrie.put('f', \"f\");\n-        charTrie.put('d', \"d\");\n-\n-        final Object[] results = new Object[] {\n-            'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n-            'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n-            'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-            'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n-            'z', \"z\"\n-        };\n-\n-        for(int i = 0; i < results.length; i+=2) {\n-            //System.out.println(\"Looking for: \" + results[i]);\n-            final Map.Entry<Character, String> found = charTrie.lowerEntry((Character)results[i]);\n-            if(i == 0) {\n-                Assert.assertNull(found);\n-            } else {\n-                Assert.assertNotNull(found);\n-                Assert.assertEquals(results[i-2], found.getKey());\n-                Assert.assertEquals(results[i-1], found.getValue());\n-            }\n-        }\n-\n-        Map.Entry<Character, String> found = charTrie.lowerEntry((char)('z' + 1));\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'z', found.getKey());\n-\n-        // Remove some & try again...\n-        charTrie.remove('a');\n-        charTrie.remove('z');\n-        charTrie.remove('q');\n-        charTrie.remove('l');\n-        charTrie.remove('p');\n-        charTrie.remove('m');\n-        charTrie.remove('u');\n-\n-        found = charTrie.lowerEntry('u');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'t', found.getKey());\n-\n-        found = charTrie.lowerEntry('v');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'t', found.getKey());\n-\n-        found = charTrie.lowerEntry('a');\n-        Assert.assertNull(found);\n-\n-        found = charTrie.lowerEntry('z');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'y', found.getKey());\n-\n-        found = charTrie.lowerEntry((char)('z'+1));\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'y', found.getKey());\n-\n-        found = charTrie.lowerEntry('q');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'o', found.getKey());\n-\n-        found = charTrie.lowerEntry('r');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'o', found.getKey());\n-\n-        found = charTrie.lowerEntry('p');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'o', found.getKey());\n-\n-        found = charTrie.lowerEntry('l');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'k', found.getKey());\n-\n-        found = charTrie.lowerEntry('m');\n-        Assert.assertNotNull(found);\n-        Assert.assertEquals((Character)'k', found.getKey());\n-\n-        found = charTrie.lowerEntry('\\0');\n-        Assert.assertNull(found);\n-\n-        charTrie.put('\\0', \"\");\n-        found = charTrie.lowerEntry('\\0');\n-        Assert.assertNull(found);\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testIteration() {\n-        final PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n-        intTrie.put(1, \"One\");\n-        intTrie.put(5, \"Five\");\n-        intTrie.put(4, \"Four\");\n-        intTrie.put(2, \"Two\");\n-        intTrie.put(3, \"Three\");\n-        intTrie.put(15, \"Fifteen\");\n-        intTrie.put(13, \"Thirteen\");\n-        intTrie.put(14, \"Fourteen\");\n-        intTrie.put(16, \"Sixteen\");\n-\n-        TestCursor cursor = new TestCursor(\n-                1, \"One\", 2, \"Two\", 3, \"Three\", 4, \"Four\", 5, \"Five\", 13, \"Thirteen\",\n-                14, \"Fourteen\", 15, \"Fifteen\", 16, \"Sixteen\");\n-\n-        cursor.starting();\n-        intTrie.traverse(cursor);\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final Map.Entry<Integer, String> entry : intTrie.entrySet()) {\n-            cursor.select(entry);\n-        }\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final Integer integer : intTrie.keySet()) {\n-            cursor.checkKey(integer);\n-        }\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final String string : intTrie.values()) {\n-            cursor.checkValue(string);\n-        }\n-        cursor.finished();\n-\n-        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n-        charTrie.put('c', \"c\");\n-        charTrie.put('p', \"p\");\n-        charTrie.put('l', \"l\");\n-        charTrie.put('t', \"t\");\n-        charTrie.put('k', \"k\");\n-        charTrie.put('a', \"a\");\n-        charTrie.put('y', \"y\");\n-        charTrie.put('r', \"r\");\n-        charTrie.put('u', \"u\");\n-        charTrie.put('o', \"o\");\n-        charTrie.put('w', \"w\");\n-        charTrie.put('i', \"i\");\n-        charTrie.put('e', \"e\");\n-        charTrie.put('x', \"x\");\n-        charTrie.put('q', \"q\");\n-        charTrie.put('b', \"b\");\n-        charTrie.put('j', \"j\");\n-        charTrie.put('s', \"s\");\n-        charTrie.put('n', \"n\");\n-        charTrie.put('v', \"v\");\n-        charTrie.put('g', \"g\");\n-        charTrie.put('h', \"h\");\n-        charTrie.put('m', \"m\");\n-        charTrie.put('z', \"z\");\n-        charTrie.put('f', \"f\");\n-        charTrie.put('d', \"d\");\n-        cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n-                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n-                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n-                'z', \"z\");\n-\n-        cursor.starting();\n-        charTrie.traverse(cursor);\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final Map.Entry<Character, String> entry : charTrie.entrySet()) {\n-            cursor.select(entry);\n-        }\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final Character character : charTrie.keySet()) {\n-            cursor.checkKey(character);\n-        }\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final String string : charTrie.values()) {\n-            cursor.checkValue(string);\n-        }\n-        cursor.finished();\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testSelect() {\n-        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n-        charTrie.put('c', \"c\");\n-        charTrie.put('p', \"p\");\n-        charTrie.put('l', \"l\");\n-        charTrie.put('t', \"t\");\n-        charTrie.put('k', \"k\");\n-        charTrie.put('a', \"a\");\n-        charTrie.put('y', \"y\");\n-        charTrie.put('r', \"r\");\n-        charTrie.put('u', \"u\");\n-        charTrie.put('o', \"o\");\n-        charTrie.put('w', \"w\");\n-        charTrie.put('i', \"i\");\n-        charTrie.put('e', \"e\");\n-        charTrie.put('x', \"x\");\n-        charTrie.put('q', \"q\");\n-        charTrie.put('b', \"b\");\n-        charTrie.put('j', \"j\");\n-        charTrie.put('s', \"s\");\n-        charTrie.put('n', \"n\");\n-        charTrie.put('v', \"v\");\n-        charTrie.put('g', \"g\");\n-        charTrie.put('h', \"h\");\n-        charTrie.put('m', \"m\");\n-        charTrie.put('z', \"z\");\n-        charTrie.put('f', \"f\");\n-        charTrie.put('d', \"d\");\n-        final TestCursor cursor = new TestCursor(\n-                'd', \"d\", 'e', \"e\", 'f', \"f\", 'g', \"g\",\n-                'a', \"a\", 'b', \"b\", 'c', \"c\",\n-                'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-                'h', \"h\", 'i', \"i\", 'j', \"j\", 'k', \"k\",\n-                't', \"t\", 'u', \"u\", 'v', \"v\", 'w', \"w\",\n-                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\",\n-                'x', \"x\", 'y', \"y\", 'z', \"z\");\n-\n-        Assert.assertEquals(26, charTrie.size());\n-\n-        cursor.starting();\n-        charTrie.select('d', cursor);\n-        cursor.finished();\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testTraverseCursorRemove() {\n-        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n-        charTrie.put('c', \"c\");\n-        charTrie.put('p', \"p\");\n-        charTrie.put('l', \"l\");\n-        charTrie.put('t', \"t\");\n-        charTrie.put('k', \"k\");\n-        charTrie.put('a', \"a\");\n-        charTrie.put('y', \"y\");\n-        charTrie.put('r', \"r\");\n-        charTrie.put('u', \"u\");\n-        charTrie.put('o', \"o\");\n-        charTrie.put('w', \"w\");\n-        charTrie.put('i', \"i\");\n-        charTrie.put('e', \"e\");\n-        charTrie.put('x', \"x\");\n-        charTrie.put('q', \"q\");\n-        charTrie.put('b', \"b\");\n-        charTrie.put('j', \"j\");\n-        charTrie.put('s', \"s\");\n-        charTrie.put('n', \"n\");\n-        charTrie.put('v', \"v\");\n-        charTrie.put('g', \"g\");\n-        charTrie.put('h', \"h\");\n-        charTrie.put('m', \"m\");\n-        charTrie.put('z', \"z\");\n-        charTrie.put('f', \"f\");\n-        charTrie.put('d', \"d\");\n-        final TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n-                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n-                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n-                'z', \"z\");\n-\n-        cursor.starting();\n-        charTrie.traverse(cursor);\n-        cursor.finished();\n-\n-        // Test removing both an internal & external node.\n-        // 'm' is an example External node in this Trie, and 'p' is an internal.\n-\n-        Assert.assertEquals(26, charTrie.size());\n-\n-        final Object[] toRemove = new Object[] { 'g', 'd', 'e', 'm', 'p', 'q', 'r', 's' };\n-        cursor.addToRemove(toRemove);\n-\n-        cursor.starting();\n-        charTrie.traverse(cursor);\n-        cursor.finished();\n-\n-        Assert.assertEquals(26 - toRemove.length, charTrie.size());\n-\n-        cursor.starting();\n-        charTrie.traverse(cursor);\n-        cursor.finished();\n-\n-        cursor.starting();\n-        for (final Entry<Character, String> entry : charTrie.entrySet()) {\n-            cursor.select(entry);\n-            if (Arrays.asList(toRemove).contains(entry.getKey())) {\n-                Assert.fail(\"got an: \" + entry);\n-            }\n-        }\n-        cursor.finished();\n-    }\n-\n-    @Test\n-    @SuppressWarnings(\"boxing\") // OK in test code\n-    public void testIteratorRemove() {\n-        final PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n-        charTrie.put('c', \"c\");\n-        charTrie.put('p', \"p\");\n-        charTrie.put('l', \"l\");\n-        charTrie.put('t', \"t\");\n-        charTrie.put('k', \"k\");\n-        charTrie.put('a', \"a\");\n-        charTrie.put('y', \"y\");\n-        charTrie.put('r', \"r\");\n-        charTrie.put('u', \"u\");\n-        charTrie.put('o', \"o\");\n-        charTrie.put('w', \"w\");\n-        charTrie.put('i', \"i\");\n-        charTrie.put('e', \"e\");\n-        charTrie.put('x', \"x\");\n-        charTrie.put('q', \"q\");\n-        charTrie.put('b', \"b\");\n-        charTrie.put('j', \"j\");\n-        charTrie.put('s', \"s\");\n-        charTrie.put('n', \"n\");\n-        charTrie.put('v', \"v\");\n-        charTrie.put('g', \"g\");\n-        charTrie.put('h', \"h\");\n-        charTrie.put('m', \"m\");\n-        charTrie.put('z', \"z\");\n-        charTrie.put('f', \"f\");\n-        charTrie.put('d', \"d\");\n-        final TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n-                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n-                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n-                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n-                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\",\n-                'z', \"z\");\n-\n-        // Test removing both an internal & external node.\n-        // 'm' is an example External node in this Trie, and 'p' is an internal.\n-\n-        Assert.assertEquals(26, charTrie.size());\n-\n-        final Object[] toRemove = new Object[] { 'e', 'm', 'p', 'q', 'r', 's' };\n-\n-        cursor.starting();\n-        for(final Iterator<Map.Entry<Character, String>> i = charTrie.entrySet().iterator(); i.hasNext(); ) {\n-            final Map.Entry<Character,String> entry = i.next();\n-            cursor.select(entry);\n-            if(Arrays.asList(toRemove).contains(entry.getKey())) {\n-                i.remove();\n-            }\n-        }\n-        cursor.finished();\n-\n-        Assert.assertEquals(26 - toRemove.length, charTrie.size());\n-\n-        cursor.remove(toRemove);\n-\n-        cursor.starting();\n-        for (final Entry<Character, String> entry : charTrie.entrySet()) {\n-            cursor.select(entry);\n-            if (Arrays.asList(toRemove).contains(entry.getKey())) {\n-                Assert.fail(\"got an: \" + entry);\n-            }\n-        }\n-        cursor.finished();\n-    }\n-\n-    @Test\n-    public void testHamlet() throws Exception {\n-        // Make sure that Hamlet is read & stored in the same order as a SortedSet.\n-        final List<String> original = new ArrayList<String>();\n-        final List<String> control = new ArrayList<String>();\n-        final SortedMap<String, String> sortedControl = new TreeMap<String, String>();\n-        final PatriciaTrie<String, String> trie = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-\n-        final InputStream in = getClass().getResourceAsStream(\"hamlet.txt\");\n-        final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n-\n-        String read = null;\n-        while( (read = reader.readLine()) != null) {\n-            final StringTokenizer st = new StringTokenizer(read);\n-            while(st.hasMoreTokens()) {\n-                final String token = st.nextToken();\n-                original.add(token);\n-                sortedControl.put(token, token);\n-                trie.put(token, token);\n-            }\n-        }\n-        control.addAll(sortedControl.values());\n-\n-        Assert.assertEquals(control.size(), sortedControl.size());\n-        Assert.assertEquals(sortedControl.size(), trie.size());\n-        Iterator<String> iter = trie.values().iterator();\n-        for (final String aControl : control) {\n-            Assert.assertEquals(aControl, iter.next());\n-        }\n-\n-        final Random rnd = new Random();\n-        int item = 0;\n-        iter = trie.values().iterator();\n-        int removed = 0;\n-        for(; item < control.size(); item++) {\n-            Assert.assertEquals(control.get(item), iter.next());\n-            if(rnd.nextBoolean()) {\n-                iter.remove();\n-                removed++;\n-            }\n-        }\n-\n-        Assert.assertEquals(control.size(), item);\n-        Assert.assertTrue(removed > 0);\n-        Assert.assertEquals(control.size(), trie.size() + removed);\n-\n-        // reset hamlet\n-        trie.clear();\n-        for (final String anOriginal : original) {\n-            trie.put(anOriginal, anOriginal);\n-        }\n-\n-        assertEqualArrays(sortedControl.values().toArray(), trie.values().toArray());\n-        assertEqualArrays(sortedControl.keySet().toArray(), trie.keySet().toArray());\n-        assertEqualArrays(sortedControl.entrySet().toArray(), trie.entrySet().toArray());\n-\n-        Assert.assertEquals(sortedControl.firstKey(), trie.firstKey());\n-        Assert.assertEquals(sortedControl.lastKey(), trie.lastKey());\n-\n-        SortedMap<String, String> sub = trie.headMap(control.get(523));\n-        Assert.assertEquals(523, sub.size());\n-        for(int i = 0; i < control.size(); i++) {\n-            if(i < 523) {\n-                Assert.assertTrue(sub.containsKey(control.get(i)));\n-            } else {\n-                Assert.assertFalse(sub.containsKey(control.get(i)));\n-            }\n-        }\n-        // Too slow to check values on all, so just do a few.\n-        Assert.assertTrue(sub.containsValue(control.get(522)));\n-        Assert.assertFalse(sub.containsValue(control.get(523)));\n-        Assert.assertFalse(sub.containsValue(control.get(524)));\n-\n-        try {\n-            sub.headMap(control.get(524));\n-            Assert.fail(\"should have thrown IAE\");\n-        } catch(final IllegalArgumentException expected) {}\n-\n-        Assert.assertEquals(sub.lastKey(), control.get(522));\n-        Assert.assertEquals(sub.firstKey(), control.get(0));\n-\n-        sub = sub.tailMap(control.get(234));\n-        Assert.assertEquals(289, sub.size());\n-        Assert.assertEquals(control.get(234), sub.firstKey());\n-        Assert.assertEquals(control.get(522), sub.lastKey());\n-        for(int i = 0; i < control.size(); i++) {\n-            if(i < 523 && i > 233) {\n-                Assert.assertTrue(sub.containsKey(control.get(i)));\n-            } else {\n-                Assert.assertFalse(sub.containsKey(control.get(i)));\n-            }\n-        }\n-\n-        try {\n-            sub.tailMap(control.get(232));\n-            Assert.fail(\"should have thrown IAE\");\n-        } catch(final IllegalArgumentException expected) {}\n-\n-        sub = sub.subMap(control.get(300), control.get(400));\n-        Assert.assertEquals(100, sub.size());\n-        Assert.assertEquals(control.get(300), sub.firstKey());\n-        Assert.assertEquals(control.get(399), sub.lastKey());\n-\n-        for(int i = 0; i < control.size(); i++) {\n-            if(i < 400 && i > 299) {\n-                Assert.assertTrue(sub.containsKey(control.get(i)));\n-            } else {\n-                Assert.assertFalse(sub.containsKey(control.get(i)));\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testPrefixedBy() {\n-        final PatriciaTrie<String, String> trie\n-            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+public class PatriciaTrieTest<V> extends AbstractSortedMapTest<String, V> {\n+\n+    public PatriciaTrieTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(PatriciaTrieTest.class);\n+    }\n+\n+    @Override\n+    public SortedMap<String, V> makeObject() {\n+        return new PatriciaTrie<V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public void testPrefixMap() {\n+        final PatriciaTrie<String> trie = new PatriciaTrie<String>();\n \n         final String[] keys = new String[]{\n                 \"\",\n         Iterator<Map.Entry<String, String>> entryIterator;\n         Map.Entry<String, String> entry;\n \n-        map = trie.getPrefixedBy(\"Al\");\n+        map = trie.prefixMap(\"Al\");\n         Assert.assertEquals(8, map.size());\n         Assert.assertEquals(\"Alabama\", map.firstKey());\n         Assert.assertEquals(\"Alliese\", map.lastKey());\n         Assert.assertEquals(\"Alliese\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"Albert\");\n+        map = trie.prefixMap(\"Albert\");\n         iterator = map.keySet().iterator();\n         Assert.assertEquals(\"Albert\", iterator.next());\n         Assert.assertEquals(\"Alberto\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n         Assert.assertEquals(\"Albertz\", map.remove(\"Albertz\"));\n \n-        map = trie.getPrefixedBy(\"Alberto\");\n+        map = trie.prefixMap(\"Alberto\");\n         Assert.assertEquals(2, map.size());\n         Assert.assertEquals(\"Alberto\", map.firstKey());\n         Assert.assertEquals(\"Albertoo\", map.lastKey());\n         Assert.assertEquals(\"Albertoad\", trie.remove(\"Albertoad\"));\n         trie.put(\"Albertoo\", \"Albertoo\");\n \n-        map = trie.getPrefixedBy(\"X\");\n+        map = trie.prefixMap(\"X\");\n         Assert.assertEquals(2, map.size());\n         Assert.assertFalse(map.containsKey(\"Albert\"));\n         Assert.assertTrue(map.containsKey(\"Xavier\"));\n         Assert.assertEquals(\"XyZ\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"An\");\n+        map = trie.prefixMap(\"An\");\n         Assert.assertEquals(1, map.size());\n         Assert.assertEquals(\"Anna\", map.firstKey());\n         Assert.assertEquals(\"Anna\", map.lastKey());\n         Assert.assertEquals(\"Anna\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"Ban\");\n+        map = trie.prefixMap(\"Ban\");\n         Assert.assertEquals(1, map.size());\n         Assert.assertEquals(\"Banane\", map.firstKey());\n         Assert.assertEquals(\"Banane\", map.lastKey());\n         Assert.assertEquals(\"Banane\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"Am\");\n+        map = trie.prefixMap(\"Am\");\n         Assert.assertFalse(map.isEmpty());\n         Assert.assertEquals(3, map.size());\n         Assert.assertEquals(\"Amber\", trie.remove(\"Amber\"));\n         Assert.assertEquals(\"Amber\", map.firstKey());\n         Assert.assertEquals(\"Ammun\", map.lastKey());\n \n-        map = trie.getPrefixedBy(\"Ak\\0\");\n+        map = trie.prefixMap(\"Ak\\0\");\n         Assert.assertTrue(map.isEmpty());\n \n-        map = trie.getPrefixedBy(\"Ak\");\n+        map = trie.prefixMap(\"Ak\");\n         Assert.assertEquals(2, map.size());\n         Assert.assertEquals(\"Akka\", map.firstKey());\n         Assert.assertEquals(\"Akko\", map.lastKey());\n         Assert.assertFalse(iterator.hasNext());\n         Assert.assertEquals(\"Al\", trie.remove(\"Al\"));\n \n-        map = trie.getPrefixedBy(\"Akka\");\n+        map = trie.prefixMap(\"Akka\");\n         Assert.assertEquals(1, map.size());\n         Assert.assertEquals(\"Akka\", map.firstKey());\n         Assert.assertEquals(\"Akka\", map.lastKey());\n         Assert.assertEquals(\"Akka\", iterator.next());\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"Ab\");\n+        map = trie.prefixMap(\"Ab\");\n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         try {\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"Albertooo\");\n+        map = trie.prefixMap(\"Albertooo\");\n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         try {\n         iterator = map.values().iterator();\n         Assert.assertFalse(iterator.hasNext());\n \n-        map = trie.getPrefixedBy(\"\");\n+        map = trie.prefixMap(\"\");\n         Assert.assertSame(trie, map); // stricter than necessary, but a good check\n \n-        map = trie.getPrefixedBy(\"\\0\");\n+        map = trie.prefixMap(\"\\0\");\n         Assert.assertTrue(map.isEmpty());\n         Assert.assertEquals(0, map.size());\n         try {\n         Assert.assertFalse(iterator.hasNext());\n     }\n \n-    @Test\n-    public void testPrefixByOffsetAndLength() {\n-        final PatriciaTrie<String, String> trie\n-            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+    public void testPrefixMapRemoval() {\n+        final PatriciaTrie<String> trie = new PatriciaTrie<String>();\n \n         final String[] keys = new String[]{\n                 \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n             trie.put(key, key);\n         }\n \n-        SortedMap<String, String> map;\n-        Iterator<String> iterator;\n-\n-        map = trie.getPrefixedBy(\"Alice\", 2);\n-        Assert.assertEquals(8, map.size());\n-        Assert.assertEquals(\"Alabama\", map.firstKey());\n-        Assert.assertEquals(\"Alliese\", map.lastKey());\n-        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n-        Assert.assertNotNull(trie.get(\"Xavier\"));\n-        Assert.assertNull(map.get(\"Xavier\"));\n-        Assert.assertNull(trie.get(\"Alice\"));\n-        Assert.assertNull(map.get(\"Alice\"));\n-        iterator = map.values().iterator();\n-        Assert.assertEquals(\"Alabama\", iterator.next());\n-        Assert.assertEquals(\"Albert\", iterator.next());\n-        Assert.assertEquals(\"Alberto\", iterator.next());\n-        Assert.assertEquals(\"Albertoo\", iterator.next());\n-        Assert.assertEquals(\"Alberts\", iterator.next());\n-        Assert.assertEquals(\"Alien\", iterator.next());\n-        Assert.assertEquals(\"Allie\", iterator.next());\n-        Assert.assertEquals(\"Alliese\", iterator.next());\n-        Assert.assertFalse(iterator.hasNext());\n-\n-        map = trie.getPrefixedBy(\"BAlice\", 1, 2);\n-        Assert.assertEquals(8, map.size());\n-        Assert.assertEquals(\"Alabama\", map.firstKey());\n-        Assert.assertEquals(\"Alliese\", map.lastKey());\n-        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n-        Assert.assertNotNull(trie.get(\"Xavier\"));\n-        Assert.assertNull(map.get(\"Xavier\"));\n-        Assert.assertNull(trie.get(\"Alice\"));\n-        Assert.assertNull(map.get(\"Alice\"));\n-        iterator = map.values().iterator();\n-        Assert.assertEquals(\"Alabama\", iterator.next());\n-        Assert.assertEquals(\"Albert\", iterator.next());\n-        Assert.assertEquals(\"Alberto\", iterator.next());\n-        Assert.assertEquals(\"Albertoo\", iterator.next());\n-        Assert.assertEquals(\"Alberts\", iterator.next());\n-        Assert.assertEquals(\"Alien\", iterator.next());\n-        Assert.assertEquals(\"Allie\", iterator.next());\n-        Assert.assertEquals(\"Alliese\", iterator.next());\n-        Assert.assertFalse(iterator.hasNext());\n-    }\n-\n-    @Test\n-    public void testPrefixedByRemoval() {\n-        final PatriciaTrie<String, String> trie\n-            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-\n-        final String[] keys = new String[]{\n-                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n-                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n-                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n-                \"Amma\"\n-        };\n-\n-        for (final String key : keys) {\n-            trie.put(key, key);\n-        }\n-\n-        SortedMap<String, String> map = trie.getPrefixedBy(\"Al\");\n+        SortedMap<String, String> map = trie.prefixMap(\"Al\");\n         Assert.assertEquals(8, map.size());\n         Iterator<String> iter = map.keySet().iterator();\n         Assert.assertEquals(\"Alabama\", iter.next());\n         Assert.assertEquals(\"Alliese\", iter.next());\n         Assert.assertFalse(iter.hasNext());\n \n-        map = trie.getPrefixedBy(\"Ak\");\n+        map = trie.prefixMap(\"Ak\");\n         Assert.assertEquals(2, map.size());\n         iter = map.keySet().iterator();\n         Assert.assertEquals(\"Akka\", iter.next());\n         Assert.assertFalse(iter.hasNext());\n     }\n \n-    @Test\n-    public void testTraverseWithAllNullBitKey() {\n-        final PatriciaTrie<String, String> trie\n-            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-\n-        //\n-        // One entry in the Trie\n-        // Entry is stored at the root\n-        //\n-\n-        // trie.put(\"\", \"All Bits Are Zero\");\n-        trie.put(\"\\0\", \"All Bits Are Zero\");\n-\n-        //\n-        //  / (\"\")   <-- root\n-        //  \\_/  \\\n-        //       null\n-        //\n-\n-        final List<String> strings = new ArrayList<String>();\n-        trie.traverse(new Cursor<String, String>() {\n-            public Decision select(final Entry<? extends String, ? extends String> entry) {\n-                strings.add(entry.getValue());\n-                return Decision.CONTINUE;\n-            }\n-        });\n-\n-        Assert.assertEquals(1, strings.size());\n-\n-        strings.clear();\n-        for (final String s : trie.values()) {\n-            strings.add(s);\n-        }\n-        Assert.assertEquals(1, strings.size());\n-    }\n-\n-    @Test\n-    public void testSelectWithAllNullBitKey() {\n-        final PatriciaTrie<String, String> trie\n-            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n-\n-        // trie.put(\"\", \"All Bits Are Zero\");\n-        trie.put(\"\\0\", \"All Bits Are Zero\");\n-\n-        final List<String> strings = new ArrayList<String>();\n-        trie.select(\"Hello\", new Cursor<String, String>() {\n-            public Decision select(final Entry<? extends String, ? extends String> entry) {\n-                strings.add(entry.getValue());\n-                return Decision.CONTINUE;\n-            }\n-        });\n-        Assert.assertEquals(1, strings.size());\n-    }\n-\n-    private static class TestCursor implements Cursor<Object, Object> {\n-        private final List<Object> keys;\n-        private final List<Object> values;\n-        private Object selectFor;\n-        private List<Object> toRemove;\n-        private int index = 0;\n-\n-        TestCursor(final Object... objects) {\n-            if(objects.length % 2 != 0) {\n-                throw new IllegalArgumentException(\"must be * 2\");\n-            }\n-\n-            keys = new ArrayList<Object>(objects.length / 2);\n-            values = new ArrayList<Object>(keys.size());\n-            toRemove = Collections.emptyList();\n-            for(int i = 0; i < objects.length; i++) {\n-                keys.add(objects[i]);\n-                values.add(objects[++i]);\n-            }\n-        }\n-\n-        @SuppressWarnings(\"unused\")\n-        void selectFor(final Object object) {\n-            selectFor = object;\n-        }\n-\n-        void addToRemove(final Object... objects) {\n-            toRemove = new ArrayList<Object>(Arrays.asList(objects));\n-        }\n-\n-        void remove(final Object... objects) {\n-            for (final Object object : objects) {\n-                final int idx = keys.indexOf(object);\n-                keys.remove(idx);\n-                values.remove(idx);\n-            }\n-        }\n-\n-        void starting() {\n-            index = 0;\n-        }\n-\n-        public void checkKey(final Object k) {\n-            Assert.assertEquals(keys.get(index++), k);\n-        }\n-\n-        public void checkValue(final Object o) {\n-            Assert.assertEquals(values.get(index++), o);\n-        }\n-\n-        public Decision select(final Entry<?, ?> entry) {\n-          //  System.out.println(\"Scanning: \" + entry.getKey());\n-            Assert.assertEquals(keys.get(index), entry.getKey());\n-            Assert.assertEquals(values.get(index), entry.getValue());\n-            index++;\n-\n-            if(toRemove.contains(entry.getKey())) {\n-              // System.out.println(\"Removing: \" + entry.getKey());\n-                index--;\n-                keys.remove(index);\n-                values.remove(index);\n-                toRemove.remove(entry.getKey());\n-                return Decision.REMOVE;\n-            }\n-\n-            if(selectFor != null && selectFor.equals(entry.getKey())) {\n-                return Decision.EXIT;\n-            } else {\n-                return Decision.CONTINUE;\n-            }\n-        }\n-\n-        void finished() {\n-            Assert.assertEquals(keys.size(), index);\n-        }\n-    }\n-\n-    private static void assertEqualArrays(final Object[] a, final Object[] b) {\n-        Assert.assertTrue(Arrays.equals(a, b));\n-    }\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/PatriciaTrie.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/PatriciaTrie.fullCollection.version4.obj\");\n+//    }    \n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/trie/UnmodifiableTrieTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.trie;\n+\n+import java.util.SortedMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.map.AbstractSortedMapTest;\n+import org.apache.commons.collections4.map.UnmodifiableSortedMap;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the\n+ * {@link UnmodifiableTrie} implementation.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableTrieTest<V> extends AbstractSortedMapTest<String, V> {\n+\n+    public UnmodifiableTrieTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableTrieTest.class);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public SortedMap<String, V> makeObject() {\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(new PatriciaTrie<V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public SortedMap<String, V> makeFullMap() {\n+        final SortedMap<String, V> m = new PatriciaTrie<V>();\n+        addSampleMappings(m);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        final SortedMap<String, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n+\n+        try {\n+            UnmodifiableSortedMap.unmodifiableSortedMap(null);\n+            fail();\n+        } catch (final IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableTrie.emptyCollection.version4.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"src/test/resources/data/test/UnmodifiableTrie.fullCollection.version4.obj\");\n+//    }\n+\n+}", "timestamp": 1371157260, "metainfo": ""}