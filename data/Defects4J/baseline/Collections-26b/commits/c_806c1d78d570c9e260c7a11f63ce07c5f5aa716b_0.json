{"sha": "806c1d78d570c9e260c7a11f63ce07c5f5aa716b", "log": "Rename test classes for map package.  ", "commit": "\n--- a/src/test/java/org/apache/commons/collections/AbstractTreeMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractTreeMapTest.java\n \n import java.util.TreeMap;\n \n-import org.apache.commons.collections.map.AbstractTestMap;\n+import org.apache.commons.collections.map.AbstractMapTest;\n \n /**\n  * Tests TreeMap.\n  *\n  * @author Jason van Zyl\n  */\n-public abstract class AbstractTreeMapTest<K, V> extends AbstractTestMap<K, V> {\n+public abstract class AbstractTreeMapTest<K, V> extends AbstractMapTest<K, V> {\n \n     public AbstractTreeMapTest(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.iterators.AbstractMapIteratorTest;\n-import org.apache.commons.collections.map.AbstractTestIterableMap;\n+import org.apache.commons.collections.map.AbstractIterableMapTest;\n \n /**\n  * Abstract test class for {@link BidiMap} methods and contracts.\n  *\n  * @version $Id$\n  */\n-public abstract class AbstractBidiMapTest<K, V> extends AbstractTestIterableMap<K, V> {\n+public abstract class AbstractBidiMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n \n     public AbstractBidiMapTest(String testName) {\n         super(testName);\n--- a/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n \n import org.apache.commons.collections.BulkTest;\n import org.apache.commons.collections.SortedBidiMap;\n-import org.apache.commons.collections.map.AbstractTestSortedMap;\n+import org.apache.commons.collections.map.AbstractSortedMapTest;\n \n /**\n  * Abstract test class for {@link SortedBidiMap} methods and contracts.\n \n     //-----------------------------------------------------------------------\n     public BulkTest bulkTestHeadMap() {\n-        return new AbstractTestSortedMap.TestHeadMap<K, V>(this);\n+        return new AbstractSortedMapTest.TestHeadMap<K, V>(this);\n     }\n \n     public BulkTest bulkTestTailMap() {\n-        return new AbstractTestSortedMap.TestTailMap<K, V>(this);\n+        return new AbstractSortedMapTest.TestTailMap<K, V>(this);\n     }\n \n     public BulkTest bulkTestSubMap() {\n-        return new AbstractTestSortedMap.TestSubMap<K, V>(this);\n+        return new AbstractSortedMapTest.TestSubMap<K, V>(this);\n     }\n \n }\n--- a/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/AbstractCollectionTest.java\n  * {@link #confirmed}, the {@link #verify()} method is invoked to compare\n  * the results.  You may want to override {@link #verify()} to perform\n  * additional verifications.  For instance, when testing the collection\n- * views of a map, {@link org.apache.commons.collections.map.AbstractTestMap AbstractTestMap} \n+ * views of a map, {@link org.apache.commons.collections.map.AbstractMapTest AbstractTestMap} \n  * would override {@link #verify()} to make\n  * sure the map is changed after the collection view is changed.\n  * <p>\n--- a/src/test/java/org/apache/commons/collections/list/CursorableLinkedListTest.java\n+++ b/src/test/java/org/apache/commons/collections/list/CursorableLinkedListTest.java\n     @Override\n     public String[] ignoredTests() {\n         ArrayList<String> list = new ArrayList<String>();\n-        String prefix = \"TestCursorableLinkedList\";\n+        String prefix = \"CursorableLinkedListTest\";\n         String bulk = \".bulkTestSubList\";\n         String[] ignored = new String[] {\n                 \".testEmptyListSerialization\",\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractIterableMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.AbstractMapIteratorTest;\n+\n+/**\n+ * Abstract test class for {@link IterableMap} methods and contracts.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractIterableMapTest<K, V> extends AbstractMapTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractIterableMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract IterableMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        return (IterableMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFailFastEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+        if (isFailFastExpected() == false) return;\n+        resetFull();\n+        Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();\n+        Map.Entry<K, V> val = it.next();\n+        getMap().remove(val.getKey());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().entrySet().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+    }\n+\n+    public void testFailFastKeySet() {\n+        if (isRemoveSupported() == false) return;\n+        if (isFailFastExpected() == false) return;\n+        resetFull();\n+        Iterator<K> it = getMap().keySet().iterator();\n+        K val = it.next();\n+        getMap().remove(val);\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().keySet().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+    }\n+\n+    public void testFailFastValues() {\n+        if (isRemoveSupported() == false) return;\n+        if (isFailFastExpected() == false) return;\n+        resetFull();\n+        Iterator<V> it = getMap().values().iterator();\n+        it.next();\n+        getMap().remove(getMap().keySet().iterator().next());\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+\n+        resetFull();\n+        it = getMap().values().iterator();\n+        it.next();\n+        getMap().clear();\n+        try {\n+            it.next();\n+            fail();\n+        } catch (ConcurrentModificationException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestMapIterator() {\n+        return new InnerTestMapIterator();\n+    }\n+\n+    public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V> {\n+        public InnerTestMapIterator() {\n+            super(\"InnerTestMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractIterableMapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractIterableMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isGetStructuralModify() {\n+            return AbstractIterableMapTest.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractIterableMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractIterableMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractIterableMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public Map<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractIterableMapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractIterableMapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractIterableMapTest.this.verify();\n+        }\n+    }\n+\n+//  public void testCreate() throws Exception {\n+//      resetEmpty();\n+//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n+//      resetFull();\n+//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n+//  }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public IterableMap<K, V> getMap() {\n+        return (IterableMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.AbstractObjectTest;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.AbstractCollectionTest;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n+import org.apache.commons.collections.set.AbstractSetTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.Map} methods and contracts.\n+ * <p>\n+ * The forces at work here are similar to those in {@link AbstractCollectionTest}.\n+ * If your class implements the full Map interface, including optional\n+ * operations, simply extend this class, and implement the\n+ * {@link #makeObject()} method.\n+ * <p>\n+ * On the other hand, if your map implementation is weird, you may have to\n+ * override one or more of the other protected methods.  They're described\n+ * below.\n+ * <p>\n+ * <b>Entry Population Methods</b>\n+ * <p>\n+ * Override these methods if your map requires special entries:\n+ *\n+ * <ul>\n+ * <li>{@link #getSampleKeys()}\n+ * <li>{@link #getSampleValues()}\n+ * <li>{@link #getNewSampleValues()}\n+ * <li>{@link #getOtherKeys()}\n+ * <li>{@link #getOtherValues()}\n+ * </ul>\n+ *\n+ * <b>Supported Operation Methods</b>\n+ * <p>\n+ * Override these methods if your map doesn't support certain operations:\n+ *\n+ * <ul>\n+ * <li> {@link #isPutAddSupported()}\n+ * <li> {@link #isPutChangeSupported()}\n+ * <li> {@link #isSetValueSupported()}\n+ * <li> {@link #isRemoveSupported()}\n+ * <li> {@link #isGetStructuralModify()}\n+ * <li> {@link #isAllowDuplicateValues()}\n+ * <li> {@link #isAllowNullKey()}\n+ * <li> {@link #isAllowNullValue()}\n+ * </ul>\n+ *\n+ * <b>Fixture Methods</b>\n+ * <p>\n+ * For tests on modification operations (puts and removes), fixtures are used\n+ * to verify that that operation results in correct state for the map and its\n+ * collection views.  Basically, the modification is performed against your\n+ * map implementation, and an identical modification is performed against\n+ * a <I>confirmed</I> map implementation.  A confirmed map implementation is\n+ * something like <Code>java.util.HashMap</Code>, which is known to conform\n+ * exactly to the {@link Map} contract.  After the modification takes place\n+ * on both your map implementation and the confirmed map implementation, the\n+ * two maps are compared to see if their state is identical.  The comparison\n+ * also compares the collection views to make sure they're still the same.<P>\n+ *\n+ * The upshot of all that is that <I>any</I> test that modifies the map in\n+ * <I>any</I> way will verify that <I>all</I> of the map's state is still\n+ * correct, including the state of its collection views.  So for instance\n+ * if a key is removed by the map's key set's iterator, then the entry set\n+ * is checked to make sure the key/value pair no longer appears.<P>\n+ *\n+ * The {@link #map} field holds an instance of your collection implementation.\n+ * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n+ * that map's collection views.  And the {@link #confirmed} field holds\n+ * an instance of the confirmed collection implementation.  The\n+ * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to\n+ * empty or full maps, so that tests can proceed from a known state.<P>\n+ *\n+ * After a modification operation to both {@link #map} and {@link #confirmed},\n+ * the {@link #verify()} method is invoked to compare the results.  The\n+ * {@link #verify} method calls separate methods to verify the map and its three\n+ * collection views ({@link #verifyMap}, {@link #verifyEntrySet},\n+ * {@link #verifyKeySet}, and {@link #verifyValues}).  You may want to override\n+ * one of the verification methods to perform additional verifications.  For\n+ * instance, TestDoubleOrderedMap would want override its\n+ * {@link #verifyValues()} method to verify that the values are unique and in\n+ * ascending order.<P>\n+ *\n+ * <b>Other Notes</b>\n+ * <p>\n+ * If your {@link Map} fails one of these tests by design, you may still use\n+ * this base set of cases.  Simply override the test case (method) your map\n+ * fails and/or the methods that define the assumptions used by the test\n+ * cases.  For example, if your map does not allow duplicate values, override\n+ * {@link #isAllowDuplicateValues()} and have it return <code>false</code>\n+ *\n+ * @author Michael Smith\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @version $Revision$\n+ */\n+public abstract class AbstractMapTest<K, V> extends AbstractObjectTest {\n+\n+    /**\n+     * JDK1.2 has bugs in null handling of Maps, especially HashMap.Entry.toString\n+     * This avoids nulls for JDK1.2\n+     */\n+    private static final boolean JDK12;\n+    static {\n+        String str = System.getProperty(\"java.version\");\n+        JDK12 = str.startsWith(\"1.2\");\n+    }\n+\n+    // These instance variables are initialized with the reset method.\n+    // Tests for map methods that alter the map (put, putAll, remove)\n+    // first call reset() to create the map and its views; then perform\n+    // the modification on the map; perform the same modification on the\n+    // confirmed; and then call verify() to ensure that the map is equal\n+    // to the confirmed, that the already-constructed collection views\n+    // are still equal to the confirmed's collection views.\n+\n+    /** Map created by reset(). */\n+    protected Map<K, V> map;\n+\n+    /** Entry set of map created by reset(). */\n+    protected Set<Map.Entry<K, V>> entrySet;\n+\n+    /** Key set of map created by reset(). */\n+    protected Set<K> keySet;\n+\n+    /** Values collection of map created by reset(). */\n+    protected Collection<V> values;\n+\n+    /** HashMap created by reset(). */\n+    protected Map<K, V> confirmed;\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>put</code> and <code>putAll</code> operations\n+     * adding new mappings.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support put adding.\n+     */\n+    public boolean isPutAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>put</code> and <code>putAll</code> operations\n+     * changing existing mappings.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support put changing.\n+     */\n+    public boolean isPutChangeSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>setValue</code> operation on entrySet entries.\n+     * <p>\n+     * Default implementation returns isPutChangeSupported().\n+     * Override if your collection class does not support setValue but does\n+     * support put changing.\n+     */\n+    public boolean isSetValueSupported() {\n+        return isPutChangeSupported();\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * support the <code>remove</code> and <code>clear</code> operations.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * can cause structural modification on a get(). The example is LRUMap.\n+     * <p>\n+     * Default implementation returns false.\n+     * Override if your map class structurally modifies on get.\n+     */\n+    public boolean isGetStructuralModify() {\n+        return false;\n+    }\n+\n+    /**\n+     * Returns whether the sub map views of SortedMap are serializable.\n+     * If the class being tested is based around a TreeMap then you should\n+     * override and return false as TreeMap has a bug in deserialization.\n+     *\n+     * @return false\n+     */\n+    public boolean isSubMapViewsSerializable() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports null keys.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support null keys.\n+     */\n+    public boolean isAllowNullKey() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports null values.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support null values.\n+     */\n+    public boolean isAllowNullValue() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * supports duplicate values.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support duplicate values.\n+     */\n+    public boolean isAllowDuplicateValues() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by\n+     * {@link #makeObject()} and {@link #makeFullMap()}\n+     * provide fail-fast behavior on their various iterators.\n+     * <p>\n+     * Default implementation returns true.\n+     * Override if your collection class does not support fast failure.\n+     */\n+    public boolean isFailFastExpected() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns the set of keys in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleValues()} and all array elements must be different. The\n+     *  default implementation constructs a set of String keys, and includes a\n+     *  single null key if {@link #isAllowNullKey()} returns <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        Object[] result = new Object[] {\n+            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\",\n+            \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n+            \"key\",\n+            \"key2\",\n+            (isAllowNullKey() && !JDK12) ? null : \"nonnullkey\"\n+        };\n+        return (K[]) result;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getOtherKeys() {\n+        return (K[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getOtherValues() {\n+        return (V[]) getOtherNonNullStringElements();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <E> List<E> getAsList(Object[] o) {\n+        ArrayList<E> result = new ArrayList<E>();\n+        for (Object element : o) {\n+            result.add((E) element);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a list of string elements suitable for return by\n+     * {@link #getOtherKeys()} or {@link #getOtherValues}.\n+     *\n+     * <p>Override getOtherElements to return the results of this method if your\n+     * collection does not support heterogenous elements or the null element.\n+     * </p>\n+     */\n+    public Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\",\"then\",\"despite\",/* of */\"space\",\"I\",\"would\",\"be\",\"brought\",\n+            \"From\",\"limits\",\"far\",\"remote\",\"where\",\"thou\",\"dost\",\"stay\"\n+        };\n+    }\n+\n+    /**\n+     * Returns the set of values in the mappings used to test the map.  This\n+     * method must return an array with the same length as\n+     * {@link #getSampleKeys()}.  The default implementation constructs a set of\n+     * String values and includes a single null value if\n+     * {@link #isAllowNullValue()} returns <code>true</code>, and includes\n+     * two values that are the same if {@link #isAllowDuplicateValues()} returns\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        Object[] result = new Object[] {\n+            \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n+            \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n+            (isAllowNullValue() && !JDK12) ? null : \"nonnullvalue\",\n+            \"value\",\n+            (isAllowDuplicateValues()) ? \"value\" : \"value2\",\n+        };\n+        return (V[]) result;\n+    }\n+\n+    /**\n+     * Returns a the set of values that can be used to replace the values\n+     * returned from {@link #getSampleValues()}.  This method must return an\n+     * array with the same length as {@link #getSampleValues()}.  The values\n+     * returned from this method should not be the same as those returned from\n+     * {@link #getSampleValues()}.  The default implementation constructs a\n+     * set of String values and includes a single null value if\n+     * {@link #isAllowNullValue()} returns <code>true</code>, and includes two values\n+     * that are the same if {@link #isAllowDuplicateValues()} returns\n+     * <code>true</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        Object[] result = new Object[] {\n+            (isAllowNullValue() && !JDK12 && isAllowDuplicateValues()) ? null : \"newnonnullvalue\",\n+            \"newvalue\",\n+            (isAllowDuplicateValues()) ? \"newvalue\" : \"newvalue2\",\n+            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\",\n+            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\",\n+            \"newseev\", \"newyouv\", \"newallv\", \"newagainv\",\n+        };\n+        return (V[]) result;\n+    }\n+\n+    /**\n+     *  Helper method to add all the mappings described by\n+     * {@link #getSampleKeys()} and {@link #getSampleValues()}.\n+     */\n+    public void addSampleMappings(Map<? super K, ? super V> m) {\n+\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            try {\n+                m.put(keys[i], values[i]);\n+            } catch (NullPointerException exception) {\n+                assertTrue(\"NullPointerException only allowed to be thrown \" +\n+                           \"if either the key or value is null.\",\n+                           keys[i] == null || values[i] == null);\n+\n+                assertTrue(\"NullPointerException on null key, but \" +\n+                           \"isAllowNullKey is not overridden to return false.\",\n+                           keys[i] == null || !isAllowNullKey());\n+\n+                assertTrue(\"NullPointerException on null value, but \" +\n+                           \"isAllowNullValue is not overridden to return false.\",\n+                           values[i] == null || !isAllowNullValue());\n+\n+                assertTrue(\"Unknown reason for NullPointer.\", false);\n+            }\n+        }\n+        assertEquals(\"size must reflect number of mappings added.\",\n+                     keys.length, m.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return a new, empty {@link Map} to be used for testing.\n+     *\n+     * @return the map to be tested\n+     */\n+    @Override\n+    public abstract Map<K,V> makeObject();\n+\n+    /**\n+     * Return a new, populated map.  The mappings in the map should match the\n+     * keys and values returned from {@link #getSampleKeys()} and\n+     * {@link #getSampleValues()}.  The default implementation uses makeEmptyMap()\n+     * and calls {@link #addSampleMappings} to add all the mappings to the\n+     * map.\n+     *\n+     * @return the map to be tested\n+     */\n+    public Map<K, V> makeFullMap() {\n+        Map<K, V> m = makeObject();\n+        addSampleMappings(m);\n+        return m;\n+    }\n+\n+    /**\n+     * Override to return a map other than HashMap as the confirmed map.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n+    }\n+\n+    /**\n+     * Creates a new Map Entry that is independent of the first and the map.\n+     */\n+    public static <K, V> Map.Entry<K, V> cloneMapEntry(Map.Entry<K, V> entry) {\n+        HashMap<K, V> map = new HashMap<K, V>();\n+        map.put(entry.getKey(), entry.getValue());\n+        return map.entrySet().iterator().next();\n+    }\n+\n+    /**\n+     * Gets the compatability version, needed for package access.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return super.getCompatibilityVersion();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Test to ensure the test setup is working properly.  This method checks\n+     * to ensure that the getSampleKeys and getSampleValues methods are\n+     * returning results that look appropriate.  That is, they both return a\n+     * non-null array of equal length.  The keys array must not have any\n+     * duplicate values, and may only contain a (single) null key if\n+     * isNullKeySupported() returns true.  The values array must only have a null\n+     * value if useNullValue() is true and may only have duplicate values if\n+     * isAllowDuplicateValues() returns true.\n+     */\n+    public void testSampleMappings() {\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Object[] newValues = getNewSampleValues();\n+\n+        assertNotNull(\"failure in test: Must have keys returned from \" +\n+                 \"getSampleKeys.\", keys);\n+\n+        assertNotNull(\"failure in test: Must have values returned from \" +\n+                 \"getSampleValues.\", values);\n+\n+        // verify keys and values have equivalent lengths (in case getSampleX are\n+        // overridden)\n+        assertEquals(\"failure in test: not the same number of sample \" +\n+                   \"keys and values.\",  keys.length, values.length);\n+\n+        assertEquals(\"failure in test: not the same number of values and new values.\",\n+                   values.length, newValues.length);\n+\n+        // verify there aren't duplicate keys, and check values\n+        for (int i = 0; i < keys.length - 1; i++) {\n+            for (int j = i + 1; j < keys.length; j++) {\n+                assertTrue(\"failure in test: duplicate null keys.\",\n+                        (keys[i] != null || keys[j] != null));\n+                assertTrue(\n+                        \"failure in test: duplicate non-null key.\",\n+                        (keys[i] == null || keys[j] == null || (!keys[i].equals(keys[j]) && !keys[j]\n+                                .equals(keys[i]))));\n+            }\n+            assertTrue(\"failure in test: found null key, but isNullKeySupported \" + \"is false.\",\n+                    keys[i] != null || isAllowNullKey());\n+            assertTrue(\n+                    \"failure in test: found null value, but isNullValueSupported \" + \"is false.\",\n+                    values[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: found null new value, but isNullValueSupported \"\n+                    + \"is false.\", newValues[i] != null || isAllowNullValue());\n+            assertTrue(\"failure in test: values should not be the same as new value\",\n+                    values[i] != newValues[i]\n+                            && (values[i] == null || !values[i].equals(newValues[i])));\n+        }\n+    }\n+\n+    // tests begin here.  Each test adds a little bit of tested functionality.\n+    // Many methods assume previous methods passed.  That is, they do not\n+    // exhaustively recheck things that have already been checked in a previous\n+    // test methods.\n+\n+    /**\n+     * Test to ensure that makeEmptyMap and makeFull returns a new non-null\n+     * map with each invocation.\n+     */\n+    public void testMakeMap() {\n+        Map<K, V> em = makeObject();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        Map<K, V> em2 = makeObject();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n+                   \"with each invocation.\", em != em2);\n+\n+        Map<K, V> fm = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        Map<K, V> fm2 = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        assertTrue(\"failure in test: makeFullMap must return a new map \" +\n+                   \"with each invocation.\", fm != fm2);\n+    }\n+\n+    /**\n+     * Tests Map.isEmpty()\n+     */\n+    public void testMapIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"Map.isEmpty() should return true with an empty map\",\n+                     true, getMap().isEmpty());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n+                     false, getMap().isEmpty());\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.size()\n+     */\n+    public void testMapSize() {\n+        resetEmpty();\n+        assertEquals(\"Map.size() should be 0 with an empty map\",\n+                     0, getMap().size());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.size() should equal the number of entries \" +\n+                     \"in the map\", getSampleKeys().length, getMap().size());\n+        verify();\n+    }\n+\n+    /**\n+     * Tests {@link Map#clear()}.  If the map {@link #isRemoveSupported()}\n+     * can add and remove elements}, then {@link Map#size()} and\n+     * {@link Map#isEmpty()} are used to ensure that map has no elements after\n+     * a call to clear.  If the map does not support adding and removing\n+     * elements, this method checks to ensure clear throws an\n+     * UnsupportedOperationException.\n+     */\n+    public void testMapClear() {\n+        if (!isRemoveSupported()) {\n+            try {\n+                resetFull();\n+                getMap().clear();\n+                fail(\"Expected UnsupportedOperationException on clear\");\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        resetEmpty();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+\n+        resetFull();\n+        getMap().clear();\n+        getConfirmed().clear();\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.containsKey(Object) by verifying it returns false for all\n+     * sample keys on a map created using an empty map and returns true for\n+     * all sample keys returned on a full map.\n+     */\n+    public void testMapContainsKey() {\n+        Object[] keys = getSampleKeys();\n+\n+        resetEmpty();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must not contain key when map is empty\",\n+                       !getMap().containsKey(keys[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must contain key for a mapping in the map. \" +\n+                       \"Missing: \" + keys[i], getMap().containsKey(keys[i]));\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.containsValue(Object) by verifying it returns false for all\n+     * sample values on an empty map and returns true for all sample values on\n+     * a full map.\n+     */\n+    public void testMapContainsValue() {\n+        Object[] values = getSampleValues();\n+\n+        resetEmpty();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Empty map must not contain value\",\n+                       !getMap().containsValue(values[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Map must contain value for a mapping in the map.\",\n+                    getMap().containsValue(values[i]));\n+        }\n+        verify();\n+    }\n+\n+\n+    /**\n+     * Tests Map.equals(Object)\n+     */\n+    public void testMapEquals() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full maps unequal.\", getMap().equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        // modify the HashMap created from the full map and make sure this\n+        // change results in map.equals() to return false.\n+        Iterator<K> iter = confirmed.keySet().iterator();\n+        iter.next();\n+        iter.remove();\n+        assertTrue(\"Different maps equal.\", !getMap().equals(confirmed));\n+\n+        resetFull();\n+        assertTrue(\"equals(null) returned true.\", !getMap().equals(null));\n+        assertTrue(\"equals(new Object()) returned true.\",\n+                   !getMap().equals(new Object()));\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.get(Object)\n+     */\n+    public void testMapGet() {\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Empty map.get() should return null.\",\n+                    getMap().get(keys[i]) == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+        for (int i = 0; i < keys.length; i++) {\n+            assertEquals(\"Full map.get() should return value from mapping.\",\n+                         values[i], getMap().get(keys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.hashCode()\n+     */\n+    public void testMapHashCode() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+\n+        resetFull();\n+        assertTrue(\"Equal maps have different hashCodes.\",\n+                getMap().hashCode() == confirmed.hashCode());\n+    }\n+\n+    /**\n+     * Tests Map.toString().  Since the format of the string returned by the\n+     * toString() method is not defined in the Map interface, there is no\n+     * common way to test the results of the toString() method.  Thereforce,\n+     * it is encouraged that Map implementations override this test with one\n+     * that checks the format matches any format defined in its API.  This\n+     * default implementation just verifies that the toString() method does\n+     * not return null.\n+     */\n+    public void testMapToString() {\n+        resetEmpty();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Empty map toString() should not return null\",\n+                getMap().toString() != null);\n+        verify();\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyMapCompatibility() throws Exception {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeEmptyMap();\n+        if (!(map instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        Map<K, V> map = makeObject();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertEquals(\"Map is empty\", 0, map2.size());\n+        }\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testFullMapCompatibility() throws Exception {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeFullMap();\n+        if (!(map instanceof Serializable)) return;\n+\n+        writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        Map<K, V> map = makeFullMap();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+            assertEquals(\"Map is the right size\", getSampleKeys().length, map2.size());\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(Object, Object)\n+     */\n+    public void testMapPut() {\n+        resetEmpty();\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        V[] newValues = getNewSampleValues();\n+\n+        if (isPutAddSupported()) {\n+            for (int i = 0; i < keys.length; i++) {\n+                Object o = getMap().put(keys[i], values[i]);\n+                getConfirmed().put(keys[i], values[i]);\n+                verify();\n+                assertTrue(\"First map.put should return null\", o == null);\n+                assertTrue(\"Map should contain key after put\",\n+                        getMap().containsKey(keys[i]));\n+                assertTrue(\"Map should contain value after put\",\n+                        getMap().containsValue(values[i]));\n+            }\n+            if (isPutChangeSupported()) {\n+                for (int i = 0; i < keys.length; i++) {\n+                    Object o = getMap().put(keys[i], newValues[i]);\n+                    getConfirmed().put(keys[i], newValues[i]);\n+                    verify();\n+                    assertEquals(\"Map.put should return previous value when changed\", values[i], o);\n+                    assertTrue(\"Map should still contain key after put when changed\",\n+                            getMap().containsKey(keys[i]));\n+                    assertTrue(\"Map should contain new value after put when changed\",\n+                            getMap().containsValue(newValues[i]));\n+\n+                    // if duplicates are allowed, we're not guaranteed that the value\n+                    // no longer exists, so don't try checking that.\n+                    if (!isAllowDuplicateValues()) {\n+                        assertTrue(\"Map should not contain old value after put when changed\",\n+                                !getMap().containsValue(values[i]));\n+                    }\n+                }\n+            } else {\n+                try {\n+                    // two possible exception here, either valid\n+                    getMap().put(keys[0], newValues[0]);\n+                    fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n+                } catch (IllegalArgumentException ex) {\n+                } catch (UnsupportedOperationException ex) {}\n+            }\n+\n+        } else if (isPutChangeSupported()) {\n+            resetEmpty();\n+            try {\n+                getMap().put(keys[0], values[0]);\n+                fail(\"Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size\");\n+            } catch (IllegalArgumentException ex) {\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+\n+            resetFull();\n+            int i = 0;\n+            for (Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n+                K  key = it.next();\n+                V o = getMap().put(key, newValues[i]);\n+                V value = getConfirmed().put(key, newValues[i]);\n+                verify();\n+                assertEquals(\"Map.put should return previous value when changed\", value, o);\n+                assertTrue(\"Map should still contain key after put when changed\", getMap()\n+                        .containsKey(key));\n+                assertTrue(\"Map should contain new value after put when changed\", getMap()\n+                        .containsValue(newValues[i]));\n+\n+                // if duplicates are allowed, we're not guaranteed that the value\n+                // no longer exists, so don't try checking that.\n+                if (!isAllowDuplicateValues()) {\n+                    assertTrue(\"Map should not contain old value after put when changed\",\n+                        !getMap().containsValue(values[i]));\n+                }\n+            }\n+        } else {\n+            try {\n+                getMap().put(keys[0], values[0]);\n+                fail(\"Expected UnsupportedOperationException on put (add)\");\n+            } catch (UnsupportedOperationException ex) {}\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(null, value)\n+     */\n+    public void testMapPutNullKey() {\n+        resetFull();\n+        V[] values = getSampleValues();\n+\n+        if (isPutAddSupported()) {\n+            if (isAllowNullKey()) {\n+                getMap().put(null, values[0]);\n+            } else {\n+                try {\n+                    getMap().put(null, values[0]);\n+                    fail(\"put(null, value) should throw NPE/IAE\");\n+                } catch (NullPointerException ex) {\n+                } catch (IllegalArgumentException ex) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.put(null, value)\n+     */\n+    public void testMapPutNullValue() {\n+        resetFull();\n+        K[] keys = getSampleKeys();\n+\n+        if (isPutAddSupported()) {\n+            if (isAllowNullValue()) {\n+                getMap().put(keys[0], null);\n+            } else {\n+                try {\n+                    getMap().put(keys[0], null);\n+                    fail(\"put(key, null) should throw NPE/IAE\");\n+                } catch (NullPointerException ex) {\n+                } catch (IllegalArgumentException ex) {}\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests Map.putAll(map)\n+     */\n+    public void testMapPutAll() {\n+        if (!isPutAddSupported()) {\n+            if (!isPutChangeSupported()) {\n+                Map<K, V> temp = makeFullMap();\n+                resetEmpty();\n+                try {\n+                    getMap().putAll(temp);\n+                    fail(\"Expected UnsupportedOperationException on putAll\");\n+                } catch (UnsupportedOperationException ex) {}\n+            }\n+            return;\n+        }\n+\n+        // check putAll OK adding empty map to empty map\n+        resetEmpty();\n+        assertEquals(0, getMap().size());\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(0, getMap().size());\n+\n+        // check putAll OK adding empty map to non-empty map\n+        resetFull();\n+        int size = getMap().size();\n+        getMap().putAll(new HashMap<K, V>());\n+        assertEquals(size, getMap().size());\n+\n+        // check putAll OK adding non-empty map to empty map\n+        resetEmpty();\n+        Map<K, V> m2 = makeFullMap();\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+\n+        // check putAll OK adding non-empty JDK map to empty map\n+        resetEmpty();\n+        m2 = makeConfirmedMap();\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        for(int i = 0; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+\n+        // check putAll OK adding non-empty JDK map to non-empty map\n+        resetEmpty();\n+        m2 = makeConfirmedMap();\n+        getMap().put(keys[0], values[0]);\n+        getConfirmed().put(keys[0], values[0]);\n+        verify();\n+        for(int i = 1; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+        getMap().putAll(m2);\n+        getConfirmed().putAll(m2);\n+        verify();\n+    }\n+\n+    /**\n+     * Tests Map.remove(Object)\n+     */\n+    public void testMapRemove() {\n+        if (!isRemoveSupported()) {\n+            try {\n+                resetFull();\n+                getMap().remove(getMap().keySet().iterator().next());\n+                fail(\"Expected UnsupportedOperationException on remove\");\n+            } catch (UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        for (int i = 0; i < keys.length; i++) {\n+            Object o = getMap().remove(keys[i]);\n+            assertTrue(\"First map.remove should return null\", o == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            Object o = getMap().remove(keys[i]);\n+            getConfirmed().remove(keys[i]);\n+            verify();\n+\n+            assertEquals(\"map.remove with valid key should return value\",\n+                         values[i], o);\n+        }\n+\n+        Object[] other = getOtherKeys();\n+\n+        resetFull();\n+        int size = getMap().size();\n+        for (int i = 0; i < other.length; i++) {\n+            Object o = getMap().remove(other[i]);\n+            assertNull(\"map.remove for nonexistent key should return null\", o);\n+            assertEquals(\"map.remove for nonexistent key should not \" +\n+                         \"shrink map\", size, getMap().size());\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testValuesClearChangesMap() {\n+        if (!isRemoveSupported()) return;\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(values.size() > 0);\n+        values.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(values.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        values = getMap().values();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(values.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(values.size() == 0);\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testKeySetClearChangesMap() {\n+        if (!isRemoveSupported()) return;\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Set<K> keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        keySet.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(keySet.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        keySet = getMap().keySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(keySet.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(keySet.size() == 0);\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet()} collection is backed by\n+     * the underlying map for clear().\n+     */\n+    public void testEntrySetClearChangesMap() {\n+        if (!isRemoveSupported()) return;\n+\n+        // clear values, reflected in map\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        entrySet.clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+\n+        // clear map, reflected in values\n+        resetFull();\n+        entrySet = getMap().entrySet();\n+        assertTrue(getMap().size() > 0);\n+        assertTrue(entrySet.size() > 0);\n+        getMap().clear();\n+        assertTrue(getMap().size() == 0);\n+        assertTrue(entrySet.size() == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testEntrySetContains1() {\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        assertEquals(true, entrySet.contains(entry));\n+    }\n+\n+    public void testEntrySetContains2() {\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        Map.Entry<K, V> test = cloneMapEntry(entry);\n+        assertEquals(true, entrySet.contains(test));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySetContains3() {\n+        resetFull();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+        assertEquals(false, entrySet.contains(test));\n+    }\n+\n+    public void testEntrySetRemove1() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+\n+        assertEquals(true, entrySet.remove(entry));\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    public void testEntrySetRemove2() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+        Map.Entry<K, V> test = cloneMapEntry(entry);\n+\n+        assertEquals(true, entrySet.remove(test));\n+        assertEquals(false, getMap().containsKey(key));\n+        assertEquals(size - 1, getMap().size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySetRemove3() {\n+        if (!isRemoveSupported()) return;\n+        resetFull();\n+        int size = getMap().size();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        K key = entry.getKey();\n+        HashMap<K, V> temp = new HashMap<K, V>();\n+        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n+        Map.Entry<K, V> test = temp.entrySet().iterator().next();\n+\n+        assertEquals(false, entrySet.remove(test));\n+        assertEquals(true, getMap().containsKey(key));\n+        assertEquals(size, getMap().size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map by removing from the values collection\n+     * and testing if the value was removed from the map.\n+     * <p>\n+     * We should really test the \"vice versa\" case--that values removed\n+     * from the map are removed from the values collection--also,\n+     * but that's a more difficult test to construct (lacking a\n+     * \"removeValue\" method.)\n+     * </p>\n+     * <p>\n+     * See bug <a href=\"http://issues.apache.org/bugzilla/show_bug.cgi?id=9573\">\n+     * 9573</a>.\n+     * </p>\n+     */\n+    public void testValuesRemoveChangesMap() {\n+        resetFull();\n+        V[] sampleValues = getSampleValues();\n+        Collection<V> values = getMap().values();\n+        for (int i = 0; i < sampleValues.length; i++) {\n+            if (map.containsValue(sampleValues[i])) {\n+                int j = 0;  // loop counter prevents infinite loops when remove is broken\n+                while (values.contains(sampleValues[i]) && j < 10000) {\n+                    try {\n+                        values.remove(sampleValues[i]);\n+                    } catch (UnsupportedOperationException e) {\n+                        // if values.remove is unsupported, just skip this test\n+                        return;\n+                    }\n+                    j++;\n+                }\n+                assertTrue(\"values().remove(obj) is broken\", j < 10000);\n+                assertTrue(\n+                    \"Value should have been removed from the underlying map.\",\n+                    !getMap().containsValue(sampleValues[i]));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests values.removeAll.\n+     */\n+    public void testValuesRemoveAll() {\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        if (!values.equals(sampleValuesAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(values.removeAll(Collections.<V> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.removeAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertEquals(sampleValuesAsList.size(), getMap().size());\n+        try {\n+            assertTrue(values.removeAll(sampleValuesAsList));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.removeAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test values.retainAll.\n+     */\n+    public void testValuesRetainAll() {\n+        resetFull();\n+        Collection<V> values = getMap().values();\n+        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        if (!values.equals(sampleValuesAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(values.retainAll(sampleValuesAsList));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertEquals(sampleValuesAsList.size(), getMap().size());\n+        try {\n+            assertTrue(values.retainAll(Collections.<V> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verifies that values.iterator.remove changes the underlying map.\n+     */\n+    public void testValuesIteratorRemoveChangesMap() {\n+        resetFull();\n+        List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+        Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n+        Collection<V> values = getMap().values();\n+        for (Iterator<V> iter = values.iterator(); iter.hasNext();) {\n+            V value = iter.next();\n+            Integer count = cardinality.get(value);\n+            if (count == null) {\n+                return;\n+            }\n+            try {\n+                iter.remove();\n+                cardinality.put(value, --count);\n+            } catch (UnsupportedOperationException e) {\n+                // if values.iterator.remove is unsupported, just skip this test\n+                return;\n+            }\n+            boolean expected = count > 0;\n+            StringBuilder msg = new StringBuilder(\"Value should \");\n+            msg.append(expected ? \"yet \" : \"no longer \");\n+            msg.append(\"be present in the underlying map\");\n+            assertEquals(msg.toString(), expected, getMap().containsValue(value));\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} set is backed by\n+     * the underlying map by removing from the keySet set\n+     * and testing if the key was removed from the map.\n+     */\n+    public void testKeySetRemoveChangesMap() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        Set<K> keys = getMap().keySet();\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            try {\n+                keys.remove(sampleKeys[i]);\n+            } catch (UnsupportedOperationException e) {\n+                // if key.remove is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\n+                \"Key should have been removed from the underlying map.\",\n+                !getMap().containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Test keySet.removeAll.\n+     */\n+    public void testKeySetRemoveAll() {\n+        resetFull();\n+        Set<K> keys = getMap().keySet();\n+        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(keys.removeAll(Collections.<K> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+            assertTrue(keys.removeAll(sampleKeysAsList));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test keySet.retainAll.\n+     */\n+    public void testKeySetRetainAll() {\n+        resetFull();\n+        Set<K> keys = getMap().keySet();\n+        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+            return;\n+        }\n+        try {\n+            assertFalse(keys.retainAll(sampleKeysAsList));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+            assertTrue(keys.retainAll(Collections.<K> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that keySet.iterator.remove changes the underlying map.\n+     */\n+    public void testKeySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n+            K key = iter.next();\n+            try {\n+                iter.remove();\n+            } catch (UnsupportedOperationException e) {\n+                return;\n+            }\n+            assertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet} set is backed by\n+     * the underlying map by removing from the entrySet set\n+     * and testing if the entry was removed from the map.\n+     */\n+    public void testEntrySetRemoveChangesMap() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        V[] sampleValues = getSampleValues();\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            try {\n+                entrySet.remove(new DefaultMapEntry<K, V>(sampleKeys[i], sampleValues[i]));\n+            } catch (UnsupportedOperationException e) {\n+                // if entrySet removal is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\n+                    \"Entry should have been removed from the underlying map.\",\n+                    !getMap().containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    /**\n+     * Test entrySet.removeAll.\n+     */\n+    public void testEntrySetRemoveAll() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        V[] sampleValues = getSampleValues();\n+        //verify map looks as expected:\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            if (!getMap().containsKey(sampleKeys[i])) {\n+                return;\n+            }\n+            V value = sampleValues[i];\n+            V test = getMap().get(sampleKeys[i]);\n+            if (value == test || value != null && value.equals(test)) {\n+                continue;\n+            }\n+            return;\n+        }\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        try {\n+            assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeys.length, getMap().size());\n+        try {\n+            assertTrue(entrySet.removeAll(comparisonSet));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test entrySet.retainAll.\n+     */\n+    public void testEntrySetRetainAll() {\n+        resetFull();\n+        K[] sampleKeys = getSampleKeys();\n+        V[] sampleValues = getSampleValues();\n+        //verify map looks as expected:\n+        for (int i = 0; i < sampleKeys.length; i++) {\n+            if (!getMap().containsKey(sampleKeys[i])) {\n+                return;\n+            }\n+            V value = sampleValues[i];\n+            V test = getMap().get(sampleKeys[i]);\n+            if (value == test || value != null && value.equals(test)) {\n+                continue;\n+            }\n+            return;\n+        }\n+        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+        HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+        try {\n+            assertFalse(entrySet.retainAll(comparisonSet));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertEquals(sampleKeys.length, getMap().size());\n+        try {\n+            assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+            return;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that entrySet.iterator.remove changes the underlying map.\n+     */\n+    public void testEntrySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n+            K key = iter.next().getKey();\n+            try {\n+                iter.remove();\n+            } catch (UnsupportedOperationException e) {\n+                return;\n+            }\n+            assertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Utility methods to create an array of Map.Entry objects\n+     * out of the given key and value arrays.<P>\n+     *\n+     * @param keys    the array of keys\n+     * @param values  the array of values\n+     * @return an array of Map.Entry of those keys to those values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private Map.Entry<K, V>[] makeEntryArray(K[] keys, V[] values) {\n+        Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n+        for (int i = 0; i < keys.length; i++) {\n+            Map<K, V> map = makeConfirmedMap();\n+            map.put(keys[i], values[i]);\n+            result[i] = map.entrySet().iterator().next();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Bulk test {@link Map#entrySet()}.  This method runs through all of\n+     * the tests in {@link AbstractSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing the map's entry set\n+     */\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestMapEntrySet();\n+    }\n+\n+    public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>> {\n+        public TestMapEntrySet() {\n+            super(\"MapEntrySet\");\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Entry<K, V>[] getFullElements() {\n+            return getFullNonNullElements();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Map.Entry<K, V>[] getFullNonNullElements() {\n+            K[] k = getSampleKeys();\n+            V[] v = getSampleValues();\n+            return makeEntryArray(k, v);\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        @Override\n+        public Map.Entry<K, V>[] getOtherElements() {\n+            K[] k = getOtherKeys();\n+            V[] v = getOtherValues();\n+            return makeEntryArray(k, v);\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> makeObject() {\n+            return AbstractMapTest.this.makeObject().entrySet();\n+        }\n+\n+        @Override\n+        public Set<Map.Entry<K, V>> makeFullCollection() {\n+            return makeFullMap().entrySet();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            // Collection views don't support add operations.\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            // Entry set should only support remove if map does\n+            return AbstractMapTest.this.isRemoveSupported();\n+        }\n+\n+        public boolean isGetStructuralModify() {\n+            return AbstractMapTest.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMapTest.this.resetFull();\n+            setCollection(AbstractMapTest.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMapTest.this.resetEmpty();\n+            setCollection(AbstractMapTest.this.getMap().entrySet());\n+            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n+        }\n+\n+        public void testMapEntrySetIteratorEntry() {\n+            resetFull();\n+            Iterator<Map.Entry<K, V>> it = getCollection().iterator();\n+            int count = 0;\n+            while (it.hasNext()) {\n+                Map.Entry<K, V> entry = it.next();\n+                assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n+                assertEquals(true, AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n+                if (isGetStructuralModify() == false) {\n+                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());\n+                }\n+                count++;\n+            }\n+            assertEquals(getCollection().size(), count);\n+        }\n+\n+        public void testMapEntrySetIteratorEntrySetValue() {\n+            K key1 = getSampleKeys()[0];\n+            K key2 = (getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1]);\n+            V newValue1 = getNewSampleValues()[0];\n+            V newValue2 = (getNewSampleValues().length ==1 ? getNewSampleValues()[0] : getNewSampleValues()[1]);\n+\n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            verify();\n+\n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n+            verify();\n+\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            assertEquals(newValue1, entry1.getValue());\n+            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n+            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n+            verify();\n+\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+            assertEquals(newValue2, entry2.getValue());\n+            assertEquals(true, AbstractMapTest.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractMapTest.this.getMap().containsValue(newValue2));\n+            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));\n+            verify();\n+        }\n+\n+        public Map.Entry<K, V> getEntry(Iterator<Map.Entry<K, V>> itConfirmed, K key) {\n+            Map.Entry<K, V> entry = null;\n+            while (itConfirmed.hasNext()) {\n+                Map.Entry<K, V> temp = itConfirmed.next();\n+                if (temp.getKey() == null) {\n+                    if (key == null) {\n+                        entry = temp;\n+                        break;\n+                    }\n+                } else if (temp.getKey().equals(key)) {\n+                    entry = temp;\n+                    break;\n+                }\n+            }\n+            assertNotNull(\"No matching entry in map for key '\" + key + \"'\", entry);\n+            return entry;\n+        }\n+\n+        public void testMapEntrySetRemoveNonMapEntry() {\n+            if (isRemoveSupported() == false) return;\n+            resetFull();\n+            assertEquals(false, getCollection().remove(null));\n+            assertEquals(false, getCollection().remove(new Object()));\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractMapTest.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     * Bulk test {@link Map#keySet()}.  This method runs through all of\n+     * the tests in {@link AbstractSetTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractSetTest} instance for testing the map's key set\n+     */\n+    public BulkTest bulkTestMapKeySet() {\n+        return new TestMapKeySet();\n+    }\n+\n+    public class TestMapKeySet extends AbstractSetTest<K> {\n+        public TestMapKeySet() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return getSampleKeys();\n+        }\n+\n+        @Override\n+        public K[] getOtherElements() {\n+            return getOtherKeys();\n+        }\n+\n+        @Override\n+        public Set<K> makeObject() {\n+            return AbstractMapTest.this.makeObject().keySet();\n+        }\n+\n+        @Override\n+        public Set<K> makeFullCollection() {\n+            return AbstractMapTest.this.makeFullMap().keySet();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMapTest.this.resetEmpty();\n+            setCollection(AbstractMapTest.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMapTest.this.resetFull();\n+            setCollection(AbstractMapTest.this.getMap().keySet());\n+            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractMapTest.this.verify();\n+        }\n+    }\n+\n+    /**\n+     * Bulk test {@link Map#values()}.  This method runs through all of\n+     * the tests in {@link AbstractCollectionTest}.\n+     * After modification operations, {@link #verify()} is invoked to ensure\n+     * that the map and the other collection views are still valid.\n+     *\n+     * @return a {@link AbstractCollectionTest} instance for testing the map's\n+     *    values collection\n+     */\n+    public BulkTest bulkTestMapValues() {\n+        return new TestMapValues();\n+    }\n+\n+    public class TestMapValues extends AbstractCollectionTest<V> {\n+        public TestMapValues() {\n+            super(\"\");\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return getSampleValues();\n+        }\n+\n+        @Override\n+        public V[] getOtherElements() {\n+            return getOtherValues();\n+        }\n+\n+        @Override\n+        public Collection<V> makeObject() {\n+            return AbstractMapTest.this.makeObject().values();\n+        }\n+\n+        @Override\n+        public Collection<V> makeFullCollection() {\n+            return AbstractMapTest.this.makeFullMap().values();\n+        }\n+\n+        @Override\n+        public boolean isNullSupported() {\n+            return AbstractMapTest.this.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return AbstractMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean areEqualElementsDistinguishable() {\n+            // equal values are associated with different keys, so they are\n+            // distinguishable.\n+            return true;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public Collection<V> makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+\n+        @Override\n+        public void resetFull() {\n+            AbstractMapTest.this.resetFull();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void resetEmpty() {\n+            AbstractMapTest.this.resetEmpty();\n+            setCollection(map.values());\n+            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractMapTest.this.verify();\n+        }\n+\n+        // TODO: should test that a remove on the values collection view\n+        // removes the proper mapping and not just any mapping that may have\n+        // the value equal to the value returned from the values iterator.\n+    }\n+\n+\n+    /**\n+     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     * {@link #values} and {@link #confirmed} fields to empty.\n+     */\n+    public void resetEmpty() {\n+        this.map = makeObject();\n+        views();\n+        this.confirmed = makeConfirmedMap();\n+    }\n+\n+    /**\n+     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     * {@link #values} and {@link #confirmed} fields to full.\n+     */\n+    public void resetFull() {\n+        this.map = makeFullMap();\n+        views();\n+        this.confirmed = makeConfirmedMap();\n+        K[] k = getSampleKeys();\n+        V[] v = getSampleValues();\n+        for (int i = 0; i < k.length; i++) {\n+            confirmed.put(k[i], v[i]);\n+        }\n+    }\n+\n+    /**\n+     * Resets the collection view fields.\n+     */\n+    private void views() {\n+        this.keySet = getMap().keySet();\n+        this.values = getMap().values();\n+        this.entrySet = getMap().entrySet();\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * This method checks that the map is equal to the HashMap,\n+     * <I>and</I> that the map's collection views are still equal to\n+     * the HashMap's collection views.  An <Code>equals</Code> test\n+     * is done on the maps and their collection views; their size and\n+     * <Code>isEmpty</Code> results are compared; their hashCodes are\n+     * compared; and <Code>containsAll</Code> tests are run on the\n+     * collection views.\n+     */\n+    public void verify() {\n+        verifyMap();\n+        verifyEntrySet();\n+        verifyKeySet();\n+        verifyValues();\n+    }\n+\n+    public void verifyMap() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"Map should be same size as HashMap\", size, getMap().size());\n+        assertEquals(\"Map should be empty if HashMap is\", empty, getMap().isEmpty());\n+        assertEquals(\"hashCodes should be the same\", getConfirmed().hashCode(), getMap().hashCode());\n+        // this fails for LRUMap because confirmed.equals() somehow modifies\n+        // map, causing concurrent modification exceptions.\n+        //assertEquals(\"Map should still equal HashMap\", confirmed, map);\n+        // this works though and performs the same verification:\n+        assertTrue(\"Map should still equal HashMap\", getMap().equals(getConfirmed()));\n+        // TODO: this should really be reexamined to figure out why LRU map\n+        // behaves like it does (the equals shouldn't modify since all accesses\n+        // by the confirmed collection should be through an iterator, thus not\n+        // causing LRUMap to change).\n+    }\n+\n+    public void verifyEntrySet() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"entrySet should be same size as HashMap's\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     size, entrySet.size());\n+        assertEquals(\"entrySet should be empty if HashMap is\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     empty, entrySet.isEmpty());\n+        assertTrue(\"entrySet should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                   entrySet.containsAll(getConfirmed().entrySet()));\n+        assertEquals(\"entrySet hashCodes should be the same\" +\n+                     \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet(),\n+                     getConfirmed().entrySet().hashCode(), entrySet.hashCode());\n+        assertEquals(\"Map's entry set should still equal HashMap's\",\n+                     getConfirmed().entrySet(), entrySet);\n+    }\n+\n+    public void verifyKeySet() {\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"keySet should be same size as HashMap's\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     size, keySet.size());\n+        assertEquals(\"keySet should be empty if HashMap is\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     empty, keySet.isEmpty());\n+        assertTrue(\"keySet should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                   keySet.containsAll(getConfirmed().keySet()));\n+        assertEquals(\"keySet hashCodes should be the same\" +\n+                     \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet(),\n+                     getConfirmed().keySet().hashCode(), keySet.hashCode());\n+        assertEquals(\"Map's key set should still equal HashMap's\",\n+                getConfirmed().keySet(), keySet);\n+    }\n+\n+    public void verifyValues() {\n+        List<V> known = new ArrayList<V>(getConfirmed().values());\n+        List<V> test = new ArrayList<V>(values);\n+\n+        int size = getConfirmed().size();\n+        boolean empty = getConfirmed().isEmpty();\n+        assertEquals(\"values should be same size as HashMap's\" +\n+                     \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                     size, values.size());\n+        assertEquals(\"values should be empty if HashMap is\" +\n+                     \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                     empty, values.isEmpty());\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                    test.containsAll(known));\n+        assertTrue(\"values should contain all HashMap's elements\" +\n+                   \"\\nTest: \" + test + \"\\nReal: \" + known,\n+                   known.containsAll(test));\n+        // originally coded to use a HashBag, but now separate jar so...\n+        for (Iterator<V> it = known.iterator(); it.hasNext();) {\n+            boolean removed = test.remove(it.next());\n+            assertTrue(\"Map's values should still equal HashMap's\", removed);\n+        }\n+        assertTrue(\"Map's values should still equal HashMap's\", test.isEmpty());\n+    }\n+\n+    /**\n+     * Erases any leftover instance variables by setting them to null.\n+     */\n+    @Override\n+    public void tearDown() throws Exception {\n+        map = null;\n+        keySet = null;\n+        entrySet = null;\n+        values = null;\n+        confirmed = null;\n+    }\n+\n+    /**\n+     * Get the map.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getMap() {\n+        return map;\n+    }\n+\n+    /**\n+     * Get the confirmed.\n+     * @return Map<K,V>\n+     */\n+    public Map<K, V> getConfirmed() {\n+        return confirmed;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractOrderedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.comparators.NullComparator;\n+import org.apache.commons.collections.iterators.AbstractOrderedMapIteratorTest;\n+\n+/**\n+ * Abstract test class for {@link OrderedMap} methods and contracts.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractOrderedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractOrderedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract OrderedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        return (OrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * OrderedMap uses TreeMap as its known comparison.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new NullComparator<K>());\n+    }\n+\n+    /**\n+     * The only confirmed collection we have that is ordered is the sorted one.\n+     * Thus, sort the keys.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        List<K> list = new ArrayList<K>(Arrays.asList(super.getSampleKeys()));\n+        Collections.sort(list, new NullComparator<K>());\n+        return (K[]) list.toArray();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        try {\n+            ordered.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, ordered.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        try {\n+            ordered.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        ordered = getMap();\n+        K confirmedLast = null;\n+        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, ordered.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        assertEquals(null, ordered.nextKey(getOtherKeys()[0]));\n+        if (!isAllowNullKey()) {\n+            try {\n+                assertEquals(null, ordered.nextKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+\n+        resetFull();\n+        ordered = getMap();\n+        Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.nextKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                ordered.nextKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.nextKey(null));\n+        }\n+    }\n+\n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        assertEquals(null, ordered.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, ordered.previousKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, ordered.previousKey(null));\n+        }\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(confirmed.keySet());\n+        Collections.reverse(list);\n+        Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, ordered.previousKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                ordered.previousKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            if (isAllowNullKey() == false) {\n+                assertEquals(null, ordered.previousKey(null));\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestOrderedMapIterator() {\n+        return new InnerTestOrderedMapIterator();\n+    }\n+\n+    public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V> {\n+        public InnerTestOrderedMapIterator() {\n+            super(\"InnerTestOrderedMapIterator\");\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractOrderedMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean isGetStructuralModify() {\n+            return AbstractOrderedMapTest.this.isGetStructuralModify();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractOrderedMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public OrderedMapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractOrderedMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public OrderedMapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractOrderedMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public OrderedMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedMapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedMapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractOrderedMapTest.this.verify();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMap<K, V> getMap() {\n+        return (OrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/AbstractSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Abstract test class for {@link java.util.SortedMap} methods and contracts.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractSortedMapTest<K, V> extends AbstractMapTest<K, V> {\n+\n+    /**\n+     * JUnit constructor.\n+     *\n+     * @param testName  the test name\n+     */\n+    public AbstractSortedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Can't sort null keys.\n+     *\n+     * @return false\n+     */\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    /**\n+     * SortedMap uses TreeMap as its known comparison.\n+     *\n+     * @return a map that is known to be valid\n+     */\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testComparator() {\n+//        SortedMap<K, V> sm = makeFullMap();\n+        // no tests I can think of\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        return (SortedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    public void testFirstKey() {\n+        SortedMap<K, V> sm = makeFullMap();\n+        assertSame(sm.keySet().iterator().next(), sm.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        SortedMap<K, V> sm = makeFullMap();\n+        K obj = null;\n+        for (Iterator<K> it = sm.keySet().iterator(); it.hasNext();) {\n+            obj = it.next();\n+        }\n+        assertSame(obj, sm.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestHeadMap() {\n+        return new TestHeadMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new TestTailMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new TestSubMap<K, V>(this);\n+    }\n+\n+    public static abstract class TestViewMap <K, V> extends AbstractSortedMapTest<K, V> {\n+        protected final AbstractMapTest<K, V> main;\n+        protected final List<K> subSortedKeys = new ArrayList<K>();\n+        protected final List<V> subSortedValues = new ArrayList<V>();\n+        protected final List<V> subSortedNewValues = new ArrayList<V>();\n+\n+        public TestViewMap(String name, AbstractMapTest<K, V> main) {\n+            super(name);\n+            this.main = main;\n+        }\n+        @Override\n+        public void resetEmpty() {\n+            // needed to init verify correctly\n+            main.resetEmpty();\n+            super.resetEmpty();\n+        }\n+        @Override\n+        public void resetFull() {\n+            // needed to init verify correctly\n+            main.resetFull();\n+            super.resetFull();\n+        }\n+        @Override\n+        public void verify() {\n+            // cross verify changes on view with changes on main map\n+            super.verify();\n+            main.verify();\n+        }\n+        @Override\n+        public BulkTest bulkTestHeadMap() {\n+            return null;  // block infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestTailMap() {\n+            return null;  // block infinite recursion\n+        }\n+        @Override\n+        public BulkTest bulkTestSubMap() {\n+            return null;  // block infinite recursion\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public K[] getSampleKeys() {\n+            return (K[]) subSortedKeys.toArray();\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getSampleValues() {\n+            return (V[]) subSortedValues.toArray();\n+        }\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public V[] getNewSampleValues() {\n+            return (V[]) subSortedNewValues.toArray();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+//        public void testSimpleSerialization() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testSimpleSerialization();\n+//        }\n+//        public void testSerializeDeserializeThenCompare() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testSerializeDeserializeThenCompare();\n+//        }\n+//        public void testEmptyMapCompatibility() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testEmptyMapCompatibility();\n+//        }\n+//        public void testFullMapCompatibility() throws Exception {\n+//            if (main.isSubMapViewsSerializable() == false) return;\n+//            super.testFullMapCompatibility();\n+//        }\n+    }\n+\n+    public static class TestHeadMap<K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 6;\n+        final K toKey;\n+\n+        public TestHeadMap(AbstractMapTest<K, V> main) {\n+            super(\"SortedMap.HeadMap\", main);\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.toKey = this.subSortedKeys.get(SUBSIZE);\n+            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n+            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n+        }\n+        public void testHeadMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                getMap().put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".HeadMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj\");\n+//        }\n+    }\n+\n+    public static class TestTailMap <K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 6;\n+        final K fromKey;\n+        final K invalidKey;\n+\n+        public TestTailMap(AbstractMapTest<K, V> main) {\n+            super(\"SortedMap.TailMap\", main);\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n+            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n+            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n+        }\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n+        }\n+        public void testTailMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                getMap().put(invalidKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".TailMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj\");\n+//        }\n+    }\n+\n+    public static class TestSubMap<K, V> extends TestViewMap<K, V> {\n+        static final int SUBSIZE = 3;\n+        final K fromKey;\n+        final K toKey;\n+\n+        public TestSubMap(AbstractMapTest<K, V> main) {\n+            super(\"SortedMap.SubMap\", main);\n+            Map<K, V> sm = main.makeFullMap();\n+            for (Iterator<Map.Entry<K, V>> it = sm.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry<K, V> entry = it.next();\n+                this.subSortedKeys.add(entry.getKey());\n+                this.subSortedValues.add(entry.getValue());\n+            }\n+            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n+            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n+\n+            this.subSortedKeys.subList(0, SUBSIZE).clear();\n+            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n+\n+            this.subSortedValues.subList(0, SUBSIZE).clear();\n+            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n+\n+            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n+                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n+        }\n+\n+        @Override\n+        public SortedMap<K, V> makeObject() {\n+            // done this way so toKey is correctly set in the returned map\n+            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n+        }\n+        @Override\n+        public SortedMap<K, V> makeFullMap() {\n+            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n+        }\n+        public void testSubMapOutOfRange() {\n+            if (isPutAddSupported() == false) return;\n+            resetEmpty();\n+            try {\n+                getMap().put(toKey, subSortedValues.get(0));\n+                fail();\n+            } catch (IllegalArgumentException ex) {}\n+            verify();\n+        }\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion() + \".SubMapView\";\n+        }\n+\n+//        public void testCreate() throws Exception {\n+//            Map map = makeEmptyMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj\");\n+//            map = makeFullMap();\n+//            writeExternalFormToDisk(\n+//                (java.io.Serializable) map,\n+//                \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj\");\n+//        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getMap() {\n+        return (SortedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedMap<K, V> getConfirmed() {\n+        return (SortedMap<K, V>) super.getConfirmed();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/CaseInsensitiveMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Tests for the {@link CaseInsensitiveMap} implementation.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Commons-Collections team\n+ */\n+public class CaseInsensitiveMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public CaseInsensitiveMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(CaseInsensitiveMapTest.class);\n+    }\n+\n+    @Override\n+    public CaseInsensitiveMap<K, V> makeObject() {\n+        return new CaseInsensitiveMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-------------------------------------------------------------------------\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testCaseInsensitive() {\n+        Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        assertEquals(\"One\", map.get(\"one\"));\n+        assertEquals(\"One\", map.get(\"oNe\"));\n+        map.put((K) \"two\", (V) \"Three\");\n+        assertEquals(\"Three\", map.get(\"Two\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        Map<K, V> map = makeObject();\n+        map.put((K) \"One\", (V) \"One\");\n+        map.put((K) \"Two\", (V) \"Two\");\n+        map.put(null, (V) \"Three\");\n+        assertEquals(\"Three\", map.get(null));\n+        map.put(null, (V) \"Four\");\n+        assertEquals(\"Four\", map.get(null));\n+        Set<K> keys = map.keySet();\n+        assertTrue(keys.contains(\"one\"));\n+        assertTrue(keys.contains(\"two\"));\n+        assertTrue(keys.contains(null));\n+        assertEquals(3, keys.size());\n+    }\n+\n+    public void testPutAll() {\n+        Map<Object, String> map = new HashMap<Object, String>();\n+        map.put(\"One\", \"One\");\n+        map.put(\"Two\", \"Two\");\n+        map.put(\"one\", \"Three\");\n+        map.put(null, \"Four\");\n+        map.put(new Integer(20), \"Five\");\n+        Map<Object, String> caseInsensitiveMap = new CaseInsensitiveMap<Object, String>(map);\n+        assertEquals(4, caseInsensitiveMap.size()); // ones collapsed\n+        Set<Object> keys = caseInsensitiveMap.keySet();\n+        assertTrue(keys.contains(\"one\"));\n+        assertTrue(keys.contains(\"two\"));\n+        assertTrue(keys.contains(null));\n+        assertTrue(keys.contains(Integer.toString(20)));\n+        assertEquals(4, keys.size());\n+        assertTrue(!caseInsensitiveMap.containsValue(\"One\")\n+            || !caseInsensitiveMap.containsValue(\"Three\")); // ones collaped\n+        assertEquals(\"Four\", caseInsensitiveMap.get(null));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        CaseInsensitiveMap<K, V> map = new CaseInsensitiveMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        CaseInsensitiveMap<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    /*\n+    public void testCreate() throws Exception {\n+        resetEmpty();\n+        writeExternalFormToDisk((java.io.Serializable) map, \"/home/phil/jakarta-commons/collections/data/test/CaseInsensitiveMap.emptyCollection.version3.obj\");\n+        resetFull();\n+        writeExternalFormToDisk((java.io.Serializable) map, \"/home/phil/jakarta-commons/collections/data/test/CaseInsensitiveMap.fullCollection.version3.obj\");\n+    }\n+     */\n+\n+    // COLLECTIONS-294\n+    public void testLocaleIndependence() {\n+        Locale orig = Locale.getDefault();\n+\n+        Locale[] locales = { Locale.ENGLISH, new Locale(\"tr\", \"\", \"\"), Locale.getDefault() };\n+\n+        String[][] data = { \n+            { \"i\", \"I\" },\n+            { \"\\u03C2\", \"\\u03C3\" },\n+            { \"\\u03A3\", \"\\u03C2\" },\n+            { \"\\u03A3\", \"\\u03C3\" },\n+        };\n+\n+        try {\n+            for (int i = 0; i < locales.length; i++) {\n+                Locale.setDefault(locales[i]);\n+                for (int j = 0; j < data.length; j++) {\n+                    assertTrue(\"Test data corrupt: \" + j, data[j][0].equalsIgnoreCase(data[j][1]));\n+                    CaseInsensitiveMap<String, String> map = new CaseInsensitiveMap<String, String>();\n+                    map.put(data[j][0], \"value\");\n+                    assertEquals(Locale.getDefault() + \": \" + j, \"value\", map.get(data[j][1]));\n+                }\n+            }\n+        } finally {\n+            Locale.setDefault(orig);\n+        }\n+    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final CaseInsensitiveMap<String,String> map = new CaseInsensitiveMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/CompositeMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Assert;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Collection;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link CompositeMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Brian McCallister\n+ */\n+public class CompositeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+    /** used as a flag in MapMutator tests */\n+    private boolean pass = false;\n+    \n+    public CompositeMapTest(String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        this.pass = false;\n+    }\n+    \n+    @Override\n+    public CompositeMap<K, V> makeObject() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>();\n+        map.addComposited(new HashMap<K, V>());\n+        map.setMutator( new EmptyMapMutator<K, V>() );\n+        return map;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildOne() {\n+        HashMap<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"1\", (V) \"one\");\n+        map.put((K) \"2\", (V) \"two\");\n+        return map;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildTwo() {\n+        HashMap<K, V> map = new HashMap<K, V>();\n+        map.put((K) \"3\", (V) \"three\");\n+        map.put((K) \"4\", (V) \"four\");\n+        return map;\n+    }\n+    \n+    public void testGet() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        Assert.assertEquals(\"one\", map.get(\"1\"));\n+        Assert.assertEquals(\"four\", map.get(\"4\"));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddComposited() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        try {\n+            map.addComposited(three);\n+            fail(\"Expecting IllegalArgumentException.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveComposited() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(three);\n+        assertFalse(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(buildOne());\n+        assertFalse(map.containsKey(\"2\"));\n+        \n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFromUnderlying() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        three.remove(\"5\");\n+        assertFalse(map.containsKey(\"5\"));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveFromComposited() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo());\n+        HashMap<K, V> three = new HashMap<K, V>();\n+        three.put((K) \"5\", (V) \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        map.remove(\"5\");\n+        assertFalse(three.containsKey(\"5\"));\n+    }\n+    \n+    public void testResolveCollision() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+\n+            public void resolveCollision(CompositeMap<K, V> composite,\n+            Map<K, V> existing,\n+            Map<K, V> added,\n+            Collection<K> intersect) {\n+                pass = true;\n+            }\n+            \n+            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n+                V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.addComposited(buildOne());\n+        assertTrue(pass);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+            public void resolveCollision(CompositeMap<K, V> composite,\n+            Map<K, V> existing,\n+            Map<K, V> added,\n+            Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n+                V value) {\n+                pass = true;\n+                return (V) \"foo\";\n+            }\n+            \n+            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.put((K) \"willy\", (V) \"wonka\");\n+        assertTrue(pass);\n+    }\n+    \n+    public void testPutAll() {\n+        CompositeMap<K, V> map = new CompositeMap<K, V>(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator<K, V>() {\n+            private static final long serialVersionUID = 1L;\n+            public void resolveCollision(CompositeMap<K, V> composite,\n+            Map<K, V> existing,\n+            Map<K, V> added,\n+            Collection<K> intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, \n+                V value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited, Map<? extends K, ? extends V> t) {\n+                pass = true;\n+            }\n+        });\n+        \n+        map.putAll(null);\n+        assertTrue(pass);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/CompositeMap.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/CompositeMap.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/DefaultedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FactoryUtils;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.functors.ConstantFactory;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link DefaultedMap} implementation.\n+ *\n+ * @since Commons Collections 3.2\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class DefaultedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    protected final Factory<V> nullFactory = FactoryUtils.<V>nullFactory();\n+\n+    public DefaultedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return DefaultedMap.defaultedMap(new HashMap<K, V>(), nullFactory);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet() {\n+        Map<K, V> map = new DefaultedMap<K, V>((V) \"NULL\");\n+\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet2() {\n+        HashMap<K, V> base = new HashMap<K, V>();\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, (V) \"NULL\");\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet3() {\n+        HashMap<K, V> base = new HashMap<K, V>();\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, ConstantFactory.constantFactory((V) \"NULL\"));\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapGet4() {\n+        HashMap<K, V> base = new HashMap<K, V>();\n+        Map<K, V> map = DefaultedMap.defaultedMap(base, new Transformer<K, V>() {\n+            public V transform(K input) {\n+                if (input instanceof String) {\n+                    return (V) \"NULL\";\n+                }\n+                return (V) \"NULL_OBJECT\";\n+            }\n+        });\n+\n+        assertEquals(0, map.size());\n+        assertEquals(0, base.size());\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+        assertEquals(\"NULL_OBJECT\", map.get(new Integer(0)));\n+\n+        map.put((K) \"Key\", (V) \"Value\");\n+        assertEquals(1, map.size());\n+        assertEquals(1, base.size());\n+        assertEquals(true, map.containsKey(\"Key\"));\n+        assertEquals(\"Value\", map.get(\"Key\"));\n+        assertEquals(false, map.containsKey(\"NotInMap\"));\n+        assertEquals(\"NULL\", map.get(\"NotInMap\"));\n+        assertEquals(\"NULL_OBJECT\", map.get(new Integer(0)));\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"c:/commons/collections/data/test/DefaultedMap.emptyCollection.version3.2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"c:/commons/collections/data/test/DefaultedMap.fullCollection.version3.2.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/FixedSizeMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the {@link FixedSizeMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FixedSizeMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public FixedSizeMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return FixedSizeMap.fixedSizeMap(new HashMap<K, V>());\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        Map<K, V> map = new HashMap<K, V>();\n+        addSampleMappings(map);\n+        return FixedSizeMap.fixedSizeMap(map);\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/FixedSizeSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the {@link FixedSizeSortedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class FixedSizeSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    public FixedSizeSortedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(FixedSizeSortedMapTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return FixedSizeSortedMap.fixedSizeSortedMap(new TreeMap<K, V>());\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        SortedMap<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+        return FixedSizeSortedMap.fixedSizeSortedMap(map);\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/Flat3MapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.AbstractMapIteratorTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class Flat3MapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final Integer THREE = new Integer(3);\n+    private static final String TEN = \"10\";\n+    private static final String TWENTY = \"20\";\n+    private static final String THIRTY = \"30\";\n+\n+    public Flat3MapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(Flat3MapTest.class);\n+    }\n+\n+    @Override\n+    public Flat3Map<K, V> makeObject() {\n+        return new Flat3Map<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals1() {\n+        Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"b\", (V) \"testA\");\n+        assertEquals(false, map1.equals(map2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEquals2() {\n+        Flat3Map<K, V> map1 = makeObject();\n+        map1.put((K) \"a\", (V) \"testA\");\n+        map1.put((K) \"b\", (V) \"testB\");\n+        Flat3Map<K, V> map2 = makeObject();\n+        map2.put((K) \"a\", (V) \"testB\");\n+        map2.put((K) \"c\", (V) \"testA\");\n+        assertEquals(false, map1.equals(map2));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone2() {\n+        Flat3Map<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertSame(TEN, map.get(ONE));\n+        assertSame(TWENTY, map.get(TWO));\n+\n+        // clone works (size = 2)\n+        Flat3Map<K, V> cloned = map.clone();\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+\n+        // change original doesn't change clone\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+        assertEquals(4, map.size());\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone4() {\n+        Flat3Map<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n+        // clone works (size = 4)\n+        Flat3Map<K, V> cloned = map.clone();\n+        assertEquals(4, map.size());\n+        assertEquals(4, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertEquals(true, cloned.containsKey(TEN));\n+        assertEquals(true, cloned.containsKey(TWENTY));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+        assertSame(ONE, cloned.get(TEN));\n+        assertSame(TWO, cloned.get(TWENTY));\n+\n+        // change original doesn't change clone\n+        map.clear();\n+        assertEquals(0, map.size());\n+        assertEquals(4, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsKey(TWO));\n+        assertEquals(true, cloned.containsKey(TEN));\n+        assertEquals(true, cloned.containsKey(TWENTY));\n+        assertSame(TEN, cloned.get(ONE));\n+        assertSame(TWENTY, cloned.get(TWO));\n+        assertSame(ONE, cloned.get(TEN));\n+        assertSame(TWO, cloned.get(TWENTY));\n+    }\n+\n+    public void testSerialisation0() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        byte[] bytes = bout.toByteArray();\n+        out.close();\n+        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        ObjectInputStream in = new ObjectInputStream(bin);\n+        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(0, map.size());\n+        assertEquals(0, ser.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialisation2() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        byte[] bytes = bout.toByteArray();\n+        out.close();\n+        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        ObjectInputStream in = new ObjectInputStream(bin);\n+        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(2, map.size());\n+        assertEquals(2, ser.size());\n+        assertEquals(true, ser.containsKey(ONE));\n+        assertEquals(true, ser.containsKey(TWO));\n+        assertEquals(TEN, ser.get(ONE));\n+        assertEquals(TWENTY, ser.get(TWO));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSerialisation4() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) TEN, (V) ONE);\n+        map.put((K) TWENTY, (V) TWO);\n+\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(bout);\n+        out.writeObject(map);\n+        byte[] bytes = bout.toByteArray();\n+        out.close();\n+        ByteArrayInputStream bin = new ByteArrayInputStream(bytes);\n+        ObjectInputStream in = new ObjectInputStream(bin);\n+        Flat3Map<?, ?> ser = (Flat3Map<?, ?>) in.readObject();\n+        in.close();\n+        assertEquals(4, map.size());\n+        assertEquals(4, ser.size());\n+        assertEquals(true, ser.containsKey(ONE));\n+        assertEquals(true, ser.containsKey(TWO));\n+        assertEquals(true, ser.containsKey(TEN));\n+        assertEquals(true, ser.containsKey(TWENTY));\n+        assertEquals(TEN, ser.get(ONE));\n+        assertEquals(TWENTY, ser.get(TWO));\n+        assertEquals(ONE, ser.get(TEN));\n+        assertEquals(TWO, ser.get(TWENTY));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue1() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(\"NewValue\", map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue2() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(\"NewValue\", map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntryIteratorSetValue3() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        it.next();\n+        it.next();\n+        Map.Entry<K, V> entry = it.next();\n+        entry.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(\"NewValue\", map.get(THREE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue1() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(\"NewValue\", map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue2() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(\"NewValue\", map.get(TWO));\n+        assertEquals(THIRTY, map.get(THREE));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapIteratorSetValue3() throws Exception {\n+        Flat3Map<K, V> map = makeObject();\n+        map.put((K) ONE, (V) TEN);\n+        map.put((K) TWO, (V) TWENTY);\n+        map.put((K) THREE, (V) THIRTY);\n+\n+        MapIterator<K, V> it = map.mapIterator();\n+        it.next();\n+        it.next();\n+        it.next();\n+        it.setValue((V) \"NewValue\");\n+        assertEquals(3, map.size());\n+        assertEquals(true, map.containsKey(ONE));\n+        assertEquals(true, map.containsKey(TWO));\n+        assertEquals(true, map.containsKey(THREE));\n+        assertEquals(TEN, map.get(ONE));\n+        assertEquals(TWENTY, map.get(TWO));\n+        assertEquals(\"NewValue\", map.get(THREE));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public BulkTest bulkTestMapIterator() {\n+        return new TestFlatMapIterator();\n+    }\n+\n+    public class TestFlatMapIterator extends AbstractMapIteratorTest<K, V> {\n+        public TestFlatMapIterator() {\n+            super(\"TestFlatMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return Flat3MapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return Flat3MapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return Flat3MapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return Flat3MapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return Flat3MapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public IterableMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return Flat3MapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return Flat3MapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            Flat3MapTest.this.verify();\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/Flat3Map.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/Flat3Map.fullCollection.version3.1.obj\");\n+//    }\n+\n+    public void testCollections261() {\n+        Flat3Map<Integer, Integer> m = new Flat3Map<Integer, Integer>();\n+        m.put( new Integer(1), new Integer(1) );\n+        m.put( new Integer(0), new Integer(0) );\n+        assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n+        assertEquals( new Integer(0), m.remove( new Integer(0) ) ); \n+\n+        m.put( new Integer(2), new Integer(2) );\n+        m.put( new Integer(1), new Integer(1) );\n+        m.put( new Integer(0), new Integer(0) );\n+        assertEquals( new Integer(2), m.remove( new Integer(2) ) ); \n+        assertEquals( new Integer(1), m.remove( new Integer(1) ) ); \n+        assertEquals( new Integer(0), m.remove( new Integer(0) ) ); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/HashedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class HashedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public HashedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(HashedMapTest.class);\n+    }\n+\n+    @Override\n+    public HashedMap<K, V> makeObject() {\n+        return new HashedMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        HashedMap<K, V> map = new HashedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        HashedMap<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    public void testInternalState() {\n+        HashedMap<K, V> map = new HashedMap<K, V>(42, 0.75f);\n+        assertEquals(0.75f, map.loadFactor, 0.1f);\n+        assertEquals(0, map.size);\n+        assertEquals(64, map.data.length);\n+        assertEquals(48, map.threshold);\n+        assertEquals(0, map.modCount);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final HashedMap<String,String> map = new HashedMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/IdentityMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import org.apache.commons.collections.AbstractObjectTest;\n+import org.apache.commons.collections.IterableMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class IdentityMapTest<K, V> extends AbstractObjectTest {\n+\n+    private static final Integer I1A = new Integer(1);\n+    private static final Integer I1B = new Integer(1);\n+    private static final Integer I2A = new Integer(2);\n+    private static final Integer I2B = new Integer(2);\n+\n+    public IdentityMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(IdentityMapTest.class);\n+//        return BulkTest.makeSuite(TestIdentityMap.class);  // causes race condition!\n+    }\n+\n+    @Override\n+    public IdentityMap<K, V> makeObject() {\n+        return new IdentityMap<K, V>();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasics() {\n+        IterableMap<K, V> map = new IdentityMap<K, V>();\n+        assertEquals(0, map.size());\n+\n+        map.put((K) I1A, (V) I2A);\n+        assertEquals(1, map.size());\n+        assertSame(I2A, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(true, map.containsValue(I2A));\n+        assertEquals(false, map.containsValue(I2B));\n+\n+        map.put((K) I1A, (V) I2B);\n+        assertEquals(1, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+\n+        map.put((K) I1B, (V) I2B);\n+        assertEquals(2, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(I2B, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(true, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashEntry() {\n+        IterableMap<K, V> map = new IdentityMap<K, V>();\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry2 = it.next();\n+        Map.Entry<K, V> entry3 = it.next();\n+\n+        assertEquals(true, entry1.equals(entry2));\n+        assertEquals(true, entry2.equals(entry1));\n+        assertEquals(false, entry1.equals(entry3));\n+    }\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in SVN.\n+     */\n+    public void testEmptyMapCompatibility() throws IOException, ClassNotFoundException {\n+        // test to make sure the canonical form has been preserved\n+        Map<K, V> map = makeObject();\n+        if (map instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertEquals(\"Map is empty\", 0, map2.size());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        IdentityMap<K, V> map = new IdentityMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        Map map = new IdentityMap();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.emptyCollection.version3.obj\");\n+//        map = new IdentityMap();\n+//        map.put(I1A, I2A);\n+//        map.put(I1B, I2A);\n+//        map.put(I2A, I2B);\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/IdentityMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final IdentityMap<String,String> map = new IdentityMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/LRUMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.ResettableIterator;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class LRUMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public LRUMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(LRUMapTest.class);\n+    }\n+\n+    @Override\n+    public LRUMap<K, V> makeObject() {\n+        return new LRUMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> makeFullMap() {\n+        return (LRUMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public boolean isGetStructuralModify() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testLRU() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> kit;\n+        Iterator<V> vit;\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(2);\n+        assertEquals(0, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+\n+        map.put(keys[0], values[0]);\n+        assertEquals(1, map.size());\n+        assertEquals(false, map.isFull());\n+        assertEquals(2, map.maxSize());\n+\n+        map.put(keys[1], values[1]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        map.put(keys[2], values[2]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        map.put(keys[2], values[0]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[2], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[1], vit.next());\n+        assertSame(values[0], vit.next());\n+\n+        map.put(keys[1], values[3]);\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(2, map.maxSize());\n+        kit = map.keySet().iterator();\n+        assertSame(keys[2], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(ordered.keySet());\n+        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testAccessOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> kit = null;\n+        Iterator<V> vit = null;\n+\n+        resetEmpty();\n+        map.put(keys[0], values[0]);\n+        map.put(keys[1], values[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[1], vit.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[0], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        // change to order\n+        map.put(keys[0], values[3]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+\n+        // change to order\n+        map.get(keys[1]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[0], kit.next());\n+        assertSame(keys[1], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[3], vit.next());\n+        assertSame(values[2], vit.next());\n+\n+        // change to order\n+        map.get(keys[0]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+\n+        // no change to order\n+        map.get(keys[0]);\n+        kit = map.keySet().iterator();\n+        assertSame(keys[1], kit.next());\n+        assertSame(keys[0], kit.next());\n+        vit = map.values().iterator();\n+        assertSame(values[2], vit.next());\n+        assertSame(values[3], vit.next());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        LRUMap<K, V> map = new LRUMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRU() {\n+        MockLRUMapSubclass<K, String> map = new MockLRUMapSubclass<K, String>(2);\n+        assertNull(map.entry);\n+        map.put((K) \"A\", \"a\");\n+        assertNull(map.entry);\n+        map.put((K) \"B\", \"b\");\n+        assertNull(map.entry);\n+        map.put((K) \"C\", \"c\");  // removes oldest, which is A=a\n+        assertNotNull(map.entry);\n+        assertEquals(\"A\", map.key);\n+        assertEquals(\"a\", map.value);\n+        assertEquals(\"C\", map.entry.getKey());  // entry is reused\n+        assertEquals(\"c\", map.entry.getValue());  // entry is reused\n+        assertEquals(false, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclass<K, V> extends LRUMap<K, V> {\n+        LinkEntry<K, V> entry;\n+        K key;\n+        V value;\n+\n+        MockLRUMapSubclass(int size) {\n+            super(size);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+            this.entry = entry;\n+            this.key = entry.getKey();\n+            this.value = entry.getValue();\n+            return true;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUBlocksRemove() {\n+        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, false);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUBlocksRemoveScan() {\n+        MockLRUMapSubclassBlocksRemove<K, V> map = new MockLRUMapSubclassBlocksRemove<K, V>(2, true);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a, but this is blocked\n+        assertEquals(3, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(true, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassBlocksRemove<K, V> extends LRUMap<K, V> {\n+        MockLRUMapSubclassBlocksRemove(int size, boolean scanUntilRemove) {\n+            super(size, scanUntilRemove);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemoveLRUFirstBlocksRemove() {\n+        MockLRUMapSubclassFirstBlocksRemove<K, V> map = new MockLRUMapSubclassFirstBlocksRemove<K, V>(2);\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"a\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"b\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"C\", (V) \"c\");  // should remove oldest, which is A=a  but this is blocked - so advance to B=b\n+        assertEquals(2, map.size());\n+        assertEquals(2, map.maxSize());\n+        assertEquals(true, map.containsKey(\"A\"));\n+        assertEquals(false, map.containsKey(\"B\"));\n+        assertEquals(true, map.containsKey(\"C\"));\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MockLRUMapSubclassFirstBlocksRemove<K, V> extends LRUMap<K, V> {\n+        MockLRUMapSubclassFirstBlocksRemove(int size) {\n+            super(size, true);\n+        }\n+\n+        @Override\n+        protected boolean removeLRU(LinkEntry<K, V> entry) {\n+            if (\"a\".equals(entry.getValue())) {\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    static class SingleHashCode {\n+        private final String code;\n+        SingleHashCode(String code) {\n+            this.code = code;\n+        }\n+        @Override\n+        public int hashCode() {\n+            // always return the same hashcode\n+            // that way, it will end up in the same bucket\n+            return 12;\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SingleHashCode:\" + code;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_Buckets() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        SingleHashCode one = new SingleHashCode(\"1\");\n+        SingleHashCode two = new SingleHashCode(\"2\");\n+        SingleHashCode three = new SingleHashCode(\"3\");\n+        SingleHashCode four = new SingleHashCode(\"4\");\n+        SingleHashCode five = new SingleHashCode(\"5\");\n+        SingleHashCode six = new SingleHashCode(\"6\");\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        int hashIndex = map.hashIndex(map.hash(one), 4);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(one, map.header.after.key);  // LRU\n+        assertEquals(two, map.header.after.after.key);\n+        assertEquals(three, map.header.after.after.after.key);  // MRU\n+        assertEquals(three, map.data[hashIndex].key);\n+        assertEquals(two, map.data[hashIndex].next.key);\n+        assertEquals(one, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) four, (V) \"D\");  // reuses last in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(two, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(four, map.header.after.after.after.key);  // MRU\n+        assertEquals(four, map.data[hashIndex].key);\n+        assertEquals(three, map.data[hashIndex].next.key);\n+        assertEquals(two, map.data[hashIndex].next.next.key);\n+\n+        map.get(three);\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(two, map.header.after.key);  // LRU\n+        assertEquals(four, map.header.after.after.key);\n+        assertEquals(three, map.header.after.after.after.key);  // MRU\n+        assertEquals(four, map.data[hashIndex].key);\n+        assertEquals(three, map.data[hashIndex].next.key);\n+        assertEquals(two, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) five, (V) \"E\");  // reuses last in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(four, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(five, map.header.after.after.after.key);  // MRU\n+        assertEquals(five, map.data[hashIndex].key);\n+        assertEquals(four, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+\n+        map.get(three);\n+        map.get(five);\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(four, map.header.after.key);  // LRU\n+        assertEquals(three, map.header.after.after.key);\n+        assertEquals(five, map.header.after.after.after.key);  // MRU\n+        assertEquals(five, map.data[hashIndex].key);\n+        assertEquals(four, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+\n+        map.put((K) six, (V) \"F\");  // reuses middle in next list\n+\n+        assertEquals(4, map.data.length);\n+        assertEquals(3, map.size);\n+        assertEquals(null, map.header.next);\n+        assertEquals(three, map.header.after.key);  // LRU\n+        assertEquals(five, map.header.after.after.key);\n+        assertEquals(six, map.header.after.after.after.key);  // MRU\n+        assertEquals(six, map.data[hashIndex].key);\n+        assertEquals(five, map.data[hashIndex].next.key);\n+        assertEquals(three, map.data[hashIndex].next.next.key);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInternalState_getEntry_int() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        SingleHashCode one = new SingleHashCode(\"1\");\n+        SingleHashCode two = new SingleHashCode(\"2\");\n+        SingleHashCode three = new SingleHashCode(\"3\");\n+\n+        LRUMap<K, V> map = new LRUMap<K, V>(3, 1.0f);\n+        map.put((K) one, (V) \"A\");\n+        map.put((K) two, (V) \"B\");\n+        map.put((K) three, (V) \"C\");\n+\n+        assertEquals(one, map.getEntry(0).key);\n+        assertEquals(two, map.getEntry(1).key);\n+        assertEquals(three, map.getEntry(2).key);\n+        try {\n+            map.getEntry(-1);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            map.getEntry(3);\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {}\n+    }\n+    \n+    public void testSynchronizedRemoveFromMapIterator() throws InterruptedException {\n+\n+        final LRUMap<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (MapIterator<Object, Thread> iter = map.mapIterator(); iter.hasNext();) {\n+                                iter.next();\n+                                if (iter.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromEntrySet() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator<Map.Entry<Object, Thread>> iter = map.entrySet().iterator(); iter.hasNext();) {\n+                                Map.Entry<Object, Thread> entry = iter.next();\n+                                if (entry.getValue() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromKeySet() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator<Object> iter = map.keySet().iterator(); iter.hasNext();) {\n+                                String name = (String) iter.next();\n+                                if (name.substring(0, name.indexOf('[')).equals(getName())) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+    \n+    public void testSynchronizedRemoveFromValues() throws InterruptedException {\n+\n+        final Map<Object, Thread> map = new LRUMap<Object, Thread>(10000);\n+        \n+        final Map<Throwable, String> exceptions = new HashMap<Throwable, String>();\n+        final ThreadGroup tg = new ThreadGroup(getName()) {\n+            @Override\n+            public void uncaughtException(Thread t, Throwable e) {\n+                exceptions.put(e, t.getName());\n+                super.uncaughtException(t, e);\n+            }\n+        };\n+\n+        final int[] counter = new int[1];\n+        counter[0] = 0;\n+        final Thread[] threads = new Thread[50];\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i] = new Thread(tg, \"JUnit Thread \" + i) {\n+\n+                @Override\n+                public void run() {\n+                    int i = 0;\n+                    try {\n+                        synchronized (this) {\n+                            notifyAll();\n+                            wait();\n+                        }\n+                        Thread thread = Thread.currentThread();\n+                        while (i < 1000  && !interrupted()) {\n+                            synchronized (map) {\n+                                map.put(thread.getName() + \"[\" + ++i + \"]\", thread);\n+                            }\n+                        }\n+                        synchronized (map) {\n+                            for (Iterator<Thread> iter = map.values().iterator(); iter.hasNext();) {\n+                                if (iter.next() == this) {\n+                                    iter.remove();\n+                                }\n+                            }\n+                        }\n+                    } catch (InterruptedException e) {\n+                        fail(\"Unexpected InterruptedException\");\n+                    }\n+                    if (i > 0) {\n+                        synchronized (counter) {\n+                            counter[0]++;\n+                        }\n+                    }\n+                }\n+\n+            };\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].start();\n+                threads[i].wait();\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].notifyAll();\n+            }\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            threads[i].interrupt();\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            synchronized (threads[i]) {\n+                threads[i].join();\n+            }\n+        }\n+\n+        assertEquals(\"Exceptions have been thrown: \" + exceptions, 0, exceptions.size());\n+        assertTrue(\"Each thread should have put at least 1 element into the map, but only \" \n+                + counter[0] + \" did succeed\", counter[0] >= threads.length);\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LRUMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LRUMap<K, V> getMap() {\n+        return (LRUMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/LazyMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import static org.apache.commons.collections.map.LazyMap.lazyMap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FactoryUtils;\n+import org.apache.commons.collections.Transformer;\n+import org.junit.Test;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link LazyMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class LazyMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n+\n+    public LazyMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public LazyMap<K,V> makeObject() {\n+        return lazyMap(new HashMap<K,V>(), FactoryUtils.<V>nullFactory());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testMapGet() {\n+        //TODO eliminate need for this via superclass - see svn history.\n+    }\n+\n+    @Test\n+    public void mapGetWithFactory() {\n+        Map<Integer, Number> map = lazyMap(new HashMap<Integer,Number>(), oneFactory);\n+        assertEquals(0, map.size());\n+        Number i1 = map.get(\"Five\");\n+        assertEquals(1, i1);\n+        assertEquals(1, map.size());\n+        Number i2 = map.get(new String(new char[] {'F','i','v','e'}));\n+        assertEquals(1, i2);\n+        assertEquals(1, map.size());\n+        assertSame(i1, i2);\n+\n+        map = lazyMap(new HashMap<Integer,Number>(), FactoryUtils.<Long>nullFactory());\n+        Object o = map.get(\"Five\");\n+        assertEquals(null,o);\n+        assertEquals(1, map.size());\n+    }\n+\n+    @Test\n+    public void mapGetWithTransformer() {\n+        Transformer<Number, Integer> intConverter = new Transformer<Number, Integer>(){\n+            public Integer transform(Number input) {\n+                return input.intValue();\n+            }\n+        };\n+        Map<Long, Number> map = lazyMap(new HashMap<Long,Number>(), intConverter );\n+        assertEquals(0, map.size());\n+        Number i1 = map.get(123L);\n+        assertEquals(123, i1);\n+        assertEquals(1, map.size());\n+    }\n+\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazyMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazyMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/LazySortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import static org.apache.commons.collections.map.LazySortedMap.lazySortedMap;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.Factory;\n+import org.apache.commons.collections.FactoryUtils;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+import org.junit.Test;\n+\n+/**\n+ * Extension of {@link LazyMapTest} for exercising the \n+ * {@link LazySortedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class LazySortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+    \n+    private static final Factory<Integer> oneFactory = FactoryUtils.constantFactory(1);\n+   \n+    public LazySortedMapTest(String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    public SortedMap<K,V> makeObject() {\n+        return lazySortedMap(new TreeMap<K,V>(), FactoryUtils.<V>nullFactory());\n+    }\n+    \n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TODO TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    // from TestLazyMap\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public void testMapGet() {\n+        //TODO eliminate need for this via superclass - see svn history.\n+    }\n+    \n+    @Test\n+    public void mapGet() {\n+        Map<Integer, Number> map = lazySortedMap(new TreeMap<Integer,Number>(), oneFactory);\n+        assertEquals(0, map.size());\n+        Number i1 = map.get(5);\n+        assertEquals(1, i1);\n+        assertEquals(1, map.size());\n+\n+        map = lazySortedMap(new TreeMap<Integer,Number>(), FactoryUtils.<Number>nullFactory());\n+        Number o = map.get(5);\n+        assertEquals(null,o);\n+        assertEquals(1, map.size());\n+        \n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testSortOrder() {\n+        SortedMap<String, Number> map = lazySortedMap(new TreeMap<String,Number>(), oneFactory);\n+        map.put(\"A\",  5);\n+        map.get(\"B\"); // Entry with value \"One\" created\n+        map.put(\"C\", 8);\n+        assertEquals(\"First key should be A\", \"A\", map.firstKey());\n+        assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n+        assertEquals(\"First key in tail map should be B\", \n+            \"B\", map.tailMap(\"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\", \n+            \"B\", map.headMap(\"C\").lastKey());\n+        assertEquals(\"Last key in submap should be B\",\n+            \"B\", map.subMap(\"A\",\"C\").lastKey());\n+        \n+        Comparator<?> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\", \n+            c == null);      \n+    } \n+    \n+    public void testTransformerDecorate() {\n+        Transformer<Object, Integer> transformer = TransformerUtils.asTransformer(oneFactory);\n+        SortedMap<Integer, Number> map = lazySortedMap(new TreeMap<Integer, Number>(), transformer);     \n+        assertTrue(map instanceof LazySortedMap);  \n+         try {\n+            map = lazySortedMap(new TreeMap<Integer, Number>(), (Transformer<Integer, Number>) null);\n+            fail(\"Expecting IllegalArgumentException for null transformer\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        try {\n+            map = lazySortedMap((SortedMap<Integer,Number>) null, transformer);\n+            fail(\"Expecting IllegalArgumentException for null map\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        } \n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazySortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/LazySortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/LinkedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.ResettableIterator;\n+import org.apache.commons.collections.list.AbstractListTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class LinkedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public LinkedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(LinkedMapTest.class);\n+    }\n+\n+    @Override\n+    public LinkedMap<K, V> makeObject() {\n+        return new LinkedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> makeFullMap() {\n+        return (LinkedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReset() {\n+        resetEmpty();\n+        OrderedMap<K, V> ordered = getMap();\n+        ((ResettableIterator<K>) ordered.mapIterator()).reset();\n+\n+        resetFull();\n+        ordered = getMap();\n+        List<K> list = new ArrayList<K>(ordered.keySet());\n+        ResettableIterator<K> it = (ResettableIterator<K>) ordered.mapIterator();\n+        assertSame(list.get(0), it.next());\n+        assertSame(list.get(1), it.next());\n+        it.reset();\n+        assertSame(list.get(0), it.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testInsertionOrder() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+        K[] keys = getSampleKeys();\n+        V[] values = getSampleValues();\n+        Iterator<K> keyIter;\n+        Iterator<V> valueIter;\n+\n+        resetEmpty();\n+        map.put(keys[0], values[0]);\n+        map.put(keys[1], values[1]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[1]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[1], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[1], values[2]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[0], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+\n+        // no change to order\n+        map.put(keys[0], values[3]);\n+        keyIter = map.keySet().iterator();\n+        assertSame(keys[0], keyIter.next());\n+        assertSame(keys[1], keyIter.next());\n+        valueIter = map.values().iterator();\n+        assertSame(values[3], valueIter.next());\n+        assertSame(values[2], valueIter.next());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.get(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lm.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.getValue(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lm.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        assertEquals(-1, lm.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lm = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lm.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        LinkedMap<K, V> lm = getMap();\n+        try {\n+            lm.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lm = getMap();\n+        try {\n+            lm.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lm.remove(lm.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lm.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lm.get(key);\n+            assertEquals(value, lm.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lm.containsKey(key));\n+        }\n+    }\n+\n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+\n+    public class TestListView extends AbstractListTest<K> {\n+\n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return LinkedMapTest.this.makeObject().asList();\n+        }\n+\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return LinkedMapTest.this.makeFullMap().asList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return LinkedMapTest.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return LinkedMapTest.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        LinkedMap<K, V> map = new LinkedMap<K, V>(10);\n+        map.put((K) \"1\", (V) \"1\");\n+        Map<K, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(\"1\"), cloned.get(\"1\"));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/LinkedMap.fullCollection.version3.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public LinkedMap<K, V> getMap() {\n+        return (LinkedMap<K, V>) super.getMap();\n+    }\n+\n+    /**\n+     * Test for <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-323\">COLLECTIONS-323</a>.\n+     */\n+    public void testInitialCapacityZero() {\n+        final LinkedMap<String,String> map = new LinkedMap<String,String>(0);\n+        assertEquals(1, map.data.length);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/ListOrderedMap2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.list.AbstractListTest;\n+\n+/**\n+ * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class ListOrderedMap2Test<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public ListOrderedMap2Test(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ListOrderedMap2Test.class);\n+    }\n+\n+    @Override\n+    public ListOrderedMap<K, V> makeObject() {\n+        return new ListOrderedMap<K, V>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lom = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+\n+    public BulkTest bulkTestListView() {\n+        return new TestListView();\n+    }\n+\n+    public class TestListView extends AbstractListTest<K> {\n+\n+        TestListView() {\n+            super(\"TestListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return ListOrderedMap2Test.this.makeObject().asList();\n+        }\n+\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return ListOrderedMap2Test.this.makeFullMap().asList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return ListOrderedMap2Test.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return ListOrderedMap2Test.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/ListOrderedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.list.AbstractListTest;\n+\n+/**\n+ * Extension of {@link AbstractOrderedMapTest} for exercising the {@link ListOrderedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ * @author Matt Benson\n+ */\n+public class ListOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public ListOrderedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ListOrderedMapTest.class);\n+    }\n+\n+    @Override\n+    public ListOrderedMap<K, V> makeObject() {\n+        return ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> makeFullMap() {\n+        return (ListOrderedMap<K, V>) super.makeFullMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testGetByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.get(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.get(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.get(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            assertSame(it.next(), lom.get(i));\n+        }\n+    }\n+\n+    public void testGetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.getValue(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.getValue(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.getValue(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        int i = 0;\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext(); i++) {\n+            it.next();\n+            assertSame(it.getValue(), lom.getValue(i));\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        assertEquals(-1, lom.indexOf(getOtherKeys()));\n+\n+        resetFull();\n+        lom = getMap();\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            assertEquals(i, lom.indexOf(list.get(i)));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValueByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.setValue(0, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.setValue(-1, (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.setValue(lom.size(), (V) \"\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        for (int i = 0; i < lom.size(); i++) {\n+            V value = lom.getValue(i);\n+            Object input = new Integer(i);\n+            assertEquals(value, lom.setValue(i, (V) input));\n+            assertEquals(input, lom.getValue(i));\n+        }\n+    }\n+\n+    public void testRemoveByIndex() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+        try {\n+            lom.remove(0);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        resetFull();\n+        lom = getMap();\n+        try {\n+            lom.remove(-1);\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.remove(lom.size());\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        List<K> list = new ArrayList<K>();\n+        for (MapIterator<K, V> it = lom.mapIterator(); it.hasNext();) {\n+            list.add(it.next());\n+        }\n+        for (int i = 0; i < list.size(); i++) {\n+            Object key = list.get(i);\n+            Object value = lom.get(key);\n+            assertEquals(value, lom.remove(i));\n+            list.remove(i);\n+            assertEquals(false, lom.containsKey(key));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut_intObjectObject() {\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+\n+        try {\n+            lom.put(1, (K) \"testInsert1\", (V) \"testInsert1v\");\n+            fail(\"should not be able to insert at pos 1 in empty Map\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+        try {\n+            lom.put(-1, (K) \"testInsert-1\", (V) \"testInsert-1v\");\n+            fail(\"should not be able to insert at pos -1 in empty Map\");\n+        } catch (IndexOutOfBoundsException ex) {}\n+\n+        // put where key doesn't exist\n+        lom.put(0, (K) \"testInsert1\", (V) \"testInsert1v\");\n+        assertEquals(\"testInsert1v\", lom.getValue(0));\n+\n+        lom.put((K) \"testInsertPut\", (V) \"testInsertPutv\");\n+        assertEquals(\"testInsert1v\", lom.getValue(0));\n+        assertEquals(\"testInsertPutv\", lom.getValue(1));\n+\n+        lom.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsertPutv\", lom.getValue(2));\n+\n+        lom.put(3, (K) \"testInsert3\", (V) \"testInsert3v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsertPutv\", lom.getValue(2));\n+        assertEquals(\"testInsert3v\", lom.getValue(3));\n+\n+        // put in a full map\n+        resetFull();\n+        lom = getMap();\n+        ListOrderedMap<K, V> lom2 = new ListOrderedMap<K, V>();\n+        lom2.putAll(lom);\n+\n+        lom2.put(0, (K) \"testInsert0\", (V) \"testInsert0v\");\n+        assertEquals(\"testInsert0v\", lom2.getValue(0));\n+        for (int i = 0; i < lom.size(); i++) {\n+            assertEquals(lom2.getValue(i + 1), lom.getValue(i));\n+        }\n+\n+        // put where key does exist\n+        Integer i1 = new Integer(1);\n+        Integer i1b = new Integer(1);\n+        Integer i2 = new Integer(2);\n+        Integer i3 = new Integer(3);\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertSame(i1, lom.get(0));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(0, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertEquals(\"2\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+        assertSame(i1b, lom.get(0));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(1, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"One\", lom.getValue(0));\n+        assertEquals(\"2\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(2, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"2\", lom.getValue(0));\n+        assertEquals(\"One\", lom.getValue(1));\n+        assertEquals(\"3\", lom.getValue(2));\n+\n+        resetEmpty();\n+        lom = getMap();\n+        lom.put((K) i1, (V) \"1\");\n+        lom.put((K) i2, (V) \"2\");\n+        lom.put((K) i3, (V) \"3\");\n+        lom.put(3, (K) i1b, (V) \"One\");\n+        assertEquals(3, lom.size());\n+        assertEquals(3, lom.map.size());\n+        assertEquals(3, lom.insertOrder.size());\n+        assertEquals(\"2\", lom.getValue(0));\n+        assertEquals(\"3\", lom.getValue(1));\n+        assertEquals(\"One\", lom.getValue(2));\n+    }\n+\n+    public void testPutAllWithIndex() {\n+        resetEmpty();\n+        ListOrderedMap<String, String> lom = (ListOrderedMap<String, String>) map;\n+\n+        // Create Initial Data\n+        lom.put(\"testInsert0\", \"testInsert0v\");\n+        lom.put(\"testInsert1\", \"testInsert1v\");\n+        lom.put(\"testInsert2\", \"testInsert2v\");\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"testInsert1v\", lom.getValue(1));\n+        assertEquals(\"testInsert2v\", lom.getValue(2));\n+\n+        // Create New Test Map and Add using putAll(int, Object, Object)\n+        Map<String, String> values = new ListOrderedMap<String, String>();\n+        values.put(\"NewInsert0\", \"NewInsert0v\");\n+        values.put(\"NewInsert1\", \"NewInsert1v\");\n+        lom.putAll(1, values);\n+\n+        // Perform Asserts\n+        assertEquals(\"testInsert0v\", lom.getValue(0));\n+        assertEquals(\"NewInsert0v\", lom.getValue(1));\n+        assertEquals(\"NewInsert1v\", lom.getValue(2));\n+        assertEquals(\"testInsert1v\", lom.getValue(3));\n+        assertEquals(\"testInsert2v\", lom.getValue(4));\n+    }\n+\n+    public void testPutAllWithIndexBug441() {\n+        // see COLLECTIONS-441\n+        resetEmpty();\n+        ListOrderedMap<K, V> lom = getMap();\n+\n+        int size = 5;\n+        for (int i = 0; i < size; i++) {\n+            lom.put((K) Integer.valueOf(i), (V) Boolean.valueOf(true));\n+        }\n+\n+        Map<K, V> map = new TreeMap<K, V>();\n+        for (int i = 0; i < size; i++) {\n+            map.put((K) Integer.valueOf(i), (V) Boolean.valueOf(false));\n+        }\n+\n+        lom.putAll(3, map);\n+        \n+        List<K> orderedList = lom.asList();\n+        for (int i = 0; i < size; i++) {\n+            assertEquals(i, orderedList.get(i));\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testValueList_getByIndex() {\n+        resetFull();\n+        ListOrderedMap<K, V> lom = getMap();\n+        for (int i = 0; i < lom.size(); i++) {\n+            V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().get(i));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueList_setByIndex() {\n+        resetFull();\n+        ListOrderedMap<K, V> lom = getMap();\n+        for (int i = 0; i < lom.size(); i++) {\n+            Object input = new Integer(i);\n+            V expected = lom.getValue(i);\n+            assertEquals(expected, lom.valueList().set(i, (V) input));\n+            assertEquals(input, lom.getValue(i));\n+            assertEquals(input, lom.valueList().get(i));\n+        }\n+    }\n+\n+    public void testValueList_removeByIndex() {\n+        resetFull();\n+        ListOrderedMap<K, V> lom = getMap();\n+        while (lom.size() > 1) {\n+            V expected = lom.getValue(1);\n+            assertEquals(expected, lom.valueList().remove(1));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestKeyListView() {\n+        return new TestKeyListView();\n+    }\n+\n+    public BulkTest bulkTestValueListView() {\n+        return new TestValueListView();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public class TestKeyListView extends AbstractListTest<K> {\n+        TestKeyListView() {\n+            super(\"TestKeyListView\");\n+        }\n+\n+        @Override\n+        public List<K> makeObject() {\n+            return ListOrderedMapTest.this.makeObject().keyList();\n+        }\n+        @Override\n+        public List<K> makeFullCollection() {\n+            return ListOrderedMapTest.this.makeFullMap().keyList();\n+        }\n+\n+        @Override\n+        public K[] getFullElements() {\n+            return ListOrderedMapTest.this.getSampleKeys();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return ListOrderedMapTest.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public class TestValueListView extends AbstractListTest<V> {\n+        TestValueListView() {\n+            super(\"TestValueListView\");\n+        }\n+\n+        @Override\n+        public List<V> makeObject() {\n+            return ListOrderedMapTest.this.makeObject().valueList();\n+        }\n+        @Override\n+        public List<V> makeFullCollection() {\n+            return ListOrderedMapTest.this.makeFullMap().valueList();\n+        }\n+\n+        @Override\n+        public V[] getFullElements() {\n+            return ListOrderedMapTest.this.getSampleValues();\n+        }\n+        @Override\n+        public boolean isAddSupported() {\n+            return false;\n+        }\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return true;\n+        }\n+        @Override\n+        public boolean isSetSupported() {\n+            return true;\n+        }\n+        @Override\n+        public boolean isNullSupported() {\n+            return ListOrderedMapTest.this.isAllowNullKey();\n+        }\n+        @Override\n+        public boolean isTestSerialization() {\n+            return false;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/ListOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ListOrderedMap<K, V> getMap() {\n+        return (ListOrderedMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/MultiKeyMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.MultiKey;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MultiKeyMapTest<K, V> extends AbstractIterableMapTest<MultiKey<? extends K>, V> {\n+\n+    static final Integer I1 = new Integer(1);\n+    static final Integer I2 = new Integer(2);\n+    static final Integer I3 = new Integer(3);\n+    static final Integer I4 = new Integer(4);\n+    static final Integer I5 = new Integer(5);\n+    static final Integer I6 = new Integer(6);\n+    static final Integer I7 = new Integer(7);\n+    static final Integer I8 = new Integer(8);\n+\n+    public MultiKeyMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(MultiKeyMapTest.class);\n+    }\n+\n+    @Override\n+    public MultiKeyMap<K, V> makeObject() {\n+        return new MultiKeyMap<K, V>();\n+    }\n+\n+    @Override\n+    public MultiKey<K>[] getSampleKeys() {\n+        return getMultiKeyKeys();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiKey<K>[] getMultiKeyKeys() {\n+        return new MultiKey[] {\n+            new MultiKey<Integer>(I1, I2),\n+            new MultiKey<Integer>(I2, I3),\n+            new MultiKey<Integer>(I3, I4),\n+            new MultiKey<Integer>(I1, I1, I2),\n+            new MultiKey<Integer>(I2, I3, I4),\n+            new MultiKey<Integer>(I3, I7, I6),\n+            new MultiKey<Integer>(I1, I1, I2, I3),\n+            new MultiKey<Integer>(I2, I4, I5, I6),\n+            new MultiKey<Integer>(I3, I6, I7, I8),\n+            new MultiKey<Integer>(I1, I1, I2, I3, I4),\n+            new MultiKey<Integer>(I2, I3, I4, I5, I6),\n+            new MultiKey<Integer>(I3, I5, I6, I7, I8),\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] {\n+            \"2A\", \"2B\", \"2C\",\n+            \"3D\", \"3E\", \"3F\",\n+            \"4G\", \"4H\", \"4I\",\n+            \"5J\", \"5K\", \"5L\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] {\n+            \"1a\", \"1b\", \"1c\",\n+            \"2d\", \"2e\", \"2f\",\n+            \"3g\", \"3h\", \"3i\",\n+            \"4j\", \"4k\", \"4l\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiKey<K>[] getOtherKeys() {\n+        return new MultiKey[] {\n+            new MultiKey<Integer>(I1, I7),\n+            new MultiKey<Integer>(I1, I8),\n+            new MultiKey<Integer>(I2, I4),\n+            new MultiKey<Integer>(I2, I5),\n+        };\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        assertEquals(null, map.put(new MultiKey<K>(null, null), null));\n+        try {\n+            map.put(null, (V) new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMultiKeyGet() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(null, multimap.get(null, key.getKey(1)));\n+                assertEquals(null, multimap.get(key.getKey(0), null));\n+                assertEquals(null, multimap.get(null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(null, null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(null, multimap.get(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyContainsKey() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKey<K> key = keys[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null));\n+                assertEquals(false, multimap.containsKey(null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyPut() {\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKeyMap<K, V> multimap = new MultiKeyMap<K, V>();\n+\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(new MultiKey<K>(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyRemove() {\n+        MultiKey<K>[] keys = getMultiKeyKeys();\n+        V[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            resetFull();\n+            MultiKeyMap<K, V> multimap = getMap();\n+            int size = multimap.size();\n+\n+            MultiKey<K> key = keys[i];\n+            V value = values[i];\n+\n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll1() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1);\n+        assertEquals(8, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll2() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I2, I3);\n+        assertEquals(9, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll3() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1, I1, I2);\n+        assertEquals(9, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n+        }\n+    }\n+\n+    public void testMultiKeyRemoveAll4() {\n+        resetFull();\n+        MultiKeyMap<K, V> multimap = getMap();\n+        assertEquals(12, multimap.size());\n+\n+        multimap.removeAll(I1, I1, I2, I3);\n+        assertEquals(10, multimap.size());\n+        for (MapIterator<MultiKey<? extends K>, V> it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey<? extends K> key = it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testClone() {\n+        MultiKeyMap<K, V> map = new MultiKeyMap<K, V>();\n+        map.put(new MultiKey<K>((K) I1, (K) I2), (V) \"1-2\");\n+        Map<MultiKey<? extends K>, V> cloned = map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(new MultiKey<K>((K) I1, (K) I2)), cloned.get(new MultiKey<K>((K) I1, (K) I2)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testLRUMultiKeyMap() {\n+        MultiKeyMap<K, V> map = MultiKeyMap.multiKeyMap(new LRUMap<MultiKey<? extends K>, V>(2));\n+        map.put((K) I1, (K) I2, (V) \"1-2\");\n+        map.put((K) I1, (K) I3, (V) \"1-1\");\n+        assertEquals(2, map.size());\n+        map.put((K) I1, (K) I4, (V) \"1-4\");\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(I1, I3));\n+        assertEquals(true, map.containsKey(I1, I4));\n+        assertEquals(false, map.containsKey(I1, I2));\n+\n+        MultiKeyMap<K, V> cloned = map.clone();\n+        assertEquals(2, map.size());\n+        assertEquals(true, cloned.containsKey(I1, I3));\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(false, cloned.containsKey(I1, I2));\n+        cloned.put((K) I1, (K) I5, (V) \"1-5\");\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(true, cloned.containsKey(I1, I5));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/MultiKeyMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/MultiKeyMap.fullCollection.version3.1.obj\");\n+//    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public MultiKeyMap<K, V> getMap() {\n+        return (MultiKeyMap<K, V>) super.getMap();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/MultiValueMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.MultiMap;\n+\n+import org.apache.commons.collections.AbstractObjectTest;\n+\n+/**\n+ * TestMultiValueMap.\n+ *\n+ * @author <a href=\"mailto:jcarman@apache.org\">James Carman</a>\n+ * @author Stephen Colebourne\n+ * @since Commons Collections 3.2\n+ */\n+public class MultiValueMapTest<K, V> extends AbstractObjectTest {\n+\n+    public MultiValueMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public void testNoMappingReturnsNull() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        assertNull(map.get(\"whatever\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueCollectionType() {\n+        final MultiValueMap<K, V> map = createTestMap(LinkedList.class);\n+        assertTrue(map.get(\"one\") instanceof LinkedList);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMultipleValues() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"un\");\n+        assertEquals(expected, map.get(\"one\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue(\"uno\"));\n+        assertTrue(map.containsValue(\"un\"));\n+        assertTrue(map.containsValue(\"dos\"));\n+        assertTrue(map.containsValue(\"deux\"));\n+        assertTrue(map.containsValue(\"tres\"));\n+        assertTrue(map.containsValue(\"trois\"));\n+        assertFalse(map.containsValue(\"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testKeyContainsValue() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        assertTrue(map.containsValue((K) \"one\", \"uno\"));\n+        assertTrue(map.containsValue((K) \"one\", \"un\"));\n+        assertTrue(map.containsValue((K) \"two\", \"dos\"));\n+        assertTrue(map.containsValue((K) \"two\", \"deux\"));\n+        assertTrue(map.containsValue((K) \"three\", \"tres\"));\n+        assertTrue(map.containsValue((K) \"three\", \"trois\"));\n+        assertFalse(map.containsValue((K) \"four\", \"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValues() {\n+        final MultiValueMap<K, V> map = createTestMap(HashSet.class);\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"dos\");\n+        expected.add((V) \"tres\");\n+        expected.add((V) \"un\");\n+        expected.add((V) \"deux\");\n+        expected.add((V) \"trois\");\n+        final Collection<Object> c = map.values();\n+        assertEquals(6, c.size());\n+        assertEquals(expected, new HashSet<Object>(c));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private MultiValueMap<K, V> createTestMap() {\n+        return createTestMap(ArrayList.class);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <C extends Collection<V>> MultiValueMap<K, V> createTestMap(Class<C> collectionClass) {\n+        final MultiValueMap<K, V> map = MultiValueMap.multiValueMap(new HashMap<K, C>(), collectionClass);\n+        map.put((K) \"one\", (V) \"uno\");\n+        map.put((K) \"one\", (V) \"un\");\n+        map.put((K) \"two\", (V) \"dos\");\n+        map.put((K) \"two\", (V) \"deux\");\n+        map.put((K) \"three\", (V) \"tres\");\n+        map.put((K) \"three\", (V) \"trois\");\n+        return map;\n+    }\n+\n+    public void testKeyedIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator(\"one\")));\n+        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList(new String[]{ \"uno\", \"un\" }));\n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testRemoveAllViaIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        for (Iterator<?> i = map.values().iterator(); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+    public void testRemoveAllViaKeyedIterator() {\n+        final MultiValueMap<K, V> map = createTestMap();\n+        for (Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertEquals(4, map.totalSize());\n+    }\n+\n+    public void testTotalSizeA() {\n+        assertEquals(6, createTestMap().totalSize());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapEquals() {\n+        MultiValueMap<K, V> one = new MultiValueMap<K, V>();\n+        Integer value = new Integer(1);\n+        one.put((K) \"One\", value);\n+        one.remove(\"One\", value);\n+\n+        MultiValueMap<K, V> two = new MultiValueMap<K, V>();\n+        assertEquals(two, one);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testGetCollection() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        map.put((K) \"A\", \"AA\");\n+        assertSame(map.get(\"A\"), map.getCollection(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTotalSize() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.totalSize());\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.totalSize());\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(2, map.totalSize());\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(3, map.totalSize());\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(4, map.totalSize());\n+        map.remove(\"A\");\n+        assertEquals(3, map.totalSize());\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(2, map.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(2, map.size());\n+        map.remove(\"A\");\n+        assertEquals(1, map.size());\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(1, map.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize_Key() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(0, map.size(\"B\"));\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(0, map.size(\"B\"));\n+        map.put((K) \"B\", \"BA\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(1, map.size(\"B\"));\n+        map.put((K) \"B\", \"BB\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(2, map.size(\"B\"));\n+        map.put((K) \"B\", \"BC\");\n+        assertEquals(1, map.size(\"A\"));\n+        assertEquals(3, map.size(\"B\"));\n+        map.remove(\"A\");\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(3, map.size(\"B\"));\n+        map.remove(\"B\", \"BC\");\n+        assertEquals(0, map.size(\"A\"));\n+        assertEquals(2, map.size(\"B\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIterator_Key() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(false, map.iterator(\"A\").hasNext());\n+        map.put((K) \"A\", \"AA\");\n+        Iterator<?> it = map.iterator(\"A\");\n+        assertEquals(true, it.hasNext());\n+        it.next();\n+        assertEquals(false, it.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue_Key() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        assertEquals(false, map.containsValue(\"A\", \"AA\"));\n+        assertEquals(false, map.containsValue(\"B\", \"BB\"));\n+        map.put((K) \"A\", \"AA\");\n+        assertEquals(true, map.containsValue(\"A\", \"AA\"));\n+        assertEquals(false, map.containsValue(\"A\", \"AB\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithList() {\n+        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, Collection>(), ArrayList.class);\n+        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n+        assertEquals(1, test.size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithSet() {\n+        MultiValueMap<K, V> test = MultiValueMap.multiValueMap(new HashMap<K, HashSet>(), HashSet.class);\n+        assertEquals(\"a\", test.put((K) \"A\", \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", \"b\"));\n+        assertEquals(null, test.put((K) \"A\", \"a\"));\n+        assertEquals(1, test.size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.totalSize());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map1() {\n+        MultiMap<K, V> original = new MultiValueMap<K, V>();\n+        original.put((K) \"key\", \"object1\");\n+        original.put((K) \"key\", \"object2\");\n+\n+        MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        test.put((K) \"keyA\", \"objectA\");\n+        test.put((K) \"key\", \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(2, test.size());\n+        assertEquals(4, test.totalSize());\n+        assertEquals(1, test.getCollection(\"keyA\").size());\n+        assertEquals(3, test.getCollection(\"key\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map2() {\n+        Map<K, V> original = new HashMap<K, V>();\n+        original.put((K) \"keyX\", (V) \"object1\");\n+        original.put((K) \"keyY\", (V) \"object2\");\n+\n+        MultiValueMap<K, V> test = new MultiValueMap<K, V>();\n+        test.put((K) \"keyA\", \"objectA\");\n+        test.put((K) \"keyX\", \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(3, test.size());\n+        assertEquals(4, test.totalSize());\n+        assertEquals(1, test.getCollection(\"keyA\").size());\n+        assertEquals(2, test.getCollection(\"keyX\").size());\n+        assertEquals(1, test.getCollection(\"keyY\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_KeyCollection() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        Collection<V> coll = (Collection<V>) Arrays.asList(new Object[] { \"X\", \"Y\", \"Z\" });\n+\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", null));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", new ArrayList<V>()));\n+        assertEquals(3, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+\n+        coll = (Collection<V>) Arrays.asList(new Object[] { \"M\" });\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(4, map.size(\"A\"));\n+        assertEquals(true, map.containsValue(\"A\", \"X\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Y\"));\n+        assertEquals(true, map.containsValue(\"A\", \"Z\"));\n+        assertEquals(true, map.containsValue(\"A\", \"M\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove_KeyItem() {\n+        MultiValueMap<K, V> map = new MultiValueMap<K, V>();\n+        map.put((K) \"A\", \"AA\");\n+        map.put((K) \"A\", \"AB\");\n+        map.put((K) \"A\", \"AC\");\n+        assertEquals(null, map.remove(\"C\", \"CA\"));\n+        assertEquals(null, map.remove(\"A\", \"AD\"));\n+        assertEquals(\"AC\", map.remove(\"A\", \"AC\"));\n+        assertEquals(\"AB\", map.remove(\"A\", \"AB\"));\n+        assertEquals(\"AA\", map.remove(\"A\", \"AA\"));\n+        assertEquals(new MultiValueMap<K, V>(), map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    // Manual serialization testing as this class cannot easily \n+    // extend the AbstractTestMap\n+    //-----------------------------------------------------------------------\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+    @Override\n+    public Object makeObject() {\n+        Map m = makeEmptyMap();\n+        m.put(\"a\", \"1\");\n+        m.put(\"a\", \"1b\");\n+        m.put(\"b\", \"2\");\n+        m.put(\"c\", \"3\");\n+        m.put(\"c\", \"3b\");\n+        m.put(\"d\", \"4\");\n+        return m;\n+    }\n+\n+    private Map makeEmptyMap() {\n+        return new MultiValueMap();\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) makeEmptyMap(),\n+//            \"/tmp/MultiValueMap.emptyCollection.version3.3.obj\");\n+//\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) makeObject(),\n+//            \"/tmp/MultiValueMap.fullCollection.version3.3.obj\");\n+//    }\n+\n+    public void testEmptyMapCompatibility() throws Exception {\n+        Map<?,?> map = makeEmptyMap();\n+        Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+        assertEquals(\"Map is empty\", 0, map2.size());\n+    }\n+    public void testFullMapCompatibility() throws Exception {\n+        Map<?,?> map = (Map<?,?>) makeObject();\n+        Map<?,?> map2 = (Map<?,?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        assertEquals(\"Map is the right size\", map.size(), map2.size());\n+        for (Iterator<?> it = map.keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            assertEquals( \"Map had inequal elements\", map.get(key), map2.get(key) );\n+            map2.remove(key);\n+        }\n+        assertEquals(\"Map had extra values\", 0, map2.size());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/PassiveExpiringMapTest.java\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.map.PassiveExpiringMap.ExpirationPolicy;\n+\n+public class PassiveExpiringMapTest<K, V>\n+    extends AbstractMapTest<K, V> {\n+\n+    private static class TestExpirationPolicy\n+        implements ExpirationPolicy<Integer, String> {\n+\n+        private static final long serialVersionUID = 1L;\n+\n+        public long expirationTime(Integer key, String value) {\n+            // odd keys expire immediately, even keys never expire\n+            if (key == null) {\n+                return 0;\n+            }\n+\n+            if (key.intValue() % 2 == 0) {\n+                return -1;\n+            }\n+\n+            return 0;\n+        }\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(PassiveExpiringMapTest.class);\n+    }\n+\n+    public PassiveExpiringMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // public void testCreate() throws Exception {\n+    // writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+    // \"PassiveExpiringMap.emptyCollection.version4.obj\");\n+    //\n+    // writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+    // \"PassiveExpiringMap.fullCollection.version4.obj\");\n+    // }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4\";\n+    }\n+\n+    private Map<Integer, String> makeDecoratedTestMap() {\n+        Map<Integer, String> m = new HashMap<Integer, String>();\n+        m.put(Integer.valueOf(1), \"one\");\n+        m.put(Integer.valueOf(2), \"two\");\n+        m.put(Integer.valueOf(3), \"three\");\n+        m.put(Integer.valueOf(4), \"four\");\n+        m.put(Integer.valueOf(5), \"five\");\n+        m.put(Integer.valueOf(6), \"six\");\n+        return new PassiveExpiringMap<Integer, String>(\n+                                                       new TestExpirationPolicy(),\n+                                                       m);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeObject() {\n+        return new PassiveExpiringMap<K, V>();\n+    }\n+\n+    private Map<Integer, String> makeTestMap() {\n+        Map<Integer, String> m = new PassiveExpiringMap<Integer, String>(\n+                                                                         new TestExpirationPolicy());\n+        m.put(Integer.valueOf(1), \"one\");\n+        m.put(Integer.valueOf(2), \"two\");\n+        m.put(Integer.valueOf(3), \"three\");\n+        m.put(Integer.valueOf(4), \"four\");\n+        m.put(Integer.valueOf(5), \"five\");\n+        m.put(Integer.valueOf(6), \"six\");\n+        return m;\n+    }\n+\n+    public void testConstructors() {\n+        try {\n+            Map<String, String> map = null;\n+            new PassiveExpiringMap<String, String>(map);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        try {\n+            ExpirationPolicy<String, String> policy = null;\n+            new PassiveExpiringMap<String, String>(policy);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+\n+        try {\n+            TimeUnit unit = null;\n+            new PassiveExpiringMap<String, String>(10L, unit);\n+            fail(\"constructor - exception should have been thrown.\");\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testContainsKey() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.containsKey(Integer.valueOf(1)));\n+        assertFalse(m.containsKey(Integer.valueOf(3)));\n+        assertFalse(m.containsKey(Integer.valueOf(5)));\n+        assertTrue(m.containsKey(Integer.valueOf(2)));\n+        assertTrue(m.containsKey(Integer.valueOf(4)));\n+        assertTrue(m.containsKey(Integer.valueOf(6)));\n+    }\n+\n+    public void testContainsValue() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.containsValue(\"one\"));\n+        assertFalse(m.containsValue(\"three\"));\n+        assertFalse(m.containsValue(\"five\"));\n+        assertTrue(m.containsValue(\"two\"));\n+        assertTrue(m.containsValue(\"four\"));\n+        assertTrue(m.containsValue(\"six\"));\n+    }\n+\n+    public void testDecoratedMap() {\n+        // entries shouldn't expire\n+        Map<Integer, String> m = makeDecoratedTestMap();\n+        assertEquals(6, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+\n+        // removing a single item shouldn't affect any other items\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+        m.remove(Integer.valueOf(2));\n+        assertEquals(5, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+        assertNull(m.get(Integer.valueOf(2)));\n+\n+        // adding a single, even item shouldn't affect any other items\n+        assertNull(m.get(Integer.valueOf(2)));\n+        m.put(Integer.valueOf(2), \"two\");\n+        assertEquals(6, m.size());\n+        assertEquals(\"one\", m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+\n+        // adding a single, odd item (one that expires) shouldn't affect any\n+        // other items\n+        // put the entry expires immediately\n+        m.put(Integer.valueOf(1), \"one-one\");\n+        assertEquals(5, m.size());\n+        assertNull(m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+    }\n+\n+    public void testEntrySet() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.entrySet().size());\n+    }\n+\n+    public void testGet() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertNull(m.get(Integer.valueOf(1)));\n+        assertEquals(\"two\", m.get(Integer.valueOf(2)));\n+        assertNull(m.get(Integer.valueOf(3)));\n+        assertEquals(\"four\", m.get(Integer.valueOf(4)));\n+        assertNull(m.get(Integer.valueOf(5)));\n+        assertEquals(\"six\", m.get(Integer.valueOf(6)));\n+    }\n+\n+    public void testIsEmpty() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertFalse(m.isEmpty());\n+\n+        // remove just evens\n+        m = makeTestMap();\n+        m.remove(Integer.valueOf(2));\n+        m.remove(Integer.valueOf(4));\n+        m.remove(Integer.valueOf(6));\n+        assertTrue(m.isEmpty());\n+    }\n+\n+    public void testKeySet() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.keySet().size());\n+    }\n+\n+    public void testSize() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.size());\n+    }\n+\n+    public void testValues() {\n+        Map<Integer, String> m = makeTestMap();\n+        assertEquals(3, m.values().size());\n+    }\n+\n+    public void testZeroTimeToLive() {\n+        // item should not be available\n+        PassiveExpiringMap<String, String> m = new PassiveExpiringMap<String, String>(\n+                                                                                      0L);\n+        m.put(\"a\", \"b\");\n+        assertNull(m.get(\"a\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/PredicatedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the \n+ * {@link PredicatedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class PredicatedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.<Object>truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n+        public boolean evaluate(Object o) {\n+            return (o instanceof String);\n+        }\n+    };\n+\n+    public PredicatedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected IterableMap<K, V> decorateMap(Map<K, V> map, Predicate<? super K> keyPredicate,\n+        Predicate<? super V> valuePredicate) {\n+        return PredicatedMap.predicatedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return decorateMap(new HashMap<K, V>(), truePredicate, truePredicate);\n+    }\n+\n+    public IterableMap<K, V> makeTestMap() {\n+        return decorateMap(new HashMap<K, V>(), testPredicate, testPredicate);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySet() {\n+        Map<K, V> map = makeTestMap();\n+        assertTrue(\"returned entryset should not be null\",\n+            map.entrySet() != null);\n+        map = decorateMap(new HashMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n+        assertTrue(\"returned entryset should contain one entry\",\n+            map.entrySet().size() == 1);\n+        map = decorateMap(map, null, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        Map<K, V> map = makeTestMap();\n+        try {\n+            map.put((K) \"Hi\", (V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put((K) new Integer(3), (V) \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n+        try {\n+            Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"F\", (V) \"f\");\n+        iterator = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/PredicatedSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.apache.commons.collections.functors.TruePredicate;\n+\n+/**\n+ * Extension of {@link PredicatedMapTest} for exercising the\n+ * {@link PredicatedSortedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class PredicatedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    protected static final Predicate<Object> truePredicate = TruePredicate.truePredicate();\n+\n+    protected static final Predicate<Object> testPredicate = new Predicate<Object>() {\n+        public boolean evaluate(Object o) {\n+            return (o instanceof String);\n+        }\n+    };\n+\n+    public PredicatedSortedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    protected SortedMap<K, V> decorateMap(SortedMap<K, V> map, Predicate<? super K> keyPredicate,\n+        Predicate<? super V> valuePredicate) {\n+        return PredicatedSortedMap.predicatedSortedMap(map, keyPredicate, valuePredicate);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return decorateMap(new TreeMap<K, V>(), truePredicate, truePredicate);\n+    }\n+\n+    public SortedMap<K, V> makeTestMap() {\n+        return decorateMap(new TreeMap<K, V>(), testPredicate, testPredicate);\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    // from TestPredicatedMap\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEntrySet() {\n+        SortedMap<K, V> map = makeTestMap();\n+        assertTrue(\"returned entryset should not be null\",\n+            map.entrySet() != null);\n+        map = decorateMap(new TreeMap<K, V>(), null, null);\n+        map.put((K) \"oneKey\", (V) \"oneValue\");\n+        assertTrue(\"returned entryset should contain one entry\",\n+            map.entrySet().size() == 1);\n+        map = decorateMap(map, null, null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPut() {\n+        Map<K, V> map = makeTestMap();\n+        try {\n+            map.put((K) \"Hi\", (V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put((K) new Integer(3), (V) \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        Map<K, V> map2 = new HashMap<K, V>();\n+        map2.put((K) \"A\", (V) \"a\");\n+        map2.put((K) \"B\", (V) \"b\");\n+        map2.put((K) \"C\", (V) \"c\");\n+        map2.put((K) \"c\", (V) new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"E\", (V) \"e\");\n+        Iterator<Map.Entry<K, V>> iterator = map.entrySet().iterator();\n+        try {\n+            Map.Entry<K, V> entry = iterator.next();\n+            entry.setValue((V) new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put((K) \"F\", (V) \"f\");\n+        iterator = map.entrySet().iterator();\n+        Map.Entry<K, V> entry = iterator.next();\n+        entry.setValue((V) \"x\");\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSortOrder() {\n+        SortedMap<K, V> map = makeTestMap();\n+        map.put((K) \"A\",  (V) \"a\");\n+        map.put((K) \"B\", (V) \"b\");\n+        try {\n+            map.put(null, (V) \"c\");\n+            fail(\"Null key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        map.put((K) \"C\", (V) \"c\");\n+        try {\n+            map.put((K) \"D\", null);\n+            fail(\"Null value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertEquals(\"First key should be A\", \"A\", map.firstKey());\n+        assertEquals(\"Last key should be C\", \"C\", map.lastKey());\n+        assertEquals(\"First key in tail map should be B\",\n+            \"B\", map.tailMap((K) \"B\").firstKey());\n+        assertEquals(\"Last key in head map should be B\",\n+            \"B\", map.headMap((K) \"C\").lastKey());\n+        assertEquals(\"Last key in submap should be B\",\n+           \"B\", map.subMap((K) \"A\",(K) \"C\").lastKey());\n+\n+        Comparator<? super K> c = map.comparator();\n+        assertTrue(\"natural order, so comparator should be null\",\n+            c == null);\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/PredicatedSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/ReferenceIdentityMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.map.AbstractReferenceMap.ReferenceStrength;\n+\n+/**\n+ * Tests for ReferenceIdentityMap.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Guilhem Lavaux\n+ */\n+public class ReferenceIdentityMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    private static final Integer I1A = new Integer(1);\n+    private static final Integer I1B = new Integer(1);\n+    private static final Integer I2A = new Integer(2);\n+    private static final Integer I2B = new Integer(2);\n+\n+    public ReferenceIdentityMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ReferenceIdentityMapTest.class);\n+    }\n+\n+    @Override\n+    public ReferenceIdentityMap<K, V> makeObject() {\n+        return new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        // Testing against another [collections] class generally isn't a good idea,\n+        // but the closest alternative is IdentityHashMap, which propagates reference-equality down to keySet and values.\n+        // arguably ReferenceIdentityMap should do the same but that's a later discussion.\n+        return new IdentityMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBasics() {\n+        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+        assertEquals(0, map.size());\n+\n+        map.put((K) I1A, (V) I2A);\n+        assertEquals(1, map.size());\n+        assertSame(I2A, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(true, map.containsValue(I2A));\n+        assertEquals(false, map.containsValue(I2B));\n+\n+        map.put((K) I1A, (V) I2B);\n+        assertEquals(1, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(null, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(false, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+\n+        map.put((K) I1B, (V) I2B);\n+        assertEquals(2, map.size());\n+        assertSame(I2B, map.get(I1A));\n+        assertSame(I2B, map.get(I1B));\n+        assertEquals(true, map.containsKey(I1A));\n+        assertEquals(true, map.containsKey(I1B));\n+        assertEquals(false, map.containsValue(I2A));\n+        assertEquals(true, map.containsValue(I2B));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHashEntry() {\n+        IterableMap<K, V> map = new ReferenceIdentityMap<K, V>(ReferenceStrength.HARD, ReferenceStrength.HARD);\n+\n+        map.put((K) I1A, (V) I2A);\n+        map.put((K) I1B, (V) I2A);\n+\n+        Map.Entry<K, V> entry1 = map.entrySet().iterator().next();\n+        Iterator<Map.Entry<K, V>> it = map.entrySet().iterator();\n+        Map.Entry<K, V> entry2 = it.next();\n+        Map.Entry<K, V> entry3 = it.next();\n+\n+        assertEquals(true, entry1.equals(entry2));\n+        assertEquals(true, entry2.equals(entry1));\n+        assertEquals(false, entry1.equals(entry3));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, getMap().get(null));\n+        assertEquals(false, getMap().containsKey(null));\n+        assertEquals(false, getMap().containsValue(null));\n+        assertEquals(null, getMap().remove(null));\n+        assertEquals(false, getMap().entrySet().contains(null));\n+        assertEquals(false, getMap().keySet().contains(null));\n+        assertEquals(false, getMap().values().contains(null));\n+        try {\n+            getMap().put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            getMap().put((K) new Object(), null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            getMap().put(null, (V) new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+/*\n+    // Tests often fail because gc is uncontrollable\n+\n+    public void testPurge() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceIdentityMap map = new ReferenceIdentityMap(ReferenceIdentityMap.WEAK, ReferenceIdentityMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Map<K, V> buildRefMap() {\n+        K key = (K) new Object();\n+        V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        Map<K, V> testMap = new ReferenceIdentityMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        testMap.put(key, value);\n+\n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        return testMap;\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        Map<K, V> testMap = buildRefMap();\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while (true) {\n+            System.gc();\n+            if (iterations++ > 50) {\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if (\n+                keyReference.get() == null &&\n+                valueReference.get() == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                @SuppressWarnings(\"unused\")\n+                byte[] b =  new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void gc() {\n+        try {\n+            // trigger GC\n+            byte[][] tooLarge = new byte[1000000000][1000000000];\n+            fail(\"you have too much RAM\");\n+        } catch (OutOfMemoryError ex) {\n+            System.gc(); // ignore\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/ReferenceMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.map.AbstractReferenceMap.ReferenceStrength;\n+\n+/**\n+ * Tests for ReferenceMap.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Paul Jack\n+ * @author Guilhem Lavaux\n+ */\n+public class ReferenceMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public ReferenceMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(ReferenceMapTest.class);\n+    }\n+\n+    @Override\n+    public ReferenceMap<K, V> makeObject() {\n+        return new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.WEAK);\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            map.put((K) new Object(), null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        try {\n+            map.put(null, (V) new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n+/*\n+    // Tests often fail because gc is uncontrollable\n+\n+    public void testPurge() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < hard.length; i++) {\n+            hard[i] = new Object();\n+            map.put(hard[i], new Object());\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak values\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+        }\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys\", map.isEmpty());\n+\n+        for (int i = 0; i < hard.length; i++) {\n+            map.put(new Object(), hard[i]);\n+            map.put(hard[i], new Object());\n+        }\n+\n+        gc();\n+        assertTrue(\"map should be empty after purge of weak keys and values\", map.isEmpty());\n+    }\n+\n+\n+    public void testGetAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        for (int i = 0; i < 10; i++) {\n+            map.put(new Integer(i), new Integer(i));\n+        }\n+\n+        gc();\n+        for (int i = 0; i < 10; i++) {\n+            Integer I = new Integer(i);\n+            assertTrue(\"map.containsKey should return false for GC'd element\", !map.containsKey(I));\n+            assertTrue(\"map.get should return null for GC'd element\", map.get(I) == null);\n+        }\n+    }\n+\n+\n+    public void testEntrySetIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        Iterator iterator = map.entrySet().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            Integer key = (Integer)entry.getKey();\n+            Integer value = (Integer)entry.getValue();\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        gc();\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+\n+    public void testMapIteratorAfterGC2() {\n+        ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n+        Object[] hard = new Object[10];\n+        for (int i = 0; i < 10; i++) {\n+            hard[i] = new Integer(10 + i);\n+            map.put(new Integer(i), new Integer(i));\n+            map.put(hard[i], hard[i]);\n+        }\n+\n+        MapIterator iterator = map.mapIterator();\n+        while (iterator.hasNext()) {\n+            Object key1 = iterator.next();\n+            gc();\n+            Integer key = (Integer) iterator.getKey();\n+            Integer value = (Integer) iterator.getValue();\n+            assertTrue(\"iterator keys should match\", key == key1);\n+            assertTrue(\"iterator should skip GC'd keys\", key.intValue() >= 10);\n+            assertTrue(\"iterator should skip GC'd values\", value.intValue() >= 10);\n+        }\n+\n+    }\n+*/\n+\n+    WeakReference<K> keyReference;\n+    WeakReference<V> valueReference;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<K, V> buildRefMap() {\n+        K key = (K) new Object();\n+        V value = (V) new Object();\n+\n+        keyReference = new WeakReference<K>(key);\n+        valueReference = new WeakReference<V>(value);\n+\n+        Map<K, V> testMap = new ReferenceMap<K, V>(ReferenceStrength.WEAK, ReferenceStrength.HARD, true);\n+        testMap.put(key, value);\n+\n+        assertEquals(\"In map\", value, testMap.get(key));\n+        assertNotNull(\"Weak reference released early (1)\", keyReference.get());\n+        assertNotNull(\"Weak reference released early (2)\", valueReference.get());\n+        return testMap;\n+    }\n+\n+    /** Tests whether purge values setting works */\n+    public void testPurgeValues() throws Exception {\n+        // many thanks to Juozas Baliuka for suggesting this method\n+        Map<K, V> testMap = buildRefMap();\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while (true) {\n+            System.gc();\n+            if (iterations++ > 50) {\n+                fail(\"Max iterations reached before resource released.\");\n+            }\n+            testMap.isEmpty();\n+            if (keyReference.get() == null && valueReference.get() == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                @SuppressWarnings(\"unused\")\n+                byte[] b = new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static void gc() {\n+        try {\n+            // trigger GC\n+            byte[][] tooLarge = new byte[1000000000][1000000000];\n+            fail(\"you have too much RAM\");\n+        } catch (OutOfMemoryError ex) {\n+            System.gc(); // ignore\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/SingletonMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BoundedMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.KeyValue;\n+import org.apache.commons.collections.OrderedMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class SingletonMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    private static final Integer ONE = new Integer(1);\n+    private static final Integer TWO = new Integer(2);\n+    private static final String TEN = \"10\";\n+\n+    public SingletonMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(SingletonMapTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public OrderedMap<K, V> makeObject() {\n+        // need an empty singleton map, but thats not possible\n+        // use a ridiculous fake instead to make the tests pass\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        // the ridiculous map above still doesn't pass these tests\n+        // but its not relevant, so we ignore them\n+        return new String[] {\n+            \"SingletonMapTest.bulkTestMapIterator.testEmptyMapIterator\",\n+            \"SingletonMapTest.bulkTestOrderedMapIterator.testEmptyMapIterator\",\n+        };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SingletonMap<K, V> makeFullMap() {\n+        return new SingletonMap<K, V>((K) ONE, (V) TWO);\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public K[] getSampleKeys() {\n+        return (K[]) new Object[] { ONE };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getSampleValues() {\n+        return (V[]) new Object[] { TWO };\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public V[] getNewSampleValues() {\n+        return (V[]) new Object[] { TEN };\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        SingletonMap<K, V> cloned = map.clone();\n+        assertEquals(1, cloned.size());\n+        assertEquals(true, cloned.containsKey(ONE));\n+        assertEquals(true, cloned.containsValue(TWO));\n+    }\n+\n+    public void testKeyValue() {\n+        SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        assertEquals(ONE, map.getKey());\n+        assertEquals(TWO, map.getValue());\n+        assertTrue(map instanceof KeyValue);\n+    }\n+\n+    public void testBoundedMap() {\n+        SingletonMap<K, V> map = makeFullMap();\n+        assertEquals(1, map.size());\n+        assertEquals(true, map.isFull());\n+        assertEquals(1, map.maxSize());\n+        assertTrue(map instanceof BoundedMap);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+//    public BulkTest bulkTestMapIterator() {\n+//        return new TestFlatMapIterator();\n+//    }\n+//\n+//    public class TestFlatMapIterator extends AbstractTestOrderedMapIterator {\n+//        public TestFlatMapIterator() {\n+//            super(\"TestFlatMapIterator\");\n+//        }\n+//\n+//        public Object[] addSetValues() {\n+//            return TestSingletonMap.this.getNewSampleValues();\n+//        }\n+//\n+//        public boolean supportsRemove() {\n+//            return TestSingletonMap.this.isRemoveSupported();\n+//        }\n+//\n+//        public boolean supportsSetValue() {\n+//            return TestSingletonMap.this.isSetValueSupported();\n+//        }\n+//\n+//        public MapIterator makeEmptyMapIterator() {\n+//            resetEmpty();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public MapIterator makeFullMapIterator() {\n+//            resetFull();\n+//            return ((Flat3Map) TestSingletonMap.this.map).mapIterator();\n+//        }\n+//\n+//        public Map getMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.map;\n+//        }\n+//\n+//        public Map getConfirmedMap() {\n+//            // assumes makeFullMapIterator() called first\n+//            return TestSingletonMap.this.confirmed;\n+//        }\n+//\n+//        public void verify() {\n+//            super.verify();\n+//            TestSingletonMap.this.verify();\n+//        }\n+//    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/SingletonMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/SingletonMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/StaticBucketMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Unit tests.\n+ * {@link StaticBucketMap}.\n+ *\n+ * @version $Revision$\n+ *\n+ * @author Michael A. Smith\n+ */\n+public class StaticBucketMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public StaticBucketMapTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(StaticBucketMapTest.class);\n+    }\n+\n+    @Override\n+    public StaticBucketMap<K, V> makeObject() {\n+        return new StaticBucketMap<K, V>(30);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean isFailFastExpected() {\n+        return false;\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        String pre = \"StaticBucketMapTest.bulkTestMap\";\n+        String post = \".testCollectionIteratorFailFast\";\n+        return new String[] {\n+            pre + \"EntrySet\" + post,\n+            pre + \"KeySet\" + post,\n+            pre + \"Values\" + post\n+        };\n+    }\n+\n+    // Bugzilla 37567\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_get_nullMatchesIncorrectly() {\n+        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put(null, (V) \"A\");\n+        assertEquals(\"A\", map.get(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, null, map.get(str));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_containsKey_nullMatchesIncorrectly() {\n+        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put(null, (V) \"A\");\n+        assertEquals(true, map.containsKey(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, false, map.containsKey(str));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void test_containsValue_nullMatchesIncorrectly() {\n+        StaticBucketMap<K, V> map = new StaticBucketMap<K, V>(17);\n+        map.put((K) \"A\", null);\n+        assertEquals(true, map.containsValue(null));\n+        // loop so we find a string that is in the same bucket as the null\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            String str = String.valueOf((char) i);\n+            assertEquals(\"String: \" + str, false, map.containsValue(str));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TransformedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the {@link TransformedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public TransformedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return TransformedMap.transformingMap(new HashMap<K, V>(), TransformerUtils.<K> nopTransformer(),\n+                TransformerUtils.<V> nopTransformer());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedMap() {\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        Map<K, V> map = TransformedMap\n+                .transformingMap(\n+                        new HashMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(new Integer((String) els[i])));\n+            assertEquals(false, map.containsKey(els[i]));\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(els[i], map.get(new Integer((String) els[i])));\n+        }\n+\n+        assertEquals(null, map.remove(els[0]));\n+        assertEquals(els[0], map.remove(new Integer((String) els[0])));\n+\n+        map = TransformedMap.transformingMap(new HashMap(), null, TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(new Integer((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(new Integer((String) els[i]), map.get(els[i]));\n+        }\n+\n+        assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n+\n+        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n+        assertEquals(new Integer(66), array[0].getValue());\n+        assertEquals(new Integer(66), map.get(array[0].getKey()));\n+\n+        Map.Entry entry = entrySet.iterator().next();\n+        entry.setValue(\"88\");\n+        assertEquals(new Integer(88), entry.getValue());\n+        assertEquals(new Integer(88), map.get(entry.getKey()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        Map<K, V> base = new HashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        Map<K, V> trans = TransformedMap\n+                .transformingMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(\"1\", trans.get(\"A\"));\n+        assertEquals(\"2\", trans.get(\"B\"));\n+        assertEquals(\"3\", trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        Map<K, V> base = new HashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        Map<K, V> trans = TransformedMap\n+                .transformedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(new Integer(1), trans.get(\"A\"));\n+        assertEquals(new Integer(2), trans.get(\"B\"));\n+        assertEquals(new Integer(3), trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/TransformedSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.TransformerUtils;\n+import org.apache.commons.collections.collection.TransformedCollectionTest;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the {@link TransformedSortedMap}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class TransformedSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    public TransformedSortedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TransformedSortedMapTest.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public SortedMap<K, V> makeObject() {\n+        return TransformedSortedMap.transformingSortedMap(new TreeMap<K, V>(),\n+                (Transformer<? super K, ? extends K>) TransformerUtils.nopTransformer(),\n+                (Transformer<? super V, ? extends V>) TransformerUtils.nopTransformer());\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testTransformedMap() {\n+        Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        SortedMap<K, V> map = TransformedSortedMap\n+                .transformingSortedMap(\n+                        new TreeMap<K, V>(),\n+                        (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n+                        null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(new Integer((String) els[i])));\n+            try {\n+                map.containsKey(els[i]);\n+                fail();\n+            } catch (ClassCastException ex) {}\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(els[i], map.get(new Integer((String) els[i])));\n+        }\n+\n+        try {\n+            map.remove(els[0]);\n+            fail();\n+        } catch (ClassCastException ex) {}\n+        assertEquals(els[0], map.remove(new Integer((String) els[0])));\n+\n+        map = TransformedSortedMap\n+                .transformingSortedMap(\n+                        new TreeMap<K, V>(),\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(new Integer((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(new Integer((String) els[i]), map.get(els[i]));\n+        }\n+\n+        assertEquals(new Integer((String) els[0]), map.remove(els[0]));\n+\n+        Set<Map.Entry<K, V>> entrySet = map.entrySet();\n+        Map.Entry<K, V>[] array = entrySet.toArray(new Map.Entry[0]);\n+        array[0].setValue((V) \"66\");\n+        assertEquals(new Integer(66), array[0].getValue());\n+        assertEquals(new Integer(66), map.get(array[0].getKey()));\n+\n+        Map.Entry<K, V> entry = entrySet.iterator().next();\n+        entry.setValue((V) \"88\");\n+        assertEquals(new Integer(88), entry.getValue());\n+        assertEquals(new Integer(88), map.get(entry.getKey()));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        SortedMap<K, V> trans = TransformedSortedMap\n+                .transformingSortedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(\"1\", trans.get(\"A\"));\n+        assertEquals(\"2\", trans.get(\"B\"));\n+        assertEquals(\"3\", trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        SortedMap<K, V> base = new TreeMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        SortedMap<K, V> trans = TransformedSortedMap\n+                .transformedSortedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(new Integer(1), trans.get(\"A\"));\n+        assertEquals(new Integer(2), trans.get(\"B\"));\n+        assertEquals(new Integer(3), trans.get(\"C\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(new Integer(4), trans.get(\"D\"));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/UnmodifiableMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Extension of {@link AbstractMapTest} for exercising the\n+ * {@link UnmodifiableMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Phil Steitz\n+ */\n+public class UnmodifiableMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n+\n+    public UnmodifiableMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public IterableMap<K, V> makeObject() {\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(new HashMap<K, V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public IterableMap<K, V> makeFullMap() {\n+        Map<K, V> m = new HashMap<K, V>();\n+        addSampleMappings(m);\n+        return (IterableMap<K, V>) UnmodifiableMap.unmodifiableMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        Map<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableMap.unmodifiableMap(map));\n+\n+        try {\n+            UnmodifiableMap.unmodifiableMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/UnmodifiableOrderedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.OrderedMap;\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Extension of {@link AbstractOrderedMapTest} for exercising the\n+ * {@link UnmodifiableOrderedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class UnmodifiableOrderedMapTest<K, V> extends AbstractOrderedMapTest<K, V> {\n+\n+    public UnmodifiableOrderedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public OrderedMap<K, V> makeObject() {\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(ListOrderedMap.listOrderedMap(new HashMap<K, V>()));\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public OrderedMap<K, V> makeFullMap() {\n+        OrderedMap<K, V> m = ListOrderedMap.listOrderedMap(new HashMap<K, V>());\n+        addSampleMappings(m);\n+        return UnmodifiableOrderedMap.unmodifiableOrderedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        OrderedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableOrderedMap.unmodifiableOrderedMap(map));\n+\n+        try {\n+            UnmodifiableOrderedMap.unmodifiableOrderedMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableOrderedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableOrderedMap.fullCollection.version3.1.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/map/UnmodifiableSortedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.Unmodifiable;\n+\n+/**\n+ * Extension of {@link AbstractSortedMapTest} for exercising the\n+ * {@link UnmodifiableSortedMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision$\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class UnmodifiableSortedMapTest<K, V> extends AbstractSortedMapTest<K, V> {\n+\n+    public UnmodifiableSortedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-------------------------------------------------------------------\n+\n+    @Override\n+    public SortedMap<K, V> makeObject() {\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(new TreeMap<K, V>());\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeFullMap() {\n+        SortedMap<K, V> m = new TreeMap<K, V>();\n+        addSampleMappings(m);\n+        return UnmodifiableSortedMap.unmodifiableSortedMap(m);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        SortedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableSortedMap.unmodifiableSortedMap(map));\n+\n+        try {\n+            UnmodifiableSortedMap.unmodifiableSortedMap(null);\n+            fail();\n+        } catch (IllegalArgumentException ex) {}\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableSortedMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/UnmodifiableSortedMap.fullCollection.version3.1.obj\");\n+//    }\n+}", "timestamp": 1352893014, "metainfo": ""}