{"sha": "c95ade5f5cdc734d1c136e4a3bdc0a935150f87b", "log": "Improve implementation of TreeList to perform better, fix bugs bug 26680, 28930   ", "commit": "\n--- a/src/java/org/apache/commons/collections/list/TreeList.java\n+++ b/src/java/org/apache/commons/collections/list/TreeList.java\n \n import java.util.AbstractList;\n import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.OrderedIterator;\n \n /**\n  * A <code>List</code> implementation that is optimised for fast insertions and\n  * than both an <code>ArrayList</code> and a <code>LinkedList</code> where elements\n  * are inserted and removed repeatedly from anywhere in the list.\n  * <p>\n- * The trade-off versus <code>ArrayList</code> is memory usage. <code>TreeList</code>\n- * stores each entry in an object which uses up more memory. Also, <code>ArrayList</code>\n- * is faster if additions and removals only occur at the end of the list, not in the middle.\n+ * The following relative performance statistics are indicative of this class:\n+ * <pre>\n+ *              get  add  insert  iterate  remove\n+ * TreeList       3    5       1       2       1\n+ * ArrayList      1    1      40       1      40\n+ * LinkedList  5800    1     350       2     325\n+ * </pre>\n+ * <code>ArrayList</code> is a good general purpose list implementation.\n+ * It is faster than <code>TreeList</code> for most operations except inserting\n+ * and removing in the middle of the list. <code>ArrayList</code> also uses less\n+ * memory as <code>TreeList</code> uses one object per entry.\n  * <p>\n- * The trade-off versus <code>LinkedList</code> is based on how you use the list.\n- * If additions and removals only occur at the start or end of the list, not in the\n- * middle then <code>LinkedList</code> is faster.\n- * <p>\n- * The following performance statistics are indicative of this class:\n- * <pre>\n- *           add   insert      get\n- * TreeList  300      501      110\n- * ArrayList  70    20390       20\n- * LinkedList 50   226636   279742\n- * </pre>\n+ * <code>LinkedList</code> is rarely a good choice of implementation.\n+ * <code>TreeList</code> is almost always a good replacement for it, although it\n+ * does use sligtly more memory.\n  * \n  * @since Commons Collections 3.1\n- * @version $Revision: 1.1 $ $Date: 2004/05/10 19:59:03 $\n+ * @version $Revision: 1.2 $ $Date: 2004/05/12 23:24:45 $\n  *\n  * @author Joerg Schmuecker\n  * @author Stephen Colebourne\n  */\n public class TreeList extends AbstractList {\n-//    Add; insert; get\n-//    tree   = 980;170;50;\n-//    array  = 280;6920;0;\n-//    linked = 380;55480;55800;\n+//    add; toArray; iterator; insert; get; indexOf; remove\n+//    TreeList = 1260;7360;3080;  160;   170;3400;  170;\n+//   ArrayList =  220;1480;1760; 6870;    50;1540; 7200;\n+//  LinkedList =  270;7360;3350;55860;290720;2910;55200;\n \n     /** The root node in the AVL tree */\n     private AVLNode root;\n      * \n      * @return an iterator over the list\n      */\n-//    public Iterator iterator() {\n-//        // override to go 65% faster\n-//        if (size() == 0) {\n-//            return IteratorUtils.EMPTY_ITERATOR;\n-//        }\n-//        return new TreeIterator(this);\n-//    }\n+    public Iterator iterator() {\n+        // override to go 75% faster\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Gets a ListIterator over the list.\n+     * \n+     * @return the new iterator\n+     */\n+    public ListIterator listIterator() {\n+        // override to go 75% faster\n+        return listIterator(0);\n+    }\n+\n+    /**\n+     * Gets a ListIterator over the list.\n+     * \n+     * @param fromIndex  the index to start from\n+     * @return the new iterator\n+     */\n+    public ListIterator listIterator(int fromIndex) {\n+        // override to go 75% faster\n+        // cannot use IteratorUtils.EMPTY_ITERATOR as iterator.add() must work\n+        checkInterval(fromIndex, 0, size());\n+        return new TreeListIterator(this, fromIndex);\n+    }\n \n     /**\n      * Searches for the index of an object in the list.\n      * @return the list as an array\n      */\n     public Object[] toArray() {\n-        // override to go 40% faster\n+        // override to go 20% faster\n         Object[] array = new Object[size()];\n         if (root != null) {\n             root.toArray(array, root.relativePosition);\n      * @param obj  the element to add\n      */\n     public void add(int index, Object obj) {\n+        modCount++;\n         checkInterval(index, 0, size());\n         if (root == null) {\n-            root = new AVLNode(index, obj);\n+            root = new AVLNode(index, obj, null, null);\n         } else {\n             root = root.insert(index, obj);\n         }\n      * @return the previous object at that index\n      */\n     public Object remove(int index) {\n+        modCount++;\n         checkInterval(index, 0, size() - 1);\n         Object result = get(index);\n         root = root.remove(index);\n      * Clears the list, removing all entries.\n      */\n     public void clear() {\n+        modCount++;\n         root = null;\n         size = 0;\n     }\n      * <p>\n      * This node contains the real work.\n      * TreeList is just there to implement {@link java.util.List}.\n+     * The nodes don't know the index of the object they are holding.  They\n+     * do know however their position relative to their parent node.\n+     * This allows to calculate the index of a node while traversing the tree.\n+     * <p>\n+     * The Faedelung calculation stores a flag for both the left and right child\n+     * to indicate if they are a child (false) or a link as in linked list (true).\n      */\n     static class AVLNode {\n-        /** The left child node */\n+        /** The left child node or the predecessor if {@link #leftIsPrevious}.*/\n         private AVLNode left;\n-        /** The right child node */\n+        /** Flag indicating that left reference is not a subtree but the predecessor. */\n+        private boolean leftIsPrevious;\n+        /** The right child node or the successor if {@link #rightIsNext}. */\n         private AVLNode right;\n-        /** How many levels of left/right are below this one */\n+        /** Flag indicating that right reference is not a subtree but the successor. */\n+        private boolean rightIsNext;\n+        /** How many levels of left/right are below this one. */\n         private int height;\n-        /** The relative position, root holds absolute position */\n+        /** The relative position, root holds absolute position. */\n         private int relativePosition;\n-        /** The stored element */\n+        /** The stored element. */\n         private Object value;\n \n         /**\n          * Constructs a new node with a relative position.\n          * \n          * @param relativePosition  the relative position of the node\n-         * @param obj  the element\n-         */\n-        public AVLNode(int relativePosition, Object obj) {\n-            super();\n+         * @param obj  the value for the ndoe\n+         * @param rightFollower the node with the value following this one\n+         * @param leftFollower the node with the value leading this one\n+         */\n+        private AVLNode(int relativePosition, Object obj, AVLNode rightFollower, AVLNode leftFollower) {\n             this.relativePosition = relativePosition;\n-            this.value = obj;\n+            value = obj;\n+            rightIsNext = true;\n+            leftIsPrevious = true;\n+            right = rightFollower;\n+            left = leftFollower;\n         }\n \n         /**\n                 return this;\n             }\n \n-            AVLNode nextNode = ((indexRelativeToMe < 0) ? left : right);\n+            AVLNode nextNode = ((indexRelativeToMe < 0) ? getLeftSubTree() : getRightSubTree());\n             if (nextNode == null) {\n-                int i = 1;\n+                return null;\n             }\n             return nextNode.get(indexRelativeToMe);\n         }\n          * Locate the index that contains the specified object.\n          */\n         int indexOf(Object object, int index) {\n-            if (left != null) {\n+            if (getLeftSubTree() != null) {\n                 int result = left.indexOf(object, index + left.relativePosition);\n                 if (result != -1) {\n                     return result;\n             if (value == null ? value == object : value.equals(object)) {\n                 return index;\n             }\n-            if (right != null) {\n+            if (getRightSubTree() != null) {\n                 return right.indexOf(object, index + right.relativePosition);\n             }\n             return -1;\n \n         /**\n          * Stores the node and its children into the array specified.\n+         * \n+         * @param array the array to be filled\n+         * @param index the index of this node\n          */\n         void toArray(Object[] array, int index) {\n             array[index] = value;\n-            if (left != null) {\n+            if (getLeftSubTree() != null) {\n                 left.toArray(array, index + left.relativePosition);\n             }\n-            if (right != null) {\n+            if (getRightSubTree() != null) {\n                 right.toArray(array, index + right.relativePosition);\n             }\n+        }\n+\n+        /**\n+         * Gets the next node in the list after this one.\n+         * \n+         * @return the next node\n+         */\n+        AVLNode next() {\n+            if (rightIsNext || right == null) {\n+                return right;\n+            }\n+            return right.min();\n+        }\n+\n+        /**\n+         * Gets the node in the list before this one.\n+         * \n+         * @return the previous node\n+         */\n+        AVLNode previous() {\n+            if (leftIsPrevious || left == null) {\n+                return left;\n+            }\n+            return left.max();\n+        }\n+\n+        /**\n+         * Inserts a node at the position index.  \n+         * \n+         * @param index is the index of the position relative to the position of \n+         * the parent node.\n+         * @param obj is the object to be stored in the position.\n+         */\n+        AVLNode insert(int index, Object obj) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe <= 0) {\n+                return insertOnLeft(indexRelativeToMe, obj);\n+            } else {\n+                return insertOnRight(indexRelativeToMe, obj);\n+            }\n+        }\n+\n+        private AVLNode insertOnLeft(int indexRelativeToMe, Object obj) {\n+            AVLNode ret = this;\n+\n+            if (getLeftSubTree() == null) {\n+                setLeft(new AVLNode(-1, obj, this, left), null);\n+            } else {\n+                setLeft(left.insert(indexRelativeToMe, obj), null);\n+            }\n+\n+            if (relativePosition >= 0) {\n+                relativePosition++;\n+            }\n+            ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        private AVLNode insertOnRight(int indexRelativeToMe, Object obj) {\n+            AVLNode ret = this;\n+\n+            if (getRightSubTree() == null) {\n+                setRight(new AVLNode(+1, obj, right, this), null);\n+            } else {\n+                setRight(right.insert(indexRelativeToMe, obj), null);\n+            }\n+            if (relativePosition < 0) {\n+                relativePosition--;\n+            }\n+            ret = balance();\n+            recalcHeight();\n+            return ret;\n+        }\n+\n+        //-----------------------------------------------------------------------\n+        /**\n+         * Gets the left node, returning null if its a faedelung.\n+         */\n+        private AVLNode getLeftSubTree() {\n+            return (leftIsPrevious ? null : left);\n+        }\n+\n+        /**\n+         * Gets the right node, returning null if its a faedelung.\n+         */\n+        private AVLNode getRightSubTree() {\n+            return (rightIsNext ? null : right);\n+        }\n+\n+        /**\n+         * Gets the rightmost child of this node.\n+         * \n+         * @return the rightmost child (greatest index)\n+         */\n+        private AVLNode max() {\n+            return (getRightSubTree() == null) ? this : right.max();\n+        }\n+\n+        /**\n+         * Gets the leftmost child of this node.\n+         * \n+         * @return the leftmost child (smallest index)\n+         */\n+        private AVLNode min() {\n+            return (getLeftSubTree() == null) ? this : left.min();\n+        }\n+\n+        /**\n+         * Removes the node at a given position.\n+         * \n+         * @param index is the index of the element to be removed relative to the position of \n+         * the parent node of the current node.\n+         */\n+        AVLNode remove(int index) {\n+            int indexRelativeToMe = index - relativePosition;\n+\n+            if (indexRelativeToMe == 0) {\n+                return removeSelf();\n+            }\n+            if (indexRelativeToMe > 0) {\n+                setRight(right.remove(indexRelativeToMe), right.right);\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                setLeft(left.remove(indexRelativeToMe), left.left);\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode removeMax() {\n+            if (getRightSubTree() == null) {\n+                return removeSelf();\n+            }\n+            setRight(right.removeMax(), right.right);\n+            if (relativePosition < 0) {\n+                relativePosition++;\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode removeMin() {\n+            if (getLeftSubTree() == null) {\n+                return removeSelf();\n+            }\n+            setLeft(left.removeMin(), left.left);\n+            if (relativePosition > 0) {\n+                relativePosition--;\n+            }\n+            recalcHeight();\n+            return balance();\n+        }\n+\n+        private AVLNode removeSelf() {\n+            if (getRightSubTree() == null && getLeftSubTree() == null)\n+                return null;\n+            if (getRightSubTree() == null) {\n+                if (relativePosition > 0) {\n+                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n+                }\n+                left.max().setRight(null, right);\n+                return left;\n+            }\n+            if (getLeftSubTree() == null) {\n+                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n+                right.min().setLeft(null, left);\n+                return right;\n+            }\n+\n+            if (heightRightMinusLeft() > 0) {\n+                AVLNode rightMin = right.min();\n+                value = rightMin.value;\n+                if (leftIsPrevious) {\n+                    left = rightMin.left;\n+                }\n+                right = right.removeMin();\n+                if (relativePosition < 0) {\n+                    relativePosition++;\n+                }\n+            } else {\n+                AVLNode leftMax = left.max();\n+                value = leftMax.value;\n+                if (rightIsNext) {\n+                    right = leftMax.right;\n+                }\n+                left = left.removeMax();\n+                if (relativePosition > 0) {\n+                    relativePosition--;\n+                }\n+            }\n+            recalcHeight();\n+            return this;\n         }\n \n         //-----------------------------------------------------------------------\n                     return this;\n                 case -2 :\n                     if (left.heightRightMinusLeft() > 0) {\n-                        setLeft(left.rotateLeft());\n+                        setLeft(left.rotateLeft(), null);\n                     }\n                     return rotateRight();\n                 case 2 :\n                     if (right.heightRightMinusLeft() < 0) {\n-                        setRight(right.rotateRight());\n+                        setRight(right.rotateRight(), null);\n                     }\n                     return rotateLeft();\n                 default :\n         }\n \n         /**\n+         * Gets the relative position.\n+         */\n+        private int getOffset(AVLNode node) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            return node.relativePosition;\n+        }\n+\n+        /**\n+         * Sets the relative position.\n+         */\n+        private int setOffset(AVLNode node, int newOffest) {\n+            if (node == null) {\n+                return 0;\n+            }\n+            int oldOffset = getOffset(node);\n+            node.relativePosition = newOffest;\n+            return oldOffset;\n+        }\n+\n+        /**\n+         * Sets the height by calculation.\n+         */\n+        private void recalcHeight() {\n+            height = Math.max(\n+                getLeftSubTree() == null ? -1 : getLeftSubTree().height,\n+                getRightSubTree() == null ? -1 : getRightSubTree().height) + 1;\n+        }\n+\n+        /**\n          * Returns the height of the node or -1 if the node is null.\n-         * \n-         * Convenience method.\n-         */\n-        private int getHeight(AVLNode n) {\n-            return (n == null ? -1 : n.height);\n-        }\n-\n-        /**\n-         * Returns the height difference\n+         */\n+        private int getHeight(AVLNode node) {\n+            return (node == null ? -1 : node.height);\n+        }\n+\n+        /**\n+         * Returns the height difference right - left\n          */\n         private int heightRightMinusLeft() {\n-            return getHeight(right) - getHeight(left);\n-        }\n-\n-        /**\n-         * Inserts a node at the position index.\n-         * \n-         * @param index  is the index of the position relative to the position of \n-         *  the parent node.\n-         * @param obj  is the object to be stored in the position.\n-         */\n-        AVLNode insert(int index, Object obj) {\n-            int indexRelativeToMe = index - relativePosition;\n-\n-            if (indexRelativeToMe <= 0) {\n-                return insertOnLeft(indexRelativeToMe, obj);\n-            } else {\n-                return insertOnRight(indexRelativeToMe, obj);\n-            }\n-        }\n-\n-        private AVLNode insertOnLeft(int indexRelativeToMe, Object obj) {\n-            AVLNode ret = this;\n-\n-            if (left == null) {\n-                left = new AVLNode(-1, obj);\n-            } else {\n-                left = left.insert(indexRelativeToMe, obj);\n-\n-            }\n-            if (relativePosition >= 0) {\n-                relativePosition++;\n-            }\n-            ret = balance();\n-            recalcHeight();\n-            return ret;\n-        }\n-\n-        private AVLNode insertOnRight(int indexRelativeToMe, Object obj) {\n-            AVLNode ret = this;\n-\n-            if (right == null) {\n-                right = new AVLNode(+1, obj);\n-            } else {\n-                right = right.insert(indexRelativeToMe, obj);\n-\n-            }\n-            if (relativePosition < 0) {\n-                relativePosition--;\n-            }\n-            ret = balance();\n-            recalcHeight();\n-            return ret;\n-        }\n-\n-        private void recalcHeight() {\n-            height = Math.max(left == null ? -1 : left.height, right == null ? -1 : right.height) + 1;\n+            return getHeight(getRightSubTree()) - getHeight(getLeftSubTree());\n         }\n \n         private AVLNode rotateLeft() {\n-            AVLNode newTop = right;\n-            AVLNode movedNode = right.left;\n-\n-            int newTopPosition = relativePosition + getOffset(right);\n-            int myNewPosition = -right.relativePosition;\n-            int movedPosition = getOffset(right) + getOffset(movedNode);\n-\n-            setRight(right.left);\n-            newTop.setLeft(this);\n+            AVLNode newTop = right; // can't be faedelung!\n+            AVLNode movedNode = getRightSubTree().getLeftSubTree();\n+\n+            int newTopPosition = relativePosition + getOffset(newTop);\n+            int myNewPosition = -newTop.relativePosition;\n+            int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+\n+            setRight(movedNode, newTop);\n+            newTop.setLeft(this, null);\n \n             setOffset(newTop, newTopPosition);\n             setOffset(this, myNewPosition);\n             return newTop;\n         }\n \n-        private int getOffset(AVLNode node) {\n-            if (node == null) {\n-                return 0;\n-            }\n-            return node.relativePosition;\n-        }\n-\n         private AVLNode rotateRight() {\n-            AVLNode newTop = left;\n-            AVLNode movedNode = left.right;\n-\n-            int newTopPosition = relativePosition + getOffset(left);\n-            int myNewPosition = -left.relativePosition;\n-            int movedPosition = getOffset(left) + getOffset(movedNode);\n-\n-            setLeft(left.right);\n-            newTop.setRight(this);\n+            AVLNode newTop = left; // can't be faedelung\n+            AVLNode movedNode = getLeftSubTree().getRightSubTree();\n+\n+            int newTopPosition = relativePosition + getOffset(newTop);\n+            int myNewPosition = -newTop.relativePosition;\n+            int movedPosition = getOffset(newTop) + getOffset(movedNode);\n+\n+            setLeft(movedNode, newTop);\n+            newTop.setRight(this, null);\n \n             setOffset(newTop, newTopPosition);\n             setOffset(this, myNewPosition);\n             setOffset(movedNode, movedPosition);\n             return newTop;\n-\n-        }\n-\n-        private void setLeft(AVLNode node) {\n-            left = node;\n+        }\n+\n+        private void setLeft(AVLNode node, AVLNode previous) {\n+            leftIsPrevious = (node == null);\n+            left = (leftIsPrevious ? previous : node);\n             recalcHeight();\n         }\n \n-        private int setOffset(AVLNode node, int newOffest) {\n-            if (node == null) {\n-                return 0;\n-            }\n-            int oldOffset = getOffset(node);\n-            node.relativePosition = newOffest;\n-            return oldOffset;\n-        }\n-\n-        private void setRight(AVLNode node) {\n-            right = node;\n+        private void setRight(AVLNode node, AVLNode next) {\n+            rightIsNext = (node == null);\n+            right = (rightIsNext ? next : node);\n             recalcHeight();\n         }\n \n-        /**\n-         * Removes the node at a given position.\n-         * \n-         * @param index  is the index of the element to be removed relative to\n-         *  the position of the parent node of the current node.\n-         * @return the new root of the tree\n-         */\n-        AVLNode remove(int index) {\n-            int indexRelativeToMe = index - relativePosition;\n-\n-            if (indexRelativeToMe == 0) {\n-                return removeSelf();\n-            }\n-            if (indexRelativeToMe > 0) {\n-                right = right.remove(indexRelativeToMe);\n-                if (relativePosition < 0) {\n-                    relativePosition++;\n-                }\n-            } else {\n-                left = left.remove(indexRelativeToMe);\n-                if (relativePosition > 0) {\n-                    relativePosition--;\n-                }\n-            }\n-            recalcHeight();\n-            return balance();\n-        }\n-\n-        private AVLNode removeSelf() {\n-            if (right == null && left == null)\n-                return null;\n-            if (right == null) {\n-                if (relativePosition > 0) {\n-                    left.relativePosition += relativePosition + (relativePosition > 0 ? 0 : 1);\n-                }\n-                return left;\n-            }\n-            if (left == null) {\n-                right.relativePosition += relativePosition - (relativePosition < 0 ? 0 : 1);\n-                return right;\n-            }\n-\n-            if (heightRightMinusLeft() > 0) {\n-                value = right.min().value;\n-                right = right.removeMin();\n-                if (relativePosition < 0) {\n-                    relativePosition++;\n-                }\n-            } else {\n-                value = left.max().value;\n-                left = left.removeMax();\n-                if (relativePosition > 0) {\n-                    relativePosition--;\n-                }\n-            }\n-            recalcHeight();\n-            return this;\n-        }\n-\n-        private AVLNode removeMin() {\n-            if (left == null) {\n-                return removeSelf();\n-            }\n-            left = left.removeMin();\n-            adjustOffsetForRemovalLeft();\n-            recalcHeight();\n-            return balance();\n-        }\n-\n-        private void adjustOffsetForRemovalLeft() {\n-            if (relativePosition > 0) {\n-                relativePosition--;\n-            }\n-        }\n-\n-        private void adjustOffsetForRemovalRight() {\n-            if (relativePosition < 0) {\n-                relativePosition++;\n-            }\n-        }\n-\n-        private AVLNode min() {\n-            return (left == null) ? this : left.min();\n-        }\n-\n-        private AVLNode removeMax() {\n-            if (right == null) {\n-                return removeSelf();\n-            }\n-            right = right.removeMax();\n-            adjustOffsetForRemovalRight();\n-            recalcHeight();\n-            return balance();\n-        }\n-\n-        private AVLNode max() {\n-            return (right == null) ? this : right.max();\n-        }\n-\n-        /**\n-         * Used for debugging.\n-         */\n-        public String toString() {\n-            return \"AVLNode(\" + relativePosition + \",\" + (left != null) + \",\" + value + \",\" + (right != null) + \")\";\n-        }\n-\n-    }\n-\n-    //-----------------------------------------------------------------------\n-//    /**\n-//     * Iterator over the TreeList.\n-//     * <p>\n-//     * This iterator is good at iteration, but bad at removal.\n-//     * Implementing ListIterator would be even more complex, so has been avoided.\n-//     */\n-//    static class TreeIterator implements Iterator {\n-//        /** The parent list */\n-//        private final TreeList parent;\n-//        /** A stack built up during iteration to avoid each node referencing its parent */\n-//        private ArrayStack stack = new ArrayStack();\n-//        /** Whether remove is currently allowed */\n-//        private boolean canRemoveOrSet;\n-//        /** The last node returned */\n-//        private AVLNode lastNode;\n-//        /** The next index */\n-//        private int nextIndex;\n-//        \n-//        /**\n-//         * Constructor.\n-//         * \n-//         * @param parent  the parent list\n-//         */\n-//        TreeIterator(TreeList parent) {\n-//            this.parent = parent;\n+//      private void checkFaedelung() {\n+//          AVLNode maxNode = left.max();\n+//          if (!maxNode.rightIsFaedelung || maxNode.right != this) {\n+//              throw new RuntimeException(maxNode + \" should right-faedel to \" + this);\n+//          }\n+//          AVLNode minNode = right.min();\n+//          if (!minNode.leftIsFaedelung || minNode.left != this) {\n+//              throw new RuntimeException(maxNode + \" should left-faedel to \" + this);\n+//          }\n+//      }\n+//\n+//        private int checkTreeDepth() {\n+//            int hright = (getRightSubTree() == null ? -1 : getRightSubTree().checkTreeDepth());\n+//            //          System.out.print(\"checkTreeDepth\");\n+//            //          System.out.print(this);\n+//            //          System.out.print(\" left: \");\n+//            //          System.out.print(_left);\n+//            //          System.out.print(\" right: \");\n+//            //          System.out.println(_right);\n+//\n+//            int hleft = (left == null ? -1 : left.checkTreeDepth());\n+//            if (height != Math.max(hright, hleft) + 1) {\n+//                throw new RuntimeException(\n+//                    \"height should be max\" + hleft + \",\" + hright + \" but is \" + height);\n+//            }\n+//            return height;\n //        }\n //\n-//        private AVLNode findNext() {\n-//            AVLNode node = lastNode;\n-//            if (node == null) {\n-//                node = parent.root;\n-//                while (node.left != null) {\n-//                    stack.add(node);\n-//                    node = node.left;\n-//                }\n-//                return node;\n+//        private int checkLeftSubNode() {\n+//            if (getLeftSubTree() == null) {\n+//                return 0;\n //            }\n-//            if (node.right != null) {\n-//                node = node.right;\n-//                while (node.left != null) {\n-//                    stack.add(node);\n-//                    node = node.left;\n-//                }\n-//                return node;\n+//            int count = 1 + left.checkRightSubNode();\n+//            if (left.relativePosition != -count) {\n+//                throw new RuntimeException();\n //            }\n-//            if (stack.isEmpty()) {\n-//                throw new NoSuchElementException();\n+//            return count + left.checkLeftSubNode();\n+//        }\n+//        \n+//        private int checkRightSubNode() {\n+//            AVLNode right = getRightSubTree();\n+//            if (right == null) {\n+//                return 0;\n //            }\n-//            return (AVLNode) stack.pop();\n+//            int count = 1;\n+//            count += right.checkLeftSubNode();\n+//            if (right.relativePosition != count) {\n+//                throw new RuntimeException();\n+//            }\n+//            return count + right.checkRightSubNode();\n //        }\n-//\n-//        public boolean hasNext() {\n-//            return (nextIndex < parent.size());\n-//        }\n-//\n-//        public Object next() {\n-//            if (hasNext() == false) {\n-//                throw new NoSuchElementException();\n-//            }\n-//            lastNode = findNext();\n-//            nextIndex++;\n-//            canRemoveOrSet = true;\n-//            return lastNode.getValue();\n-//        }\n-//\n-//        public int nextIndex() {\n-//            return nextIndex;\n-//        }\n-//\n-////        public boolean hasPrevious() {\n-////            return (nextIndex > 0);\n-////        }\n-////\n-////        public Object previous() {\n-////            if (hasPrevious() == false) {\n-////                throw new NoSuchElementException();\n-////            }\n-////            return parent.get(nextIndex--);\n-////        }\n-////\n-////        public int previousIndex() {\n-////            return nextIndex() - 1;\n-////        }\n-//\n-//        public void remove() {\n-//            if (canRemoveOrSet == false) {\n-//                throw new IllegalStateException();\n-//            }\n-//            if (nextIndex == 1) {\n-//                parent.remove(--nextIndex);\n-//                this.lastNode = null;\n-//                this.stack.clear();\n-//            } else if (hasNext()) {\n-//                AVLNode nextNode = findNext();\n-//                parent.remove(--nextIndex);\n-//                TreeIterator it = new TreeIterator(parent);\n-//                AVLNode node = null;\n-//                while (it.hasNext()) {\n-//                    it.next();\n-//                    if (it.lastNode == nextNode) {\n-//                        this.stack = it.stack;\n-//                        break;\n-//                    }\n-//                    node = it.lastNode;\n-//                }\n-//                this.lastNode = node;\n-//            } else {\n-//                parent.remove(--nextIndex);\n-//                this.lastNode = parent.root.get(parent.size() - 1);\n-//                this.stack.clear();\n-//            }\n-//            canRemoveOrSet = false;\n-//        }\n-//\n-////        public void set(Object obj) {\n-////            if (canRemoveOrSet == false) {\n-////                throw new IllegalStateException();\n-////            }\n-////            lastNode.setValue(obj);\n-////        }\n-////\n-////        public void add(Object obj) {\n-////        }\n-//    }\n+\n+        /**\n+         * Used for debugging.\n+         */\n+        public String toString() {\n+            return \"AVLNode(\" + relativePosition + \",\" + (left != null) + \",\" + value +\n+                \",\" + (getRightSubTree() != null) + \", faedelung \" + rightIsNext + \" )\";\n+        }\n+    }\n+\n+    /**\n+     * A list iterator over the linked list.\n+     */\n+    static class TreeListIterator implements ListIterator, OrderedIterator {\n+        /** The parent list */\n+        protected final TreeList parent;\n+        /**\n+         * The node that will be returned by {@link #next()}. If this is equal\n+         * to {@link AbstractLinkedList#header} then there are no more values to return.\n+         */\n+        protected AVLNode next;\n+        /**\n+         * The index of {@link #next}.\n+         */\n+        protected int nextIndex;\n+        /**\n+         * The last node that was returned by {@link #next()} or {@link\n+         * #previous()}. Set to <code>null</code> if {@link #next()} or {@link\n+         * #previous()} haven't been called, or if the node has been removed\n+         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n+         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n+         * this behaviour.\n+         */\n+        protected AVLNode current;\n+        /**\n+         * The index of {@link #current}.\n+         */\n+        protected int currentIndex;\n+        /**\n+         * The modification count that the list is expected to have. If the list\n+         * doesn't have this count, then a\n+         * {@link java.util.ConcurrentModificationException} may be thrown by\n+         * the operations.\n+         */\n+        protected int expectedModCount;\n+\n+        /**\n+         * Create a ListIterator for a list.\n+         * \n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n+         */\n+        protected TreeListIterator(TreeList parent, int fromIndex) throws IndexOutOfBoundsException {\n+            super();\n+            this.parent = parent;\n+            this.expectedModCount = parent.modCount;\n+            this.next = (parent.root == null ? null : parent.root.get(fromIndex));\n+            this.nextIndex = fromIndex;\n+        }\n+\n+        /**\n+         * Checks the modification count of the list is the value that this\n+         * object expects.\n+         * \n+         * @throws ConcurrentModificationException If the list's modification\n+         * count isn't the value that was expected.\n+         */\n+        protected void checkModCount() {\n+            if (parent.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return (nextIndex < parent.size());\n+        }\n+\n+        public Object next() {\n+            checkModCount();\n+            if (!hasNext()) {\n+                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n+            }\n+            if (next == null) {\n+                next = parent.root.get(nextIndex);\n+            }\n+            Object value = next.getValue();\n+            current = next;\n+            currentIndex = nextIndex++;\n+            next = next.next();\n+            return value;\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (nextIndex > 0);\n+        }\n+\n+        public Object previous() {\n+            checkModCount();\n+            if (!hasPrevious()) {\n+                throw new NoSuchElementException(\"Already at start of list.\");\n+            }\n+            if (next == null) {\n+                next = parent.root.get(nextIndex - 1);\n+            } else {\n+                next = next.previous();\n+            }\n+            Object value = next.getValue();\n+            current = next;\n+            currentIndex = --nextIndex;\n+            return value;\n+        }\n+\n+        public int nextIndex() {\n+            return nextIndex;\n+        }\n+\n+        public int previousIndex() {\n+            return nextIndex() - 1;\n+        }\n+\n+        public void remove() {\n+            checkModCount();\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            parent.remove(currentIndex);\n+            current = null;\n+            currentIndex = -1;\n+            nextIndex--;\n+            expectedModCount++;\n+        }\n+\n+        public void set(Object obj) {\n+            checkModCount();\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            current.setValue(obj);\n+        }\n+\n+        public void add(Object obj) {\n+            checkModCount();\n+            parent.add(nextIndex, obj);\n+            current = null;\n+            currentIndex = -1;\n+            nextIndex++;\n+            expectedModCount++;\n+        }\n+    }\n \n }\n--- a/src/test/org/apache/commons/collections/list/TestTreeList.java\n+++ b/src/test/org/apache/commons/collections/list/TestTreeList.java\n  * JUnit tests\n  * \n  * @since Commons Collections 3.1\n- * @version $Revision: 1.1 $ $Date: 2004/05/10 19:59:03 $\n+ * @version $Revision: 1.2 $ $Date: 2004/05/12 23:24:44 $\n  *\n  * @author Joerg Schmuecker\n  */\n \n     public static void main(String[] args) {\n         junit.textui.TestRunner.run(suite());\n-//        System.out.println(\"              add; insert; get; indexOf; remove\");\n+//        System.out.println(\"         add; toArray; iterator; insert; get; indexOf; remove\");\n //        System.out.print(\"   TreeList = \");\n //        benchmark(new TreeList());\n //        System.out.print(\"\\n  ArrayList = \");\n //        benchmark(new java.util.ArrayList());\n //        System.out.print(\"\\n LinkedList = \");\n+//        benchmark(new java.util.LinkedList());\n //        benchmark(new NodeCachingLinkedList());\n-\n-//        benchmark(new java.util.LinkedList());\n     }\n \n     public static Test suite() {\n         System.out.print(System.currentTimeMillis() - start + \";\");\n         \n         start = System.currentTimeMillis();\n-        for (int i = 0; i < 10000; i++) {\n+        for (int i = 0; i < 50000; i++) {\n             int j = (int) (Math.random() * 110000);\n             l.get(j);\n         }", "timestamp": 1084404285, "metainfo": ""}