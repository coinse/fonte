{"sha": "adac97557392145d360644f3c97a44ad991642b6", "log": "Move SplitMapUtils test.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/TestSplitMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.IterableMap;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Put;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.Unmodifiable;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+import org.apache.commons.collections.map.HashedMap;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TestSplitMapUtils extends BulkTest {\n+    private Map<String, Integer> backingMap;\n+    private TransformedMap<String, String, String, Integer> transformedMap;\n+\n+    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public TestSplitMapUtils(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        backingMap = new HashMap<String, Integer>();\n+        transformedMap = TransformedMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n+                stringToInt);\n+        for (int i = 0; i < 10; i++) {\n+            transformedMap.put(String.valueOf(i), String.valueOf(i));\n+        }\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testReadableMap() {\n+        final IterableMap<String, Integer> map = SplitMapUtils.readableMap(transformedMap);\n+\n+        // basic\n+        for (int i = 0; i < 10; i++) {\n+            assertFalse(map.containsValue(String.valueOf(i)));\n+            assertEquals(i, map.get(String.valueOf(i)).intValue());\n+        }\n+\n+        // mapIterator\n+        MapIterator<String, Integer> it = map.mapIterator();\n+        while (it.hasNext()) {\n+            String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(Integer.valueOf(k), it.getValue());\n+        }\n+\n+        // unmodifiable\n+        assertTrue(map instanceof Unmodifiable);\n+\n+        // check individual operations\n+        int sz = map.size();\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.clear();\n+            }\n+        });\n+\n+        assertEquals(sz, map.size());\n+\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.put(\"foo\", 100);\n+            }\n+        });\n+\n+        final HashMap<String, Integer> m = new HashMap<String, Integer>();\n+        m.put(\"foo\", 100);\n+        m.put(\"bar\", 200);\n+        m.put(\"baz\", 300);\n+        attemptPutOperation(new Runnable() {\n+            public void run() {\n+                map.putAll(m);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        IterableMap<String, Integer> other = SplitMapUtils.readableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // remove\n+        for (int i = 0; i < 10; i++) {\n+            assertEquals(i, map.remove(String.valueOf(i)).intValue());\n+            assertEquals(--sz, map.size());\n+        }\n+        assertTrue(map.isEmpty());\n+        assertSame(map, SplitMapUtils.readableMap(map));\n+    }\n+\n+    public void testAlreadyReadableMap() {\n+        HashedMap<String, Integer> hashedMap = new HashedMap<String, Integer>();\n+        assertSame(hashedMap, SplitMapUtils.readableMap(hashedMap));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testWritableMap() {\n+        final Map<String, String> map = SplitMapUtils.writableMap(transformedMap);\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.get(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.entrySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.keySet();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.values();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.size();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.isEmpty();\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsKey(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.containsValue(null);\n+            }\n+        });\n+        attemptGetOperation(new Runnable() {\n+            public void run() {\n+                map.remove(null);\n+            }\n+        });\n+\n+        // equals, hashcode\n+        Map<String, String> other = SplitMapUtils.writableMap(transformedMap);\n+        assertEquals(other, map);\n+        assertEquals(other.hashCode(), map.hashCode());\n+\n+        // put\n+        int sz = backingMap.size();\n+        assertFalse(backingMap.containsKey(\"foo\"));\n+        map.put(\"new\", \"66\");\n+        assertEquals(++sz, backingMap.size());\n+\n+        // putall\n+        Map<String, String> more = new HashMap<String, String>();\n+        more.put(\"foo\", \"77\");\n+        more.put(\"bar\", \"88\");\n+        more.put(\"baz\", \"99\");\n+        map.putAll(more);\n+        assertEquals(sz + more.size(), backingMap.size());\n+\n+        // clear\n+        map.clear();\n+        assertTrue(backingMap.isEmpty());\n+        assertSame(map, SplitMapUtils.writableMap((Put<String, String>) map));\n+    }\n+\n+    public void testAlreadyWritableMap() {\n+        HashedMap<String, String> hashedMap = new HashedMap<String, String>();\n+        assertSame(hashedMap, SplitMapUtils.writableMap(hashedMap));\n+    }\n+\n+    private void attemptGetOperation(Runnable r) {\n+        attemptMapOperation(\"Put exposed as writable Map must not allow Get operations\", r);\n+    }\n+\n+    private void attemptPutOperation(Runnable r) {\n+        attemptMapOperation(\"Get exposed as writable Map must not allow Put operations\", r);\n+    }\n+\n+    private void attemptMapOperation(String s, Runnable r) {\n+        try {\n+            r.run();\n+            fail(s);\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+}", "timestamp": 1341350876, "metainfo": ""}