{"sha": "f4693f0adf5c9994127890877d018c4ba7bbca06", "log": "Clarify null argument behavior of IterableUtils and FluentIterable: decorators do not accept null values, whereas utility methods are null-safe wrt Iterable instances.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/FluentIterable.java\n+++ b/src/main/java/org/apache/commons/collections4/FluentIterable.java\n      * corresponding input iterator supports it.\n      *\n      * @param <T>  the element type\n-     * @param iterable  the iterable to wrap into a FluentIterable, may be null\n+     * @param iterable  the iterable to wrap into a FluentIterable, may not be null\n      * @return a new FluentIterable wrapping the provided iterable\n+     * @throws NullPointerException if iterable is null\n      */\n     public static <T> FluentIterable<T> of(final Iterable<T> iterable) {\n-        if (iterable == null) {\n-            @SuppressWarnings(\"unchecked\")\n-            final FluentIterable<T> empty = IterableUtils.EMPTY_ITERABLE;\n-            return empty;\n-        } else if (iterable instanceof FluentIterable<?>) {\n+        IterableUtils.checkNotNull(iterable);\n+        if (iterable instanceof FluentIterable<?>) {\n             return (FluentIterable<T>) iterable;\n         } else {\n             return new FluentIterable<T>(iterable);\n      * Returns a new FluentIterable whose iterator will first traverse\n      * the elements of the current iterable, followed by the elements\n      * of the provided iterable.\n-     * <p>\n-     * A <code>null</code> iterable will be treated as an empty iterable.\n-     *\n-     * @param other  the other iterable to combine, may be null\n+     *\n+     * @param other  the other iterable to combine, may not be null\n      * @return a new iterable, combining this iterable with other\n+     * @throws NullPointerException if other is null\n      */\n     public FluentIterable<E> append(final Iterable<? extends E> other) {\n         return of(IterableUtils.chainedIterable(iterable, other));\n      * <p>\n      * The returned iterable will traverse the elements in the following\n      * order: [1, 2, 3, 4, 5, 6, 7, 8]\n-     * <p>\n-     * A <code>null</code> iterable will be treated as an empty iterable.\n-     *\n-     * @param other  the other iterable to collate, may be null\n+     *\n+     * @param other  the other iterable to collate, may not be null\n      * @return a new iterable, collating this iterable with the other in natural order\n+     * @throws NullPointerException if other is null\n      * @see {@link org.apache.commons.collections4.iterators.CollatingIterator CollatingIterator}\n      */\n     public FluentIterable<E> collate(final Iterable<? extends E> other) {\n      * <p>\n      * The returned iterable will traverse the elements in the following\n      * order: [8, 7, 6, 5, 4, 3, 2, 1]\n-     * <p>\n-     * A <code>null</code> iterable will be treated as an empty iterable.\n      *\n      * @param comparator  the comparator to define an ordering, may be null,\n      *   in which case natural ordering will be used\n-     * @param other  the other iterable to collate, may be null\n+     * @param other  the other iterable to collate, may not be null\n      * @return a new iterable, collating this iterable with the other in natural order\n+     * @throws NullPointerException if other is null\n      * @see {@link org.apache.commons.collections4.iterators.CollatingIterator CollatingIterator}\n      */\n     public FluentIterable<E> collate(final Iterable<? extends E> other,\n      * the elements of this iterable and the other iterable in\n      * alternating order.\n      *\n-     * @param other  the other iterable to interleave\n+     * @param other  the other iterable to interleave, may not be null\n      * @return a new iterable, interleaving this iterable with others\n+     * @throws NullPointerException if other is null\n      */\n     public FluentIterable<E> zip(final Iterable<? extends E> other) {\n         return of(IterableUtils.zippingIterable(iterable, other));\n      * the elements of this iterable and the other iterables in\n      * alternating order.\n      *\n-     * @param others  the iterables to interleave\n+     * @param others  the iterables to interleave, may not be null\n      * @return a new iterable, interleaving this iterable with others\n+     * @throws NullPointerException if either of the provided iterables is null\n      */\n     public FluentIterable<E> zip(final Iterable<? extends E>... others) {\n-        @SuppressWarnings(\"unchecked\")\n-        Iterable<E>[] iterables = new Iterable[1 + others.length];\n-        iterables[0] = iterable;\n-        System.arraycopy(others, 0, iterables, 1, others.length);\n-        return of(IterableUtils.zippingIterable(iterables));\n+        return of(IterableUtils.zippingIterable(iterable, others));\n     }\n \n     // convenience methods\n--- a/src/main/java/org/apache/commons/collections4/IterableUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IterableUtils.java\n /**\n  * Provides utility methods and decorators for {@link Iterable} instances.\n  * <p>\n- * <b>Note</b>: by design, all provided utility methods will treat a {@code null}\n- * {@link Iterable} parameters the same way as an empty iterable. All other required\n- * parameters which are null, e.g. a {@link Predicate}, will result in a\n- * {@link NullPointerException}.\n+ * <b>Note</b>: this util class has been designed for fail-fast argument checking.\n+ * <ul>\n+ * <li>\n+ * all decorator methods are <b>NOT</b> null-safe wrt the provided Iterable argument, i.e.\n+ * they will throw a {@link NullPointerException} if a null Iterable is passed as argument.\n+ * <li>\n+ * all other utility methods are null-safe wrt the provided Iterable argument, i.e. they will\n+ * treat a null Iterable the same way as an empty one. Other arguments which are null,\n+ * e.g. a {@link Predicate}, will result in a {@link NullPointerException}. Exception: passing\n+ * a null {@link Comparator} is equivalent to a Comparator with natural ordering.\n+ * </ul>\n  *\n  * @since 4.1\n  * @version $Id$\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param a  the first iterable\n-     * @param b  the second iterable\n+     * @param a  the first iterable, may not be null\n+     * @param b  the second iterable, may not be null\n      * @return a new iterable, combining the provided iterables\n+     * @throws NullPointerException if either a or b is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param a  the first iterable\n-     * @param b  the second iterable\n-     * @param c  the third iterable\n+     * @param a  the first iterable, may not be null\n+     * @param b  the second iterable, may not be null\n+     * @param c  the third iterable, may not be null\n      * @return a new iterable, combining the provided iterables\n+     * @throws NullPointerException if either of the provided iterables is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param a  the first iterable\n-     * @param b  the second iterable\n-     * @param c  the third iterable\n-     * @param d  the fourth iterable\n+     * @param a  the first iterable, may not be null\n+     * @param b  the second iterable, may not be null\n+     * @param c  the third iterable, may not be null\n+     * @param d  the fourth iterable, may not be null\n      * @return a new iterable, combining the provided iterables\n+     * @throws NullPointerException if either of the provided iterables is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <E> Iterable<E> chainedIterable(final Iterable<? extends E> a,\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param iterables  the iterables to combine\n+     * @param iterables  the iterables to combine, may not be null\n      * @return a new iterable, combining the provided iterables\n+     * @throws NullPointerException if either of the provided iterables is null\n      */\n     public static <E> Iterable<E> chainedIterable(final Iterable<? extends E>... iterables) {\n+        checkNotNull(iterables);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n                         if (count > iterables.length) {\n                             return null;\n                         } else {\n-                            return emptyIteratorIfNull(iterables[count - 1]);\n+                            return iterables[count - 1].iterator();\n                         }\n                     }\n                 };\n      * corresponding input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param a  the first iterable, may be null\n-     * @param b  the second iterable, may be null\n+     * @param a  the first iterable, may not be null\n+     * @param b  the second iterable, may not be null\n      * @return a filtered view on the specified iterable\n+     * @throws NullPointerException if either of the provided iterables is null\n      */\n     public static <E> Iterable<E> collatedIterable(final Iterable<? extends E> a,\n                                                    final Iterable<? extends E> b) {\n+        checkNotNull(a, b);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n-                return IteratorUtils.collatedIterator(null,\n-                                                      emptyIteratorIfNull(a),\n-                                                      emptyIteratorIfNull(b));\n+                return IteratorUtils.collatedIterator(null, a.iterator(), b.iterator());\n             }\n         };\n     }\n      * @param <E>  the element type\n      * @param comparator  the comparator defining an ordering over the elements,\n      *   may be null, in which case natural ordering will be used\n-     * @param a  the first iterable, may be null\n-     * @param b  the second iterable, may be null\n+     * @param a  the first iterable, may not be null\n+     * @param b  the second iterable, may not be null\n      * @return a filtered view on the specified iterable\n+     * @throws NullPointerException if either of the provided iterables is null\n      */\n     public static <E> Iterable<E> collatedIterable(final Comparator<? super E> comparator,\n                                                    final Iterable<? extends E> a,\n                                                    final Iterable<? extends E> b) {\n+        checkNotNull(a, b);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n-                return IteratorUtils.collatedIterator(comparator,\n-                                                      emptyIteratorIfNull(a),\n-                                                      emptyIteratorIfNull(b));\n+                return IteratorUtils.collatedIterator(comparator, a.iterator(), b.iterator());\n             }\n         };\n     }\n      * The returned iterable's iterator does not support {@code remove()}.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to filter, may be null\n+     * @param iterable  the iterable to filter, may not be null\n      * @param predicate  the predicate used to filter elements, may not be null\n      * @return a filtered view on the specified iterable\n-     * @throws NullPointerException if predicate is null\n+     * @throws NullPointerException if either iterable or predicate is null\n      */\n     public static <E> Iterable<E> filteredIterable(final Iterable<E> iterable,\n                                                    final Predicate<? super E> predicate) {\n+        checkNotNull(iterable);\n         if (predicate == null) {\n             throw new NullPointerException(\"Predicate must not be null.\");\n         }\n-\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to limit, may be null\n+     * @param iterable  the iterable to limit, may not be null\n      * @param maxSize  the maximum number of elements, must not be negative\n      * @return a bounded view on the specified iterable\n      * @throws IllegalArgumentException if maxSize is negative\n+     * @throws NullPointerException if iterable is null\n      */\n     public static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n+        checkNotNull(iterable);\n         if (maxSize < 0) {\n             throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n         }\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n-                return IteratorUtils.boundedIterator(emptyIteratorIfNull(iterable), maxSize);\n+                return IteratorUtils.boundedIterator(iterable.iterator(), maxSize);\n             }\n         };\n     }\n      * is empty.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to loop, may be null\n+     * @param iterable  the iterable to loop, may not be null\n      * @return a view of the iterable, providing an infinite loop over its elements\n+     * @throws NullPointerException if iterable is null\n      */\n     public static <E> Iterable<E> loopingIterable(final Iterable<E> iterable) {\n+        checkNotNull(iterable);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n                 return new LazyIteratorChain<E>() {\n                     @Override\n                     protected Iterator<? extends E> nextIterator(int count) {\n-                        if (iterable != null) {\n-                            if (IterableUtils.isEmpty(iterable)) {\n-                                return null;\n-                            } else {\n-                                return iterable.iterator();\n-                            }\n+                        if (IterableUtils.isEmpty(iterable)) {\n+                            return null;\n                         } else {\n-                            return null;\n+                            return iterable.iterator();\n                         }\n                     }\n                 };\n      * provided iterable is a {@link List} instance.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to use, may be null\n+     * @param iterable  the iterable to use, may not be null\n      * @return a reversed view of the specified iterable\n+     * @throws NullPointerException if iterable is null\n      * @see ReverseListIterator\n      */\n     public static <E> Iterable<E> reversedIterable(final Iterable<E> iterable) {\n+        checkNotNull(iterable);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n                 final List<E> list = (iterable instanceof List<?>) ?\n                         (List<E>) iterable :\n-                        IteratorUtils.toList(emptyIteratorIfNull(iterable));\n-\n+                        IteratorUtils.toList(iterable.iterator());\n                 return new ReverseListIterator<E>(list);\n             }\n         };\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to use, may be null\n+     * @param iterable  the iterable to use, may not be null\n      * @param elementsToSkip  the number of elements to skip from the start, must not be negative\n      * @return a view of the specified iterable, skipping the first N elements\n      * @throws IllegalArgumentException if elementsToSkip is negative\n+     * @throws NullPointerException if iterable is null\n      */\n     public static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n+        checkNotNull(iterable);\n         if (elementsToSkip < 0) {\n             throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n         }\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n-                return IteratorUtils.skippingIterator(emptyIteratorIfNull(iterable), elementsToSkip);\n+                return IteratorUtils.skippingIterator(iterable.iterator(), elementsToSkip);\n             }\n         };\n     }\n      *\n      * @param <I>  the input element type\n      * @param <O>  the output element type\n-     * @param iterable  the iterable to transform, may be null\n+     * @param iterable  the iterable to transform, may not be null\n      * @param transformer  the transformer, must not be null\n      * @return a transformed view of the specified iterable\n-     * @throws NullPointerException if transformer is null\n+     * @throws NullPointerException if either iterable or transformer is null\n      */\n     public static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable,\n                                                          final Transformer<? super I, ? extends O> transformer) {\n+        checkNotNull(iterable);\n         if (transformer == null) {\n             throw new NullPointerException(\"Transformer must not be null.\");\n         }\n-\n         return new FluentIterable<O>() {\n             @Override\n             public Iterator<O> iterator() {\n-                return IteratorUtils.transformedIterator(emptyIteratorIfNull(iterable), transformer);\n+                return IteratorUtils.transformedIterator(iterable.iterator(), transformer);\n             }\n         };\n     }\n      * The returned iterable's iterator does not support {@code remove()}.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to use, may be null\n+     * @param iterable  the iterable to use, may not be null\n      * @return a unique view of the specified iterable\n+     * @throws NullPointerException if iterable is null\n      */\n     public static <E> Iterable<E> uniqueIterable(final Iterable<E> iterable) {\n+        checkNotNull(iterable);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n-                return new UniqueFilterIterator<E>(emptyIteratorIfNull(iterable));\n+                return new UniqueFilterIterator<E>(iterable.iterator());\n             }\n         };\n     }\n      * The returned iterable's iterator does not support {@code remove()}.\n      *\n      * @param <E>  the element type\n-     * @param iterable  the iterable to use, may be null\n+     * @param iterable  the iterable to use, may not be null\n      * @return an unmodifiable view of the specified iterable\n+     * @throws NullPointerException if iterable is null\n      */\n     public static <E> Iterable<E> unmodifiableIterable(final Iterable<E> iterable) {\n+        checkNotNull(iterable);\n         if (iterable instanceof UnmodifiableIterable<?>) {\n             return iterable;\n         }\n-        return new UnmodifiableIterable<E>(emptyIfNull(iterable));\n+        return new UnmodifiableIterable<E>(iterable);\n     }\n \n     /**\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param a  the first iterable\n-     * @param b  the second iterable\n+     * @param a  the first iterable, may not be null\n+     * @param b  the second iterable, may not be null\n      * @return a new iterable, interleaving the provided iterables\n-     */\n-    @SuppressWarnings(\"unchecked\")\n+     * @throws NullPointerException if either a or b is null\n+     */\n     public static <E> Iterable<E> zippingIterable(final Iterable<? extends E> a,\n                                                   final Iterable<? extends E> b) {\n-        return zippingIterable(new Iterable[] {a, b});\n+        checkNotNull(a);\n+        checkNotNull(b);\n+        return new FluentIterable<E>() {\n+            @Override\n+            public Iterator<E> iterator() {\n+                return IteratorUtils.zippingIterator(a.iterator(), b.iterator());\n+            }\n+        };\n     }\n \n     /**\n      * input iterator supports it.\n      *\n      * @param <E>  the element type\n-     * @param iterables  the array of iterables to interleave\n+     * @param iterables  the array of iterables to interleave, may not be null\n      * @return a new iterable, interleaving the provided iterables\n-     */\n-    public static <E> Iterable<E> zippingIterable(final Iterable<? extends E>... iterables) {\n+     * @throws NullPointerException if either of the provided iterables is null\n+     */\n+    public static <E> Iterable<E> zippingIterable(final Iterable<? extends E> first,\n+                                                  final Iterable<? extends E>... others) {\n+        checkNotNull(first);\n+        checkNotNull(others);\n         return new FluentIterable<E>() {\n             @Override\n             public Iterator<E> iterator() {\n-                @SuppressWarnings(\"unchecked\")\n-                Iterator<? extends E>[] iterators = new Iterator[iterables.length];\n-                for (int i = 0; i < iterables.length; i++) {\n-                    iterators[i] = emptyIteratorIfNull(iterables[i]);\n+                @SuppressWarnings(\"unchecked\") // safe\n+                Iterator<? extends E>[] iterators = new Iterator[others.length + 1];\n+                iterators[0] = first.iterator();\n+                for (int i = 0; i < others.length; i++) {\n+                    iterators[i + 1] = others[i].iterator();\n                 }\n                 return IteratorUtils.zippingIterator(iterators);\n             }\n      */\n     public static <E> Iterable<E> emptyIfNull(final Iterable<E> iterable) {\n         return iterable == null ? IterableUtils.<E>emptyIterable() : iterable;\n-    }\n-\n-    /**\n-     * Returns an empty iterator if the argument is <code>null</code>,\n-     * or {@code iterable.iterator()} otherwise.\n-     *\n-     * @param <E> the element type\n-     * @param iterable  the iterable, possibly <code>null</code>\n-     * @return an empty iterator if the argument is <code>null</code>\n-     */\n-    private static <E> Iterator<E> emptyIteratorIfNull(final Iterable<E> iterable) {\n-        return iterable != null ? iterable.iterator() : IteratorUtils.<E>emptyIterator();\n     }\n \n     /**\n         if (predicate == null) {\n             throw new NullPointerException(\"Predicate must not be null.\");\n         }\n-        return size(filteredIterable(input, predicate));\n+        return size(filteredIterable(emptyIfNull(input), predicate));\n     }\n \n     /**\n         if (iterable instanceof Bag<?>) {\n             return ((Bag<E>) iterable).getCount(obj);\n         }\n-        return size(filteredIterable(iterable, EqualPredicate.<E>equalPredicate(obj)));\n+        return size(filteredIterable(emptyIfNull(iterable), EqualPredicate.<E>equalPredicate(obj)));\n     }\n \n     /**\n     public static <E> String toString(final Iterable<E> iterable,\n                                       final Transformer<? super E, String> transformer) {\n         if (transformer == null) {\n-            throw new NullPointerException(\"transformer may not be null\");\n+            throw new NullPointerException(\"Transformer must not be null.\");\n         }\n         return IteratorUtils.toString(emptyIteratorIfNull(iterable), transformer);\n     }\n                                       transformer, delimiter, prefix, suffix);\n     }\n \n+    // Helper methods\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Fail-fast check for null arguments.\n+     *\n+     * @param iterable  the iterable to check\n+     * @throws NullPointerException if iterable is null\n+     */\n+    static void checkNotNull(final Iterable<?> iterable) {\n+        if (iterable == null) {\n+            throw new NullPointerException(\"Iterable must not be null.\");\n+        }\n+    }\n+\n+    /**\n+     * Fail-fast check for null arguments.\n+     *\n+     * @param iterable  the iterable to check\n+     * @throws NullPointerException if the argument or any of its contents is null\n+     */\n+    static void checkNotNull(final Iterable<?>... iterables) {\n+        if (iterables == null) {\n+            throw new NullPointerException(\"Iterables must not be null.\");\n+        }\n+        for (final Iterable<?> iterable : iterables) {\n+            checkNotNull(iterable);\n+        }\n+    }\n+\n+    /**\n+     * Returns an empty iterator if the argument is <code>null</code>,\n+     * or {@code iterable.iterator()} otherwise.\n+     *\n+     * @param <E> the element type\n+     * @param iterable  the iterable, possibly <code>null</code>\n+     * @return an empty iterator if the argument is <code>null</code>\n+     */\n+    private static <E> Iterator<E> emptyIteratorIfNull(final Iterable<E> iterable) {\n+        return iterable != null ? iterable.iterator() : IteratorUtils.<E>emptyIterator();\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/collections4/FluentIterableTest.java\n+++ b/src/test/java/org/apache/commons/collections4/FluentIterableTest.java\n     // -----------------------------------------------------------------------\n     @Test\n     public void factoryMethodOf() {\n-        List<Integer> result = FluentIterable.of(1, 2, 3, 4, 5).toList();\n+        FluentIterable<Integer> iterable = FluentIterable.of(1, 2, 3, 4, 5);\n+        List<Integer> result = iterable.toList();\n         assertEquals(Arrays.asList(1, 2, 3, 4, 5), result);\n+\n+        iterable = FluentIterable.of(1);\n+        assertEquals(1, iterable.size());\n+        assertFalse(iterable.isEmpty());\n+        assertEquals(Arrays.asList(1), iterable.toList());\n \n         result = FluentIterable.of(new Integer[0]).toList();\n         assertTrue(result.isEmpty());\n \n         final Iterable<Integer> it = null;\n-        result = FluentIterable.of(it).toList();\n-        assertTrue(result.isEmpty());\n+        try {\n+            FluentIterable.of(it).toList();\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n     }\n \n     @Test\n         Collections.sort(combinedList);\n         assertEquals(combinedList, result);\n \n-        result = FluentIterable.of(iterableOdd).collate(null).toList();\n-        List<Integer> expected = IterableUtils.toList(iterableOdd);\n-        assertEquals(expected, result);\n+        try {\n+            FluentIterable.of(iterableOdd).collate(null).toList();\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n     }\n \n     @Test\n         Collections.sort(combinedList);\n         assertEquals(combinedList, result);\n \n-        result = FluentIterable.of(iterableOdd).zip((Iterable<Integer>) null).toList();\n-        List<Integer> expected = IterableUtils.toList(iterableOdd);\n-        assertEquals(expected, result);\n+        try {\n+            FluentIterable.of(iterableOdd).zip((Iterable<Integer>) null).toList();\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n         \n         result = FluentIterable.of(Arrays.asList(1, 4, 7)).zip(Arrays.asList(2, 5, 8), Arrays.asList(3, 6, 9)).toList();\n         combinedList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n \n     @Test\n     public void size() {\n-        assertEquals(0, FluentIterable.of((Iterable<?>) null).size());\n+        try {\n+            FluentIterable.of((Iterable<?>) null).size();\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n         assertEquals(0, FluentIterable.of(emptyIterable).size());\n         assertEquals(IterableUtils.toList(iterableOdd).size(), FluentIterable.of(iterableOdd).size());\n     }", "timestamp": 1433761722, "metainfo": ""}