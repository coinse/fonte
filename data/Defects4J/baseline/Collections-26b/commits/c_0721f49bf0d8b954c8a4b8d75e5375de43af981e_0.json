{"sha": "0721f49bf0d8b954c8a4b8d75e5375de43af981e", "log": "[COLLECTIONS-508] Further additions.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n     /**\n      * Gets the list of values associated with the specified key.\n      * <p>\n-     * Implementations typically return <code>null</code> if no values have been\n-     * mapped to the key, however the implementation may choose to return an\n-     * empty collection.\n-     * <p>\n-     * Implementations may choose to return a clone of the internal collection.\n+     * This method will return an <b>empty</b> list if\n+     * {@link #containsKey(Object)} returns {@code false}. Changes to the\n+     * returned list will update the underlying {@code ListValuedMap} and\n+     * vice-versa.\n      *\n      * @param key the key to retrieve\n-     * @return the <code>Collection</code> of values, implementations should\n-     *         return <code>null</code> for no mapping, but may return an empty collection\n+     * @return the <code>List</code> of values, implementations should return an\n+     *         empty list for no mapping\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n     /**\n      * Removes all values associated with the specified key.\n      * <p>\n-     * Implementations typically return <code>null</code> from a subsequent\n-     * <code>get(Object)</code>, however they may choose to return an empty\n-     * collection.\n+     * The returned list <i>may</i> be modifiable, but updates will not be\n+     * propagated to this list-valued map. In case no mapping was stored for the\n+     * specified key, an empty, unmodifiable list will be returned.\n      *\n      * @param key the key to remove values from\n-     * @return the <code>Collection</code> of values removed, implementations\n-     *         should return <code>null</code> for no mapping found, but may\n-     *         return an empty collection\n+     * @return the <code>List</code> of values removed, implementations\n+     *         typically return an empty, unmodifiable List for no mapping found\n      * @throws UnsupportedOperationException if the map is unmodifiable\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/MultiMapUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.multimap.MultiValuedHashMap;\n+import org.apache.commons.collections4.multimap.TransformedMultiValuedMap;\n+import org.apache.commons.collections4.multimap.UnmodifiableMultiValuedMap;\n+\n+/**\n+ * Provides utility methods and decorators for {@link MultiValuedMap} instances.\n+ * <p>\n+ * It contains various type safe and null safe methods.\n+ * <p>\n+ * It also provides the following decorators:\n+ *\n+ * <ul>\n+ *   <li>{@link #unmodifiableMultiValuedMap(MultiValuedMap)}</li>\n+ *   <li>{@link #transformedMultiValuedMap(MultiValuedMap, Transformer, Transformer)}</li>\n+ * </ul>\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class MultiMapUtils {\n+\n+    /**\n+     * <code>MultiMapUtils</code> should not normally be instantiated.\n+     */\n+    private MultiMapUtils() {\n+    }\n+\n+    /**\n+     * An empty {@link UnmodifiableMultiValuedMap}.\n+     */\n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+    public static final MultiValuedMap EMPTY_MULTI_VALUED_MAP =\n+            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(new MultiValuedHashMap());\n+\n+    /**\n+     * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n+     *\n+     * @param <K> the type of key in the map\n+     * @param <V> the type of value in the map\n+     * @return immutable and empty <code>MultiValuedMap</code>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> MultiValuedMap<K, V> emptyMultiValuedMap() {\n+        return EMPTY_MULTI_VALUED_MAP;\n+    }\n+\n+    // Null safe methods\n+\n+    /**\n+     * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n+     * <code>null</code>, or the argument itself otherwise.\n+     *\n+     * @param <K> the type of key in the map\n+     * @param <V> the type of value in the map\n+     * @param map the map, possibly <code>null</code>\n+     * @return an empty <code>MultiValuedMap</code> if the argument is <code>null</code>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> MultiValuedMap<K, V> emptyIfNull(final MultiValuedMap<K, V> map) {\n+        return map == null ? EMPTY_MULTI_VALUED_MAP : map;\n+    }\n+\n+    /**\n+     * Null-safe check if the specified <code>MultiValuedMap</code> is empty.\n+     * <p>\n+     * Null returns true.\n+     *\n+     * @param map the map to check, may be null\n+     * @return true if empty or null\n+     */\n+    public static boolean isEmpty(final MultiValuedMap<?, ?> map) {\n+        return map == null || map.isEmpty();\n+    }\n+\n+    // Null safe getters\n+    // -------------------------------------------------------------------------\n+\n+    /**\n+     * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the <code>MultiValuedMap</code> to use\n+     * @param key the key to look up\n+     * @return the Collection in the <code>MultiValuedMap</code>, <code>null</code> if map input is null\n+     */\n+    public static <K, V> Collection<V> getCollection(final MultiValuedMap<K, V> map, final K key) {\n+        if (map != null) {\n+            return map.get(key);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the <code>MultiValuedMap</code> to use\n+     * @param key the key to look up\n+     * @return the Collection in the <code>MultiValuedMap</code> as List,\n+     *         <code>null</code> if map input is null\n+     */\n+    public static <K, V> List<V> getList(MultiValuedMap<K, V> map, K key) {\n+        if (map != null) {\n+            Collection<V> col = map.get(key);\n+            if (col instanceof List) {\n+                return (List<V>) col;\n+            }\n+            return new ArrayList<V>(col);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the <code>MultiValuedMap</code> to use\n+     * @param key the key to look up\n+     * @return the Collection in the <code>MultiValuedMap</code> as Set,\n+     *         <code>null</code> if map input is null\n+     */\n+    public static <K, V> Set<V> getSet(MultiValuedMap<K, V> map, K key) {\n+        if (map != null) {\n+            Collection<V> col =  map.get(key);\n+            if (col instanceof Set) {\n+                return (Set<V>) col;\n+            }\n+            return new HashSet<V>(col);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the <code>MultiValuedMap</code> to use\n+     * @param key the key to look up\n+     * @return the Collection in the <code>MultiValuedMap</code> as Bag,\n+     *         <code>null</code> if map input is null\n+     */\n+    public static <K, V> Bag<V> getBag(MultiValuedMap<K, V> map, K key) {\n+        if (map != null) {\n+            Collection<V> col = map.get(key);\n+            if (col instanceof Bag) {\n+                return (Bag<V>) col;\n+            }\n+            return new HashBag<V>(col);\n+        }\n+        return null;\n+    }\n+\n+    // Factory Methods\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Creates a {@link ListValuedMap} with a {@link HashMap} as its internal storage.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return a new <code>ListValuedMap</code>\n+     */\n+    public static <K, V> ListValuedMap<K, V> createListValuedHashMap() {\n+        return MultiValuedHashMap.<K, V>listValuedHashMap();\n+    }\n+\n+    /**\n+     * Creates a {@link ListValuedMap} with a {@link HashMap} as its internal\n+     * storage which maps the keys to list of type <code>listClass</code>.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the List class type\n+     * @param listClass the class of the list\n+     * @return a new <code>ListValuedMap</code>\n+     */\n+    public static <K, V, C extends List<V>> ListValuedMap<K, V> createListValuedHashMap(final Class<C> listClass) {\n+        return MultiValuedHashMap.<K, V, C>listValuedHashMap(listClass);\n+    }\n+\n+    /**\n+     * Creates a {@link SetValuedMap} with a {@link HashMap} as its internal\n+     * storage\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return a new <code>SetValuedMap</code>\n+     */\n+    public static <K, V> SetValuedMap<K, V> createSetValuedHashMap() {\n+        return MultiValuedHashMap.<K, V>setValuedHashMap();\n+    }\n+\n+    /**\n+     * Creates a {@link SetValuedMap} with a {@link HashMap} as its internal\n+     * storage which maps the keys to a set of type <code>setClass</code>\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the Set class type\n+     * @param setClass the class of the set\n+     * @return a new <code>SetValuedMap</code>\n+     */\n+    public static <K, V, C extends Set<V>> SetValuedMap<K, V> createSetValuedHashMap(final Class<C> setClass) {\n+        return MultiValuedHashMap.<K, V, C>setValuedHashMap(setClass);\n+    }\n+\n+    // MultiValuedMap Decorators\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n+     * map.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the <code>MultiValuedMap</code> to make unmodifiable, must not\n+     *        be null\n+     * @return an <code>UnmodifiableMultiValuedMap</code> backed by the given\n+     *         map\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    public static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(\n+            final MultiValuedMap<? extends K, ? extends V> map) {\n+        return UnmodifiableMultiValuedMap.<K, V>unmodifiableMultiValuedMap(map);\n+    }\n+\n+    /**\n+     * Returns a <code>TransformedMultiValuedMap</code> backed by the given map.\n+     * <p>\n+     * This method returns a new <code>MultiValuedMap</code> (decorating the\n+     * specified map) that will transform any new entries added to it. Existing\n+     * entries in the specified map will not be transformed. If you want that\n+     * behaviour, see {@link TransformedMultiValuedMap#transformedMap}.\n+     * <p>\n+     * Each object is passed through the transformers as it is added to the Map.\n+     * It is important not to use the original map after invoking this method,\n+     * as it is a back door for adding untransformed objects.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are\n+     * NOT transformed.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the <code>MultiValuedMap</code> to transform, must not be\n+     *        null, typically empty\n+     * @param keyTransformer the transformer for the map keys, null means no\n+     *        transformation\n+     * @param valueTransformer the transformer for the map values, null means no\n+     *        transformation\n+     * @return a transformed <code>MultiValuedMap</code> backed by the given map\n+     * @throws IllegalArgumentException if the <code>MultiValuedMap</code> is\n+     *         null\n+     */\n+    public static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        return TransformedMultiValuedMap.transformingMap(map, keyTransformer, valueTransformer);\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n     boolean containsMapping(Object key, Object value);\n \n     /**\n-     * Returns a view collection of the values associated with the specified key.\n-     * <p>\n-     * This method will return an <b>empty</b> collection if {@link #containsKey(Object)}\n-     * returns {@code false}. Changes to the returned collection will update the\n-     * underlying {@code MultiValuedMap} and vice-versa.\n+     * Returns a view collection of the values associated with the specified\n+     * key.\n+     * <p>\n+     * This method will return an <b>empty</b> collection if\n+     * {@link #containsKey(Object)} returns {@code false}. Changes to the\n+     * returned collection will update the underlying {@code MultiValuedMap} and\n+     * vice-versa.\n      *\n      * @param key the key to retrieve\n      * @return the <code>Collection</code> of values, implementations should\n-     *         return <code>null</code> for no mapping, but may return an empty collection\n+     *         return an empty collection for no mapping\n      * @throws ClassCastException if the key is of an invalid type (optional)\n      * @throws NullPointerException if the key is null and null keys are invalid (optional)\n      */\n      * Other values attached to that key are unaffected.\n      * <p>\n      * If the last value for a key is removed, implementations typically return\n-     * <code>null</code> from a subsequent <code>get(Object)</code>, however\n-     * they may choose to return an empty collection.\n+     * an empty collection from a subsequent <code>get(Object)</code>.\n      *\n      * @param key the key to remove from\n      * @param item the item to remove\n--- a/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n     /**\n      * Gets the set of values associated with the specified key.\n      * <p>\n-     * Implementations typically return <code>null</code> if no values have been\n-     * mapped to the key, however the implementation may choose to return an\n-     * empty collection.\n+     * Implementations typically return an empty <code>Set</code> if no values\n+     * have been mapped to the key.\n      * <p>\n-     * Implementations may choose to return a clone of the internal collection.\n      *\n      * @param key the key to retrieve\n-     * @return the <code>Set</code> of values, implementations should return\n-     *         <code>null</code> for no mapping, but may return an empty\n-     *         collection\n+     * @return the <code>Set</code> of values, implementations should return an\n+     *         empty Set for no mapping\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n     /**\n      * Removes all values associated with the specified key.\n      * <p>\n-     * Implementations typically return <code>null</code> from a subsequent\n-     * <code>get(Object)</code>, however they may choose to return an empty\n-     * collection.\n+     * The returned set <i>may</i> be modifiable, but updates will not be\n+     * propagated to this set-valued map. In case no mapping was stored for the\n+     * specified key, an empty, unmodifiable set will be returned.\n      *\n      * @param key the key to remove values from\n      * @return the <code>Set</code> of values removed, implementations should\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.ListUtils;\n+import org.apache.commons.collections4.ListValuedMap;\n+\n+/**\n+ * Abstract implementation of the {@link ListValuedMap} interface to simplify\n+ * the creation of subclass implementations.\n+ * <p>\n+ * Subclasses specify a Map implementation to use as the internal storage and\n+ * the List implementation to use as values.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap<K, V>\n+        implements ListValuedMap<K, V>, Serializable {\n+\n+    /** The serialization version */\n+    private static final long serialVersionUID = 6024950625989666915L;\n+\n+    /**\n+     * A constructor that wraps, not copies\n+     *\n+     * @param <C> the list type\n+     * @param map the map to wrap, must not be null\n+     * @param listClazz the collection class\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected <C extends List<V>> AbstractListValuedMap(Map<K, ? super C> map, Class<C> listClazz) {\n+        super(map, listClazz);\n+    }\n+\n+    /**\n+     * A constructor that wraps, not copies\n+     *\n+     * @param <C> the list type\n+     * @param map the map to wrap, must not be null\n+     * @param listClazz the collection class\n+     * @param initialListCapacity the initial size of the values list\n+     * @throws IllegalArgumentException if the map is null or if\n+     *         initialListCapacity is negative\n+     */\n+    protected <C extends List<V>> AbstractListValuedMap(Map<K, ? super C> map, Class<C> listClazz,\n+            int initialListCapacity) {\n+        super(map, listClazz, initialListCapacity);\n+    }\n+\n+    /**\n+     * Gets the list of values associated with the specified key. This would\n+     * return an empty list in case the mapping is not present\n+     *\n+     * @param key the key to retrieve\n+     * @return the <code>List</code> of values, will return an empty\n+     *         <code>List</code> for no mapping\n+     * @throws ClassCastException if the key is of an invalid type\n+     */\n+    @Override\n+    public List<V> get(Object key) {\n+        return new WrappedList(key);\n+    }\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * A subsequent <code>get(Object)</code> would return an empty list.\n+     *\n+     * @param key the key to remove values from\n+     * @return the <code>List</code> of values removed, will return an empty,\n+     *         unmodifiable list for no mapping found.\n+     * @throws ClassCastException if the key is of an invalid type\n+     */\n+    @Override\n+    public List<V> remove(Object key) {\n+        return ListUtils.emptyIfNull((List<V>) getMap().remove(key));\n+    }\n+\n+    /**\n+     * Wrapped list to handle add and remove on the list returned by get(object)\n+     */\n+    private class WrappedList extends WrappedCollection implements List<V> {\n+\n+        public WrappedList(Object key) {\n+            super(key);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public void add(int index, V value) {\n+            List<V> list = (List<V>) getMapping();\n+            if (list == null) {\n+                list = (List<V>) AbstractListValuedMap.this.createCollection();\n+                list.add(index, value);\n+                getMap().put((K) key, list);\n+            }\n+            list.add(index, value);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public boolean addAll(int index, Collection<? extends V> c) {\n+            List<V> list = (List<V>) getMapping();\n+            if (list == null) {\n+                list = (List<V>) createCollection();\n+                boolean result = list.addAll(index, c);\n+                if (result) {\n+                    getMap().put((K) key, list);\n+                }\n+                return result;\n+            }\n+            return list.addAll(index, c);\n+        }\n+\n+        public V get(int index) {\n+            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            return list.get(index);\n+        }\n+\n+        public int indexOf(Object o) {\n+            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            return list.indexOf(o);\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            return list.indexOf(o);\n+        }\n+\n+        public ListIterator<V> listIterator() {\n+            return new ValuesListIterator(key);\n+        }\n+\n+        public ListIterator<V> listIterator(int index) {\n+            return new ValuesListIterator(key, index);\n+        }\n+\n+        public V remove(int index) {\n+            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            V value = list.remove(index);\n+            if (list.isEmpty()) {\n+                AbstractListValuedMap.this.remove(key);\n+            }\n+            return value;\n+        }\n+\n+        public V set(int index, V value) {\n+            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            return list.set(index, value);\n+        }\n+\n+        public List<V> subList(int fromIndex, int toIndex) {\n+            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            return list.subList(fromIndex, toIndex);\n+        }\n+\n+    }\n+\n+    /** Values ListItrerator */\n+    private class ValuesListIterator implements ListIterator<V>{\n+\n+        private final Object key;\n+\n+        private List<V> values;\n+        private ListIterator<V> iterator;\n+\n+        public ValuesListIterator(Object key){\n+            this.key = key;\n+            this.values = ListUtils.emptyIfNull((List<V>) getMap().get(key));\n+            this.iterator = values.listIterator();\n+        }\n+\n+        public ValuesListIterator(Object key, int index){\n+            this.key = key;\n+            this.values = ListUtils.emptyIfNull((List<V>) getMap().get(key));\n+            this.iterator = values.listIterator(index);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        public void add(V value) {\n+            if (getMap().get(key) == null) {\n+                List<V> list = (List<V>) createCollection();\n+                getMap().put((K) key, list);\n+                this.values = list;\n+                this.iterator = list.listIterator();\n+            }\n+        this.iterator.add(value);\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+\n+        public V next() {\n+            return iterator.next();\n+        }\n+\n+        public int nextIndex() {\n+            return iterator.nextIndex();\n+        }\n+\n+        public V previous() {\n+            return iterator.previous();\n+        }\n+\n+        public int previousIndex() {\n+            return iterator.previousIndex();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            if (values.isEmpty()) {\n+                getMap().remove(key);\n+            }\n+        }\n+\n+        public void set(V value) {\n+            iterator.set(value);\n+        }\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n import java.util.AbstractCollection;\n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Map.Entry;\n      *\n      * @param <C> the collection type\n      * @param map the map to wrap, must not be null\n+     * @param collectionClazz the collection class\n      * @param initialCollectionCapacity the initial capacity of the collection\n-     * @param collectionClazz the collection class\n      * @throws IllegalArgumentException if the map is null or if\n-     *         initialCollectionCapacity is negetive\n+     *         initialCollectionCapacity is negative\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map,\n-            int initialCollectionCapacity, final Class<C> collectionClazz) {\n+            final Class<C> collectionClazz, final int initialCollectionCapacity) {\n         if (map == null) {\n             throw new IllegalArgumentException(\"Map must not be null\");\n         }\n     /**\n      * Removes all values associated with the specified key.\n      * <p>\n-     * A subsequent <code>get(Object)</code> would return null collection.\n+     * A subsequent <code>get(Object)</code> would return an empty collection.\n      *\n      * @param key the key to remove values from\n-     * @return the <code>Collection</code> of values removed, will return\n-     *         <code>null</code> for no mapping found.\n+     * @return the <code>Collection</code> of values removed, will return an\n+     *         empty, unmodifiable collection for no mapping found.\n      * @throws ClassCastException if the key is of an invalid type\n      */\n     public Collection<V> remove(Object key) {\n-        Collection<V> coll = getMap().remove(key);\n-        return coll == null ? Collections.<V>emptyList() : coll;\n+        return CollectionUtils.emptyIfNull(getMap().remove(key));\n     }\n \n     /**\n      * The item is removed from the collection mapped to the specified key.\n      * Other values attached to that key are unaffected.\n      * <p>\n-     * If the last value for a key is removed, <code>null</code> would be\n+     * If the last value for a key is removed, an empty collection would be\n      * returned from a subsequent <code>get(Object)</code>.\n      *\n      * @param key the key to remove from\n     /**\n      * Wrapped collection to handle add and remove on the collection returned by get(object)\n      */\n-    private class WrappedCollection implements Collection<V> {\n-\n-        private final Object key;\n+    protected class WrappedCollection implements Collection<V> {\n+\n+        protected final Object key;\n \n         public WrappedCollection(Object key) {\n             this.key = key;\n         }\n \n-        private Collection<V> getMapping() {\n+        protected Collection<V> getMapping() {\n             return getMap().get(key);\n         }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.SetUtils;\n+import org.apache.commons.collections4.SetValuedMap;\n+\n+/**\n+ * Abstract implementation of the {@link SetValuedMap} interface to simplify the\n+ * creation of subclass implementations.\n+ * <p>\n+ * Subclasses specify a Map implementation to use as the internal storage and\n+ * the Set implementation to use as values.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractSetValuedMap<K, V> extends AbstractMultiValuedMap<K, V> implements SetValuedMap<K, V> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 3383617478898639862L;\n+\n+    /**\n+     * A constructor that wraps, not copies\n+     *\n+     * @param <C> the set type\n+     * @param map the map to wrap, must not be null\n+     * @param setClazz the collection class\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected <C extends Set<V>> AbstractSetValuedMap(Map<K, ? super C> map, Class<C> setClazz) {\n+        super(map, setClazz);\n+    }\n+\n+    /**\n+     * A constructor that wraps, not copies\n+     *\n+     * @param <C> the set type\n+     * @param map the map to wrap, must not be null\n+     * @param setClazz the collection class\n+     * @param initialSetCapacity the initial size of the values set\n+     * @throws IllegalArgumentException if the map is null or if\n+     *         initialSetCapacity is negative\n+     */\n+    protected <C extends Set<V>> AbstractSetValuedMap(Map<K, ? super C> map, Class<C> setClazz,\n+            int initialSetCapacity) {\n+        super(map, setClazz, initialSetCapacity);\n+    }\n+\n+    /**\n+     * Gets the set of values associated with the specified key. This would\n+     * return an empty set in case the mapping is not present\n+     *\n+     * @param key the key to retrieve\n+     * @return the <code>Set</code> of values, will return an empty\n+     *         <code>Set</code> for no mapping\n+     * @throws ClassCastException if the key is of an invalid type\n+     */\n+    @Override\n+    public Set<V> get(Object key) {\n+        return new WrappedSet(key);\n+    }\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * A subsequent <code>get(Object)</code> would return an empty set.\n+     *\n+     * @param key the key to remove values from\n+     * @return the <code>Set</code> of values removed, will return an empty,\n+     *         unmodifiable set for no mapping found.\n+     * @throws ClassCastException if the key is of an invalid type\n+     */\n+    @Override\n+    public Set<V> remove(Object key) {\n+        return SetUtils.emptyIfNull((Set<V>) getMap().remove(key));\n+    }\n+\n+    /**\n+     * Wrapped set to handle add and remove on the collection returned by\n+     * get(object)\n+     */\n+    protected class WrappedSet extends WrappedCollection implements Set<V> {\n+\n+        public WrappedSet(Object key) {\n+            super(key);\n+        }\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n import java.util.Map;\n-\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.ListValuedMap;\n import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.SetValuedMap;\n \n /**\n  * Implements a {@link MultiValuedMap}, using a {@link HashMap} to provide data\n     static final float DEFAULT_LOAD_FACTOR = 0.75f;\n \n     /**\n-     * Creates a MultiValuedHashMap which maps keys to collections of type\n-     * <code>collectionClass</code>.\n-     *\n-     * @param <K> the key type\n-     * @param <V> the value type\n-     * @param <C> the collection class type\n-     * @param collectionClass the type of the collection class\n-     * @return a new MultiValuedMap\n-     */\n-    public static <K, V, C extends Collection<V>> MultiValuedMap<K, V> multiValuedMap(\n-            final Class<C> collectionClass) {\n-        return new MultiValuedHashMap<K, V>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, collectionClass);\n+     * Creates a {@link ListValuedMap} with a {@link HashMap} as its internal\n+     * storage\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return a new <code>ListValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> ListValuedMap<K, V> listValuedHashMap() {\n+        return new ListValuedHashMap(ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a {@link ListValuedMap} with a {@link HashMap} as its internal\n+     * storage which maps the keys to list of type <code>listClass</code>\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the List class type\n+     * @param listClass the class of the list\n+     * @return a new <code>ListValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V, C extends List<V>> ListValuedMap<K, V> listValuedHashMap(final Class<C> listClass) {\n+        return new ListValuedHashMap(listClass);\n+    }\n+\n+    /**\n+     * Creates a {@link SetValuedMap} with a {@link HashMap} as its internal\n+     * storage\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return a new <code>SetValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> SetValuedMap<K, V> setValuedHashMap() {\n+        return new SetValuedHashMap(HashSet.class);\n+    }\n+\n+    /**\n+     * Creates a {@link SetValuedMap} with a {@link HashMap} as its internal\n+     * storage which maps the keys to a set of type <code>setClass</code>\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the Set class type\n+     * @param setClass the class of the set\n+     * @return a new <code>SetValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V, C extends Set<V>> SetValuedMap<K, V> setValuedHashMap(final Class<C> setClass) {\n+        return new SetValuedHashMap(setClass);\n     }\n \n     /**\n      */\n     @SuppressWarnings(\"unchecked\")\n     public MultiValuedHashMap(int initialCapacity, float loadFactor, int initialCollectionCapacity) {\n-        this(initialCapacity, loadFactor, initialCollectionCapacity, ArrayList.class);\n+        this(initialCapacity, loadFactor, ArrayList.class, initialCollectionCapacity);\n     }\n \n     /**\n      *        create the value collections\n      */\n     protected <C extends Collection<V>> MultiValuedHashMap(int initialCapacity, float loadFactor,\n-            int initialCollectionCapacity, final Class<C> collectionClazz) {\n-        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), initialCollectionCapacity, collectionClazz);\n+            final Class<C> collectionClazz, int initialCollectionCapacity) {\n+        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz, initialCollectionCapacity);\n+    }\n+\n+    /** Inner class for ListValuedMap */\n+    private static class ListValuedHashMap<K, V> extends AbstractListValuedMap<K, V> {\n+\n+        private static final long serialVersionUID = 3667581458573135234L;\n+\n+        public <C extends List<V>> ListValuedHashMap(Class<C> listClazz) {\n+            super(new HashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz);\n+        }\n+\n+        public <C extends List<V>> ListValuedHashMap(Class<C> listClazz, int initialListCapacity) {\n+            super(new HashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz,\n+                    initialListCapacity);\n+        }\n+\n+    }\n+\n+    /** Inner class for SetValuedMap */\n+    private static class SetValuedHashMap<K, V> extends AbstractSetValuedMap<K, V> {\n+\n+        private static final long serialVersionUID = -3817515514829894543L;\n+\n+        public <C extends Set<V>> SetValuedHashMap(Class<C> setClazz) {\n+            super(new HashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz);\n+        }\n+\n+        public <C extends Set<V>> SetValuedHashMap(Class<C> setClazz, int initialSetCapacity) {\n+            super(new HashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz,\n+                    initialSetCapacity);\n+        }\n+\n     }\n \n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/MultiMapUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.multimap.MultiValuedHashMap;\n+\n+import junit.framework.Test;\n+\n+/**\n+ * Tests for MultiMapUtils\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class MultiMapUtilsTest extends BulkTest {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(MultiMapUtilsTest.class);\n+    }\n+\n+    public MultiMapUtilsTest(String name) {\n+        super(name);\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public void testEmptyUnmodifiableMultiValuedMap() {\n+        final MultiValuedMap map = MultiMapUtils.EMPTY_MULTI_VALUED_MAP;\n+        assertTrue(map.isEmpty());\n+        try {\n+            map.put(\"key\", \"value\");\n+            fail(\"Should throw UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    public void testTypeSafeEmptyMultiValuedMap() {\n+        final MultiValuedMap<String, String> map = MultiMapUtils.<String, String>emptyMultiValuedMap();\n+        assertTrue(map.isEmpty());\n+        try {\n+            map.put(\"key\", \"value\");\n+            fail(\"Should throw UnsupportedOperationException\");\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+    public void testEmptyIfNull() {\n+        assertTrue(MultiMapUtils.emptyIfNull(null).isEmpty());\n+\n+        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertFalse(MultiMapUtils.emptyIfNull(map).isEmpty());\n+    }\n+\n+    public void testIsEmptyWithEmptyMap() {\n+        final MultiValuedMap<Object, Object> map = new MultiValuedHashMap<Object, Object>();\n+        assertEquals(true, MultiMapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNonEmptyMap() {\n+        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();\n+        map.put(\"item\", \"value\");\n+        assertEquals(false, MultiMapUtils.isEmpty(map));\n+    }\n+\n+    public void testIsEmptyWithNull() {\n+        final MultiValuedMap<Object, Object> map = null;\n+        assertEquals(true, MultiMapUtils.isEmpty(map));\n+    }\n+\n+    public void testGetCollection() {\n+        assertNull(MultiMapUtils.getCollection(null, \"key1\"));\n+\n+        String values[] = { \"v1\", \"v2\", \"v3\" };\n+        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();\n+        for (String val : values) {\n+            map.put(\"key1\", val);\n+        }\n+\n+        Collection<String> col = MultiMapUtils.getCollection(map, \"key1\");\n+        for (String val : values) {\n+            assertTrue(col.contains(val));\n+        }\n+    }\n+\n+    public void testGetList() {\n+        assertNull(MultiMapUtils.getList(null, \"key1\"));\n+\n+        String values[] = { \"v1\", \"v2\", \"v3\" };\n+        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();\n+        for (String val : values) {\n+            map.put(\"key1\", val);\n+        }\n+\n+        List<String> list = MultiMapUtils.getList(map, \"key1\");\n+        int i = 0;\n+        for (String val : list) {\n+            assertTrue(val.equals(values[i++]));\n+        }\n+    }\n+\n+    public void testGetSet() {\n+        assertNull(MultiMapUtils.getList(null, \"key1\"));\n+\n+        String values[] = { \"v1\", \"v2\", \"v3\" };\n+        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();\n+        for (String val : values) {\n+            map.put(\"key1\", val);\n+            map.put(\"key1\", val);\n+        }\n+\n+        Set<String> set = MultiMapUtils.getSet(map, \"key1\");\n+        assertEquals(3, set.size());\n+        for (String val : values) {\n+            assertTrue(set.contains(val));\n+        }\n+    }\n+\n+    public void testGetBag() {\n+        assertNull(MultiMapUtils.getBag(null, \"key1\"));\n+\n+        String values[] = { \"v1\", \"v2\", \"v3\" };\n+        final MultiValuedMap<String, String> map = new MultiValuedHashMap<String, String>();\n+        for (String val : values) {\n+            map.put(\"key1\", val);\n+            map.put(\"key1\", val);\n+        }\n+\n+        Bag<String> bag = MultiMapUtils.getBag(map, \"key1\");\n+        assertEquals(6, bag.size());\n+        for (String val : values) {\n+            assertTrue(bag.contains(val));\n+            assertEquals(2, bag.getCount(val));\n+        }\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n  * <p>\n  * To use, extend this class and implement the {@link #makeObject} method and if\n  * necessary override the {@link #makeFullMap()} method.\n- * \n+ *\n  * @since 4.1\n  * @version $Id$\n  */\n--- a/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n  */\n package org.apache.commons.collections4.multimap;\n \n-import java.util.ArrayList;\n-import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n \n import junit.framework.Test;\n \n import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.ListValuedMap;\n import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.SetValuedMap;\n \n /**\n  * Test MultValuedHashMap\n- * \n+ *\n  * @since 4.1\n  * @version $Id$\n  */\n         return m;\n     }\n \n-    /*private <C extends Collection<V>> MultiValuedHashMap<K, V> createTestMap(final Class<C> collectionClass) {\n-        final MultiValuedHashMap<K, V> map =\n-                (MultiValuedHashMap<K, V>) MultiValuedHashMap.<K, V, C> multiValuedMap(collectionClass);\n-        addSampleMappings(map);\n-        return map;\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapAdd() {\n+        final SetValuedMap<K, V> setMap = MultiValuedHashMap.setValuedHashMap();\n+        assertTrue(setMap.get(\"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get(\"A\");\n+        assertTrue(set.add((V) \"a1\"));\n+        assertTrue(set.add((V) \"a2\"));\n+        assertFalse(set.add((V) \"a1\"));\n+        assertEquals(2, setMap.size());\n+        assertTrue(setMap.containsKey(\"A\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public void testValueCollectionType() {\n-        final MultiValuedHashMap<K, V> map = createTestMap(LinkedList.class);\n-        assertTrue(map.get(\"one\") instanceof LinkedList);\n-    }*/\n+    public void testSetValuedMapRemove() {\n+        final SetValuedMap<K, V> setMap = MultiValuedHashMap.setValuedHashMap();\n+        assertTrue(setMap.get(\"whatever\") instanceof Set);\n \n-    @SuppressWarnings(\"unchecked\")\n-    public void testPutWithList() {\n-        final MultiValuedHashMap<K, V> test =\n-                (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(ArrayList.class);\n-        assertEquals(true, test.put((K) \"A\", (V) \"a\"));\n-        assertEquals(true, test.put((K) \"A\", (V) \"b\"));\n-        assertEquals(true, test.put((K) \"A\", (V) \"a\"));\n-        assertEquals(1, test.keySet().size());\n-        assertEquals(3, test.get(\"A\").size());\n-        assertEquals(3, test.size());\n+        Set<V> set = setMap.get(\"A\");\n+        assertTrue(set.add((V) \"a1\"));\n+        assertTrue(set.add((V) \"a2\"));\n+        assertFalse(set.add((V) \"a1\"));\n+        assertEquals(2, setMap.size());\n+        assertTrue(setMap.containsKey(\"A\"));\n+\n+        assertTrue(set.remove(\"a1\"));\n+        assertTrue(set.remove(\"a2\"));\n+        assertFalse(set.remove(\"a1\"));\n+\n+        assertEquals(0, setMap.size());\n+        assertFalse(setMap.containsKey(\"A\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public void testPutWithSet() {\n-        final MultiValuedHashMap<K, V> test =\n-                (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(HashSet.class);\n-        assertEquals(true, test.put((K) \"A\", (V) \"a\"));\n-        assertEquals(true, test.put((K) \"A\", (V) \"b\"));\n-        assertEquals(false, test.put((K) \"A\", (V) \"a\"));\n-        assertEquals(1, test.keySet().size());\n-        assertEquals(2, test.get(\"A\").size());\n-        assertEquals(2, test.size());\n+    public void testSetValuedMapRemoveViaIterator() {\n+        final SetValuedMap<K, V> setMap = MultiValuedHashMap.setValuedHashMap();\n+        assertTrue(setMap.get(\"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get(\"A\");\n+        set.add((V) \"a1\");\n+        set.add((V) \"a2\");\n+        set.add((V) \"a1\");\n+\n+        Iterator<V> it = set.iterator();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, setMap.size());\n+        assertFalse(setMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapAdd() {\n+        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n+        assertTrue(listMap.get(\"whatever\") instanceof List);\n+        List<V> list = listMap.get(\"A\");\n+        list.add((V) \"a1\");\n+        assertEquals(1, listMap.size());\n+        assertTrue(listMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapAddViaListIterator() {\n+        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n+        ListIterator<V> listIt = listMap.get(\"B\").listIterator();\n+        assertFalse(listIt.hasNext());\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        listIt.add((V) \"b3\");\n+        assertEquals(3, listMap.size());\n+        assertTrue(listMap.containsKey(\"B\"));\n+        // As ListIterator always adds before the current cursor\n+        assertFalse(listIt.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapRemove() {\n+        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n+        List<V> list = listMap.get(\"A\");\n+        list.add((V) \"a1\");\n+        list.add((V) \"a2\");\n+        list.add((V) \"a3\");\n+        assertEquals(3, listMap.size());\n+        assertEquals(\"a1\", list.remove(0));\n+        assertEquals(2, listMap.size());\n+        assertEquals(\"a2\", list.remove(0));\n+        assertEquals(1, listMap.size());\n+        assertEquals(\"a3\", list.remove(0));\n+        assertEquals(0, listMap.size());\n+        assertFalse(listMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapRemoveViaListIterator() {\n+        final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n+        ListIterator<V> listIt = listMap.get(\"B\").listIterator();\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        assertEquals(2, listMap.size());\n+        assertTrue(listMap.containsKey(\"B\"));\n+        listIt = listMap.get(\"B\").listIterator();\n+        while (listIt.hasNext()) {\n+            listIt.next();\n+            listIt.remove();\n+        }\n+        assertFalse(listMap.containsKey(\"B\"));\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        assertTrue(listMap.containsKey(\"B\"));\n+        assertEquals(2, listMap.get(\"B\").size());\n     }\n \n //    public void testCreate() throws Exception {", "timestamp": 1397763956, "metainfo": ""}