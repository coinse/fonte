{"sha": "00f8c54647ae08549ff61d92a700cc9a98a995e4", "log": "Rename BinaryBuffer to PriorityBuffer   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BinaryHeap.java\n+++ b/src/java/org/apache/commons/collections/BinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.18 2004/01/02 01:36:51 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.19 2004/01/02 02:14:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * The <code>PriorityQueue</code> interface has now been replaced for most uses\n  * by the <code>Buffer</code> interface. This class and the interface are\n  * retained for backwards compatability. The intended replacement is\n- * {@link org.apache.commons.collections.buffer.BinaryBuffer BinaryBuffer}.\n+ * {@link org.apache.commons.collections.buffer.PriorityBuffer PriorityBuffer}.\n  * <p>\n  * The removal order of a binary heap is based on either the natural sort\n  * order of its elements or a specified {@link Comparator}.  The \n  * </pre>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.18 $ $Date: 2004/01/02 01:36:51 $\n+ * @version $Revision: 1.19 $ $Date: 2004/01/02 02:14:28 $\n  * \n  * @author Peter Donald\n  * @author Ram Chidambaram\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/PriorityBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/PriorityBuffer.java,v 1.1 2004/01/02 02:14:29 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.AbstractCollection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+/**\n+ * Binary heap implementation of <code>Buffer</code> that provides for\n+ * removal based on <code>Comparator</code> ordering.\n+ * <p>\n+ * The removal order of a binary heap is based on either the natural sort\n+ * order of its elements or a specified {@link Comparator}.  The \n+ * {@link #remove()} method always returns the first element as determined\n+ * by the sort order.  (The <code>ascendingOrder</code> flag in the constructors\n+ * can be used to reverse the sort order, in which case {@link #remove()}\n+ * will always remove the last element.)  The removal order is \n+ * <i>not</i> the same as the order of iteration; elements are\n+ * returned by the iterator in no particular order.\n+ * <p>\n+ * The {@link #add(Object)} and {@link #remove()} operations perform\n+ * in logarithmic time.  The {@link #get()} operation performs in constant\n+ * time.  All other operations perform in linear time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  Use \n+ * {@link org.apache.commons.collections.BufferUtils#synchronizedBuffer(Buffer)} or\n+ * {@link org.apache.commons.collections.buffer.SynchronizedBuffer#decorate(Buffer)}\n+ * to provide synchronized access to a <code>PriorityBuffer</code>:\n+ *\n+ * <pre>\n+ * Buffer heap = SynchronizedBuffer.decorate(new PriorityBuffer());\n+ * </pre>\n+ *\n+ * @since Commons Collections 3.0 (previously BinaryHeap v1.0)\n+ * @version $Revision: 1.1 $ $Date: 2004/01/02 02:14:29 $\n+ * \n+ * @author Peter Donald\n+ * @author Ram Chidambaram\n+ * @author Michael A. Smith\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class PriorityBuffer extends AbstractCollection implements Buffer {\n+\n+    /**\n+     * The default capacity for the buffer.\n+     */\n+    private static final int DEFAULT_CAPACITY = 13;\n+    \n+    /**\n+     * The elements in this buffer.\n+     */\n+    protected Object[] elements;\n+    /**\n+     * The number of elements currently in this buffer.\n+     */\n+    protected int size;\n+    /**\n+     * If true, the first element as determined by the sort order will \n+     * be returned.  If false, the last element as determined by the\n+     * sort order will be returned.\n+     */\n+    protected boolean ascendingOrder;\n+    /**\n+     * The comparator used to order the elements\n+     */\n+    protected Comparator comparator;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order by the\n+     * natural order of the objects added.\n+     */\n+    public PriorityBuffer() {\n+        this(DEFAULT_CAPACITY, true, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order using the\n+     * specified comparator.\n+     * \n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     */\n+    public PriorityBuffer(Comparator comparator) {\n+        this(DEFAULT_CAPACITY, true, comparator);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer specifying the sort order and using the\n+     * natural order of the objects added.\n+     *\n+     * @param ascendingOrder  if <code>true</code> the heap is created as a \n+     * minimum heap; otherwise, the heap is created as a maximum heap\n+     */\n+    public PriorityBuffer(boolean ascendingOrder) {\n+        this(DEFAULT_CAPACITY, ascendingOrder, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer specifying the sort order and comparator.\n+     *\n+     * @param ascendingOrder  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     */\n+    public PriorityBuffer(boolean ascendingOrder, Comparator comparator) {\n+        this(DEFAULT_CAPACITY, ascendingOrder, comparator);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order by the\n+     * natural order of the objects added, specifying an initial capacity.\n+     *  \n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public PriorityBuffer(int capacity) {\n+        this(capacity, true, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that sorts in ascending order using the\n+     * specified comparator and initial capacity.\n+     *\n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     * @throws IllegalArgumentException if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public PriorityBuffer(int capacity, Comparator comparator) {\n+        this(capacity, true, comparator);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that specifying initial capacity and\n+     * sort order, using the natural order of the objects added.\n+     *\n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @param ascendingOrder if <code>true</code> the heap is created as a \n+     *  minimum heap; otherwise, the heap is created as a maximum heap.\n+     * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public PriorityBuffer(int capacity, boolean ascendingOrder) {\n+        this(capacity, ascendingOrder, null);\n+    }\n+\n+    /**\n+     * Constructs a new empty buffer that specifying initial capacity,\n+     * sort order and comparator.\n+     *\n+     * @param capacity  the initial capacity for the buffer, greater than zero\n+     * @param ascendingOrder  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements,\n+     *  null means use natural order\n+     * @throws IllegalArgumentException if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public PriorityBuffer(int capacity, boolean ascendingOrder, Comparator comparator) {\n+        super();\n+        if (capacity <= 0) {\n+            throw new IllegalArgumentException(\"invalid capacity\");\n+        }\n+        this.ascendingOrder = ascendingOrder;\n+\n+        //+1 as 0 is noop\n+        this.elements = new Object[capacity + 1];\n+        this.comparator = comparator;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the heap is ascending or descending order.\n+     * \n+     * @return true if ascending order (a min heap)\n+     */\n+    public boolean isAscendingOrder() {\n+        return ascendingOrder;\n+    }\n+    \n+    /**\n+     * Gets the comparator being used for this buffer, null is natural order.\n+     * \n+     * @return the comparator in use, null is natural order\n+     */\n+    public Comparator comparator() {\n+        return comparator;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns the number of elements in this buffer.\n+     *\n+     * @return the number of elements in this buffer\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    /**\n+     * Clears all elements from the buffer.\n+     */\n+    public void clear() {\n+        elements = new Object[elements.length]; // for gc\n+        size = 0;\n+    }\n+\n+    /**\n+     * Adds an element to the buffer.\n+     * <p>\n+     * The element added will be sorted according to the comparator in use.\n+     *\n+     * @param element  the element to be added\n+     */\n+    public boolean add(Object element) {\n+        if (isAtCapacity()) {\n+            grow();\n+        }\n+        // percolate element to it's place in tree\n+        if (ascendingOrder) {\n+            percolateUpMinHeap(element);\n+        } else {\n+            percolateUpMaxHeap(element);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the next element to be removed without actually removing it (peek).\n+     *\n+     * @return the next element\n+     * @throws BufferUnderflowException if the buffer is empty\n+     */\n+    public Object get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException();\n+        } else {\n+            return elements[1];\n+        }\n+    }\n+\n+    /**\n+     * Gets and removes the next element (pop).\n+     *\n+     * @return the next element\n+     * @throws BufferUnderflowException if the buffer is empty\n+     */\n+    public Object remove() {\n+        final Object result = get();\n+        elements[1] = elements[size--];\n+\n+        // set the unused element to 'null' so that the garbage collector\n+        // can free the object if not used anywhere else.(remove reference)\n+        elements[size + 1] = null;\n+\n+        if (size != 0) {\n+            // percolate top element to it's place in tree\n+            if (ascendingOrder) {\n+                percolateDownMinHeap(1);\n+            } else {\n+                percolateDownMaxHeap(1);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests if the buffer is at capacity.\n+     *\n+     * @return <code>true</code> if buffer is full; <code>false</code> otherwise.\n+     */\n+    protected boolean isAtCapacity() {\n+        //+1 as element 0 is noop\n+        return elements.length == size + 1;\n+    }\n+\n+    \n+    /**\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a mimimum heap.\n+     *\n+     * @param index the index for the element\n+     */\n+    protected void percolateDownMinHeap(final int index) {\n+        final Object element = elements[index];\n+        int hole = index;\n+\n+        while ((hole * 2) <= size) {\n+            int child = hole * 2;\n+\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != size && compare(elements[child + 1], elements[child]) < 0) {\n+                child++;\n+            }\n+\n+            // if we found resting place of bubble then terminate search\n+            if (compare(elements[child], element) >= 0) {\n+                break;\n+            }\n+\n+            elements[hole] = elements[child];\n+            hole = child;\n+        }\n+\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a maximum heap.\n+     *\n+     * @param index the index of the element\n+     */\n+    protected void percolateDownMaxHeap(final int index) {\n+        final Object element = elements[index];\n+        int hole = index;\n+\n+        while ((hole * 2) <= size) {\n+            int child = hole * 2;\n+\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != size && compare(elements[child + 1], elements[child]) > 0) {\n+                child++;\n+            }\n+\n+            // if we found resting place of bubble then terminate search\n+            if (compare(elements[child], element) <= 0) {\n+                break;\n+            }\n+\n+            elements[hole] = elements[child];\n+            hole = child;\n+        }\n+\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element up heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param index the index of the element to be percolated up\n+     */\n+    protected void percolateUpMinHeap(final int index) {\n+        int hole = index;\n+        Object element = elements[hole];\n+        while (hole > 1 && compare(element, elements[hole / 2]) < 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            elements[hole] = elements[next];\n+            hole = next;\n+        }\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMinHeap(final Object element) {\n+        elements[++size] = element;\n+        percolateUpMinHeap(size);\n+    }\n+\n+    /**\n+     * Percolates element up heap from from the position given by the index.\n+     * <p>\n+     * Assume it is a maximum heap.\n+     *\n+     * @param index the index of the element to be percolated up\n+     */\n+    protected void percolateUpMaxHeap(final int index) {\n+        int hole = index;\n+        Object element = elements[hole];\n+\n+        while (hole > 1 && compare(element, elements[hole / 2]) > 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            elements[hole] = elements[next];\n+            hole = next;\n+        }\n+\n+        elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMaxHeap(final Object element) {\n+        elements[++size] = element;\n+        percolateUpMaxHeap(size);\n+    }\n+\n+    /**\n+     * Compares two objects using the comparator if specified, or the\n+     * natural order otherwise.\n+     * \n+     * @param a  the first object\n+     * @param b  the second object\n+     * @return -ve if a less than b, 0 if they are equal, +ve if a greater than b\n+     */\n+    protected int compare(Object a, Object b) {\n+        if (comparator != null) {\n+            return comparator.compare(a, b);\n+        } else {\n+            return ((Comparable) a).compareTo(b);\n+        }\n+    }\n+\n+    /**\n+     * Increases the size of the heap to support additional elements\n+     */\n+    protected void grow() {\n+        final Object[] array = new Object[elements.length * 2];\n+        System.arraycopy(elements, 0, array, 0, elements.length);\n+        elements = array;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an iterator over this heap's elements.\n+     *\n+     * @return an iterator over this heap's elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator() {\n+\n+            private int index = 1;\n+            private int lastReturnedIndex = -1;\n+\n+            public boolean hasNext() {\n+                return index <= size;\n+            }\n+\n+            public Object next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException();\n+                }\n+                lastReturnedIndex = index;\n+                index++;\n+                return elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n+                elements[ lastReturnedIndex ] = elements[ size ];\n+                elements[ size ] = null;\n+                size--;  \n+                if( size != 0 && lastReturnedIndex <= size) {\n+                    int compareToParent = 0;\n+                    if (lastReturnedIndex > 1) {\n+                        compareToParent = compare(elements[lastReturnedIndex], \n+                            elements[lastReturnedIndex / 2]);  \n+                    }\n+                    if (ascendingOrder) {\n+                        if (lastReturnedIndex > 1 && compareToParent < 0) {\n+                            percolateUpMinHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMinHeap(lastReturnedIndex);\n+                        }\n+                    } else {  // max heap\n+                        if (lastReturnedIndex > 1 && compareToParent > 0) {\n+                            percolateUpMaxHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMaxHeap(lastReturnedIndex);\n+                        }\n+                    }          \n+                }\n+                index--;\n+                lastReturnedIndex = -1; \n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Returns a string representation of this heap.  The returned string\n+     * is similar to those produced by standard JDK collections.\n+     *\n+     * @return a string representation of this heap\n+     */\n+    public String toString() {\n+        final StringBuffer sb = new StringBuffer();\n+\n+        sb.append(\"[ \");\n+\n+        for (int i = 1; i < size + 1; i++) {\n+            if (i != 1) {\n+                sb.append(\", \");\n+            }\n+            sb.append(elements[i]);\n+        }\n+\n+        sb.append(\" ]\");\n+\n+        return sb.toString();\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/buffer/TestAll.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestAll.java,v 1.3 2004/01/01 19:01:34 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestAll.java,v 1.4 2004/01/02 02:14:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2004/01/01 19:01:34 $\n+ * @version $Revision: 1.4 $ $Date: 2004/01/02 02:14:28 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n-        suite.addTest(TestBinaryBuffer.suite());\n-        suite.addTest(TestBlockingBuffer.suite());\n         suite.addTest(TestBoundedFifoBuffer.suite());\n         suite.addTest(TestBoundedFifoBuffer2.suite());\n         suite.addTest(TestCircularFifoBuffer.suite());\n+        suite.addTest(TestPriorityBuffer.suite());\n+        suite.addTest(TestUnboundedFifoBuffer.suite());\n+        \n+        suite.addTest(TestBlockingBuffer.suite());\n         suite.addTest(TestPredicatedBuffer.suite());\n         suite.addTest(TestTransformedBuffer.suite());\n-        suite.addTest(TestUnboundedFifoBuffer.suite());\n         \n         return suite;\n     }\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestPriorityBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestPriorityBuffer.java,v 1.1 2004/01/02 02:14:28 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2004 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.ComparatorUtils;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * Tests the PriorityBuffer.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/01/02 02:14:28 $\n+ * \n+ * @author Michael A. Smith\n+ */\n+public class TestPriorityBuffer extends AbstractTestCollection {\n+\n+    public static void main(String[] args) {\n+        junit.textui.TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestPriorityBuffer.class);\n+    }\n+\n+    public TestPriorityBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public void verify() {\n+        super.verify();\n+        PriorityBuffer heap = (PriorityBuffer) collection;\n+\n+        Comparator c = heap.comparator;\n+        if (c == null) {\n+            c = ComparatorUtils.naturalComparator();\n+        }\n+        if (!heap.ascendingOrder) {\n+            c = ComparatorUtils.reversedComparator(c);\n+        }\n+\n+        Object[] tree = heap.elements;\n+        for (int i = 1; i <= heap.size; i++) {\n+            Object parent = tree[i];\n+            if (i * 2 <= heap.size) {\n+                assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n+            }\n+            if (i * 2 + 1 < heap.size) {\n+                assertTrue(\"Parent is less than or equal to its right child\", c.compare(parent, tree[i * 2 + 1]) <= 0);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    /**\n+     * Overridden because BinaryBuffer isn't fail fast.\n+     * @return false\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    public Collection makeConfirmedFullCollection() {\n+        ArrayList list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Return a new, empty {@link Object} to used for testing.\n+     */\n+    public Collection makeCollection() {\n+        return new PriorityBuffer();\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public Object[] getFullElements() {\n+        return getFullNonNullStringElements();\n+    }\n+\n+    public Object[] getOtherElements() {\n+        return getOtherNonNullStringElements();\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public void testBufferEmpty() {\n+        resetEmpty();\n+        Buffer buffer = (Buffer) collection;\n+\n+        assertEquals(0, buffer.size());\n+        assertEquals(true, buffer.isEmpty());\n+        try {\n+            buffer.get();\n+            fail();\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            buffer.remove();\n+            fail();\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+    \n+    public void testBasicOps() {\n+        PriorityBuffer heap = new PriorityBuffer();\n+\n+        heap.add(\"a\");\n+        heap.add(\"c\");\n+        heap.add(\"e\");\n+        heap.add(\"b\");\n+        heap.add(\"d\");\n+        heap.add(\"n\");\n+        heap.add(\"m\");\n+        heap.add(\"l\");\n+        heap.add(\"k\");\n+        heap.add(\"j\");\n+        heap.add(\"i\");\n+        heap.add(\"h\");\n+        heap.add(\"g\");\n+        heap.add(\"f\");\n+\n+        assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+            assertEquals(\n+                \"get using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.get());\n+\n+            assertEquals(\n+                \"remove using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.remove());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are removed\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are removed\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    public void testBasicComparatorOps() {\n+        PriorityBuffer heap = new PriorityBuffer(new ReverseComparator(new ComparableComparator()));\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called before any elements are added\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called before any elements are added\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        heap.add(\"a\");\n+        heap.add(\"c\");\n+        heap.add(\"e\");\n+        heap.add(\"b\");\n+        heap.add(\"d\");\n+        heap.add(\"n\");\n+        heap.add(\"m\");\n+        heap.add(\"l\");\n+        heap.add(\"k\");\n+        heap.add(\"j\");\n+        heap.add(\"i\");\n+        heap.add(\"h\");\n+        heap.add(\"g\");\n+        heap.add(\"f\");\n+\n+        assertTrue(\"heap should not be empty after adds\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+\n+            // note: since we're using a comparator that reverses items, the\n+            // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n+\n+            assertEquals(\n+                \"get using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.get());\n+\n+            assertEquals(\n+                \"remove using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.remove());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are removed\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are removed\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.get();\n+            fail(\"NoSuchElementException should be thrown if get is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+\n+        try {\n+            heap.remove();\n+            fail(\"NoSuchElementException should be thrown if remove is called after all elements are removed\");\n+        } catch (BufferUnderflowException ex) {}\n+    }\n+\n+    /**\n+     * Illustrates bad internal heap state reported in Bugzilla PR #235818. \n+     */  \n+    public void testAddRemove() {\n+        resetEmpty();\n+        PriorityBuffer heap = (PriorityBuffer) collection;\n+        heap.add(new Integer(0));\n+        heap.add(new Integer(2));\n+        heap.add(new Integer(4));\n+        heap.add(new Integer(3));\n+        heap.add(new Integer(8));\n+        heap.add(new Integer(10));\n+        heap.add(new Integer(12));\n+        heap.add(new Integer(3));\n+        confirmed.addAll(heap);\n+        // System.out.println(heap);\n+        Object obj = new Integer(10);\n+        heap.remove(obj);\n+        confirmed.remove(obj);\n+        // System.out.println(heap);\n+        verify();\n+    }\n+    \n+    /**\n+     * Generate heaps staring with Integers from 0 - heapSize - 1.\n+     * Then perform random add / remove operations, checking\n+     * heap order after modifications. Alternates minHeaps, maxHeaps.\n+     *\n+     * Based on code provided by Steve Phelps in PR #25818\n+     *\n+     */\n+    public void testRandom() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        int operations = 20;\n+        Random randGenerator = new Random();\n+        PriorityBuffer h = null;\n+        for(int i=0; i < iterations; i++) {\n+            if (i < iterations / 2) {          \n+                h = new PriorityBuffer(true);\n+            } else {\n+                h = new PriorityBuffer(false);\n+            }\n+            for(int r = 0; r < heapSize; r++) {\n+                h.add( new Integer( randGenerator.nextInt(heapSize)) );\n+            }\n+            for( int r = 0; r < operations; r++ ) {\n+                h.remove(new Integer(r));\n+                h.add(new Integer(randGenerator.nextInt(heapSize)));\n+            }\n+            checkOrder(h);\n+        }\n+    }\n+     \n+    /**\n+     * Pops all elements from the heap and verifies that the elements come off\n+     * in the correct order.  NOTE: this method empties the heap.\n+     */\n+    protected void checkOrder(PriorityBuffer h) {\n+        Integer lastNum = null;\n+        Integer num = null;\n+        boolean fail = false;\n+        while (!h.isEmpty()) {\n+            num = (Integer) h.remove();\n+            if (h.ascendingOrder) {\n+                assertTrue(lastNum == null || num.intValue() >= lastNum.intValue());\n+            } else { // max heap\n+                assertTrue(lastNum == null || num.intValue() <= lastNum.intValue());\n+            }\n+            lastNum = num;\n+            num = null;\n+        }\n+    }\n+    \n+    /**\n+     * Returns a string showing the contents of the heap formatted as a tree.\n+     * Makes no attempt at padding levels or handling wrapping. \n+     */\n+    protected String showTree(PriorityBuffer h) {\n+        int count = 1;\n+        StringBuffer buffer = new StringBuffer();\n+        for (int offset = 1; count < h.size() + 1; offset *= 2) {\n+            for (int i = offset; i < offset * 2; i++) {\n+                if (i < h.elements.length && h.elements[i] != null) \n+                    buffer.append(h.elements[i] + \" \");\n+                count++;\n+            }\n+            buffer.append('\\n');\n+        }\n+        return buffer.toString();\n+    }\n+    \n+}", "timestamp": 1073009669, "metainfo": ""}