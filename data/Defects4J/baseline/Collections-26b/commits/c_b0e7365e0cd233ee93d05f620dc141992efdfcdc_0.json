{"sha": "b0e7365e0cd233ee93d05f620dc141992efdfcdc", "log": "[COLLECTIONS-508] Initial commit of new MultiValuedMap interface + implementations. Thanks to Dipanjan Laha.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.List;\n+\n+/**\n+ * Defines a map that holds a list of values against each key.\n+ * <p>\n+ * A <code>ListValuedMap</code> is a Map with slightly different semantics:\n+ * <ul>\n+ *   <li>Putting a value into the map will add the value to a Collection at that key.</li>\n+ *   <li>Getting a value will return a Collection, holding all the values put to that key.</li>\n+ * </ul>\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public interface ListValuedMap<K, V> extends MultiValuedMap<K, V> {\n+\n+    /**\n+     * Gets the list of values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> if no values have been\n+     * mapped to the key, however the implementation may choose to return an\n+     * empty collection.\n+     * <p>\n+     * Implementations may choose to return a clone of the internal collection.\n+     *\n+     * @param key the key to retrieve\n+     * @return the <code>Collection</code> of values, implementations should\n+     *         return <code>null</code> for no mapping, but may return an empty collection\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    List<V> get(Object key);\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> from a subsequent\n+     * <code>get(Object)</code>, however they may choose to return an empty\n+     * collection.\n+     *\n+     * @param key the key to remove values from\n+     * @return the <code>Collection</code> of values removed, implementations\n+     *         should return <code>null</code> for no mapping found, but may\n+     *         return an empty collection\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    List<V> remove(Object key);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+/**\n+ * Defines a map that holds a collection of values against each key.\n+ * <p>\n+ * A <code>MultiValuedMap</code> is a Map with slightly different semantics:\n+ * <ul>\n+ *   <li>Putting a value into the map will add the value to a Collection at that key.</li>\n+ *   <li>Getting a value will return a Collection, holding all the values put to that key.</li>\n+ * </ul>\n+ * <p>\n+ * For example:\n+ * <pre>\n+ * MultiValuedMap&lt;K, String&gt; map = new MultiValuedHashMap&lt;K, String&gt;();\n+ * map.put(key, &quot;A&quot;);\n+ * map.put(key, &quot;B&quot;);\n+ * map.put(key, &quot;C&quot;);\n+ * Collection&lt;String&gt; coll = map.get(key);\n+ * </pre>\n+ * <p>\n+ * <code>coll</code> will be a collection containing \"A\", \"B\", \"C\".\n+ * <p>\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public interface MultiValuedMap<K, V> {\n+    // Query operations\n+\n+    /**\n+     * Gets the total size of the map.\n+     * <p>\n+     * Implementations would return the total size of the map which is the count\n+     * of the values from all keys.\n+     *\n+     * @return the total size of the map\n+     */\n+    int size();\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains no key-value mappings.\n+     *\n+     * @return <tt>true</tt> if this map contains no key-value mappings\n+     */\n+    boolean isEmpty();\n+\n+    /**\n+     * Returns <tt>true</tt> if this map contains a mapping for the specified\n+     * key. More formally, returns <tt>true</tt> if and only if this map\n+     * contains a mapping for a key <tt>k</tt> such that\n+     * <tt>(key==null ? k==null : key.equals(k))</tt>. (There can be at most one\n+     * such mapping.)\n+     *\n+     * @param key key whose presence in this map is to be tested\n+     * @return <tt>true</tt> if this map contains a mapping for the specified key\n+     * @throws ClassCastException if the key is of an inappropriate type for this map (optional)\n+     * @throws NullPointerException if the specified key is null and this map\n+     *         does not permit null keys (optional)\n+     */\n+    boolean containsKey(Object key);\n+\n+    /**\n+     * Checks whether the map contains at least one mapping for the specified value.\n+     *\n+     * @param value the value to search for\n+     * @return true if the map contains the value\n+     * @throws ClassCastException if the value is of an invalid type\n+     * @throws NullPointerException if the value is null and null value are invalid\n+     */\n+    boolean containsValue(Object value);\n+\n+    /**\n+     * Checks whether the map contains a mapping for the specified key and value.\n+     *\n+     * @param key the key to search for\n+     * @param value the value to search for\n+     * @return true if the map contains the value\n+     */\n+    boolean containsMapping(Object key, Object value);\n+\n+    /**\n+     * Gets the collection of values associated with the specified key.\n+     * <p>\n+     * Implementations are free to declare that they return\n+     * <code>Collection</code> subclasses such as <code>List</code> or\n+     * <code>Set</code>.\n+     * <p>\n+     * Implementations typically return <code>null</code> if no values have been\n+     * mapped to the key, however the implementation may choose to return an\n+     * empty collection.\n+     * <p>\n+     * Implementations may choose to return a clone of the internal collection.\n+     *\n+     * @param key the key to retrieve\n+     * @return the <code>Collection</code> of values, implementations should\n+     *         return <code>null</code> for no mapping, but may return an empty collection\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Collection<V> get(Object key);\n+\n+    // Modification operations\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     * The collection may be a <code>List</code>, <code>Set</code> or other\n+     * collection dependent on implementation.\n+     *\n+     * @param key the key to store against\n+     * @param value the value to add to the collection at the key\n+     * @return typically the value added if the map changed and null if the map\n+     *         did not change\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type\n+     * @throws NullPointerException if the key or value is null and null is invalid\n+     * @throws IllegalArgumentException if the key or value is invalid\n+     */\n+    V put(K key, V value);\n+\n+    /**\n+     * Adds Iterable values to the collection associated with the specified key.\n+     *\n+     * @param key the key to store against\n+     * @param values the values to add to the collection at the key, null ignored\n+     * @return true if this map changed\n+     */\n+    boolean putAll(K key, Iterable<? extends V> values);\n+\n+    /**\n+     * Copies all of the mappings from the specified map to this map (optional\n+     * operation). The effect of this call is equivalent to that of calling\n+     * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n+     * from key <tt>k</tt> to value <tt>v</tt> in the specified map. The\n+     * behavior of this operation is undefined if the specified map is modified\n+     * while the operation is in progress.\n+     *\n+     * @param m mappings to be stored in this map\n+     * @throws UnsupportedOperationException if the <tt>putAll</tt> operation is\n+     *         not supported by this map\n+     * @throws ClassCastException if the class of a key or value in the\n+     *         specified map prevents it from being stored in this map\n+     * @throws NullPointerException if the specified map is null, or if this map\n+     *         does not permit null keys or values, and the specified map\n+     *         contains null keys or values\n+     * @throws IllegalArgumentException if some property of a key or value in\n+     *         the specified map prevents it from being stored in this map\n+     */\n+    void putAll(Map<? extends K, ? extends V> m);\n+\n+    /**\n+     * Copies all of the mappings from the specified MultiValuedMap to this map\n+     * (optional operation). The effect of this call is equivalent to that of\n+     * calling {@link #put(Object,Object) put(k, v)} on this map once for each\n+     * mapping from key <tt>k</tt> to value <tt>v</tt> in the specified map. The\n+     * behavior of this operation is undefined if the specified map is modified\n+     * while the operation is in progress.\n+     *\n+     * @param m mappings to be stored in this map\n+     * @throws UnsupportedOperationException if the <tt>putAll</tt> operation is\n+     *         not supported by this map\n+     * @throws ClassCastException if the class of a key or value in the\n+     *         specified map prevents it from being stored in this map\n+     * @throws NullPointerException if the specified map is null, or if this map\n+     *         does not permit null keys or values, and the specified map\n+     *         contains null keys or values\n+     * @throws IllegalArgumentException if some property of a key or value in\n+     *         the specified map prevents it from being stored in this map\n+     */\n+    void putAll(MultiValuedMap<? extends K, ? extends V> m);\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * Implementations typically return <code>null</code> from a subsequent\n+     * <code>get(Object)</code>, however they may choose to return an empty\n+     * collection.\n+     *\n+     * @param key the key to remove values from\n+     * @return the <code>Collection</code> of values removed, implementations\n+     *         should return <code>null</code> for no mapping found, but may\n+     *         return an empty collection\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key is of an invalid type\n+     * @throws NullPointerException if the key is null and null keys are invalid\n+     */\n+    Collection<V> remove(Object key);\n+\n+    /**\n+     * Removes a key-value mapping from the map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, implementations typically return\n+     * <code>null</code> from a subsequent <code>get(Object)</code>, however\n+     * they may choose to return an empty collection.\n+     *\n+     * @param key the key to remove from\n+     * @param item the item to remove\n+     * @return {@code true} if the mapping was removed, {@code false} otherwise\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     * @throws ClassCastException if the key or value is of an invalid type\n+     * @throws NullPointerException if the key or value is null and null is\n+     *         invalid\n+     */\n+    boolean removeMapping(K key, V item);\n+\n+    /**\n+     * Removes all of the mappings from this map (optional operation).\n+     * The map will be empty after this call returns.\n+     *\n+     * @throws UnsupportedOperationException if the map is unmodifiable\n+     */\n+    void clear();\n+\n+    // Views\n+\n+    /**\n+     * Returns a {@link Collection} view of the mappings contained in this map.\n+     * The collection is backed by the map, so changes to the map are reflected\n+     * in this, and vice-versa.\n+     *\n+     * @return a set view of the mappings contained in this map\n+     */\n+    Collection<Entry<K, V>> entries();\n+\n+    /**\n+     * Returns a {@link Bag} view of the key mapping contained in this map.\n+     * <p>\n+     * Implementations typically return a Bag of keys with its values count as\n+     * the count of the Bag. This bag is backed by the map, so any changes in\n+     * the map is reflected here.\n+     *\n+     * @return a bag view of the key mapping contained in this map\n+     */\n+    Bag<K> keys();\n+\n+    /**\n+     * Returns a {@link Set} view of the keys contained in this map. The set is\n+     * backed by the map, so changes to the map are reflected in the set, and\n+     * vice-versa. If the map is modified while an iteration over the set is in\n+     * progress (except through the iterator's own <tt>remove</tt> operation),\n+     * the results of the iteration are undefined. The set supports element\n+     * removal, which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n+     * <tt>retainAll</tt>, and <tt>clear</tt> operations. It does not support\n+     * the <tt>add</tt> or <tt>addAll</tt> operations.\n+     *\n+     * @return a set view of the keys contained in this map\n+     */\n+    Set<K> keySet();\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * Implementations typically return a collection containing the combination\n+     * of values from all keys.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    Collection<V> values();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.AbstractCollection;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.Factory;\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.bag.HashBag;\n+import org.apache.commons.collections4.functors.InstantiateFactory;\n+import org.apache.commons.collections4.iterators.EmptyIterator;\n+import org.apache.commons.collections4.iterators.IteratorChain;\n+import org.apache.commons.collections4.iterators.LazyIteratorChain;\n+import org.apache.commons.collections4.iterators.TransformIterator;\n+\n+/**\n+ * Abstract implementation of the {@link MultiValuedMap} interface to simplify\n+ * the creation of subclass implementations.\n+ * <p>\n+ * Subclasses specify a Map implementation to use as the internal storage.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V>, Serializable {\n+\n+    /** Serialization Version */\n+    private static final long serialVersionUID = 7994988366330224277L;\n+\n+    /** The factory for creating value collections. */\n+    private final Factory<? extends Collection<V>> collectionFactory;\n+\n+    /** The values view */\n+    private transient Collection<V> valuesView;\n+\n+    /** The EntryValues view */\n+    private transient EntryValues entryValuesView;\n+\n+    /** The KeyBag view */\n+    private transient KeysBag keysBagView;\n+\n+    /** The map used to store the data */\n+    private final Map<K, Collection<V>> map;\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param <C>  the collection type\n+     * @param map  the map to wrap, must not be null\n+     * @param collectionClazz  the collection class\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map,\n+                                                               final Class<C> collectionClazz) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        this.map = (Map<K, Collection<V>>) map;\n+        this.collectionFactory = new InstantiateFactory<C>(collectionClazz);\n+    }\n+\n+    /**\n+     * Gets the map being wrapped.\n+     *\n+     * @return the wrapped map\n+     */\n+    protected Map<K, Collection<V>> getMap() {\n+        return map;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsKey(Object key) {\n+        return getMap().containsKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsValue(final Object value) {\n+        final Set<Map.Entry<K, Collection<V>>> pairs = getMap().entrySet();\n+        if (pairs != null) {\n+            for (final Map.Entry<K, Collection<V>> entry : pairs) {\n+                if (entry.getValue().contains(value)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsMapping(Object key, Object value) {\n+        final Collection<V> col = get(key);\n+        if (col == null) {\n+            return false;\n+        }\n+        return col.contains(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Collection<Entry<K, V>> entries() {\n+        return entryValuesView != null ? entryValuesView : (entryValuesView = new EntryValues());\n+    }\n+\n+    /**\n+     * Gets the collection of values associated with the specified key.\n+     *\n+     * @param key the key to retrieve\n+     * @return the <code>Collection</code> of values, will return\n+     *         <code>null</code> for no mapping\n+     * @throws ClassCastException if the key is of an invalid type\n+     */\n+    public Collection<V> get(Object key) {\n+        return getMap().get(key);\n+    }\n+\n+    /**\n+     * Removes all values associated with the specified key.\n+     * <p>\n+     * A subsequent <code>get(Object)</code> would return null collection.\n+     *\n+     * @param key the key to remove values from\n+     * @return the <code>Collection</code> of values removed, will return\n+     *         <code>null</code> for no mapping found.\n+     * @throws ClassCastException if the key is of an invalid type\n+     */\n+    public Collection<V> remove(Object key) {\n+        return getMap().remove(key);\n+    }\n+\n+    /**\n+     * Removes a specific value from map.\n+     * <p>\n+     * The item is removed from the collection mapped to the specified key.\n+     * Other values attached to that key are unaffected.\n+     * <p>\n+     * If the last value for a key is removed, <code>null</code> would be\n+     * returned from a subsequent <code>get(Object)</code>.\n+     *\n+     * @param key the key to remove from\n+     * @param item the item to remove\n+     * @return {@code true} if the mapping was removed, {@code false} otherwise\n+     */\n+    public boolean removeMapping(K key, V item) {\n+        boolean result = false;\n+        final Collection<V> col = get(key);\n+        if (col == null) {\n+            return false;\n+        }\n+        result = col.remove(item);\n+        if (!result) {\n+            return false;\n+        }\n+        if (col.isEmpty()) {\n+            remove(key);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isEmpty() {\n+        return getMap().isEmpty();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<K> keySet() {\n+        return getMap().keySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (Collection<V> col : getMap().values()) {\n+            size += col.size();\n+        }\n+        return size;\n+    }\n+\n+    /**\n+     * Gets a collection containing all the values in the map.\n+     * <p>\n+     * Returns a collection containing all the values from all keys.\n+     *\n+     * @return a collection view of the values contained in this map\n+     */\n+    public Collection<V> values() {\n+        final Collection<V> vs = valuesView;\n+        return vs != null ? vs : (valuesView = new Values());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void clear() {\n+        getMap().clear();\n+    }\n+\n+    /**\n+     * Adds the value to the collection associated with the specified key.\n+     * <p>\n+     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Instead the new value is added to the collection stored against the key.\n+     *\n+     * @param key the key to store against\n+     * @param value the value to add to the collection at the key\n+     * @return the value added if the map changed and null if the map did not\n+     *         change\n+     */\n+    public V put(K key, V value) {\n+        boolean result = false;\n+        Collection<V> coll = get(key);\n+        if (coll == null) {\n+            coll = createCollection();\n+            coll.add(value);\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                getMap().put(key, coll);\n+                result = true; // map definitely changed\n+            }\n+        } else {\n+            result = coll.add(value);\n+        }\n+        return result ? value : null;\n+    }\n+\n+    /**\n+     * Copies all of the mappings from the specified map to this map. The effect\n+     * of this call is equivalent to that of calling {@link #put(Object,Object)\n+     * put(k, v)} on this map once for each mapping from key <tt>k</tt> to value\n+     * <tt>v</tt> in the specified map. The behavior of this operation is\n+     * undefined if the specified map is modified while the operation is in\n+     * progress.\n+     *\n+     * @param map mappings to be stored in this map\n+     */\n+    public void putAll(final Map<? extends K, ? extends V> map) {\n+        if (map != null) {\n+            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+                put((K) entry.getKey(), (V) entry.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copies all of the mappings from the specified MultiValuedMap to this map.\n+     * The effect of this call is equivalent to that of calling\n+     * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n+     * from key <tt>k</tt> to value <tt>v</tt> in the specified map. The\n+     * behavior of this operation is undefined if the specified map is modified\n+     * while the operation is in progress.\n+     *\n+     * @param map mappings to be stored in this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void putAll(MultiValuedMap<? extends K, ? extends V> map) {\n+        if (map != null) {\n+            for (final K key : map.keySet()) {\n+                putAll(key, (Collection<V>) map.get(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a {@link Bag} view of the key mapping contained in this map.\n+     * <p>\n+     * Returns a Bag of keys with its values count as the count of the Bag. This\n+     * bag is backed by the map, so any changes in the map is reflected here.\n+     * Any method which modifies this bag like <tt>add</tt>, <tt>remove</tt>,\n+     * <tt>Iterator.remove</tt> etc throws\n+     * <code>UnsupportedOperationException</code>\n+     *\n+     * @return a bag view of the key mapping contained in this map\n+     */\n+    public Bag<K> keys() {\n+        return keysBagView != null ? keysBagView : (keysBagView = new KeysBag());\n+    }\n+\n+    /**\n+     * Adds Iterable values to the collection associated with the specified key.\n+     *\n+     * @param key the key to store against\n+     * @param values the values to add to the collection at the key, null\n+     *        ignored\n+     * @return true if this map changed\n+     */\n+    public boolean putAll(final K key, final Iterable<? extends V> values) {\n+        if (values == null || values.iterator() == null || !values.iterator().hasNext()) {\n+            return false;\n+        }\n+        Iterator<? extends V> it = values.iterator();\n+        boolean result = false;\n+        Collection<V> coll = get(key);\n+        if (coll == null) {\n+            coll = createCollection(); // might produce a non-empty collection\n+            while (it.hasNext()) {\n+                coll.add(it.next());\n+            }\n+            if (coll.size() > 0) {\n+                // only add if non-zero size to maintain class state\n+                getMap().put(key, coll);\n+                result = true; // map definitely changed\n+            }\n+        } else {\n+            while (it.hasNext()) {\n+                boolean tmpResult = coll.add(it.next());\n+                if (!result && tmpResult) {\n+                    // If any one of the values have been added, the map has\n+                    // changed\n+                    result = true;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Gets an iterator for the collection mapped to the specified key.\n+     *\n+     * @param key the key to get an iterator for\n+     * @return the iterator of the collection at the key, empty iterator if key\n+     *         not in map\n+     */\n+    public Iterator<V> iterator(final Object key) {\n+        if (!containsKey(key)) {\n+            return EmptyIterator.<V> emptyIterator();\n+        }\n+        return new ValuesIterator(key);\n+    }\n+\n+    /**\n+     * Gets the size of the collection mapped to the specified key.\n+     *\n+     * @param key the key to get size for\n+     * @return the size of the collection at the key, zero if key not in map\n+     */\n+    public int size(final Object key) {\n+        final Collection<V> coll = get(key);\n+        if (coll == null) {\n+            return 0;\n+        }\n+        return coll.size();\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (obj instanceof MultiValuedMap == false) {\n+            return false;\n+        }\n+        MultiValuedMap<?, ?> other = (MultiValuedMap<?, ?>) obj;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        Iterator it = keySet().iterator();\n+        while (it.hasNext()) {\n+            Object key = it.next();\n+            Collection<?> col = get(key);\n+            Collection<?> otherCol = other.get(key);\n+            if (otherCol == null) {\n+                return false;\n+            }\n+            if (col.size() != otherCol.size()) {\n+                return false;\n+            }\n+            for (Object value : col) {\n+                if (!otherCol.contains(value)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return getMap().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getMap().toString();\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    protected Collection<V> createCollection() {\n+        return collectionFactory.create();\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    /**\n+     * Inner class that provides a Bag<K> keys view\n+     */\n+    private class KeysBag implements Bag<K> {\n+\n+        public boolean addAll(Collection<? extends K> c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return getMap().containsKey(o);\n+        }\n+\n+        public boolean isEmpty() {\n+            return getMap().isEmpty();\n+        }\n+\n+        public Object[] toArray() {\n+            final Object[] result = new Object[size()];\n+            int i = 0;\n+            final Iterator<K> it = getMap().keySet().iterator();\n+            while (it.hasNext()) {\n+                final K current = it.next();\n+                for (int index = getCount(current); index > 0; index--) {\n+                    result[i++] = current;\n+                }\n+            }\n+            return result;\n+        }\n+\n+        public <T> T[] toArray(T[] array) {\n+            final int size = size();\n+            if (array.length < size) {\n+                @SuppressWarnings(\"unchecked\")\n+                // safe as both are of type T\n+                final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n+                array = unchecked;\n+            }\n+\n+            int i = 0;\n+            final Iterator<K> it = getMap().keySet().iterator();\n+            while (it.hasNext()) {\n+                final K current = it.next();\n+                for (int index = getCount(current); index > 0; index--) {\n+                    // unsafe, will throw ArrayStoreException if types are not\n+                    // compatible, see javadoc\n+                    @SuppressWarnings(\"unchecked\")\n+                    final T unchecked = (T) current;\n+                    array[i++] = unchecked;\n+                }\n+            }\n+            while (i < array.length) {\n+                array[i++] = null;\n+            }\n+            return array;\n+        }\n+\n+        public int getCount(Object object) {\n+            int count = 0;\n+            Collection<V> col = AbstractMultiValuedMap.this.getMap().get(object);\n+            if (col != null) {\n+                count = col.size();\n+            }\n+            return count;\n+        }\n+\n+        public boolean add(K object) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean add(K object, int nCopies) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean remove(Object object) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean remove(Object object, int nCopies) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set<K> uniqueSet() {\n+            return keySet();\n+        }\n+\n+        public int size() {\n+            return AbstractMultiValuedMap.this.size();\n+        }\n+\n+        public boolean containsAll(Collection<?> coll) {\n+            if (coll instanceof Bag) {\n+                return containsAll((Bag<?>) coll);\n+            }\n+            return containsAll(new HashBag<Object>(coll));\n+        }\n+\n+        private boolean containsAll(final Bag<?> other) {\n+            final Iterator<?> it = other.uniqueSet().iterator();\n+            while (it.hasNext()) {\n+                final Object current = it.next();\n+                if (getCount(current) < other.getCount(current)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        public boolean removeAll(Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean retainAll(Collection<?> coll) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Iterator<K> iterator() {\n+            return new LazyIteratorChain<K>() {\n+\n+                final Iterator<K> keyIterator = getMap().keySet().iterator();\n+\n+                @Override\n+                protected Iterator<? extends K> nextIterator(int count) {\n+                    if (!keyIterator.hasNext()) {\n+                        return null;\n+                    }\n+                    final K key = keyIterator.next();\n+                    final Iterator<V> colIterator = getMap().get(key).iterator();\n+                    Iterator<K> nextIt = new Iterator<K>() {\n+\n+                        public boolean hasNext() {\n+                            return colIterator.hasNext();\n+                        }\n+\n+                        public K next() {\n+                            colIterator.next();// Increment the iterator\n+                            // The earlier statement would throw\n+                            // NoSuchElementException anyway in case it ends\n+                            return key;\n+                        }\n+\n+                        public void remove() {\n+                            throw new UnsupportedOperationException();\n+                        }\n+                    };\n+                    return nextIt;\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    /**\n+     * Inner class that provides the Entry<K, V> view\n+     */\n+    private class EntryValues extends AbstractCollection<Entry<K, V>> {\n+\n+        @Override\n+        public Iterator<Entry<K, V>> iterator() {\n+            return new LazyIteratorChain<Entry<K, V>>() {\n+\n+                final Collection<K> keysCol = new ArrayList<K>(getMap().keySet());\n+                final Iterator<K> keyIterator = keysCol.iterator();\n+\n+                @Override\n+                protected Iterator<? extends Entry<K, V>> nextIterator(int count) {\n+                    if (!keyIterator.hasNext()) {\n+                        return null;\n+                    }\n+                    final K key = keyIterator.next();\n+                    final Transformer<V, Entry<K, V>> entryTransformer = new Transformer<V, Entry<K, V>>() {\n+\n+                        public Entry<K, V> transform(final V input) {\n+                            return new Entry<K, V>() {\n+\n+                                public K getKey() {\n+                                    return key;\n+                                }\n+\n+                                public V getValue() {\n+                                    return input;\n+                                }\n+\n+                                public V setValue(V value) {\n+                                    throw new UnsupportedOperationException();\n+                                }\n+                            };\n+                        }\n+                    };\n+                    return new TransformIterator<V, Entry<K, V>>(new ValuesIterator(key), entryTransformer);\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public int size() {\n+            return AbstractMultiValuedMap.this.size();\n+        }\n+\n+    }\n+\n+    /**\n+     * Inner class that provides the values view.\n+     */\n+    private class Values extends AbstractCollection<V> {\n+        @Override\n+        public Iterator<V> iterator() {\n+            final IteratorChain<V> chain = new IteratorChain<V>();\n+            for (final K k : keySet()) {\n+                chain.addIterator(new ValuesIterator(k));\n+            }\n+            return chain;\n+        }\n+\n+        @Override\n+        public int size() {\n+            return AbstractMultiValuedMap.this.size();\n+        }\n+\n+        @Override\n+        public void clear() {\n+            AbstractMultiValuedMap.this.clear();\n+        }\n+    }\n+\n+    /**\n+     * Inner class that provides the values iterator.\n+     */\n+    private class ValuesIterator implements Iterator<V> {\n+        private final Object key;\n+        private final Collection<V> values;\n+        private final Iterator<V> iterator;\n+\n+        public ValuesIterator(final Object key) {\n+            this.key = key;\n+            this.values = get(key);\n+            this.iterator = values.iterator();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+            if (values.isEmpty()) {\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public V next() {\n+            return iterator.next();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.MultiValuedMap;\n+\n+/**\n+ * Decorates another <code>MultiValuedMap</code> to provide additional behaviour.\n+ * <p>\n+ * Each method call made on this <code>MultiValuedMap</code> is forwarded to the\n+ * decorated <code>MultiValuedMap</code>. This class is used as a framework to\n+ * build to extensions such as synchronized and unmodifiable behaviour.\n+ *\n+ * @param <K> the type of key elements\n+ * @param <V> the type of value elements\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class AbstractMultiValuedMapDecorator<K, V>\n+        implements MultiValuedMap<K, V>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -9184930955231260637L;\n+\n+    /** MultiValuedMap to decorate */\n+    private final MultiValuedMap<K, V> map;\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    protected AbstractMultiValuedMapDecorator(final MultiValuedMap<K, V> map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"MultiValuedMap must not be null\");\n+        }\n+        this.map = map;\n+    }\n+\n+    protected MultiValuedMap<K, V> decorated() {\n+        return map;\n+    }\n+\n+    public int size() {\n+        return decorated().size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return decorated().isEmpty();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return decorated().containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return decorated().containsValue(value);\n+    }\n+\n+    public boolean containsMapping(Object key, Object value) {\n+        return decorated().containsMapping(key, value);\n+    }\n+\n+    public Collection<V> get(Object key) {\n+        return decorated().get(key);\n+    }\n+\n+    public Collection<V> remove(Object key) {\n+        return decorated().remove(key);\n+    }\n+\n+    public boolean removeMapping(K key, V item) {\n+        return decorated().removeMapping(key, item);\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+\n+    public V put(K key, V value) {\n+        return decorated().put(key, value);\n+    }\n+\n+    public Set<K> keySet() {\n+        return decorated().keySet();\n+    }\n+\n+    public Collection<Entry<K, V>> entries() {\n+        return decorated().entries();\n+    }\n+\n+    public Bag<K> keys() {\n+        return decorated().keys();\n+    }\n+\n+    public Collection<V> values() {\n+        return decorated().values();\n+    }\n+\n+    public boolean putAll(K key, Iterable<? extends V> values) {\n+        return decorated().putAll(key, values);\n+    }\n+\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        decorated().putAll(m);\n+    }\n+\n+    public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n+        decorated().putAll(m);\n+    }\n+\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        return decorated().equals(object);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return decorated().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return decorated().toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+\n+/**\n+ * Implements a {@link MultiValuedMap}, using a {@link HashMap} to provide data\n+ * storage. This is the standard implementation of a MultiValuedMap\n+ * <p>\n+ * A <code>MultiValuedMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that\n+ * key\n+ * <p>\n+ * In addition, this implementation allows the type of collection used for the\n+ * values to be controlled. By default, an <code>ArrayList</code> is used,\n+ * however a <code>Class<? extends Collection></code> to instantiate the value\n+ * collection may be specified.\n+ * <p>\n+ * <strong>Note that MultiValuedHashMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class MultiValuedHashMap<K, V> extends AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V> {\n+\n+    /** Serialization Version */\n+    private static final long serialVersionUID = -5845183518195365857L;\n+\n+    /**\n+     * Creates a MultiValuedHashMap which maps keys to collections of type\n+     * <code>collectionClass</code>.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the collection class type\n+     * @param collectionClass the type of the collection class\n+     * @return a new MultiValuedMap\n+     */\n+    public static <K, V, C extends Collection<V>> MultiValuedMap<K, V> multiValuedMap(\n+            final Class<C> collectionClass) {\n+        return new MultiValuedHashMap<K, V>(collectionClass);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>HashMap</code> which stores the\n+     * multiple values in an <code>ArrayList</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedHashMap() {\n+        this(ArrayList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a <code>MultiValuedMap</code> to copy into this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+        this(ArrayList.class);\n+        super.putAll(map);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a <code>Map</code> to copy into this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedHashMap(final Map<? extends K, ? extends V> map) {\n+        this(ArrayList.class);\n+        super.putAll(map);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedHashMap which creates the value collections using\n+     * the supplied <code>collectionClazz</code>.\n+     *\n+     * @param <C>  the collection type\n+     * @param collectionClazz  the class of the <code>Collection</code> to use to\n+     *   create the value collections\n+     */\n+    protected <C extends Collection<V>> MultiValuedHashMap(final Class<C> collectionClazz) {\n+        super(new HashMap<K, Collection<V>>(), collectionClazz);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.map.LinkedMap;\n+\n+/**\n+ * Decorates another <code>MultiValuedMap</code> to transform objects that are added.\n+ * <p>\n+ * This class affects the MultiValuedMap put methods. Thus objects must be\n+ * removed or searched for using their transformed form. For example, if the\n+ * transformation converts Strings to Integers, you must use the Integer form to\n+ * remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMultiValuedMap is not synchronized and is not thread-safe.</strong>\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class TransformedMultiValuedMap<K, V> extends AbstractMultiValuedMapDecorator<K, V> {\n+\n+    /** Serialization Version */\n+    private static final long serialVersionUID = -1254147899086470720L;\n+\n+    private final Transformer<? super K, ? extends K> keyTransformer;\n+\n+    private final Transformer<? super V, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming MultiValuedMap.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are\n+     * NOT transformed. Contrast this with\n+     * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the MultiValuedMap to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     *        means no transformation\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     *        means no transformation\n+     * @return a new transformed MultiValuedMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        return new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    /**\n+     * Factory method to create a transforming MultiValuedMap that will\n+     * transform existing contents of the specified map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they will\n+     * be transformed by this method. Contrast this with\n+     * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map the MultiValuedMap to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     *        means no transformation\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     *        means no transformation\n+     * @return a new transformed MultiValuedMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n+        final TransformedMultiValuedMap<K, V> decorated =\n+                new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n+        if (map.size() > 0) {\n+            MultiValuedMap<K, V> transformed = decorated.transformMultiValuedMap(map);\n+            decorated.clear();\n+            // to avoid double transform\n+            decorated.decorated().putAll(transformed);\n+        }\n+        return decorated;\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map the MultiValuedMap to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     *        means no conversion\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     *        means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedMultiValuedMap(MultiValuedMap<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer, Transformer<? super V, ? extends V> valueTransformer) {\n+        super(map);\n+        this.keyTransformer = keyTransformer;\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @return the transformed object\n+     */\n+    protected K transformKey(final K object) {\n+        if (keyTransformer == null) {\n+            return object;\n+        }\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @return the transformed object\n+     */\n+    protected V transformValue(final V object) {\n+        if (valueTransformer == null) {\n+            return object;\n+        }\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map the map to transform\n+     * @return the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Transforms a MultiValuedMap.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map the MultiValuedMap to transform\n+     * @return the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MultiValuedMap<K, V> transformMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+        if (map.isEmpty()) {\n+            return (MultiValuedMap<K, V>) map;\n+        }\n+        final MultiValuedMap<K, V> result = new MultiValuedHashMap<K, V>();\n+\n+        for (final Map.Entry<? extends K, ? extends V> entry : map.entries()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        K transformedKey = transformKey(key);\n+        V transformedValue = transformValue(value);\n+        return decorated().put(transformedKey, transformedValue);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean putAll(K key, Iterable<? extends V> values) {\n+        if (values == null || values.iterator() == null || !values.iterator().hasNext()) {\n+            return false;\n+        }\n+        K transformedKey = transformKey(key);\n+        List<V> transformedValues = new LinkedList<V>();\n+        Iterator<V> it = (Iterator<V>) values.iterator();\n+        while (it.hasNext()) {\n+            transformedValues.add(transformValue(it.next()));\n+        }\n+        return decorated().putAll(transformedKey, transformedValues);\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        if (m == null) {\n+            return;\n+        }\n+        decorated().putAll(transformMap(m));\n+    }\n+\n+    @Override\n+    public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n+        if (m == null) {\n+            return;\n+        }\n+        decorated().putAll(transformMultiValuedMap(m));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.Unmodifiable;\n+import org.apache.commons.collections4.bag.UnmodifiableBag;\n+import org.apache.commons.collections4.collection.UnmodifiableCollection;\n+import org.apache.commons.collections4.set.UnmodifiableSet;\n+\n+/**\n+ * Decorates another {@link MultiValuedMap} to ensure it can't be altered.\n+ * <p>\n+ * Attempts to modify it will result in an UnsupportedOperationException.\n+ *\n+ * @param <K> the type of key elements\n+ * @param <V> the type of value elements\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class UnmodifiableMultiValuedMap<K, V>\n+        extends AbstractMultiValuedMapDecorator<K, V> implements Unmodifiable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 1418669828214151566L;\n+\n+    /**\n+     * Factory method to create an unmodifiable MultiValuedMap.\n+     * <p>\n+     * If the map passed in is already unmodifiable, it is returned.\n+     *\n+     * @param <K> the type of key elements\n+     * @param <V> the type of value elements\n+     * @param map the map to decorate, must not be null\n+     * @return an unmodifiable MultiValuedMap\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> UnmodifiableMultiValuedMap<K, V>\n+            unmodifiableMultiValuedMap(MultiValuedMap<? extends K, ? extends V> map) {\n+        if (map instanceof Unmodifiable) {\n+            return (UnmodifiableMultiValuedMap<K, V>) map;\n+        }\n+        return new UnmodifiableMultiValuedMap<K, V>(map);\n+    }\n+\n+    /**\n+     * Constructor that wraps (not copies).\n+     *\n+     * @param map the MultiValuedMap to decorate, must not be null\n+     * @throws IllegalArgumentException if the map is null\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private UnmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+        super((MultiValuedMap<K, V>) map);\n+    }\n+\n+    @Override\n+    public Collection<V> remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeMapping(K key, V item) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        return UnmodifiableSet.<K>unmodifiableSet(decorated().keySet());\n+    }\n+\n+    @Override\n+    public Collection<Entry<K, V>> entries() {\n+        return UnmodifiableCollection.<Entry<K, V>>unmodifiableCollection(decorated().entries());\n+    }\n+\n+    @Override\n+    public Bag<K> keys() {\n+        return UnmodifiableBag.<K>unmodifiableBag(decorated().keys());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        return UnmodifiableCollection.<V>unmodifiableCollection(decorated().values());\n+    }\n+\n+    @Override\n+    public boolean putAll(K key, Iterable<? extends V> values) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the {@link org.apache.commons.collections4.MultiValuedMap} interfaces.\n+ * A MultiValuedMap holds a collection of values against each key.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>MultiValuedHashMap - implementation that uses a HashMap to store the data\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided in the package:\n+ * <ul>\n+ *   <li>Transformed - transforms elements added to the MultiValuedMap\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections4.multimap;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.AbstractObjectTest;\n+import org.apache.commons.collections4.Bag;\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.bag.HashBag;\n+\n+/**\n+ * Abstract test class for {@link MultiValuedMap} contract and methods.\n+ * <p>\n+ * To use, extend this class and implement the {@link #makeObject} method and if\n+ * necessary override the {@link #makeFullMap()} method.\n+ * \n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public abstract class AbstractMultiValuedMapTest<K, V> extends AbstractObjectTest {\n+\n+    public AbstractMultiValuedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    abstract public MultiValuedMap<K, V> makeObject();\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"4.1\"; // MultiValuedMap has been added in version 4.1\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by {@link #makeObject()} and\n+     * {@link #makeFullMap()} support the <code>put</code> and\n+     * <code>putAll</code> operations adding new mappings.\n+     * <p>\n+     * Default implementation returns true. Override if your collection class\n+     * does not support put adding.\n+     */\n+    public boolean isAddSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the maps produced by {@link #makeObject()} and\n+     * {@link #makeFullMap()} support the <code>remove</code> and\n+     * <code>clear</code> operations.\n+     * <p>\n+     * Default implementation returns true. Override if your collection class\n+     * does not support removal operations.\n+     */\n+    public boolean isRemoveSupported() {\n+        return true;\n+    }\n+\n+    protected MultiValuedMap<K, V> makeFullMap() {\n+        final MultiValuedMap<K, V> map = makeObject();\n+        addSampleMappings(map);\n+        return map;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected void addSampleMappings(MultiValuedMap<? super K, ? super V> map) {\n+        map.put((K) \"one\", (V) \"uno\");\n+        map.put((K) \"one\", (V) \"un\");\n+        map.put((K) \"two\", (V) \"dos\");\n+        map.put((K) \"two\", (V) \"deux\");\n+        map.put((K) \"three\", (V) \"tres\");\n+        map.put((K) \"three\", (V) \"trois\");\n+    }\n+\n+    public void testNoMappingReturnsNull() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertNull(map.get(\"whatever\"));\n+    }\n+\n+    public void testMultipleValues() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        Collection<V> col = map.get(\"one\");\n+        assertTrue(col.contains(\"uno\"));\n+        assertTrue(col.contains(\"un\"));\n+    }\n+\n+    public void testGet() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertTrue(map.get(\"one\").contains(\"uno\"));\n+        assertTrue(map.get(\"one\").contains(\"un\"));\n+        assertTrue(map.get(\"two\").contains(\"dos\"));\n+        assertTrue(map.get(\"two\").contains(\"deux\"));\n+        assertTrue(map.get(\"three\").contains(\"tres\"));\n+        assertTrue(map.get(\"three\").contains(\"trois\"));\n+    }\n+\n+    public void testContainsValue() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertTrue(map.containsValue(\"uno\"));\n+        assertTrue(map.containsValue(\"un\"));\n+        assertTrue(map.containsValue(\"dos\"));\n+        assertTrue(map.containsValue(\"deux\"));\n+        assertTrue(map.containsValue(\"tres\"));\n+        assertTrue(map.containsValue(\"trois\"));\n+        assertFalse(map.containsValue(\"quatro\"));\n+    }\n+\n+    public void testKeyContainsValue() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertTrue(map.containsMapping(\"one\", \"uno\"));\n+        assertTrue(map.containsMapping(\"one\", \"un\"));\n+        assertTrue(map.containsMapping(\"two\", \"dos\"));\n+        assertTrue(map.containsMapping(\"two\", \"deux\"));\n+        assertTrue(map.containsMapping(\"three\", \"tres\"));\n+        assertTrue(map.containsMapping(\"three\", \"trois\"));\n+        assertFalse(map.containsMapping(\"four\", \"quatro\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValues() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        final HashSet<V> expected = new HashSet<V>();\n+        expected.add((V) \"uno\");\n+        expected.add((V) \"dos\");\n+        expected.add((V) \"tres\");\n+        expected.add((V) \"un\");\n+        expected.add((V) \"deux\");\n+        expected.add((V) \"trois\");\n+        final Collection<V> c = map.values();\n+        assertEquals(6, c.size());\n+        assertEquals(expected, new HashSet<V>(c));\n+    }\n+\n+//    public void testKeyedIterator() {\n+//        final MultiValuedMap<K, V> map = makeFullMap();\n+//        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator(\"one\")));\n+//        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList(\"uno\", \"un\"));\n+//        assertEquals(expected, actual);\n+//    }\n+\n+    public void testRemoveAllViaIterator() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertTrue(map.isEmpty());\n+    }\n+\n+//    public void testRemoveAllViaKeyedIterator() {\n+//        if (!isRemoveSupported()) {\n+//            return;\n+//        }\n+//        final MultiValuedMap<K, V> map = makeFullMap();\n+//        for (final Iterator<?> i = map.iterator(\"one\"); i.hasNext();) {\n+//            i.next();\n+//            i.remove();\n+//        }\n+//        assertNull(map.get(\"one\"));\n+//        assertEquals(4, map.size());\n+//    }\n+\n+    public void testEntriesCollectionIterator() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        Collection<V> values = new ArrayList<V>(map.values());\n+        Iterator<Map.Entry<K, V>> iterator = map.entries().iterator();\n+        while (iterator.hasNext()) {\n+            Map.Entry<K, V> entry = iterator.next();\n+            assertTrue(map.containsMapping(entry.getKey(), entry.getValue()));\n+            assertTrue(values.contains(entry.getValue()));\n+            if (isRemoveSupported()) {\n+                assertTrue(values.remove(entry.getValue()));\n+            }\n+        }\n+        if (isRemoveSupported()) {\n+            assertTrue(values.isEmpty());\n+        }\n+    }\n+\n+    public void testRemoveAllViaEntriesIterator() {\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        for (final Iterator<?> i = map.entries().iterator(); i.hasNext();) {\n+            i.next();\n+            i.remove();\n+        }\n+        assertNull(map.get(\"one\"));\n+        assertEquals(0, map.size());\n+    }\n+\n+    public void testSize() {\n+        assertEquals(6, makeFullMap().size());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMapEquals() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> one = makeObject();\n+        final Integer value = Integer.valueOf(1);\n+        one.put((K) \"One\", (V) value);\n+        one.removeMapping((K) \"One\", (V) value);\n+\n+        final MultiValuedMap<K, V> two = makeObject();\n+        assertEquals(two, one);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSizeWithPutRemove() {\n+        if (!isRemoveSupported() || !isAddSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeObject();\n+        assertEquals(0, map.size());\n+        map.put((K) \"A\", (V) \"AA\");\n+        assertEquals(1, map.size());\n+        map.put((K) \"B\", (V) \"BA\");\n+        assertEquals(2, map.size());\n+        map.put((K) \"B\", (V) \"BB\");\n+        assertEquals(3, map.size());\n+        map.put((K) \"B\", (V) \"BC\");\n+        assertEquals(4, map.size());\n+        map.remove(\"A\");\n+        assertEquals(3, map.size());\n+        map.removeMapping((K) \"B\", (V) \"BC\");\n+        assertEquals(2, map.size());\n+    }\n+\n+    public void testKeySetSize() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertEquals(3, map.keySet().size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSize_Key() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertEquals(2, map.get(\"one\").size());\n+        assertEquals(2, map.get(\"two\").size());\n+        assertEquals(2, map.get(\"three\").size());\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        map.put((K) \"A\", (V) \"AA\");\n+        assertEquals(1, map.get(\"A\").size());\n+        //assertEquals(0, map.get(\"B\").size());\n+        map.put((K) \"B\", (V) \"BA\");\n+        assertEquals(1, map.get(\"A\").size());\n+        assertEquals(1, map.get(\"B\").size());\n+        map.put((K) \"B\", (V) \"BB\");\n+        assertEquals(1, map.get(\"A\").size());\n+        assertEquals(2, map.get(\"B\").size());\n+        map.put((K) \"B\", (V) \"BC\");\n+        assertEquals(1, map.get(\"A\").size());\n+        assertEquals(3, map.get(\"B\").size());\n+        if (!isRemoveSupported()) {\n+            return;\n+        }\n+        map.remove(\"A\");\n+        //assertEquals(0, map.get(\"A\").size());\n+        assertEquals(3, map.get(\"B\").size());\n+        map.removeMapping((K) \"B\", (V) \"BC\");\n+        //assertEquals(0, map.get(\"A\").size());\n+        assertEquals(2, map.get(\"B\").size());\n+    }\n+\n+//    @SuppressWarnings(\"unchecked\")\n+//    public void testIterator_Key() {\n+//        final MultiValuedMap<K, V> map = makeFullMap();\n+//        Iterator<V> it = map.iterator(\"one\");\n+//        assertEquals(true, it.hasNext());\n+//        Set<V> values = new HashSet<V>();\n+//        while (it.hasNext()) {\n+//            values.add(it.next());\n+//        }\n+//        assertEquals(true, values.contains(\"un\"));\n+//        assertEquals(true, values.contains(\"uno\"));\n+//        assertEquals(false, map.iterator(\"A\").hasNext());\n+//        assertEquals(false, map.iterator(\"A\").hasNext());\n+//        if (!isAddSupported()) {\n+//            return;\n+//        }\n+//        map.put((K) \"A\", (V) \"AA\");\n+//        it = map.iterator(\"A\");\n+//        assertEquals(true, it.hasNext());\n+//        it.next();\n+//        assertEquals(false, it.hasNext());\n+//    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testContainsValue_Key() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertEquals(true, map.containsMapping(\"one\", (V) \"uno\"));\n+        assertEquals(false, map.containsMapping(\"two\", (V) \"2\"));\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        map.put((K) \"A\", (V) \"AA\");\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"AA\"));\n+        assertEquals(false, map.containsMapping(\"A\", (V) \"AB\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map1() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> original = makeObject();\n+        original.put((K) \"key\", (V) \"object1\");\n+        original.put((K) \"key\", (V) \"object2\");\n+\n+        final MultiValuedMap<K, V> test = makeObject();\n+        test.put((K) \"keyA\", (V) \"objectA\");\n+        test.put((K) \"key\", (V) \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(2, test.keySet().size());\n+        assertEquals(4, test.size());\n+        assertEquals(1, test.get(\"keyA\").size());\n+        assertEquals(3, test.get(\"key\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_Map2() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        final Map<K, V> original = new HashMap<K, V>();\n+        original.put((K) \"keyX\", (V) \"object1\");\n+        original.put((K) \"keyY\", (V) \"object2\");\n+\n+        final MultiValuedMap<K, V> test = makeObject();\n+        test.put((K) \"keyA\", (V) \"objectA\");\n+        test.put((K) \"keyX\", (V) \"object0\");\n+        test.putAll(original);\n+\n+        assertEquals(3, test.keySet().size());\n+        assertEquals(4, test.size());\n+        assertEquals(1, test.get(\"keyA\").size());\n+        assertEquals(2, test.get(\"keyX\").size());\n+        assertEquals(1, test.get(\"keyY\").size());\n+        assertEquals(true, test.containsValue(\"objectA\"));\n+        assertEquals(true, test.containsValue(\"object0\"));\n+        assertEquals(true, test.containsValue(\"object1\"));\n+        assertEquals(true, test.containsValue(\"object2\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutAll_KeyIterable() {\n+        if (!isAddSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeObject();\n+        Collection<V> coll = (Collection<V>) Arrays.asList(\"X\", \"Y\", \"Z\");\n+\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(3, map.get(\"A\").size());\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", null));\n+        assertEquals(3, map.get(\"A\").size());\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n+\n+        assertEquals(false, map.putAll((K) \"A\", new ArrayList<V>()));\n+        assertEquals(3, map.get(\"A\").size());\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n+\n+        coll = (Collection<V>) Arrays.asList(\"M\");\n+        assertEquals(true, map.putAll((K) \"A\", coll));\n+        assertEquals(4, map.get(\"A\").size());\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n+        assertEquals(true, map.containsMapping(\"A\", (V) \"M\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testRemove_KeyItem() {\n+        if (!isRemoveSupported() || !isAddSupported()) {\n+            return;\n+        }\n+        final MultiValuedMap<K, V> map = makeObject();\n+        map.put((K) \"A\", (V) \"AA\");\n+        map.put((K) \"A\", (V) \"AB\");\n+        map.put((K) \"A\", (V) \"AC\");\n+        assertEquals(false, map.removeMapping((K) \"C\", (V) \"CA\"));\n+        assertEquals(false, map.removeMapping((K) \"A\", (V) \"AD\"));\n+        assertEquals(true, map.removeMapping((K) \"A\", (V) \"AC\"));\n+        assertEquals(true, map.removeMapping((K) \"A\", (V) \"AB\"));\n+        assertEquals(true, map.removeMapping((K) \"A\", (V) \"AA\"));\n+        //assertEquals(new MultiValuedHashMap<K, V>(), map);\n+    }\n+\n+    public void testKeysBag() {\n+        MultiValuedMap<K, V> map = makeFullMap();\n+        Bag<K> keyBag = map.keys();\n+        assertEquals(2, keyBag.getCount(\"one\"));\n+        assertEquals(2, keyBag.getCount(\"two\"));\n+        assertEquals(2, keyBag.getCount(\"three\"));\n+        assertEquals(6, keyBag.size());\n+    }\n+\n+    public void testKeysBagIterator() {\n+        MultiValuedMap<K, V> map = makeFullMap();\n+        Collection<K> col = new ArrayList<K>();\n+        Iterator<K> it = map.keys().iterator();\n+        while (it.hasNext()) {\n+            col.add(it.next());\n+        }\n+        Bag<K> bag = new HashBag<K>(col);\n+        assertEquals(2, bag.getCount(\"one\"));\n+        assertEquals(2, bag.getCount(\"two\"));\n+        assertEquals(2, bag.getCount(\"three\"));\n+        assertEquals(6, bag.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testKeysBagContainsAll() {\n+        MultiValuedMap<K, V> map = makeFullMap();\n+        Bag<K> keyBag = map.keys();\n+        Collection<K> col = (Collection<K>) Arrays.asList(\"one\", \"two\", \"three\", \"one\", \"two\", \"three\");\n+        assertTrue(keyBag.containsAll(col));\n+    }\n+\n+//    public void testMapEqulas() {\n+//        MultiValuedMap<K, V> map1 = makeFullMap();\n+//        MultiValuedMap<K, V> map2 = makeFullMap();\n+//        assertEquals(true, map1.equals(map2));\n+//    }\n+\n+    // -----------------------------------------------------------------------\n+    // Manual serialization testing as this class cannot easily\n+    // extend the AbstractTestMap\n+    // -----------------------------------------------------------------------\n+\n+    public void testEmptyMapCompatibility() throws Exception {\n+        final MultiValuedMap<?, ?> map = makeObject();\n+        final MultiValuedMap<?, ?> map2 = (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+        assertEquals(\"Map is empty\", 0, map2.size());\n+    }\n+\n+    public void testFullMapCompatibility() throws Exception {\n+        final MultiValuedMap<?, ?> map = (MultiValuedMap<?, ?>) makeFullMap();\n+        final MultiValuedMap<?, ?> map2 = (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        assertEquals(\"Map is the right size\", map.size(), map2.size());\n+        for (final Object key : map.keySet()) {\n+            assertEquals(\"Map had inequal elements\", map.get(key), map2.get(key));\n+            if (isRemoveSupported()) {\n+                map2.remove(key);\n+            }\n+        }\n+        if (isRemoveSupported()) {\n+            assertEquals(\"Map had extra values\", 0, map2.size());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+\n+/**\n+ * Test MultValuedHashMap\n+ * \n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class MultiValuedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n+\n+    public MultiValuedHashMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public MultiValuedMap<K, V> makeObject() {\n+        final MultiValuedMap<K, V> m = new MultiValuedHashMap<K, V>();\n+        return m;\n+    }\n+\n+    private <C extends Collection<V>> MultiValuedHashMap<K, V> createTestMap(final Class<C> collectionClass) {\n+        final MultiValuedHashMap<K, V> map =\n+                (MultiValuedHashMap<K, V>) MultiValuedHashMap.<K, V, C> multiValuedMap(collectionClass);\n+        addSampleMappings(map);\n+        return map;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueCollectionType() {\n+        final MultiValuedHashMap<K, V> map = createTestMap(LinkedList.class);\n+        assertTrue(map.get(\"one\") instanceof LinkedList);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithList() {\n+        final MultiValuedHashMap<K, V> test = (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(ArrayList.class);\n+        assertEquals(\"a\", test.put((K) \"A\", (V) \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", (V) \"b\"));\n+        assertEquals(1, test.keySet().size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.size());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPutWithSet() {\n+        final MultiValuedHashMap<K, V> test = (MultiValuedHashMap<K, V>) MultiValuedHashMap.multiValuedMap(HashSet.class);\n+        assertEquals(\"a\", test.put((K) \"A\", (V) \"a\"));\n+        assertEquals(\"b\", test.put((K) \"A\", (V) \"b\"));\n+        assertEquals(null, test.put((K) \"A\", (V) \"a\"));\n+        assertEquals(1, test.keySet().size());\n+        assertEquals(2, test.size(\"A\"));\n+        assertEquals(2, test.size());\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+//                \"src/test/resources/data/test/MultiValuedHashMap.emptyCollection.version4.1.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+//                \"src/test/resources/data/test/MultiValuedHashMap.fullCollection.version4.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.TransformerUtils;\n+import org.apache.commons.collections4.collection.TransformedCollectionTest;\n+import org.apache.commons.collections4.multimap.TransformedMultiValuedMap;\n+\n+/**\n+ * Tests for TransformedMultiValuedMap\n+ * \n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class TransformedMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n+\n+    public TransformedMultiValuedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public MultiValuedMap<K, V> makeObject() {\n+        return TransformedMultiValuedMap.transformingMap(new MultiValuedHashMap<K, V>(),\n+                TransformerUtils.<K> nopTransformer(), TransformerUtils.<V> nopTransformer());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testKeyTransformedMap() {\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(\n+                new MultiValuedHashMap<K, V>(),\n+                (Transformer<? super K, ? extends K>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER,\n+                null);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));\n+            assertEquals(false, map.containsKey(els[i]));\n+            assertEquals(true, map.containsValue(els[i]));\n+            assertEquals(true, map.get(Integer.valueOf((String) els[i])).contains(els[i]));\n+        }\n+\n+        assertEquals(null, map.remove(els[0]));\n+        assertEquals(true, map.remove(Integer.valueOf((String) els[0])).contains(els[0]));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testValueTransformedMap() {\n+        final Object[] els = new Object[] { \"1\", \"3\", \"5\", \"7\", \"2\", \"4\", \"6\" };\n+\n+        MultiValuedMap<K, V> map = TransformedMultiValuedMap.transformingMap(\n+                new MultiValuedHashMap<K, V>(), null,\n+                (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < els.length; i++) {\n+            map.put((K) els[i], (V) els[i]);\n+            assertEquals(i + 1, map.size());\n+            assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));\n+            assertEquals(false, map.containsValue(els[i]));\n+            assertEquals(true, map.containsKey(els[i]));\n+            assertEquals(true, map.get(els[i]).contains(Integer.valueOf((String) els[i])));\n+        }\n+        assertEquals(true, map.remove(els[0]).contains(Integer.valueOf((String) els[0])));\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_Decorate() {\n+        final MultiValuedMap<K, V> base = new MultiValuedHashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        final MultiValuedMap<K, V> trans = TransformedMultiValuedMap\n+                .transformingMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(true, trans.get(\"A\").contains(\"1\"));\n+        assertEquals(true, trans.get(\"B\").contains(\"2\"));\n+        assertEquals(true, trans.get(\"C\").contains(\"3\"));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(true, trans.get(\"D\").contains(Integer.valueOf(4)));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testFactory_decorateTransform() {\n+        final MultiValuedMap<K, V> base = new MultiValuedHashMap<K, V>();\n+        base.put((K) \"A\", (V) \"1\");\n+        base.put((K) \"B\", (V) \"2\");\n+        base.put((K) \"C\", (V) \"3\");\n+\n+        final MultiValuedMap<K, V> trans = TransformedMultiValuedMap\n+                .transformedMap(\n+                        base,\n+                        null,\n+                        (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n+        assertEquals(3, trans.size());\n+        assertEquals(true, trans.get(\"A\").contains(Integer.valueOf(1)));\n+        assertEquals(true, trans.get(\"B\").contains(Integer.valueOf(2)));\n+        assertEquals(true, trans.get(\"C\").contains(Integer.valueOf(3)));\n+        trans.put((K) \"D\", (V) \"4\");\n+        assertEquals(true, trans.get(\"D\").contains(Integer.valueOf(4)));\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+//                \"src/test/resources/data/test/TransformedMultiValuedMap.emptyCollection.version4.1.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+//                \"src/test/resources/data/test/TransformedMultiValuedMap.fullCollection.version4.1.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.Unmodifiable;\n+\n+/**\n+ * Tests for UnmodifiableMultiValuedMap\n+ * \n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class UnmodifiableMultiValuedMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n+\n+    public UnmodifiableMultiValuedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public MultiValuedMap<K, V> makeObject() {\n+        return UnmodifiableMultiValuedMap.<K, V> unmodifiableMultiValuedMap(new MultiValuedHashMap<K, V>());\n+    }\n+\n+    protected MultiValuedMap<K, V> makeFullMap() {\n+        final MultiValuedMap<K, V> map = new MultiValuedHashMap<K, V>();\n+        addSampleMappings(map);\n+        return UnmodifiableMultiValuedMap.<K, V> unmodifiableMultiValuedMap(map);\n+    }\n+\n+    public void testUnmodifiable() {\n+        assertTrue(makeObject() instanceof Unmodifiable);\n+        assertTrue(makeFullMap() instanceof Unmodifiable);\n+    }\n+\n+    public void testDecorateFactory() {\n+        final MultiValuedMap<K, V> map = makeFullMap();\n+        assertSame(map, UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(map));\n+    }\n+\n+    public void testDecoratorFactoryNullMap() {\n+        try {\n+            UnmodifiableMultiValuedMap.unmodifiableMultiValuedMap(null);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testAddException() {\n+        MultiValuedMap<K, V> map = makeObject();\n+        try {\n+            map.put((K) \"one\", (V) \"uno\");\n+            fail();\n+        } catch (UnsupportedOperationException e) {\n+        }\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        writeExternalFormToDisk((java.io.Serializable) makeObject(),\n+//                \"src/test/resources/data/test/UnmodifiableMultiValuedMap.emptyCollection.version4.1.obj\");\n+//        writeExternalFormToDisk((java.io.Serializable) makeFullMap(),\n+//                \"src/test/resources/data/test/UnmodifiableMultiValuedMap.fullCollection.version4.1.obj\");\n+//    }\n+\n+}", "timestamp": 1395784867, "metainfo": ""}