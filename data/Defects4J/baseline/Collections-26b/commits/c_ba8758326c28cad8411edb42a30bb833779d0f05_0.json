{"sha": "ba8758326c28cad8411edb42a30bb833779d0f05", "log": "[COLLECTIONS-471] Added BoundedIterator.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IteratorUtils.java\n \n import org.apache.commons.collections4.iterators.ArrayIterator;\n import org.apache.commons.collections4.iterators.ArrayListIterator;\n+import org.apache.commons.collections4.iterators.BoundedIterator;\n import org.apache.commons.collections4.iterators.CollatingIterator;\n import org.apache.commons.collections4.iterators.EmptyIterator;\n import org.apache.commons.collections4.iterators.EmptyListIterator;\n      */\n     public static <E> ResettableListIterator<E> arrayListIterator(final Object array, final int start, final int end) {\n         return new ArrayListIterator<E>(array, start, end);\n+    }\n+\n+    // Bounded\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified iterator to return at most the given number\n+     * of elements.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @param max  the maximum number of elements returned by this iterator\n+     * @return a new bounded iterator\n+     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n+     * @since 4.0.1\n+     */\n+    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator, long max) {\n+        return BoundedIterator.boundedIterator(iterator, max);\n+    }\n+\n+    /**\n+     * Decorates the specified iterator to return at most the given number\n+     * of elements, skipping all elements until the iterator reaches the\n+     * position at {@code offset}.\n+     * <p>\n+     * The iterator is immediately advanced until it reaches the position at\n+     * {@code offset}, incurring O(n) time.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @param offset  the index of the first element of the decorated iterator to return\n+     * @param max  the maximum number of elements returned by this iterator\n+     * @return a new bounded iterator\n+     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n+     * @since 4.0.1\n+     */\n+    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n+                                                         long offset, long max) {\n+        return BoundedIterator.boundedIterator(iterator, offset, max);\n     }\n \n     // Unmodifiable\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/iterators/BoundedIterator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Decorates another iterator to return elements in a specific range.\n+ * <p>\n+ * The decorated iterator is bounded in the range [offset, offset+max).\n+ * The {@code offset} corresponds to the position of the first element to\n+ * be returned from the decorated iterator, and {@code max} is the maximum\n+ * number of elements to be returned at most.\n+ * <p>\n+ * In case an offset parameter other than 0 is provided, the decorated\n+ * iterator is immediately advanced to this position, skipping all elements\n+ * before that position.\n+ *\n+ * @since 4.0.1\n+ * @version $Id$\n+ */\n+public class BoundedIterator<E> implements Iterator<E> {\n+\n+    /** The iterator being decorated. */\n+    private final Iterator<? extends E> iterator;\n+\n+    /** The offset to bound the first element return */\n+    private final long offset;\n+\n+    /** The max number of elements to return */\n+    private final long max;\n+\n+    /** The position of the current element */\n+    private long pos;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Decorates the specified iterator to return at most the given number\n+     * of elements.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @param max  the maximum number of elements returned by this iterator\n+     * @return a new bounded iterator\n+     * @throws IllegalArgumentException if the iterator is null or max is negative\n+     */\n+    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n+                                                         final long max) {\n+        return boundedIterator(iterator, 0, max);\n+    }\n+\n+    /**\n+     * Decorates the specified iterator to return at most the given number\n+     * of elements, skipping all elements until the iterator reaches the position\n+     * at {@code offset}.\n+     * <p>\n+     * The iterator is immediately advanced until it reaches the position at {@code offset},\n+     * incurring O(n) time.\n+     *\n+     * @param <E>  the element type\n+     * @param iterator  the iterator to decorate\n+     * @param offset  the index of the first element of the decorated iterator to return\n+     * @param max  the maximum number of elements returned by this iterator\n+     * @return a new bounded iterator\n+     * @throws IllegalArgumentException if the iterator is null or either offset or max is negative\n+     */\n+    public static <E> BoundedIterator<E> boundedIterator(final Iterator<? extends E> iterator,\n+                                                         final long offset, final long max) {\n+        return new BoundedIterator<E>(iterator, 0, max);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Decorates the specified iterator to return at most the given number of elements,\n+     * skipping all elements until the iterator reaches the position at {@code offset}.\n+     * <p>\n+     * The iterator is immediately advanced until it reaches the position at {@code offset},\n+     * incurring O(n) time.\n+     *\n+     * @param iterator  the iterator to be decorated\n+     * @param offset  the index of the first element of the decorated iterator to return\n+     * @param max  the maximum number of elements of the decorated iterator to return\n+     * @throws IllegalArgumentException if iterator is null, or either offset or max is negative\n+     */\n+    public BoundedIterator(final Iterator<? extends E> iterator, final long offset, final long max) {\n+        if (iterator == null) {\n+            throw new IllegalArgumentException(\"Iterator must not be null\");\n+        }\n+        if (offset < 0) {\n+            throw new IllegalArgumentException(\"Offset parameter must not be negative.\");\n+        }\n+        if (max < 0) {\n+            throw new IllegalArgumentException(\"Max parameter must not be negative.\");\n+        }\n+\n+        this.iterator = iterator;\n+        this.offset = offset;\n+        this.max = max;\n+        pos = 0;\n+        init();\n+    }\n+\n+    /**\n+     * Advances the underlying iterator to the beginning of the bounded range.\n+     */\n+    private void init() {\n+        while (pos < offset && iterator.hasNext()) {\n+            iterator.next();\n+            pos++;\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    public boolean hasNext() {\n+        if (!checkBounds()) {\n+            return false;\n+        }\n+        return iterator.hasNext();\n+    }\n+\n+    /**\n+     * Checks whether the iterator is still within its bounded range.\n+     * @return {@code true} if the iterator is within its bounds, {@code false} otherwise\n+     */\n+    private boolean checkBounds() {\n+        if (pos - offset + 1 > max) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public E next() {\n+        if (!checkBounds()) {\n+            throw new NoSuchElementException();\n+        }\n+        final E next = iterator.next();\n+        pos++;\n+        return next;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * In case an offset other than 0 was specified, the underlying iterator will be advanced\n+     * to this position upon creation. A call to {@link #remove()} will still result in an\n+     * {@link IllegalStateException} if no explicit call to {@link #next()} has been made prior\n+     * to calling {@link #remove()}.\n+     */\n+    public void remove() {\n+        if (pos <= offset) {\n+            throw new IllegalStateException(\"remove() can not be called before calling next()\");\n+        }\n+        iterator.remove();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/iterators/BoundedIteratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n+ */\n+package org.apache.commons.collections4.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.junit.Test;\n+\n+/**\n+ * A unit test to test the basic functions of {@link BoundedIterator}.\n+ *\n+ * @version $Id$\n+ */\n+public class BoundedIteratorTest<E> extends AbstractIteratorTest<E> {\n+\n+    /** Test array of size 7 */\n+    private String[] testArray = {\n+        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"\n+    };\n+\n+    private List<E> testList;\n+\n+    public BoundedIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void setUp()\n+        throws Exception {\n+        super.setUp();\n+        testList = Arrays.asList((E[]) testArray);\n+    }\n+\n+    @Override\n+    public Iterator<E> makeEmptyIterator() {\n+        return BoundedIterator.boundedIterator(Collections.<E>emptyList().iterator(), 10);\n+    }\n+\n+    @Override\n+    public Iterator<E> makeObject() {\n+        return BoundedIterator.boundedIterator(new ArrayList<E>(testList).iterator(), 1, testList.size() - 1);\n+    }\n+\n+    // ---------------- Tests ---------------------\n+\n+    /**\n+     * Test a decorated iterator bounded such that the first element returned is\n+     * at an index greater its first element, and the last element returned is\n+     * at an index less than its last element.\n+     */\n+    @Test\n+    public void testBounded() {\n+        Iterator<E> iter = new BoundedIterator<E>(testList.iterator(), 2, 4);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test a decorated iterator bounded such that the <code>offset</code> is\n+     * zero and the <code>max</code> is its size, in that the BoundedIterator\n+     * should return all the same elements as its decorated iterator.\n+     */\n+    @Test\n+    public void testSameAsDecorated() {\n+        Iterator<E> iter = new BoundedIterator<E>(testList.iterator(), 0,\n+                                                  testList.size());\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"a\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test a decorated iterator bounded to a <code>max</code> of 0. The\n+     * BoundedIterator should behave as if there are no more elements to return,\n+     * since it is technically an empty iterator.\n+     */\n+    @Test\n+    public void testEmptyBounded() {\n+        Iterator<E> iter = new BoundedIterator<E>(testList.iterator(), 3, 0);\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if a negative <code>offset</code> is passed to the\n+     * constructor. {@link IllegalArgumentException} is expected.\n+     */\n+    @Test\n+    public void testNegativeOffset() {\n+        try {\n+            new BoundedIterator<E>(testList.iterator(), -1, 4);\n+            fail(\"Expected IllegalArgumentException.\");\n+        } catch (IllegalArgumentException iae) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if a negative <code>max</code> is passed to the\n+     * constructor. {@link IllegalArgumentException} is expected.\n+     */\n+    @Test\n+    public void testNegativeMax() {\n+        try {\n+            new BoundedIterator<E>(testList.iterator(), 3, -1);\n+            fail(\"Expected IllegalArgumentException.\");\n+        } catch (IllegalArgumentException iae) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if the <code>offset</code> passed to the constructor is\n+     * greater than the decorated iterator's size. The BoundedIterator should\n+     * behave as if there are no more elements to return.\n+     */\n+    @Test\n+    public void testOffsetGreaterThanSize() {\n+        Iterator<E> iter = new BoundedIterator<E>(testList.iterator(), 10, 4);\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if the <code>max</code> passed to the constructor is\n+     * greater than the size of the decorated iterator. The last element\n+     * returned should be the same as the last element of the decorated\n+     * iterator.\n+     */\n+    @Test\n+    public void testMaxGreaterThanSize() {\n+        Iterator<E> iter = new BoundedIterator<E>(testList.iterator(), 1, 10);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"g\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the <code>remove()</code> method being called without\n+     * <code>next()</code> being called first.\n+     */\n+    @Test\n+    public void testRemoveWithoutCallingNext() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new BoundedIterator<E>(testListCopy.iterator(), 1, 5);\n+\n+        try {\n+            iter.remove();\n+            fail(\"Expected IllegalStateException.\");\n+        } catch (IllegalStateException ise) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the <code>remove()</code> method being called twice without calling\n+     * <code>next()</code> in between.\n+     */\n+    @Test\n+    public void testRemoveCalledTwice() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new BoundedIterator<E>(testListCopy.iterator(), 1, 5);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        iter.remove();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Expected IllegalStateException.\");\n+        } catch (IllegalStateException ise) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test removing the first element. Verify that the element is removed from\n+     * the underlying collection.\n+     */\n+    @Test\n+    public void testRemoveFirst() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new BoundedIterator<E>(testListCopy.iterator(), 1, 5);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+\n+        iter.remove();\n+        assertFalse(testListCopy.contains(\"b\"));\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test removing an element in the middle of the iterator. Verify that the\n+     * element is removed from the underlying collection.\n+     */\n+    @Test\n+    public void testRemoveMiddle() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new BoundedIterator<E>(testListCopy.iterator(), 1, 5);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+\n+        iter.remove();\n+        assertFalse(testListCopy.contains(\"d\"));\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test removing the last element. Verify that the element is removed from\n+     * the underlying collection.\n+     */\n+    @Test\n+    public void testRemoveLast() {\n+        List<E> testListCopy = new ArrayList<E>(testList);\n+        Iterator<E> iter = new BoundedIterator<E>(testListCopy.iterator(), 1, 5);\n+\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"c\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"d\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"e\", iter.next());\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"f\", iter.next());\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+\n+        iter.remove();\n+        assertFalse(testListCopy.contains(\"f\"));\n+\n+        assertFalse(iter.hasNext());\n+        try {\n+            iter.next();\n+            fail(\"Expected NoSuchElementException.\");\n+        } catch (NoSuchElementException nsee) { /* Success case */\n+        }\n+    }\n+\n+    /**\n+     * Test the case if the decorated iterator does not support the\n+     * <code>remove()</code> method and throws an {@link UnsupportedOperationException}.\n+     */\n+    @Test\n+    public void testRemoveUnsupported() {\n+        Iterator<E> mockIterator = new AbstractIteratorDecorator<E>(testList.iterator()) {\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+\n+        Iterator<E> iter = new BoundedIterator<E>(mockIterator, 1, 5);\n+        assertTrue(iter.hasNext());\n+        assertEquals(\"b\", iter.next());\n+        try {\n+            iter.remove();\n+            fail(\"Expected UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException usoe) { /* Success case */\n+        }\n+    }\n+}", "timestamp": 1385592845, "metainfo": ""}