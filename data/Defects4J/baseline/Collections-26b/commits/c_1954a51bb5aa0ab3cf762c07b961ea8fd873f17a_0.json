{"sha": "1954a51bb5aa0ab3cf762c07b961ea8fd873f17a", "log": "Continue review of multimap package.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n      * @param key  the key to retrieve\n      * @return the {@code List} of values, implementations should return an\n      *   empty {@code List} for no mapping\n-     * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n     @Override\n-    List<V> get(Object key);\n+    List<V> get(K key);\n \n     /**\n      * Removes all values associated with the specified key.\n      * @return the {@code List} of values removed, implementations\n      *   typically return an empty, unmodifiable {@code List} for no mapping found\n      * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/MultiMapUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiMapUtils.java\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n     /**\n      * Returns immutable EMPTY_MULTI_VALUED_MAP with generic type safety.\n      *\n-     * @param <K>  the type of key in the map\n-     * @param <V>  the type of value in the map\n+     * @param <K> the type of key in the map\n+     * @param <V> the type of value in the map\n      * @return immutable and empty <code>MultiValuedMap</code>\n      */\n     @SuppressWarnings(\"unchecked\")\n      * Returns an immutable empty <code>MultiValuedMap</code> if the argument is\n      * <code>null</code>, or the argument itself otherwise.\n      *\n-     * @param <K>  the type of key in the map\n-     * @param <V>  the type of value in the map\n+     * @param <K> the type of key in the map\n+     * @param <V> the type of value in the map\n      * @param map  the map, may be null\n      * @return an empty {@link MultiValuedMap} if the argument is null\n      */\n     /**\n      * Gets a Collection from <code>MultiValuedMap</code> in a null-safe manner.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the {@link MultiValuedMap} to use\n      * @param key  the key to look up\n      * @return the Collection in the {@link MultiValuedMap}, or null if input map is null\n         if (map != null) {\n             return map.get(key);\n         }\n-        return null;\n+        return Collections.emptyList();\n     }\n \n     // TODO: review the getValuesAsXXX methods - depending on the actual MultiValuedMap type, changes\n     /**\n      * Gets a List from <code>MultiValuedMap</code> in a null-safe manner.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the {@link MultiValuedMap} to use\n      * @param key  the key to look up\n      * @return the Collection in the {@link MultiValuedMap} as List, or null if input map is null\n     /**\n      * Gets a Set from <code>MultiValuedMap</code> in a null-safe manner.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the {@link MultiValuedMap} to use\n      * @param key  the key to look up\n      * @return the Collection in the {@link MultiValuedMap} as Set, or null if input map is null\n     /**\n      * Gets a Bag from <code>MultiValuedMap</code> in a null-safe manner.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the {@link MultiValuedMap} to use\n      * @param key  the key to look up\n      * @return the Collection in the {@link MultiValuedMap} as Bag, or null if input map is null\n      * Creates a {@link ListValuedMap} with an {@link java.util.ArrayList ArrayList} as\n      * collection class to store the values mapped to a key.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @return a new <code>ListValuedMap</code>\n      */\n     public static <K, V> ListValuedMap<K, V> newListValuedHashMap() {\n      * Creates a {@link ListValuedMap} with a {@link java.util.HashMap HashMap} as its internal\n      * storage which maps the keys to list of type <code>listClass</code>.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n-     * @param <C>  the List class type\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the List class type\n      * @param listClass the class of the list\n      * @return a new {@link ListValuedMap}\n      */\n      * Creates a {@link SetValuedMap} with an {@link java.util.HashSet HashSet} as\n      * collection class to store the values mapped to a key.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @return a new {@link SetValuedMap}\n      */\n     public static <K, V> SetValuedMap<K, V> newSetValuedHashMap() {\n      * Creates a {@link SetValuedMap} with a {@link java.util.HashMap HashMap} as its internal\n      * storage which maps the keys to a set of type <code>setClass</code>\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n-     * @param <C>  the Set class type\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the Set class type\n      * @param setClass  the class of the set\n      * @return a new {@link SetValuedMap}\n      */\n      * Returns an <code>UnmodifiableMultiValuedMap</code> backed by the given\n      * map.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the {@link MultiValuedMap} to decorate, must not be null\n      * @return an unmodifiable {@link MultiValuedMap} backed by the provided map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     public static <K, V> MultiValuedMap<K, V> unmodifiableMultiValuedMap(\n             final MultiValuedMap<? extends K, ? extends V> map) {\n      * If there are any elements already in the map being decorated, they are\n      * NOT transformed.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n-     * @param map the {@link MultiValuedMap} to transform, must not be null, typically empty\n-     * @param keyTransformer the transformer for the map keys, null means no transformation\n-     * @param valueTransformer the transformer for the map values, null means no transformation\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param map  the {@link MultiValuedMap} to transform, must not be null, typically empty\n+     * @param keyTransformer  the transformer for the map keys, null means no transformation\n+     * @param valueTransformer  the transformer for the map values, null means no transformation\n      * @return a transformed <code>MultiValuedMap</code> backed by the given map\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     public static <K, V> MultiValuedMap<K, V> transformedMultiValuedMap(final MultiValuedMap<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n      *\n      * @param key  key whose presence in this map is to be tested\n      * @return true if this map contains a mapping for the specified key\n-     * @throws ClassCastException if the key is of an inappropriate type for this map (optional)\n      * @throws NullPointerException if the specified key is null and this map\n      *   does not permit null keys (optional)\n      */\n      *\n      * @param value  the value to search for\n      * @return true if the map contains the value\n-     * @throws ClassCastException if the type of the specified value is not compatible\n-     *   with the used collection (optional)\n      * @throws NullPointerException if the value is null and null values are not supported\n      *   by the used collection types (optional)\n      */\n      * @param key  the key to retrieve\n      * @return the {@code Collection} of values, implementations should\n      *   return an empty collection for no mapping\n-     * @throws ClassCastException if the key is of an invalid type (optional)\n      * @throws NullPointerException if the key is null and null keys are invalid (optional)\n      */\n-    Collection<V> get(Object key);\n+    Collection<V> get(K key);\n \n     // Modification operations\n \n      *   type does not allow duplicate values, e.g. when using a Set\n      * @throws UnsupportedOperationException if the put operation is not supported by\n      *   this multi-valued map, e.g. if it is unmodifiable\n-     * @throws ClassCastException if the key or value is of an invalid type (optional)\n      * @throws NullPointerException if the key or value is null and null is invalid (optional)\n      * @throws IllegalArgumentException if some aspect of the specified key or value prevents\n      *   it from being stored in this multi-valued map\n      * @param map  mappings to be stored in this map, may not be null\n      * @throws UnsupportedOperationException if the {@code putAll} operation is\n      *   not supported by this map\n-     * @throws ClassCastException if the class of a key or value in the\n-     *   specified map prevents it from being stored in this map (optional)\n      * @throws NullPointerException if the specified map is null, or if this map\n      *   does not permit null keys or values, and the specified map\n      *   contains null keys or values (optional)\n      * @throws IllegalArgumentException if some property of a key or value in\n      *   the specified map prevents it from being stored in this map\n      */\n-    void putAll(Map<? extends K, ? extends V> map);\n+    boolean putAll(Map<? extends K, ? extends V> map);\n \n     /**\n      * Copies all mappings from the specified map to this multi-valued map\n      * @param map  mappings to be stored in this map, may not be null\n      * @throws UnsupportedOperationException if the {@code putAll} operation is\n      *   not supported by this map\n-     * @throws ClassCastException if the class of a key or value in the\n-     *   specified map prevents it from being stored in this map (optional)\n      * @throws NullPointerException if the specified map is null, or if this map\n      *   does not permit null keys or values, and the specified map\n      *   contains null keys or values (optional)\n      * @throws IllegalArgumentException if some property of a key or value in\n      *   the specified map prevents it from being stored in this map\n      */\n-    void putAll(MultiValuedMap<? extends K, ? extends V> map);\n+    boolean putAll(MultiValuedMap<? extends K, ? extends V> map);\n \n     /**\n      * Removes all values associated with the specified key.\n      * @param key  the key to remove values from\n      * @return the values that were removed\n      * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key is of an invalid type (optional)\n      * @throws NullPointerException if the key is null and null keys are invalid (optional)\n      */\n     Collection<V> remove(Object key);\n      * @param item  the item to remove\n      * @return true if the mapping was removed, false otherwise\n      * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key or value is of an invalid type (optional)\n      * @throws NullPointerException if the key or value is null and null is invalid (optional)\n      */\n-    boolean removeMapping(K key, V item);\n+    boolean removeMapping(Object key, Object item);\n \n     /**\n      * Removes all of the mappings from this map (optional operation).\n--- a/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n      * have been mapped to the key.\n      * <p>\n      *\n-     * @param key the key to retrieve\n+     * @param key  the key to retrieve\n      * @return the {@code Set} of values, implementations should return an\n      *   empty {@code Set} for no mapping\n-     * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n     @Override\n-    Set<V> get(Object key);\n+    Set<V> get(K key);\n \n     /**\n      * Removes all values associated with the specified key.\n      * propagated to this set-valued map. In case no mapping was stored for the\n      * specified key, an empty, unmodifiable set will be returned.\n      *\n-     * @param key the key to remove values from\n+     * @param key  the key to remove values from\n      * @return the {@code Set} of values removed, implementations should\n      *   return null for no mapping found, but may return an empty collection\n      * @throws UnsupportedOperationException if the map is unmodifiable\n-     * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java\n \n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n import java.util.Map;\n-import java.util.Map.Entry;\n \n import org.apache.commons.collections4.ListUtils;\n import org.apache.commons.collections4.ListValuedMap;\n         implements ListValuedMap<K, V> {\n \n     /** The serialization version */\n-    private static final long serialVersionUID = 6024950625989666915L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /**\n      * A constructor that wraps, not copies\n      *\n      * @param <C> the list type\n-     * @param map the map to wrap, must not be null\n-     * @param listClazz the collection class\n+     * @param map  the map to wrap, must not be null\n+     * @param listClazz  the collection class\n      * @throws NullPointerException if the map is null\n      */\n     protected <C extends List<V>> AbstractListValuedMap(final Map<K, ? super C> map, Class<C> listClazz) {\n      * A constructor that wraps, not copies\n      *\n      * @param <C> the list type\n-     * @param map the map to wrap, must not be null\n-     * @param listClazz the collection class\n-     * @param initialListCapacity the initial size of the values list\n-     * @throws NullPointerException if the map is null\n-     * @throws IllegalArgumentException if initialListCapacity is negative\n+     * @param map  the map to wrap, must not be null\n+     * @param listClazz  the collection class\n+     * @param initialListCapacity  the initial size of the values list\n+     * @throws NullPointerException  if the map is null\n+     * @throws IllegalArgumentException  if initialListCapacity is negative\n      */\n     protected <C extends List<V>> AbstractListValuedMap(final Map<K, ? super C> map, Class<C> listClazz,\n                                                         final int initialListCapacity) {\n     }\n \n     /**\n+     * Creates a new value collection using the provided factory.\n+     * @return a new list\n+     */\n+    @Override\n+    protected List<V> createCollection() {\n+        return (List<V>) super.createCollection();\n+    }\n+\n+    /**\n      * Gets the list of values associated with the specified key. This would\n      * return an empty list in case the mapping is not present\n      *\n-     * @param key the key to retrieve\n-     * @return the <code>List</code> of values, will return an empty {@link List} for no mapping\n-     * @throws ClassCastException if the key is of an invalid type\n-     */\n-    @Override\n-    public List<V> get(Object key) {\n+     * @param key  the key to retrieve\n+     * @return the {@code List} of values, will return an empty {@link List} for no mapping\n+     */\n+    @Override\n+    public List<V> get(final K key) {\n         return new WrappedList(key);\n     }\n \n      * <p>\n      * A subsequent <code>get(Object)</code> would return an empty list.\n      *\n-     * @param key the key to remove values from\n+     * @param key  the key to remove values from\n      * @return the <code>List</code> of values removed, will return an empty,\n-     *         unmodifiable list for no mapping found.\n-     * @throws ClassCastException if the key is of an invalid type\n+     *   unmodifiable list for no mapping found.\n      */\n     @Override\n     public List<V> remove(Object key) {\n         if (this == obj) {\n             return true;\n         }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (obj instanceof ListValuedMap == false) {\n-            return false;\n-        }\n-        ListValuedMap<?, ?> other = (ListValuedMap<?, ?>) obj;\n-        if (other.size() != size()) {\n-            return false;\n-        }\n-        Iterator<?> it = keySet().iterator();\n-        while (it.hasNext()) {\n-            Object key = it.next();\n-            List<?> list = get(key);\n-            List<?> otherList = other.get(key);\n-            if (otherList == null) {\n-                return false;\n-            }\n-            if (ListUtils.isEqualList(list, otherList) == false) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        if (obj instanceof ListValuedMap) {\n+            return asMap().equals(((ListValuedMap<?, ?>) obj).asMap());\n+        }\n+        return false;\n     }\n \n     @Override\n     public int hashCode() {\n-        int h = 0;\n-        Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();\n-        while (it.hasNext()) {\n-            Entry<K, Collection<V>> entry = it.next();\n-            K key = entry.getKey();\n-            List<V> valueList = (List<V>) entry.getValue();\n-            h += (key == null ? 0 : key.hashCode()) ^ ListUtils.hashCodeForList(valueList);\n-        }\n-        return h;\n+        return asMap().hashCode();\n     }\n \n     /**\n      */\n     private class WrappedList extends WrappedCollection implements List<V> {\n \n-        public WrappedList(Object key) {\n+        public WrappedList(final K key) {\n             super(key);\n         }\n \n-        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        protected List<V> getMapping() {\n+            return (List<V>) getMap().get(key);\n+        }\n+\n+        @Override\n         public void add(int index, V value) {\n-            List<V> list = (List<V>) getMapping();\n+            List<V> list = getMapping();\n             if (list == null) {\n-                list = (List<V>) AbstractListValuedMap.this.createCollection();\n-                list.add(index, value);\n-                getMap().put((K) key, list);\n+                list = createCollection();\n+                getMap().put(key, list);\n             }\n             list.add(index, value);\n         }\n \n-        @SuppressWarnings(\"unchecked\")\n+        @Override\n         public boolean addAll(int index, Collection<? extends V> c) {\n-            List<V> list = (List<V>) getMapping();\n+            List<V> list = getMapping();\n             if (list == null) {\n-                list = (List<V>) createCollection();\n-                boolean result = list.addAll(index, c);\n-                if (result) {\n-                    getMap().put((K) key, list);\n+                list = createCollection();\n+                boolean changed = list.addAll(index, c);\n+                if (changed) {\n+                    getMap().put(key, list);\n                 }\n-                return result;\n+                return changed;\n             }\n             return list.addAll(index, c);\n         }\n \n+        @Override\n         public V get(int index) {\n-            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            final List<V> list = ListUtils.emptyIfNull(getMapping());\n             return list.get(index);\n         }\n \n+        @Override\n         public int indexOf(Object o) {\n-            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            final List<V> list = ListUtils.emptyIfNull(getMapping());\n             return list.indexOf(o);\n         }\n \n+        @Override\n         public int lastIndexOf(Object o) {\n-            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n-            return list.indexOf(o);\n-        }\n-\n+            final List<V> list = ListUtils.emptyIfNull(getMapping());\n+            return list.lastIndexOf(o);\n+        }\n+\n+        @Override\n         public ListIterator<V> listIterator() {\n             return new ValuesListIterator(key);\n         }\n \n+        @Override\n         public ListIterator<V> listIterator(int index) {\n             return new ValuesListIterator(key, index);\n         }\n \n+        @Override\n         public V remove(int index) {\n-            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            final List<V> list = ListUtils.emptyIfNull(getMapping());\n             V value = list.remove(index);\n             if (list.isEmpty()) {\n                 AbstractListValuedMap.this.remove(key);\n             return value;\n         }\n \n+        @Override\n         public V set(int index, V value) {\n-            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            final List<V> list = ListUtils.emptyIfNull(getMapping());\n             return list.set(index, value);\n         }\n \n+        @Override\n         public List<V> subList(int fromIndex, int toIndex) {\n-            final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());\n+            final List<V> list = ListUtils.emptyIfNull(getMapping());\n             return list.subList(fromIndex, toIndex);\n         }\n \n         @Override\n         public boolean equals(Object other) {\n-            final List<V> list = (List<V>) getMapping();\n+            final List<V> list = getMapping();\n             if (list == null) {\n                 return Collections.emptyList().equals(other);\n             }\n-            if (other == null) {\n-                return false;\n-            }\n             if (!(other instanceof List)) {\n                 return false;\n             }\n             List<?> otherList = (List<?>) other;\n-            if (ListUtils.isEqualList(list, otherList) == false) {\n-                return false;\n-            }\n-            return true;\n+            return ListUtils.isEqualList(list, otherList);\n         }\n \n         @Override\n         public int hashCode() {\n-            final List<V> list = (List<V>) getMapping();\n-            if (list == null) {\n-                return Collections.emptyList().hashCode();\n-            }\n+            final List<V> list = getMapping();\n             return ListUtils.hashCodeForList(list);\n         }\n \n     }\n \n-    /** Values ListItrerator */\n-    private class ValuesListIterator implements ListIterator<V>{\n-\n-        private final Object key;\n-\n+    /** Values ListIterator */\n+    private class ValuesListIterator implements ListIterator<V> {\n+\n+        private final K key;\n         private List<V> values;\n         private ListIterator<V> iterator;\n \n-        public ValuesListIterator(Object key){\n+        public ValuesListIterator(final K key) {\n             this.key = key;\n             this.values = ListUtils.emptyIfNull((List<V>) getMap().get(key));\n             this.iterator = values.listIterator();\n         }\n \n-        public ValuesListIterator(Object key, int index){\n+        public ValuesListIterator(final K key, int index) {\n             this.key = key;\n             this.values = ListUtils.emptyIfNull((List<V>) getMap().get(key));\n             this.iterator = values.listIterator(index);\n         }\n \n-        @SuppressWarnings(\"unchecked\")\n+        @Override\n         public void add(V value) {\n             if (getMap().get(key) == null) {\n-                List<V> list = (List<V>) createCollection();\n-                getMap().put((K) key, list);\n+                List<V> list = createCollection();\n+                getMap().put(key, list);\n                 this.values = list;\n                 this.iterator = list.listIterator();\n             }\n-        this.iterator.add(value);\n-        }\n-\n+            this.iterator.add(value);\n+        }\n+\n+        @Override\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        @Override\n         public boolean hasPrevious() {\n             return iterator.hasPrevious();\n         }\n \n+        @Override\n         public V next() {\n             return iterator.next();\n         }\n \n+        @Override\n         public int nextIndex() {\n             return iterator.nextIndex();\n         }\n \n+        @Override\n         public V previous() {\n             return iterator.previous();\n         }\n \n+        @Override\n         public int previousIndex() {\n             return iterator.previousIndex();\n         }\n \n+        @Override\n         public void remove() {\n             iterator.remove();\n             if (values.isEmpty()) {\n             }\n         }\n \n+        @Override\n         public void set(V value) {\n             iterator.set(value);\n         }\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n  * @since 4.1\n  * @version $Id$\n  */\n-public class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V>, Serializable {\n+public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V>, Serializable {\n \n     /** Serialization Version */\n-    private static final long serialVersionUID = 7994988366330224277L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /** The factory for creating value collections. */\n     private final Factory<? extends Collection<V>> collectionFactory;\n     /**\n      * Constructor that wraps (not copies).\n      *\n-     * @param <C>  the collection type\n+     * @param <C> the collection type\n      * @param map  the map to wrap, must not be null\n      * @param collectionClazz  the collection class\n      * @throws NullPointerException if the map is null\n      * Constructor that wraps (not copies).\n      *\n      * @param <C> the collection type\n-     * @param map the map to wrap, must not be null\n-     * @param collectionClazz the collection class\n-     * @param initialCollectionCapacity the initial capacity of the collection\n-     * @throws NullPointerException if the map is null\n-     * @throws IllegalArgumentException if initialCollectionCapacity is negative\n+     * @param map  the map to wrap, must not be null\n+     * @param collectionClazz  the collection class\n+     * @param initialCollectionCapacity  the initial capacity of the collection\n+     * @throws NullPointerException  if the map is null\n+     * @throws IllegalArgumentException  if initialCollectionCapacity is negative\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected <C extends Collection<V>> AbstractMultiValuedMap(final Map<K, ? super C> map,\n             throw new NullPointerException(\"Map must not be null.\");\n         }\n         if (initialCollectionCapacity < 0) {\n-            throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCollectionCapacity);\n+            throw new IllegalArgumentException(\"InitialCapacity must not be negative.\");\n         }\n         this.map = (Map<K, Collection<V>>) map;\n-        this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE },\n+        this.collectionFactory = new InstantiateFactory<C>(collectionClazz,\n+                new Class[] { Integer.TYPE },\n                 new Object[] { Integer.valueOf(initialCollectionCapacity) });\n     }\n \n         return map;\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public boolean containsKey(Object key) {\n         return getMap().containsKey(key);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public boolean containsValue(final Object value) {\n-        final Set<Map.Entry<K, Collection<V>>> pairs = getMap().entrySet();\n-        if (pairs != null) {\n-            for (final Map.Entry<K, Collection<V>> entry : pairs) {\n-                if (entry.getValue().contains(value)) {\n-                    return true;\n-                }\n-            }\n-        }\n-        return false;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n+        return values().contains(value);\n+    }\n+\n     @Override\n     public boolean containsMapping(Object key, Object value) {\n-        final Collection<V> col = getMap().get(key);\n-        if (col == null) {\n-            return false;\n-        }\n-        return col.contains(value);\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n+        Collection<V> coll = getMap().get(key);\n+        return coll != null && coll.contains(value);\n+    }\n+\n     @Override\n     public Collection<Entry<K, V>> entries() {\n         return entryValuesView != null ? entryValuesView : (entryValuesView = new EntryValues());\n      * would return an empty collection in case the mapping is not present\n      *\n      * @param key the key to retrieve\n-     * @return the <code>Collection</code> of values, will return an empty\n-     *         <code>Collection</code> for no mapping\n-     * @throws ClassCastException if the key is of an invalid type\n-     */\n-    @Override\n-    public Collection<V> get(Object key) {\n+     * @return the {@code Collection} of values, will return an empty {@code Collection} for no mapping\n+     */\n+    @Override\n+    public Collection<V> get(final K key) {\n+        // TODO: wrap collection based on class type - needed for proper equals\n         return new WrappedCollection(key);\n     }\n \n      * <p>\n      * A subsequent <code>get(Object)</code> would return an empty collection.\n      *\n-     * @param key the key to remove values from\n+     * @param key  the key to remove values from\n      * @return the <code>Collection</code> of values removed, will return an\n-     *         empty, unmodifiable collection for no mapping found.\n-     * @throws ClassCastException if the key is of an invalid type\n+     *   empty, unmodifiable collection for no mapping found\n      */\n     @Override\n     public Collection<V> remove(Object key) {\n     }\n \n     /**\n-     * Removes a specific value from map.\n+     * Removes a specific key/value mapping from the multi-valued map.\n      * <p>\n-     * The item is removed from the collection mapped to the specified key.\n+     * The value is removed from the collection mapped to the specified key.\n      * Other values attached to that key are unaffected.\n      * <p>\n      * If the last value for a key is removed, an empty collection would be\n-     * returned from a subsequent <code>get(Object)</code>.\n+     * returned from a subsequent {@link #get(Object)}.\n      *\n      * @param key the key to remove from\n-     * @param item the item to remove\n-     * @return {@code true} if the mapping was removed, {@code false} otherwise\n-     */\n-    @Override\n-    public boolean removeMapping(K key, V item) {\n-        boolean result = false;\n-        final Collection<V> col = getMap().get(key);\n-        if (col == null) {\n+     * @param value the value to remove\n+     * @return true if the mapping was removed, false otherwise\n+     */\n+    @Override\n+    public boolean removeMapping(final Object key, final Object value) {\n+        final Collection<V> coll = getMap().get(key);\n+        if (coll == null) {\n             return false;\n         }\n-        result = col.remove(item);\n-        if (!result) {\n-            return false;\n-        }\n-        if (col.isEmpty()) {\n-            remove(key);\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n+        boolean changed = coll.remove(value);\n+        if (coll.isEmpty()) {\n+            getMap().remove(key);\n+        }\n+        return changed;\n+    }\n+\n     @Override\n     public boolean isEmpty() {\n         return getMap().isEmpty();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public Set<K> keySet() {\n         return getMap().keySet();\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public int size() {\n+        // TODO: cache the total size\n         int size = 0;\n-        for (Collection<V> col : getMap().values()) {\n+        for (final Collection<V> col : getMap().values()) {\n             size += col.size();\n         }\n         return size;\n         return vs != null ? vs : (valuesView = new Values());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public void clear() {\n         getMap().clear();\n      * @return the value added if the map changed and null if the map did not change\n      */\n     @Override\n-    public boolean put(K key, V value) {\n-        boolean result = false;\n+    public boolean put(final K key, final V value) {\n         Collection<V> coll = getMap().get(key);\n         if (coll == null) {\n             coll = createCollection();\n-            coll.add(value);\n-            if (coll.size() > 0) {\n-                // only add if non-zero size to maintain class state\n+            if (coll.add(value)) {\n                 getMap().put(key, coll);\n-                result = true; // map definitely changed\n+                return true;\n+            } else {\n+                return false;\n             }\n         } else {\n-            result = coll.add(value);\n-        }\n-        return result;\n+            return coll.add(value);\n+        }\n     }\n \n     /**\n      * undefined if the specified map is modified while the operation is in\n      * progress.\n      *\n-     * @param map mappings to be stored in this map\n-     */\n-    @Override\n-    public void putAll(final Map<? extends K, ? extends V> map) {\n-        if (map != null) {\n-            for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n-                put(entry.getKey(), entry.getValue());\n-            }\n-        }\n+     * @param map mappings to be stored in this map, may not be null\n+     * @throws NullPointerException if map is null\n+     */\n+    @Override\n+    public boolean putAll(final Map<? extends K, ? extends V> map) {\n+        if (map == null) {\n+            throw new NullPointerException(\"Map must not be null.\");\n+        }\n+        boolean changed = false;\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            changed |= put(entry.getKey(), entry.getValue());\n+        }\n+        return changed;\n     }\n \n     /**\n      * behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n-     * @param map mappings to be stored in this map\n-     */\n-    @Override\n-    public void putAll(MultiValuedMap<? extends K, ? extends V> map) {\n-        if (map != null) {\n-            for (final K key : map.keySet()) {\n-                putAll(key, map.get(key));\n-            }\n-        }\n+     * @param map mappings to be stored in this map, may not be null\n+     * @throws NullPointerException if map is null\n+     */\n+    @Override\n+    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n+        if (map == null) {\n+            throw new NullPointerException(\"Map must not be null.\");\n+        }\n+        boolean changed = false;\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entries()) {\n+            changed |= put(entry.getKey(), entry.getValue());\n+        }\n+        return changed;\n     }\n \n     /**\n                                         : (keysMultiSetView = new KeysMultiSet());\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n     @Override\n     public Map<K, Collection<V>> asMap() {\n         return getMap();\n             throw new NullPointerException(\"Values must not be null.\");\n         }\n \n-        Iterator<? extends V> it = values.iterator();\n-        if (!it.hasNext()) {\n-            return false;\n-        }\n-        boolean result = false;\n-        Collection<V> coll = getMap().get(key);\n-        if (coll == null) {\n-            coll = createCollection(); // might produce a non-empty collection\n-            while (it.hasNext()) {\n-                coll.add(it.next());\n-            }\n-            if (coll.size() > 0) {\n-                // only add if non-zero size to maintain class state\n-                getMap().put(key, coll);\n-                result = true; // map definitely changed\n-            }\n+        if (values instanceof Collection<?>) {\n+            Collection<? extends V> valueCollection = (Collection<? extends V>) values;\n+            return !valueCollection.isEmpty() && get(key).addAll(valueCollection); \n         } else {\n-            while (it.hasNext()) {\n-                boolean tmpResult = coll.add(it.next());\n-                if (!result && tmpResult) {\n-                    // If any one of the values have been added, the map has\n-                    // changed\n-                    result = true;\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n+            Iterator<? extends V> it = values.iterator();\n+            return it.hasNext() && CollectionUtils.addAll(get(key), it);\n+        }\n+    }\n+\n     @Override\n     public MapIterator<K, V> mapIterator() {\n         if (size() == 0) {\n-            return EmptyMapIterator.<K, V>emptyMapIterator();\n+            return EmptyMapIterator.emptyMapIterator();\n         }\n         return new MultiValuedMapIterator();\n     }\n         if (this == obj) {\n             return true;\n         }\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (obj instanceof MultiValuedMap == false) {\n-            return false;\n-        }\n-        MultiValuedMap<?, ?> other = (MultiValuedMap<?, ?>) obj;\n-        if (other.size() != size()) {\n-            return false;\n-        }\n-        Iterator<?> it = keySet().iterator();\n-        while (it.hasNext()) {\n-            Object key = it.next();\n-            Collection<?> col = get(key);\n-            Collection<?> otherCol = other.get(key);\n-            if (otherCol == null) {\n-                return false;\n-            }\n-            if (CollectionUtils.isEqualCollection(col, otherCol) == false) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        if (obj instanceof MultiValuedMap) {\n+            return asMap().equals(((MultiValuedMap<?, ?>) obj).asMap());\n+        }\n+        return false;\n     }\n \n     @Override\n     public int hashCode() {\n-        int h = 0;\n-        Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();\n-        while (it.hasNext()) {\n-            Entry<K, Collection<V>> entry = it.next();\n-            K key = entry.getKey();\n-            Collection<V> valueCol = entry.getValue();\n-            int vh = 0;\n-            if (valueCol != null) {\n-                Iterator<V> colIt = valueCol.iterator();\n-                while (colIt.hasNext()) {\n-                    V val = colIt.next();\n-                    if (val != null) {\n-                        vh += val.hashCode();\n-                    }\n-                }\n-            }\n-            h += (key == null ? 0 : key.hashCode()) ^ vh;\n-        }\n-        return h;\n+        return getMap().hashCode();\n     }\n \n     @Override\n      */\n     protected class WrappedCollection implements Collection<V> {\n \n-        protected final Object key;\n-\n-        public WrappedCollection(Object key) {\n+        protected final K key;\n+\n+        public WrappedCollection(final K key) {\n             this.key = key;\n         }\n \n         }\n \n         @Override\n-        @SuppressWarnings(\"unchecked\")\n         public boolean add(V value) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n-                return AbstractMultiValuedMap.this.put((K) key, value);\n-            }\n-            return col.add(value);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public boolean addAll(Collection<? extends V> c) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n-                return AbstractMultiValuedMap.this.putAll((K) key, c);\n-            }\n-            return col.addAll(c);\n+            Collection<V> coll = getMapping();\n+            if (coll == null) {\n+                coll = createCollection();\n+                AbstractMultiValuedMap.this.map.put(key, coll);\n+            }\n+            return coll.add(value);\n+        }\n+\n+        @Override\n+        public boolean addAll(Collection<? extends V> other) {\n+            Collection<V> coll = getMapping();\n+            if (coll == null) {\n+                coll = createCollection();\n+                AbstractMultiValuedMap.this.map.put(key, coll);\n+            }\n+            return coll.addAll(other);\n         }\n \n         @Override\n         public void clear() {\n-            final Collection<V> col = getMapping();\n-            if (col != null) {\n-                col.clear();\n+            final Collection<V> coll = getMapping();\n+            if (coll != null) {\n+                coll.clear();\n                 AbstractMultiValuedMap.this.remove(key);\n             }\n         }\n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public Iterator<V> iterator() {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return IteratorUtils.EMPTY_ITERATOR;\n             }\n             return new ValuesIterator(key);\n \n         @Override\n         public int size() {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n-                return 0;\n-            }\n-            return col.size();\n-        }\n-\n-        @Override\n-        public boolean contains(Object o) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+            final Collection<V> coll = getMapping();\n+            return coll == null ? 0 : coll.size();\n+        }\n+\n+        @Override\n+        public boolean contains(Object obj) {\n+            final Collection<V> coll = getMapping();\n+            return coll == null ? false : coll.contains(obj);\n+        }\n+\n+        @Override\n+        public boolean containsAll(Collection<?> other) {\n+            final Collection<V> coll = getMapping();\n+            return coll == null ? false : coll.containsAll(other);\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            final Collection<V> coll = getMapping();\n+            return coll == null ? true : coll.isEmpty();\n+        }\n+\n+        @Override\n+        public boolean remove(Object item) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return false;\n             }\n-            return col.contains(o);\n-        }\n-\n-        @Override\n-        public boolean containsAll(Collection<?> o) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+\n+            boolean result = coll.remove(item);\n+            if (coll.isEmpty()) {\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean removeAll(Collection<?> c) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return false;\n             }\n-            return col.containsAll(o);\n-        }\n-\n-        @Override\n-        public boolean isEmpty() {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n-                return true;\n-            }\n-            return col.isEmpty();\n-        }\n-\n-        @Override\n-        public boolean remove(Object item) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+\n+            boolean result = coll.removeAll(c);\n+            if (coll.isEmpty()) {\n+                AbstractMultiValuedMap.this.remove(key);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean retainAll(Collection<?> c) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return false;\n             }\n \n-            boolean result = col.remove(item);\n-            if (col.isEmpty()) {\n+            boolean result = coll.retainAll(c);\n+            if (coll.isEmpty()) {\n                 AbstractMultiValuedMap.this.remove(key);\n             }\n             return result;\n         }\n \n         @Override\n-        public boolean removeAll(Collection<?> c) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n-                return false;\n-            }\n-\n-            boolean result = col.removeAll(c);\n-            if (col.isEmpty()) {\n-                AbstractMultiValuedMap.this.remove(key);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public boolean retainAll(Collection<?> c) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n-                return false;\n-            }\n-\n-            boolean result = col.retainAll(c);\n-            if (col.isEmpty()) {\n-                AbstractMultiValuedMap.this.remove(key);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n         public Object[] toArray() {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return CollectionUtils.EMPTY_COLLECTION.toArray();\n             }\n-            return col.toArray();\n+            return coll.toArray();\n         }\n \n         @Override\n         @SuppressWarnings(\"unchecked\")\n         public <T> T[] toArray(T[] a) {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return (T[]) CollectionUtils.EMPTY_COLLECTION.toArray(a);\n             }\n-            return col.toArray(a);\n+            return coll.toArray(a);\n         }\n \n         @Override\n         public String toString() {\n-            final Collection<V> col = getMapping();\n-            if (col == null) {\n+            final Collection<V> coll = getMapping();\n+            if (coll == null) {\n                 return CollectionUtils.EMPTY_COLLECTION.toString();\n             }\n-            return col.toString();\n-        }\n-\n-    }\n-\n-    /**\n-     * Inner class that provides a MultiSet<K> keys view\n+            return coll.toString();\n+        }\n+\n+    }\n+\n+    /**\n+     * Inner class that provides a MultiSet<K> keys view.\n      */\n     private class KeysMultiSet implements MultiSet<K> {\n \n \n         @Override\n         public Set<K> uniqueSet() {\n-            return UnmodifiableSet.<K>unmodifiableSet(keySet());\n+            return UnmodifiableSet.unmodifiableSet(keySet());\n         }\n \n         @Override\n     }\n \n     /**\n-     * Inner class for MultiValuedMap Entries\n+     * Inner class for MultiValuedMap Entries.\n      */\n     private class MultiValuedMapEntry extends AbstractMapEntry<K, V> {\n \n     }\n \n     /**\n-     * Inner class for MapIterator\n+     * Inner class for MapIterator.\n      */\n     private class MultiValuedMapIterator implements MapIterator<K, V> {\n \n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n  * @since 4.1\n  * @version $Id$\n  */\n-public class AbstractMultiValuedMapDecorator<K, V>\n+public abstract class AbstractMultiValuedMapDecorator<K, V>\n         implements MultiValuedMap<K, V>, Serializable {\n \n     /** Serialization version */\n-    private static final long serialVersionUID = -9184930955231260637L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /** MultiValuedMap to decorate */\n     private final MultiValuedMap<K, V> map;\n     /**\n      * Constructor that wraps (not copies).\n      *\n-     * @param map the map to decorate, must not be null\n+     * @param map  the map to decorate, must not be null\n      * @throws NullPointerException if the map is null\n      */\n     protected AbstractMultiValuedMapDecorator(final MultiValuedMap<K, V> map) {\n         this.map = map;\n     }\n \n+    /**\n+     * The decorated multi-valued map.\n+     *\n+     * @return the map to decorate\n+     */\n     protected MultiValuedMap<K, V> decorated() {\n         return map;\n     }\n     }\n \n     @Override\n-    public boolean containsKey(Object key) {\n+    public boolean containsKey(final Object key) {\n         return decorated().containsKey(key);\n     }\n \n     @Override\n-    public boolean containsValue(Object value) {\n+    public boolean containsValue(final Object value) {\n         return decorated().containsValue(value);\n     }\n \n     @Override\n-    public boolean containsMapping(Object key, Object value) {\n+    public boolean containsMapping(final Object key, final Object value) {\n         return decorated().containsMapping(key, value);\n     }\n \n     @Override\n-    public Collection<V> get(Object key) {\n+    public Collection<V> get(final K key) {\n         return decorated().get(key);\n     }\n \n     @Override\n-    public Collection<V> remove(Object key) {\n+    public Collection<V> remove(final Object key) {\n         return decorated().remove(key);\n     }\n \n     @Override\n-    public boolean removeMapping(K key, V item) {\n+    public boolean removeMapping(final Object key, final Object item) {\n         return decorated().removeMapping(key, item);\n     }\n \n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> m) {\n-        decorated().putAll(m);\n+    public boolean putAll(Map<? extends K, ? extends V> map) {\n+        return decorated().putAll(map);\n     }\n \n     @Override\n-    public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n-        decorated().putAll(m);\n+    public boolean putAll(MultiValuedMap<? extends K, ? extends V> map) {\n+        return decorated().putAll(map);\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java\n  */\n package org.apache.commons.collections4.multimap;\n \n-import java.util.Collection;\n import java.util.Collections;\n-import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n-import java.util.Map.Entry;\n \n import org.apache.commons.collections4.SetUtils;\n import org.apache.commons.collections4.SetValuedMap;\n  * @since 4.1\n  * @version $Id$\n  */\n-public abstract class AbstractSetValuedMap<K, V> extends AbstractMultiValuedMap<K, V> implements SetValuedMap<K, V> {\n+public abstract class AbstractSetValuedMap<K, V> extends AbstractMultiValuedMap<K, V>\n+    implements SetValuedMap<K, V> {\n \n     /** Serialization version */\n-    private static final long serialVersionUID = 3383617478898639862L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /**\n      * A constructor that wraps, not copies\n      *\n      * @param <C> the set type\n-     * @param map the map to wrap, must not be null\n-     * @param setClazz the collection class\n+     * @param map  the map to wrap, must not be null\n+     * @param setClazz  the collection class\n      * @throws NullPointerException if the map is null\n      */\n     protected <C extends Set<V>> AbstractSetValuedMap(Map<K, ? super C> map, Class<C> setClazz) {\n      * A constructor that wraps, not copies\n      *\n      * @param <C> the set type\n-     * @param map the map to wrap, must not be null\n-     * @param setClazz the collection class\n-     * @param initialSetCapacity the initial size of the values set\n+     * @param map  the map to wrap, must not be null\n+     * @param setClazz  the collection class\n+     * @param initialSetCapacity  the initial size of the values set\n      * @throws NullPointerException if the map is null\n      * @throws IllegalArgumentException if initialSetCapacity is negative\n      */\n      * Gets the set of values associated with the specified key. This would\n      * return an empty set in case the mapping is not present\n      *\n-     * @param key the key to retrieve\n+     * @param key  the key to retrieve\n      * @return the <code>Set</code> of values, will return an empty\n-     *         <code>Set</code> for no mapping\n-     * @throws ClassCastException if the key is of an invalid type\n+     *   <code>Set</code> for no mapping\n      */\n     @Override\n-    public Set<V> get(Object key) {\n+    public Set<V> get(final K key) {\n         return new WrappedSet(key);\n     }\n \n      *\n      * @param key the key to remove values from\n      * @return the <code>Set</code> of values removed, will return an empty,\n-     *         unmodifiable set for no mapping found.\n-     * @throws ClassCastException if the key is of an invalid type\n+     *   unmodifiable set for no mapping found.\n      */\n     @Override\n     public Set<V> remove(Object key) {\n         if (this == obj) {\n             return true;\n         }\n-        if (obj == null) {\n-            return false;\n+        if (obj instanceof SetValuedMap) {\n+            return asMap().equals(((SetValuedMap<?, ?>) obj).asMap());\n         }\n-        if (obj instanceof SetValuedMap == false) {\n-            return false;\n-        }\n-        SetValuedMap<?, ?> other = (SetValuedMap<?, ?>) obj;\n-        if (other.size() != size()) {\n-            return false;\n-        }\n-        Iterator<?> it = keySet().iterator();\n-        while (it.hasNext()) {\n-            Object key = it.next();\n-            Set<?> set = get(key);\n-            Set<?> otherSet = other.get(key);\n-            if (otherSet == null) {\n-                return false;\n-            }\n-            if (SetUtils.isEqualSet(set, otherSet) == false) {\n-                return false;\n-            }\n-        }\n-        return true;\n+        return false;\n     }\n \n     @Override\n     public int hashCode() {\n-        int h = 0;\n-        Iterator<Entry<K, Collection<V>>> it = getMap().entrySet().iterator();\n-        while (it.hasNext()) {\n-            Entry<K, Collection<V>> entry = it.next();\n-            K key = entry.getKey();\n-            Set<V> valueSet = (Set<V>) entry.getValue();\n-            h += (key == null ? 0 : key.hashCode()) ^ SetUtils.hashCodeForSet(valueSet);\n-        }\n-        return h;\n+        return asMap().hashCode();\n     }\n \n     /**\n      * Wrapped set to handle add and remove on the collection returned by\n-     * get(object)\n+     * {@code get(Object)}.\n      */\n     protected class WrappedSet extends WrappedCollection implements Set<V> {\n \n-        public WrappedSet(Object key) {\n+        public WrappedSet(final K key) {\n             super(key);\n         }\n \n             if (set == null) {\n                 return Collections.emptySet().equals(other);\n             }\n-            if (other == null) {\n-                return false;\n-            }\n             if (!(other instanceof Set)) {\n                 return false;\n             }\n             Set<?> otherSet = (Set<?>) other;\n-            if (SetUtils.isEqualSet(set, otherSet) == false) {\n-                return false;\n-            }\n-            return true;\n+            return SetUtils.isEqualSet(set, otherSet);\n         }\n \n         @Override\n         public int hashCode() {\n             final Set<V> set = (Set<V>) getMapping();\n-            if (set == null) {\n-                return Collections.emptySet().hashCode();\n-            }\n             return SetUtils.hashCodeForSet(set);\n         }\n \n--- a/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedHashMap.java\n public class MultiValuedHashMap<K, V> extends AbstractMultiValuedMap<K, V> {\n \n     /** Serialization Version */\n-    private static final long serialVersionUID = -5845183518195365857L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /**\n      * The initial capacity used when none specified in constructor.\n      */\n     protected <C extends Collection<V>> MultiValuedHashMap(int initialCapacity, float loadFactor,\n             final Class<C> collectionClazz, int initialCollectionCapacity) {\n-        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz, initialCollectionCapacity);\n+        super(new HashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz,\n+                                            initialCollectionCapacity);\n     }\n \n     /** Inner class for ListValuedMap */\n     private static class ListValuedHashMap<K, V> extends AbstractListValuedMap<K, V> {\n \n-        private static final long serialVersionUID = 3667581458573135234L;\n+        private static final long serialVersionUID = 20150612L;\n \n         public <C extends List<V>> ListValuedHashMap(Class<C> listClazz) {\n             super(new HashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz);\n     /** Inner class for SetValuedMap */\n     private static class SetValuedHashMap<K, V> extends AbstractSetValuedMap<K, V> {\n \n-        private static final long serialVersionUID = -3817515514829894543L;\n+        private static final long serialVersionUID = 20150612L;\n \n         public <C extends Set<V>> SetValuedHashMap(Class<C> setClazz) {\n             super(new HashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz);\n--- a/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n package org.apache.commons.collections4.multimap;\n \n import java.util.Iterator;\n-import java.util.LinkedList;\n-import java.util.List;\n import java.util.Map;\n \n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.collections4.FluentIterable;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Transformer;\n-import org.apache.commons.collections4.map.LinkedMap;\n \n /**\n  * Decorates another <code>MultiValuedMap</code> to transform objects that are added.\n public class TransformedMultiValuedMap<K, V> extends AbstractMultiValuedMapDecorator<K, V> {\n \n     /** Serialization Version */\n-    private static final long serialVersionUID = -1254147899086470720L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /** The key transformer */\n     private final Transformer<? super K, ? extends K> keyTransformer;\n      * NOT transformed. Contrast this with\n      * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the MultiValuedMap to decorate, may not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n      * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n      * be transformed by this method. Contrast this with\n      * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n      *\n-     * @param <K>  the key type\n-     * @param <V>  the value type\n+     * @param <K> the key type\n+     * @param <V> the value type\n      * @param map  the MultiValuedMap to decorate, may not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n      * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n             final Transformer<? super V, ? extends V> valueTransformer) {\n         final TransformedMultiValuedMap<K, V> decorated =\n                 new TransformedMultiValuedMap<K, V>(map, keyTransformer, valueTransformer);\n-        if (map.size() > 0) {\n-            MultiValuedMap<K, V> transformed = decorated.transformMultiValuedMap(map);\n+        if (!map.isEmpty()) {\n+            final MultiValuedMap<K, V> mapCopy = new MultiValuedHashMap<K, V>(map);\n             decorated.clear();\n-            // to avoid double transform\n-            decorated.decorated().putAll(transformed);\n+            decorated.putAll(mapCopy);\n         }\n         return decorated;\n     }\n      * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n      * @throws NullPointerException if map is null\n      */\n-    protected TransformedMultiValuedMap(MultiValuedMap<K, V> map,\n-            Transformer<? super K, ? extends K> keyTransformer, Transformer<? super V, ? extends V> valueTransformer) {\n+    protected TransformedMultiValuedMap(final MultiValuedMap<K, V> map,\n+            final Transformer<? super K, ? extends K> keyTransformer,\n+            final Transformer<? super V, ? extends V> valueTransformer) {\n         super(map);\n         this.keyTransformer = keyTransformer;\n         this.valueTransformer = valueTransformer;\n         return valueTransformer.transform(object);\n     }\n \n-    /**\n-     * Transforms a map.\n-     * <p>\n-     * The transformer itself may throw an exception if necessary.\n-     *\n-     * @param map  the map to transform\n-     * @return the transformed object\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    protected Map<K, V> transformMap(final Map<? extends K, ? extends V> map) {\n-        if (map.isEmpty()) {\n-            return (Map<K, V>) map;\n-        }\n-        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n-\n-        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n-            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Transforms a MultiValuedMap.\n-     * <p>\n-     * The transformer itself may throw an exception if necessary.\n-     *\n-     * @param map  the MultiValuedMap to transform\n-     * @return the transformed object\n-     */\n-    @SuppressWarnings(\"unchecked\")\n-    protected MultiValuedMap<K, V> transformMultiValuedMap(\n-            final MultiValuedMap<? extends K, ? extends V> map) {\n-        if (map.isEmpty()) {\n-            return (MultiValuedMap<K, V>) map;\n-        }\n-        final MultiValuedMap<K, V> result = new MultiValuedHashMap<K, V>();\n-\n-        for (final Map.Entry<? extends K, ? extends V> entry : map.entries()) {\n-            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n-        }\n-        return result;\n+    @Override\n+    public boolean put(final K key, final V value) {\n+        return decorated().put(transformKey(key), transformValue(value));\n     }\n \n     @Override\n-    public boolean put(K key, V value) {\n-        K transformedKey = transformKey(key);\n-        V transformedValue = transformValue(value);\n-        return decorated().put(transformedKey, transformedValue);\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    public boolean putAll(K key, Iterable<? extends V> values) {\n+    public boolean putAll(final K key, final Iterable<? extends V> values) {\n         if (values == null) {\n             throw new NullPointerException(\"Values must not be null.\");\n         }\n \n-        Iterator<V> it = (Iterator<V>) values.iterator();\n-        if (!it.hasNext()) {\n-            return false;\n-        }\n-        K transformedKey = transformKey(key);\n-        List<V> transformedValues = new LinkedList<V>();\n-        while (it.hasNext()) {\n-            transformedValues.add(transformValue(it.next()));\n-        }\n-        return decorated().putAll(transformedKey, transformedValues);\n+        final Iterable<V> transformedValues = FluentIterable.of(values).transform(valueTransformer);\n+        final Iterator<? extends V> it = transformedValues.iterator();\n+        return it.hasNext() && CollectionUtils.addAll(decorated().get(transformKey(key)), it);\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> m) {\n-        decorated().putAll(transformMap(m));\n+    public boolean putAll(final Map<? extends K, ? extends V> map) {\n+        if (map == null) {\n+            throw new NullPointerException(\"Map must not be null.\");\n+        }\n+        boolean changed = false;\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            changed |= put(entry.getKey(), entry.getValue());\n+        }\n+        return changed;\n     }\n \n     @Override\n-    public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n-        decorated().putAll(transformMultiValuedMap(m));\n+    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n+        if (map == null) {\n+            throw new NullPointerException(\"Map must not be null.\");\n+        }\n+        boolean changed = false;\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entries()) {\n+            changed |= put(entry.getKey(), entry.getValue());\n+        }\n+        return changed;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n  * @since 4.1\n  * @version $Id$\n  */\n-public class UnmodifiableMultiValuedMap<K, V>\n+public final class UnmodifiableMultiValuedMap<K, V>\n         extends AbstractMultiValuedMapDecorator<K, V> implements Unmodifiable {\n \n     /** Serialization version */\n-    private static final long serialVersionUID = 1418669828214151566L;\n+    private static final long serialVersionUID = 20150612L;\n \n     /**\n      * Factory method to create an unmodifiable MultiValuedMap.\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n      *\n-     * @param <K>  the type of key elements\n-     * @param <V>  the type of value elements\n+     * @param <K> the type of key elements\n+     * @param <V> the type of value elements\n      * @param map  the map to decorate, may not be null\n      * @return an unmodifiable MultiValuedMap\n      * @throws NullPointerException if map is null\n     }\n \n     @Override\n-    public Collection<V> remove(Object key) {\n+    public Collection<V> remove(final Object key) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public boolean removeMapping(K key, V item) {\n+    public boolean removeMapping(final Object key, final Object item) {\n         throw new UnsupportedOperationException();\n     }\n \n     }\n \n     @Override\n-    public Collection<V> get(Object key) {\n-        return UnmodifiableCollection.<V>unmodifiableCollection(decorated().get(key));\n+    public Collection<V> get(final K key) {\n+        return UnmodifiableCollection.unmodifiableCollection(decorated().get(key));\n     }\n \n     @Override\n-    public boolean put(K key, V value) {\n+    public boolean put(final K key, final V value) {\n         throw new UnsupportedOperationException();\n     }\n \n \n     @Override\n     public Map<K, Collection<V>> asMap() {\n-        return UnmodifiableMap.<K, Collection<V>>unmodifiableMap(decorated().asMap());\n+        return UnmodifiableMap.unmodifiableMap(decorated().asMap());\n     }\n \n     @Override\n     public MapIterator<K, V> mapIterator() {\n-        return UnmodifiableMapIterator.<K, V>unmodifiableMapIterator(decorated().mapIterator());\n+        return UnmodifiableMapIterator.unmodifiableMapIterator(decorated().mapIterator());\n     }\n \n     @Override\n-    public boolean putAll(K key, Iterable<? extends V> values) {\n+    public boolean putAll(final K key, final Iterable<? extends V> values) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(Map<? extends K, ? extends V> m) {\n+    public boolean putAll(final Map<? extends K, ? extends V> map) {\n         throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n+    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testNoMappingReturnsEmptyCol() {\n         final MultiValuedMap<K, V> map = makeFullMap();\n-        assertTrue(map.get(\"whatever\").isEmpty());\n+        assertTrue(map.get((K) \"whatever\").isEmpty());\n     }\n \n     public void testMultipleValues() {\n         final MultiValuedMap<K, V> map = makeFullMap();\n-        Collection<V> col = map.get(\"one\");\n+        @SuppressWarnings(\"unchecked\")\n+        Collection<V> col = map.get((K) \"one\");\n         assertTrue(col.contains(\"uno\"));\n         assertTrue(col.contains(\"un\"));\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testGet() {\n         final MultiValuedMap<K, V> map = makeFullMap();\n-        assertTrue(map.get(\"one\").contains(\"uno\"));\n-        assertTrue(map.get(\"one\").contains(\"un\"));\n-        assertTrue(map.get(\"two\").contains(\"dos\"));\n-        assertTrue(map.get(\"two\").contains(\"deux\"));\n-        assertTrue(map.get(\"three\").contains(\"tres\"));\n-        assertTrue(map.get(\"three\").contains(\"trois\"));\n+        assertTrue(map.get((K) \"one\").contains(\"uno\"));\n+        assertTrue(map.get((K) \"one\").contains(\"un\"));\n+        assertTrue(map.get((K) \"two\").contains(\"dos\"));\n+        assertTrue(map.get((K) \"two\").contains(\"deux\"));\n+        assertTrue(map.get((K) \"three\").contains(\"tres\"));\n+        assertTrue(map.get((K) \"three\").contains(\"trois\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         }\n         resetEmpty();\n         final MultiValuedMap<K, V> map =  getMap();\n-        Collection<V> col1 = map.get(\"one\");\n-        Collection<V> col2 = map.get(\"one\");\n+        Collection<V> col1 = map.get((K) \"one\");\n+        Collection<V> col2 = map.get((K) \"one\");\n         assertTrue(col1.isEmpty());\n         assertTrue(col2.isEmpty());\n         assertEquals(0, map.size());\n         }\n         resetFull();\n         final MultiValuedMap<K, V> map = getMap();\n-        Collection<V> col = map.get(\"one\");\n+        @SuppressWarnings(\"unchecked\")\n+        Collection<V> col = map.get((K) \"one\");\n         assertEquals(2, col.size());\n         assertEquals(6, map.size());\n         col.remove(\"uno\");\n         }\n         resetFull();\n         final MultiValuedMap<K, V> map = getMap();\n-        Iterator<V> it = map.get(\"one\").iterator();\n+        @SuppressWarnings(\"unchecked\")\n+        Iterator<V> it = map.get((K) \"one\").iterator();\n         while (it.hasNext()) {\n             it.next();\n             it.remove();\n //        assertEquals(expected, actual);\n //    }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveAllViaValuesIterator() {\n         if (!isRemoveSupported()) {\n             return;\n             i.next();\n             i.remove();\n         }\n-        assertTrue(map.get(\"one\").isEmpty());\n+        assertTrue(map.get((K) \"one\").isEmpty());\n         assertTrue(map.isEmpty());\n     }\n \n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n     public void testRemoveAllViaEntriesIterator() {\n         if (!isRemoveSupported()) {\n             return;\n             i.next();\n             i.remove();\n         }\n-        assertTrue(map.get(\"one\").isEmpty());\n+        assertTrue(map.get((K) \"one\").isEmpty());\n         assertEquals(0, map.size());\n     }\n \n         final MultiValuedMap<K, V> one = makeObject();\n         final Integer value = Integer.valueOf(1);\n         one.put((K) \"One\", (V) value);\n-        one.removeMapping((K) \"One\", (V) value);\n+        one.removeMapping(\"One\", value);\n \n         final MultiValuedMap<K, V> two = makeObject();\n         assertEquals(two, one);\n         assertEquals(4, map.size());\n         map.remove(\"A\");\n         assertEquals(3, map.size());\n-        map.removeMapping((K) \"B\", (V) \"BC\");\n+        map.removeMapping(\"B\", \"BC\");\n         assertEquals(2, map.size());\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public void testSize_Key() {\n         final MultiValuedMap<K, V> map = makeFullMap();\n-        assertEquals(2, map.get(\"one\").size());\n-        assertEquals(2, map.get(\"two\").size());\n-        assertEquals(2, map.get(\"three\").size());\n+        assertEquals(2, map.get((K) \"one\").size());\n+        assertEquals(2, map.get((K) \"two\").size());\n+        assertEquals(2, map.get((K) \"three\").size());\n         if (!isAddSupported()) {\n             return;\n         }\n         map.put((K) \"A\", (V) \"AA\");\n-        assertEquals(1, map.get(\"A\").size());\n+        assertEquals(1, map.get((K) \"A\").size());\n         //assertEquals(0, map.get(\"B\").size());\n         map.put((K) \"B\", (V) \"BA\");\n-        assertEquals(1, map.get(\"A\").size());\n-        assertEquals(1, map.get(\"B\").size());\n+        assertEquals(1, map.get((K) \"A\").size());\n+        assertEquals(1, map.get((K) \"B\").size());\n         map.put((K) \"B\", (V) \"BB\");\n-        assertEquals(1, map.get(\"A\").size());\n-        assertEquals(2, map.get(\"B\").size());\n+        assertEquals(1, map.get((K) \"A\").size());\n+        assertEquals(2, map.get((K) \"B\").size());\n         map.put((K) \"B\", (V) \"BC\");\n-        assertEquals(1, map.get(\"A\").size());\n-        assertEquals(3, map.get(\"B\").size());\n+        assertEquals(1, map.get((K) \"A\").size());\n+        assertEquals(3, map.get((K) \"B\").size());\n         if (!isRemoveSupported()) {\n             return;\n         }\n         map.remove(\"A\");\n         //assertEquals(0, map.get(\"A\").size());\n-        assertEquals(3, map.get(\"B\").size());\n-        map.removeMapping((K) \"B\", (V) \"BC\");\n+        assertEquals(3, map.get((K) \"B\").size());\n+        map.removeMapping(\"B\", \"BC\");\n         //assertEquals(0, map.get(\"A\").size());\n-        assertEquals(2, map.get(\"B\").size());\n+        assertEquals(2, map.get((K) \"B\").size());\n     }\n \n //    @SuppressWarnings(\"unchecked\")\n \n         assertEquals(2, test.keySet().size());\n         assertEquals(4, test.size());\n-        assertEquals(1, test.get(\"keyA\").size());\n-        assertEquals(3, test.get(\"key\").size());\n+        assertEquals(1, test.get((K) \"keyA\").size());\n+        assertEquals(3, test.get((K) \"key\").size());\n         assertEquals(true, test.containsValue(\"objectA\"));\n         assertEquals(true, test.containsValue(\"object0\"));\n         assertEquals(true, test.containsValue(\"object1\"));\n \n         assertEquals(3, test.keySet().size());\n         assertEquals(4, test.size());\n-        assertEquals(1, test.get(\"keyA\").size());\n-        assertEquals(2, test.get(\"keyX\").size());\n-        assertEquals(1, test.get(\"keyY\").size());\n+        assertEquals(1, test.get((K) \"keyA\").size());\n+        assertEquals(2, test.get((K) \"keyX\").size());\n+        assertEquals(1, test.get((K) \"keyY\").size());\n         assertEquals(true, test.containsValue(\"objectA\"));\n         assertEquals(true, test.containsValue(\"object0\"));\n         assertEquals(true, test.containsValue(\"object1\"));\n         Collection<V> coll = (Collection<V>) Arrays.asList(\"X\", \"Y\", \"Z\");\n \n         assertEquals(true, map.putAll((K) \"A\", coll));\n-        assertEquals(3, map.get(\"A\").size());\n+        assertEquals(3, map.get((K) \"A\").size());\n         assertEquals(true, map.containsMapping(\"A\", \"X\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n             // expected\n         }\n \n-        assertEquals(3, map.get(\"A\").size());\n+        assertEquals(3, map.get((K) \"A\").size());\n         assertEquals(true, map.containsMapping(\"A\", \"X\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n \n         assertEquals(false, map.putAll((K) \"A\", new ArrayList<V>()));\n-        assertEquals(3, map.get(\"A\").size());\n+        assertEquals(3, map.get((K) \"A\").size());\n         assertEquals(true, map.containsMapping(\"A\", \"X\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n \n         coll = (Collection<V>) Arrays.asList(\"M\");\n         assertEquals(true, map.putAll((K) \"A\", coll));\n-        assertEquals(4, map.get(\"A\").size());\n+        assertEquals(4, map.get((K) \"A\").size());\n         assertEquals(true, map.containsMapping(\"A\", \"X\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n         assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n         map.put((K) \"A\", (V) \"AA\");\n         map.put((K) \"A\", (V) \"AB\");\n         map.put((K) \"A\", (V) \"AC\");\n-        assertEquals(false, map.removeMapping((K) \"C\", (V) \"CA\"));\n-        assertEquals(false, map.removeMapping((K) \"A\", (V) \"AD\"));\n-        assertEquals(true, map.removeMapping((K) \"A\", (V) \"AC\"));\n-        assertEquals(true, map.removeMapping((K) \"A\", (V) \"AB\"));\n-        assertEquals(true, map.removeMapping((K) \"A\", (V) \"AA\"));\n+        assertEquals(false, map.removeMapping(\"C\", \"CA\"));\n+        assertEquals(false, map.removeMapping(\"A\", \"AD\"));\n+        assertEquals(true, map.removeMapping(\"A\", \"AC\"));\n+        assertEquals(true, map.removeMapping(\"A\", \"AB\"));\n+        assertEquals(true, map.removeMapping(\"A\", \"AA\"));\n         //assertEquals(new MultiValuedHashMap<K, V>(), map);\n     }\n \n         assertEquals(\"Map is empty\", 0, map2.size());\n     }\n \n+    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n     public void testFullMapCompatibility() throws Exception {\n-        final MultiValuedMap<?, ?> map = makeFullMap();\n-        final MultiValuedMap<?, ?> map2 =\n-                (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+        final MultiValuedMap map = makeFullMap();\n+        final MultiValuedMap map2 =\n+                (MultiValuedMap) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n         assertEquals(\"Map is the right size\", map.size(), map2.size());\n         for (final Object key : map.keySet()) {\n-            assertTrue(\"Map had inequal elements\", CollectionUtils.isEqualCollection(map.get(key), map2.get(key)));\n+            assertTrue(\"Map had inequal elements\",\n+                       CollectionUtils.isEqualCollection(map.get(key), map2.get(key)));\n             if (isRemoveSupported()) {\n                 map2.remove(key);\n             }\n--- a/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/MultiValuedHashMapTest.java\n     @SuppressWarnings(\"unchecked\")\n     public void testSetValuedMapAdd() {\n         final SetValuedMap<K, V> setMap = MultiValuedHashMap.setValuedHashMap();\n-        assertTrue(setMap.get(\"whatever\") instanceof Set);\n-\n-        Set<V> set = setMap.get(\"A\");\n+        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get((K) \"A\");\n         assertTrue(set.add((V) \"a1\"));\n         assertTrue(set.add((V) \"a2\"));\n         assertFalse(set.add((V) \"a1\"));\n     @SuppressWarnings(\"unchecked\")\n     public void testSetValuedMapRemove() {\n         final SetValuedMap<K, V> setMap = MultiValuedHashMap.setValuedHashMap();\n-        assertTrue(setMap.get(\"whatever\") instanceof Set);\n-\n-        Set<V> set = setMap.get(\"A\");\n+        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get((K) \"A\");\n         assertTrue(set.add((V) \"a1\"));\n         assertTrue(set.add((V) \"a2\"));\n         assertFalse(set.add((V) \"a1\"));\n     @SuppressWarnings(\"unchecked\")\n     public void testSetValuedMapRemoveViaIterator() {\n         final SetValuedMap<K, V> setMap = MultiValuedHashMap.setValuedHashMap();\n-        assertTrue(setMap.get(\"whatever\") instanceof Set);\n-\n-        Set<V> set = setMap.get(\"A\");\n+        assertTrue(setMap.get((K) \"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get((K) \"A\");\n         set.add((V) \"a1\");\n         set.add((V) \"a2\");\n         set.add((V) \"a1\");\n     @SuppressWarnings(\"unchecked\")\n     public void testListValuedMapAdd() {\n         final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n-        assertTrue(listMap.get(\"whatever\") instanceof List);\n-        List<V> list = listMap.get(\"A\");\n+        assertTrue(listMap.get((K) \"whatever\") instanceof List);\n+        List<V> list = listMap.get((K) \"A\");\n         list.add((V) \"a1\");\n         assertEquals(1, listMap.size());\n         assertTrue(listMap.containsKey(\"A\"));\n     @SuppressWarnings(\"unchecked\")\n     public void testListValuedMapAddViaListIterator() {\n         final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n-        ListIterator<V> listIt = listMap.get(\"B\").listIterator();\n+        ListIterator<V> listIt = listMap.get((K) \"B\").listIterator();\n         assertFalse(listIt.hasNext());\n         listIt.add((V) \"b1\");\n         listIt.add((V) \"b2\");\n     @SuppressWarnings(\"unchecked\")\n     public void testListValuedMapRemove() {\n         final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n-        List<V> list = listMap.get(\"A\");\n+        List<V> list = listMap.get((K) \"A\");\n         list.add((V) \"a1\");\n         list.add((V) \"a2\");\n         list.add((V) \"a3\");\n     @SuppressWarnings(\"unchecked\")\n     public void testListValuedMapRemoveViaListIterator() {\n         final ListValuedMap<K, V> listMap = MultiValuedHashMap.listValuedHashMap();\n-        ListIterator<V> listIt = listMap.get(\"B\").listIterator();\n+        ListIterator<V> listIt = listMap.get((K) \"B\").listIterator();\n         listIt.add((V) \"b1\");\n         listIt.add((V) \"b2\");\n         assertEquals(2, listMap.size());\n         assertTrue(listMap.containsKey(\"B\"));\n-        listIt = listMap.get(\"B\").listIterator();\n+        listIt = listMap.get((K) \"B\").listIterator();\n         while (listIt.hasNext()) {\n             listIt.next();\n             listIt.remove();\n         listIt.add((V) \"b1\");\n         listIt.add((V) \"b2\");\n         assertTrue(listMap.containsKey(\"B\"));\n-        assertEquals(2, listMap.get(\"B\").size());\n+        assertEquals(2, listMap.get((K) \"B\").size());\n     }\n \n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n \n         map1.put(\"a\", \"a1\");\n         map1.put(\"a\", \"a2\");\n-        map2.put(\"a\", \"a2\");\n         map2.put(\"a\", \"a1\");\n+        map2.put(\"a\", \"a2\");\n         assertEquals(map1, map2);\n         assertEquals(map1.hashCode(), map2.hashCode());\n \n--- a/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMapTest.java\n             assertEquals(true, map.containsKey(Integer.valueOf((String) els[i])));\n             assertEquals(false, map.containsKey(els[i]));\n             assertEquals(true, map.containsValue(els[i]));\n-            assertEquals(true, map.get(Integer.valueOf((String) els[i])).contains(els[i]));\n+            assertEquals(true, map.get((K) Integer.valueOf((String) els[i])).contains(els[i]));\n         }\n \n         Collection<V> coll = map.remove(els[0]);\n             assertEquals(true, map.containsValue(Integer.valueOf((String) els[i])));\n             assertEquals(false, map.containsValue(els[i]));\n             assertEquals(true, map.containsKey(els[i]));\n-            assertEquals(true, map.get(els[i]).contains(Integer.valueOf((String) els[i])));\n+            assertEquals(true, map.get((K) els[i]).contains(Integer.valueOf((String) els[i])));\n         }\n         assertEquals(true, map.remove(els[0]).contains(Integer.valueOf((String) els[0])));\n     }\n                         null,\n                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n-        assertEquals(true, trans.get(\"A\").contains(\"1\"));\n-        assertEquals(true, trans.get(\"B\").contains(\"2\"));\n-        assertEquals(true, trans.get(\"C\").contains(\"3\"));\n+        assertEquals(true, trans.get((K) \"A\").contains(\"1\"));\n+        assertEquals(true, trans.get((K) \"B\").contains(\"2\"));\n+        assertEquals(true, trans.get((K) \"C\").contains(\"3\"));\n         trans.put((K) \"D\", (V) \"4\");\n-        assertEquals(true, trans.get(\"D\").contains(Integer.valueOf(4)));\n+        assertEquals(true, trans.get((K) \"D\").contains(Integer.valueOf(4)));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n                         null,\n                         (Transformer<? super V, ? extends V>) TransformedCollectionTest.STRING_TO_INTEGER_TRANSFORMER);\n         assertEquals(3, trans.size());\n-        assertEquals(true, trans.get(\"A\").contains(Integer.valueOf(1)));\n-        assertEquals(true, trans.get(\"B\").contains(Integer.valueOf(2)));\n-        assertEquals(true, trans.get(\"C\").contains(Integer.valueOf(3)));\n+        assertEquals(true, trans.get((K) \"A\").contains(Integer.valueOf(1)));\n+        assertEquals(true, trans.get((K) \"B\").contains(Integer.valueOf(2)));\n+        assertEquals(true, trans.get((K) \"C\").contains(Integer.valueOf(3)));\n         trans.put((K) \"D\", (V) \"4\");\n-        assertEquals(true, trans.get(\"D\").contains(Integer.valueOf(4)));\n+        assertEquals(true, trans.get((K) \"D\").contains(Integer.valueOf(4)));\n     }\n \n //    public void testCreate() throws Exception {", "timestamp": 1434220031, "metainfo": ""}