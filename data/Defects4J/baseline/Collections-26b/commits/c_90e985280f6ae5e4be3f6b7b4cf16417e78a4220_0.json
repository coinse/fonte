{"sha": "90e985280f6ae5e4be3f6b7b4cf16417e78a4220", "log": "Small performance improvement bug 22973, from Janek Bogucki Method and Javadoc improvement   ", "commit": "\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.38 2003/09/07 15:09:34 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.39 2003/09/09 21:25:18 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * A set of {@link Collection} related utility methods.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.38 $ $Date: 2003/09/07 15:09:34 $\n+ * @version $Revision: 1.39 $ $Date: 2003/09/09 21:25:18 $\n  * \n  * @author Rodney Waldhoff\n  * @author Paul Jack\n  */\n public class CollectionUtils {\n \n+\t/** Constant to avoid repeated object creation */\n+    private static Integer INTEGER_ONE = new Integer(1);\n+\n     /**\n      * An empty unmodifiable collection.\n      * The JDK provides empty Set and List implementations which could be used for\n     }\n \n     /**\n-     * Returns a {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n+     * Returns a new {@link Collection} containing <tt><i>a</i> - <i>b</i></tt>.\n      * The cardinality of each element <i>e</i> in the returned {@link Collection}\n      * will be the cardinality of <i>e</i> in <i>a</i> minus the cardinality\n      * of <i>e</i> in <i>b</i>, or zero, whichever is greater.\n      *\n+     * @param a  the collection to subtract from, must not be null\n+     * @param b  the collection to subtract, must not be null\n+     * @return a new collection with the results\n      * @see Collection#removeAll\n      */\n     public static Collection subtract(final Collection a, final Collection b) {\n         ArrayList list = new ArrayList( a );\n-        Iterator it =  b.iterator();\n-        while(it.hasNext()) {\n+        for (Iterator it = b.iterator(); it.hasNext();) {\n             list.remove(it.next());\n         }\n         return list;\n     }\n \n     /**\n-     * Returns <code>true</code> iff some element of <i>a</i>\n-     * is also an element of <i>b</i> (or, equivalently, if \n-     * some element of <i>b</i> is also an element of <i>a</i>).\n-     * In other words, this method returns <code>true</code>\n-     * iff the {@link #intersection} of <i>a</i> and <i>b</i>\n-     * is not empty.\n+     * Returns <code>true</code> iff at least one element is in both collections.\n+     * <p>\n+     * In other words, this method returns <code>true</code> iff the\n+     * {@link #intersection} of <i>coll1</i> and <i>coll2</i> is not empty.\n+     * \n+     * @param coll1  the first collection, must not be null\n+     * @param coll2  the first collection, must not be null\n+     * @return <code>true</code> iff the intersection of the collections is non-empty\n      * @since 2.1\n-     * @param a a non-<code>null</code> Collection\n-     * @param b a non-<code>null</code> Collection\n-     * @return <code>true</code> iff the intersection of <i>a</i> and <i>b</i> is non-empty\n      * @see #intersection\n      */\n-    public static boolean containsAny(final Collection a, final Collection b) {\n-        // TO DO: we may be able to optimize this by ensuring either a or b\n-        // is the larger of the two Collections, but I'm not sure which.\n-        for(Iterator iter = a.iterator(); iter.hasNext();) {\n-            if(b.contains(iter.next())) {\n-                return true;\n+    public static boolean containsAny(final Collection coll1, final Collection coll2) {\n+        if (coll1.size() > coll2.size()) {\n+            for (Iterator it = coll1.iterator(); it.hasNext();) {\n+                if (coll2.contains(it.next())) {\n+                    return true;\n+                }\n+            }\n+        } else {\n+            for (Iterator it = coll2.iterator(); it.hasNext();) {\n+                if (coll1.contains(it.next())) {\n+                    return true;\n+                }\n             }\n         }\n         return false;\n     }\n \n     /**\n-     * Returns a {@link Map} mapping each unique element in\n-     * the given {@link Collection} to an {@link Integer}\n-     * representing the number of occurences of that element\n-     * in the {@link Collection}.\n-     * An entry that maps to <tt>null</tt> indicates that the\n-     * element does not appear in the given {@link Collection}.\n-     */\n-    public static Map getCardinalityMap(final Collection col) {\n-        HashMap count = new HashMap();\n-        Iterator it = col.iterator();\n-        while(it.hasNext()) {\n+     * Returns a {@link Map} mapping each unique element in the given\n+     * {@link Collection} to an {@link Integer} representing the number\n+     * of occurences of that element in the {@link Collection}.\n+     * <p>\n+     * Only those elements present in the collection will appear as\n+     * keys in the map.\n+     * \n+     * @param coll  the collection to get the cardinality map for\n+     * @return the populated cardinality map\n+     */\n+    public static Map getCardinalityMap(final Collection coll) {\n+        Map count = new HashMap();\n+        for (Iterator it = coll.iterator(); it.hasNext();) {\n             Object obj = it.next();\n-            Integer c = (Integer)(count.get(obj));\n-            if(null == c) {\n-                count.put(obj,new Integer(1));\n+            Integer c = (Integer) (count.get(obj));\n+            if (c == null) {\n+                count.put(obj,INTEGER_ONE);\n             } else {\n                 count.put(obj,new Integer(c.intValue() + 1));\n             }", "timestamp": 1063142718, "metainfo": ""}