{"sha": "578a598fa7055331c267546b8412f14094192972", "log": "Renamed unit tests for bidimap and splitmap package.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+import org.apache.commons.collections.map.AbstractTestIterableMap;\n+\n+/**\n+ * Abstract test class for {@link BidiMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractBidiMapTest<K, V> extends AbstractTestIterableMap<K, V> {\n+\n+    public AbstractBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractBidiMapTest() {\n+        super(\"Inverse\");\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override to create a full <code>BidiMap</code> other than the default.\n+     *\n+     * @return a full <code>BidiMap</code> implementation.\n+     */\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        return (BidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    /**\n+     * Override to return the empty BidiMap.\n+     */\n+    @Override\n+    public abstract BidiMap<K, V> makeObject();\n+\n+    /**\n+     * Override to indicate to AbstractTestMap this is a BidiMap.\n+     */\n+    @Override\n+    public boolean isAllowDuplicateValues() {\n+        return false;\n+    }\n+\n+    /**\n+     * Override as DualHashBidiMap didn't exist until version 3.\n+     */\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3\";\n+    }\n+\n+    // BidiPut\n+    //-----------------------------------------------------------------------\n+    @SuppressWarnings(\"unchecked\")\n+    public void testBidiPut() {\n+        if (isPutAddSupported() == false || isPutChangeSupported() == false) return;\n+\n+        BidiMap<K, V> map = makeObject();\n+        BidiMap<V, K> inverse = map.inverseBidiMap();\n+        assertEquals(0, map.size());\n+        assertEquals(map.size(), inverse.size());\n+\n+        map.put((K) \"A\", (V) \"B\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"B\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"B\"));\n+\n+        map.put((K) \"A\", (V) \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"A\"));\n+        assertEquals(\"A\", inverse.get(\"C\"));\n+\n+        map.put((K) \"B\", (V) \"C\");\n+        assertEquals(1, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"C\", map.get(\"B\"));\n+        assertEquals(\"B\", inverse.get(\"C\"));\n+\n+        map.put((K) \"E\", (V) \"F\");\n+        assertEquals(2, map.size());\n+        assertEquals(map.size(), inverse.size());\n+        assertEquals(\"F\", map.get(\"E\"));\n+        assertEquals(\"E\", inverse.get(\"F\"));\n+    }\n+\n+    /**\n+     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     * <p>\n+     * This implementation checks the inverse map as well.\n+     */\n+    @Override\n+    public void verify() {\n+        verifyInverse();\n+        super.verify();\n+    }\n+\n+    public void verifyInverse() {\n+        assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());\n+        Map<K, V> map1 = new HashMap<K, V>(map);\n+        Map<V, K> map2 = new HashMap<V, K>(((BidiMap<K, V>) map).inverseBidiMap());\n+        Set<K> keys1 = map1.keySet();\n+        Set<V> keys2 = map2.keySet();\n+        Collection<V> values1 = map1.values();\n+        Collection<K> values2 = map2.values();\n+        assertEquals(true, keys1.containsAll(values2));\n+        assertEquals(true, values2.containsAll(keys1));\n+        assertEquals(true, values1.containsAll(keys2));\n+        assertEquals(true, keys2.containsAll(values1));\n+    }\n+\n+    // testGetKey\n+    //-----------------------------------------------------------------------\n+    public void testBidiGetKey() {\n+        doTestGetKey(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+    }\n+\n+    public void testBidiGetKeyInverse() {\n+        doTestGetKey(\n+            makeFullMap().inverseBidiMap(),\n+            getSampleValues()[0],\n+            getSampleKeys()[0]);\n+    }\n+\n+    private final void doTestGetKey(BidiMap<?, ?> map, Object key, Object value) {\n+        assertEquals(\"Value not found for key.\", value, map.get(key));\n+        assertEquals(\"Key not found for value.\", key, map.getKey(value));\n+    }\n+\n+    // testInverse\n+    //-----------------------------------------------------------------------\n+    public void testBidiInverse() {\n+        final BidiMap<K, V> map = makeFullMap();\n+        final BidiMap<V, K> inverseMap = map.inverseBidiMap();\n+\n+        assertSame(\n+            \"Inverse of inverse is not equal to original.\",\n+            map,\n+            inverseMap.inverseBidiMap());\n+\n+        assertEquals(\n+            \"Value not found for key.\",\n+            getSampleKeys()[0],\n+            inverseMap.get(getSampleValues()[0]));\n+\n+        assertEquals(\n+            \"Key not found for value.\",\n+            getSampleValues()[0],\n+            inverseMap.getKey(getSampleKeys()[0]));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiModifyEntrySet() {\n+        if (isSetValueSupported() == false) return;\n+\n+        modifyEntrySet(makeFullMap());\n+        modifyEntrySet(makeFullMap().inverseBidiMap());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private final <T> void modifyEntrySet(BidiMap<?, T> map) {\n+        // Gets first entry\n+        final Map.Entry<?, T> entry = map.entrySet().iterator().next();\n+\n+        // Gets key and value\n+        final Object key = entry.getKey();\n+        final Object oldValue = entry.getValue();\n+\n+        // Sets new value\n+        final Object newValue = \"newValue\";\n+        entry.setValue((T) newValue);\n+\n+        assertEquals(\n+            \"Modifying entrySet did not affect underlying Map.\",\n+            newValue,\n+            map.get(key));\n+\n+        assertNull(\n+            \"Modifying entrySet did not affect inverse Map.\",\n+            map.getKey(oldValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClear() {\n+        if (isRemoveSupported() == false) {\n+            try {\n+                makeFullMap().clear();\n+                fail();\n+            } catch(UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        BidiMap<?, ?> map = makeFullMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+        // Tests clear on inverse\n+        map = makeFullMap().inverseBidiMap();\n+        map.clear();\n+        assertTrue(\"Map was not cleared.\", map.isEmpty());\n+        assertTrue(\"Inverse map was not cleared.\", map.inverseBidiMap().isEmpty());\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemove() {\n+        if (isRemoveSupported() == false) {\n+            try {\n+                makeFullMap().remove(getSampleKeys()[0]);\n+                fail();\n+            } catch(UnsupportedOperationException ex) {}\n+            try {\n+                makeFullMap().removeValue(getSampleValues()[0]);\n+                fail();\n+            } catch(UnsupportedOperationException ex) {}\n+            return;\n+        }\n+\n+        remove(makeFullMap(), getSampleKeys()[0]);\n+        remove(makeFullMap().inverseBidiMap(), getSampleValues()[0]);\n+\n+        removeValue(makeFullMap(), getSampleValues()[0]);\n+        removeValue(makeFullMap().inverseBidiMap(), getSampleKeys()[0]);\n+\n+        assertEquals(null, makeFullMap().removeValue(\"NotPresent\"));\n+    }\n+\n+    private final void remove(BidiMap<?, ?> map, Object key) {\n+        final Object value = map.remove(key);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    private final void removeValue(BidiMap<?, ?> map, Object value) {\n+        final Object key = map.removeValue(value);\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertNull(\"Value was not removed.\", map.getKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiKeySetValuesOrder() {\n+        resetFull();\n+        Iterator<K> keys = map.keySet().iterator();\n+        Iterator<V> values = map.values().iterator();\n+        for (; keys.hasNext() && values.hasNext();) {\n+            K key = keys.next();\n+            V value = values.next();\n+            assertSame(map.get(key), value);\n+        }\n+        assertEquals(false, keys.hasNext());\n+        assertEquals(false, values.hasNext());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByKeySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+        removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n+    }\n+\n+    private final void removeByKeySet(BidiMap<?, ?> map, Object key, Object value) {\n+        map.keySet().remove(key);\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n+        removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n+    }\n+\n+    private final void removeByEntrySet(BidiMap<?, ?> map, Object key, Object value) {\n+        Map<Object, Object> temp = new HashMap<Object, Object>();\n+        temp.put(key, value);\n+        map.entrySet().remove(temp.entrySet().iterator().next());\n+\n+        assertTrue(\"Key was not removed.\", !map.containsKey(key));\n+        assertTrue(\"Value was not removed.\", !map.containsValue(value));\n+\n+        assertTrue(\n+            \"Key was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsValue(key));\n+        assertTrue(\n+            \"Value was not removed from inverse map.\",\n+            !map.inverseBidiMap().containsKey(value));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public BidiMap<K, V> getMap() {\n+        return (BidiMap<K, V>) super.getMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestBidiMapEntrySet();\n+    }\n+\n+    public class TestBidiMapEntrySet extends TestMapEntrySet {\n+        public TestBidiMapEntrySet() {\n+            super();\n+        }\n+        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n+            K key1 = getSampleKeys()[0];\n+            K key2 = getSampleKeys()[1];\n+            V newValue1 = getNewSampleValues()[0];\n+            V newValue2 = getNewSampleValues()[1];\n+\n+            resetFull();\n+            // explicitly get entries as sample values/keys are connected for some maps\n+            // such as BeanMap\n+            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry1 = getEntry(it, key1);\n+            it = TestBidiMapEntrySet.this.getCollection().iterator();\n+            Map.Entry<K, V> entry2 = getEntry(it, key2);\n+            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n+            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n+            Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n+            TestBidiMapEntrySet.this.verify();\n+\n+            if (isSetValueSupported() == false) {\n+                try {\n+                    entry1.setValue(newValue1);\n+                } catch (UnsupportedOperationException ex) {\n+                }\n+                return;\n+            }\n+\n+            // these checked in superclass\n+            entry1.setValue(newValue1);\n+            entryConfirmed1.setValue(newValue1);\n+            entry2.setValue(newValue2);\n+            entryConfirmed2.setValue(newValue2);\n+\n+            // at this point\n+            // key1=newValue1, key2=newValue2\n+            try {\n+                entry2.setValue(newValue1);  // should remove key1\n+            } catch (IllegalArgumentException ex) {\n+                return;  // simplest way of dealing with tricky situation\n+            }\n+            entryConfirmed2.setValue(newValue1);\n+            AbstractBidiMapTest.this.getConfirmed().remove(key1);\n+            assertEquals(newValue1, entry2.getValue());\n+            assertEquals(true, AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));\n+            assertEquals(true, AbstractBidiMapTest.this.getMap().containsValue(newValue1));\n+            assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));\n+            assertEquals(false, AbstractBidiMapTest.this.getMap().containsKey(key1));\n+            assertEquals(false, AbstractBidiMapTest.this.getMap().containsValue(newValue2));\n+            TestBidiMapEntrySet.this.verify();\n+\n+            // check for ConcurrentModification\n+            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+            if (isRemoveSupported()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    public BulkTest bulkTestInverseMap() {\n+        return new TestInverseBidiMap(this);\n+    }\n+\n+    public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {\n+        final AbstractBidiMapTest<K, V> main;\n+\n+        public TestInverseBidiMap(AbstractBidiMapTest<K, V> main) {\n+            super();\n+            this.main = main;\n+        }\n+\n+        @Override\n+        public BidiMap<V, K> makeObject() {\n+            return main.makeObject().inverseBidiMap();\n+        }\n+\n+        @Override\n+        public BidiMap<V, K> makeFullMap() {\n+            return main.makeFullMap().inverseBidiMap();\n+        }\n+\n+        @Override\n+        public V[] getSampleKeys() {\n+            return main.getSampleValues();\n+        }\n+        @Override\n+        public K[] getSampleValues() {\n+            return main.getSampleKeys();\n+        }\n+\n+        @Override\n+        public String getCompatibilityVersion() {\n+            return main.getCompatibilityVersion();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullKey() {\n+            return main.isAllowNullKey();\n+        }\n+\n+        @Override\n+        public boolean isAllowNullValue() {\n+            return main.isAllowNullValue();\n+        }\n+\n+        @Override\n+        public boolean isPutAddSupported() {\n+            return main.isPutAddSupported();\n+        }\n+\n+        @Override\n+        public boolean isPutChangeSupported() {\n+            return main.isPutChangeSupported();\n+        }\n+\n+        @Override\n+        public boolean isSetValueSupported() {\n+            return main.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public boolean isRemoveSupported() {\n+            return main.isRemoveSupported();\n+        }\n+\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestBidiMapIterator() {\n+        return new TestBidiMapIterator();\n+    }\n+\n+    public class TestBidiMapIterator extends AbstractTestMapIterator<K, V> {\n+        public TestBidiMapIterator() {\n+            super(\"TestBidiMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractBidiMapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractBidiMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractBidiMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public BidiMap<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractBidiMapTest.this.getMap();\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractBidiMapTest.this.getConfirmed();\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractBidiMapTest.this.verify();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiMapIteratorSet() {\n+        V newValue1 = getOtherValues()[0];\n+        V newValue2 = getOtherValues()[1];\n+\n+        resetFull();\n+        BidiMap<K, V> bidi = getMap();\n+        MapIterator<K, V> it = bidi.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        K key1 = it.next();\n+\n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+\n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+\n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(key1));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(key1));\n+        verify();\n+\n+        K key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, bidi.containsKey(key2));\n+        assertEquals(true, bidi.containsValue(newValue2));\n+        assertEquals(newValue2, bidi.get(key2));\n+        verify();\n+\n+        // at this point\n+        // key1=newValue1, key2=newValue2\n+        try {\n+            it.setValue(newValue1);  // should remove key1\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            return;  // simplest way of dealing with tricky situation\n+        }\n+        confirmed.put(key2, newValue1);\n+        AbstractBidiMapTest.this.getConfirmed().remove(key1);\n+        assertEquals(newValue1, it.getValue());\n+        assertEquals(true, bidi.containsKey(it.getKey()));\n+        assertEquals(true, bidi.containsValue(newValue1));\n+        assertEquals(newValue1, bidi.get(it.getKey()));\n+        assertEquals(false, bidi.containsKey(key1));\n+        assertEquals(false, bidi.containsValue(newValue2));\n+        verify();\n+\n+        // check for ConcurrentModification\n+        it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n+        if (isRemoveSupported()) {\n+            it.remove();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapDecoratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.collections.OrderedBidiMap;\n+\n+/**\n+ * Test class for AbstractOrderedBidiMapDecorator.\n+ *\n+ * @version $Id$\n+ */\n+public class AbstractOrderedBidiMapDecoratorTest<K, V>\n+        extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    public AbstractOrderedBidiMapDecoratorTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return new TestOrderedBidiMap<K, V>();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isSetValueSupported() {\n+        return true;\n+    }\n+\n+    /**\n+     * Simple class to actually test.\n+     */\n+    private static final class TestOrderedBidiMap<K, V> extends AbstractOrderedBidiMapDecorator<K, V> {\n+\n+        private TestOrderedBidiMap<V, K> inverse = null;\n+\n+        public TestOrderedBidiMap() {\n+            super(new DualTreeBidiMap<K, V>());\n+        }\n+\n+        public TestOrderedBidiMap(OrderedBidiMap<K, V> map) {\n+            super(map);\n+        }\n+\n+        @Override\n+        public OrderedBidiMap<V, K> inverseBidiMap() {\n+            if (inverse == null) {\n+                inverse = new TestOrderedBidiMap<V, K>(decorated().inverseBidiMap());\n+                inverse.inverse = this;\n+            }\n+            return inverse;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractOrderedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.OrderedBidiMap;\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+\n+/**\n+ * Abstract test class for {@link OrderedBidiMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractOrderedBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public AbstractOrderedBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public AbstractOrderedBidiMapTest() {\n+        super();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testFirstKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        try {\n+            bidi.firstKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedFirst = confirmed.keySet().iterator().next();\n+        assertEquals(confirmedFirst, bidi.firstKey());\n+    }\n+\n+    public void testLastKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        try {\n+            bidi.lastKey();\n+            fail();\n+        } catch (NoSuchElementException ex) {}\n+\n+        resetFull();\n+        bidi = getMap();\n+        K confirmedLast = null;\n+        for (Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n+            confirmedLast = it.next();\n+        }\n+        assertEquals(confirmedLast, bidi.lastKey());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testNextKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;\n+        assertEquals(null, bidi.nextKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.nextKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+\n+        resetFull();\n+        bidi = (OrderedBidiMap<K, V>) map;\n+        Iterator<K> it = confirmed.keySet().iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.nextKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.nextKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.nextKey(null));\n+        }\n+    }\n+\n+    public void testPreviousKey() {\n+        resetEmpty();\n+        OrderedBidiMap<K, V> bidi = getMap();\n+        assertEquals(null, bidi.previousKey(getOtherKeys()[0]));\n+        if (isAllowNullKey() == false) {\n+            try {\n+                assertEquals(null, bidi.previousKey(null)); // this is allowed too\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+\n+        resetFull();\n+        bidi = getMap();\n+        List<K> list = new ArrayList<K>(confirmed.keySet());\n+        Collections.reverse(list);\n+        Iterator<K> it = list.iterator();\n+        K confirmedLast = it.next();\n+        while (it.hasNext()) {\n+            K confirmedObject = it.next();\n+            assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n+            confirmedLast = confirmedObject;\n+        }\n+        assertEquals(null, bidi.previousKey(confirmedLast));\n+\n+        if (isAllowNullKey() == false) {\n+            try {\n+                bidi.previousKey(null);\n+                fail();\n+            } catch (NullPointerException ex) {}\n+        } else {\n+            assertEquals(null, bidi.previousKey(null));\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestOrderedMapIterator() {\n+        return new TestBidiOrderedMapIterator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedBidiMap<K, V> getMap() {\n+        return (OrderedBidiMap<K, V>) super.getMap();\n+    }\n+\n+    public class TestBidiOrderedMapIterator extends AbstractTestMapIterator<K, V> {\n+        public TestBidiOrderedMapIterator() {\n+            super(\"TestBidiOrderedMapIterator\");\n+        }\n+\n+        @Override\n+        public V[] addSetValues() {\n+            return AbstractOrderedBidiMapTest.this.getNewSampleValues();\n+        }\n+\n+        @Override\n+        public boolean supportsRemove() {\n+            return AbstractOrderedBidiMapTest.this.isRemoveSupported();\n+        }\n+\n+        @Override\n+        public boolean supportsSetValue() {\n+            return AbstractOrderedBidiMapTest.this.isSetValueSupported();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeEmptyIterator() {\n+            resetEmpty();\n+            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public MapIterator<K, V> makeObject() {\n+            resetFull();\n+            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n+        }\n+\n+        @Override\n+        public Map<K, V> getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedBidiMapTest.this.map;\n+        }\n+\n+        @Override\n+        public Map<K, V> getConfirmedMap() {\n+            // assumes makeFullMapIterator() called first\n+            return AbstractOrderedBidiMapTest.this.confirmed;\n+        }\n+\n+        @Override\n+        public void verify() {\n+            super.verify();\n+            AbstractOrderedBidiMapTest.this.verify();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/AbstractSortedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.SortedBidiMap;\n+import org.apache.commons.collections.map.AbstractTestSortedMap;\n+\n+/**\n+ * Abstract test class for {@link SortedBidiMap} methods and contracts.\n+ *\n+ * @version $Id$\n+ */\n+public abstract class AbstractSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    protected List<K> sortedKeys;\n+    protected List<V> sortedValues = new ArrayList<V>();\n+    protected SortedSet<V> sortedNewValues = new TreeSet<V>();\n+\n+    public AbstractSortedBidiMapTest(String testName) {\n+        super(testName);\n+        sortedKeys = getAsList(getSampleKeys());\n+        Collections.sort(sortedKeys);\n+        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+\n+        Map<K, V> map = new TreeMap<K, V>();\n+        addSampleMappings(map);\n+\n+        sortedValues.addAll(map.values());\n+        sortedValues = Collections.unmodifiableList(sortedValues);\n+\n+        sortedNewValues.addAll(this.<V> getAsList(getNewSampleValues()));\n+    }\n+\n+//    public AbstractTestSortedBidiMap() {\n+//        super();\n+//        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n+//        Collections.sort(sortedKeys);\n+//        sortedKeys = Collections.unmodifiableList(sortedKeys);\n+//\n+//        Map map = new TreeMap();\n+//        for (int i = 0; i < getSampleKeys().length; i++) {\n+//            map.put(getSampleValues()[i], getSampleKeys()[i]);\n+//        }\n+//        sortedValues.addAll(map.values());\n+//        sortedValues = Collections.unmodifiableList(sortedValues);\n+//\n+//        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n+//    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract SortedBidiMap<K, V> makeObject();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        return (SortedBidiMap<K, V>) super.makeFullMap();\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiHeadMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K toKey = it.next();\n+        K second = it.next();\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> head = sm.headMap(toKey);\n+        assertEquals(1, head.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, head.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, head.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(false, head.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(false, head.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByHeadMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+        V toKeyValue = sm.get(toKey);\n+\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        int size = sm.size();\n+        assertEquals(2, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+\n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        V firstValue = sub.remove(first);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        V secondValue = sub.remove(second);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByHeadMapEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.headMap(toKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        assertEquals(2, sub.size());\n+        assertEquals(2, set.size());\n+\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiTailMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        assertEquals(sm.size() - 1, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearByTailMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        int size = sm.size();\n+        assertEquals(size - 3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(3, sm.size());\n+        assertEquals(3, sm.inverseBidiMap().size());\n+\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        Object firstValue = sub.remove(first);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        Object secondValue = sub.remove(second);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveByTailMapEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.tailMap(fromKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(size - 3, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(size - 4, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    //-----------------------------------------------------------------------\n+    public void testBidiSubMapContains() {\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        K first = it.next();\n+        K fromKey = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+        K third = it.next();\n+        V firstValue = sm.get(first);\n+        V fromKeyValue = sm.get(fromKey);\n+        V secondValue = sm.get(second);\n+        V thirdValue = sm.get(third);\n+\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        assertEquals(2, sub.size());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(true, sm.containsValue(firstValue));\n+        assertEquals(false, sub.containsValue(firstValue));\n+        assertEquals(true, sm.containsKey(fromKey));\n+        assertEquals(true, sub.containsKey(fromKey));\n+        assertEquals(true, sm.containsValue(fromKeyValue));\n+        assertEquals(true, sub.containsValue(fromKeyValue));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, sm.containsValue(secondValue));\n+        assertEquals(true, sub.containsValue(secondValue));\n+        assertEquals(true, sm.containsKey(third));\n+        assertEquals(false, sub.containsKey(third));\n+        assertEquals(true, sm.containsValue(thirdValue));\n+        assertEquals(false, sub.containsValue(thirdValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiClearBySubMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        V fromKeyValue = sm.get(fromKey);\n+        V firstValue = sm.get(first);\n+        V secondValue = sm.get(second);\n+        V toKeyValue = sm.get(toKey);\n+\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        int size = sm.size();\n+        assertEquals(3, sub.size());\n+        sub.clear();\n+        assertEquals(0, sub.size());\n+        assertEquals(size - 3, sm.size());\n+        assertEquals(size - 3, sm.inverseBidiMap().size());\n+\n+        assertEquals(false, sm.containsKey(fromKey));\n+        assertEquals(false, sm.containsValue(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(fromKeyValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(fromKey));\n+        assertEquals(false, sub.containsKey(fromKey));\n+        assertEquals(false, sub.containsValue(fromKeyValue));\n+\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+\n+        assertEquals(true, sm.containsKey(toKey));\n+        assertEquals(true, sm.containsValue(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsKey(toKeyValue));\n+        assertEquals(true, sm.inverseBidiMap().containsValue(toKey));\n+        assertEquals(false, sub.containsKey(toKey));\n+        assertEquals(false, sub.containsValue(toKeyValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMap() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+\n+        V firstValue = sub.remove(first);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(first));\n+        assertEquals(false, sm.containsValue(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(first));\n+        assertEquals(false, sub.containsKey(first));\n+        assertEquals(false, sub.containsValue(firstValue));\n+\n+        V secondValue = sub.remove(second);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(second));\n+        assertEquals(false, sm.containsValue(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondValue));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(second));\n+        assertEquals(false, sub.containsKey(second));\n+        assertEquals(false, sub.containsValue(secondValue));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testBidiRemoveBySubMapEntrySet() {\n+        if (isRemoveSupported() == false) return;\n+\n+        // extra test as other tests get complex\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+        Iterator<K> it = sm.keySet().iterator();\n+        it.next();\n+        it.next();\n+        K fromKey = it.next();\n+        K first = it.next();\n+        K second = it.next();\n+        K toKey = it.next();\n+\n+        int size = sm.size();\n+        SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n+        Set<Map.Entry<K, V>> set = sub.entrySet();\n+        assertEquals(3, set.size());\n+        Iterator<Map.Entry<K, V>> it2 = set.iterator();\n+        it2.next();\n+        Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n+        Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n+        assertEquals(true, sm.containsKey(first));\n+        assertEquals(true, sub.containsKey(first));\n+        assertEquals(true, set.contains(firstEntry));\n+        assertEquals(true, sm.containsKey(second));\n+        assertEquals(true, sub.containsKey(second));\n+        assertEquals(true, set.contains(secondEntry));\n+\n+        set.remove(firstEntry);\n+        assertEquals(2, sub.size());\n+        assertEquals(size - 1, sm.size());\n+        assertEquals(size - 1, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sm.containsValue(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n+        assertEquals(false, sub.containsKey(firstEntry.getKey()));\n+        assertEquals(false, sub.containsValue(firstEntry.getValue()));\n+        assertEquals(false, set.contains(firstEntry));\n+\n+        set.remove(secondEntry);\n+        assertEquals(1, sub.size());\n+        assertEquals(size - 2, sm.size());\n+        assertEquals(size - 2, sm.inverseBidiMap().size());\n+        assertEquals(false, sm.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sm.containsValue(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n+        assertEquals(false, sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n+        assertEquals(false, sub.containsKey(secondEntry.getKey()));\n+        assertEquals(false, sub.containsValue(secondEntry.getValue()));\n+        assertEquals(false, set.contains(secondEntry));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestHeadMap() {\n+        return new AbstractTestSortedMap.TestHeadMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestTailMap() {\n+        return new AbstractTestSortedMap.TestTailMap<K, V>(this);\n+    }\n+\n+    public BulkTest bulkTestSubMap() {\n+        return new AbstractTestSortedMap.TestSubMap<K, V>(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/DualHashBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class DualHashBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualHashBidiMapTest.class);\n+    }\n+\n+    public DualHashBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualHashBidiMap<K, V> makeObject() {\n+        return new DualHashBidiMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] { \"DualHashBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\" };\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualHashBidiMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualHashBidiMap.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/DualTreeBidiMap2Test.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.SortedBidiMap;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class DualTreeBidiMap2Test<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualTreeBidiMap2Test.class);\n+    }\n+\n+    public DualTreeBidiMap2Test(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>(\n+                new ReverseComparator<K>(ComparableComparator.<K> comparableComparator()),\n+                new ReverseComparator<V>(ComparableComparator.<V> comparableComparator()));\n+    }\n+\n+    @Override\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>(new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n+    }\n+\n+    public void testComparator() {\n+        resetEmpty();\n+        SortedBidiMap<K, V> bidi = (SortedBidiMap<K, V>) map;\n+        assertNotNull(bidi.comparator());\n+        assertTrue(bidi.comparator() instanceof ReverseComparator);\n+    }\n+\n+    public void testComparator2() {\n+        DualTreeBidiMap<String, Integer> dtbm = new DualTreeBidiMap<String, Integer>(\n+                String.CASE_INSENSITIVE_ORDER, null);\n+        dtbm.put(\"two\", 0);\n+        dtbm.put(\"one\", 1);\n+        assertEquals(\"one\", dtbm.firstKey());\n+        assertEquals(\"two\", dtbm.lastKey());\n+        \n+    }\n+\n+    public void testSerializeDeserializeCheckComparator() throws Exception {\n+        SortedBidiMap<?, ?> obj = makeObject();\n+        if (obj instanceof Serializable && isTestSerialization()) {\n+            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+            ObjectOutputStream out = new ObjectOutputStream(buffer);\n+            out.writeObject(obj);\n+            out.close();\n+\n+            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+            Object dest = in.readObject();\n+            in.close();\n+\n+            SortedBidiMap<?,?> bidi = (SortedBidiMap<?,?>) dest;\n+            assertNotNull(obj.comparator());\n+            assertNotNull(bidi.comparator());\n+            assertTrue(bidi.comparator() instanceof ReverseComparator);\n+        }\n+    }\n+\n+    private static class IntegerComparator implements Comparator<Integer>, java.io.Serializable{\n+        private static final long serialVersionUID = 1L;\n+        public int compare(Integer o1, Integer o2) {\n+            return o1.compareTo(o2);\n+        }\n+    }\n+\n+    public void testCollections364() throws Exception {\n+        DualTreeBidiMap<String, Integer> original = new DualTreeBidiMap<String, Integer>(\n+                String.CASE_INSENSITIVE_ORDER, new IntegerComparator());\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        ObjectOutputStream out = new ObjectOutputStream(buffer);\n+        out.writeObject(original);\n+        out.close();\n+\n+        ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n+        @SuppressWarnings(\"unchecked\")\n+        DualTreeBidiMap<String, Integer> deserialised = (DualTreeBidiMap<String, Integer>) in.readObject();\n+        in.close();\n+\n+        assertNotNull(original.comparator());\n+        assertNotNull(deserialised.comparator());\n+        assertEquals(original.comparator().getClass(), deserialised.comparator().getClass());\n+        assertEquals(original.valueComparator().getClass(), deserialised.valueComparator().getClass());\n+    }\n+\n+    public void testSortOrder() throws Exception {\n+        SortedBidiMap<K, V> sm = makeFullMap();\n+\n+        // Sort by the comparator used in the makeEmptyBidiMap() method\n+        List<K> newSortedKeys = getAsList(getSampleKeys());\n+        Collections.sort(newSortedKeys, new ReverseComparator<K>(ComparableComparator.<K>comparableComparator()));\n+        newSortedKeys = Collections.unmodifiableList(newSortedKeys);\n+\n+        Iterator<K> mapIter = sm.keySet().iterator();\n+        Iterator<K> expectedIter = newSortedKeys.iterator();\n+        while (expectedIter.hasNext()) {\n+            K expectedKey = expectedIter.next();\n+            K mapKey = mapIter.next();\n+            assertNotNull(\"key in sorted list may not be null\", expectedKey);\n+            assertNotNull(\"key in map may not be null\", mapKey);\n+            assertEquals(\"key from sorted list and map must be equal\", expectedKey, mapKey);\n+        }\n+    }\n+\n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.Test2\";\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"DualTreeBidiMap2Test.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.emptyCollection.version3.Test2.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.fullCollection.version3.Test2.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/DualTreeBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class DualTreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(DualTreeBidiMapTest.class);\n+    }\n+\n+    public DualTreeBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public DualTreeBidiMap<K, V> makeObject() {\n+        return new DualTreeBidiMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"DualTreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.emptyCollection.version3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/DualTreeBidiMap.fullCollection.version3.obj\");\n+//    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/TreeBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class TreeBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TreeBidiMapTest.class);\n+    }\n+\n+    public TreeBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeObject() {\n+        return new TreeBidiMap<K, V>();\n+    }\n+    \n+    @Override\n+    public TreeMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"TreeBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+    \n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public boolean isSetValueSupported() {\n+        return false;\n+    }\n+    \n+    @Override\n+    public String getCompatibilityVersion() {\n+        return \"3.3\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/TreeBidiMap.emptyCollection.version3.3.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk((java.io.Serializable) map, \"/tmp/TreeBidiMap.fullCollection.version3.3.obj\");\n+//    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableBidiMapTest.class);\n+    }\n+\n+    public UnmodifiableBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeObject() {\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(new DualHashBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        BidiMap<K, V> bidi = new DualHashBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableBidiMap.unmodifiableBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new HashMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"UnmodifiableBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableOrderedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BidiMap;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.OrderedBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableOrderedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableOrderedBidiMapTest.class);\n+    }\n+\n+    public UnmodifiableOrderedBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public OrderedBidiMap<K, V> makeObject() {\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(new TreeBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public BidiMap<K, V> makeFullMap() {\n+        OrderedBidiMap<K, V> bidi = new TreeBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableOrderedBidiMap.unmodifiableOrderedBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public Map<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    /**\n+     * Override to prevent infinite recursion of tests.\n+     */\n+    @Override\n+    public String[] ignoredTests() {\n+        return new String[] {\"UnmodifiableOrderedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/bidimap/UnmodifiableSortedBidiMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.bidimap;\n+\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import junit.framework.Test;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.SortedBidiMap;\n+\n+/**\n+ * JUnit tests.\n+ *\n+ * @version $Id$\n+ */\n+public class UnmodifiableSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractSortedBidiMapTest<K, V> {\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(UnmodifiableSortedBidiMapTest.class);\n+    }\n+\n+    public UnmodifiableSortedBidiMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public SortedBidiMap<K, V> makeObject() {\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(new DualTreeBidiMap<K, V>());\n+    }\n+\n+    @Override\n+    public SortedBidiMap<K, V> makeFullMap() {\n+        SortedBidiMap<K, V> bidi = new DualTreeBidiMap<K, V>();\n+        addSampleMappings(bidi);\n+        return UnmodifiableSortedBidiMap.unmodifiableSortedBidiMap(bidi);\n+    }\n+\n+    @Override\n+    public SortedMap<K, V> makeConfirmedMap() {\n+        return new TreeMap<K, V>();\n+    }\n+\n+    @Override\n+    public boolean isSubMapViewsSerializable() {\n+        // TreeMap sub map views have a bug in deserialization.\n+        return false;\n+    }\n+\n+    @Override\n+    public String[] ignoredTests() {\n+        // Override to prevent infinite recursion of tests.\n+        return new String[] {\"UnmodifiableSortedBidiMapTest.bulkTestInverseMap.bulkTestInverseMap\"};\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    @Override\n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isAllowNullValue() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutAddSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isPutChangeSupported() {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isRemoveSupported() {\n+        return false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/splitmap/TransformedMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.splitmap;\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.functors.NOPTransformer;\n+\n+/**\n+ * Tests for {@link TransformedMap}\n+ *\n+ * TODO fix version, add Serialization tests\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TransformedMapTest extends BulkTest {\n+\n+    private Transformer<Integer, String> intToString = new Transformer<Integer, String>() {\n+        public String transform(Integer input) {\n+            return String.valueOf(input);\n+        }\n+    };\n+\n+    private Transformer<Object, Class<?>> objectToClass = new Transformer<Object, Class<?>>() {\n+        public java.lang.Class<?> transform(Object input) {\n+            return input == null ? null : input.getClass();\n+        }\n+    };\n+\n+    private Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public TransformedMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testTransformedMap() {\n+        TransformedMap<Integer, String, Object, Class<?>> map = TransformedMap.transformingMap(\n+                new HashMap<String, Class<?>>(), intToString, objectToClass);\n+\n+        Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n+        Object[] v = new Object[] { \"\", new Object(), new HashMap<Object, Object>(), 0, BigInteger.TEN, null,\n+                new Object[0] };\n+\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < k.length; i++) {\n+            map.put(k[i], v[i]);\n+            assertEquals(i + 1, map.size());\n+            assertTrue(map.containsKey(intToString.transform(k[i])));\n+            assertFalse(map.containsKey(k[i]));\n+            assertTrue(map.containsValue(objectToClass.transform(v[i])));\n+            assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));\n+            assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));\n+        }\n+\n+        int sz = map.size();\n+        assertEquals(null, map.remove(k[0]));\n+        assertEquals(sz, map.size());\n+        assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n+        assertEquals(--sz, map.size());\n+\n+        TransformedMap<String, String, String, Integer> map2 = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map2.size());\n+        for (int i = 0; i < 6; i++) {\n+            map2.put(String.valueOf(i), String.valueOf(i));\n+            assertEquals(i + 1, map2.size());\n+            assertTrue(map2.containsValue(i));\n+            assertFalse(map2.containsValue(String.valueOf(i)));\n+            assertTrue(map2.containsKey(String.valueOf(i)));\n+            assertEquals(i, map2.get(String.valueOf(i)).intValue());\n+        }\n+\n+        int sz2 = map2.size();\n+        assertEquals(Integer.valueOf(0), map2.remove(\"0\"));\n+        assertEquals(--sz2, map2.size());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testMapIterator() {\n+        TransformedMap<String, String, String, Integer> map = TransformedMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < 6; i++) {\n+            map.put(String.valueOf(i), String.valueOf(i));\n+        }\n+\n+        for (MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n+            String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(map.get(k), it.getValue());\n+        }\n+    }\n+\n+    public void testEmptyMap() throws IOException, ClassNotFoundException {\n+        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+\n+        ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"/TransformedMap.emptyCollection.version3.2.obj\" ) );\n+        Object readObject = in.readObject();\n+        in.close();\n+\n+        TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        assertTrue( \"Map should be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+\n+    public void testFullMap() throws IOException, ClassNotFoundException {\n+        TransformedMap<String, String, String, String> map = TransformedMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+        map.put( \"a\", \"b\" );\n+        map.put( \"c\", \"d\" );\n+        map.put( \"e\", \"f\" );\n+        map.put( \"g\", \"h\" );\n+\n+        ObjectInputStream in = new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"TransformedMap.fullCollection.version3.2.obj\" ) );\n+        Object readObject = in.readObject();\n+        in.close();\n+\n+        TransformedMap<?, ?, ?, ?> readMap = (TransformedMap<?, ?, ?, ?>) readObject;\n+        assertFalse( \"Map should not be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+//\n+//    public void testCreate() throws IOException {\n+//        TransformedMap<String, String, String, String> map = TransformedMap.decorate(\n+//                new HashMap<String, String>(),\n+//                NOPTransformer.<String>getInstance(),\n+//                NOPTransformer.<String>getInstance() );\n+//\n+//        ObjectOutputStream out = new ObjectOutputStream(\n+//                new FileOutputStream( \"data/test/TransformedMap.emptyCollection.version3.2.obj\" ) );\n+//        out.writeObject( map );\n+//\n+//        map.put( \"a\", \"b\" );\n+//        map.put( \"c\", \"d\" );\n+//        map.put( \"e\", \"f\" );\n+//        map.put( \"g\", \"h\" );\n+//\n+//        out = new ObjectOutputStream(\n+//                new FileOutputStream( \"data/test/TransformedMap.fullCollection.version3.2.obj\" ) );\n+//        out.writeObject( map );\n+//    }\n+}", "timestamp": 1345151265, "metainfo": ""}