{"sha": "c81f67f5a8b757c3505c682ec2b81a757bc95e51", "log": "Generics; fix keys as Strings only  ", "commit": "\n--- a/src/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n  * @author Shinobu Kawai\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n  */\n-public class ExtendedProperties extends Hashtable {\n+public class ExtendedProperties extends Hashtable<String, Object> {\n \n     private static final long serialVersionUID = -4064305575636043822L;\n \n      * you wish to perform operations with configuration\n      * information in a particular order.\n      */\n-    protected ArrayList keysAsListed = new ArrayList();\n+    protected ArrayList<String> keysAsListed = new ArrayList<String>();\n \n     protected final static String START_TOKEN=\"${\";\n     protected final static String END_TOKEN=\"}\";\n      *\n      * @return the string with the interpolation taken care of\n      */\n-    protected String interpolateHelper(String base, List priorVariables) {\n+    protected String interpolateHelper(String base, List<String> priorVariables) {\n         // COPIED from [configuration] 2003-12-29\n         if (base == null) {\n             return null;\n         // on the first call initialize priorVariables\n         // and add base as the first element\n         if (priorVariables == null) {\n-            priorVariables = new ArrayList();\n+            priorVariables = new ArrayList<String>();\n             priorVariables.add(base);\n         }\n \n \n                 // create a nice trace of interpolated variables like so:\n                 // var1->var2->var3\n-                for (Iterator it = priorVariables.iterator(); it.hasNext();) {\n+                for (Iterator<?> it = priorVariables.iterator(); it.hasNext();) {\n                     priorVariableSb.append(it.next());\n                     if (it.hasNext()) {\n                         priorVariableSb.append(\"->\");\n \n         if (current instanceof String) {\n             // one object already in map - convert it to a vector\n-            List values = new Vector(2);\n+            List<Object> values = new Vector<Object>(2);\n             values.add(current);\n             values.add(value);\n             super.put(key, values);\n             \n         } else if (current instanceof List) {\n             // already a list - just add the new token\n-            ((List) current).add(value);\n+            @SuppressWarnings(\"unchecked\") // We only add Strings to the Lists\n+            List<String> list = (List<String>) current;\n+            list.add((String) value);\n             \n         } else {\n             // brand new key - store in keysAsListed to retain order\n             theWrtr.println(header);\n         }\n         \n-        Enumeration theKeys = keys();\n+        Enumeration<String> theKeys = keys();\n         while (theKeys.hasMoreElements()) {\n-            String key = (String) theKeys.nextElement();\n+            String key = theKeys.nextElement();\n             Object value = get(key);\n             if (value != null) {\n                 if (value instanceof String) {\n                     theWrtr.println(currentOutput.toString());\n                     \n                 } else if (value instanceof List) {\n-                    List values = (List) value;\n-                    for (Iterator it = values.iterator(); it.hasNext(); ) {\n-                        String currentElement = (String) it.next();\n+                    @SuppressWarnings(\"unchecked\") // we only add Strings to the Lists\n+                    List<String> values = (List<String>) value;\n+                    for (Iterator<String> it = values.iterator(); it.hasNext(); ) {\n+                        String currentElement = it.next();\n                         StringBuilder currentOutput = new StringBuilder();\n                         currentOutput.append(key);\n                         currentOutput.append(\"=\");\n      * @param props  the properties to combine\n      */\n     public void combine(ExtendedProperties props) {\n-        for (Iterator it = props.getKeys(); it.hasNext();) {\n-            String key = (String) it.next();\n+        for (Iterator<String> it = props.getKeys(); it.hasNext();) {\n+            String key = it.next();\n             clearProperty(key);\n             addPropertyDirect(key, props.get(key));\n         }\n      *\n      * @return an Iterator over the keys\n      */\n-    public Iterator getKeys() {\n+    public Iterator<String> getKeys() {\n         return keysAsListed.iterator();\n     }\n \n      * @param prefix  the prefix to match\n      * @return an Iterator of keys that match the prefix\n      */\n-    public Iterator getKeys(String prefix) {\n-        Iterator keys = getKeys();\n-        ArrayList matchingKeys = new ArrayList();\n+    public Iterator<String> getKeys(String prefix) {\n+        Iterator<String> keys = getKeys();\n+        ArrayList<String> matchingKeys = new ArrayList<String>();\n \n         while (keys.hasNext()) {\n-            Object key = keys.next();\n-\n-            if (key instanceof String && ((String) key).startsWith(prefix)) {\n+            String key = keys.next();\n+            if (key.startsWith(prefix)) {\n                 matchingKeys.add(key);\n             }\n         }\n      *\n      * @param prefix  the prefix to get a subset for\n      * @return a new independent ExtendedProperties\n+     * or {@code null} if no keys matched\n      */\n     public ExtendedProperties subset(String prefix) {\n         ExtendedProperties c = new ExtendedProperties();\n-        Iterator keys = getKeys();\n+        Iterator<String> keys = getKeys();\n         boolean validSubset = false;\n \n         while (keys.hasNext()) {\n-            Object key = keys.next();\n-\n-            if (key instanceof String && ((String) key).startsWith(prefix)) {\n+            String key = keys.next();\n+\n+            if (key.startsWith(prefix)) {\n                 if (!validSubset) {\n                     validSubset = true;\n                 }\n                  * subset but it is a valid subset.\n                  */\n                 String newKey = null;\n-                if (((String) key).length() == prefix.length()) {\n+                if (key.length() == prefix.length()) {\n                     newKey = prefix;\n                 } else {\n-                    newKey = ((String) key).substring(prefix.length() + 1);\n+                    newKey = key.substring(prefix.length() + 1);\n                 }\n \n                 /*\n      * Display the configuration for debugging purposes to System.out.\n      */\n     public void display() {\n-        Iterator i = getKeys();\n+        Iterator<String> i = getKeys();\n \n         while (i.hasNext()) {\n-            String key = (String) i.next();\n+            String key = i.next();\n             Object value = get(key);\n             System.out.println(key + \" => \" + value);\n         }\n                 return interpolate(defaultValue);\n             }\n         } else if (value instanceof List) {\n-            return interpolate((String) ((List) value).get(0));\n+            @SuppressWarnings(\"unchecked\") // Must be OK as we only add Strings to Lists\n+            List<String> entry = (List<String>) value;\n+            return interpolate(entry.get(0));\n         } else {\n             throw new ClassCastException('\\'' + key + \"' doesn't map to a String object\");\n         }\n     public String[] getStringArray(String key) {\n         Object value = get(key);\n \n-        List values;\n+        List<String> values;\n         if (value instanceof String) {\n-            values = new Vector(1);\n-            values.add(value);\n+            values = new Vector<String>(1);\n+            values.add((String) value);\n             \n         } else if (value instanceof List) {\n-            values = (List) value;\n+            @SuppressWarnings(\"unchecked\") // We only add Strings to the Lists\n+            List<String> list = (List<String>) value;\n+            values = list;\n             \n         } else if (value == null) {\n             if (defaults != null) {\n \n         String[] tokens = new String[values.size()];\n         for (int i = 0; i < tokens.length; i++) {\n-            tokens[i] = (String) values.get(i);\n+            tokens[i] = values.get(i);\n         }\n \n         return tokens;\n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Vector.\n      */\n-    public Vector getVector(String key) {\n+    public Vector<String> getVector(String key) {\n         return getVector(key, null);\n     }\n \n      * @throws ClassCastException is thrown if the key maps to an\n      * object that is not a Vector.\n      */\n-    public Vector getVector(String key, Vector defaultValue) {\n+    public Vector<String> getVector(String key, Vector<String> defaultValue) {\n         Object value = get(key);\n \n         if (value instanceof List) {\n-            return new Vector((List) value);\n+            @SuppressWarnings(\"unchecked\") // our lists only contain Strings\n+            List<String> list = (List<String>) value;\n+            return new Vector<String>(list);\n             \n         } else if (value instanceof String) {\n-            Vector values = new Vector(1);\n-            values.add(value);\n+            Vector<String> values = new Vector<String>(1);\n+            values.add((String) value);\n             super.put(key, values);\n             return values;\n             \n             if (defaults != null) {\n                 return defaults.getVector(key, defaultValue);\n             } else {\n-                return ((defaultValue == null) ? new Vector() : defaultValue);\n+                return ((defaultValue == null) ? new Vector<String>() : defaultValue);\n             }\n         } else {\n             throw new ClassCastException('\\'' + key + \"' doesn't map to a Vector object\");\n      * object that is not a List.\n      * @since Commons Collections 3.2\n      */\n-    public List getList(String key) {\n+    public List<String> getList(String key) {\n         return getList(key, null);\n     }\n \n      * object that is not a List.\n      * @since Commons Collections 3.2\n      */\n-    public List getList(String key, List defaultValue) {\n+    public List<String> getList(String key, List<String> defaultValue) {\n         Object value = get(key);\n \n         if (value instanceof List) {\n-            return new ArrayList((List) value);\n+            @SuppressWarnings(\"unchecked\") // our lists only contain strings\n+            List<String> list = (List<String>) value;\n+            return new ArrayList<String>(list);\n             \n         } else if (value instanceof String) {\n-            List values = new ArrayList(1);\n-            values.add(value);\n+            List<String> values = new ArrayList<String>(1);\n+            values.add((String) value);\n             super.put(key, values);\n             return values;\n             \n             if (defaults != null) {\n                 return defaults.getList(key, defaultValue);\n             } else {\n-                return ((defaultValue == null) ? new ArrayList() : defaultValue);\n+                return ((defaultValue == null) ? new ArrayList<String>() : defaultValue);\n             }\n         } else {\n             throw new ClassCastException('\\'' + key + \"' doesn't map to a List object\");\n     public static ExtendedProperties convertProperties(Properties props) {\n         ExtendedProperties c = new ExtendedProperties();\n \n-        for (Enumeration e = props.propertyNames(); e.hasMoreElements();) {\n-            String s = (String) e.nextElement();\n+        for (@SuppressWarnings(\"unchecked\") // Properties are supposed to have string keys ...\n+        Enumeration<String> e = (Enumeration<String>) props.propertyNames(); e.hasMoreElements();) {\n+            String s = e.nextElement(); // ... if props does not, this line would fail anyway ...\n             String value = props.getProperty(s);\n             if(value != null) {\n                 c.setProperty(s, value);\n      * @return old value of the property\n      */\n     @Override\n-    public Object put(Object key, Object value) {\n-        String strKey = String.valueOf(key);\n-        Object ret = getProperty(strKey);\n-        addProperty(strKey, value);\n+    public Object put(String key, Object value) {\n+        Object ret = getProperty(key);\n+        addProperty(key, value);\n         return ret;\n     }\n \n      * @param map full of key/value pair data\n      */\n     @Override\n-    public void putAll(Map map) {\n+    public void putAll(Map<? extends String, ? extends Object> map) {\n         if (map instanceof ExtendedProperties) {\n-            for (Iterator it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n-                Object key = it.next();\n+            for (Iterator<String> it = ((ExtendedProperties) map).getKeys(); it.hasNext(); ) {\n+                String key = it.next();\n                 put(key, map.get(key));\n             }\n         } else {\n-            for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n-                Map.Entry entry = (Map.Entry) it.next();\n+            @SuppressWarnings(\"unchecked\") // OK to downcast here\n+            Map<String, Object> mapso = (Map<String,Object>) map;\n+            for (Iterator<Map.Entry<String, Object>> it = mapso.entrySet().iterator(); it.hasNext(); ) {\n+                Map.Entry<String,Object> entry = it.next();\n                 put(entry.getKey(), entry.getValue());\n             }\n         }", "timestamp": 1287538562, "metainfo": ""}