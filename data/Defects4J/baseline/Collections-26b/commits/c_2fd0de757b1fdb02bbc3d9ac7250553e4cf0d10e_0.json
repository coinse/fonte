{"sha": "2fd0de757b1fdb02bbc3d9ac7250553e4cf0d10e", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r740150 | mbenson | 2009-02-02 15:24:00 -0800 (Mon, 02 Feb 2009) | 1 line          make all [collections] maps implement IterableMap     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/CompositeMap.java\n+++ b/src/java/org/apache/commons/collections/map/CompositeMap.java\n import java.io.Serializable;\n \n import java.util.Collection;\n-import java.util.Iterator;\n import java.util.Map;\n import java.util.Set;\n \n  * <strong>Note that CompositeMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  *\n  * @since Commons Collections 3.0\n  *\n  * @author Brian McCallister\n  */\n-public class CompositeMap implements Map, Serializable {\n+public class CompositeMap<K, V> extends AbstractIterableMap<K, V> implements Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -6096931280583808322L;\n \n     /** Array of all maps in the composite */\n-    private Map[] composite;\n+    private Map<K, V>[] composite;\n \n     /** Handle mutation operations */\n-    private MapMutator mutator;\n+    private MapMutator<K, V> mutator;\n \n     /**\n      * Create a new, empty, CompositeMap.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public CompositeMap() {\n-        this(new Map[]{}, null);\n+        this(new Map[] {}, null);\n     }\n \n     /**\n      * Create a new CompositeMap with two composited Map instances.\n-     * \n+     *\n      * @param one  the first Map to be composited\n      * @param two  the second Map to be composited\n      * @throws IllegalArgumentException if there is a key collision\n      */\n-    public CompositeMap(Map one, Map two) {\n-        this(new Map[]{one, two}, null);\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(Map<K, V> one, Map<K, V> two) {\n+        this(new Map[] { one, two }, null);\n     }\n \n     /**\n      * Create a new CompositeMap with two composited Map instances.\n-     * \n+     *\n      * @param one  the first Map to be composited\n      * @param two  the second Map to be composited\n      * @param mutator  MapMutator to be used for mutation operations\n      */\n-    public CompositeMap(Map one, Map two, MapMutator mutator) {\n-        this(new Map[]{one, two}, mutator);\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(Map<K, V> one, Map<K, V> two, MapMutator<K, V> mutator) {\n+        this(new Map[] { one, two }, mutator);\n     }\n \n     /**\n      * Create a new CompositeMap which composites all of the Map instances in the\n      * argument. It copies the argument array, it does not use it directly.\n-     * \n+     *\n      * @param composite  the Maps to be composited\n      * @throws IllegalArgumentException if there is a key collision\n      */\n-    public CompositeMap(Map[] composite) {\n+    public CompositeMap(Map<K, V>[] composite) {\n         this(composite, null);\n     }\n \n     /**\n      * Create a new CompositeMap which composites all of the Map instances in the\n      * argument. It copies the argument array, it does not use it directly.\n-     * \n+     *\n      * @param composite  Maps to be composited\n      * @param mutator  MapMutator to be used for mutation operations\n      */\n-    public CompositeMap(Map[] composite, MapMutator mutator) {\n+    @SuppressWarnings(\"unchecked\")\n+    public CompositeMap(Map<K, V>[] composite, MapMutator<K, V> mutator) {\n         this.mutator = mutator;\n         this.composite = new Map[0];\n         for (int i = composite.length - 1; i >= 0; --i) {\n     //-----------------------------------------------------------------------\n     /**\n      * Specify the MapMutator to be used by mutation operations.\n-     * \n+     *\n      * @param mutator  the MapMutator to be used for mutation delegation\n      */\n-    public void setMutator(MapMutator mutator) {\n+    public void setMutator(MapMutator<K, V> mutator) {\n         this.mutator = mutator;\n     }\n-    \n+\n     /**\n      * Add an additional Map to the composite.\n      *\n      * @throws IllegalArgumentException if there is a key collision and there is no\n      *         MapMutator set to handle it.\n      */\n-    public synchronized void addComposited(Map map) throws IllegalArgumentException {\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized void addComposited(Map<K, V> map) throws IllegalArgumentException {\n         for (int i = composite.length - 1; i >= 0; --i) {\n-            Collection intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n+            Collection<K> intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n             if (intersect.size() != 0) {\n                 if (this.mutator == null) {\n                     throw new IllegalArgumentException(\"Key collision adding Map to CompositeMap\");\n                 }\n-                else {\n-                    this.mutator.resolveCollision(this, this.composite[i], map, intersect);\n-                }\n-            }\n-        }\n-        Map[] temp = new Map[this.composite.length + 1];\n+                this.mutator.resolveCollision(this, this.composite[i], map, intersect);\n+            }\n+        }\n+        Map<K, V>[] temp = new Map[this.composite.length + 1];\n         System.arraycopy(this.composite, 0, temp, 0, this.composite.length);\n         temp[temp.length - 1] = map;\n         this.composite = temp;\n     }\n-    \n+\n     /**\n      * Remove a Map from the composite.\n      *\n      * @param map  the Map to be removed from the composite\n      * @return The removed Map or <code>null</code> if map is not in the composite\n      */\n-    public synchronized Map removeComposited(Map map) {\n+    @SuppressWarnings(\"unchecked\")\n+    public synchronized Map<K, V> removeComposited(Map<K, V> map) {\n         int size = this.composite.length;\n         for (int i = 0; i < size; ++i) {\n             if (this.composite[i].equals(map)) {\n-                Map[] temp = new Map[size - 1];\n+                Map<K, V>[] temp = new Map[size - 1];\n                 System.arraycopy(this.composite, 0, temp, 0, i);\n                 System.arraycopy(this.composite, i + 1, temp, i, size - i - 1);\n                 this.composite = temp;\n         return null;\n     }\n \n-    //-----------------------------------------------------------------------    \n+    //-----------------------------------------------------------------------\n     /**\n      * Calls <code>clear()</code> on all composited Maps.\n      *\n             this.composite[i].clear();\n         }\n     }\n-    \n+\n     /**\n      * Returns <tt>true</tt> if this map contains a mapping for the specified\n      * key.  More formally, returns <tt>true</tt> if and only if\n      *         key.\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n-     *           this map (optional).\n+     *         this map (optional).\n      * @throws NullPointerException if the key is <tt>null</tt> and this map\n      *            does not not permit <tt>null</tt> keys (optional).\n      */\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Returns <tt>true</tt> if this map maps one or more keys to the\n      * specified value.  More formally, returns <tt>true</tt> if and only if\n      * @return <tt>true</tt> if this map maps one or more keys to the\n      *         specified value.\n      * @throws ClassCastException if the value is of an inappropriate type for\n-     *           this map (optional).\n+     *         this map (optional).\n      * @throws NullPointerException if the value is <tt>null</tt> and this map\n      *            does not not permit <tt>null</tt> values (optional).\n      */\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Returns a set view of the mappings contained in this map.  Each element\n      * in the returned set is a <code>Map.Entry</code>.  The set is backed by the\n      * @see CompositeSet\n      * @return a set view of the mappings contained in this map.\n      */\n-    public Set entrySet() {\n-        CompositeSet entries = new CompositeSet();\n-        for (int i = this.composite.length - 1; i >= 0; --i) {\n-            entries.addComposited(this.composite[i].entrySet());\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        CompositeSet<Map.Entry<K, V>> entries = new CompositeSet<Map.Entry<K,V>>();\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            entries.addComposited(composite[i].entrySet());\n         }\n         return entries;\n     }\n-    \n+\n     /**\n      * Returns the value to which this map maps the specified key.  Returns\n      * <tt>null</tt> if the map contains no mapping for this key.  A return\n      *\n      * @param key key whose associated value is to be returned.\n      * @return the value to which this map maps the specified key, or\n-     *           <tt>null</tt> if the map contains no mapping for this key.\n+     *         <tt>null</tt> if the map contains no mapping for this key.\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n-     *           this map (optional).\n+     *         this map (optional).\n      * @throws NullPointerException key is <tt>null</tt> and this map does not\n-     *          not permit <tt>null</tt> keys (optional).\n+     *         not permit <tt>null</tt> keys (optional).\n      *\n      * @see #containsKey(Object)\n      */\n-    public Object get(Object key) {\n+    public V get(Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             if (this.composite[i].containsKey(key)) {\n                 return this.composite[i].get(key);\n         }\n         return null;\n     }\n-    \n+\n     /**\n      * Returns <tt>true</tt> if this map contains no key-value mappings.\n      *\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Returns a set view of the keys contained in this map.  The set is\n      * backed by the map, so changes to the map are reflected in the set, and\n      *\n      * @return a set view of the keys contained in this map.\n      */\n-    public Set keySet() {\n-        CompositeSet keys = new CompositeSet();\n+    public Set<K> keySet() {\n+        CompositeSet<K> keys = new CompositeSet<K>();\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             keys.addComposited(this.composite[i].keySet());\n         }\n         return keys;\n     }\n-    \n+\n     /**\n      * Associates the specified value with the specified key in this map\n      * (optional operation).  If the map previously contained a mapping for\n      * @param key key with which the specified value is to be associated.\n      * @param value value to be associated with the specified key.\n      * @return previous value associated with specified key, or <tt>null</tt>\n-     *           if there was no mapping for key.  A <tt>null</tt> return can\n-     *           also indicate that the map previously associated <tt>null</tt>\n-     *           with the specified key, if the implementation supports\n-     *           <tt>null</tt> values.\n+     *         if there was no mapping for key.  A <tt>null</tt> return can\n+     *         also indicate that the map previously associated <tt>null</tt>\n+     *         with the specified key, if the implementation supports\n+     *         <tt>null</tt> values.\n      *\n      * @throws UnsupportedOperationException if no MapMutator has been specified\n      * @throws ClassCastException if the class of the specified key or value\n-     *               prevents it from being stored in this map.\n+     *            prevents it from being stored in this map.\n      * @throws IllegalArgumentException if some aspect of this key or value\n-     *              prevents it from being stored in this map.\n+     *            prevents it from being stored in this map.\n      * @throws NullPointerException this map does not permit <tt>null</tt>\n      *            keys or values, and the specified key or value is\n      *            <tt>null</tt>.\n      */\n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         if (this.mutator == null) {\n             throw new UnsupportedOperationException(\"No mutator specified\");\n         }\n         return this.mutator.put(this, this.composite, key, value);\n     }\n-    \n+\n     /**\n      * Copies all of the mappings from the specified map to this map\n      * (optional operation).  The effect of this call is equivalent to that\n      * @param map Mappings to be stored in this map.\n      *\n      * @throws UnsupportedOperationException if the <tt>putAll</tt> method is\n-     *           not supported by this map.\n+     *         not supported by this map.\n      *\n      * @throws ClassCastException if the class of a key or value in the\n-     *               specified map prevents it from being stored in this map.\n+     *         specified map prevents it from being stored in this map.\n      *\n      * @throws IllegalArgumentException some aspect of a key or value in the\n-     *              specified map prevents it from being stored in this map.\n+     *         specified map prevents it from being stored in this map.\n      * @throws NullPointerException the specified map is <tt>null</tt>, or if\n      *         this map does not permit <tt>null</tt> keys or values, and the\n      *         specified map contains <tt>null</tt> keys or values.\n      */\n-    public void putAll(Map map) {\n+    public void putAll(Map<? extends K, ? extends V> map) {\n         if (this.mutator == null) {\n             throw new UnsupportedOperationException(\"No mutator specified\");\n         }\n         this.mutator.putAll(this, this.composite, map);\n     }\n-    \n+\n     /**\n      * Removes the mapping for this key from this map if it is present\n      * (optional operation).   More formally, if this map contains a mapping\n      *\n      * @param key key whose mapping is to be removed from the map.\n      * @return previous value associated with specified key, or <tt>null</tt>\n-     *           if there was no mapping for key.\n+     *         if there was no mapping for key.\n      *\n      * @throws ClassCastException if the key is of an inappropriate type for\n-     *           the composited map (optional).\n+     *         the composited map (optional).\n      * @throws NullPointerException if the key is <tt>null</tt> and the composited map\n      *            does not not permit <tt>null</tt> keys (optional).\n      * @throws UnsupportedOperationException if the <tt>remove</tt> method is\n      *         not supported by the composited map containing the key\n      */\n-    public Object remove(Object key) {\n+    public V remove(Object key) {\n         for (int i = this.composite.length - 1; i >= 0; --i) {\n             if (this.composite[i].containsKey(key)) {\n                 return this.composite[i].remove(key);\n         }\n         return null;\n     }\n-    \n+\n     /**\n      * Returns the number of key-value mappings in this map.  If the\n      * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns\n         }\n         return size;\n     }\n-    \n+\n     /**\n      * Returns a collection view of the values contained in this map.  The\n      * collection is backed by the map, so changes to the map are reflected in\n      *\n      * @return a collection view of the values contained in this map.\n      */\n-    public Collection values() {\n-        CompositeCollection keys = new CompositeCollection();\n-        for (int i = this.composite.length - 1; i >= 0; --i) {\n-            keys.addComposited(this.composite[i].values());\n-        }\n-        return keys;\n-    }\n-    \n+    public Collection<V> values() {\n+        CompositeCollection<V> values = new CompositeCollection<V>();\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            values.addComposited(composite[i].values());\n+        }\n+        return values;\n+    }\n+\n     /**\n      * Checks if this Map equals another as per the Map specification.\n-     * \n+     *\n      * @param obj  the object to compare to\n      * @return true if the maps are equal\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean equals(Object obj) {\n         if (obj instanceof Map) {\n             Map map = (Map) obj;\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Gets a hash code for the Map as per the Map specification.\n      */\n     public int hashCode() {\n         int code = 0;\n-        for (Iterator i = this.entrySet().iterator(); i.hasNext();) {\n-            code += i.next().hashCode();\n+        for (Map.Entry<K, V> entry : entrySet()) {\n+            code += entry.hashCode();\n         }\n         return code;\n     }\n-    \n+\n     /**\n      * This interface allows definition for all of the indeterminate\n      * mutators in a CompositeMap, as well as providing a hook for\n      * callbacks on key collisions.\n      */\n-    public static interface MapMutator extends Serializable {\n+    public static interface MapMutator<K, V> extends Serializable {\n         /**\n          * Called when adding a new Composited Map results in a\n          * key collision.\n          * @param added  the Map being added\n          * @param intersect  the intersection of the keysets of the existing and added maps\n          */\n-        public void resolveCollision(\n-            CompositeMap composite, Map existing, Map added, Collection intersect);\n-        \n+        public void resolveCollision(CompositeMap<K, V> composite, Map<K, V> existing,\n+                Map<K, V> added, Collection<K> intersect);\n+\n         /**\n          * Called when the CompositeMap.put() method is invoked.\n          *\n          * @param key  key with which the specified value is to be associated.\n          * @param value  value to be associated with the specified key.\n          * @return previous value associated with specified key, or <tt>null</tt>\n-         *           if there was no mapping for key.  A <tt>null</tt> return can\n-         *           also indicate that the map previously associated <tt>null</tt>\n-         *           with the specified key, if the implementation supports\n-         *           <tt>null</tt> values.\n+         *         if there was no mapping for key.  A <tt>null</tt> return can\n+         *         also indicate that the map previously associated <tt>null</tt>\n+         *         with the specified key, if the implementation supports\n+         *         <tt>null</tt> values.\n          *\n          * @throws UnsupportedOperationException if not defined\n          * @throws ClassCastException if the class of the specified key or value\n-         *               prevents it from being stored in this map.\n+         *            prevents it from being stored in this map.\n          * @throws IllegalArgumentException if some aspect of this key or value\n-         *              prevents it from being stored in this map.\n+         *            prevents it from being stored in this map.\n          * @throws NullPointerException this map does not permit <tt>null</tt>\n          *            keys or values, and the specified key or value is\n          *            <tt>null</tt>.\n          */\n-        public Object put(CompositeMap map, Map[] composited, Object key, Object value);\n-        \n+        public V put(CompositeMap<K, V> map, Map<K, V>[] composited, K key, V value);\n+\n         /**\n          * Called when the CompositeMap.putAll() method is invoked.\n          *\n          *\n          * @throws UnsupportedOperationException if not defined\n          * @throws ClassCastException if the class of the specified key or value\n-         *               prevents it from being stored in this map.\n+         *            prevents it from being stored in this map.\n          * @throws IllegalArgumentException if some aspect of this key or value\n-         *              prevents it from being stored in this map.\n+         *            prevents it from being stored in this map.\n          * @throws NullPointerException this map does not permit <tt>null</tt>\n          *            keys or values, and the specified key or value is\n          *            <tt>null</tt>.\n          */\n-        public void putAll(CompositeMap map, Map[] composited, Map mapToAdd);\n+        public void putAll(CompositeMap<K, V> map, Map<K, V>[] composited,\n+                Map<? extends K, ? extends V> mapToAdd);\n     }\n }", "timestamp": 1252994159, "metainfo": ""}