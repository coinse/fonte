{"sha": "b9db60ade4ca7d02bbd9b530e12221e5f44e227e", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r641231 | skestle | 2008-03-26 02:58:51 -0700 (Wed, 26 Mar 2008) | 1 line          Started incorporating Edwin's patch for COLLECTIONS-253, in preparation for COLLECTIONS-290.     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/functors/FunctorUtils.java\n+++ b/src/java/org/apache/commons/collections/functors/FunctorUtils.java\n package org.apache.commons.collections.functors;\n \n import java.util.Collection;\n-import java.util.Iterator;\n \n import org.apache.commons.collections.Closure;\n import org.apache.commons.collections.Predicate;\n  * @author Matt Benson\n  */\n class FunctorUtils {\n-    \n+\n     /**\n      * Restricted constructor.\n      */\n     private FunctorUtils() {\n         super();\n     }\n-    \n+\n     /**\n      * Clone the predicates to ensure that the internal reference can't be messed with.\n-     * \n+     * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n+     * able to be coerced to Predicate<T> without casting issues.\n+     *\n      * @param predicates  the predicates to copy\n      * @return the cloned predicates\n      */\n-    static Predicate[] copy(Predicate[] predicates) {\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T>[] copy(Predicate<? super T>[] predicates) {\n         if (predicates == null) {\n             return null;\n         }\n-        return (Predicate[]) predicates.clone();\n-    }\n-    \n+        return (Predicate<T>[]) predicates.clone();\n+    }\n+\n+    /**\n+     * A very simple method that coerces Predicate<? super T> to Predicate<T>.\n+     * Due to the {@link Predicate#evaluate(T)} method, Predicate<? super T> is\n+     * able to be coerced to Predicate<T> without casting issues.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned predicate should \"accept\"\n+     * @param predicate the predicate to coerce.\n+     * @return the coerced predicate.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T> coerce(Predicate<? super T> predicate){\n+        return (Predicate<T>) predicate;\n+    }\n+\n     /**\n      * Validate the predicates to ensure that all is well.\n-     * \n+     *\n      * @param predicates  the predicates to validate\n      */\n-    static void validate(Predicate[] predicates) {\n+    static void validate(Predicate<?>[] predicates) {\n         if (predicates == null) {\n             throw new IllegalArgumentException(\"The predicate array must not be null\");\n         }\n             }\n         }\n     }\n-    \n+\n     /**\n      * Validate the predicates to ensure that all is well.\n-     * \n+     *\n      * @param predicates  the predicates to validate\n      * @return predicate array\n      */\n-    static Predicate[] validate(Collection predicates) {\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Predicate<T>[] validate(Collection<? extends Predicate<T>> predicates) {\n         if (predicates == null) {\n             throw new IllegalArgumentException(\"The predicate collection must not be null\");\n         }\n         // convert to array like this to guarantee iterator() ordering\n-        Predicate[] preds = new Predicate[predicates.size()];\n+        Predicate<T>[] preds = new Predicate[predicates.size()];\n         int i = 0;\n-        for (Iterator it = predicates.iterator(); it.hasNext();) {\n-            preds[i] = (Predicate) it.next();\n+        for (Predicate<T> predicate : predicates) {\n+            preds[i] = predicate;\n             if (preds[i] == null) {\n                 throw new IllegalArgumentException(\"The predicate collection must not contain a null predicate, index \" + i + \" was null\");\n             }\n         }\n         return preds;\n     }\n-    \n+\n     /**\n      * Clone the closures to ensure that the internal reference can't be messed with.\n-     * \n+     *\n      * @param closures  the closures to copy\n      * @return the cloned closures\n      */\n-    static Closure[] copy(Closure[] closures) {\n+    @SuppressWarnings(\"unchecked\")\n+    static <E> Closure<E>[] copy(Closure<? super E>[] closures) {\n         if (closures == null) {\n             return null;\n         }\n-        return (Closure[]) closures.clone();\n-    }\n-    \n+        return (Closure<E>[]) closures.clone();\n+    }\n+\n     /**\n      * Validate the closures to ensure that all is well.\n-     * \n+     *\n      * @param closures  the closures to validate\n      */\n-    static void validate(Closure[] closures) {\n+    static void validate(Closure<?>[] closures) {\n         if (closures == null) {\n             throw new IllegalArgumentException(\"The closure array must not be null\");\n         }\n     }\n \n     /**\n+     * A very simple method that coerces Closure<? super T> to Closure<T>.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned closure should \"accept\"\n+     * @param closure the closure to coerce.\n+     * @return the coerced closure.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> Closure<T> coerce(Closure<? super T> closure){\n+        return (Closure<T>) closure;\n+    }\n+\n+    /**\n      * Copy method\n-     * \n+     *\n      * @param transformers  the transformers to copy\n      * @return a clone of the transformers\n      */\n-    static Transformer[] copy(Transformer[] transformers) {\n+    @SuppressWarnings(\"unchecked\")\n+    static <I, O> Transformer<I, O>[] copy(Transformer<? super I, ? extends O>[] transformers) {\n         if (transformers == null) {\n             return null;\n         }\n-        return (Transformer[]) transformers.clone();\n-    }\n-    \n+        return (Transformer<I, O>[]) transformers.clone();\n+    }\n+\n     /**\n      * Validate method\n-     * \n+     *\n      * @param transformers  the transformers to validate\n      */\n-    static void validate(Transformer[] transformers) {\n+    static void validate(Transformer<?, ?>[] transformers) {\n         if (transformers == null) {\n             throw new IllegalArgumentException(\"The transformer array must not be null\");\n         }\n         }\n     }\n \n+    /**\n+     * A very simple method that coerces Transformer<? super I, ? extends O> to Transformer<I, O>.\n+     * <p>This method exists\n+     * simply as centralised documentation and atomic unchecked warning\n+     * suppression.\n+     *\n+     * @param <T> the type of object the returned transformer should \"accept\"\n+     * @param transformer the transformer to coerce.\n+     * @return the coerced transformer.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    static <I, O> Transformer<I, O> coerce(Transformer<? super I, ? extends O> transformer) {\n+        return (Transformer<I, O>) transformer;\n+    }\n+\n }", "timestamp": 1252994106, "metainfo": ""}