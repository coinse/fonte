{"sha": "0b9cb552be0203407c0effb2e4df46a7eed96f4a", "log": "Add CursorableLinkedList to list subpackage Rework AbstractLL/NodeCachingLL to allow for this Update tests   ", "commit": "\n--- a/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/AbstractLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/AbstractLinkedList.java,v 1.1 2003/12/11 00:18:06 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/AbstractLinkedList.java,v 1.2 2003/12/24 01:15:40 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * An abstract implementation of a linked list which provides numerous points for\n  * subclasses to override.\n  * <p>\n- * Overridable methods are provided to change the storage node, and to change how\n- * entries are added to and removed from the map. Hopefully, all you need for\n- * unusual subclasses is here.\n- * <p>\n- * This class currently extends AbstractList, but do not rely on that. It may change.\n+ * Overridable methods are provided to change the storage node and to change how\n+ * nodes are added to and removed. Hopefully, all you need for unusual subclasses\n+ * is here.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/12/11 00:18:06 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/24 01:15:40 $\n  *\n  * @author Rich Dougherty\n  * @author Phil Steitz\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractLinkedList extends AbstractList implements List {\n+public abstract class AbstractLinkedList implements List {\n \n     /*\n      * Implementation notes:\n      * - a modification count is kept, with the same semantics as\n      * {@link java.util.LinkedList}.\n      * - respects {@link AbstractList#modCount}\n-     * - only extends AbstractList for subList() - TODO\n      */\n \n     /**\n     protected transient Node header;\n     /** The size of the list */\n     protected transient int size;\n-//    /** Modification count for iterators */\n-//    protected transient int modCount;\n+    /** Modification count for iterators */\n+    protected transient int modCount;\n \n     /**\n      * Constructor that does nothing intended for deserialization.\n     }\n \n     public ListIterator listIterator() {\n-        return new LinkedListIterator();\n-    }\n-\n-    public ListIterator listIterator(int startIndex) {\n-        return new LinkedListIterator(startIndex);\n+        return new LinkedListIterator(this, 0);\n+    }\n+\n+    public ListIterator listIterator(int fromIndex) {\n+        return new LinkedListIterator(this, fromIndex);\n     }\n \n     //-----------------------------------------------------------------------\n             }\n         }\n         return true;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public Object[] toArray() {\n+        return toArray(new Object[size]);\n+    }\n+\n+    public Object[] toArray(Object[] array) {\n+        // Extend the array if needed\n+        if (array.length < size) {\n+            Class componentType = array.getClass().getComponentType();\n+            array = (Object[]) Array.newInstance(componentType, size);\n+        }\n+        // Copy the values into the array\n+        int i = 0;\n+        for (Node node = header.next; node != header; node = node.next, i++) {\n+            array[i] = node.value;\n+        }\n+        // Set the value after the last value to null\n+        if (array.length > size) {\n+            array[size] = null;\n+        }\n+        return array;\n+    }\n+\n+    /**\n+     * Gets a sublist of the main list.\n+     * \n+     * @param fromIndexInclusive  the index to start from\n+     * @param toIndexExclusive  the index to end at\n+     * @return the new sublist\n+     */\n+    public List subList(int fromIndexInclusive, int toIndexExclusive) {\n+        return new LinkedSubList(this, fromIndexInclusive, toIndexExclusive);\n     }\n     \n     //-----------------------------------------------------------------------\n     public Object set(int index, Object value) {\n         Node node = getNode(index, false);\n         Object oldValue = node.value;\n-        node.value = value;\n+        updateNode(node, value);\n         return oldValue;\n     }\n \n         removeAllNodes();\n     }\n     \n-    //-----------------------------------------------------------------------\n-    public Object[] toArray() {\n-        return toArray(new Object[size]);\n-    }\n-\n-    public Object[] toArray(Object[] array) {\n-        // Extend the array if needed\n-        if (array.length < size) {\n-            Class componentType = array.getClass().getComponentType();\n-            array = (Object[]) Array.newInstance(componentType, size);\n-        }\n-        // Copy the values into the array\n-        Node node = header.next;\n-        for (int i = 0; i < size; i++) {\n-            array[i] = node.value;\n-            node = node.next;\n-        }\n-        // Set the value after the last value to null\n-        if (array.length > size) {\n-            array[size] = null;\n-        }\n-        return array;\n-    }\n-\n     //-----------------------------------------------------------------------\n     public Object getFirst() {\n         Node node = header.next;\n         return node.value;\n     }\n \n-    public void addFirst(Object o) {\n+    public boolean addFirst(Object o) {\n         addNodeAfter(header, o);\n-    }\n-\n-    public void addLast(Object o) {\n+        return true;\n+    }\n+\n+    public boolean addLast(Object o) {\n         addNodeBefore(header, o);\n+        return true;\n     }\n \n     public Object removeFirst() {\n     }\n     \n     /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     * \n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    protected void updateNode(Node node, Object value) {\n+        node.value = value;\n+    }\n+\n+    /**\n      * Creates a new node with previous, next and element all set to null.\n      * This implementation creates a new empty Node.\n      * Subclasses can override this to create a different class.\n      * This implementation creates a new Node with data.\n      * Subclasses can override this to create a different class.\n      * \n-     * @param previous  node to precede the new node\n-     * @param next  node to follow the new node\n      * @param value  value of the new node\n      */\n-    protected Node createNode(Node previous, Node next, Object value) {\n-        return new Node(previous, next, value);\n+    protected Node createNode(Object value) {\n+        return new Node(value);\n     }\n \n     /**\n      * Creates a new node with the specified object as its \n      * <code>value</code> and inserts it before <code>node</code>.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and {@link #addNode(Node, Node)}.\n      *\n      * @param node  node to insert before\n      * @param value  value of the newly added node\n      * @throws NullPointerException if <code>node</code> is null\n      */\n     protected void addNodeBefore(Node node, Object value) {\n-        Node newNode = createNode(node.previous, node, value);\n-        node.previous.next = newNode;\n-        node.previous = newNode;\n-        size++;\n-        modCount++;\n+        Node newNode = createNode(value);\n+        addNode(newNode, node);\n     }\n \n     /**\n      * Creates a new node with the specified object as its \n      * <code>value</code> and inserts it after <code>node</code>.\n+     * <p>\n+     * This implementation uses {@link #createNode(Object)} and {@link #addNode(Node, Node)}.\n      * \n      * @param node  node to insert after\n      * @param value  value of the newly added node\n      * @throws NullPointerException if <code>node</code> is null\n      */\n     protected void addNodeAfter(Node node, Object value) {\n-        Node newNode = createNode(node, node.next, value);\n-        node.next.previous = newNode;\n-        node.next = newNode;\n+        Node newNode = createNode(value);\n+        addNode(newNode, node.next);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    protected void addNode(Node nodeToInsert, Node insertBeforeNode) {\n+        nodeToInsert.next = insertBeforeNode;\n+        nodeToInsert.previous = insertBeforeNode.previous;\n+        insertBeforeNode.previous.next = nodeToInsert;\n+        insertBeforeNode.previous = nodeToInsert;\n         size++;\n         modCount++;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n+     * Creates an iterator for the sublist.\n+     * \n+     * @param subList  the sublist to get an iterator for\n+     */\n+    protected Iterator createSubListIterator(LinkedSubList subList) {\n+        return createSubListListIterator(subList, 0);\n+    }\n+\n+    /**\n+     * Creates a list iterator for the sublist.\n+     * \n+     * @param subList  the sublist to get an iterator for\n+     * @param fromIndex  the index to start from, relative to the sublist\n+     */\n+    protected ListIterator createSubListListIterator(LinkedSubList subList, int fromIndex) {\n+        return new LinkedSubListIterator(subList, fromIndex);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n      * Serializes the data held in this object to the stream specified.\n      * <p>\n      * The first serializable subclass must call this method from\n     //-----------------------------------------------------------------------\n     /**\n      * A node within the linked list.\n-     * \n-     * @author Rich Dougherty\n-     * @author Stephen Colebourne\n      */\n     protected static class Node {\n \n         /** A pointer to the node before this node */\n-        public Node previous;\n+        protected Node previous;\n         /** A pointer to the node after this node */\n-        public Node next;\n+        protected Node next;\n         /** The object contained within this node */\n-        public Object value;\n+        protected Object value;\n \n         /**\n          * Constructs a new header node.\n          */\n-        public Node() {\n+        protected Node() {\n             super();\n             previous = this;\n             next = this;\n         }\n \n+        /**\n+         * Constructs a new node.\n+         * \n+         * @param value  the value to store\n+         */\n+        protected Node(Object value) {\n+            super();\n+            this.value = value;\n+        }\n+        \n         /**\n          * Constructs a new node.\n          * \n          * @param next  the next node in the list\n          * @param value  the value to store\n          */\n-        public Node(Node previous, Node next, Object value) {\n+        protected Node(Node previous, Node next, Object value) {\n             super();\n             this.previous = previous;\n             this.next = next;\n     //-----------------------------------------------------------------------\n     /**\n      * A list iterator over the linked list.\n-     * \n-     * @author Rich Dougherty\n-     */\n-    protected class LinkedListIterator implements ListIterator, OrderedIterator {\n+     */\n+    protected static class LinkedListIterator implements ListIterator, OrderedIterator {\n+        \n+        /** The parent list */\n+        protected final AbstractLinkedList list;\n \n         /**\n          * The node that will be returned by {@link #next()}. If this is equal\n          * to {@link #marker} then there are no more values to return.\n          */\n-        protected Node nextNode;\n+        protected Node next;\n \n         /**\n          * The index of {@link #nextNode}.\n          * Should be accesed through {@link #getLastNodeReturned()} to enforce\n          * this behaviour.\n          */\n-        protected Node lastNodeReturned;\n+        protected Node current;\n \n         /**\n          * The modification count that the list is expected to have. If the list\n         protected int expectedModCount;\n \n         /**\n-         * Create a ListIterator for a list, starting at the first value in\n-         * the list.\n-         */\n-        public LinkedListIterator() throws IndexOutOfBoundsException {\n-            this(0);\n-        }\n-\n-        /**\n          * Create a ListIterator for a list.\n          * \n-         * @param startIndex The index to start at.\n+         * @param parent  the parent list\n+         * @param fromIndex  the index to start at\n          */\n-        public LinkedListIterator(int startIndex) throws IndexOutOfBoundsException {\n+        public LinkedListIterator(AbstractLinkedList parent, int fromIndex) throws IndexOutOfBoundsException {\n             super();\n-            expectedModCount = modCount;\n-            nextNode = getNode(startIndex, true);\n-            nextIndex = startIndex;\n+            this.list = parent;\n+            this.expectedModCount = list.modCount;\n+            this.next = list.getNode(fromIndex, true);\n+            this.nextIndex = fromIndex;\n         }\n \n         /**\n          * @throws ConcurrentModificationException If the list's modification\n          * count isn't the value that was expected.\n          */\n-        protected void checkModCount()\n-            throws ConcurrentModificationException {\n-            if (modCount != expectedModCount) {\n+        protected void checkModCount() {\n+            if (list.modCount != expectedModCount) {\n                 throw new ConcurrentModificationException();\n             }\n         }\n          * with {@link #remove()} or a new node added with {@link #add(Object)}.\n          */\n         protected Node getLastNodeReturned() throws IllegalStateException {\n-            if (lastNodeReturned == null) {\n+            if (current == null) {\n                 throw new IllegalStateException();\n             }\n-            return lastNodeReturned;\n+            return current;\n         }\n \n         public boolean hasNext() {\n-            return nextNode != header;\n+            return next != list.header;\n         }\n \n         public Object next() {\n                 throw new NoSuchElementException(\"No element at index \" +\n                         nextIndex + \".\");\n             }\n-            Object value = nextNode.value;\n-            lastNodeReturned = nextNode;\n-            nextNode = nextNode.next;\n+            Object value = next.value;\n+            current = next;\n+            next = next.next;\n             nextIndex++;\n             return value;\n         }\n \n         public boolean hasPrevious() {\n-            return nextNode.previous != header;\n+            return next.previous != list.header;\n         }\n \n         public Object previous() {\n             if (!hasPrevious()) {\n                 throw new NoSuchElementException(\"Already at start of list.\");\n             }\n-            nextNode = nextNode.previous;\n-            Object value = nextNode.value;\n-            lastNodeReturned = nextNode;\n+            next = next.previous;\n+            Object value = next.value;\n+            current = next;\n             nextIndex--;\n             return value;\n         }\n         }\n \n         public int previousIndex() {\n-            return nextIndex - 1;\n+            // not normally overridden, as relative to nextIndex()\n+            return nextIndex() - 1;\n         }\n \n         public void remove() {\n             checkModCount();\n-            removeNode(getLastNodeReturned());\n-            lastNodeReturned = null;\n+            list.removeNode(getLastNodeReturned());\n+            current = null;\n             nextIndex--;\n             expectedModCount++;\n         }\n \n-        public void set(Object o) {\n-            checkModCount();\n-            getLastNodeReturned().value = o;\n-        }\n-\n-        public void add(Object o) {\n-            checkModCount();\n-            addNodeBefore(nextNode, o);\n-            lastNodeReturned = null;\n+        public void set(Object obj) {\n+            checkModCount();\n+            getLastNodeReturned().value = obj;\n+        }\n+\n+        public void add(Object obj) {\n+            checkModCount();\n+            list.addNodeBefore(next, obj);\n+            current = null;\n             nextIndex++;\n             expectedModCount++;\n         }\n \n     }\n \n+    //-----------------------------------------------------------------------\n+    /**\n+     * A list iterator over the linked sub list.\n+     */\n+    protected static class LinkedSubListIterator extends LinkedListIterator {\n+        \n+        /** The parent list */\n+        protected final LinkedSubList sub;\n+        \n+        protected LinkedSubListIterator(LinkedSubList sub, int startIndex) {\n+            super(sub.list, startIndex + sub.offset);\n+            this.sub = sub;\n+        }\n+\n+        public boolean hasNext() {\n+            return (nextIndex() < sub.size);\n+        }\n+\n+        public boolean hasPrevious() {\n+            return (previousIndex() >= 0);\n+        }\n+\n+        public int nextIndex() {\n+            return (super.nextIndex() - sub.offset);\n+        }\n+\n+        public void add(Object obj) {\n+            super.add(obj);\n+            sub.expectedModCount = list.modCount;\n+            sub.size++;\n+        }\n+        \n+        public void remove() {\n+            super.remove();\n+            sub.expectedModCount = list.modCount;\n+            sub.size--;\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * The sublist implementation for AbstractLinkedList.\n+     */\n+    protected static class LinkedSubList extends AbstractList {\n+        /** The main list */\n+        private AbstractLinkedList list;\n+        /** Offset from the main list */\n+        private int offset;\n+        /** Sublist size */\n+        private int size;\n+        /** Sublist modCount */\n+        private int expectedModCount;\n+\n+        protected LinkedSubList(AbstractLinkedList list, int fromIndex, int toIndex) {\n+            if (fromIndex < 0) {\n+                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n+            }\n+            if (toIndex > list.size()) {\n+                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n+            }\n+            if (fromIndex > toIndex) {\n+                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n+            }\n+            this.list = list;\n+            this.offset = fromIndex;\n+            this.size = toIndex - fromIndex;\n+            this.expectedModCount = list.modCount;\n+        }\n+\n+        public int size() {\n+            checkModCount();\n+            return size;\n+        }\n+\n+        public Object get(int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return list.get(index + offset);\n+        }\n+\n+        public void add(int index, Object obj) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            list.add(index + offset, obj);\n+            expectedModCount = list.modCount;\n+            size++;\n+            LinkedSubList.this.modCount++;\n+        }\n+\n+        public Object remove(int index) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            Object result = list.remove(index + offset);\n+            expectedModCount = list.modCount;\n+            size--;\n+            LinkedSubList.this.modCount++;\n+            return result;\n+        }\n+\n+        public boolean addAll(Collection coll) {\n+            return addAll(size, coll);\n+        }\n+\n+        public boolean addAll(int index, Collection coll) {\n+            rangeCheck(index, size + 1);\n+            int cSize = coll.size();\n+            if (cSize == 0) {\n+                return false;\n+            }\n+\n+            checkModCount();\n+            list.addAll(offset + index, coll);\n+            expectedModCount = list.modCount;\n+            size += cSize;\n+            LinkedSubList.this.modCount++;\n+            return true;\n+        }\n+\n+        public Object set(int index, Object obj) {\n+            rangeCheck(index, size);\n+            checkModCount();\n+            return list.set(index + offset, obj);\n+        }\n+\n+        public void clear() {\n+            checkModCount();\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+\n+        public Iterator iterator() {\n+            checkModCount();\n+            return list.createSubListIterator(this);\n+        }\n+\n+        public ListIterator listIterator(final int index) {\n+            rangeCheck(index, size + 1);\n+            checkModCount();\n+            return list.createSubListListIterator(this, index);\n+        }\n+\n+        public List subList(int fromIndexInclusive, int toIndexExclusive) {\n+            return new LinkedSubList(list, fromIndexInclusive + offset, toIndexExclusive + offset);\n+        }\n+\n+        protected void rangeCheck(int index, int beyond) {\n+            if (index < 0 || index >= beyond) {\n+                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n+            }\n+        }\n+\n+        protected void checkModCount() {\n+            if (list.modCount != expectedModCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+    }\n+    \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/list/CursorableLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/CursorableLinkedList.java,v 1.1 2003/12/24 01:15:40 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+/**\n+ * A <code>List</code> implementation with a <code>ListIterator</code> that\n+ * allows concurrent modifications to the underlying list.\n+ * <p>\n+ * This implementation supports all of the optional {@link List} operations.\n+ * It extends <code>AbstractLinkedList</code> and thus provides the\n+ * stack/queue/dequeue operations available in {@link java.util.LinkedList}.\n+ * <p>\n+ * The main feature of this class is the ability to modify the list and the\n+ * iterator at the same time. Both the {@link #listIterator()} and {@link #cursor()}\n+ * methods provides access to a <code>Cursor</code> instance which extends\n+ * <code>ListIterator</code>. The cursor allows changes to the list concurrent\n+ * with changes to the iterator. Note that the {@link #iterator()} method and\n+ * sublists  do <b>not</b> provide this cursor behaviour.\n+ * <p>\n+ * The <code>Cursor</code> class is provided partly for backwards compatability\n+ * and partly because it allows the cursor to be directly closed. Closing the\n+ * cursor is optional because references are held via a <code>WeakReference</code>.\n+ * For most purposes, simply modify the iterator and list at will, and then let\n+ * the garbage collector to the rest.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n+ *\n+ * @see java.util.LinkedList\n+ * @since Commons Collections 1.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/24 01:15:40 $\n+ * \n+ * @author Rodney Waldhoff\n+ * @author Janek Bogucki\n+ * @author Simon Kitching\n+ * @author Stephen Colebourne\n+ */\n+public class CursorableLinkedList extends AbstractLinkedList implements Serializable {\n+\n+    /** Ensure serialization compatability */\n+    private static final long serialVersionUID = 8836393098519411393L;\n+\n+    /** A list of the cursor currently open on this list */\n+    protected transient List cursors = new ArrayList();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that creates.\n+     */\n+    public CursorableLinkedList() {\n+        super();\n+        init(); // must call init() as use super();\n+    }\n+\n+    /**\n+     * Constructor that copies the specified collection\n+     * \n+     * @param coll  the collection to copy\n+     */\n+    public CursorableLinkedList(Collection coll) {\n+        super(coll);\n+    }\n+\n+    /**\n+     * The equivalent of a default constructor called\n+     * by any constructor and by <code>readObject</code>.\n+     */\n+    protected void init() {\n+        super.init();\n+        cursors = new ArrayList();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an iterator that does <b>not</b> support concurrent modification.\n+     * <p>\n+     * If the underlying list is modified while iterating using this iterator\n+     * a ConcurrentModificationException will occur.\n+     * The cursor behaviour is available via {@link #listIterator()}.\n+     * \n+     * @return a new iterator that does <b>not</b> support concurrent modification\n+     */\n+    public Iterator iterator() {\n+        return super.listIterator(0);\n+    }\n+\n+    /**\n+     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * \n+     * @return a new cursor iterator\n+     */\n+    public ListIterator listIterator() {\n+        return cursor(0);\n+    }\n+\n+    /**\n+     * Returns a cursor iterator that allows changes to the underlying list in parallel.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * \n+     * @param fromIndex  the index to start from\n+     * @return a new cursor iterator\n+     */\n+    public ListIterator listIterator(int fromIndex) {\n+        return cursor(fromIndex);\n+    }\n+\n+    /**\n+     * Returns a {@link Cursor} for iterating through the elements of this list.\n+     * <p>\n+     * A <code>Cursor</code> is a <code>ListIterator</code> with an additional\n+     * <code>close()</code> method. Calling this method immediately discards the\n+     * references to the cursor. If it is not called, then the garbage collector\n+     * will still remove the reference as it is held via a <code>WeakReference</code>.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * <p>\n+     * The {@link #listIterator()} method returns the same as this method, and can\n+     * be cast to a <code>Cursor</code> if the <code>close</code> method is required.\n+     *\n+     * @return a new cursor iterator\n+     */\n+    public CursorableLinkedList.Cursor cursor() {\n+        return cursor(0);\n+    }\n+\n+    /**\n+     * Returns a {@link Cursor} for iterating through the elements of this list\n+     * starting from a specified index.\n+     * <p>\n+     * A <code>Cursor</code> is a <code>ListIterator</code> with an additional\n+     * <code>close()</code> method. Calling this method immediately discards the\n+     * references to the cursor. If it is not called, then the garbage collector\n+     * will still remove the reference as it is held via a <code>WeakReference</code>.\n+     * <p>\n+     * The cursor enables iteration and list changes to occur in any order without\n+     * invalidating the iterator (from one thread). When elements are added to the\n+     * list, an event is fired to all active cursors enabling them to adjust to the\n+     * change in the list.\n+     * <p>\n+     * When the \"current\" (i.e., last returned by {@link ListIterator#next}\n+     * or {@link ListIterator#previous}) element of the list is removed,\n+     * the cursor automatically adjusts to the change (invalidating the\n+     * last returned value such that it cannot be removed).\n+     * <p>\n+     * The {@link #listIterator(int)} method returns the same as this method, and can\n+     * be cast to a <code>Cursor</code> if the <code>close</code> method is required.\n+     *\n+     * @param fromIndex  the index to start from\n+     * @return a new cursor iterator\n+     * @throws IndexOutOfBoundsException if the index is out of range\n+     *      (index &lt; 0 || index &gt; size()).\n+     */\n+    public CursorableLinkedList.Cursor cursor(int fromIndex) {\n+        Cursor cursor = new Cursor(this, fromIndex);\n+        registerCursor(cursor);\n+        return cursor;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Updates the node with a new value.\n+     * This implementation sets the value on the node.\n+     * Subclasses can override this to record the change.\n+     * \n+     * @param node  node to update\n+     * @param value  new value of the node\n+     */\n+    protected void updateNode(Node node, Object value) {\n+        super.updateNode(node, value);\n+        broadcastNodeChanged(node);\n+    }\n+\n+    /**\n+     * Inserts a new node into the list.\n+     *\n+     * @param nodeToInsert  new node to insert\n+     * @param insertBeforeNode  node to insert before\n+     * @throws NullPointerException if either node is null\n+     */\n+    protected void addNode(Node nodeToInsert, Node insertBeforeNode) {\n+        super.addNode(nodeToInsert, insertBeforeNode);\n+        broadcastNodeInserted(nodeToInsert);\n+    }\n+    \n+    /**\n+     * Removes the specified node from the list.\n+     *\n+     * @param node  the node to remove\n+     * @throws NullPointerException if <code>node</code> is null\n+     */\n+    protected void removeNode(Node node) {\n+        super.removeNode(node);\n+        broadcastNodeRemoved(node);\n+    }\n+\n+    /**\n+     * Removes all nodes by iteration.\n+     */\n+    protected void removeAllNodes() {\n+        if (size() > 0) {\n+            // superclass implementation would break all the iterators\n+            Iterator it = iterator();\n+            while (it.hasNext()) {\n+                it.next();\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Registers a cursor to be notified of changes to this list.\n+     * \n+     * @param cursor  the cursor to register\n+     */\n+    protected void registerCursor(Cursor cursor) {\n+        // We take this opportunity to clean the cursors list\n+        // of WeakReference objects to garbage-collected cursors.\n+        for (Iterator it = cursors.iterator(); it.hasNext();) {\n+            WeakReference ref = (WeakReference) it.next();\n+            if (ref.get() == null) {\n+                it.remove();\n+            }\n+        }\n+        cursors.add(new WeakReference(cursor));\n+    }\n+\n+    /**\n+     * Deregisters a cursor from the list to be notified of changes.\n+     * \n+     * @param cursor  the cursor to deregister\n+     */\n+    protected void unregisterCursor(Cursor cursor) {\n+        for (Iterator it = cursors.iterator(); it.hasNext();) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cur = (Cursor) ref.get();\n+            if (cur == null) {\n+                // some other unrelated cursor object has been \n+                // garbage-collected; let's take the opportunity to\n+                // clean up the cursors list anyway..\n+                it.remove();\n+\n+            } else if (cur == cursor) {\n+                ref.clear();\n+                it.remove();\n+                break;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was changed.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeChanged(Node node) {\n+        Iterator it = cursors.iterator();\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeChanged(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was just removed from my list.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeRemoved(Node node) {\n+        Iterator it = cursors.iterator();\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeRemoved(node);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Informs all of my registered cursors that the specified\n+     * element was just added to my list.\n+     * \n+     * @param node  the node that was changed\n+     */\n+    protected void broadcastNodeInserted(Node node) {\n+        Iterator it = cursors.iterator();\n+        while (it.hasNext()) {\n+            WeakReference ref = (WeakReference) it.next();\n+            Cursor cursor = (Cursor) ref.get();\n+            if (cursor == null) {\n+                it.remove(); // clean up list\n+            } else {\n+                cursor.nodeInserted(node);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Serializes the data held in this object to the stream specified.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Deserializes the data held in this object to the stream specified.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * An extended <code>ListIterator</code> that allows concurrent changes to\n+     * the underlying list.\n+     */\n+    public static class Cursor extends AbstractLinkedList.LinkedListIterator {\n+        /** Is the cursor valid (not closed) */\n+        boolean valid = true;\n+        /** Is the next index valid */\n+        boolean nextIndexValid = true;\n+        \n+        /**\n+         * Constructs a new cursor.\n+         * \n+         * @param index  the index to start from\n+         */\n+        protected Cursor(CursorableLinkedList parent, int index) {\n+            super(parent, index);\n+            valid = true;\n+        }\n+        \n+        /**\n+         * Adds an object to the list.\n+         * The object added here will be the new 'previous' in the iterator.\n+         * \n+         * @param obj  the object to add\n+         */\n+        public void add(Object obj) {\n+            super.add(obj);\n+            // add on iterator does not return the added element\n+            next = next.next;\n+        }\n+\n+        /**\n+         * Gets the index of the next element to be returned.\n+         * \n+         * @return the next index\n+         */\n+        public int nextIndex() {\n+            if (nextIndexValid == false) {\n+                if (next == list.header) {\n+                    nextIndex = list.size();\n+                } else {\n+                    int pos = 0;\n+                    Node temp = list.header.next;\n+                    while (temp != next) {\n+                        pos++;\n+                        temp = temp.next;\n+                    }\n+                    nextIndex = pos;\n+                }\n+                nextIndexValid = true;\n+            }\n+            return nextIndex;\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has changed.\n+         * \n+         * @param node  the node that changed\n+         */\n+        protected void nodeChanged(Node node) {\n+            // do nothing\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has been removed.\n+         * \n+         * @param node  the node that was removed\n+         */\n+        protected void nodeRemoved(Node node) {\n+            if (node == next) {\n+                next = node.next;\n+            } else if (node == current) {\n+                current = null;\n+                nextIndex--;\n+            } else {\n+                nextIndexValid = false;\n+            }\n+        }\n+\n+        /**\n+         * Handle event from the list when a node has been added.\n+         * \n+         * @param node  the node that was added\n+         */\n+        protected void nodeInserted(Node node) {\n+            if (node.previous == current) {\n+                next = node;\n+            } else if (next.previous == node) {\n+                next = node;\n+            } else {\n+                nextIndexValid = false;\n+            }\n+        }\n+\n+        /**\n+         * Override superclass modCount check, and replace it with our valid flag.\n+         */\n+        protected void checkModCount() {\n+            if (!valid) {\n+                throw new ConcurrentModificationException(\"Cursor closed\");\n+            }\n+        }\n+\n+        /**\n+         * Mark this cursor as no longer being needed. Any resources\n+         * associated with this cursor are immediately released.\n+         * In previous versions of this class, it was mandatory to close\n+         * all cursor objects to avoid memory leaks. It is <i>no longer</i>\n+         * necessary to call this close method; an instance of this class\n+         * can now be treated exactly like a normal iterator.\n+         */\n+        public void close() {\n+            if (valid) {\n+                ((CursorableLinkedList) list).unregisterCursor(this);\n+                valid = false;\n+            }\n+        }\n+    }\n+}\n+\n+//class CursorableSubList extends CursorableLinkedList implements List {\n+//\n+//    //--- constructors -----------------------------------------------\n+//\n+//    CursorableSubList(CursorableLinkedList list, int from, int to) {\n+//        if(0 > from || list.size() < to) {\n+//            throw new IndexOutOfBoundsException();\n+//        } else if(from > to) {\n+//            throw new IllegalArgumentException();\n+//        }\n+//        _list = list;\n+//        if(from < list.size()) {\n+//            _head.setNext(_list.getListableAt(from));\n+//            _pre = (null == _head.next()) ? null : _head.next().prev();\n+//        } else {\n+//            _pre = _list.getListableAt(from-1);\n+//        }\n+//        if(from == to) {\n+//            _head.setNext(null);\n+//            _head.setPrev(null);\n+//            if(to < list.size()) {\n+//                _post = _list.getListableAt(to);\n+//            } else {\n+//                _post = null;\n+//            }\n+//        } else {\n+//            _head.setPrev(_list.getListableAt(to-1));\n+//            _post = _head.prev().next();\n+//        }\n+//        _size = to - from;\n+//        _modCount = _list._modCount;\n+//    }\n+//\n+//    //--- public methods ------------------------------------------\n+//\n+//    public void clear() {\n+//        checkForComod();\n+//        Iterator it = iterator();\n+//        while(it.hasNext()) {\n+//            it.next();\n+//            it.remove();\n+//        }\n+//    }\n+//\n+//    public Iterator iterator() {\n+//        checkForComod();\n+//        return super.iterator();\n+//    }\n+//\n+//    public int size() {\n+//        checkForComod();\n+//        return super.size();\n+//    }\n+//\n+//    public boolean isEmpty() {\n+//        checkForComod();\n+//        return super.isEmpty();\n+//    }\n+//\n+//    public Object[] toArray() {\n+//        checkForComod();\n+//        return super.toArray();\n+//    }\n+//\n+//    public Object[] toArray(Object a[]) {\n+//        checkForComod();\n+//        return super.toArray(a);\n+//    }\n+//\n+//    public boolean contains(Object o) {\n+//        checkForComod();\n+//        return super.contains(o);\n+//    }\n+//\n+//    public boolean remove(Object o) {\n+//        checkForComod();\n+//        return super.remove(o);\n+//    }\n+//\n+//    public Object removeFirst() {\n+//        checkForComod();\n+//        return super.removeFirst();\n+//    }\n+//\n+//    public Object removeLast() {\n+//        checkForComod();\n+//        return super.removeLast();\n+//    }\n+//\n+//    public boolean addAll(Collection c) {\n+//        checkForComod();\n+//        return super.addAll(c);\n+//    }\n+//\n+//    public boolean add(Object o) {\n+//        checkForComod();\n+//        return super.add(o);\n+//    }\n+//\n+//    public boolean addFirst(Object o) {\n+//        checkForComod();\n+//        return super.addFirst(o);\n+//    }\n+//\n+//    public boolean addLast(Object o) {\n+//        checkForComod();\n+//        return super.addLast(o);\n+//    }\n+//\n+//    public boolean removeAll(Collection c) {\n+//        checkForComod();\n+//        return super.removeAll(c);\n+//    }\n+//\n+//    public boolean containsAll(Collection c) {\n+//        checkForComod();\n+//        return super.containsAll(c);\n+//    }\n+//\n+//    public boolean addAll(int index, Collection c) {\n+//        checkForComod();\n+//        return super.addAll(index,c);\n+//    }\n+//\n+//    public int hashCode() {\n+//        checkForComod();\n+//        return super.hashCode();\n+//    }\n+//\n+//    public boolean retainAll(Collection c) {\n+//        checkForComod();\n+//        return super.retainAll(c);\n+//    }\n+//\n+//    public Object set(int index, Object element) {\n+//        checkForComod();\n+//        return super.set(index,element);\n+//    }\n+//\n+//    public boolean equals(Object o) {\n+//        checkForComod();\n+//        return super.equals(o);\n+//    }\n+//\n+//    public Object get(int index) {\n+//        checkForComod();\n+//        return super.get(index);\n+//    }\n+//\n+//    public Object getFirst() {\n+//        checkForComod();\n+//        return super.getFirst();\n+//    }\n+//\n+//    public Object getLast() {\n+//        checkForComod();\n+//        return super.getLast();\n+//    }\n+//\n+//    public void add(int index, Object element) {\n+//        checkForComod();\n+//        super.add(index,element);\n+//    }\n+//\n+//    public ListIterator listIterator(int index) {\n+//        checkForComod();\n+//        return super.listIterator(index);\n+//    }\n+//\n+//    public Object remove(int index) {\n+//        checkForComod();\n+//        return super.remove(index);\n+//    }\n+//\n+//    public int indexOf(Object o) {\n+//        checkForComod();\n+//        return super.indexOf(o);\n+//    }\n+//\n+//    public int lastIndexOf(Object o) {\n+//        checkForComod();\n+//        return super.lastIndexOf(o);\n+//    }\n+//\n+//    public ListIterator listIterator() {\n+//        checkForComod();\n+//        return super.listIterator();\n+//    }\n+//\n+//    public List subList(int fromIndex, int toIndex) {\n+//        checkForComod();\n+//        return super.subList(fromIndex,toIndex);\n+//    }\n+//\n+//    //--- protected methods ------------------------------------------\n+//\n+//    /**\n+//     * Inserts a new <i>value</i> into my\n+//     * list, after the specified <i>before</i> element, and before the\n+//     * specified <i>after</i> element\n+//     *\n+//     * @return the newly created {@link CursorableLinkedList.Listable}\n+//     */\n+//    protected Listable insertListable(Listable before, Listable after, Object value) {\n+//        _modCount++;\n+//        _size++;\n+//        Listable elt = _list.insertListable((null == before ? _pre : before), (null == after ? _post : after),value);\n+//        if(null == _head.next()) {\n+//            _head.setNext(elt);\n+//            _head.setPrev(elt);\n+//        }\n+//        if(before == _head.prev()) {\n+//            _head.setPrev(elt);\n+//        }\n+//        if(after == _head.next()) {\n+//            _head.setNext(elt);\n+//        }\n+//        broadcastListableInserted(elt);\n+//        return elt;\n+//    }\n+//\n+//    /**\n+//     * Removes the given {@link CursorableLinkedList.Listable} from my list.\n+//     */\n+//    protected void removeListable(Listable elt) {\n+//        _modCount++;\n+//        _size--;\n+//        if(_head.next() == elt && _head.prev() == elt) {\n+//            _head.setNext(null);\n+//            _head.setPrev(null);\n+//        }\n+//        if(_head.next() == elt) {\n+//            _head.setNext(elt.next());\n+//        }\n+//        if(_head.prev() == elt) {\n+//            _head.setPrev(elt.prev());\n+//        }\n+//        _list.removeListable(elt);\n+//        broadcastListableRemoved(elt);\n+//    }\n+//\n+//    /**\n+//     * Test to see if my underlying list has been modified\n+//     * by some other process.  If it has, throws a\n+//     * {@link ConcurrentModificationException}, otherwise\n+//     * quietly returns.\n+//     *\n+//     * @throws ConcurrentModificationException\n+//     */\n+//    protected void checkForComod() throws ConcurrentModificationException {\n+//        if(_modCount != _list._modCount) {\n+//            throw new ConcurrentModificationException();\n+//        }\n+//    }\n+//\n+//    //--- protected attributes ---------------------------------------\n+//\n+//    /** My underlying list */\n+//    protected CursorableLinkedList _list = null;\n+//\n+//    /** The element in my underlying list preceding the first element in my list. */\n+//    protected Listable _pre = null;\n+//\n+//    /** The element in my underlying list following the last element in my list. */\n+//    protected Listable _post = null;\n+//\n+//}\n--- a/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n+++ b/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java,v 1.1 2003/12/11 00:18:06 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/list/NodeCachingLinkedList.java,v 1.2 2003/12/24 01:15:40 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import java.util.Collection;\n \n /**\n- * A linked list implementation that caches the nodes used internally to prevent\n- * unnecessary object creates and deletion. This results in a performance\n- * improvement for long-lived lists which both add and remove.\n+ * A <code>List</code> implementation that stores a cache of internal Node objects\n+ * in an effort to reduce wasteful object creation.\n+ * <p>\n+ * A linked list creates one Node for each item of data added. This can result in\n+ * a lot of object creation and garbage collection. This implementation seeks to\n+ * avoid that by maintaining a store of cached nodes.\n+ * <p>\n+ * This implementation is suitable for long-lived lists where both add and remove\n+ * are used. Short-lived lists, or lists which only grow will have worse performance\n+ * using this class.\n+ * <p>\n+ * <b>Note that this implementation is not synchronized.</b>\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/12/11 00:18:06 $\n+ * @version $Revision: 1.2 $ $Date: 2003/12/24 01:15:40 $\n  * \n  * @author Jeff Varszegi\n  * @author Rich Dougherty\n     //-----------------------------------------------------------------------\n     /**\n      * Gets the maximum size of the cache.\n+     * \n+     * @return the maximum cache size\n      */\n     protected int getMaximumCacheSize() {\n         return maximumCacheSize;\n \n     /**\n      * Sets the maximum size of the cache.\n+     * \n+     * @param maximumCacheSize  the new maximum cache size\n      */\n     protected void setMaximumCacheSize(int maximumCacheSize) {\n         this.maximumCacheSize = maximumCacheSize;\n      * {@link #cacheSize} is decreased accordingly. The node that is returned\n      * will have <code>null</code> values for next, previous and element.\n      *\n-     * @return A node, or <code>null</code> if there are no nodes in the cache.\n+     * @return a node, or <code>null</code> if there are no nodes in the cache.\n      */\n     protected Node getNodeFromCache() {\n         if (cacheSize == 0) {\n         return cachedNode;\n     }\n     \n+    /**\n+     * Checks whether the cache is full.\n+     * \n+     * @return true if the cache is full\n+     */\n     protected boolean isCacheFull() {\n         return cacheSize >= maximumCacheSize;\n     }\n     \n     /**\n-     * Adds a node to the cache, if the cache isn't full. The node's contents\n-     * are cleared to so they can be garbage collected.\n+     * Adds a node to the cache, if the cache isn't full.\n+     * The node's contents are cleared to so they can be garbage collected.\n+     * \n+     * @param node  the node to add to the cache\n      */\n     protected void addNodeToCache(Node node) {\n         if (isCacheFull()) {\n-            // Don't cache the node.\n+            // don't cache the node.\n             return;\n         }\n-        // Clear the node's contents and add it to the cache.\n+        // clear the node's contents and add it to the cache.\n         Node nextCachedNode = firstCachedNode;\n         node.previous = null;\n         node.next = nextCachedNode;\n \n     //-----------------------------------------------------------------------    \n     /**\n-     * Create a node, getting it from the cache if possible.\n-     */\n-    protected Node createHeaderNode() {\n+     * Creates a new node, either by reusing one from the cache or creating\n+     * a new one.\n+     * \n+     * @param value  value of the new node\n+     * @return the newly created node\n+     */\n+    protected Node createNode(Object value) {\n         Node cachedNode = getNodeFromCache();\n         if (cachedNode == null) {\n-            return super.createHeaderNode();\n+            return super.createNode(value);\n         } else {\n-            return cachedNode;\n-        }\n-    }\n-    \n-    /**\n-     * Creates a new node with the specified properties, using a cached Node\n-     * if possible.\n-     * \n-     * @param previous  node to precede the new node\n-     * @param next  node to follow the new node\n-     * @param value  value of the new node\n-     */\n-    protected Node createNode(Node previous, Node next, Object value) {\n-        Node cachedNode = getNodeFromCache();\n-        if (cachedNode == null) {\n-            return super.createNode(previous, next, value);\n-        } else {\n-            cachedNode.next = next;\n-            cachedNode.previous = previous;\n             cachedNode.value = value;\n             return cachedNode;\n         }\n     }\n \n     /**\n-     * Calls the superclass' implementation then calls\n-     * <code>addNodeToCache</code> on the node which has \n-     * been removed.\n+     * Removes the node from the list, storing it in the cache for reuse\n+     * if the cache is not yet full.\n+     * \n+     * @param node  the node to remove\n      */\n     protected void removeNode(Node node) {\n         super.removeNode(node);\n         addNodeToCache(node);\n     }\n     \n+    /**\n+     * Removes all the nodes from the list, storing as many as required in the\n+     * cache for reuse.\n+     * \n+     * @param node  the node to remove\n+     */\n     protected void removeAllNodes() {\n         // Add the removed nodes to the cache, then remove the rest.\n         // We can add them to the cache before removing them, since\n--- a/src/test/org/apache/commons/collections/list/TestAll.java\n+++ b/src/test/org/apache/commons/collections/list/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestAll.java,v 1.2 2003/12/11 00:18:06 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestAll.java,v 1.3 2003/12/24 01:15:40 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/12/11 00:18:06 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/24 01:15:40 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n+        suite.addTest(TestCursorableLinkedList.suite());\n         suite.addTest(TestNodeCachingLinkedList.suite());\n         \n         suite.addTest(TestFixedSizeList.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/list/TestCursorableLinkedList.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/list/TestCursorableLinkedList.java,v 1.1 2003/12/24 01:15:40 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.list;\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Test class.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/12/24 01:15:40 $\n+ * \n+ * @author Rodney Waldhoff\n+ * @author Simon Kitching\n+ */\n+public class TestCursorableLinkedList extends TestAbstractLinkedList {\n+    public TestCursorableLinkedList(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestCursorableLinkedList.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestCursorableLinkedList.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    private CursorableLinkedList list = null;\n+\n+    public void setUp() {\n+        list = new CursorableLinkedList();\n+    }\n+\n+    public List makeEmptyList() {\n+        return new CursorableLinkedList();\n+    }\n+\n+    public void testAdd() {\n+        assertEquals(\"[]\",list.toString());\n+        assertTrue(list.add(new Integer(1)));\n+        assertEquals(\"[1]\",list.toString());\n+        assertTrue(list.add(new Integer(2)));\n+        assertEquals(\"[1, 2]\",list.toString());\n+        assertTrue(list.add(new Integer(3)));\n+        assertEquals(\"[1, 2, 3]\",list.toString());\n+        assertTrue(list.addFirst(new Integer(0)));\n+        assertEquals(\"[0, 1, 2, 3]\",list.toString());\n+        assertTrue(list.addLast(new Integer(4)));\n+        assertEquals(\"[0, 1, 2, 3, 4]\",list.toString());\n+        list.add(0,new Integer(-2));\n+        assertEquals(\"[-2, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(1,new Integer(-1));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4]\",list.toString());\n+        list.add(7,new Integer(5));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5]\",list.toString());\n+\n+        java.util.List list2 = new java.util.LinkedList();\n+        list2.add(\"A\");\n+        list2.add(\"B\");\n+        list2.add(\"C\");\n+\n+        assertTrue(list.addAll(list2));\n+        assertEquals(\"[-2, -1, 0, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+        assertTrue(list.addAll(3,list2));\n+        assertEquals(\"[-2, -1, 0, A, B, C, 1, 2, 3, 4, 5, A, B, C]\",list.toString());\n+    }\n+\n+    public void testClear() {\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        list.add(\"element\");\n+        assertEquals(1,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        list.add(\"element1\");\n+        list.add(\"element2\");\n+        assertEquals(2,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+\n+        for(int i=0;i<1000;i++) {\n+            list.add(new Integer(i));\n+        }\n+        assertEquals(1000,list.size());\n+        assertTrue(!list.isEmpty());\n+\n+        list.clear();\n+        assertEquals(0,list.size());\n+        assertTrue(list.isEmpty());\n+    }\n+\n+    public void testContains() {\n+        assertTrue(!list.contains(\"A\"));\n+        assertTrue(list.add(\"A\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.add(\"B\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.addFirst(\"a\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.remove(\"a\"));\n+        assertTrue(list.contains(\"A\"));\n+        assertTrue(list.remove(\"A\"));\n+        assertTrue(!list.contains(\"A\"));\n+    }\n+\n+    public void testContainsAll() {\n+        assertTrue(list.containsAll(list));\n+        java.util.List list2 = new java.util.LinkedList();\n+        assertTrue(list.containsAll(list2));\n+        list2.add(\"A\");\n+        assertTrue(!list.containsAll(list2));\n+        list.add(\"B\");\n+        list.add(\"A\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add(\"B\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add(\"C\");\n+        assertTrue(!list.containsAll(list2));\n+        list.add(\"C\");\n+        assertTrue(list.containsAll(list2));\n+        list2.add(\"C\");\n+        assertTrue(list.containsAll(list2));\n+        assertTrue(list.containsAll(list));\n+    }\n+\n+    public void testCursorNavigation() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"1\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"1\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"1\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"4\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"5\",it.next());\n+        assertTrue(!it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"5\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"4\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"3\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"2\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(\"1\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        it.close();\n+    }\n+\n+    public void testCursorSet() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        assertEquals(\"1\",it.next());\n+        it.set(\"a\");\n+        assertEquals(\"a\",it.previous());\n+        it.set(\"A\");\n+        assertEquals(\"A\",it.next());\n+        assertEquals(\"2\",it.next());\n+        it.set(\"B\");\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"4\",it.next());\n+        it.set(\"D\");\n+        assertEquals(\"5\",it.next());\n+        it.set(\"E\");\n+        assertEquals(\"[A, B, 3, D, E]\",list.toString());\n+        it.close();\n+    }\n+\n+    public void testCursorRemove() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        try {\n+            it.remove();\n+            fail();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\",it.next());\n+        assertEquals(\"2\",it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"3\",it.previous());\n+        assertEquals(\"1\",it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\",it.next());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[4]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+        it.close();\n+    }\n+\n+    public void testCursorAdd() {\n+        CursorableLinkedList.Cursor it = list.cursor();\n+        it.add(\"1\");\n+        assertEquals(\"[1]\",list.toString());\n+        it.add(\"3\");\n+        assertEquals(\"[1, 3]\",list.toString());\n+        it.add(\"5\");\n+        assertEquals(\"[1, 3, 5]\",list.toString());\n+        assertEquals(\"5\",it.previous());\n+        it.add(\"4\");\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        assertEquals(\"3\",it.previous());\n+        it.add(\"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.close();\n+    }\n+\n+    public void testCursorConcurrentModification() {\n+        // this test verifies that cursors remain valid when the list\n+        // is modified via other means.\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+        list.add(\"7\");\n+        list.add(\"9\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        CursorableLinkedList.Cursor c2 = list.cursor();\n+        Iterator li = list.iterator();\n+        \n+        // test cursors remain valid when list modified by std Iterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\",li.next());\n+        assertEquals(\"2\",li.next());\n+        li.remove();\n+        assertEquals(\"3\",li.next());\n+        assertEquals(\"1\",c1.next());\n+        assertEquals(\"3\",c1.next());\n+        assertEquals(\"1\",c2.next());\n+        \n+        // test cursor c1 can remove elements from previously modified list\n+        // test cursor c2 skips elements removed via different cursor\n+        c1.remove();\n+        assertEquals(\"5\",c2.next());\n+        c2.add(\"6\");\n+        assertEquals(\"5\",c1.next());\n+        assertEquals(\"6\",c1.next());\n+        assertEquals(\"7\",c1.next());\n+        \n+        // test cursors remain valid when list mod via CursorableLinkedList\n+        // test cursor remains valid when elements inserted into list before\n+        // the current position of the cursor.\n+        list.add(0, \"0\");\n+\n+        // test cursor remains valid when element inserted immediately after\n+        // current element of a cursor, and the element is seen on the\n+        // next call to the next method of that cursor.\n+        list.add(5, \"8\");\n+\n+        assertEquals(\"8\",c1.next());\n+        assertEquals(\"9\",c1.next());\n+        c1.add(\"10\");\n+        assertEquals(\"7\",c2.next());\n+        assertEquals(\"8\",c2.next());\n+        assertEquals(\"9\",c2.next());\n+        assertEquals(\"10\",c2.next());\n+        \n+        try {\n+            c2.next();\n+            fail();\n+        } catch (NoSuchElementException nse) {}\n+        \n+        try {\n+            li.next();\n+            fail();\n+        } catch (ConcurrentModificationException cme) {}\n+        \n+        c1.close();  // not necessary\n+        c2.close();  // not necessary\n+    }\n+    \n+    public void testCursorNextIndexMid() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        Iterator li = list.iterator();\n+        \n+        // test cursors remain valid when list modified by std Iterator\n+        // test cursors skip elements removed via ListIterator\n+        assertEquals(\"1\", li.next());\n+        assertEquals(\"2\", li.next());\n+        li.remove();\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"3\", c1.next());\n+    }\n+    \n+    public void testCursorNextIndexFirst() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        \n+        assertEquals(0, c1.nextIndex());\n+        list.remove(0);\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"2\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"3\", c1.next());\n+    }\n+    \n+    public void testCursorNextIndexAddBefore() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        \n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        list.add(0, \"0\");\n+        assertEquals(2, c1.nextIndex());\n+        assertEquals(\"2\", c1.next());\n+    }\n+    \n+    public void testCursorNextIndexAddNext() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        \n+        assertEquals(0, c1.nextIndex());\n+        list.add(0, \"0\");\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"0\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+    }\n+    \n+    public void testCursorNextIndexAddAfter() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"5\");\n+\n+        CursorableLinkedList.Cursor c1 = list.cursor();\n+        \n+        assertEquals(0, c1.nextIndex());\n+        list.add(1, \"0\");\n+        assertEquals(0, c1.nextIndex());\n+        assertEquals(\"1\", c1.next());\n+        assertEquals(1, c1.nextIndex());\n+        assertEquals(\"0\", c1.next());\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        assertTrue(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+        list.add(\"A\");\n+        assertTrue(list.equals(list));\n+        assertEquals(list.hashCode(),list.hashCode());\n+\n+        CursorableLinkedList list2 = new CursorableLinkedList();\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+\n+        java.util.List list3 = new java.util.LinkedList();\n+        assertTrue(!list.equals(list3));\n+        assertTrue(!list3.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list2.add(\"A\");\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(!list2.equals(list3));\n+        assertTrue(!list3.equals(list2));\n+\n+        list3.add(\"A\");\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add(\"B\");\n+        assertTrue(list.equals(list));\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+        assertTrue(!list.equals(list3));\n+        assertTrue(!list3.equals(list));\n+\n+        list2.add(\"B\");\n+        list3.add(\"B\");\n+        assertTrue(list.equals(list));\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add(\"C\");\n+        list2.add(\"C\");\n+        list3.add(\"C\");\n+        assertTrue(list.equals(list));\n+        assertTrue(list.equals(list2));\n+        assertTrue(list2.equals(list));\n+        assertTrue(list2.equals(list3));\n+        assertTrue(list3.equals(list2));\n+        assertEquals(list.hashCode(),list2.hashCode());\n+        assertEquals(list2.hashCode(),list3.hashCode());\n+\n+        list.add(\"D\");\n+        list2.addFirst(\"D\");\n+        assertTrue(list.equals(list));\n+        assertTrue(!list.equals(list2));\n+        assertTrue(!list2.equals(list));\n+    }\n+\n+    public void testGet() {\n+        try {\n+            list.get(0);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        assertTrue(list.add(\"A\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertTrue(list.add(\"B\"));\n+        assertEquals(\"A\",list.get(0));\n+        assertEquals(\"B\",list.get(1));\n+\n+        try {\n+            list.get(-1);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+\n+        try {\n+            list.get(2);\n+            fail(\"shouldn't get here\");\n+        } catch(IndexOutOfBoundsException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testIndexOf() {\n+        assertEquals(-1,list.indexOf(\"A\"));\n+        assertEquals(-1,list.lastIndexOf(\"A\"));\n+        list.add(\"A\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(-1,list.indexOf(\"B\"));\n+        assertEquals(-1,list.lastIndexOf(\"B\"));\n+        list.add(\"B\");\n+        assertEquals(0,list.indexOf(\"A\"));\n+        assertEquals(0,list.lastIndexOf(\"A\"));\n+        assertEquals(1,list.indexOf(\"B\"));\n+        assertEquals(1,list.lastIndexOf(\"B\"));\n+        list.addFirst(\"B\");\n+        assertEquals(1,list.indexOf(\"A\"));\n+        assertEquals(1,list.lastIndexOf(\"A\"));\n+        assertEquals(0,list.indexOf(\"B\"));\n+        assertEquals(2,list.lastIndexOf(\"B\"));\n+    }\n+\n+    public void testIsEmpty() {\n+        assertTrue(list.isEmpty());\n+        list.add(\"element\");\n+        assertTrue(!list.isEmpty());\n+        list.remove(\"element\");\n+        assertTrue(list.isEmpty());\n+        list.add(\"element\");\n+        assertTrue(!list.isEmpty());\n+        list.clear();\n+        assertTrue(list.isEmpty());\n+    }\n+\n+    public void testIterator() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        Iterator it = list.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"1\",it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"2\",it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"3\",it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"4\",it.next());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"5\",it.next());\n+        assertTrue(!it.hasNext());\n+\n+        it = list.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"1\",it.next());\n+        it.remove();\n+        assertEquals(\"[2, 3, 4, 5]\",list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"2\",it.next());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"4\",it.next());\n+        it.remove();\n+        assertEquals(\"[5]\",list.toString());\n+        assertTrue(it.hasNext());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+        assertTrue(!it.hasNext());\n+    }\n+\n+    public void testListIteratorNavigation() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        ListIterator it = list.listIterator();\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1,it.previousIndex());\n+        assertEquals(0,it.nextIndex());\n+        assertEquals(\"1\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"1\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1,it.previousIndex());\n+        assertEquals(0,it.nextIndex());\n+        assertEquals(\"1\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"2\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1,it.previousIndex());\n+        assertEquals(2,it.nextIndex());\n+        assertEquals(\"2\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"2\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1,it.previousIndex());\n+        assertEquals(2,it.nextIndex());\n+        assertEquals(\"3\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(2,it.previousIndex());\n+        assertEquals(3,it.nextIndex());\n+        assertEquals(\"4\",it.next());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(3,it.previousIndex());\n+        assertEquals(4,it.nextIndex());\n+        assertEquals(\"5\",it.next());\n+        assertTrue(!it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(4,it.previousIndex());\n+        assertEquals(5,it.nextIndex());\n+        assertEquals(\"5\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(3,it.previousIndex());\n+        assertEquals(4,it.nextIndex());\n+        assertEquals(\"4\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(2,it.previousIndex());\n+        assertEquals(3,it.nextIndex());\n+        assertEquals(\"3\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(1,it.previousIndex());\n+        assertEquals(2,it.nextIndex());\n+        assertEquals(\"2\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(it.hasPrevious());\n+        assertEquals(0,it.previousIndex());\n+        assertEquals(1,it.nextIndex());\n+        assertEquals(\"1\",it.previous());\n+        assertTrue(it.hasNext());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(-1,it.previousIndex());\n+        assertEquals(0,it.nextIndex());\n+    }\n+\n+    public void testListIteratorSet() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        ListIterator it = list.listIterator();\n+        assertEquals(\"1\",it.next());\n+        it.set(\"a\");\n+        assertEquals(\"a\",it.previous());\n+        it.set(\"A\");\n+        assertEquals(\"A\",it.next());\n+        assertEquals(\"2\",it.next());\n+        it.set(\"B\");\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"4\",it.next());\n+        it.set(\"D\");\n+        assertEquals(\"5\",it.next());\n+        it.set(\"E\");\n+        assertEquals(\"[A, B, 3, D, E]\",list.toString());\n+    }\n+\n+    public void testListIteratorRemove() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        ListIterator it = list.listIterator();\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"1\",it.next());\n+        assertEquals(\"2\",it.next());\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        it.remove();\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",it.next());\n+        assertEquals(\"3\",it.previous());\n+        assertEquals(\"1\",it.previous());\n+        it.remove();\n+        assertEquals(\"[3, 4, 5]\",list.toString());\n+        assertTrue(!it.hasPrevious());\n+        assertEquals(\"3\",it.next());\n+        it.remove();\n+        assertEquals(\"[4, 5]\",list.toString());\n+        try {\n+            it.remove();\n+        } catch(IllegalStateException e) {\n+            // expected\n+        }\n+        assertEquals(\"4\",it.next());\n+        assertEquals(\"5\",it.next());\n+        it.remove();\n+        assertEquals(\"[4]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        it.remove();\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    public void testListIteratorAdd() {\n+        ListIterator it = list.listIterator();\n+        it.add(\"1\");\n+        assertEquals(\"[1]\",list.toString());\n+        it.add(\"3\");\n+        assertEquals(\"[1, 3]\",list.toString());\n+        it.add(\"5\");\n+        assertEquals(\"[1, 3, 5]\",list.toString());\n+        assertEquals(\"5\",it.previous());\n+        it.add(\"4\");\n+        assertEquals(\"[1, 3, 4, 5]\",list.toString());\n+        assertEquals(\"4\",it.previous());\n+        assertEquals(\"3\",it.previous());\n+        it.add(\"2\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+    }\n+\n+    public void testRemoveAll() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        HashSet set = new HashSet();\n+        set.add(\"A\");\n+        set.add(\"2\");\n+        set.add(\"C\");\n+        set.add(\"4\");\n+        set.add(\"D\");\n+\n+        assertTrue(list.removeAll(set));\n+        assertEquals(\"[1, 3, 5]\",list.toString());\n+        assertTrue(!list.removeAll(set));\n+    }\n+\n+    public void testRemoveByIndex() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        assertEquals(\"1\",list.remove(0));\n+        assertEquals(\"[2, 3, 4, 5]\",list.toString());\n+        assertEquals(\"3\",list.remove(1));\n+        assertEquals(\"[2, 4, 5]\",list.toString());\n+        assertEquals(\"4\",list.remove(1));\n+        assertEquals(\"[2, 5]\",list.toString());\n+        assertEquals(\"5\",list.remove(1));\n+        assertEquals(\"[2]\",list.toString());\n+        assertEquals(\"2\",list.remove(0));\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    public void testRemove() {\n+        list.add(\"1\");\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        assertEquals(\"[1, 1, 2, 3, 4, 5, 2, 3, 4, 5]\",list.toString());\n+        assertTrue(!list.remove(\"6\"));\n+        assertTrue(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4, 5]\",list.toString());\n+        assertTrue(list.remove(\"5\"));\n+        assertEquals(\"[1, 1, 2, 3, 4, 2, 3, 4]\",list.toString());\n+        assertTrue(!list.remove(\"5\"));\n+        assertTrue(list.remove(\"1\"));\n+        assertEquals(\"[1, 2, 3, 4, 2, 3, 4]\",list.toString());\n+        assertTrue(list.remove(\"1\"));\n+        assertEquals(\"[2, 3, 4, 2, 3, 4]\",list.toString());\n+        assertTrue(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 2, 3, 4]\",list.toString());\n+        assertTrue(list.remove(\"2\"));\n+        assertEquals(\"[3, 4, 3, 4]\",list.toString());\n+        assertTrue(list.remove(\"3\"));\n+        assertEquals(\"[4, 3, 4]\",list.toString());\n+        assertTrue(list.remove(\"3\"));\n+        assertEquals(\"[4, 4]\",list.toString());\n+        assertTrue(list.remove(\"4\"));\n+        assertEquals(\"[4]\",list.toString());\n+        assertTrue(list.remove(\"4\"));\n+        assertEquals(\"[]\",list.toString());\n+    }\n+\n+    public void testRetainAll() {\n+        list.add(\"1\");\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        list.add(\"5\");\n+\n+        HashSet set = new HashSet();\n+        set.add(\"A\");\n+        set.add(\"2\");\n+        set.add(\"C\");\n+        set.add(\"4\");\n+        set.add(\"D\");\n+\n+        assertTrue(list.retainAll(set));\n+        assertEquals(\"[2, 2, 4, 4]\",list.toString());\n+        assertTrue(!list.retainAll(set));\n+    }\n+\n+    public void testSet() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+        assertEquals(\"[1, 2, 3, 4, 5]\",list.toString());\n+        list.set(0,\"A\");\n+        assertEquals(\"[A, 2, 3, 4, 5]\",list.toString());\n+        list.set(1,\"B\");\n+        assertEquals(\"[A, B, 3, 4, 5]\",list.toString());\n+        list.set(2,\"C\");\n+        assertEquals(\"[A, B, C, 4, 5]\",list.toString());\n+        list.set(3,\"D\");\n+        assertEquals(\"[A, B, C, D, 5]\",list.toString());\n+        list.set(4,\"E\");\n+        assertEquals(\"[A, B, C, D, E]\",list.toString());\n+    }\n+\n+    public void testSubList() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        assertEquals(\"[A, B, C, D, E]\",list.toString());\n+        assertEquals(\"[A, B, C, D, E]\",list.subList(0,5).toString());\n+        assertEquals(\"[B, C, D, E]\",list.subList(1,5).toString());\n+        assertEquals(\"[C, D, E]\",list.subList(2,5).toString());\n+        assertEquals(\"[D, E]\",list.subList(3,5).toString());\n+        assertEquals(\"[E]\",list.subList(4,5).toString());\n+        assertEquals(\"[]\",list.subList(5,5).toString());\n+    }\n+\n+    public void testSubListAddEnd() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(5,5);\n+        sublist.add(\"F\");\n+        assertEquals(\"[A, B, C, D, E, F]\",list.toString());\n+        assertEquals(\"[F]\",sublist.toString());\n+        sublist.add(\"G\");\n+        assertEquals(\"[A, B, C, D, E, F, G]\",list.toString());\n+        assertEquals(\"[F, G]\",sublist.toString());\n+    }\n+\n+    public void testSubListAddBegin() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(0,0);\n+        sublist.add(\"a\");\n+        assertEquals(\"[a, A, B, C, D, E]\",list.toString());\n+        assertEquals(\"[a]\",sublist.toString());\n+        sublist.add(\"b\");\n+        assertEquals(\"[a, b, A, B, C, D, E]\",list.toString());\n+        assertEquals(\"[a, b]\",sublist.toString());\n+    }\n+\n+    public void testSubListAddMiddle() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(1,3);\n+        sublist.add(\"a\");\n+        assertEquals(\"[A, B, C, a, D, E]\",list.toString());\n+        assertEquals(\"[B, C, a]\",sublist.toString());\n+        sublist.add(\"b\");\n+        assertEquals(\"[A, B, C, a, b, D, E]\",list.toString());\n+        assertEquals(\"[B, C, a, b]\",sublist.toString());\n+    }\n+\n+    public void testSubListRemove() {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        List sublist = list.subList(1,4);\n+        assertEquals(\"[B, C, D]\",sublist.toString());\n+        assertEquals(\"[A, B, C, D, E]\",list.toString());\n+        sublist.remove(\"C\");\n+        assertEquals(\"[B, D]\",sublist.toString());\n+        assertEquals(\"[A, B, D, E]\",list.toString());\n+        sublist.remove(1);\n+        assertEquals(\"[B]\",sublist.toString());\n+        assertEquals(\"[A, B, E]\",list.toString());\n+        sublist.clear();\n+        assertEquals(\"[]\",sublist.toString());\n+        assertEquals(\"[A, E]\",list.toString());\n+    }\n+\n+    public void testToArray() {\n+        list.add(\"1\");\n+        list.add(\"2\");\n+        list.add(\"3\");\n+        list.add(\"4\");\n+        list.add(\"5\");\n+\n+        Object[] elts = list.toArray();\n+        assertEquals(\"1\",elts[0]);\n+        assertEquals(\"2\",elts[1]);\n+        assertEquals(\"3\",elts[2]);\n+        assertEquals(\"4\",elts[3]);\n+        assertEquals(\"5\",elts[4]);\n+        assertEquals(5,elts.length);\n+\n+        String[] elts2 = (String[])(list.toArray(new String[0]));\n+        assertEquals(\"1\",elts2[0]);\n+        assertEquals(\"2\",elts2[1]);\n+        assertEquals(\"3\",elts2[2]);\n+        assertEquals(\"4\",elts2[3]);\n+        assertEquals(\"5\",elts2[4]);\n+        assertEquals(5,elts2.length);\n+\n+        String[] elts3 = new String[5];\n+        assertSame(elts3,list.toArray(elts3));\n+        assertEquals(\"1\",elts3[0]);\n+        assertEquals(\"2\",elts3[1]);\n+        assertEquals(\"3\",elts3[2]);\n+        assertEquals(\"4\",elts3[3]);\n+        assertEquals(\"5\",elts3[4]);\n+        assertEquals(5,elts3.length);\n+\n+        String[] elts4 = new String[3];\n+        String[] elts4b = (String[])(list.toArray(elts4));\n+        assertTrue(elts4 != elts4b);\n+        assertEquals(\"1\",elts4b[0]);\n+        assertEquals(\"2\",elts4b[1]);\n+        assertEquals(\"3\",elts4b[2]);\n+        assertEquals(\"4\",elts4b[3]);\n+        assertEquals(\"5\",elts4b[4]);\n+        assertEquals(5,elts4b.length);\n+    }\n+\n+    public void testSerialization() throws Exception {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    public void testSerializationWithOpenCursor() throws Exception {\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        list.add(\"D\");\n+        list.add(\"E\");\n+        CursorableLinkedList.Cursor cursor = list.cursor();\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+    public void testLongSerialization() throws Exception {\n+        // recursive serialization will cause a stack\n+        // overflow exception with long lists\n+        for(int i=0;i<10000;i++) {\n+            list.add(new Integer(i));\n+        }\n+\n+        java.io.ByteArrayOutputStream buf = new java.io.ByteArrayOutputStream();\n+        java.io.ObjectOutputStream out = new java.io.ObjectOutputStream(buf);\n+        out.writeObject(list);\n+        out.flush();\n+        out.close();\n+\n+        java.io.ByteArrayInputStream bufin = new java.io.ByteArrayInputStream(buf.toByteArray());\n+        java.io.ObjectInputStream in = new java.io.ObjectInputStream(bufin);\n+        Object list2 = in.readObject();\n+\n+        assertTrue(list != list2);\n+        assertTrue(list2.equals(list));\n+        assertTrue(list.equals(list2));\n+    }\n+\n+\n+    /**\n+     *  Ignore the serialization tests for sublists and sub-sublists.\n+     *\n+     *  @return an array of sublist serialization test names \n+     */\n+    public String[] ignoredTests() {\n+        ArrayList list = new ArrayList();\n+        String prefix = \"TestCursorableLinkedList\";\n+        String bulk = \".bulkTestSubList\";\n+        String[] ignored = new String[] {\n+          \".testEmptyListSerialization\",\n+          \".testFullListSerialization\", \n+          \".testEmptyListCompatibility\", \n+          \".testFullListCompatibility\", \n+          \".testSimpleSerialization\",\n+          \".testCanonicalEmptyCollectionExists\",\n+          \".testCanonicalFullCollectionExists\",\n+          \".testSerializeDeserializeThenCompare\"\n+        };\n+        for (int i = 0; i < ignored.length; i++) {\n+            list.add(prefix + bulk + ignored[i]);\n+            list.add(prefix + bulk + bulk + ignored[i]);\n+        }\n+        return (String[])list.toArray(new String[0]);\n+    }\n+\n+}", "timestamp": 1072228540, "metainfo": ""}