{"sha": "c57a9af3e746273815932edce5cd2a4dca540d46", "log": "[COLLECTION-225] Added first version patricia trie contribution.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/Trie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.Map.Entry;\n+\n+/**\n+ * Defines the interface for a prefix tree, an ordered tree data structure. For \n+ * more information, see <a href=\"http://en.wikipedia.org/wiki/Trie\">Tries</a>.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface Trie<K, V> extends SortedMap<K, V> {\n+\n+    /**\n+     * Returns the {@link Entry} whose key is closest in a bitwise XOR \n+     * metric to the given key. This is NOT lexicographic closeness.\n+     * For example, given the keys:\n+     *\n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     * \n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n+     * return 'L', because the XOR distance between D &amp; L is smaller \n+     * than the XOR distance between D &amp; H. \n+     * \n+     * @return The {@link Entry} whose key is closest in a bitwise XOR metric\n+     * to the provided key.\n+     */\n+    public Map.Entry<K, V> select(K key);\n+    \n+    /**\n+     * Returns the key that is closest in a bitwise XOR metric to the \n+     * provided key. This is NOT lexicographic closeness!\n+     * \n+     * For example, given the keys:\n+     * \n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     * \n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n+     * return 'L', because the XOR distance between D &amp; L is smaller \n+     * than the XOR distance between D &amp; H. \n+     * \n+     * @return The key that is closest in a bitwise XOR metric to the provided key.\n+     */\n+    public K selectKey(K key);\n+    \n+    /**\n+     * Returns the value whose key is closest in a bitwise XOR metric to \n+     * the provided key. This is NOT lexicographic closeness!\n+     * \n+     * For example, given the keys:\n+     * \n+     * <ol>\n+     * <li>D = 1000100\n+     * <li>H = 1001000\n+     * <li>L = 1001100\n+     * </ol>\n+     * \n+     * If the {@link Trie} contained 'H' and 'L', a lookup of 'D' would \n+     * return 'L', because the XOR distance between D &amp; L is smaller \n+     * than the XOR distance between D &amp; H. \n+     * \n+     * @return The value whose key is closest in a bitwise XOR metric\n+     * to the provided key.\n+     */\n+    public V selectValue(K key);\n+    \n+    /**\n+     * Iterates through the {@link Trie}, starting with the entry whose bitwise\n+     * value is closest in an XOR metric to the given key. After the closest\n+     * entry is found, the {@link Trie} will call select on that entry and continue\n+     * calling select for each entry (traversing in order of XOR closeness,\n+     * NOT lexicographically) until the cursor returns {@link Decision#EXIT}.\n+     * \n+     * <p>The cursor can return {@link Decision#CONTINUE} to continue traversing.\n+     * \n+     * <p>{@link Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * and stop traversing.\n+     * \n+     * <p>Note: The {@link Decision#REMOVE} operation is not supported.\n+     * \n+     * @return The entry the cursor returned {@link Decision#EXIT} on, or null \n+     * if it continued till the end.\n+     */\n+    public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor);\n+    \n+    /**\n+     * Traverses the {@link Trie} in lexicographical order. \n+     * {@link Cursor#select(java.util.Map.Entry)} will be called on each entry.\n+     * \n+     * <p>The traversal will stop when the cursor returns {@link Decision#EXIT}, \n+     * {@link Decision#CONTINUE} is used to continue traversing and \n+     * {@link Decision#REMOVE} is used to remove the element that was selected \n+     * and continue traversing.\n+     * \n+     * <p>{@link Decision#REMOVE_AND_EXIT} is used to remove the current element\n+     * and stop traversing.\n+     *   \n+     * @return The entry the cursor returned {@link Decision#EXIT} on, or null \n+     * if it continued till the end.\n+     */\n+    public Map.Entry<K,V> traverse(Cursor<? super K, ? super V> cursor);\n+    \n+    /**\n+     * Returns a view of this {@link SortedTrie} of all elements that are prefixed \n+     * by the given key.\n+     * \n+     * <p>In a {@link SortedTrie} with fixed size keys, this is essentially a \n+     * {@link #get(Object)} operation.\n+     * \n+     * <p>For example, if the {@link SortedTrie} contains 'Anna', 'Anael', \n+     * 'Analu', 'Andreas', 'Andrea', 'Andres', and 'Anatole', then\n+     * a lookup of 'And' would return 'Andreas', 'Andrea', and 'Andres'.\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key);\n+    \n+    /**\n+     * Returns a view of this {@link SortedTrie} of all elements that are prefixed \n+     * by the length of the key.\n+     * \n+     * <p>{@link SortedTrie}s with fixed size keys will not support this operation \n+     * (because all keys are the same length).\n+     * \n+     * <p>For example, if the {@link SortedTrie} contains 'Anna', 'Anael', 'Analu', \n+     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for 'Andrey' \n+     * and a length of 4 would return 'Andreas', 'Andrea', and 'Andres'.\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int length);\n+    \n+    /**\n+     * Returns a view of this {@link SortedTrie} of all elements that are prefixed\n+     * by the key, starting at the given offset and for the given length.\n+     * \n+     * <p>{@link SortedTrie}s with fixed size keys will not support this operation \n+     * (because all keys are the same length).\n+     * \n+     * <p>For example, if the {@link SortedTrie} contains 'Anna', 'Anael', 'Analu', \n+     * 'Andreas', 'Andrea', 'Andres', and 'Anatole', then a lookup for \n+     * 'Hello Andrey Smith', an offset of 6 and a length of 4 would return \n+     * 'Andreas', 'Andrea', and 'Andres'.\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length);\n+    \n+    /**\n+     * Returns a view of this {@link SortedTrie} of all elements that are prefixed\n+     * by the number of bits in the given Key.\n+     * \n+     * <p>In {@link SortedTrie}s with fixed size keys like IP addresses this method\n+     * can be used to lookup partial keys. That is you can lookup all addresses\n+     * that begin with '192.168' by providing the key '192.168.X.X' and a \n+     * length of 16.\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits);\n+    \n+    /**\n+     * Returns a view of this {@link SortedTrie} of all elements that are prefixed\n+     * by the number of bits in the given Key.\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits);\n+    \n+    /**\n+     * A {@link Cursor} can be used to traverse a {@link Trie}, visit each node \n+     * step by step and make {@link Decision}s on each step how to continue with \n+     * traversing the {@link Trie}.\n+     */\n+    public interface Cursor<K, V> {\n+        \n+        /**\n+         * The {@link Decision} tells the {@link Cursor} what to do on each step \n+         * while traversing the {@link Trie}.\n+         * \n+         * NOTE: Not all operations that work with a {@link Cursor} support all \n+         * {@link Decision} types\n+         */\n+        public static enum Decision {\n+            \n+            /**\n+             * Exit the traverse operation\n+             */\n+            EXIT, \n+            \n+            /**\n+             * Continue with the traverse operation\n+             */\n+            CONTINUE, \n+            \n+            /**\n+             * Remove the previously returned element\n+             * from the {@link Trie} and continue\n+             */\n+            REMOVE, \n+            \n+            /**\n+             * Remove the previously returned element\n+             * from the {@link Trie} and exit from the\n+             * traverse operation\n+             */\n+            REMOVE_AND_EXIT;\n+        }\n+        \n+        /**\n+         * Called for each {@link Entry} in the {@link Trie}. Return \n+         * {@link Decision#EXIT} to finish the {@link Trie} operation,\n+         * {@link Decision#CONTINUE} to go to the next {@link Entry},\n+         * {@link Decision#REMOVE} to remove the {@link Entry} and\n+         * continue iterating or {@link Decision#REMOVE_AND_EXIT} to\n+         * remove the {@link Entry} and stop iterating.\n+         * \n+         * Note: Not all operations support {@link Decision#REMOVE}.\n+         */\n+        public Decision select(Map.Entry<? extends K, ? extends V> entry);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/TrieUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import org.apache.commons.collections.trie.SynchronizedTrie;\n+import org.apache.commons.collections.trie.UnmodifiableTrie;\n+\n+/**\n+ * A collection of {@link Trie} utilities.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class TrieUtils {\n+\n+    /**\n+     * {@link TrieUtils} should not normally be instantiated.\n+     */\n+    private TrieUtils() {}\n+    \n+    /**\n+     * Returns a synchronized instance of a {@link Trie}\n+     * \n+     * @see Collections#synchronizedMap(Map)\n+     */\n+    public static <K, V> Trie<K, V> synchronizedTrie(Trie<K, V> trie) {\n+        return SynchronizedTrie.synchronizedTrie(trie);\n+    }\n+    \n+    /**\n+     * Returns an unmodifiable instance of a {@link Trie}\n+     * \n+     * @see Collections#unmodifiableMap(Map)\n+     */\n+    public static <K, V> Trie<K, V> unmodifiableTrie(Trie<K, V> trie) {\n+        return UnmodifiableTrie.unmodifiableTrie(trie);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/AbstractKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * TODO: add javadoc\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public abstract class AbstractKeyAnalyzer<K> implements KeyAnalyzer<K> {\n+    \n+    private static final long serialVersionUID = -20497563720380683L;\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public int compare(K o1, K o2) {\n+        if (o1 == null) {\n+            return (o2 == null) ? 0 : -1;\n+        } else if (o2 == null) {\n+            return (o1 == null) ? 0 : 1;\n+        }\n+        \n+        return ((Comparable<K>)o1).compareTo(o2);\n+    }\n+    \n+    /** \n+     * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}\n+     */\n+    static boolean isOutOfBoundsIndex(int bitIndex) {\n+        return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n+    }\n+\n+    /** \n+     * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}\n+     */\n+    static boolean isEqualBitKey(int bitIndex) {\n+        return bitIndex == EQUAL_BIT_KEY;\n+    }\n+\n+    /** \n+     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY} \n+     */\n+    static boolean isNullBitKey(int bitIndex) {\n+        return bitIndex == NULL_BIT_KEY;\n+    }\n+\n+    /** \n+     * Returns true if the given bitIndex is valid. Indices \n+     * are considered valid if they're between 0 and \n+     * {@link Integer#MAX_VALUE}\n+     */\n+    static boolean isValidBitIndex(int bitIndex) {\n+        return 0 <= bitIndex && bitIndex <= Integer.MAX_VALUE;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/AbstractTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.Trie;\n+\n+/**\n+ * This class provides some basic {@link Trie} functionality and \n+ * utility methods for actual {@link Trie} implementations.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+abstract class AbstractTrie<K, V> extends AbstractMap<K, V> \n+        implements Trie<K, V>, Serializable {\n+    \n+    private static final long serialVersionUID = 5826987063535505652L;\n+    \n+    /**\n+     * The {@link KeyAnalyzer} that's being used to build the \n+     * PATRICIA {@link Trie}.\n+     */\n+    protected final KeyAnalyzer<? super K> keyAnalyzer;\n+    \n+    /** \n+     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n+     */\n+    public AbstractTrie(KeyAnalyzer<? super K> keyAnalyzer) {\n+        if (keyAnalyzer == null) {\n+            throw new NullPointerException(\"keyAnalyzer\");\n+        }\n+        \n+        this.keyAnalyzer = keyAnalyzer;\n+    }\n+    \n+    /**\n+     * Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n+     */\n+    public KeyAnalyzer<? super K> getKeyAnalyzer() {\n+        return keyAnalyzer;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K selectKey(K key) {\n+        Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getKey();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V selectValue(K key) {\n+        Map.Entry<K, V> entry = select(key);\n+        if (entry == null) {\n+            return null;\n+        }\n+        return entry.getValue();\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        StringBuilder buffer = new StringBuilder();\n+        buffer.append(\"Trie[\").append(size()).append(\"]={\\n\");\n+        for (Map.Entry<K, V> entry : entrySet()) {\n+            buffer.append(\"  \").append(entry).append(\"\\n\");\n+        }\n+        buffer.append(\"}\\n\");\n+        return buffer.toString();\n+    }\n+    \n+    /**\n+     * A utility method to cast keys. It actually doesn't\n+     * cast anything. It's just fooling the compiler!\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    final K castKey(Object key) {\n+        return (K)key;\n+    }\n+    \n+    /**\n+     * Returns the length of the given key in bits\n+     * \n+     * @see KeyAnalyzer#lengthInBits(Object)\n+     */\n+    final int lengthInBits(K key) {\n+        if (key == null) {\n+            return 0;\n+        }\n+        \n+        return keyAnalyzer.lengthInBits(key);\n+    }\n+    \n+    /**\n+     * Returns the number of bits per element in the key\n+     * \n+     * @see KeyAnalyzer#bitsPerElement()\n+     */\n+    final int bitsPerElement() {\n+        return keyAnalyzer.bitsPerElement();\n+    }\n+    \n+    /**\n+     * Returns whether or not the given bit on the \n+     * key is set or false if the key is null.\n+     * \n+     * @see KeyAnalyzer#isBitSet(Object, int, int)\n+     */\n+    final boolean isBitSet(K key, int bitIndex, int lengthInBits) {\n+        if (key == null) { // root's might be null!\n+            return false;\n+        }\n+        return keyAnalyzer.isBitSet(key, bitIndex, lengthInBits);\n+    }\n+    \n+    /**\n+     * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}\n+     */\n+    final int bitIndex(K key, K foundKey) {\n+        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), \n+                foundKey, 0, lengthInBits(foundKey));\n+    }\n+    \n+    /**\n+     * An utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n+     */\n+    final boolean compareKeys(K key, K other) {\n+        if (key == null) {\n+            return (other == null);\n+        } else if (other == null) {\n+            return (key == null);\n+        }\n+        \n+        return keyAnalyzer.compare(key, other) == 0;\n+    }\n+    \n+    /**\n+     * Returns true if both values are either null or equal\n+     */\n+    static boolean compare(Object a, Object b) {\n+        return (a == null ? b == null : a.equals(b));\n+    }\n+    \n+    /**\n+     * A basic implementation of {@link Entry}\n+     */\n+    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n+        \n+        private static final long serialVersionUID = -944364551314110330L;\n+\n+        protected K key;\n+        \n+        protected V value;\n+        \n+        private final int hashCode;\n+        \n+        public BasicEntry(K key) {\n+            this.key = key;\n+            this.hashCode = (key != null ? key.hashCode() : 0);\n+        }\n+        \n+        public BasicEntry(K key, V value) {\n+            this.key = key;\n+            this.value = value;\n+            \n+            this.hashCode = (key != null ? key.hashCode() : 0)\n+                    ^ (value != null ? value.hashCode() : 0);\n+        }\n+        \n+        /**\n+         * Replaces the current key and value with the provided\n+         * key &amp; value\n+         */\n+        public V setKeyValue(K key, V value) {\n+            this.key = key;\n+            return setValue(value);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K getKey() {\n+            return key;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public V getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public V setValue(V value) {\n+            V previous = this.value;\n+            this.value = value;\n+            return previous;\n+        }\n+        \n+        @Override\n+        public int hashCode() {\n+            return hashCode;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            } else if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+            \n+            Map.Entry<?, ?> other = (Map.Entry<?, ?>)o;\n+            if (compare(key, other.getKey()) \n+                    && compare(value, other.getValue())) {\n+                return true;\n+            }\n+            return false;\n+        }\n+        \n+        @Override\n+        public String toString() {\n+            return key + \"=\" + value;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/ByteArrayKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for byte[]s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ByteArrayKeyAnalyzer extends AbstractKeyAnalyzer<byte[]> {\n+    \n+    private static final long serialVersionUID = 7382825097492285877L;\n+\n+    /**\n+     * A singleton instance of {@link ByteArrayKeyAnalyzer}\n+     */\n+    public static final ByteArrayKeyAnalyzer INSTANCE \n+        = new ByteArrayKeyAnalyzer(Integer.MAX_VALUE);\n+    \n+    /**\n+     * The length of an {@link Byte} in bits\n+     */\n+    public static final int LENGTH = Byte.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x80;\n+    \n+    /**\n+     * A place holder for null\n+     */\n+    private static final byte[] NULL = new byte[0];\n+    \n+    /**\n+     * The maximum length of a key in bits\n+     */\n+    private final int maxLengthInBits;\n+    \n+    public ByteArrayKeyAnalyzer(int maxLengthInBits) {\n+        if (maxLengthInBits < 0) {\n+            throw new IllegalArgumentException(\n+                    \"maxLengthInBits=\" + maxLengthInBits);\n+        }\n+        \n+        this.maxLengthInBits = maxLengthInBits;\n+    }\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * Returns the maximum length of a key in bits\n+     * @return the maximum key length in bits\n+     */\n+    public int getMaxLengthInBits() {\n+        return maxLengthInBits;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(byte[] key) {\n+        return (key != null ? key.length * bitsPerElement() : 0);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(byte[] key, int bitIndex, int lengthInBits) {\n+        if (key == null) {     \n+            return false;\n+        }\n+        \n+        int prefix = maxLengthInBits - lengthInBits;\n+        int keyBitIndex = bitIndex - prefix;\n+        \n+        if (keyBitIndex >= lengthInBits || keyBitIndex < 0) {\n+            return false;\n+        }\n+        \n+        int index = (int)(keyBitIndex / LENGTH);\n+        int bit = (int)(keyBitIndex % LENGTH);\n+        return (key[index] & mask(bit)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(byte[] key, int offsetInBits, int lengthInBits, \n+            byte[] other, int otherOffsetInBits, int otherLengthInBits) {\n+        \n+        if (other == null) {\n+            other = NULL;\n+        }\n+        \n+        boolean allNull = true;\n+        int length = Math.max(lengthInBits, otherLengthInBits);\n+        int prefix = maxLengthInBits - length;\n+        \n+        if (prefix < 0) {\n+            return KeyAnalyzer.OUT_OF_BOUNDS_BIT_KEY;\n+        }\n+        \n+        for (int i = 0; i < length; i++) {\n+            int index = prefix + (offsetInBits + i);\n+            boolean value = isBitSet(key, index, lengthInBits);\n+                \n+            if (value) {\n+                allNull = false;\n+            }\n+            \n+            int otherIndex = prefix + (otherOffsetInBits + i);\n+            boolean otherValue = isBitSet(other, otherIndex, otherLengthInBits);\n+            \n+            if (value != otherValue) {\n+                return index;\n+            }\n+        }\n+        \n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(byte[] prefix, int offsetInBits, \n+            int lengthInBits, byte[] key) {\n+        \n+        int keyLength = lengthInBits(key);\n+        if (lengthInBits > keyLength) {\n+            return false;\n+        }\n+        \n+        int elements = lengthInBits - offsetInBits;\n+        for (int i = 0; i < elements; i++) {\n+            if (isBitSet(prefix, i+offsetInBits, lengthInBits) \n+                    != isBitSet(key, i, keyLength)) {\n+                return false;\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int compare(byte[] o1, byte[] o2) {\n+        if (o1 == null) {\n+            return (o2 == null) ? 0 : -1;\n+        } else if (o2 == null) {\n+            return (o1 == null) ? 0 : 1;\n+        }\n+        \n+        if (o1.length != o2.length) {\n+            return o1.length - o2.length;\n+        }\n+        \n+        for (int i = 0; i < o1.length; i++) {\n+            int diff = (o1[i] & 0xFF) - (o2[i] & 0xFF);\n+            if (diff != 0) {\n+                return diff;\n+            }\n+        }\n+\n+        return 0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/ByteKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Byte}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ByteKeyAnalyzer extends AbstractKeyAnalyzer<Byte> {\n+    \n+    private static final long serialVersionUID = 3395803342983289829L;\n+\n+    /**\n+     * A singleton instance of {@link ByteKeyAnalyzer}\n+     */\n+    public static final ByteKeyAnalyzer INSTANCE = new ByteKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Byte} in bits\n+     */\n+    public static final int LENGTH = Byte.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x80;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(Byte key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(Byte key, int bitIndex, int lengthInBits) {\n+        return (key & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(Byte key, int offsetInBits, int lengthInBits, \n+            Byte other, int otherOffsetInBits, int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        byte keyValue = key.byteValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        byte otherValue = (other != null ? other.byteValue() : 0);\n+        \n+        if (keyValue != otherValue) {\n+            int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(Byte prefix, int offsetInBits, \n+            int lengthInBits, Byte key) {\n+        \n+        int value1 = (prefix.byteValue() << offsetInBits);\n+        int value2 = key.byteValue();\n+        \n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= (0x1 << i);\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/CharArrayKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * An {@link KeyAnalyzer} for {@code char[]}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CharArrayKeyAnalyzer extends AbstractKeyAnalyzer<char[]> {\n+    \n+    private static final long serialVersionUID = -8167897361549463457L;\n+\n+    /**\n+     * A singleton instance of {@link CharArrayKeyAnalyzer}\n+     */\n+    public static final CharArrayKeyAnalyzer INSTANCE = new CharArrayKeyAnalyzer();\n+\n+    /**\n+     * The number of bits per {@link Character}\n+     */\n+    public static final int LENGTH = Character.SIZE;\n+\n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+\n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(char[] key) {\n+        return (key != null ? key.length * LENGTH : 0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(char[] key, int offsetInBits, int lengthInBits,\n+            char[] other, int otherOffsetInBits, int otherLengthInBits) {\n+        boolean allNull = true;\n+\n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0\n+                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"The offsets and lengths must be at Character boundaries\");\n+        }\n+\n+\n+        int beginIndex1 = offsetInBits / LENGTH;\n+        int beginIndex2 = otherOffsetInBits / LENGTH;\n+\n+        int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+\n+        int length = Math.max(endIndex1, endIndex2);\n+\n+        // Look at each character, and if they're different\n+        // then figure out which bit makes the difference\n+        // and return it.\n+        char k = 0, f = 0;\n+        for(int i = 0; i < length; i++) {\n+            int index1 = beginIndex1 + i;\n+            int index2 = beginIndex2 + i;\n+\n+            if (index1 >= endIndex1) {\n+                k = 0;\n+            } else {\n+                k = key[index1];\n+            }\n+\n+            if (other == null || index2 >= endIndex2) {\n+                f = 0;\n+            } else {\n+                f = other[index2];\n+            }\n+\n+            if (k != f) {\n+               int x = k ^ f;\n+               return i * LENGTH + (Integer.numberOfLeadingZeros(x) - LENGTH);\n+            }\n+\n+            if (k != 0) {\n+                allNull = false;\n+            }\n+        }\n+\n+        // All bits are 0\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+\n+        // Both keys are equal\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(char[] key, int bitIndex, int lengthInBits) {\n+        if (key == null || bitIndex >= lengthInBits) {\n+            return false;\n+        }\n+\n+        int index = (int)(bitIndex / LENGTH);\n+        int bit = (int)(bitIndex % LENGTH);\n+\n+        return (key[index] & mask(bit)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(char[] prefix, int offsetInBits,\n+            int lengthInBits, char[] key) {\n+        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"Cannot determine prefix outside of Character boundaries\");\n+        }\n+\n+        int off = offsetInBits / LENGTH;\n+        int len = lengthInBits / LENGTH;\n+        for (int i = 0; i < len; i ++) {\n+            if (prefix[i + off] != key[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/CharacterKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Character}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class CharacterKeyAnalyzer extends AbstractKeyAnalyzer<Character> {\n+    \n+    private static final long serialVersionUID = 3928565962744720753L;\n+    \n+    /**\n+     * A singleton instance of the {@link CharacterKeyAnalyzer}.\n+     */\n+    public static final CharacterKeyAnalyzer INSTANCE \n+        = new CharacterKeyAnalyzer();\n+    \n+    /**\n+     * The length of a {@link Character} in bits\n+     */\n+    public static final int LENGTH = Character.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(Character key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(Character key, int bitIndex, int lengthInBits) {\n+        return (key & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(Character key, int offsetInBits, int lengthInBits, \n+            Character other, int otherOffsetInBits, int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        char keyValue = key.charValue();\n+        if (keyValue == Character.MIN_VALUE) {\n+            return NULL_BIT_KEY;\n+        }\n+        \n+        if (other == null) {\n+            other = Character.MIN_VALUE;\n+        }\n+        \n+        char otherValue = (other != null ? other.charValue() : Character.MIN_VALUE);\n+        \n+        if (keyValue != otherValue) {\n+            int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(Character prefix, int offsetInBits, \n+            int lengthInBits, Character key) {\n+        \n+        int value1 = (prefix.charValue() << offsetInBits);\n+        int value2 = key.charValue();\n+        \n+        int mask = 0;\n+        for(int i = 0; i < lengthInBits; i++) {\n+            mask |= (0x1 << i);\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/IntegerKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Integer}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class IntegerKeyAnalyzer extends AbstractKeyAnalyzer<Integer> {\n+    \n+    private static final long serialVersionUID = 4928508653722068982L;\n+    \n+    /**\n+     * A singleton instance of {@link IntegerKeyAnalyzer}\n+     */\n+    public static final IntegerKeyAnalyzer INSTANCE = new IntegerKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Integer} in bits\n+     */\n+    public static final int LENGTH = Integer.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x80000000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(Integer key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(Integer key, int bitIndex, int lengthInBits) {\n+        return (key & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(Integer key, int offsetInBits, int lengthInBits, \n+            Integer other, int otherOffsetInBits, int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        int keyValue = key.intValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        int otherValue = (other != null ? other.intValue() : 0);\n+        \n+        if (keyValue != otherValue) {\n+            int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(Integer prefix, int offsetInBits, \n+            int lengthInBits, Integer key) {\n+        \n+        int value1 = (prefix.intValue() << offsetInBits);\n+        int value2 = key.intValue();\n+        \n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= (0x1 << i);\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/KeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+/** \n+ * Defines the interface to analyze {@link Trie} keys on a bit level. \n+ * {@link KeyAnalyzer}'s methods return the length of the key in bits, \n+ * whether or not a bit is set, and bits per element in the key. \n+ * \n+ * <p>Additionally, a method determines if a key is a prefix of another \n+ * key and returns the bit index where one key is different from another \n+ * key (if the key and found key are equal than the return value is \n+ * {@link #EQUAL_BIT_KEY}).\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public interface KeyAnalyzer<K> extends Comparator<K>, Serializable {\n+    \n+    /** \n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} \n+     * if key's bits are all 0 \n+     */\n+    public static final int NULL_BIT_KEY = -1;\n+    \n+    /** \n+     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} \n+     * if key and found key are equal. This is a very very specific case \n+     * and shouldn't happen on a regular basis\n+     */\n+    public static final int EQUAL_BIT_KEY = -2;\n+    \n+    public static final int OUT_OF_BOUNDS_BIT_KEY = -3;\n+    \n+    /**\n+     * Returns the number of bits per element in the key.\n+     * This is only useful for variable-length keys, such as Strings.\n+     */\n+    public int bitsPerElement();\n+    \n+    /** \n+     * Returns the length of the Key in bits. \n+     */\n+    public int lengthInBits(K key);\n+    \n+    /** \n+     * Returns whether or not a bit is set \n+     */\n+    public boolean isBitSet(K key, int bitIndex, int lengthInBits);\n+    \n+    /**\n+     * Returns the n-th different bit between key and found.\n+     * This starts the comparison in key at 'keyStart' and goes\n+     * for 'keyLength' bits, and compares to the found key\n+     * starting at 'foundStart' and going for 'foundLength' bits.\n+     */\n+    public int bitIndex(K key, int offsetInBits, int lengthInBits, \n+            K other, int otherOffsetInBits, int otherLengthInBits);\n+    \n+    /**\n+     * Determines whether or not the given prefix (from offset to length)\n+     * is a prefix of the given key.\n+     */\n+    public boolean isPrefix(K prefix, int offsetInBits, int lengthInBits, K key);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/LongKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Long}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class LongKeyAnalyzer extends AbstractKeyAnalyzer<Long> {\n+    \n+    private static final long serialVersionUID = -4119639247588227409L;\n+\n+    /**\n+     * A singleton instance of {@link LongKeyAnalyzer}\n+     */\n+    public static final LongKeyAnalyzer INSTANCE = new LongKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Long} in bits\n+     */\n+    public static final int LENGTH = Long.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final long MSB = 0x8000000000000000L;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static long mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(Long key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(Long key, int bitIndex, int lengthInBits) {\n+        return (key & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(Long key, int offsetInBits, int lengthInBits, \n+            Long other, int otherOffsetInBits, int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        long keyValue = key.longValue();\n+        if (keyValue == 0L) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        long otherValue = (other != null ? other.longValue() : 0L);\n+        \n+        if (keyValue != otherValue) {\n+            long xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0L) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(Long prefix, int offsetInBits, \n+            int lengthInBits, Long key) {\n+        \n+        long value1 = (prefix.longValue() << offsetInBits);\n+        long value2 = key.longValue();\n+        \n+        long mask = 0L;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= (0x1L << i);\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/PatriciaTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Trie;\n+\n+/**\n+ * <h3>PATRICIA {@link Trie}</h3>\n+ *  \n+ * <i>Practical Algorithm to Retrieve Information Coded in Alphanumeric</i>\n+ * \n+ * <p>A PATRICIA {@link Trie} is a compressed {@link Trie}. Instead of storing \n+ * all data at the edges of the {@link Trie} (and having empty internal nodes), \n+ * PATRICIA stores data in every node. This allows for very efficient traversal, \n+ * insert, delete, predecessor, successor, prefix, range, and {@link #select(Object)} \n+ * operations. All operations are performed at worst in O(K) time, where K \n+ * is the number of bits in the largest item in the tree. In practice, \n+ * operations actually take O(A(K)) time, where A(K) is the average number of \n+ * bits of all items in the tree.\n+ * \n+ * <p>Most importantly, PATRICIA requires very few comparisons to keys while\n+ * doing any operation. While performing a lookup, each comparison (at most \n+ * K of them, described above) will perform a single bit comparison against \n+ * the given key, instead of comparing the entire key to another key.\n+ * \n+ * <p>The {@link Trie} can return operations in lexicographical order using the \n+ * {@link #traverse(Cursor)}, 'prefix', 'submap', or 'iterator' methods. The \n+ * {@link Trie} can also scan for items that are 'bitwise' (using an XOR \n+ * metric) by the 'select' method. Bitwise closeness is determined by the \n+ * {@link KeyAnalyzer} returning true or false for a bit being set or not in \n+ * a given key.\n+ * \n+ * <p>This PATRICIA {@link Trie} supports both variable length & fixed length \n+ * keys. Some methods, such as {@link #getPrefixedBy(Object)} are suited only \n+ * to variable length keys, whereas {@link #getPrefixedByBits(Object, int)} is \n+ * suited to fixed-size keys.\n+ * \n+ * <p>Any methods here that take an {@link Object} argument may throw a \n+ * {@link ClassCastException} if the method is expecting an instance of K \n+ * and it isn't K.\n+ * \n+ * @see <a href=\"http://en.wikipedia.org/wiki/Radix_tree\">Radix Tree</a>\n+ * @see <a href=\"http://www.csse.monash.edu.au/~lloyd/tildeAlgDS/Tree/PATRICIA\">PATRICIA</a>\n+ * @see <a href=\"http://www.imperialviolet.org/binary/critbit.pdf\">Crit-Bit Tree</a>\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class PatriciaTrie<K, V> extends PatriciaTrieBase<K, V> implements Trie<K, V> {\n+    \n+    private static final long serialVersionUID = 4446367780901817838L;\n+\n+    public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer) {\n+        super(keyAnalyzer);\n+    }\n+\n+    public PatriciaTrie(KeyAnalyzer<? super K> keyAnalyzer,\n+            Map<? extends K, ? extends V> m) {\n+        super(keyAnalyzer, m);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Comparator<? super K> comparator() {\n+        return keyAnalyzer;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key) {\n+        return getPrefixedByBits(key, 0, lengthInBits(key));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int length) {\n+        return getPrefixedByBits(key, 0, length * bitsPerElement());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n+        int bitsPerElement = bitsPerElement();\n+        return getPrefixedByBits(key, offset*bitsPerElement, length*bitsPerElement);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n+        return getPrefixedByBits(key, 0, lengthInBits);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K firstKey() {\n+        return firstEntry().getKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K lastKey() {\n+        TrieEntry<K, V> entry = lastEntry();\n+        if (entry != null) {\n+            return entry.getKey();\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * The view that this returns is optimized to have a very efficient\n+     * {@link Iterator}. The {@link SortedMap#firstEntry()}, \n+     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must \n+     * iterate over all possible values in order to determine the results. \n+     * This information is cached until the PATRICIA {@link Trie} changes. \n+     * All other methods (except {@link Iterator}) must compare the given \n+     * key to the prefix to ensure that it is within the range of the view.  \n+     * The {@link Iterator}'s remove method must also relocate the subtree \n+     * that contains the prefixes if the entry holding the subtree is \n+     * removed or changes. Changing the subtree takes O(K) time.\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits, int lengthInBits) {\n+        \n+        int offsetLength = offsetInBits + lengthInBits;\n+        if (offsetLength > lengthInBits(key)) {\n+            throw new IllegalArgumentException(offsetInBits + \" + \" \n+                    + lengthInBits + \" > \" + lengthInBits(key));\n+        }\n+        \n+        if (offsetLength == 0) {\n+            return this;\n+        }\n+        \n+        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return new RangeEntryMap(null, toKey);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return new RangeEntryMap(fromKey, toKey);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return new RangeEntryMap(fromKey, null);\n+    } \n+    \n+    /**\n+     * Returns an entry strictly higher than the given key,\n+     * or null if no such entry exists.\n+     */\n+    TrieEntry<K,V> higherEntry(K key) {\n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                // If data in root, and more after -- return it.\n+                if (size() > 1) {\n+                    return nextEntry(root);\n+                } else { // If no more after, no higher entry.\n+                    return null;\n+                }\n+            } else {\n+                // Root is empty & we want something after empty, return first.\n+                return firstEntry();\n+            }\n+        }\n+        \n+        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return nextEntry(found);\n+        }\n+        \n+        int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            TrieEntry<K, V> ceil = nextEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return ceil;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return firstEntry();\n+            } else if (size() > 1) {\n+                return nextEntry(firstEntry());\n+            } else {\n+                return null;\n+            }\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return nextEntry(found);\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Returns a key-value mapping associated with the least key greater\n+     * than or equal to the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> ceilingEntry(K key) {\n+        // Basically:\n+        // Follow the steps of adding an entry, but instead...\n+        //\n+        // - If we ever encounter a situation where we found an equal\n+        //   key, we return it immediately.\n+        //\n+        // - If we hit an empty root, return the first iterable item.\n+        //\n+        // - If we have to add a new item, we temporarily add it,\n+        //   find the successor to it, then remove the added item.\n+        //\n+        // These steps ensure that the returned value is either the\n+        // entry for the key itself, or the first entry directly after\n+        // the key.\n+        \n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return firstEntry();\n+            }\n+        }\n+        \n+        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return found;\n+        }\n+        \n+        int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            TrieEntry<K, V> ceil = nextEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return ceil;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return firstEntry();\n+            }\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return found;\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Returns a key-value mapping associated with the greatest key\n+     * strictly less than the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> lowerEntry(K key) {\n+        // Basically:\n+        // Follow the steps of adding an entry, but instead...\n+        //\n+        // - If we ever encounter a situation where we found an equal\n+        //   key, we return it's previousEntry immediately.\n+        //\n+        // - If we hit root (empty or not), return null.\n+        //\n+        // - If we have to add a new item, we temporarily add it,\n+        //   find the previousEntry to it, then remove the added item.\n+        //\n+        // These steps ensure that the returned value is always just before\n+        // the key or null (if there was nothing before it).\n+        \n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            return null; // there can never be anything before root.\n+        }\n+        \n+        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return previousEntry(found);\n+        }\n+        \n+        int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            TrieEntry<K, V> prior = previousEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return prior;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            return null;\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return previousEntry(found);\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Returns a key-value mapping associated with the greatest key\n+     * less than or equal to the given key, or null if there is no such key.\n+     */\n+    TrieEntry<K,V> floorEntry(K key) {        \n+        // TODO: Cleanup so that we don't actually have to add/remove from the\n+        //       tree.  (We do it here because there are other well-defined \n+        //       functions to perform the search.)\n+        int lengthInBits = lengthInBits(key);\n+        \n+        if (lengthInBits == 0) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return null;\n+            }\n+        }\n+        \n+        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            return found;\n+        }\n+        \n+        int bitIndex = bitIndex(key, found.key);\n+        if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) {\n+            TrieEntry<K, V> added = new TrieEntry<K, V>(key, null, bitIndex);\n+            addEntry(added, lengthInBits);\n+            incrementSize(); // must increment because remove will decrement\n+            TrieEntry<K, V> floor = previousEntry(added);\n+            removeEntry(added);\n+            modCount -= 2; // we didn't really modify it.\n+            return floor;\n+        } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+            if (!root.isEmpty()) {\n+                return root;\n+            } else {\n+                return null;\n+            }\n+        } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+            return found;\n+        }\n+\n+        // we should have exited above.\n+        throw new IllegalStateException(\"invalid lookup: \" + key);\n+    }\n+    \n+    /**\n+     * Finds the subtree that contains the prefix.\n+     * \n+     * This is very similar to getR but with the difference that\n+     * we stop the lookup if h.bitIndex > lengthInBits.\n+     */\n+    TrieEntry<K, V> subtree(K prefix, int offsetInBits, int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex <= path.bitIndex \n+                    || lengthInBits < current.bitIndex) {\n+                break;\n+            }\n+            \n+            path = current;\n+            if (!isBitSet(prefix, offsetInBits + current.bitIndex, \n+                    offsetInBits + lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }        \n+\n+        // Make sure the entry is valid for a subtree.\n+        TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n+        \n+        // If entry is root, it can't be empty.\n+        if (entry.isEmpty()) {\n+            return null;\n+        }\n+        \n+        int endIndexInBits = offsetInBits + lengthInBits;\n+        \n+        // if root && length of root is less than length of lookup,\n+        // there's nothing.\n+        // (this prevents returning the whole subtree if root has an empty\n+        //  string and we want to lookup things with \"\\0\")\n+        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n+            return null;\n+        }\n+        \n+        // Found key's length-th bit differs from our key\n+        // which means it cannot be the prefix...\n+        if (isBitSet(prefix, endIndexInBits, endIndexInBits) \n+                != isBitSet(entry.key, lengthInBits, lengthInBits(entry.key))) {\n+            return null;\n+        }\n+        \n+        // ... or there are less than 'length' equal bits\n+        int bitIndex = keyAnalyzer.bitIndex(prefix, offsetInBits, \n+                lengthInBits, entry.key, 0, lengthInBits(entry.getKey()));\n+        \n+        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n+            return null;\n+        }\n+        \n+        return entry;\n+    }\n+    \n+    /**\n+     * Returns the last entry the {@link Trie} is storing.\n+     * \n+     * <p>This is implemented by going always to the right until\n+     * we encounter a valid uplink. That uplink is the last key.\n+     */\n+    TrieEntry<K, V> lastEntry() {\n+        return followRight(root.left);\n+    }\n+    \n+    /**\n+     * Traverses down the right path until it finds an uplink.\n+     */\n+    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n+        // if Trie is empty, no last entry.\n+        if (node.right == null) {\n+            return null;\n+        }\n+        \n+        // Go as far right as possible, until we encounter an uplink.\n+        while (node.right.bitIndex > node.bitIndex) {\n+            node = node.right;\n+        }\n+        \n+        return node.right;\n+    }\n+    \n+    /**\n+     * Returns the node lexicographically before the given node (or null if none).\n+     * \n+     * This follows four simple branches:\n+     *  - If the uplink that returned us was a right uplink:\n+     *      - If predecessor's left is a valid uplink from predecessor, return it.\n+     *      - Else, follow the right path from the predecessor's left.\n+     *  - If the uplink that returned us was a left uplink:\n+     *      - Loop back through parents until we encounter a node where \n+     *        node != node.parent.left.\n+     *          - If node.parent.left is uplink from node.parent:\n+     *              - If node.parent.left is not root, return it.\n+     *              - If it is root & root isEmpty, return null.\n+     *              - If it is root & root !isEmpty, return root.\n+     *          - If node.parent.left is not uplink from node.parent:\n+     *              - Follow right path for first right child from node.parent.left   \n+     * \n+     * @param start\n+     */\n+    TrieEntry<K, V> previousEntry(TrieEntry<K, V> start) {\n+        if (start.predecessor == null) {\n+            throw new IllegalArgumentException(\"must have come from somewhere!\");\n+        }\n+        \n+        if (start.predecessor.right == start) {\n+            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n+                return start.predecessor.left;\n+            } else {\n+                return followRight(start.predecessor.left);\n+            }\n+        } else {\n+            TrieEntry<K, V> node = start.predecessor;\n+            while (node.parent != null && node == node.parent.left) {\n+                node = node.parent;\n+            }\n+            \n+            if (node.parent == null) { // can be null if we're looking up root.\n+                return null;\n+            }\n+            \n+            if (isValidUplink(node.parent.left, node.parent)) {\n+                if (node.parent.left == root) {\n+                    if (root.isEmpty()) {\n+                        return null;\n+                    } else {\n+                        return root;\n+                    }\n+                    \n+                } else {\n+                    return node.parent.left;\n+                }\n+            } else {\n+                return followRight(node.parent.left);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Returns the entry lexicographically after the given entry.\n+     * If the given entry is null, returns the first node.\n+     * \n+     * This will traverse only within the subtree.  If the given node\n+     * is not within the subtree, this will have undefined results.\n+     */\n+    TrieEntry<K, V> nextEntryInSubtree(TrieEntry<K, V> node, \n+            TrieEntry<K, V> parentOfSubtree) {\n+        if (node == null) {\n+            return firstEntry();\n+        } else {\n+            return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n+        }\n+    }\n+    \n+    /**\n+     * A range view of the {@link Trie}\n+     */\n+    private abstract class RangeMap extends AbstractMap<K, V> \n+            implements SortedMap<K, V> {\n+\n+        /**\n+         * The {@link #entrySet()} view\n+         */\n+        private transient volatile Set<Map.Entry<K, V>> entrySet;\n+\n+        /**\n+         * Creates and returns an {@link #entrySet()} \n+         * view of the {@link RangeMap}\n+         */\n+        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n+\n+        /**\n+         * Returns the FROM Key\n+         */\n+        protected abstract K getFromKey();\n+        \n+        /**\n+         * Whether or not the {@link #getFromKey()} is in the range\n+         */\n+        protected abstract boolean isFromInclusive();\n+        \n+        /**\n+         * Returns the TO Key\n+         */\n+        protected abstract K getToKey();\n+        \n+        /**\n+         * Whether or not the {@link #getToKey()} is in the range\n+         */\n+        protected abstract boolean isToInclusive();\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public Comparator<? super K> comparator() {\n+            return PatriciaTrie.this.comparator();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean containsKey(Object key) {\n+            if (!inRange(castKey(key))) {\n+                return false;\n+            }\n+\n+            return PatriciaTrie.this.containsKey(key);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public V remove(Object key) {\n+            if (!inRange(castKey(key))) {\n+                return null;\n+            }\n+\n+            return PatriciaTrie.this.remove(key);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public V get(Object key) {\n+            if (!inRange(castKey(key))) {\n+                return null;\n+            }\n+\n+            return PatriciaTrie.this.get(key);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public V put(K key, V value) {\n+            if (!inRange(key)) {\n+                throw new IllegalArgumentException(\n+                        \"Key is out of range: \" + key);\n+            }\n+\n+            return PatriciaTrie.this.put(key, value);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Set<Map.Entry<K, V>> entrySet() {\n+            if (entrySet == null) {\n+                entrySet = createEntrySet();\n+            }\n+            return entrySet;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+            if (!inRange2(fromKey)) {\n+                throw new IllegalArgumentException(\n+                        \"FromKey is out of range: \" + fromKey);\n+            }\n+\n+            if (!inRange2(toKey)) {\n+                throw new IllegalArgumentException(\n+                        \"ToKey is out of range: \" + toKey);\n+            }\n+\n+            return createRangeMap(fromKey, isFromInclusive(), \n+                    toKey, isToInclusive());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public SortedMap<K, V> headMap(K toKey) {\n+            if (!inRange2(toKey)) {\n+                throw new IllegalArgumentException(\n+                        \"ToKey is out of range: \" + toKey);\n+            }\n+\n+            return createRangeMap(getFromKey(), isFromInclusive(), \n+                    toKey, isToInclusive());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public SortedMap<K, V> tailMap(K fromKey) {\n+            if (!inRange2(fromKey)) {\n+                throw new IllegalArgumentException(\n+                        \"FromKey is out of range: \" + fromKey);\n+            }\n+\n+            return createRangeMap(fromKey, isFromInclusive(), \n+                    getToKey(), isToInclusive());\n+        }\n+\n+        /**\n+         * Returns true if the provided key is greater than TO and\n+         * less than FROM\n+         */\n+        protected boolean inRange(K key) {\n+\n+            K fromKey = getFromKey();\n+            K toKey = getToKey();\n+\n+            return (fromKey == null || inFromRange(key, false))\n+                    && (toKey == null || inToRange(key, false));\n+        }\n+\n+        /**\n+         * This form allows the high endpoint (as well as all legit keys)\n+         */\n+        protected boolean inRange2(K key) {\n+\n+            K fromKey = getFromKey();\n+            K toKey = getToKey();\n+\n+            return (fromKey == null || inFromRange(key, false))\n+                    && (toKey == null || inToRange(key, true));\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the FROM range \n+         * of the {@link RangeMap}\n+         */\n+        protected boolean inFromRange(K key, boolean forceInclusive) {\n+\n+            K fromKey = getFromKey();\n+            boolean fromInclusive = isFromInclusive();\n+\n+            int ret = keyAnalyzer.compare(key, fromKey);\n+            if (fromInclusive || forceInclusive) {\n+                return ret >= 0;\n+            } else {\n+                return ret > 0;\n+            }\n+        }\n+\n+        /**\n+         * Returns true if the provided key is in the TO range \n+         * of the {@link RangeMap}\n+         */\n+        protected boolean inToRange(K key, boolean forceInclusive) {\n+\n+            K toKey = getToKey();\n+            boolean toInclusive = isToInclusive();\n+\n+            int ret = keyAnalyzer.compare(key, toKey);\n+            if (toInclusive || forceInclusive) {\n+                return ret <= 0;\n+            } else {\n+                return ret < 0;\n+            }\n+        }\n+\n+        /**\n+         * Creates and returns a sub-range view of the current {@link RangeMap}\n+         */\n+        protected abstract SortedMap<K, V> createRangeMap(K fromKey,\n+                boolean fromInclusive, K toKey, boolean toInclusive);\n+    }\n+   \n+   /**\n+    * A {@link RangeMap} that deals with {@link Entry}s\n+    */\n+   private class RangeEntryMap extends RangeMap {\n+       \n+       /** \n+        * The key to start from, null if the beginning. \n+        */\n+       protected final K fromKey;\n+       \n+       /** \n+        * The key to end at, null if till the end. \n+        */\n+       protected final K toKey;\n+       \n+       /** \n+        * Whether or not the 'from' is inclusive. \n+        */\n+       protected final boolean fromInclusive;\n+       \n+       /** \n+        * Whether or not the 'to' is inclusive. \n+        */\n+       protected final boolean toInclusive;\n+       \n+       /**\n+        * Creates a {@link RangeEntryMap} with the fromKey included and\n+        * the toKey excluded from the range\n+        */\n+       protected RangeEntryMap(K fromKey, K toKey) {\n+           this(fromKey, true, toKey, false);\n+       }\n+       \n+       /**\n+        * Creates a {@link RangeEntryMap}\n+        */\n+       protected RangeEntryMap(K fromKey, boolean fromInclusive, \n+               K toKey, boolean toInclusive) {\n+           \n+           if (fromKey == null && toKey == null) {\n+               throw new IllegalArgumentException(\"must have a from or to!\");\n+           }\n+           \n+           if (fromKey != null && toKey != null \n+                   && keyAnalyzer.compare(fromKey, toKey) > 0) {\n+               throw new IllegalArgumentException(\"fromKey > toKey\");\n+           }\n+           \n+           this.fromKey = fromKey;\n+           this.fromInclusive = fromInclusive;\n+           this.toKey = toKey;\n+           this.toInclusive = toInclusive;\n+       }\n+       \n+       /**\n+        * {@inheritDoc}\n+        */\n+       public K firstKey() {\n+           Map.Entry<K,V> e = null;\n+           if (fromKey == null) {\n+               e = firstEntry();\n+           } else {\n+               if (fromInclusive) {\n+                   e = ceilingEntry(fromKey);\n+               } else {\n+                   e = higherEntry(fromKey);\n+               }\n+           }\n+           \n+           K first = e != null ? e.getKey() : null;\n+           if (e == null || toKey != null && !inToRange(first, false)) {\n+               throw new NoSuchElementException();\n+           }\n+           return first;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       public K lastKey() {\n+           Map.Entry<K,V> e;\n+           if (toKey == null) {\n+               e = lastEntry();\n+           } else {\n+               if (toInclusive) {\n+                   e = floorEntry(toKey);\n+               } else {\n+                   e = lowerEntry(toKey);\n+               }\n+           }\n+           \n+           K last = e != null ? e.getKey() : null;\n+           if (e == null || fromKey != null && !inFromRange(last, false)) {\n+               throw new NoSuchElementException();\n+           }\n+           return last;\n+       }\n+       \n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       protected Set<Entry<K, V>> createEntrySet() {\n+           return new RangeEntrySet(this);\n+       }\n+       \n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public K getFromKey() {\n+           return fromKey;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public K getToKey() {\n+           return toKey;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public boolean isFromInclusive() {\n+           return fromInclusive;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       public boolean isToInclusive() {\n+           return toInclusive;\n+       }\n+\n+       /**\n+        * {@inheritDoc}\n+        */\n+       @Override\n+       protected SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n+               K toKey, boolean toInclusive) {\n+           return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n+       }\n+   }\n+   \n+    /**\n+     * A {@link Set} view of a {@link RangeMap}\n+     */\n+    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n+\n+        private final RangeMap delegate;\n+\n+        private transient int size = -1;\n+\n+        private transient int expectedModCount;\n+\n+        /**\n+         * Creates a {@link RangeEntrySet}\n+         */\n+        public RangeEntrySet(RangeMap delegate) {\n+            if (delegate == null) {\n+                throw new NullPointerException(\"delegate\");\n+            }\n+\n+            this.delegate = delegate;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K, V>> iterator() {\n+            K fromKey = delegate.getFromKey();\n+            K toKey = delegate.getToKey();\n+\n+            TrieEntry<K, V> first = null;\n+            if (fromKey == null) {\n+                first = firstEntry();\n+            } else {\n+                first = ceilingEntry(fromKey);\n+            }\n+\n+            TrieEntry<K, V> last = null;\n+            if (toKey != null) {\n+                last = ceilingEntry(toKey);\n+            }\n+\n+            return new EntryIterator(first, last);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            if (size == -1 || expectedModCount != PatriciaTrie.this.modCount) {\n+                size = 0;\n+\n+                for (Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n+                    ++size;\n+                }\n+\n+                expectedModCount = PatriciaTrie.this.modCount;\n+            }\n+            return size;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean isEmpty() {\n+            return !iterator().hasNext();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public boolean contains(Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            K key = entry.getKey();\n+            if (!delegate.inRange(key)) {\n+                return false;\n+            }\n+\n+            TrieEntry<K, V> node = getEntry(key);\n+            return node != null && compare(node.getValue(), entry.getValue());\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public boolean remove(Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+\n+            Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n+            K key = entry.getKey();\n+            if (!delegate.inRange(key)) {\n+                return false;\n+            }\n+\n+            TrieEntry<K, V> node = getEntry(key);\n+            if (node != null && compare(node.getValue(), entry.getValue())) {\n+                removeEntry(node);\n+                return true;\n+            }\n+            return false;\n+        }\n+        \n+        /** \n+         * An {@link Iterator} for {@link RangeEntrySet}s. \n+         */\n+        private final class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+            \n+            private final K excludedKey;\n+\n+            /**\n+             * Creates a {@link EntryIterator}\n+             */\n+            private EntryIterator(\n+                    TrieEntry<K,V> first, \n+                    TrieEntry<K,V> last) {\n+                super(first);\n+                \n+                this.excludedKey = (last != null ? last.getKey() : null);\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            @Override\n+            public boolean hasNext() {\n+                return next != null && !compare(next.key, excludedKey);\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public Map.Entry<K,V> next() {\n+                if (next == null || compare(next.key, excludedKey)) {\n+                    throw new NoSuchElementException();\n+                }\n+                \n+                return nextEntry();\n+            }\n+        }\n+    }   \n+   \n+    /** \n+     * A submap used for prefix views over the {@link Trie}. \n+     */\n+    private class PrefixRangeMap extends RangeMap {\n+        \n+        private final K prefix;\n+        \n+        private final int offsetInBits;\n+        \n+        private final int lengthInBits;\n+        \n+        private K fromKey = null;\n+        \n+        private K toKey = null;\n+        \n+        private transient int expectedModCount = 0;\n+        \n+        private int size = -1;\n+        \n+        /**\n+         * Creates a {@link PrefixRangeMap}\n+         */\n+        private PrefixRangeMap(K prefix, int offsetInBits, int lengthInBits) {\n+            this.prefix = prefix;\n+            this.offsetInBits = offsetInBits;\n+            this.lengthInBits = lengthInBits;\n+        }\n+        \n+        /**\n+         * This method does two things. It determinates the FROM\n+         * and TO range of the {@link PrefixRangeMap} and the number\n+         * of elements in the range. This method must be called every \n+         * time the {@link Trie} has changed.\n+         */\n+        private int fixup() {\n+            // The trie has changed since we last\n+            // found our toKey / fromKey\n+            if (size == - 1 || PatriciaTrie.this.modCount != expectedModCount) {\n+                Iterator<Map.Entry<K, V>> it = entrySet().iterator();\n+                size = 0;\n+                \n+                Map.Entry<K, V> entry = null;\n+                if (it.hasNext()) {\n+                    entry = it.next();\n+                    size = 1;\n+                }\n+                \n+                fromKey = entry == null ? null : entry.getKey();\n+                if (fromKey != null) {\n+                    TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>)entry);\n+                    fromKey = prior == null ? null : prior.getKey();\n+                }\n+                \n+                toKey = fromKey;\n+                \n+                while (it.hasNext()) {\n+                    ++size;\n+                    entry = it.next();\n+                }\n+                \n+                toKey = entry == null ? null : entry.getKey();\n+                \n+                if (toKey != null) {\n+                    entry = nextEntry((TrieEntry<K, V>)entry);\n+                    toKey = entry == null ? null : entry.getKey();\n+                }\n+                \n+                expectedModCount = PatriciaTrie.this.modCount;\n+            }\n+            \n+            return size;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K firstKey() {\n+            fixup();\n+            \n+            Map.Entry<K,V> e = null;\n+            if (fromKey == null) {\n+                e = firstEntry();\n+            } else {\n+                e = higherEntry(fromKey);\n+            }\n+            \n+            K first = e != null ? e.getKey() : null;\n+            if (e == null || !keyAnalyzer.isPrefix(prefix, \n+                    offsetInBits, lengthInBits, first)) {\n+                throw new NoSuchElementException();\n+            }\n+            \n+            return first;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K lastKey() {\n+            fixup();\n+            \n+            Map.Entry<K,V> e = null;\n+            if (toKey == null) {\n+                e = lastEntry();\n+            } else {\n+                e = lowerEntry(toKey);\n+            }\n+            \n+            K last = e != null ? e.getKey() : null;\n+            if (e == null || !keyAnalyzer.isPrefix(prefix, \n+                    offsetInBits, lengthInBits, last)) {\n+                throw new NoSuchElementException();\n+            }\n+            \n+            return last;\n+        }\n+        \n+        /**\n+         * Returns true if this {@link PrefixRangeMap}'s key is a prefix\n+         * of the provided key.\n+         */\n+        @Override\n+        protected boolean inRange(K key) {\n+            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+\n+        /**\n+         * Same as {@link #inRange(Object)}\n+         */\n+        @Override\n+        protected boolean inRange2(K key) {\n+            return inRange(key);\n+        }\n+        \n+        /**\n+         * Returns true if the provided Key is in the FROM range\n+         * of the {@link PrefixRangeMap}\n+         */\n+        @Override\n+        protected boolean inFromRange(K key, boolean forceInclusive) {\n+            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+        \n+        /**\n+         * Returns true if the provided Key is in the TO range\n+         * of the {@link PrefixRangeMap}\n+         */\n+        @Override\n+        protected boolean inToRange(K key, boolean forceInclusive) {\n+            return keyAnalyzer.isPrefix(prefix, offsetInBits, lengthInBits, key);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        protected Set<Map.Entry<K, V>> createEntrySet() {\n+            return new PrefixRangeEntrySet(this);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public K getFromKey() {\n+            return fromKey;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public K getToKey() {\n+            return toKey;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean isFromInclusive() {\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean isToInclusive() {\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        protected SortedMap<K, V> createRangeMap(\n+                K fromKey, boolean fromInclusive,\n+                K toKey, boolean toInclusive) {\n+            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n+        }\n+    }\n+    \n+    /**\n+     * A prefix {@link RangeEntrySet} view of the {@link Trie}\n+     */\n+    private final class PrefixRangeEntrySet extends RangeEntrySet {\n+        \n+        private final PrefixRangeMap delegate;\n+        \n+        private TrieEntry<K, V> prefixStart;\n+        \n+        private int expectedModCount = 0;\n+        \n+        /**\n+         * Creates a {@link PrefixRangeEntrySet}\n+         */\n+        public PrefixRangeEntrySet(PrefixRangeMap delegate) {\n+            super(delegate);\n+            this.delegate = delegate;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return delegate.fixup();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            if (PatriciaTrie.this.modCount != expectedModCount) {\n+                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n+                expectedModCount = PatriciaTrie.this.modCount;\n+            }\n+            \n+            if (prefixStart == null) {\n+                Set<Map.Entry<K,V>> empty = Collections.emptySet();\n+                return empty.iterator();\n+            } else if (delegate.lengthInBits >= prefixStart.bitIndex) {\n+                return new SingletonIterator(prefixStart);\n+            } else {\n+                return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n+            }\n+        }\n+        \n+        /** \n+         * An {@link Iterator} that holds a single {@link TrieEntry}. \n+         */\n+        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n+            \n+            private final TrieEntry<K, V> entry;\n+            \n+            private int hit = 0;\n+            \n+            public SingletonIterator(TrieEntry<K, V> entry) {\n+                this.entry = entry;\n+            }\n+            \n+            /**\n+             * {@inheritDoc}\n+             */\n+            public boolean hasNext() {\n+                return hit == 0;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public Map.Entry<K, V> next() {\n+                if (hit != 0) {\n+                    throw new NoSuchElementException();\n+                }\n+                \n+                ++hit;\n+                return entry;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public void remove() {\n+                if (hit != 1) {\n+                    throw new IllegalStateException();\n+                }\n+                \n+                ++hit;\n+                PatriciaTrie.this.removeEntry(entry);\n+            }\n+        }\n+        \n+        /** \n+         * An {@link Iterator} for iterating over a prefix search. \n+         */\n+        private final class EntryIterator extends TrieIterator<Map.Entry<K, V>> {\n+            \n+            // values to reset the subtree if we remove it.\n+            protected final K prefix; \n+            protected final int offset;\n+            protected final int lengthInBits;\n+            protected boolean lastOne;\n+            \n+            protected TrieEntry<K, V> subtree; // the subtree to search within\n+            \n+            /**\n+             * Starts iteration at the given entry & search only \n+             * within the given subtree.\n+             */\n+            EntryIterator(TrieEntry<K, V> startScan, K prefix, \n+                    int offset, int lengthInBits) {\n+                subtree = startScan;\n+                next = PatriciaTrie.this.followLeft(startScan);\n+                this.prefix = prefix;\n+                this.offset = offset;\n+                this.lengthInBits = lengthInBits;\n+            }\n+\n+            /**\n+             * {@inheritDoc}\n+             */\n+            public Map.Entry<K,V> next() {\n+                Map.Entry<K, V> entry = nextEntry();\n+                if (lastOne) {\n+                    next = null;\n+                }\n+                return entry;\n+            }\n+            \n+            /**\n+             * {@inheritDoc}\n+             */\n+            @Override\n+            protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior) {\n+                return PatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n+            }\n+            \n+            /**\n+             * {@inheritDoc}\n+             */\n+            @Override\n+            public void remove() {\n+                // If the current entry we're removing is the subtree\n+                // then we need to find a new subtree parent.\n+                boolean needsFixing = false;\n+                int bitIdx = subtree.bitIndex;\n+                if (current == subtree) {\n+                    needsFixing = true;\n+                }\n+                \n+                super.remove();\n+                \n+                // If the subtree changed its bitIndex or we\n+                // removed the old subtree, get a new one.\n+                if (bitIdx != subtree.bitIndex || needsFixing) {\n+                    subtree = subtree(prefix, offset, lengthInBits);\n+                }\n+                \n+                // If the subtree's bitIndex is less than the\n+                // length of our prefix, it's the last item\n+                // in the prefix tree.\n+                if (lengthInBits >= subtree.bitIndex) {\n+                    lastOne = true;\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/PatriciaTrieBase.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.Trie.Cursor.Decision;\n+\n+/**\n+ * This class implements the base PATRICIA algorithm and everything that\n+ * is related to the {@link Map} interface.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+abstract class PatriciaTrieBase<K, V> extends AbstractTrie<K, V> {\n+    \n+    private static final long serialVersionUID = 5155253417231339498L;\n+\n+    /**\n+     * The root node of the {@link Trie}. \n+     */\n+    final TrieEntry<K, V> root = new TrieEntry<K, V>(null, null, -1);\n+    \n+    /**\n+     * Each of these fields are initialized to contain an instance of the\n+     * appropriate view the first time this view is requested. The views are\n+     * stateless, so there's no reason to create more than one of each.\n+     */\n+    private transient volatile Set<K> keySet;\n+    private transient volatile Collection<V> values;\n+    private transient volatile Set<Map.Entry<K,V>> entrySet;\n+    \n+    /**\n+     * The current size of the {@link Trie}\n+     */\n+    private int size = 0;\n+    \n+    /**\n+     * The number of times this {@link Trie} has been modified.\n+     * It's used to detect concurrent modifications and fail-fast\n+     * the {@link Iterator}s.\n+     */\n+    transient int modCount = 0;\n+    \n+    /** \n+     * {@inheritDoc}\n+     */\n+    public PatriciaTrieBase(KeyAnalyzer<? super K> keyAnalyzer) {\n+        super(keyAnalyzer);\n+    }\n+    \n+    /**\n+     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer} \n+     * and initializes the {@link Trie} with the values from the \n+     * provided {@link Map}.\n+     */\n+    public PatriciaTrieBase(KeyAnalyzer<? super K> keyAnalyzer, \n+            Map<? extends K, ? extends V> m) {\n+        super(keyAnalyzer);\n+        \n+        if (m == null) {\n+            throw new NullPointerException(\"m\");\n+        }\n+        \n+        putAll(m);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        root.key = null;\n+        root.bitIndex = -1;\n+        root.value = null;\n+        \n+        root.parent = null;\n+        root.left = root;\n+        root.right = null;\n+        root.predecessor = root;\n+        \n+        size = 0;\n+        incrementModCount();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int size() {\n+        return size;\n+    }\n+   \n+    /**\n+     * A helper method to increment the {@link Trie} size\n+     * and the modification counter.\n+     */\n+    void incrementSize() {\n+        size++;\n+        incrementModCount();\n+    }\n+    \n+    /**\n+     * A helper method to decrement the {@link Trie} size\n+     * and increment the modification counter.\n+     */\n+    void decrementSize() {\n+        size--;\n+        incrementModCount();\n+    }\n+    \n+    /**\n+     * A helper method to increment the modification counter.\n+     */\n+    private void incrementModCount() {\n+        ++modCount;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V put(K key, V value) {\n+        if (key == null) {\n+            throw new NullPointerException(\"Key cannot be null\");\n+        }\n+        \n+        int lengthInBits = lengthInBits(key);\n+        \n+        // The only place to store a key with a length\n+        // of zero bits is the root node\n+        if (lengthInBits == 0) {\n+            if (root.isEmpty()) {\n+                incrementSize();\n+            } else {\n+                incrementModCount();\n+            }\n+            return root.setKeyValue(key, value);\n+        }\n+        \n+        TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n+        if (compareKeys(key, found.key)) {\n+            if (found.isEmpty()) { // <- must be the root\n+                incrementSize();\n+            } else {\n+                incrementModCount();\n+            }\n+            return found.setKeyValue(key, value);\n+        }\n+        \n+        int bitIndex = bitIndex(key, found.key);\n+        if (!AbstractKeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n+            if (AbstractKeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n+                /* NEW KEY+VALUE TUPLE */\n+                TrieEntry<K, V> t = new TrieEntry<K, V>(key, value, bitIndex);\n+                addEntry(t, lengthInBits);\n+                incrementSize();\n+                return null;\n+            } else if (AbstractKeyAnalyzer.isNullBitKey(bitIndex)) {\n+                // A bits of the Key are zero. The only place to\n+                // store such a Key is the root Node!\n+                \n+                /* NULL BIT KEY */\n+                if (root.isEmpty()) {\n+                    incrementSize();\n+                } else {\n+                    incrementModCount();\n+                }\n+                return root.setKeyValue(key, value);\n+                \n+            } else if (AbstractKeyAnalyzer.isEqualBitKey(bitIndex)) {\n+                // This is a very special and rare case.\n+                \n+                /* REPLACE OLD KEY+VALUE */\n+                if (found != root) {\n+                    incrementModCount();\n+                    return found.setKeyValue(key, value);\n+                }\n+            }\n+        }\n+        \n+        throw new IndexOutOfBoundsException(\"Failed to put: \" \n+                + key + \" -> \" + value + \", \" + bitIndex);\n+    }\n+    \n+    /**\n+     * Adds the given {@link TrieEntry} to the {@link Trie}\n+     */\n+    TrieEntry<K, V> addEntry(TrieEntry<K, V> entry, int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex >= entry.bitIndex \n+                    || current.bitIndex <= path.bitIndex) {\n+                entry.predecessor = entry;\n+                \n+                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n+                    entry.left = entry;\n+                    entry.right = current;\n+                } else {\n+                    entry.left = current;\n+                    entry.right = entry;\n+                }\n+               \n+                entry.parent = path;\n+                if (current.bitIndex >= entry.bitIndex) {\n+                    current.parent = entry;\n+                }\n+                \n+                // if we inserted an uplink, set the predecessor on it\n+                if (current.bitIndex <= path.bitIndex) {\n+                    current.predecessor = entry;\n+                }\n+         \n+                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n+                    path.left = entry;\n+                } else {\n+                    path.right = entry;\n+                }\n+                \n+                return entry;\n+            }\n+                \n+            path = current;\n+            \n+            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public V get(Object k) {\n+        TrieEntry<K, V> entry = getEntry(k);\n+        return entry != null ? entry.getValue() : null;\n+    }\n+\n+    /**\n+     * Returns the entry associated with the specified key in the\n+     * PatriciaTrieBase.  Returns null if the map contains no mapping\n+     * for this key.\n+     * \n+     * This may throw ClassCastException if the object is not of type K.\n+     */\n+    TrieEntry<K,V> getEntry(Object k) {\n+        K key = castKey(k);\n+        if (key == null) {\n+            return null;\n+        }\n+        \n+        int lengthInBits = lengthInBits(key);\n+        TrieEntry<K,V> entry = getNearestEntryForKey(key, lengthInBits);\n+        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Map.Entry<K, V> select(K key) {\n+        int lengthInBits = lengthInBits(key);\n+        Reference<Map.Entry<K, V>> reference \n+            = new Reference<Map.Entry<K,V>>();\n+        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n+            return reference.get();\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Map.Entry<K,V> select(K key, Cursor<? super K, ? super V> cursor) {\n+        int lengthInBits = lengthInBits(key);\n+        Reference<Map.Entry<K, V>> reference \n+            = new Reference<Map.Entry<K,V>>();\n+        selectR(root.left, -1, key, lengthInBits, cursor, reference);\n+        return reference.get();\n+    }\n+\n+    /**\n+     * This is equivalent to the other {@link #selectR(TrieEntry, int, \n+     * Object, int, Cursor, Reference)} method but without its overhead \n+     * because we're selecting only one best matching Entry from the \n+     * {@link Trie}.\n+     */\n+    private boolean selectR(TrieEntry<K, V> h, int bitIndex, \n+            final K key, final int lengthInBits, \n+            final Reference<Map.Entry<K, V>> reference) {\n+        \n+        if (h.bitIndex <= bitIndex) {\n+            // If we hit the root Node and it is empty\n+            // we have to look for an alternative best\n+            // matching node.\n+            if (!h.isEmpty()) {\n+                reference.set(h);\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n+            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n+                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n+            }\n+        } else {\n+            if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n+                return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * \n+     */\n+    private boolean selectR(TrieEntry<K,V> h, int bitIndex, \n+            final K key, \n+            final int lengthInBits,\n+            final Cursor<? super K, ? super V> cursor,\n+            final Reference<Map.Entry<K, V>> reference) {\n+\n+        if (h.bitIndex <= bitIndex) {\n+            if (!h.isEmpty()) {\n+                Decision decision = cursor.select(h);\n+                switch(decision) {\n+                    case REMOVE:\n+                        throw new UnsupportedOperationException(\"Cannot remove during select\");\n+                    case EXIT:\n+                        reference.set(h);\n+                        return false; // exit\n+                    case REMOVE_AND_EXIT:\n+                        TrieEntry<K, V> entry = new TrieEntry<K, V>(\n+                                h.getKey(), h.getValue(), -1);\n+                        reference.set(entry);\n+                        removeEntry(h);\n+                        return false;\n+                    case CONTINUE:\n+                        // fall through.\n+                    default:\n+                        break;\n+                }\n+            }\n+            return true; // continue\n+        }\n+\n+        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n+            if (selectR(h.left, h.bitIndex, key, lengthInBits, cursor, reference)) {\n+                return selectR(h.right, h.bitIndex, key, lengthInBits, cursor, reference);\n+            }\n+        } else {\n+            if (selectR(h.right, h.bitIndex, key, lengthInBits, cursor, reference)) {\n+                return selectR(h.left, h.bitIndex, key, lengthInBits, cursor, reference);\n+            }\n+        }\n+        \n+        return false;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Map.Entry<K, V> traverse(Cursor<? super K, ? super V> cursor) {\n+        TrieEntry<K, V> entry = nextEntry(null);\n+        while (entry != null) {\n+            TrieEntry<K, V> current = entry;\n+            \n+            Decision decision = cursor.select(current);\n+            entry = nextEntry(current);\n+            \n+            switch(decision) {\n+                case EXIT:\n+                    return current;\n+                case REMOVE:\n+                    removeEntry(current);\n+                    break; // out of switch, stay in while loop\n+                case REMOVE_AND_EXIT:\n+                    Map.Entry<K, V> value = new TrieEntry<K, V>(\n+                            current.getKey(), current.getValue(), -1);\n+                    removeEntry(current);\n+                    return value;\n+                case CONTINUE: // do nothing.\n+                default:\n+                    break;\n+            }\n+        }\n+        \n+        return null;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean containsKey(Object k) {\n+        if (k == null) {\n+            return false;\n+        }\n+        \n+        K key = castKey(k);\n+        int lengthInBits = lengthInBits(key);\n+        TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n+        return !entry.isEmpty() && compareKeys(key, entry.key);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Set<Map.Entry<K,V>> entrySet() {\n+        if (entrySet == null) {\n+            entrySet = new EntrySet();\n+        }\n+        return entrySet;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Set<K> keySet() {\n+        if (keySet == null) {\n+            keySet = new KeySet();\n+        }\n+        return keySet;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Collection<V> values() {\n+        if (values == null) {\n+            values = new Values();\n+        }\n+        return values;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @throws ClassCastException if provided key is of an incompatible type \n+     */\n+    @Override\n+    public V remove(Object k) {\n+        if (k == null) {\n+            return null;\n+        }\n+        \n+        K key = castKey(k);\n+        int lengthInBits = lengthInBits(key);        \n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while (true) {\n+            if (current.bitIndex <= path.bitIndex) {\n+                if (!current.isEmpty() && compareKeys(key, current.key)) {\n+                    return removeEntry(current);\n+                } else {\n+                    return null;\n+                }\n+            }\n+            \n+            path = current;\n+            \n+            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Returns the nearest entry for a given key.  This is useful\n+     * for finding knowing if a given key exists (and finding the value\n+     * for it), or for inserting the key.\n+     * \n+     * The actual get implementation. This is very similar to\n+     * selectR but with the exception that it might return the\n+     * root Entry even if it's empty.\n+     */\n+    TrieEntry<K, V> getNearestEntryForKey(K key, int lengthInBits) {\n+        TrieEntry<K, V> current = root.left;\n+        TrieEntry<K, V> path = root;\n+        while(true) {\n+            if (current.bitIndex <= path.bitIndex) {\n+                return current;\n+            }\n+            \n+            path = current;\n+            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n+                current = current.left;\n+            } else {\n+                current = current.right;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Removes a single entry from the {@link Trie}.\n+     * \n+     * If we found a Key (Entry h) then figure out if it's\n+     * an internal (hard to remove) or external Entry (easy \n+     * to remove)\n+     */\n+    V removeEntry(TrieEntry<K, V> h) {\n+        if (h != root) {\n+            if (h.isInternalNode()) {\n+                removeInternalEntry(h);\n+            } else {\n+                removeExternalEntry(h);\n+            }\n+        }\n+        \n+        decrementSize();\n+        return h.setKeyValue(null, null);\n+    }\n+    \n+    /**\n+     * Removes an external entry from the {@link Trie}.\n+     * \n+     * If it's an external Entry then just remove it.\n+     * This is very easy and straight forward.\n+     */\n+    private void removeExternalEntry(TrieEntry<K, V> h) {\n+        if (h == root) {\n+            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n+        } else if (!h.isExternalNode()) {\n+            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n+        } \n+        \n+        TrieEntry<K, V> parent = h.parent;\n+        TrieEntry<K, V> child = (h.left == h) ? h.right : h.left;\n+        \n+        if (parent.left == h) {\n+            parent.left = child;\n+        } else {\n+            parent.right = child;\n+        }\n+        \n+        // either the parent is changing, or the predecessor is changing.\n+        if (child.bitIndex > parent.bitIndex) {\n+            child.parent = parent;\n+        } else {\n+            child.predecessor = parent;\n+        }\n+        \n+    }\n+    \n+    /**\n+     * Removes an internal entry from the {@link Trie}.\n+     * \n+     * If it's an internal Entry then \"good luck\" with understanding\n+     * this code. The Idea is essentially that Entry p takes Entry h's\n+     * place in the trie which requires some re-wiring.\n+     */\n+    private void removeInternalEntry(TrieEntry<K, V> h) {\n+        if (h == root) {\n+            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n+        } else if (!h.isInternalNode()) {\n+            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n+        } \n+        \n+        TrieEntry<K, V> p = h.predecessor;\n+        \n+        // Set P's bitIndex\n+        p.bitIndex = h.bitIndex;\n+        \n+        // Fix P's parent, predecessor and child Nodes\n+        {\n+            TrieEntry<K, V> parent = p.parent;\n+            TrieEntry<K, V> child = (p.left == h) ? p.right : p.left;\n+            \n+            // if it was looping to itself previously,\n+            // it will now be pointed from it's parent\n+            // (if we aren't removing it's parent --\n+            //  in that case, it remains looping to itself).\n+            // otherwise, it will continue to have the same\n+            // predecessor.\n+            if (p.predecessor == p && p.parent != h) {\n+                p.predecessor = p.parent;\n+            }\n+            \n+            if (parent.left == p) {\n+                parent.left = child;\n+            } else {\n+                parent.right = child;\n+            }\n+            \n+            if (child.bitIndex > parent.bitIndex) {\n+                child.parent = parent;\n+            }\n+        };\n+        \n+        // Fix H's parent and child Nodes\n+        {         \n+            // If H is a parent of its left and right child \n+            // then change them to P\n+            if (h.left.parent == h) {\n+                h.left.parent = p;\n+            }\n+            \n+            if (h.right.parent == h) {\n+                h.right.parent = p;\n+            }\n+            \n+            // Change H's parent\n+            if (h.parent.left == h) {\n+                h.parent.left = p;\n+            } else {\n+                h.parent.right = p;\n+            }\n+        };\n+        \n+        // Copy the remaining fields from H to P\n+        //p.bitIndex = h.bitIndex;\n+        p.parent = h.parent;\n+        p.left = h.left;\n+        p.right = h.right;\n+        \n+        // Make sure that if h was pointing to any uplinks,\n+        // p now points to them.\n+        if (isValidUplink(p.left, p)) {\n+            p.left.predecessor = p;\n+        }\n+        \n+        if (isValidUplink(p.right, p)) {\n+            p.right.predecessor = p;\n+        }   \n+    }\n+    \n+    /**\n+     * Returns the entry lexicographically after the given entry.\n+     * If the given entry is null, returns the first node.\n+     */\n+    TrieEntry<K, V> nextEntry(TrieEntry<K, V> node) {\n+        if (node == null) {\n+            return firstEntry();\n+        } else {\n+            return nextEntryImpl(node.predecessor, node, null);\n+        }\n+    }\n+    \n+    /**\n+     * Scans for the next node, starting at the specified point, and using 'previous'\n+     * as a hint that the last node we returned was 'previous' (so we know not to return\n+     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n+     * \n+     * The basic premise is that each iteration can follow the following steps:\n+     * \n+     * 1) Scan all the way to the left.\n+     *   a) If we already started from this node last time, proceed to Step 2.\n+     *   b) If a valid uplink is found, use it.\n+     *   c) If the result is an empty node (root not set), break the scan.\n+     *   d) If we already returned the left node, break the scan.\n+     *   \n+     * 2) Check the right.\n+     *   a) If we already returned the right node, proceed to Step 3.\n+     *   b) If it is a valid uplink, use it.\n+     *   c) Do Step 1 from the right node.\n+     *   \n+     * 3) Back up through the parents until we encounter find a parent\n+     *    that we're not the right child of.\n+     *    \n+     * 4) If there's no right child of that parent, the iteration is finished.\n+     *    Otherwise continue to Step 5.\n+     * \n+     * 5) Check to see if the right child is a valid uplink.\n+     *    a) If we already returned that child, proceed to Step 6.\n+     *       Otherwise, use it.\n+     *    \n+     * 6) If the right child of the parent is the parent itself, we've\n+     *    already found & returned the end of the Trie, so exit.\n+     *    \n+     * 7) Do Step 1 on the parent's right child.\n+     */\n+    TrieEntry<K, V> nextEntryImpl(TrieEntry<K, V> start, \n+            TrieEntry<K, V> previous, TrieEntry<K, V> tree) {\n+        \n+        TrieEntry<K, V> current = start;\n+\n+        // Only look at the left if this was a recursive or\n+        // the first check, otherwise we know we've already looked\n+        // at the left.\n+        if (previous == null || start != previous.predecessor) {\n+            while (!current.left.isEmpty()) {\n+                // stop traversing if we've already\n+                // returned the left of this node.\n+                if (previous == current.left) {\n+                    break;\n+                }\n+                \n+                if (isValidUplink(current.left, current)) {\n+                    return current.left;\n+                }\n+                \n+                current = current.left;\n+            }\n+        }\n+        \n+        // If there's no data at all, exit.\n+        if (current.isEmpty()) {\n+            return null;\n+        }\n+        \n+        // If we've already returned the left,\n+        // and the immediate right is null,\n+        // there's only one entry in the Trie\n+        // which is stored at the root.\n+        //\n+        //  / (\"\")   <-- root\n+        //  \\_/  \\\n+        //       null <-- 'current'\n+        //\n+        if (current.right == null) {\n+            return null;\n+        }\n+        \n+        // If nothing valid on the left, try the right.\n+        if (previous != current.right) {\n+            // See if it immediately is valid.\n+            if (isValidUplink(current.right, current)) {\n+                return current.right;\n+            }\n+            \n+            // Must search on the right's side if it wasn't initially valid.\n+            return nextEntryImpl(current.right, previous, tree);\n+        }\n+        \n+        // Neither left nor right are valid, find the first parent\n+        // whose child did not come from the right & traverse it.\n+        while (current == current.parent.right) {\n+            // If we're going to traverse to above the subtree, stop.\n+            if (current == tree) {\n+                return null;\n+            }\n+            \n+            current = current.parent;\n+        }\n+\n+        // If we're on the top of the subtree, we can't go any higher.\n+        if (current == tree) {\n+            return null;\n+        }\n+        \n+        // If there's no right, the parent must be root, so we're done.\n+        if (current.parent.right == null) {\n+            return null;\n+        }\n+        \n+        // If the parent's right points to itself, we've found one.\n+        if (previous != current.parent.right \n+                && isValidUplink(current.parent.right, current.parent)) {\n+            return current.parent.right;\n+        }\n+        \n+        // If the parent's right is itself, there can't be any more nodes.\n+        if (current.parent.right == current.parent) {\n+            return null;\n+        }\n+        \n+        // We need to traverse down the parent's right's path.\n+        return nextEntryImpl(current.parent.right, previous, tree);\n+    }\n+    \n+    /**\n+     * Returns the first entry the {@link Trie} is storing.\n+     * \n+     * This is implemented by going always to the left until\n+     * we encounter a valid uplink. That uplink is the first key.\n+     */\n+    TrieEntry<K, V> firstEntry() {\n+        // if Trie is empty, no first node.\n+        if (isEmpty()) {\n+            return null;\n+        }\n+        \n+        return followLeft(root);\n+    }\n+    \n+    /** \n+     * Goes left through the tree until it finds a valid node. \n+     */\n+    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n+        while(true) {\n+            TrieEntry<K, V> child = node.left;\n+            // if we hit root and it didn't have a node, go right instead.\n+            if (child.isEmpty()) {\n+                child = node.right;\n+            }\n+            \n+            if (child.bitIndex <= node.bitIndex) {\n+                return child;\n+            }\n+            \n+            node = child;\n+        }\n+    }\n+    \n+    /** \n+     * Returns true if 'next' is a valid uplink coming from 'from'. \n+     */\n+    static boolean isValidUplink(TrieEntry<?, ?> next, TrieEntry<?, ?> from) { \n+        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n+    }\n+    \n+    /**\n+     * A {@link Reference} allows us to return something through a Method's \n+     * argument list. An alternative would be to an Array with a length of \n+     * one (1) but that leads to compiler warnings. Computationally and memory\n+     * wise there's no difference (except for the need to load the \n+     * {@link Reference} Class but that happens only once).\n+     */\n+    private static class Reference<E> {\n+        \n+        private E item;\n+        \n+        public void set(E item) {\n+            this.item = item;\n+        }\n+        \n+        public E get() {\n+            return item;\n+        }\n+    }\n+    \n+    /**\n+     *  A {@link Trie} is a set of {@link TrieEntry} nodes\n+     */\n+    static class TrieEntry<K,V> extends BasicEntry<K, V> {\n+        \n+        private static final long serialVersionUID = 4596023148184140013L;\n+        \n+        /** The index this entry is comparing. */\n+        protected int bitIndex;\n+        \n+        /** The parent of this entry. */\n+        protected TrieEntry<K,V> parent;\n+        \n+        /** The left child of this entry. */\n+        protected TrieEntry<K,V> left;\n+        \n+        /** The right child of this entry. */\n+        protected TrieEntry<K,V> right;\n+        \n+        /** The entry who uplinks to this entry. */ \n+        protected TrieEntry<K,V> predecessor;\n+        \n+        public TrieEntry(K key, V value, int bitIndex) {\n+            super(key, value);\n+            \n+            this.bitIndex = bitIndex;\n+            \n+            this.parent = null;\n+            this.left = this;\n+            this.right = null;\n+            this.predecessor = this;\n+        }\n+        \n+        /**\n+         * Whether or not the entry is storing a key.\n+         * Only the root can potentially be empty, all other\n+         * nodes must have a key.\n+         */\n+        public boolean isEmpty() {\n+            return key == null;\n+        }\n+        \n+        /** \n+         * Neither the left nor right child is a loopback \n+         */\n+        public boolean isInternalNode() {\n+            return left != this && right != this;\n+        }\n+        \n+        /** \n+         * Either the left or right child is a loopback \n+         */\n+        public boolean isExternalNode() {\n+            return !isInternalNode();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            StringBuilder buffer = new StringBuilder();\n+            \n+            if (bitIndex == -1) {\n+                buffer.append(\"RootEntry(\");\n+            } else {\n+                buffer.append(\"Entry(\");\n+            }\n+            \n+            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n+            buffer.append(\"value=\").append(getValue()).append(\", \");\n+            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n+            \n+            if (parent != null) {\n+                if (parent.bitIndex == -1) {\n+                    buffer.append(\"parent=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"parent=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+            \n+            if (left != null) {\n+                if (left.bitIndex == -1) {\n+                    buffer.append(\"left=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"left=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+            \n+            if (right != null) {\n+                if (right.bitIndex == -1) {\n+                    buffer.append(\"right=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n+                }\n+            } else {\n+                buffer.append(\"right=\").append(\"null\");\n+            }\n+            buffer.append(\", \");\n+            \n+            if (predecessor != null) {\n+                if(predecessor.bitIndex == -1) {\n+                    buffer.append(\"predecessor=\").append(\"ROOT\");\n+                } else {\n+                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n+                           append(predecessor.bitIndex).append(\"]\");\n+                }\n+            }\n+            \n+            buffer.append(\")\");\n+            return buffer.toString();\n+        }\n+    }\n+    \n+\n+    /**\n+     * This is a entry set view of the {@link Trie} as returned \n+     * by {@link Map#entrySet()}\n+     */\n+    private class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<Map.Entry<K,V>> iterator() {\n+            return new EntryIterator();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean contains(Object o) {\n+            if (!(o instanceof Map.Entry)) {\n+                return false;\n+            }\n+            \n+            TrieEntry<K,V> candidate = getEntry(((Map.Entry<?, ?>)o).getKey());\n+            return candidate != null && candidate.equals(o);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean remove(Object o) {\n+            int size = size();\n+            PatriciaTrieBase.this.remove(o);\n+            return size != size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return PatriciaTrieBase.this.size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void clear() {\n+            PatriciaTrieBase.this.clear();\n+        }\n+        \n+        /**\n+         * An {@link Iterator} that returns {@link Entry} Objects\n+         */\n+        private class EntryIterator extends TrieIterator<Map.Entry<K,V>> {\n+            public Map.Entry<K,V> next() {\n+                return nextEntry();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * This is a key set view of the {@link Trie} as returned \n+     * by {@link Map#keySet()}\n+     */\n+    private class KeySet extends AbstractSet<K> {\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<K> iterator() {\n+            return new KeyIterator();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return PatriciaTrieBase.this.size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean contains(Object o) {\n+            return containsKey(o);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean remove(Object o) {\n+            int size = size();\n+            PatriciaTrieBase.this.remove(o);\n+            return size != size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void clear() {\n+            PatriciaTrieBase.this.clear();\n+        }\n+        \n+        /**\n+         * An {@link Iterator} that returns Key Objects\n+         */\n+        private class KeyIterator extends TrieIterator<K> {\n+            public K next() {\n+                return nextEntry().getKey();\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * This is a value view of the {@link Trie} as returned \n+     * by {@link Map#values()}\n+     */\n+    private class Values extends AbstractCollection<V> {\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public Iterator<V> iterator() {\n+            return new ValueIterator();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int size() {\n+            return PatriciaTrieBase.this.size();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean contains(Object o) {\n+            return containsValue(o);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public void clear() {\n+            PatriciaTrieBase.this.clear();\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean remove(Object o) {\n+            for (Iterator<V> it = iterator(); it.hasNext(); ) {\n+                V value = it.next();\n+                if (compare(value, o)) {\n+                    it.remove();\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        \n+        /**\n+         * An {@link Iterator} that returns Value Objects\n+         */\n+        private class ValueIterator extends TrieIterator<V> {\n+            public V next() {\n+                return nextEntry().getValue();\n+            }\n+        }\n+    }\n+    \n+    /** \n+     * An iterator for the entries. \n+     */\n+    abstract class TrieIterator<E> implements Iterator<E> {\n+        \n+        /**\n+         * For fast-fail\n+         */\n+        protected int expectedModCount = PatriciaTrieBase.this.modCount;\n+        \n+        protected TrieEntry<K, V> next; // the next node to return\n+        protected TrieEntry<K, V> current; // the current entry we're on\n+        \n+        /**\n+         * Starts iteration from the root\n+         */\n+        protected TrieIterator() {\n+            next = PatriciaTrieBase.this.nextEntry(null);\n+        }\n+        \n+        /**\n+         * Starts iteration at the given entry\n+         */\n+        protected TrieIterator(TrieEntry<K, V> firstEntry) {\n+            next = firstEntry;\n+        }\n+        \n+        /**\n+         * Returns the next {@link TrieEntry}\n+         */\n+        protected TrieEntry<K,V> nextEntry() { \n+            if (expectedModCount != PatriciaTrieBase.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            \n+            TrieEntry<K,V> e = next;\n+            if (e == null) {\n+                throw new NoSuchElementException();\n+            }\n+            \n+            next = findNext(e);\n+            current = e;\n+            return e;\n+        }\n+        \n+        /**\n+         * @see PatriciaTrie#nextEntry(TrieEntry)\n+         */\n+        protected TrieEntry<K, V> findNext(TrieEntry<K, V> prior) {\n+            return PatriciaTrieBase.this.nextEntry(prior);\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean hasNext() {\n+            return next != null;\n+        }\n+        \n+        /**\n+         * {@inheritDoc}\n+         */\n+        public void remove() {\n+            if (current == null) {\n+                throw new IllegalStateException();\n+            }\n+            \n+            if (expectedModCount != PatriciaTrieBase.this.modCount) {\n+                throw new ConcurrentModificationException();\n+            }\n+            \n+            TrieEntry<K, V> node = current;\n+            current = null;\n+            PatriciaTrieBase.this.removeEntry(node);\n+            \n+            expectedModCount = PatriciaTrieBase.this.modCount;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/ShortKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * A {@link KeyAnalyzer} for {@link Short}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class ShortKeyAnalyzer implements KeyAnalyzer<Short> {\n+    \n+    private static final long serialVersionUID = -8631376733513512017L;\n+\n+    /**\n+     * A singleton instance of {@link ShortKeyAnalyzer}\n+     */\n+    public static final ShortKeyAnalyzer INSTANCE = new ShortKeyAnalyzer();\n+    \n+    /**\n+     * The length of an {@link Short} in bits\n+     */\n+    public static final int LENGTH = Short.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return 1;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(Short key) {\n+        return LENGTH;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(Short key, int bitIndex, int lengthInBits) {\n+        return (key & mask(bitIndex)) != 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(Short key, int offsetInBits, int lengthInBits, \n+            Short other, int otherOffsetInBits, int otherLengthInBits) {\n+        \n+        if (offsetInBits != 0 || otherOffsetInBits != 0) {\n+            throw new IllegalArgumentException(\"offsetInBits=\" + offsetInBits \n+                    + \", otherOffsetInBits=\" + otherOffsetInBits);\n+        }\n+        \n+        int keyValue = key.shortValue();\n+        if (keyValue == 0) {\n+            return NULL_BIT_KEY;\n+        }\n+\n+        int otherValue = (other != null ? other.shortValue() : 0);\n+        \n+        if (keyValue != otherValue) {\n+            int xorValue = keyValue ^ otherValue;\n+            for (int i = 0; i < LENGTH; i++) {\n+                if ((xorValue & mask(i)) != 0) {\n+                    return i;\n+                }\n+            }\n+        }\n+        \n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int compare(Short o1, Short o2) {\n+        return o1.compareTo(o2);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(Short prefix, int offsetInBits, \n+            int lengthInBits, Short key) {\n+        \n+        int value1 = (prefix.shortValue() << offsetInBits);\n+        int value2 = key.shortValue();\n+        \n+        int mask = 0;\n+        for (int i = 0; i < lengthInBits; i++) {\n+            mask |= (0x1 << i);\n+        }\n+        \n+        return (value1 & mask) == (value2 & mask);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/StringKeyAnalyzer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+/**\n+ * An {@link KeyAnalyzer} for {@link String}s.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class StringKeyAnalyzer extends AbstractKeyAnalyzer<String> {\n+    \n+    private static final long serialVersionUID = -7032449491269434877L;\n+    \n+    /**\n+     * A singleton instance of {@link StringKeyAnalyzer}\n+     */\n+    public static final StringKeyAnalyzer INSTANCE = new StringKeyAnalyzer();\n+    \n+    /**\n+     * The number of bits per {@link Character}\n+     */\n+    public static final int LENGTH = Character.SIZE;\n+    \n+    /**\n+     * A bit mask where the first bit is 1 and the others are zero\n+     */\n+    private static final int MSB = 0x8000;\n+    \n+    /**\n+     * Returns a bit mask where the given bit is set\n+     */\n+    private static int mask(int bit) {\n+        return MSB >>> bit;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitsPerElement() {\n+        return LENGTH;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int lengthInBits(String key) {\n+        return (key != null ? key.length() * LENGTH : 0);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int bitIndex(String key, int offsetInBits, int lengthInBits,\n+            String other, int otherOffsetInBits, int otherLengthInBits) {\n+        boolean allNull = true;\n+        \n+        if (offsetInBits % LENGTH != 0 || otherOffsetInBits % LENGTH != 0 \n+                || lengthInBits % LENGTH != 0 || otherLengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"The offsets and lengths must be at Character boundaries\");\n+        }\n+        \n+        \n+        int beginIndex1 = offsetInBits / LENGTH;\n+        int beginIndex2 = otherOffsetInBits / LENGTH;\n+        \n+        int endIndex1 = beginIndex1 + lengthInBits / LENGTH;\n+        int endIndex2 = beginIndex2 + otherLengthInBits / LENGTH;\n+        \n+        int length = Math.max(endIndex1, endIndex2);\n+        \n+        // Look at each character, and if they're different\n+        // then figure out which bit makes the difference\n+        // and return it.\n+        char k = 0, f = 0;\n+        for(int i = 0; i < length; i++) {\n+            int index1 = beginIndex1 + i;\n+            int index2 = beginIndex2 + i;\n+            \n+            if (index1 >= endIndex1) {\n+                k = 0;\n+            } else {\n+                k = key.charAt(index1);\n+            }\n+            \n+            if (other == null || index2 >= endIndex2) {\n+                f = 0;\n+            } else {\n+                f = other.charAt(index2);\n+            }\n+            \n+            if (k != f) {\n+               int x = k ^ f;\n+               return i * LENGTH + (Integer.numberOfLeadingZeros(x) - LENGTH);\n+            }\n+            \n+            if (k != 0) {\n+                allNull = false;\n+            }\n+        }\n+        \n+        // All bits are 0\n+        if (allNull) {\n+            return KeyAnalyzer.NULL_BIT_KEY;\n+        }\n+        \n+        // Both keys are equal\n+        return KeyAnalyzer.EQUAL_BIT_KEY;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isBitSet(String key, int bitIndex, int lengthInBits) {\n+        if (key == null || bitIndex >= lengthInBits) {\n+            return false;\n+        }\n+        \n+        int index = (int)(bitIndex / LENGTH);\n+        int bit = (int)(bitIndex % LENGTH);\n+        \n+        return (key.charAt(index) & mask(bit)) != 0;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isPrefix(String prefix, int offsetInBits, \n+            int lengthInBits, String key) {\n+        if (offsetInBits % LENGTH != 0 || lengthInBits % LENGTH != 0) {\n+            throw new IllegalArgumentException(\n+                    \"Cannot determine prefix outside of Character boundaries\");\n+        }\n+    \n+        String s1 = prefix.substring(offsetInBits / LENGTH, lengthInBits / LENGTH);\n+        return key.startsWith(s1);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/SynchronizedTrie.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Trie;\n+import org.apache.commons.collections.collection.SynchronizedCollection;\n+import org.apache.commons.collections.set.SynchronizedSet;\n+\n+/**\n+ * A synchronized {@link Trie}.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class SynchronizedTrie<K, V> implements Trie<K, V>, Serializable {\n+    \n+    private static final long serialVersionUID = 3121878833178676939L;\n+    \n+    private final Trie<K, V> delegate;\n+    \n+    /**\n+     * Factory method to create a synchronized trie.\n+     * \n+     * @param trie  the trie to decorate, must not be null\n+     * @return a new synchronized trie\n+     * @throws IllegalArgumentException if trie is null\n+     */\n+    public static <K, V> SynchronizedTrie<K, V> synchronizedTrie(Trie<K, V> trie) {\n+        return new SynchronizedTrie<K, V>(trie);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param trie  the trie to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public SynchronizedTrie(Trie<K, V> trie) {\n+        if (trie == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.delegate = trie;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Entry<K, V> select(K key, \n+            Cursor<? super K, ? super V> cursor) {\n+        return delegate.select(key, cursor);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Entry<K, V> select(K key) {\n+        return delegate.select(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized K selectKey(K key) {\n+        return delegate.selectKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized V selectValue(K key) {\n+        return delegate.selectValue(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Entry<K, V> traverse(Cursor<? super K, ? super V> cursor) {\n+        return delegate.traverse(cursor);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Set<Entry<K, V>> entrySet() {\n+        return SynchronizedSet.synchronizedSet(delegate.entrySet());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Set<K> keySet() {\n+        return SynchronizedSet.synchronizedSet(delegate.keySet());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Collection<V> values() {\n+        return SynchronizedCollection.synchronizedCollection(delegate.values());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized void clear() {\n+        delegate.clear();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized boolean containsKey(Object key) {\n+        return delegate.containsKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized boolean containsValue(Object value) {\n+        return delegate.containsValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized V get(Object key) {\n+        return delegate.get(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized boolean isEmpty() {\n+        return delegate.isEmpty();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized V put(K key, V value) {\n+        return delegate.put(key, value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized void putAll(Map<? extends K, ? extends V> m) {\n+        delegate.putAll(m);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized V remove(Object key) {\n+        return delegate.remove(key);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized K lastKey() {\n+        return delegate.lastKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return Collections.synchronizedSortedMap(delegate.subMap(fromKey, toKey));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> tailMap(K fromKey) {\n+        return Collections.synchronizedSortedMap(delegate.tailMap(fromKey));\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized Comparator<? super K> comparator() {\n+        return delegate.comparator();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized K firstKey() {\n+        return delegate.firstKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> headMap(K toKey) {\n+        return Collections.synchronizedSortedMap(delegate.headMap(toKey));\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, offset, length));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> getPrefixedBy(K key, int length) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key, length));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> getPrefixedBy(K key) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedBy(key));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, lengthInBits));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized SortedMap<K, V> getPrefixedByBits(K key, \n+            int offsetInBits, int lengthInBits) {\n+        return Collections.synchronizedSortedMap(delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public synchronized int size() {\n+        return delegate.size();\n+    }\n+\n+    @Override\n+    public synchronized int hashCode() {\n+        return delegate.hashCode();\n+    }\n+    \n+    @Override\n+    public synchronized boolean equals(Object obj) {\n+        return delegate.equals(obj);\n+    }\n+    \n+    @Override\n+    public synchronized String toString() {\n+        return delegate.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/UnmodifiableTrie.java\n+package org.apache.commons.collections.trie;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+\n+import org.apache.commons.collections.Trie;\n+\n+/**\n+ * An unmodifiable {@link Trie}.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+public class UnmodifiableTrie<K, V> implements Trie<K, V>, Serializable {\n+    \n+    private static final long serialVersionUID = -7156426030315945159L;\n+    \n+    private final Trie<K, V> delegate;\n+    \n+    /**\n+     * Factory method to create a unmodifiable trie.\n+     * \n+     * @param trie  the trie to decorate, must not be null\n+     * @return a new unmodifiable trie\n+     * @throws IllegalArgumentException if trie is null\n+     */\n+    public static <K, V> UnmodifiableTrie<K, V> unmodifiableTrie(Trie<K, V> trie) {\n+        return new UnmodifiableTrie<K, V>(trie);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * \n+     * @param trie  the trie to decorate, must not be null\n+     * @throws IllegalArgumentException if set is null\n+     */\n+    public UnmodifiableTrie(Trie<K, V> trie) {\n+        if (trie == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        this.delegate = trie;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Entry<K, V> select(K key, final Cursor<? super K, ? super V> cursor) {\n+        Cursor<K, V> c = new Cursor<K, V>() {\n+            public Decision select(Map.Entry<? extends K, ? extends V> entry) {\n+                Decision decision = cursor.select(entry);\n+                switch (decision) {\n+                    case REMOVE:\n+                    case REMOVE_AND_EXIT:\n+                        throw new UnsupportedOperationException();\n+                    default:\n+                        // other decisions are fine\n+                        break;\n+                }\n+                \n+                return decision;\n+            }\n+        };\n+        \n+        return delegate.select(key, c);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Entry<K, V> select(K key) {\n+        return delegate.select(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K selectKey(K key) {\n+        return delegate.selectKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V selectValue(K key) {\n+        return delegate.selectValue(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Entry<K, V> traverse(final Cursor<? super K, ? super V> cursor) {\n+        Cursor<K, V> c = new Cursor<K, V>() {\n+            public Decision select(Map.Entry<? extends K, ? extends V> entry) {\n+                Decision decision = cursor.select(entry);\n+                switch (decision) {\n+                    case REMOVE:\n+                    case REMOVE_AND_EXIT:\n+                        throw new UnsupportedOperationException();\n+                    default:\n+                        // other decisions are fine\n+                        break;\n+                }\n+                \n+                return decision;\n+            }\n+        };\n+        \n+        return delegate.traverse(c);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<Entry<K, V>> entrySet() {\n+        return Collections.unmodifiableSet(delegate.entrySet());\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Set<K> keySet() {\n+        return Collections.unmodifiableSet(delegate.keySet());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Collection<V> values() {\n+        return Collections.unmodifiableCollection(delegate.values());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void clear() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsKey(Object key) {\n+        return delegate.containsKey(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean containsValue(Object value) {\n+        return delegate.containsValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V get(Object key) {\n+        return delegate.get(key);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public boolean isEmpty() {\n+        return delegate.isEmpty();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V put(K key, V value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public V remove(Object key) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K firstKey() {\n+        return delegate.firstKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return Collections.unmodifiableSortedMap(delegate.headMap(toKey));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public K lastKey() {\n+        return delegate.lastKey();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.subMap(fromKey, toKey));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return Collections.unmodifiableSortedMap(delegate.tailMap(fromKey));\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int offset, int length) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedBy(key, offset, length));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key, int length) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedBy(key, length));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedBy(K key) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedBy(key));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int lengthInBits) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedByBits(key, lengthInBits));\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SortedMap<K, V> getPrefixedByBits(K key, int offsetInBits,\n+            int lengthInBits) {\n+        return Collections.unmodifiableSortedMap(\n+                delegate.getPrefixedByBits(key, offsetInBits, lengthInBits));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Comparator<? super K> comparator() {\n+        return delegate.comparator();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int size() {\n+        return delegate.size();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public int hashCode() {\n+        return delegate.hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object obj) {\n+        return delegate.equals(obj);\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        return delegate.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/trie/package-info.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This package contains implementations of the\n+ * {@link org.apache.commons.collections.Trie Trie} interface.\n+ * <p>\n+ * The implementations are in the form of direct implementations and decorators.\n+ * A decorator wraps another implementation of the interface to add some\n+ * specific additional functionality.\n+ * <p>\n+ * The following implementations are provided in the package:\n+ * <ul>\n+ *   <li>PatriciaTrie - an implementation of a PATRICIA trie\n+ * </ul>\n+ * <p>\n+ * The following decorators are provided:\n+ * <ul>\n+ *   <li>Synchronized - synchronizes method access for multi-threaded environments\n+ *   <li>Unmodifiable - ensures the collection cannot be altered\n+ * </ul>\n+ *\n+ * @version $Id$\n+ */\n+package org.apache.commons.collections.trie;\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/trie/ByteArrayKeyAnalyzerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ByteArrayKeyAnalyzerTest {\n+\n+    private static final int SIZE = 20000;\n+    \n+    @Test\n+    public void bitSet() {\n+        byte[] key = toByteArray(\"10100110\", 2);\n+        ByteArrayKeyAnalyzer ka = new ByteArrayKeyAnalyzer(key.length * 8);\n+        int length = ka.lengthInBits(key);\n+        \n+        Assert.assertTrue(ka.isBitSet(key, 0, length));\n+        Assert.assertFalse(ka.isBitSet(key, 1, length));\n+        Assert.assertTrue(ka.isBitSet(key, 2, length));\n+        Assert.assertFalse(ka.isBitSet(key, 3, length));\n+        Assert.assertFalse(ka.isBitSet(key, 4, length));\n+        Assert.assertTrue(ka.isBitSet(key, 5, length));\n+        Assert.assertTrue(ka.isBitSet(key, 6, length));\n+        Assert.assertFalse(ka.isBitSet(key, 7, length));\n+    }\n+    \n+    @Test\n+    public void keys() {\n+        PatriciaTrie<byte[], BigInteger> trie\n+            = new PatriciaTrie<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n+        \n+        Map<byte[], BigInteger> map \n+            = new TreeMap<byte[], BigInteger>(ByteArrayKeyAnalyzer.INSTANCE);\n+        \n+        for (int i = 0; i < SIZE; i++) {\n+            BigInteger value = BigInteger.valueOf(i);\n+            byte[] key = toByteArray(value);\n+            \n+            BigInteger existing = trie.put(key, value);\n+            Assert.assertNull(existing);\n+            \n+            map.put(key, value);\n+        }\n+        \n+        Assert.assertEquals(map.size(), trie.size());\n+        \n+        for (byte[] key : map.keySet()) {\n+            BigInteger expected = new BigInteger(1, key);\n+            BigInteger value = trie.get(key);\n+            \n+            Assert.assertEquals(expected, value);\n+        }\n+    }\n+    \n+    @Test\n+    public void prefix() {\n+        byte[] prefix   = toByteArray(\"00001010\", 2);\n+        byte[] key1     = toByteArray(\"11001010\", 2);\n+        byte[] key2     = toByteArray(\"10101100\", 2);\n+        \n+        ByteArrayKeyAnalyzer keyAnalyzer = new ByteArrayKeyAnalyzer(key1.length * 8);\n+        \n+        int prefixLength = keyAnalyzer.lengthInBits(prefix);\n+            \n+        Assert.assertFalse(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key1));\n+        Assert.assertTrue(keyAnalyzer.isPrefix(prefix, 4, prefixLength, key2));\n+    }\n+    \n+    private static byte[] toByteArray(String value, int radix) {\n+        return toByteArray(Long.parseLong(value, radix));\n+    }\n+    \n+    private static byte[] toByteArray(long value) {\n+        return toByteArray(BigInteger.valueOf(value));\n+    }\n+    \n+    private static byte[] toByteArray(BigInteger value) {\n+        byte[] src = value.toByteArray();\n+        if (src.length <= 1) {\n+            return src;\n+        }\n+        \n+        if (src[0] != 0) {\n+            return src;\n+        }\n+        \n+        byte[] dst = new byte[src.length-1];\n+        System.arraycopy(src, 1, dst, 0, dst.length);\n+        return dst;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/trie/PatriciaTrieTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.trie;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Random;\n+import java.util.SortedMap;\n+import java.util.StringTokenizer;\n+import java.util.TreeMap;\n+import java.util.Map.Entry;\n+\n+import org.apache.commons.collections.Trie.Cursor;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PatriciaTrieTest {\n+    \n+    @Test\n+    public void testSimple() {\n+        PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n+        Assert.assertTrue(intTrie.isEmpty());\n+        Assert.assertEquals(0, intTrie.size());\n+        \n+        intTrie.put(1, \"One\");\n+        Assert.assertFalse(intTrie.isEmpty());\n+        Assert.assertEquals(1, intTrie.size());\n+        \n+        Assert.assertEquals(\"One\", intTrie.remove(1));\n+        Assert.assertNull(intTrie.remove(1));\n+        Assert.assertTrue(intTrie.isEmpty());\n+        Assert.assertEquals(0, intTrie.size());\n+        \n+        intTrie.put(1, \"One\");\n+        Assert.assertEquals(\"One\", intTrie.get(1));\n+        Assert.assertEquals(\"One\", intTrie.put(1, \"NotOne\"));\n+        Assert.assertEquals(1, intTrie.size());\n+        Assert.assertEquals(\"NotOne\", intTrie.get(1));\n+        Assert.assertEquals(\"NotOne\", intTrie.remove(1));\n+        Assert.assertNull(intTrie.put(1, \"One\"));\n+    }\n+    \n+    @Test\n+    public void testCeilingEntry() {\n+        PatriciaTrie<Character, String> charTrie \n+            = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        \n+        Object[] results = new Object[] {\n+            'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+            'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+            'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+            'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+            'z', \"z\"\n+        };\n+        \n+        for(int i = 0; i < results.length; i++) {\n+            Map.Entry<Character, String> found = charTrie.ceilingEntry((Character)results[i]);\n+            Assert.assertNotNull(found);\n+            Assert.assertEquals(results[i], found.getKey());\n+            Assert.assertEquals(results[++i], found.getValue());\n+        }\n+        \n+        // Remove some & try again...\n+        charTrie.remove('a');\n+        charTrie.remove('z');\n+        charTrie.remove('q');\n+        charTrie.remove('l');\n+        charTrie.remove('p');\n+        charTrie.remove('m');\n+        charTrie.remove('u');\n+        \n+        Map.Entry<Character, String> found = charTrie.ceilingEntry('u');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'v', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('a');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'b', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('z');\n+        Assert.assertNull(found);\n+        \n+        found = charTrie.ceilingEntry('q');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'r', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('l');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'n', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('p');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'r', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('m');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'n', found.getKey());\n+        \n+        found = charTrie.ceilingEntry('\\0');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'b', found.getKey());\n+        \n+        charTrie.put('\\0', \"\");\n+        found = charTrie.ceilingEntry('\\0');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'\\0', found.getKey());      \n+    }\n+    \n+    @Test\n+    public void testLowerEntry() {\n+        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        \n+        Object[] results = new Object[] {\n+            'a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+            'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+            'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+            'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+            'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+            'z', \"z\"\n+        };\n+        \n+        for(int i = 0; i < results.length; i+=2) {\n+            //System.out.println(\"Looking for: \" + results[i]);\n+            Map.Entry<Character, String> found = charTrie.lowerEntry((Character)results[i]);\n+            if(i == 0) {\n+                Assert.assertNull(found);\n+            } else {\n+                Assert.assertNotNull(found);\n+                Assert.assertEquals(results[i-2], found.getKey());\n+                Assert.assertEquals(results[i-1], found.getValue());\n+            }\n+        }\n+\n+        Map.Entry<Character, String> found = charTrie.lowerEntry((char)('z' + 1));\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'z', found.getKey());\n+        \n+        // Remove some & try again...\n+        charTrie.remove('a');\n+        charTrie.remove('z');\n+        charTrie.remove('q');\n+        charTrie.remove('l');\n+        charTrie.remove('p');\n+        charTrie.remove('m');\n+        charTrie.remove('u');\n+        \n+        found = charTrie.lowerEntry('u');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'t', found.getKey());\n+        \n+        found = charTrie.lowerEntry('v');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'t', found.getKey());\n+        \n+        found = charTrie.lowerEntry('a');\n+        Assert.assertNull(found);\n+        \n+        found = charTrie.lowerEntry('z');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'y', found.getKey());\n+        \n+        found = charTrie.lowerEntry((char)('z'+1));\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'y', found.getKey());\n+        \n+        found = charTrie.lowerEntry('q');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'o', found.getKey());\n+        \n+        found = charTrie.lowerEntry('r');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'o', found.getKey());\n+        \n+        found = charTrie.lowerEntry('p');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'o', found.getKey());\n+        \n+        found = charTrie.lowerEntry('l');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'k', found.getKey());\n+        \n+        found = charTrie.lowerEntry('m');\n+        Assert.assertNotNull(found);\n+        Assert.assertEquals((Character)'k', found.getKey());\n+        \n+        found = charTrie.lowerEntry('\\0');\n+        Assert.assertNull(found);\n+        \n+        charTrie.put('\\0', \"\");\n+        found = charTrie.lowerEntry('\\0');\n+        Assert.assertNull(found);      \n+    }\n+    \n+    @Test\n+    public void testIteration() {\n+        PatriciaTrie<Integer, String> intTrie = new PatriciaTrie<Integer, String>(new IntegerKeyAnalyzer());\n+        intTrie.put(1, \"One\");\n+        intTrie.put(5, \"Five\");\n+        intTrie.put(4, \"Four\");\n+        intTrie.put(2, \"Two\");\n+        intTrie.put(3, \"Three\");\n+        intTrie.put(15, \"Fifteen\");\n+        intTrie.put(13, \"Thirteen\");\n+        intTrie.put(14, \"Fourteen\");\n+        intTrie.put(16, \"Sixteen\");\n+        \n+        TestCursor cursor = new TestCursor(\n+                1, \"One\", 2, \"Two\", 3, \"Three\", 4, \"Four\", 5, \"Five\", 13, \"Thirteen\",\n+                14, \"Fourteen\", 15, \"Fifteen\", 16, \"Sixteen\");\n+\n+        cursor.starting();\n+        intTrie.traverse(cursor);\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (Map.Entry<Integer, String> entry : intTrie.entrySet()) {\n+            cursor.select(entry);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (Integer integer : intTrie.keySet()) {\n+            cursor.checkKey(integer);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (String string : intTrie.values()) {\n+            cursor.checkValue(string);\n+        }\n+        cursor.finished();\n+\n+        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'z', \"z\");\n+        \n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+\n+        cursor.starting();\n+        for (Map.Entry<Character, String> entry : charTrie.entrySet()) {\n+            cursor.select(entry);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (Character character : charTrie.keySet()) {\n+            cursor.checkKey(character);\n+        }\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (String string : charTrie.values()) {\n+            cursor.checkValue(string);\n+        }\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testSelect() {\n+        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        TestCursor cursor = new TestCursor(\n+                'd', \"d\", 'e', \"e\", 'f', \"f\", 'g', \"g\",\n+                'a', \"a\", 'b', \"b\", 'c', \"c\",  \n+                'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'h', \"h\", 'i', \"i\", 'j', \"j\", 'k', \"k\", \n+                't', \"t\", 'u', \"u\", 'v', \"v\", 'w', \"w\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", \n+                'x', \"x\", 'y', \"y\", 'z', \"z\");\n+                \n+        Assert.assertEquals(26, charTrie.size());\n+        \n+        cursor.starting();\n+        charTrie.select('d', cursor);\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testTraverseCursorRemove() {\n+        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'z', \"z\");\n+        \n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+        \n+        // Test removing both an internal & external node.\n+        // 'm' is an example External node in this Trie, and 'p' is an internal.\n+        \n+        Assert.assertEquals(26, charTrie.size());\n+        \n+        Object[] toRemove = new Object[] { 'g', 'd', 'e', 'm', 'p', 'q', 'r', 's' };\n+        cursor.addToRemove(toRemove);\n+        \n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+            \n+        Assert.assertEquals(26 - toRemove.length, charTrie.size());\n+\n+        cursor.starting();\n+        charTrie.traverse(cursor);\n+        cursor.finished();\n+        \n+        cursor.starting();\n+        for (Entry<Character, String> entry : charTrie.entrySet()) {\n+            cursor.select(entry);\n+            if (Arrays.asList(toRemove).contains(entry.getKey())) {\n+                Assert.fail(\"got an: \" + entry);\n+            }\n+        }\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testIteratorRemove() {\n+        PatriciaTrie<Character, String> charTrie = new PatriciaTrie<Character, String>(new CharacterKeyAnalyzer());\n+        charTrie.put('c', \"c\");\n+        charTrie.put('p', \"p\");\n+        charTrie.put('l', \"l\");\n+        charTrie.put('t', \"t\");\n+        charTrie.put('k', \"k\");\n+        charTrie.put('a', \"a\");\n+        charTrie.put('y', \"y\");\n+        charTrie.put('r', \"r\");\n+        charTrie.put('u', \"u\");\n+        charTrie.put('o', \"o\");\n+        charTrie.put('w', \"w\");\n+        charTrie.put('i', \"i\");\n+        charTrie.put('e', \"e\");\n+        charTrie.put('x', \"x\");\n+        charTrie.put('q', \"q\");\n+        charTrie.put('b', \"b\");\n+        charTrie.put('j', \"j\");\n+        charTrie.put('s', \"s\");\n+        charTrie.put('n', \"n\");\n+        charTrie.put('v', \"v\");\n+        charTrie.put('g', \"g\");\n+        charTrie.put('h', \"h\");\n+        charTrie.put('m', \"m\");\n+        charTrie.put('z', \"z\");\n+        charTrie.put('f', \"f\");\n+        charTrie.put('d', \"d\");\n+        TestCursor cursor = new TestCursor('a', \"a\", 'b', \"b\", 'c', \"c\", 'd', \"d\", 'e', \"e\",\n+                'f', \"f\", 'g', \"g\", 'h', \"h\", 'i', \"i\", 'j', \"j\",\n+                'k', \"k\", 'l', \"l\", 'm', \"m\", 'n', \"n\", 'o', \"o\",\n+                'p', \"p\", 'q', \"q\", 'r', \"r\", 's', \"s\", 't', \"t\",\n+                'u', \"u\", 'v', \"v\", 'w', \"w\", 'x', \"x\", 'y', \"y\", \n+                'z', \"z\");\n+        \n+        // Test removing both an internal & external node.\n+        // 'm' is an example External node in this Trie, and 'p' is an internal.\n+        \n+        Assert.assertEquals(26, charTrie.size());\n+        \n+        Object[] toRemove = new Object[] { 'e', 'm', 'p', 'q', 'r', 's' };\n+        \n+        cursor.starting();\n+        for(Iterator<Map.Entry<Character, String>> i = charTrie.entrySet().iterator(); i.hasNext(); ) {\n+            Map.Entry<Character,String> entry = i.next();\n+            cursor.select(entry);\n+            if(Arrays.asList(toRemove).contains(entry.getKey())) {\n+                i.remove();            \n+            }\n+        }\n+        cursor.finished();\n+            \n+        Assert.assertEquals(26 - toRemove.length, charTrie.size());\n+        \n+        cursor.remove(toRemove);\n+\n+        cursor.starting();\n+        for (Entry<Character, String> entry : charTrie.entrySet()) {\n+            cursor.select(entry);\n+            if (Arrays.asList(toRemove).contains(entry.getKey())) {\n+                Assert.fail(\"got an: \" + entry);\n+            }\n+        }\n+        cursor.finished();\n+    }\n+    \n+    @Test\n+    public void testHamlet() throws Exception {\n+        // Make sure that Hamlet is read & stored in the same order as a SortedSet.\n+        List<String> original = new ArrayList<String>();\n+        List<String> control = new ArrayList<String>();\n+        SortedMap<String, String> sortedControl = new TreeMap<String, String>();\n+        PatriciaTrie<String, String> trie = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        InputStream in = getClass().getResourceAsStream(\"hamlet.txt\");\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n+        \n+        String read = null;\n+        while( (read = reader.readLine()) != null) {\n+            StringTokenizer st = new StringTokenizer(read);\n+            while(st.hasMoreTokens()) {\n+                String token = st.nextToken();\n+                original.add(token);\n+                sortedControl.put(token, token);\n+                trie.put(token, token);\n+            }\n+        }\n+        control.addAll(sortedControl.values());\n+\n+        Assert.assertEquals(control.size(), sortedControl.size());\n+        Assert.assertEquals(sortedControl.size(), trie.size());\n+        Iterator<String> iter = trie.values().iterator();\n+        for (String aControl : control) {\n+            Assert.assertEquals(aControl, iter.next());\n+        }\n+        \n+        Random rnd = new Random();\n+        int item = 0;\n+        iter = trie.values().iterator();\n+        int removed = 0;\n+        for(; item < control.size(); item++) {\n+            Assert.assertEquals(control.get(item), iter.next());\n+            if(rnd.nextBoolean()) {\n+                iter.remove();\n+                removed++;\n+            }\n+        }\n+        \n+        Assert.assertEquals(control.size(), item);\n+        Assert.assertTrue(removed > 0);\n+        Assert.assertEquals(control.size(), trie.size() + removed);\n+        \n+        // reset hamlet\n+        trie.clear();\n+        for (String anOriginal : original) {\n+            trie.put(anOriginal, anOriginal);\n+        }\n+        \n+        assertEqualArrays(sortedControl.values().toArray(), trie.values().toArray());\n+        assertEqualArrays(sortedControl.keySet().toArray(), trie.keySet().toArray());\n+        assertEqualArrays(sortedControl.entrySet().toArray(), trie.entrySet().toArray());\n+        \n+        Assert.assertEquals(sortedControl.firstKey(), trie.firstKey());\n+        Assert.assertEquals(sortedControl.lastKey(), trie.lastKey());\n+        \n+        SortedMap<String, String> sub = trie.headMap(control.get(523));\n+        Assert.assertEquals(523, sub.size());\n+        for(int i = 0; i < control.size(); i++) {\n+            if(i < 523) {\n+                Assert.assertTrue(sub.containsKey(control.get(i)));\n+            } else {\n+                Assert.assertFalse(sub.containsKey(control.get(i)));\n+            }\n+        }\n+        // Too slow to check values on all, so just do a few.\n+        Assert.assertTrue(sub.containsValue(control.get(522)));\n+        Assert.assertFalse(sub.containsValue(control.get(523)));\n+        Assert.assertFalse(sub.containsValue(control.get(524)));\n+        \n+        try {\n+            sub.headMap(control.get(524));\n+            Assert.fail(\"should have thrown IAE\");\n+        } catch(IllegalArgumentException expected) {}\n+        \n+        Assert.assertEquals(sub.lastKey(), control.get(522));\n+        Assert.assertEquals(sub.firstKey(), control.get(0));\n+        \n+        sub = sub.tailMap(control.get(234));\n+        Assert.assertEquals(289, sub.size());\n+        Assert.assertEquals(control.get(234), sub.firstKey());\n+        Assert.assertEquals(control.get(522), sub.lastKey());\n+        for(int i = 0; i < control.size(); i++) {\n+            if(i < 523 && i > 233) {\n+                Assert.assertTrue(sub.containsKey(control.get(i)));\n+            } else {\n+                Assert.assertFalse(sub.containsKey(control.get(i)));\n+            }\n+        }\n+\n+        try {\n+            sub.tailMap(control.get(232));\n+            Assert.fail(\"should have thrown IAE\");\n+        } catch(IllegalArgumentException expected) {}\n+        \n+        sub = sub.subMap(control.get(300), control.get(400));\n+        Assert.assertEquals(100, sub.size());\n+        Assert.assertEquals(control.get(300), sub.firstKey());\n+        Assert.assertEquals(control.get(399), sub.lastKey());\n+        \n+        for(int i = 0; i < control.size(); i++) {\n+            if(i < 400 && i > 299) {\n+                Assert.assertTrue(sub.containsKey(control.get(i)));\n+            } else {\n+                Assert.assertFalse(sub.containsKey(control.get(i)));\n+            }\n+        }\n+    }\n+    \n+    @Test\n+    public void testPrefixedBy() {\n+        PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final String[] keys = new String[]{\n+                \"\", \n+                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n+                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n+                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n+                \"Amma\"\n+        };\n+\n+        for (String key : keys) {\n+            trie.put(key, key);\n+        }\n+        \n+        SortedMap<String, String> map;\n+        Iterator<String> iterator;\n+        Iterator<Map.Entry<String, String>> entryIterator;\n+        Map.Entry<String, String> entry;\n+        \n+        map = trie.getPrefixedBy(\"Al\");\n+        Assert.assertEquals(8, map.size());\n+        Assert.assertEquals(\"Alabama\", map.firstKey());\n+        Assert.assertEquals(\"Alliese\", map.lastKey());\n+        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n+        Assert.assertNotNull(trie.get(\"Xavier\"));\n+        Assert.assertNull(map.get(\"Xavier\"));\n+        Assert.assertNull(trie.get(\"Alice\"));\n+        Assert.assertNull(map.get(\"Alice\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Alabama\", iterator.next());\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Alien\", iterator.next());\n+        Assert.assertEquals(\"Allie\", iterator.next());\n+        Assert.assertEquals(\"Alliese\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Albert\");\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        Assert.assertEquals(4, map.size());\n+        Assert.assertEquals(\"Albert\", map.firstKey());\n+        Assert.assertEquals(\"Alberts\", map.lastKey());\n+        Assert.assertNull(trie.get(\"Albertz\"));\n+        map.put(\"Albertz\", \"Albertz\");\n+        Assert.assertEquals(\"Albertz\", trie.get(\"Albertz\"));\n+        Assert.assertEquals(5, map.size());\n+        Assert.assertEquals(\"Albertz\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Albertz\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        Assert.assertEquals(\"Albertz\", map.remove(\"Albertz\"));\n+        \n+        map = trie.getPrefixedBy(\"Alberto\");\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertEquals(\"Alberto\", map.firstKey());\n+        Assert.assertEquals(\"Albertoo\", map.lastKey());\n+        entryIterator = map.entrySet().iterator();\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Alberto\", entry.getKey());\n+        Assert.assertEquals(\"Alberto\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoo\", entry.getKey());\n+        Assert.assertEquals(\"Albertoo\", entry.getValue());\n+        Assert.assertFalse(entryIterator.hasNext());\n+        trie.put(\"Albertoad\", \"Albertoad\");\n+        Assert.assertEquals(3, map.size());\n+        Assert.assertEquals(\"Alberto\", map.firstKey());\n+        Assert.assertEquals(\"Albertoo\", map.lastKey());\n+        entryIterator = map.entrySet().iterator();\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Alberto\", entry.getKey());\n+        Assert.assertEquals(\"Alberto\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoad\", entry.getKey());\n+        Assert.assertEquals(\"Albertoad\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoo\", entry.getKey());\n+        Assert.assertEquals(\"Albertoo\", entry.getValue());\n+        Assert.assertFalse(entryIterator.hasNext());\n+        Assert.assertEquals(\"Albertoo\", trie.remove(\"Albertoo\"));\n+        Assert.assertEquals(\"Alberto\", map.firstKey());\n+        Assert.assertEquals(\"Albertoad\", map.lastKey());\n+        Assert.assertEquals(2, map.size());\n+        entryIterator = map.entrySet().iterator();\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Alberto\", entry.getKey());\n+        Assert.assertEquals(\"Alberto\", entry.getValue());\n+        entry = entryIterator.next();\n+        Assert.assertEquals(\"Albertoad\", entry.getKey());\n+        Assert.assertEquals(\"Albertoad\", entry.getValue());\n+        Assert.assertFalse(entryIterator.hasNext());\n+        Assert.assertEquals(\"Albertoad\", trie.remove(\"Albertoad\"));\n+        trie.put(\"Albertoo\", \"Albertoo\");\n+        \n+        map = trie.getPrefixedBy(\"X\");\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertFalse(map.containsKey(\"Albert\"));\n+        Assert.assertTrue(map.containsKey(\"Xavier\"));\n+        Assert.assertFalse(map.containsKey(\"Xalan\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Xavier\", iterator.next());\n+        Assert.assertEquals(\"XyZ\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"An\");\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Anna\", map.firstKey());\n+        Assert.assertEquals(\"Anna\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Anna\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Ban\");\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Banane\", map.firstKey());\n+        Assert.assertEquals(\"Banane\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Banane\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Am\");\n+        Assert.assertFalse(map.isEmpty());\n+        Assert.assertEquals(3, map.size());\n+        Assert.assertEquals(\"Amber\", trie.remove(\"Amber\"));\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Amma\", iterator.next());\n+        Assert.assertEquals(\"Ammun\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        iterator = map.keySet().iterator();\n+        map.put(\"Amber\", \"Amber\");\n+        Assert.assertEquals(3, map.size());\n+        try {\n+            iterator.next();\n+            Assert.fail(\"CME expected\");\n+        } catch(ConcurrentModificationException expected) {}\n+        Assert.assertEquals(\"Amber\", map.firstKey());\n+        Assert.assertEquals(\"Ammun\", map.lastKey());\n+        \n+        map = trie.getPrefixedBy(\"Ak\\0\");\n+        Assert.assertTrue(map.isEmpty());\n+        \n+        map = trie.getPrefixedBy(\"Ak\");\n+        Assert.assertEquals(2, map.size());\n+        Assert.assertEquals(\"Akka\", map.firstKey());\n+        Assert.assertEquals(\"Akko\", map.lastKey());\n+        map.put(\"Ak\", \"Ak\");\n+        Assert.assertEquals(\"Ak\", map.firstKey());\n+        Assert.assertEquals(\"Akko\", map.lastKey());\n+        Assert.assertEquals(3, map.size());\n+        trie.put(\"Al\", \"Al\");\n+        Assert.assertEquals(3, map.size());\n+        Assert.assertEquals(\"Ak\", map.remove(\"Ak\"));\n+        Assert.assertEquals(\"Akka\", map.firstKey());\n+        Assert.assertEquals(\"Akko\", map.lastKey());\n+        Assert.assertEquals(2, map.size());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Akka\", iterator.next());\n+        Assert.assertEquals(\"Akko\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        Assert.assertEquals(\"Al\", trie.remove(\"Al\"));\n+        \n+        map = trie.getPrefixedBy(\"Akka\");\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Akka\", map.firstKey());\n+        Assert.assertEquals(\"Akka\", map.lastKey());\n+        iterator = map.keySet().iterator();\n+        Assert.assertEquals(\"Akka\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Ab\");\n+        Assert.assertTrue(map.isEmpty());\n+        Assert.assertEquals(0, map.size());\n+        try {\n+            Object o = map.firstKey();\n+            Assert.fail(\"got a first key: \" + o);\n+        } catch(NoSuchElementException nsee) {}\n+        try {\n+            Object o = map.lastKey();\n+            Assert.fail(\"got a last key: \" + o);\n+        } catch(NoSuchElementException nsee) {}\n+        iterator = map.values().iterator();\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Albertooo\");\n+        Assert.assertTrue(map.isEmpty());\n+        Assert.assertEquals(0, map.size());\n+        try {\n+            Object o = map.firstKey();\n+            Assert.fail(\"got a first key: \" + o);\n+        } catch(NoSuchElementException nsee) {}\n+        try {\n+            Object o = map.lastKey();\n+            Assert.fail(\"got a last key: \" + o);\n+        } catch(NoSuchElementException nsee) {}\n+        iterator = map.values().iterator();\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"\");\n+        Assert.assertSame(trie, map); // stricter than necessary, but a good check\n+        \n+        map = trie.getPrefixedBy(\"\\0\");\n+        Assert.assertTrue(map.isEmpty());\n+        Assert.assertEquals(0, map.size());\n+        try {\n+            Object o = map.firstKey();\n+            Assert.fail(\"got a first key: \" + o);\n+        } catch(NoSuchElementException nsee) {}\n+        try {\n+            Object o = map.lastKey();\n+            Assert.fail(\"got a last key: \" + o);\n+        } catch(NoSuchElementException nsee) {}\n+        iterator = map.values().iterator();\n+        Assert.assertFalse(iterator.hasNext());\n+    }\n+    \n+    @Test\n+    public void testPrefixByOffsetAndLength() {\n+        PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final String[] keys = new String[]{\n+                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n+                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n+                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n+                \"Amma\"\n+        };\n+    \n+        for (String key : keys) {\n+            trie.put(key, key);\n+        }\n+        \n+        SortedMap<String, String> map;\n+        Iterator<String> iterator;\n+        \n+        map = trie.getPrefixedBy(\"Alice\", 2);\n+        Assert.assertEquals(8, map.size());\n+        Assert.assertEquals(\"Alabama\", map.firstKey());\n+        Assert.assertEquals(\"Alliese\", map.lastKey());\n+        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n+        Assert.assertNotNull(trie.get(\"Xavier\"));\n+        Assert.assertNull(map.get(\"Xavier\"));\n+        Assert.assertNull(trie.get(\"Alice\"));\n+        Assert.assertNull(map.get(\"Alice\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Alabama\", iterator.next());\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Alien\", iterator.next());\n+        Assert.assertEquals(\"Allie\", iterator.next());\n+        Assert.assertEquals(\"Alliese\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"BAlice\", 1, 2);\n+        Assert.assertEquals(8, map.size());\n+        Assert.assertEquals(\"Alabama\", map.firstKey());\n+        Assert.assertEquals(\"Alliese\", map.lastKey());\n+        Assert.assertEquals(\"Albertoo\", map.get(\"Albertoo\"));\n+        Assert.assertNotNull(trie.get(\"Xavier\"));\n+        Assert.assertNull(map.get(\"Xavier\"));\n+        Assert.assertNull(trie.get(\"Alice\"));\n+        Assert.assertNull(map.get(\"Alice\"));\n+        iterator = map.values().iterator();\n+        Assert.assertEquals(\"Alabama\", iterator.next());\n+        Assert.assertEquals(\"Albert\", iterator.next());\n+        Assert.assertEquals(\"Alberto\", iterator.next());\n+        Assert.assertEquals(\"Albertoo\", iterator.next());\n+        Assert.assertEquals(\"Alberts\", iterator.next());\n+        Assert.assertEquals(\"Alien\", iterator.next());\n+        Assert.assertEquals(\"Allie\", iterator.next());\n+        Assert.assertEquals(\"Alliese\", iterator.next());\n+        Assert.assertFalse(iterator.hasNext());\n+    }\n+    \n+    @Test\n+    public void testPrefixedByRemoval() {\n+        PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        final String[] keys = new String[]{\n+                \"Albert\", \"Xavier\", \"XyZ\", \"Anna\", \"Alien\", \"Alberto\",\n+                \"Alberts\", \"Allie\", \"Alliese\", \"Alabama\", \"Banane\",\n+                \"Blabla\", \"Amber\", \"Ammun\", \"Akka\", \"Akko\", \"Albertoo\",\n+                \"Amma\"\n+        };\n+\n+        for (String key : keys) {\n+            trie.put(key, key);\n+        }\n+        \n+        SortedMap<String, String> map = trie.getPrefixedBy(\"Al\");\n+        Assert.assertEquals(8, map.size());\n+        Iterator<String> iter = map.keySet().iterator();\n+        Assert.assertEquals(\"Alabama\", iter.next());\n+        Assert.assertEquals(\"Albert\", iter.next());\n+        Assert.assertEquals(\"Alberto\", iter.next());\n+        Assert.assertEquals(\"Albertoo\", iter.next());\n+        Assert.assertEquals(\"Alberts\", iter.next());\n+        Assert.assertEquals(\"Alien\", iter.next());\n+        iter.remove();\n+        Assert.assertEquals(7, map.size());\n+        Assert.assertEquals(\"Allie\", iter.next());\n+        Assert.assertEquals(\"Alliese\", iter.next());\n+        Assert.assertFalse(iter.hasNext());\n+        \n+        map = trie.getPrefixedBy(\"Ak\");\n+        Assert.assertEquals(2, map.size());\n+        iter = map.keySet().iterator();\n+        Assert.assertEquals(\"Akka\", iter.next());\n+        iter.remove();\n+        Assert.assertEquals(1, map.size());\n+        Assert.assertEquals(\"Akko\", iter.next());\n+        if(iter.hasNext()) {\n+            Assert.fail(\"shouldn't have next (but was: \" + iter.next() + \")\");\n+        }\n+        Assert.assertFalse(iter.hasNext());\n+    }\n+\n+    @Test\n+    public void testTraverseWithAllNullBitKey() {\n+        PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        //\n+        // One entry in the Trie\n+        // Entry is stored at the root\n+        //\n+        \n+        // trie.put(\"\", \"All Bits Are Zero\");\n+        trie.put(\"\\0\", \"All Bits Are Zero\");\n+        \n+        //\n+        //  / (\"\")   <-- root\n+        //  \\_/  \\\n+        //       null\n+        //\n+        \n+        final List<String> strings = new ArrayList<String>();\n+        trie.traverse(new Cursor<String, String>() {\n+            public Decision select(Entry<? extends String, ? extends String> entry) {\n+                strings.add(entry.getValue());\n+                return Decision.CONTINUE;\n+            }\n+        });\n+        \n+        Assert.assertEquals(1, strings.size());\n+        \n+        strings.clear();\n+        for (String s : trie.values()) {\n+            strings.add(s);\n+        }\n+        Assert.assertEquals(1, strings.size());\n+    }\n+    \n+    @Test\n+    public void testSelectWithAllNullBitKey() {\n+        PatriciaTrie<String, String> trie \n+            = new PatriciaTrie<String, String>(new StringKeyAnalyzer());\n+        \n+        // trie.put(\"\", \"All Bits Are Zero\");\n+        trie.put(\"\\0\", \"All Bits Are Zero\");\n+        \n+        final List<String> strings = new ArrayList<String>();\n+        trie.select(\"Hello\", new Cursor<String, String>() {\n+            public Decision select(Entry<? extends String, ? extends String> entry) {\n+                strings.add(entry.getValue());\n+                return Decision.CONTINUE;\n+            }\n+        });\n+        Assert.assertEquals(1, strings.size());\n+    }\n+    \n+    private static class TestCursor implements Cursor<Object, Object> {\n+        private List<Object> keys;\n+        private List<Object> values;\n+        private Object selectFor;\n+        private List<Object> toRemove;\n+        private int index = 0;\n+        \n+        TestCursor(Object... objects) {\n+            if(objects.length % 2 != 0) {\n+                throw new IllegalArgumentException(\"must be * 2\");\n+            }\n+            \n+            keys = new ArrayList<Object>(objects.length / 2);\n+            values = new ArrayList<Object>(keys.size());\n+            toRemove = Collections.emptyList();\n+            for(int i = 0; i < objects.length; i++) {\n+                keys.add(objects[i]);\n+                values.add(objects[++i]);\n+            }\n+        }\n+        \n+        void selectFor(Object object) {\n+            selectFor = object;\n+        }\n+        \n+        void addToRemove(Object... objects) {\n+            toRemove = new ArrayList<Object>(Arrays.asList(objects));\n+        }\n+        \n+        void remove(Object... objects) {\n+            for (Object object : objects) {\n+                int idx = keys.indexOf(object);\n+                keys.remove(idx);\n+                values.remove(idx);\n+            }\n+        }\n+        \n+        void starting() {\n+            index = 0;\n+        }\n+        \n+        public void checkKey(Object k) {\n+            Assert.assertEquals(keys.get(index++), k);\n+        }\n+        \n+        public void checkValue(Object o) {\n+            Assert.assertEquals(values.get(index++), o);\n+        }\n+\n+        public Decision select(Entry<?, ?> entry) {\n+          //  System.out.println(\"Scanning: \" + entry.getKey());\n+            Assert.assertEquals(keys.get(index), entry.getKey());\n+            Assert.assertEquals(values.get(index), entry.getValue());\n+            index++;\n+            \n+            if(toRemove.contains(entry.getKey())) {\n+              // System.out.println(\"Removing: \" + entry.getKey());\n+                index--;\n+                keys.remove(index);\n+                values.remove(index);\n+                toRemove.remove(entry.getKey());\n+                return Decision.REMOVE;\n+            } \n+            \n+            if(selectFor != null && selectFor.equals(entry.getKey())) {\n+                return Decision.EXIT;\n+            } else {\n+                return Decision.CONTINUE;\n+            }\n+        }\n+        \n+        void finished() {\n+            Assert.assertEquals(keys.size(), index);\n+        }\n+    }\n+    \n+    private static void assertEqualArrays(Object[] a, Object[] b) {\n+        Assert.assertTrue(Arrays.equals(a, b));\n+    }\n+}", "timestamp": 1343248968, "metainfo": ""}