{"sha": "fae8897bc45e3d91b11eac67aa792869e2025f1d", "log": "Added CompositeSet, CompositeMap contributed by Brian McCallister.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/collection/CompositeCollection.java\n+++ b/src/java/org/apache/commons/collections/collection/CompositeCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/collection/CompositeCollection.java,v 1.2 2003/12/03 11:37:44 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/collection/CompositeCollection.java,v 1.3 2003/12/14 21:42:55 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.list.UnmodifiableList;\n \n /**\n- * Decorates a other collections to provide a single unified view.\n+ * Decorates a collection of other collections to provide a single unified view.\n  * <p>\n  * Changes made to this collection will actually be made on the decorated collection.\n  * Add and remove operations require the use of a pluggable strategy. If no \n  * strategy is provided then add and remove are unsupported.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/12/03 11:37:44 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/14 21:42:55 $\n  *\n  * @author Brian McCallister\n  * @author Stephen Colebourne\n      * @param coll  a collection to decorate\n      */\n     public CompositeCollection(Collection coll) {\n-        super();\n+        this();\n         this.addComposited(coll);\n     }\n     \n      * @param colls  an array of collections to decorate\n      */\n     public CompositeCollection(Collection[] colls) {\n-        super();\n+        this();\n         this.addComposited(colls);\n     }\n     \n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/CompositeMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/CompositeMap.java,v 1.1 2003/12/14 21:42:55 psteitz Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.CompositeCollection;\n+import org.apache.commons.collections.set.CompositeSet;\n+\n+/**\n+ * Decorates a map of other maps to provide a single unified view.\n+ * <p>\n+ * Changes made to this map will actually be made on the decorated map.\n+ * Add and remove operations require the use of a pluggable strategy. If no\n+ * strategy is provided then add and remove are unsupported.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/14 21:42:55 $\n+ *\n+ * @author Brian McCallister\n+ */\n+public class CompositeMap implements Map {\n+    /** Array of all maps in the composite */\n+    private Map[] composite = null;\n+    \n+    /** Handle mutation operations */\n+    private MapMutator mutator = null;\n+    \n+    /**\n+     * Create a new, empty, CompositeMap\n+     */\n+    public CompositeMap() {\n+        this(new Map[]{}, null);\n+    }\n+    \n+    /**\n+     * Create a new CompositeMap with two composited Map instances\n+     * @param one First Map to be composited\n+     * @param two Second Map to be composited\n+     * @throws IllegalArgumentException if there is a key collision\n+     */\n+    public CompositeMap(Map one, Map two) {\n+        this(new Map[]{one, two}, null);\n+    }\n+    \n+    /**\n+     * Create a new CompositeMap with two composited Map instances\n+     * @param one First Map to be composited\n+     * @param two Second Map to be composited\n+     * @param mutator MapMutator to be used for mutation operations\n+     */\n+    public CompositeMap(Map one, Map two, MapMutator mutator) {\n+        this(new Map[]{one, two}, mutator);\n+    }\n+    \n+    /**\n+     * Create a new CompositeMap which composites all of the Map instances in the\n+     * argument. It copies the argument array, it does not use it directly.\n+     * @param composite Maps to be composited\n+     * @throws IllegalArgumentException if there is a key collision\n+     */\n+    public CompositeMap(Map[] composite) {\n+        this(composite, null);\n+    }\n+    \n+    /**\n+     * Create a new CompositeMap which composites all of the Map instances in the\n+     * argument. It copies the argument array, it does not use it directly.\n+     * @param composite Maps to be composited\n+     * @param mutator MapMutator to be used for mutation operations\n+     */\n+    public CompositeMap(Map[] composite, MapMutator mutator) {\n+        this.mutator = mutator;\n+        this.composite = new Map[0];\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            this.addComposited(composite[i]);\n+        }\n+    }\n+    \n+    /**\n+     * Specify the MapMutator to be used by mutation operations\n+     * @param mutator The MapMutator to be used for mutation delegation\n+     */\n+    public void setMutator(MapMutator mutator) {\n+        this.mutator = mutator;\n+    }\n+    \n+    /**\n+     * Add an additional Map to the composite\n+     *\n+     * @param map Map to be added to the composite\n+     * @throws IllegalArgumentException if there is a key collision and there is no\n+     *         MapMutator set to handle it.\n+     */\n+    public synchronized void addComposited(Map map) throws IllegalArgumentException {\n+        for (int i = composite.length - 1; i >= 0; --i) {\n+            Collection intersect = CollectionUtils.intersection(this.composite[i].keySet(), map.keySet());\n+            if (intersect.size() != 0) {\n+                if (this.mutator == null) {\n+                    throw new IllegalArgumentException(\"Key collision adding Map to CompositeMap\");\n+                }\n+                else {\n+                    this.mutator.resolveCollision(this, this.composite[i], map, intersect);\n+                }\n+            }\n+        }\n+        Map[] temp = new Map[this.composite.length + 1];\n+        System.arraycopy(this.composite, 0, temp, 0, this.composite.length);\n+        temp[temp.length - 1] = map;\n+        this.composite = temp;\n+    }\n+    \n+    /**\n+     * Remove a Map from the composite\n+     *\n+     * @param map The Map to be removed from the composite\n+     * @return The removed Map or <code>null</code> if map is not in the composite\n+     */\n+    public synchronized Map removeComposited(Map map) {\n+        int size = this.composite.length;\n+        for (int i = 0; i < size; ++i) {\n+            if (this.composite[i].equals(map)) {\n+                Map[] temp = new Map[size - 1];\n+                System.arraycopy(this.composite, 0, temp, 0, i);\n+                System.arraycopy(this.composite, i + 1, temp, i, size - i - 1);\n+                this.composite = temp;\n+                return map;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /* Map Implementation */\n+    \n+    /**\n+     * Calls <code>clear()</code> on all composited Maps\n+     *\n+     * @throws UnsupportedOperationException if any of the composited Maps do not support clear()\n+     */\n+    public void clear() {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            this.composite[i].clear();\n+        }\n+    }\n+    \n+    /**\n+     * Returns <tt>true</tt> if this map contains a mapping for the specified\n+     * key.  More formally, returns <tt>true</tt> if and only if\n+     * this map contains at a mapping for a key <tt>k</tt> such that\n+     * <tt>(key==null ? k==null : key.equals(k))</tt>.  (There can be\n+     * at most one such mapping.)\n+     *\n+     * @param key key whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map contains a mapping for the specified\n+     *         key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     * \t\t  this map (optional).\n+     * @throws NullPointerException if the key is <tt>null</tt> and this map\n+     *            does not not permit <tt>null</tt> keys (optional).\n+     */\n+    public boolean containsKey(Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) return true;\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns <tt>true</tt> if this map maps one or more keys to the\n+     * specified value.  More formally, returns <tt>true</tt> if and only if\n+     * this map contains at least one mapping to a value <tt>v</tt> such that\n+     * <tt>(value==null ? v==null : value.equals(v))</tt>.  This operation\n+     * will probably require time linear in the map size for most\n+     * implementations of the <tt>Map</tt> interface.\n+     *\n+     * @param value value whose presence in this map is to be tested.\n+     * @return <tt>true</tt> if this map maps one or more keys to the\n+     *         specified value.\n+     * @throws ClassCastException if the value is of an inappropriate type for\n+     * \t\t  this map (optional).\n+     * @throws NullPointerException if the value is <tt>null</tt> and this map\n+     *            does not not permit <tt>null</tt> values (optional).\n+     */\n+    public boolean containsValue(Object value) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsValue(value)) return true;\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns a set view of the mappings contained in this map.  Each element\n+     * in the returned set is a {@link Map.Entry}.  The set is backed by the\n+     * map, so changes to the map are reflected in the set, and vice-versa.\n+     * If the map is modified while an iteration over the set is in progress,\n+     * the results of the iteration are undefined.  The set supports element\n+     * removal, which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>, <tt>removeAll</tt>,\n+     * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not support\n+     * the <tt>add</tt> or <tt>addAll</tt> operations.\n+     * <p>\n+     * This implementation returns a <code>CompositeSet</code> which\n+     * composites the entry sets from all of the composited maps.\n+     *\n+     * @see CompositeSet\n+     * @return a set view of the mappings contained in this map.\n+     */\n+    public Set entrySet() {\n+        CompositeSet entries = new CompositeSet();\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            entries.addComposited(this.composite[i].entrySet());\n+        }\n+        return entries;\n+    }\n+    \n+    /**\n+     * Returns the value to which this map maps the specified key.  Returns\n+     * <tt>null</tt> if the map contains no mapping for this key.  A return\n+     * value of <tt>null</tt> does not <i>necessarily</i> indicate that the\n+     * map contains no mapping for the key; it's also possible that the map\n+     * explicitly maps the key to <tt>null</tt>.  The <tt>containsKey</tt>\n+     * operation may be used to distinguish these two cases.\n+     *\n+     * <p>More formally, if this map contains a mapping from a key\n+     * <tt>k</tt> to a value <tt>v</tt> such that <tt>(key==null ? k==null :\n+     * key.equals(k))</tt>, then this method returns <tt>v</tt>; otherwise\n+     * it returns <tt>null</tt>.  (There can be at most one such mapping.)\n+     *\n+     * @param key key whose associated value is to be returned.\n+     * @return the value to which this map maps the specified key, or\n+     *\t       <tt>null</tt> if the map contains no mapping for this key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     * \t\t  this map (optional).\n+     * @throws NullPointerException key is <tt>null</tt> and this map does not\n+     *\t\t  not permit <tt>null</tt> keys (optional).\n+     *\n+     * @see #containsKey(Object)\n+     */\n+    public Object get(Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) return this.composite[i].get(key);\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Returns <tt>true</tt> if this map contains no key-value mappings.\n+     *\n+     * @return <tt>true</tt> if this map contains no key-value mappings.\n+     */\n+    public boolean isEmpty() {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (!this.composite[i].isEmpty()) return false;\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Returns a set view of the keys contained in this map.  The set is\n+     * backed by the map, so changes to the map are reflected in the set, and\n+     * vice-versa.  If the map is modified while an iteration over the set is\n+     * in progress, the results of the iteration are undefined.  The set\n+     * supports element removal, which removes the corresponding mapping from\n+     * the map, via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,\n+     * <tt>removeAll</tt> <tt>retainAll</tt>, and <tt>clear</tt> operations.\n+     * It does not support the add or <tt>addAll</tt> operations.\n+     * <p>\n+     * This implementation returns a <code>CompositeSet</code> which\n+     * composites the key sets from all of the composited maps.\n+     *\n+     * @return a set view of the keys contained in this map.\n+     */\n+    public Set keySet() {\n+        CompositeSet keys = new CompositeSet();\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            keys.addComposited(this.composite[i].keySet());\n+        }\n+        return keys;\n+    }\n+    \n+    /**\n+     * Associates the specified value with the specified key in this map\n+     * (optional operation).  If the map previously contained a mapping for\n+     * this key, the old value is replaced by the specified value.  (A map\n+     * <tt>m</tt> is said to contain a mapping for a key <tt>k</tt> if and only\n+     * if {@link #containsKey(Object) m.containsKey(k)} would return\n+     * <tt>true</tt>.))\n+     *\n+     * @param key key with which the specified value is to be associated.\n+     * @param value value to be associated with the specified key.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     *\t       if there was no mapping for key.  A <tt>null</tt> return can\n+     *\t       also indicate that the map previously associated <tt>null</tt>\n+     *\t       with the specified key, if the implementation supports\n+     *\t       <tt>null</tt> values.\n+     *\n+     * @throws UnsupportedOperationException if no MapMutator has been specified\n+     * @throws ClassCastException if the class of the specified key or value\n+     * \t          prevents it from being stored in this map.\n+     * @throws IllegalArgumentException if some aspect of this key or value\n+     *\t          prevents it from being stored in this map.\n+     * @throws NullPointerException this map does not permit <tt>null</tt>\n+     *            keys or values, and the specified key or value is\n+     *            <tt>null</tt>.\n+     */\n+    public Object put(Object key, Object value) {\n+        if (this.mutator == null) throw new UnsupportedOperationException(\"No mutator specified\");\n+        return this.mutator.put(this, this.composite, key, value);\n+    }\n+    \n+    /**\n+     * Copies all of the mappings from the specified map to this map\n+     * (optional operation).  The effect of this call is equivalent to that\n+     * of calling {@link #put(Object,Object) put(k, v)} on this map once\n+     * for each mapping from key <tt>k</tt> to value <tt>v</tt> in the\n+     * specified map.  The behavior of this operation is unspecified if the\n+     * specified map is modified while the operation is in progress.\n+     *\n+     * @param t Mappings to be stored in this map.\n+     *\n+     * @throws UnsupportedOperationException if the <tt>putAll</tt> method is\n+     * \t\t  not supported by this map.\n+     *\n+     * @throws ClassCastException if the class of a key or value in the\n+     * \t          specified map prevents it from being stored in this map.\n+     *\n+     * @throws IllegalArgumentException some aspect of a key or value in the\n+     *\t          specified map prevents it from being stored in this map.\n+     * @throws NullPointerException the specified map is <tt>null</tt>, or if\n+     *         this map does not permit <tt>null</tt> keys or values, and the\n+     *         specified map contains <tt>null</tt> keys or values.\n+     */\n+    public void putAll(Map t) {\n+        if (this.mutator == null) throw new UnsupportedOperationException(\"No mutator specified\");\n+        this.mutator.putAll(this, this.composite, t);\n+    }\n+    \n+    /**\n+     * Removes the mapping for this key from this map if it is present\n+     * (optional operation).   More formally, if this map contains a mapping\n+     * from key <tt>k</tt> to value <tt>v</tt> such that\n+     * <code>(key==null ?  k==null : key.equals(k))</code>, that mapping\n+     * is removed.  (The map can contain at most one such mapping.)\n+     *\n+     * <p>Returns the value to which the map previously associated the key, or\n+     * <tt>null</tt> if the map contained no mapping for this key.  (A\n+     * <tt>null</tt> return can also indicate that the map previously\n+     * associated <tt>null</tt> with the specified key if the implementation\n+     * supports <tt>null</tt> values.)  The map will not contain a mapping for\n+     * the specified  key once the call returns.\n+     *\n+     * @param key key whose mapping is to be removed from the map.\n+     * @return previous value associated with specified key, or <tt>null</tt>\n+     *\t       if there was no mapping for key.\n+     *\n+     * @throws ClassCastException if the key is of an inappropriate type for\n+     * \t\t  the composited map (optional).\n+     * @throws NullPointerException if the key is <tt>null</tt> and the composited map\n+     *            does not not permit <tt>null</tt> keys (optional).\n+     * @throws UnsupportedOperationException if the <tt>remove</tt> method is\n+     *         not supported by the composited map containing the key\n+     */\n+    public Object remove(Object key) {\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            if (this.composite[i].containsKey(key)) return this.composite[i].remove(key);\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Returns the number of key-value mappings in this map.  If the\n+     * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns\n+     * <tt>Integer.MAX_VALUE</tt>.\n+     *\n+     * @return the number of key-value mappings in this map.\n+     */\n+    public int size() {\n+        int size = 0;\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            size += this.composite[i].size();\n+        }\n+        return size;\n+    }\n+    \n+    /**\n+     * Returns a collection view of the values contained in this map.  The\n+     * collection is backed by the map, so changes to the map are reflected in\n+     * the collection, and vice-versa.  If the map is modified while an\n+     * iteration over the collection is in progress, the results of the\n+     * iteration are undefined.  The collection supports element removal,\n+     * which removes the corresponding mapping from the map, via the\n+     * <tt>Iterator.remove</tt>, <tt>Collection.remove</tt>,\n+     * <tt>removeAll</tt>, <tt>retainAll</tt> and <tt>clear</tt> operations.\n+     * It does not support the add or <tt>addAll</tt> operations.\n+     *\n+     * @return a collection view of the values contained in this map.\n+     */\n+    public Collection values() {\n+        CompositeCollection keys = new CompositeCollection();\n+        for (int i = this.composite.length - 1; i >= 0; --i) {\n+            keys.addComposited(this.composite[i].values());\n+        }\n+        return keys;\n+    }\n+    \n+    /**\n+     * @see Map#hashCode\n+     */\n+    public int hashCode() {\n+        int code = 0;\n+        for (Iterator i = this.entrySet().iterator(); i.hasNext();) {\n+            code += i.next().hashCode();\n+        }\n+        return code;\n+    }\n+    \n+    /**\n+     * @see Map#equals\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof Map) {\n+            Map map = (Map) obj;\n+            return (this.entrySet().equals(map.entrySet()));\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * This interface allows definition for all of the indeterminate\n+     * mutators in a CompositeMap, as well as providing a hook for\n+     * callbacks on key collisions.\n+     */\n+    public static interface MapMutator {\n+        /**\n+         * Called when adding a new Composited Map results in a\n+         * key collision.\n+         *\n+         * @param composite the CompositeMap withthe collision\n+         * @param existing the Map already in the composite which contains the\n+         *        offending key\n+         * @param added the Map being added\n+         * @param intersect the intersection of the keysets of the existing and added maps\n+         */\n+        public void resolveCollision(CompositeMap composite,\n+        Map existing,\n+        Map added,\n+        Collection intersect);\n+        \n+        /**\n+         * Called when the CompositeMap.put() method is invoked.\n+         *\n+         * @param map the CompositeMap which is being modified\n+         * @param composited array of Maps in the CompositeMap being modified\n+         * @param key key with which the specified value is to be associated.\n+         * @param value value to be associated with the specified key.\n+         * @return previous value associated with specified key, or <tt>null</tt>\n+         *\t       if there was no mapping for key.  A <tt>null</tt> return can\n+         *\t       also indicate that the map previously associated <tt>null</tt>\n+         *\t       with the specified key, if the implementation supports\n+         *\t       <tt>null</tt> values.\n+         *\n+         * @throws UnsupportedOperationException if not defined\n+         * @throws ClassCastException if the class of the specified key or value\n+         * \t          prevents it from being stored in this map.\n+         * @throws IllegalArgumentException if some aspect of this key or value\n+         *\t          prevents it from being stored in this map.\n+         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         *            keys or values, and the specified key or value is\n+         *            <tt>null</tt>.\n+         */\n+        public Object put(CompositeMap map, Map[] composited, Object key, Object value);\n+        \n+        /**\n+         * Called when the CompositeMap.putAll() method is invoked.\n+         *\n+         * @param map the CompositeMap which is being modified\n+         * @param composited array of Maps in the CompositeMap being modified\n+         * @param t Mappings to be stored in this CompositeMap\n+         *\n+         * @throws UnsupportedOperationException if not defined\n+         * @throws ClassCastException if the class of the specified key or value\n+         * \t          prevents it from being stored in this map.\n+         * @throws IllegalArgumentException if some aspect of this key or value\n+         *\t          prevents it from being stored in this map.\n+         * @throws NullPointerException this map does not permit <tt>null</tt>\n+         *            keys or values, and the specified key or value is\n+         *            <tt>null</tt>.\n+         */\n+        public void putAll(CompositeMap map, Map[] composited, Map t);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/set/CompositeSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/set/CompositeSet.java,v 1.1 2003/12/14 21:42:55 psteitz Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.set;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.commons.collections.collection.CompositeCollection;\n+\n+/**\n+ * Decorates a set of other sets to provide a single unified view.\n+ * <p>\n+ * Changes made to this set will actually be made on the decorated set.\n+ * Add and remove operations require the use of a pluggable strategy. If no\n+ * strategy is provided then add and remove are unsupported.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/14 21:42:55 $\n+ *\n+ * @author Brian McCallister\n+ */\n+public class CompositeSet extends CompositeCollection implements Set {\n+    /**\n+     * Create an empty CompositeSet\n+     */\n+    public CompositeSet() {\n+        super();\n+    }\n+    \n+    /**\n+     * Create a CompositeSet with just <code>set</code> composited\n+     * @param set The initial set in the composite\n+     */\n+    public CompositeSet(Set set) {\n+        super(set);\n+    }\n+    \n+    /**\n+     * Create a composite set with sets as the initial set of composited Sets\n+     */\n+    public CompositeSet(Set[] sets) {\n+        super(sets);\n+    }\n+    \n+    /**\n+     * Add a Set to this composite\n+     *\n+     * @param c Must implement Set\n+     * @throws IllegalArgumentException if c does not implement java.util.Set\n+     *         or if a SetMutator is set, but fails to resolve a collision\n+     * @throws UnsupportedOperationException if there is no SetMutator set, or\n+     *         a CollectionMutator is set instead of a SetMutator\n+     * @see org.apache.commons.collections.collection.CompositeCollection.CollectionMutator\n+     * @see SetMutator\n+     */\n+    public synchronized void addComposited(Collection c) {\n+        if (!(c instanceof Set)) {\n+            throw new IllegalArgumentException(\"Collections added must implement java.util.Set\");\n+        }\n+        \n+        for (Iterator i = this.getCollections().iterator(); i.hasNext();) {\n+            Set set = (Set) i.next();\n+            Collection intersects = CollectionUtils.intersection(set, c);\n+            if (intersects.size() > 0) {\n+                if (this.mutator == null) {\n+                    throw new UnsupportedOperationException(\n+                        \"Collision adding composited collection with no SetMutator set\");\n+                }\n+                else if (!(this.mutator instanceof SetMutator)) {\n+                    throw new UnsupportedOperationException(\n+                        \"Collision adding composited collection to a CompositeSet with a CollectionMutator instead of a SetMutator\");\n+                }\n+                ((SetMutator) this.mutator).resolveCollision(this, set, (Set) c, intersects);\n+                if (CollectionUtils.intersection(set, c).size() > 0) {\n+                    throw new IllegalArgumentException(\n+                        \"Attempt to add illegal entry unresolved by SetMutator.resolveCollision()\");\n+                }\n+            }\n+        }\n+        super.addComposited(new Collection[]{c});\n+    }\n+    \n+    /**\n+     * Add two sets to this composite\n+     *\n+     * @throws IllegalArgumentException if c or d does not implement java.util.Set\n+     */\n+    public synchronized void addComposited(Collection c, Collection d) {\n+        if (!(c instanceof Set)) throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n+        if (!(d instanceof Set)) throw new IllegalArgumentException(\"Argument must implement java.util.Set\");\n+        this.addComposited(new Set[]{(Set) c, (Set) d});\n+    }\n+    \n+    /**\n+     * Add an array of sets to this composite\n+     * @param comps\n+     * @throws IllegalArgumentException if any of the collections in comps do not implement Set\n+     */\n+    public synchronized void addComposited(Collection[] comps) {\n+        for (int i = comps.length - 1; i >= 0; --i) {\n+            this.addComposited(comps[i]);\n+        }\n+    }\n+    \n+    /**\n+     * This can receive either a <code>CompositeCollection.CollectionMutator</code>\n+     * or a <code>CompositeSet.SetMutator</code>. If a\n+     * <code>CompositeCollection.CollectionMutator</code> is used than conflicts when adding\n+     * composited sets will throw IllegalArgumentException\n+     * <p>\n+     */\n+    public void setMutator(CollectionMutator mutator) {\n+        super.setMutator(mutator);\n+    }\n+    \n+    /* Set operations */\n+    \n+    /**\n+     * If a <code>CollectionMutator</code> is defined for this CompositeSet then this\n+     * method will be called anyway.\n+     *\n+     * @param obj Object to be removed\n+     * @return true if the object is removed, false otherwise\n+     */\n+    public boolean remove(Object obj) {\n+        for (Iterator i = this.getCollections().iterator(); i.hasNext();) {\n+            Set set = (Set) i.next();\n+            if (set.contains(obj)) return set.remove(obj);\n+        }\n+        return false;\n+    }\n+    \n+    \n+    /**\n+     * @see Set#equals\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj instanceof Set) {\n+            Set set = (Set) obj;\n+            if (set.containsAll(this) && set.size() == this.size()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * @see Set#hashCode\n+     */\n+    public int hashCode() {\n+        int code = 0;\n+        for (Iterator i = this.iterator(); i.hasNext();) {\n+            Object next = i.next();\n+            code += (next != null ? next.hashCode() : 0);\n+        }\n+        return code;\n+    }\n+    \n+    /**\n+     * Define callbacks for mutation operations.\n+     * <p>\n+     * Defining remove() on implementations of SetMutator is pointless\n+     * as they are never called by CompositeSet.\n+     */\n+    public static interface SetMutator extends CompositeCollection.CollectionMutator {\n+        /**\n+         * <p>\n+         * Called when a Set is added to the CompositeSet and there is a\n+         * collision between existing and added sets.\n+         * </p>\n+         * <p>\n+         * If <code>added</code> and <code>existing</code> still have any intersects\n+         * after this method returns an IllegalArgumentException will be thrown.\n+         * </p>\n+         * @param comp The CompositeSet being modified\n+         * @param existing The Set already existing in the composite\n+         * @param added the Set being added to the composite\n+         * @param intersects the intersection of th existing and added sets\n+         */\n+        public void resolveCollision(CompositeSet comp, Set existing, Set added, Collection intersects);\n+    }\n+}\n--- a/src/test/org/apache/commons/collections/collection/TestCompositeCollection.java\n+++ b/src/test/org/apache/commons/collections/collection/TestCompositeCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/collection/TestCompositeCollection.java,v 1.3 2003/11/18 22:37:18 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/collection/TestCompositeCollection.java,v 1.4 2003/12/14 21:42:55 psteitz Exp $\n  * ====================================================================\n  * The Apache Software License, Version 1.1\n  *\n  * {@link CompositeCollection} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/11/18 22:37:18 $\n+ * @version $Revision: 1.4 $ $Date: 2003/12/14 21:42:55 $\n  * \n  * @author Brian McCallister\n  * @author Phil Steitz\n     }\n     \n     /**\n-     * Full collection consists of 5 collections, each with one element\n+     * Full collection consists of 4 collections, each with one element\n      */\n     public Collection makeFullCollection() {\n         CompositeCollection compositeCollection = new CompositeCollection();\n     }\n     \n     /**\n-     * Full collection should look like a collection with 5 elements\n+     * Full collection should look like a collection with 4 elements\n      */\n     public Collection makeConfirmedFullCollection() {\n         Collection collection = new HashSet();\n--- a/src/test/org/apache/commons/collections/map/TestAll.java\n+++ b/src/test/org/apache/commons/collections/map/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.10 2003/12/07 01:23:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.11 2003/12/14 21:42:55 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.10 $ $Date: 2003/12/07 01:23:54 $\n+ * @version $Revision: 1.11 $ $Date: 2003/12/14 21:42:55 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n+        suite.addTest(TestCompositeMap.suite());\n         suite.addTest(TestFlat3Map.suite());\n         suite.addTest(TestHashedMap.suite());\n         suite.addTest(TestIdentityMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestCompositeMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestCompositeMap.java,v 1.1 2003/12/14 21:42:55 psteitz Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import junit.framework.Assert;\n+\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Collection;\n+\n+/**\n+ * Extension of {@link AbstractTestMap} for exercising the \n+ * {@link CompositeMap} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/14 21:42:55 $\n+ *\n+ * @author Brian McCallister\n+ */\n+public class TestCompositeMap extends AbstractTestMap {\n+    /** used as a flag in MapMutator tests */\n+    private boolean pass = false;\n+    \n+    public TestCompositeMap(String testName) {\n+        super(testName);\n+    }\n+    \n+    public static Test suite() {\n+        return new TestSuite(TestCompositeMap.class);\n+    }\n+    \n+    public void setUp() throws Exception {\n+        super.setUp();\n+        this.pass = false;\n+    }\n+    \n+    public static void main(String args[]) {\n+        String[] testCaseName = {TestCompositeMap.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+    \n+    public Map makeEmptyMap() {\n+        CompositeMap map = new CompositeMap();\n+        map.addComposited(new HashMap());\n+        map.setMutator(new CompositeMap.MapMutator() {\n+            public void resolveCollision(CompositeMap composite,\n+            Map existing,\n+            Map added,\n+            Collection intersect) {\n+                // Do nothing\n+            }\n+            \n+            public Object put(CompositeMap map, Map[] composited, Object key, Object value) {\n+                return composited[0].put(key, value);\n+            }\n+            \n+            public void putAll(CompositeMap map, Map[] composited, Map t) {\n+                composited[0].putAll(t);\n+            }\n+            \n+        });\n+        return map;\n+    }\n+    \n+    private Map buildOne() {\n+        HashMap map = new HashMap();\n+        map.put(\"1\", \"one\");\n+        map.put(\"2\", \"two\");\n+        return map;\n+    }\n+    \n+    public Map buildTwo() {\n+        HashMap map = new HashMap();\n+        map.put(\"3\", \"three\");\n+        map.put(\"4\", \"four\");\n+        return map;\n+    }\n+    \n+    public void testGet() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo());\n+        Assert.assertEquals(\"one\", map.get(\"1\"));\n+        Assert.assertEquals(\"four\", map.get(\"4\"));\n+    }\n+    \n+    public void testAddComposited() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo());\n+        HashMap three = new HashMap();\n+        three.put(\"5\", \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        try {\n+            map.addComposited(three);\n+            fail(\"Expecting IllegalArgumentException.\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testRemoveComposited() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo());\n+        HashMap three = new HashMap();\n+        three.put(\"5\", \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(three);\n+        assertFalse(map.containsKey(\"5\"));\n+        \n+        map.removeComposited(buildOne());\n+        assertFalse(map.containsKey(\"2\"));\n+        \n+    }\n+    \n+    public void testRemoveFromUnderlying() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo());\n+        HashMap three = new HashMap();\n+        three.put(\"5\", \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        three.remove(\"5\");\n+        assertFalse(map.containsKey(\"5\"));\n+    }\n+    \n+    public void testRemoveFromComposited() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo());\n+        HashMap three = new HashMap();\n+        three.put(\"5\", \"five\");\n+        map.addComposited(three);\n+        assertTrue(map.containsKey(\"5\"));\n+        \n+        //Now remove \"5\"\n+        map.remove(\"5\");\n+        assertFalse(three.containsKey(\"5\"));\n+    }\n+    \n+    public void testResolveCollision() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator() {\n+            public void resolveCollision(CompositeMap composite,\n+            Map existing,\n+            Map added,\n+            Collection intersect) {\n+                pass = true;\n+            }\n+            \n+            public Object put(CompositeMap map, Map[] composited, Object key, \n+                Object value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(CompositeMap map, Map[] composited, Map t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.addComposited(buildOne());\n+        assertTrue(pass);\n+    }\n+    \n+    public void testPut() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator() {\n+            public void resolveCollision(CompositeMap composite,\n+            Map existing,\n+            Map added,\n+            Collection intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public Object put(CompositeMap map, Map[] composited, Object key, \n+                Object value) {\n+                pass = true;\n+                return \"foo\";\n+            }\n+            \n+            public void putAll(CompositeMap map, Map[] composited, Map t) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        map.put(\"willy\", \"wonka\");\n+        assertTrue(pass);\n+    }\n+    \n+    public void testPutAll() {\n+        CompositeMap map = new CompositeMap(buildOne(), buildTwo(), \n+            new CompositeMap.MapMutator() {\n+            public void resolveCollision(CompositeMap composite,\n+            Map existing,\n+            Map added,\n+            Collection intersect) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public Object put(CompositeMap map, Map[] composited, Object key,\n+                Object value) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public void putAll(CompositeMap map, Map[] composited, Map t) {\n+                pass = true;\n+            }\n+        });\n+        \n+        map.putAll(null);\n+        assertTrue(pass);\n+    }\n+}\n+\n--- a/src/test/org/apache/commons/collections/set/TestAll.java\n+++ b/src/test/org/apache/commons/collections/set/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/set/TestAll.java,v 1.2 2003/12/03 11:19:10 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/set/TestAll.java,v 1.3 2003/12/14 21:42:55 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/12/03 11:19:10 $\n+ * @version $Revision: 1.3 $ $Date: 2003/12/14 21:42:55 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n+        suite.addTest(TestCompositeSet.suite());\n         suite.addTest(TestListOrderedSet.suite());\n         suite.addTest(TestPredicatedSet.suite());\n         suite.addTest(TestPredicatedSortedSet.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/set/TestCompositeSet.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/set/TestCompositeSet.java,v 1.1 2003/12/14 21:42:55 psteitz Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+\n+package org.apache.commons.collections.set;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.collection.CompositeCollection;\n+\n+import java.util.Set;\n+import java.util.HashSet;\n+import java.util.Collection;\n+\n+/**\n+ * Extension of {@link AbstractTestSet} for exercising the \n+ * {@link CompositeSet} implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/14 21:42:55 $\n+ *\n+ * @author Brian McCallister\n+ * @author Phil Steitz\n+ */\n+\n+public class TestCompositeSet extends AbstractTestSet {\n+    public TestCompositeSet(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        return new TestSuite(TestCompositeSet.class);\n+    }\n+    \n+    public Set makeEmptySet() {\n+        final HashSet contained = new HashSet();\n+        CompositeSet set = new CompositeSet(contained);\n+        set.setMutator(new CompositeSet.SetMutator() {\n+            public void resolveCollision(CompositeSet comp, Set existing, \n+                Set added, Collection intersects) {\n+                throw new IllegalArgumentException();\n+            }\n+            \n+            public boolean add(CompositeCollection composite, \n+                Collection[] collections, Object obj) {\n+                return contained.add(obj);\n+            }\n+            \n+            public boolean addAll(CompositeCollection composite, \n+                Collection[] collections, Collection coll) {\n+                return contained.addAll(coll);\n+            }\n+            \n+            public boolean remove(CompositeCollection composite, \n+                Collection[] collections, Object obj) {\n+                return contained.remove(obj);\n+            }\n+        });\n+        return set;\n+    }\n+    \n+    public Set buildOne() {\n+        HashSet set = new HashSet();\n+        set.add(\"1\");\n+        set.add(\"2\");\n+        return set;\n+    }\n+    \n+    public Set buildTwo() {\n+        HashSet set = new HashSet();\n+        set.add(\"3\");\n+        set.add(\"4\");\n+        return set;\n+    }\n+    \n+    public void testContains() {\n+        CompositeSet set = new CompositeSet(new Set[]{buildOne(), buildTwo()});\n+        assertTrue(set.contains(\"1\"));\n+    }\n+    \n+    public void testRemoveUnderlying() {\n+        Set one = buildOne();\n+        Set two = buildTwo();\n+        CompositeSet set = new CompositeSet(new Set[]{one, two});\n+        one.remove(\"1\");\n+        assertFalse(set.contains(\"1\"));\n+        \n+        two.remove(\"3\");\n+        assertFalse(set.contains(\"3\"));\n+    }\n+    \n+    public void testRemoveComposited() {\n+        Set one = buildOne();\n+        Set two = buildTwo();\n+        CompositeSet set = new CompositeSet(new Set[]{one, two});\n+        set.remove(\"1\");\n+        assertFalse(one.contains(\"1\"));\n+        \n+        set.remove(\"3\");\n+        assertFalse(one.contains(\"3\"));\n+    }\n+    \n+    public void testFailedCollisionResolution() {\n+        Set one = buildOne();\n+        Set two = buildTwo();\n+        CompositeSet set = new CompositeSet(new Set[]{one, two});\n+        set.setMutator(new CompositeSet.SetMutator() {\n+            public void resolveCollision(CompositeSet comp, Set existing, \n+                Set added, Collection intersects) {\n+            }\n+            \n+            public boolean add(CompositeCollection composite, \n+                Collection[] collections, Object obj) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public boolean addAll(CompositeCollection composite, \n+                Collection[] collections, Collection coll) {\n+                throw new UnsupportedOperationException();\n+            }\n+            \n+            public boolean remove(CompositeCollection composite, \n+                Collection[] collections, Object obj) {\n+                throw new UnsupportedOperationException();\n+            }\n+        });\n+        \n+        HashSet three = new HashSet();\n+        three.add(\"1\");\n+        try {\n+            set.addComposited(three);\n+            fail(\"IllegalArgumentException should have been thrown\");\n+        }\n+        catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testAddComposited() {\n+        Set one = buildOne();\n+        Set two = buildTwo();\n+        CompositeSet set = new CompositeSet();\n+        set.addComposited(one, two);\n+        CompositeSet set2 = new CompositeSet(buildOne());\n+        set2.addComposited(buildTwo());\n+        assertTrue(set.equals(set2));\n+        HashSet set3 = new HashSet();\n+        set3.add(\"1\");\n+        set3.add(\"2\");\n+        set3.add(\"3\");\n+        HashSet set4 = new HashSet();\n+        set4.add(\"4\");\n+        CompositeSet set5 = new CompositeSet(set3);\n+        set5.addComposited(set4);\n+        assertTrue(set.equals(set5));\n+        try {\n+            set.addComposited(set3);\n+            fail(\"Expecting UnsupportedOperationException.\");\n+        } catch (UnsupportedOperationException ex) {\n+            // expected\n+        }\n+    }\n+}", "timestamp": 1071438175, "metainfo": ""}