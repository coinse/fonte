{"sha": "afae3dd81da5b7518514ffe828428ac0d05d8fe2", "log": "Update javadoc with renamed tests, minor formatting fixes.  ", "commit": "\n--- a/src/test/java/org/apache/commons/collections4/BulkTest.java\n+++ b/src/test/java/org/apache/commons/collections4/BulkTest.java\n  * For instance, consider the following two classes:\n  *\n  * <Pre>\n- *  public class TestSet extends BulkTest {\n+ *  public class SetTest extends BulkTest {\n  *\n  *      private Set set;\n  *\n- *      public TestSet(Set set) {\n+ *      public SetTest(Set set) {\n  *          this.set = set;\n  *      }\n  *\n  *  }\n  *\n  *\n- *  public class TestHashMap extends BulkTest {\n+ *  public class HashMapTest extends BulkTest {\n  *\n  *      private Map makeFullMap() {\n  *          HashMap result = new HashMap();\n  *  }\n  *  </Pre>\n  *\n- *  In the above examples, <code>TestSet</code> defines two\n- *  simple test methods and no bulk test methods; <code>TestHashMap</code>\n+ *  In the above examples, <code>SetTest</code> defines two\n+ *  simple test methods and no bulk test methods; <code>HashMapTest</code>\n  *  defines one simple test method and two bulk test methods.  When\n- *  <code>makeSuite(TestHashMap.class).run</code> is executed, \n+ *  <code>makeSuite(HashMapTest.class).run</code> is executed, \n  *  <I>five</I> simple test methods will be run, in this order:<P>\n  *\n  *  <Ol>\n- *  <Li>TestHashMap.testClear()\n- *  <Li>TestHashMap.bulkTestKeySet().testContains();\n- *  <Li>TestHashMap.bulkTestKeySet().testClear();\n- *  <Li>TestHashMap.bulkTestEntrySet().testContains();\n- *  <Li>TestHashMap.bulkTestEntrySet().testClear();\n+ *  <Li>HashMapTest.testClear()\n+ *  <Li>HashMapTest.bulkTestKeySet().testContains();\n+ *  <Li>HashMapTest.bulkTestKeySet().testClear();\n+ *  <Li>HashMapTest.bulkTestEntrySet().testContains();\n+ *  <Li>HashMapTest.bulkTestEntrySet().testClear();\n  *  </Ol>\n  *\n  *  In the graphical junit test runners, the tests would be displayed in\n  *  the following tree:<P>\n  *\n  *  <UL>\n- *  <LI>TestHashMap</LI>\n+ *  <LI>HashMapTest</LI>\n  *      <UL>\n  *      <LI>testClear\n  *      <LI>bulkTestKeySet\n      *  method name.  The method names are delimited by periods:\n      *\n      *  <pre>\n-     *  TestHashMap.bulkTestEntrySet.testClear\n+     *  HashMapTest.bulkTestEntrySet.testClear\n      *  </pre>\n      *\n      *  is the name of one of the simple tests defined in the sample classes\n-     *  described above.  If the sample <code>TestHashMap</code> class\n+     *  described above.  If the sample <code>HashMapTest</code> class\n      *  included this method:\n      *\n      *  <pre>\n      *  public String[] ignoredTests() {\n-     *      return new String[] { \"TestHashMap.bulkTestEntrySet.testClear\" };\n+     *      return new String[] { \"HashMapTest.bulkTestEntrySet.testClear\" };\n      *  }\n      *  </pre>\n      *\n      *\n      *  The class is examined for simple and bulk test methods; any child\n      *  bulk tests are also examined recursively; and the results are stored\n-     *  in a hierarchal {@link TestSuite}.<P>\n+     *  in a hierarchical {@link TestSuite}.<P>\n      *\n      *  The given class must be a subclass of <code>BulkTest</code> and must\n      *  not be abstract.<P>\n     private TestSuite result;\n \n     /** \n-     *  The prefix for simple test methods.  Used to check if a test is in \n-     *  the ignored list.\n+     * The prefix for simple test methods.  Used to check if a test is in \n+     * the ignored list.\n      */ \n     private String prefix;\n \n     /** \n-     *  Constructor.\n-     *\n-     *  @param startingClass  the starting class\n+     * Constructor.\n+     *\n+     * @param startingClass  the starting class\n      */     \n     public BulkTestSuiteMaker(final Class<? extends BulkTest> startingClass) {\n         this.startingClass = startingClass;\n     }\n \n     /**\n-     *  Makes a hierarchical TestSuite based on the starting class.\n-     *\n-     *  @return  the hierarchical TestSuite for startingClass\n+     * Makes a hierarchical TestSuite based on the starting class.\n+     *\n+     * @return  the hierarchical TestSuite for startingClass\n      */\n     public TestSuite make() {\n          this.result = new TestSuite();\n     }\n \n     /**\n-     *  Appends all the simple tests and bulk tests defined by the given\n-     *  instance's class to the current TestSuite.\n-     *\n-     *  @param bulk  An instance of the class that defines simple and bulk\n+     * Appends all the simple tests and bulk tests defined by the given\n+     * instance's class to the current TestSuite.\n+     *\n+     * @param bulk  An instance of the class that defines simple and bulk\n      *    tests for us to append\n      */\n     void make(final BulkTest bulk) {\n     }\n \n     /**\n-     *  Adds the simple test defined by the given method to the TestSuite.\n-     *\n-     *  @param bulk  The instance of the class that defined the method\n+     * Adds the simple test defined by the given method to the TestSuite.\n+     *\n+     * @param bulk  The instance of the class that defined the method\n      *   (I know it's weird.  But the point is, we can clone the instance\n      *   and not have to worry about constructors.)\n-     *  @param m  The simple test method\n+     * @param m  The simple test method\n      */\n     void addTest(final BulkTest bulk, final Method m) {\n         final BulkTest bulk2 = (BulkTest)bulk.clone();\n     }\n \n     /**\n-     *  Adds a whole new suite of tests that are defined by the result of\n-     *  the given bulk test method.  In other words, the given bulk test\n-     *  method is invoked, and the resulting BulkTest instance is examined\n-     *  for yet more simple and bulk tests.\n-     *\n-     *  @param bulk  The instance of the class that defined the method\n-     *  @param m  The bulk test method\n+     * Adds a whole new suite of tests that are defined by the result of\n+     * the given bulk test method.  In other words, the given bulk test\n+     * method is invoked, and the resulting BulkTest instance is examined\n+     * for yet more simple and bulk tests.\n+     *\n+     * @param bulk  The instance of the class that defined the method\n+     * @param m  The bulk test method\n      */\n     void addBulk(final BulkTest bulk, final Method m) {\n         final String verboseName = prefix + \".\" + m.getName();\n     }\n \n     /**\n-     *  Returns the base name of the given class.\n-     *\n-     *  @param c  the class\n-     *  @return the name of that class, minus any package names\n+     * Returns the base name of the given class.\n+     *\n+     * @param c  the class\n+     * @return the name of that class, minus any package names\n      */\n     private static String getBaseName(final Class<?> c) {\n         String name = c.getName();\n         try {\n             return c.getConstructor(new Class[] { String.class });\n         } catch (final NoSuchMethodException e) {\n-            throw new IllegalArgumentException(c + \" must provide \" +\n-             \"a (String) constructor\");\n+            throw new IllegalArgumentException(c + \" must provide a (String) constructor\");\n         }\n     }\n \n                 return makeTestCase(c, element);\n             }\n         }\n-        throw new IllegalArgumentException(c.getName() + \" must provide \" \n-          + \" at least one test method.\");\n-    }\n-\n-    /**\n-     *  Returns true if the given method is a simple test method.\n+        throw new IllegalArgumentException(c.getName() + \" must provide at least one test method.\");\n+    }\n+\n+    /**\n+     * Returns true if the given method is a simple test method.\n      */\n     private static boolean isTest(final Method m) {\n         if (!m.getName().startsWith(\"test\")) {\n     }\n \n     /**\n-     *  Returns true if the given method is a bulk test method.\n+     * Returns true if the given method is a bulk test method.\n      */\n     private static boolean isBulk(final Method m) {\n         if (!m.getName().startsWith(\"bulkTest\")) {", "timestamp": 1366566914, "metainfo": ""}