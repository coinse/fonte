{"sha": "a9447a7c7213f40318a0f3f0ca78da9d56654d69", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r751871 | mbenson | 2009-03-09 15:13:34 -0700 (Mon, 09 Mar 2009) | 1 line          Add OrderedMap to our SortedMap implementations     ------------------------------------------------------------------------     r471189 | scolebourne | 2006-11-04 05:57:57 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getMap(), getOrderedMap() and getSortedMap() - use decorated()     ------------------------------------------------------------------------     r471180 | scolebourne | 2006-11-04 05:27:44 -0800 (Sat, 04 Nov 2006) | 1 line          Abstract*Decorator - Generify and use covariant return types     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/AbstractSortedMapDecorator.java\n+++ b/src/java/org/apache/commons/collections/map/AbstractSortedMapDecorator.java\n package org.apache.commons.collections.map;\n \n import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.SortedMap;\n+\n+import org.apache.commons.collections.IterableSortedMap;\n+import org.apache.commons.collections.OrderedMapIterator;\n+import org.apache.commons.collections.iterators.ListIteratorWrapper;\n \n /** \n  * Provides a base decorator that enables additional functionality to be added\n  * it would provide a loophole around the validation.\n  * But, you might want that loophole, so this class is kept simple.\n  *\n+ * @param <K> the type of the keys in the map\n+ * @param <V> the type of the values in the map\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public abstract class AbstractSortedMapDecorator\n-        extends AbstractMapDecorator implements SortedMap {\n+public abstract class AbstractSortedMapDecorator<K, V> extends AbstractMapDecorator<K, V> implements\n+        IterableSortedMap<K, V> {\n \n     /**\n      * Constructor only used in deserialization, do not use otherwise.\n      * @param map  the map to decorate, must not be null\n      * @throws IllegalArgumentException if the collection is null\n      */\n-    public AbstractSortedMapDecorator(SortedMap map) {\n+    public AbstractSortedMapDecorator(SortedMap<K, V> map) {\n         super(map);\n     }\n \n      * \n      * @return the decorated map\n      */\n-    protected SortedMap getSortedMap() {\n-        return (SortedMap) map;\n+    protected SortedMap<K, V> decorated() {\n+        return (SortedMap<K, V>) super.decorated();\n     }\n \n     //-----------------------------------------------------------------------\n-    public Comparator comparator() {\n-        return getSortedMap().comparator();\n+    public Comparator<? super K> comparator() {\n+        return decorated().comparator();\n     }\n \n-    public Object firstKey() {\n-        return getSortedMap().firstKey();\n+    public K firstKey() {\n+        return decorated().firstKey();\n     }\n \n-    public SortedMap headMap(Object toKey) {\n-        return getSortedMap().headMap(toKey);\n+    public K lastKey() {\n+        return decorated().lastKey();\n     }\n \n-    public Object lastKey() {\n-        return getSortedMap().lastKey();\n+    public SortedMap<K, V> subMap(K fromKey, K toKey) {\n+        return decorated().subMap(fromKey, toKey);\n     }\n \n-    public SortedMap subMap(Object fromKey, Object toKey) {\n-        return getSortedMap().subMap(fromKey, toKey);\n+    public SortedMap<K, V> headMap(K toKey) {\n+        return decorated().headMap(toKey);\n     }\n \n-    public SortedMap tailMap(Object fromKey) {\n-        return getSortedMap().tailMap(fromKey);\n+    public SortedMap<K, V> tailMap(K fromKey) {\n+        return decorated().tailMap(fromKey);\n     }\n \n+    public K previousKey(K key) {\n+        SortedMap<K, V> headMap = headMap(key);\n+        return headMap.isEmpty() ? null : headMap.lastKey();\n+    };\n+\n+    public K nextKey(K key) {\n+        Iterator<K> it = tailMap(key).keySet().iterator();\n+        it.next();\n+        return it.hasNext() ? it.next() : null;\n+    };\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OrderedMapIterator<K, V> mapIterator() {\n+        return new SortedMapIterator<K, V>(entrySet());\n+    }\n+\n+    /**\n+     * OrderedMapIterator implementation.\n+     *\n+     * @param <K>\n+     * @param <V>\n+     */\n+    protected static class SortedMapIterator<K, V> extends EntrySetToMapIteratorAdapter<K, V>\n+            implements OrderedMapIterator<K, V> {\n+\n+        /**\n+         * Create a new AbstractSortedMapDecorator.SortedMapIterator.\n+         */\n+        protected SortedMapIterator(Set<Map.Entry<K, V>> entrySet) {\n+            super(entrySet);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public synchronized void reset() {\n+            super.reset();\n+            iterator = new ListIteratorWrapper<Map.Entry<K, V>>(iterator);\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public boolean hasPrevious() {\n+            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        public K previous() {\n+            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n+            return getKey();\n+        }\n+    }\n }", "timestamp": 1252994157, "metainfo": ""}