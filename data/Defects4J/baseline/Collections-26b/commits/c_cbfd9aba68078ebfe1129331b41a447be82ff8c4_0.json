{"sha": "cbfd9aba68078ebfe1129331b41a447be82ff8c4", "log": "Handle multiple keys better, bug reported by Wolfgang Hoschek   ", "commit": "\n--- a/src/java/org/apache/commons/collections/ExtendedProperties.java\n+++ b/src/java/org/apache/commons/collections/ExtendedProperties.java\n  * it, go ahead and tune it up!\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.22 $ $Date: 2004/03/17 21:09:08 $\n+ * @version $Revision: 1.23 $ $Date: 2004/06/21 23:39:25 $\n  * \n  * @author <a href=\"mailto:stefano@apache.org\">Stefano Mazzocchi</a>\n  * @author <a href=\"mailto:jon@latchkey.com\">Jon S. Stevens</a>\n      * <code>[\"file\", \"classpath\"]</code>\n      *\n      * @param key  the key to add\n-     * @param token  the value to add\n-     */\n-    public void addProperty(String key, Object token) {\n-        Object obj = this.get(key);\n-\n-        /*\n-         *  $$$ GMJ\n-         *  FIXME : post 1.0 release, we need to not assume\n-         *  that a scalar is a String - it can be an Object\n-         *  so we should make a little vector-like class\n-         *  say, Foo that wraps (not extends Vector),\n-         *  so we can do things like\n-         *  if ( !( o instanceof Foo) )\n-         *  so we know it's our 'vector' container\n-         *\n-         *  This applies throughout\n-         */\n-\n-        if (obj instanceof String) {\n-            Vector v = new Vector(2);\n-            v.addElement(obj);\n-            v.addElement(token);\n-            put(key, v);\n-            \n-        } else if (obj instanceof Vector) {\n-            ((Vector) obj).addElement(token);\n-            \n-        } else {\n-            /*\n-             * This is the first time that we have seen\n-             * request to place an object in the \n-             * configuration with the key 'key'. So\n-             * we just want to place it directly into\n-             * the configuration ... but we are going to\n-             * make a special exception for String objects\n-             * that contain \",\" characters. We will take\n-             * CSV lists and turn the list into a vector of\n-             * Strings before placing it in the configuration.\n-             * This is a concession for Properties and the\n-             * like that cannot parse multiple same key\n-             * values.\n-             */\n-            if (token instanceof String &&\n-                ((String) token).indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n-                    \n-                PropertiesTokenizer tokenizer = new PropertiesTokenizer((String) token);\n-\n+     * @param value  the value to add\n+     */\n+    public void addProperty(String key, Object value) {\n+        if (value instanceof String) {\n+            String str = (String) value;\n+            if (str.indexOf(PropertiesTokenizer.DELIMITER) > 0) {\n+                // token contains commas, so must be split apart then added\n+                PropertiesTokenizer tokenizer = new PropertiesTokenizer(str);\n                 while (tokenizer.hasMoreTokens()) {\n-                    String value = tokenizer.nextToken();\n-\n-                    /*\n-                     * We know this is a string, so make sure it\n-                     * just goes in rather than risking vectorization\n-                     * if it contains an escaped comma\n-                     */\n-                    addStringProperty(key, unescape(value));\n+                    String token = tokenizer.nextToken();\n+                    addPropertyInternal(key, unescape(token));\n                 }\n             } else {\n-                /*\n-                 * We want to keep track of the order the keys\n-                 * are parsed, or dynamically entered into\n-                 * the configuration. So when we see a key\n-                 * for the first time we will place it in\n-                 * an ArrayList so that if a client class needs\n-                 * to perform operations with configuration\n-                 * in a definite order it will be possible.\n-                 */\n-                if (token instanceof String) {\n-                    token = unescape((String) token);\n-                }\n-                addPropertyDirect(key, token);\n-            }\n+                // token contains no commas, so can be simply added\n+                addPropertyInternal(key, unescape(str));\n+            }\n+        } else {\n+            addPropertyInternal(key, value);\n         }\n \n         // Adding a property connotes initialization\n      * Adds a key/value pair to the map.  This routine does\n      * no magic morphing.  It ensures the keylist is maintained\n      *\n-     * @param key key to use for mapping\n-     * @param obj object to store\n-     */\n-    private void addPropertyDirect(String key, Object obj) {\n+     * @param key  the key to store at\n+     * @param value  the decoded object to store\n+     */\n+    private void addPropertyDirect(String key, Object value) {\n         // safety check\n         if (!containsKey(key)) {\n             keysAsListed.add(key);\n         }\n-        put(key, obj);\n-    }\n-\n-    /**\n-     * Sets a string property w/o checking for commas - used\n+        put(key, value);\n+    }\n+\n+    /**\n+     * Adds a decoded property to the map w/o checking for commas - used\n      * internally when a property has been broken up into\n      * strings that could contain escaped commas to prevent\n      * the inadvertent vectorization.\n      * <p>\n      * Thanks to Leon Messerschmidt for this one.\n      *\n-     */\n-    private void addStringProperty(String key, String token) {\n-        Object obj = this.get(key);\n-\n-        /*\n-         *  $$$ GMJ\n-         *  FIXME : post 1.0 release, we need to not assume\n-         *  that a scalar is a String - it can be an Object\n-         *  so we should make a little vector-like class\n-         *  say, Foo that wraps (not extends Vector),\n-         *  so we can do things like\n-         *  if ( !( o instanceof Foo) )\n-         *  so we know it's our 'vector' container\n-         *\n-         *  This applies throughout\n-         */\n-\n-        // do the usual thing - if we have a value and \n-        // it's scalar, make a vector, otherwise add\n-        // to the vector\n-        if (obj instanceof String) {\n+     * @param key  the key to store at\n+     * @param value  the decoded object to store\n+     */\n+    private void addPropertyInternal(String key, Object value) {\n+        Object current = this.get(key);\n+\n+        if (current instanceof String) {\n+            // one object already in map - convert it to a vector\n             Vector v = new Vector(2);\n-            v.addElement(obj);\n-            v.addElement(token);\n+            v.addElement(current);\n+            v.addElement(value);\n             put(key, v);\n             \n-        } else if (obj instanceof Vector) {\n-            ((Vector) obj).addElement(token);\n-            \n-        } else {\n-            addPropertyDirect(key, token);\n+        } else if (current instanceof Vector) {\n+            // already a vector - just add the new token\n+            ((Vector) current).addElement(value);\n+            \n+        } else {\n+            // brand new key - store in keysAsListed to retain order\n+            if (!containsKey(key)) {\n+                keysAsListed.add(key);\n+            }\n+            put(key, value);\n         }\n     }\n \n--- a/src/test/org/apache/commons/collections/TestExtendedProperties.java\n+++ b/src/test/org/apache/commons/collections/TestExtendedProperties.java\n /**\n  * Tests some basic functions of the ExtendedProperties class.\n  * \n- * @version $Revision: 1.12 $ $Date: 2004/02/18 01:20:35 $\n+ * @version $Revision: 1.13 $ $Date: 2004/06/21 23:39:25 $\n  * \n  * @author Geir Magnusson Jr.\n  * @author Mohan Kishore\n         }\n     }\n     \n+    public void testMultipleSameKey1() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a\n+        one=b,c\n+        */\n+        String s1 = \"one=a\\none=b,c\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+        assertEquals(3, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+    }\n+    \n+    public void testMultipleSameKey2() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a,b\n+        one=c,d\n+        */\n+        String s1 = \"one=a,b\\none=c,d\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+        assertEquals(4, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getVector(\"one\").get(3));\n+    }\n+    \n+    public void testMultipleSameKey3() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        /*\n+        initialize using:\n+        one=a,b\n+        one=c\n+        */\n+        String s1 = \"one=a,b\\none=c\\n\";\n+        byte[] bytes = s1.getBytes();\n+        ByteArrayInputStream bais = new ByteArrayInputStream(bytes);\n+        ep1.load(bais);\n+        assertEquals(1, ep1.size());\n+        assertEquals(3, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(\"b\", ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+    }\n+    \n+    public void testMultipleSameKeyByCode() throws Exception {\n+        ExtendedProperties ep1 = new ExtendedProperties();\n+\n+        ep1.addProperty(\"one\", \"a\");\n+        assertEquals(1, ep1.size());\n+        assertEquals(1, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        \n+        ep1.addProperty(\"one\", Boolean.TRUE);\n+        assertEquals(1, ep1.size());\n+        assertEquals(2, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getVector(\"one\").get(1));\n+        \n+        ep1.addProperty(\"one\", \"c,d\");\n+        assertEquals(1, ep1.size());\n+        assertEquals(4, ep1.getVector(\"one\").size());\n+        assertEquals(\"a\", ep1.getVector(\"one\").get(0));\n+        assertEquals(Boolean.TRUE, ep1.getVector(\"one\").get(1));\n+        assertEquals(\"c\", ep1.getVector(\"one\").get(2));\n+        assertEquals(\"d\", ep1.getVector(\"one\").get(3));\n+    }\n+    \n }", "timestamp": 1087861165, "metainfo": ""}