{"sha": "71839dd264dba2f9537b9f8099326f652b4a25a3", "log": "[COLLECTIONS-396] Added new LazyIteratorChain in iterators. Thanks to Jeff Rodriguez.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/LazyIteratorChain.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * An LazyIteratorChain is an Iterator that wraps a number of Iterators in a lazy manner.\n+ * <p>\n+ * This class makes multiple iterators look like one to the caller. When any\n+ * method from the Iterator interface is called, the LazyIteratorChain will delegate\n+ * to a single underlying Iterator. The LazyIteratorChain will invoke the Iterators\n+ * in sequence until all Iterators are exhausted.\n+ * <p>\n+ * The Iterators are provided by {@link #nextIterator(int)} which has to be overridden by\n+ * sub-classes and allows to lazily create the Iterators as they are accessed:\n+ * <pre>\n+ * return new LazyIteratorChain<String>() {\n+ *     protected Iterator<String> nextIterator(int count) {\n+ *         return count == 1 ? Arrays.asList(\"foo\", \"bar\").iterator() : null;\n+ *     }\n+ * };\n+ * </pre>\n+ * <p>\n+ * Once the inner Iterator's {@link Iterator#hasNext()} method returns false,\n+ * {@link #nextIterator(int)} will be called to obtain another iterator, and so on\n+ * until {@link #nextIterator(int)} returns null, indicating that the chain is exhausted.\n+ * <p>\n+ * NOTE: The LazyIteratorChain may contain no iterators. In this case the class will\n+ * function as an empty iterator.\n+ *\n+ * @since 4.0\n+ * @version $Id $\n+ */\n+public abstract class LazyIteratorChain<E> implements Iterator<E> {\n+\n+    /** The number of times {@link #nextIterator()} was already called. */\n+    private int callCounter = 0;\n+\n+    /** Indicates that the Iterator chain has been exhausted. */\n+    private boolean chainExhausted = false;\n+\n+    /** The current iterator. */\n+    private Iterator<? extends E> currentIterator = null;\n+\n+    /**\n+     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n+     * was most recently called used for the remove() operation only.\n+     */\n+    private Iterator<? extends E> lastUsedIterator = null;\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Gets the next iterator after the previous one has been exhausted.\n+     * <p>\n+     * This method <b>MUST</b> return null when there are no more iterators.\n+     *\n+     * @param count the number of time this method has been called (starts with 1)\n+     * @return the next iterator, or null if there are no more.\n+     */\n+    protected abstract Iterator<? extends E> nextIterator(int count);\n+\n+    /**\n+     * Updates the current iterator field to ensure that the current Iterator\n+     * is not exhausted.\n+     */\n+    private void updateCurrentIterator() {\n+        if (callCounter == 0) {\n+            currentIterator = nextIterator(++callCounter);\n+            if (currentIterator == null) {\n+                currentIterator = EmptyIterator.<E>emptyIterator();\n+                chainExhausted = true;\n+            }\n+            // set last used iterator here, in case the user calls remove\n+            // before calling hasNext() or next() (although they shouldn't)\n+            lastUsedIterator = currentIterator;\n+        }\n+\n+        while (currentIterator.hasNext() == false && !chainExhausted) {\n+            final Iterator<? extends E> nextIterator = nextIterator(++callCounter);\n+            if (nextIterator != null) {\n+                currentIterator = nextIterator;\n+            } else {\n+                chainExhausted = true;\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+\n+    /**\n+     * Return true if any Iterator in the chain has a remaining element.\n+     * \n+     * @return true if elements remain\n+     */\n+    public boolean hasNext() {\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+\n+        return currentIterator.hasNext();\n+    }\n+\n+    /**\n+     * Returns the next element of the current Iterator\n+     * \n+     * @return element from the current Iterator\n+     * @throws java.util.NoSuchElementException if all the Iterators are exhausted\n+     */\n+    public E next() {\n+        updateCurrentIterator();\n+        lastUsedIterator = currentIterator;\n+        \n+        return currentIterator.next();\n+    }\n+\n+    /**\n+     * Removes from the underlying collection the last element returned by the Iterator.\n+     * <p>\n+     * As with next() and hasNext(), this method calls remove() on the underlying Iterator.\n+     * Therefore, this method may throw an UnsupportedOperationException if the underlying\n+     * Iterator does not support this method.\n+     * \n+     * @throws UnsupportedOperationException if the remove operator is not\n+     *   supported by the underlying Iterator\n+     * @throws IllegalStateException if the next method has not yet been called,\n+     *   or the remove method has already been called after the last call to the next method.\n+     */\n+    public void remove() {\n+        if (currentIterator == null) {\n+            updateCurrentIterator();\n+        }\n+        lastUsedIterator.remove();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/LazyIteratorChainTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.IteratorUtils;\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Tests the LazyIteratorChain class.\n+ *\n+ * @version $Id$\n+ */\n+public class LazyIteratorChainTest extends AbstractIteratorTest<String> {\n+\n+    protected String[] testArray = {\n+        \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\n+    };\n+\n+    protected List<String> list1 = null;\n+    protected List<String> list2 = null;\n+    protected List<String> list3 = null;\n+\n+    public LazyIteratorChainTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        list1 = new ArrayList<String>();\n+        list1.add(\"One\");\n+        list1.add(\"Two\");\n+        list1.add(\"Three\");\n+        list2 = new ArrayList<String>();\n+        list2.add(\"Four\");\n+        list3 = new ArrayList<String>();\n+        list3.add(\"Five\");\n+        list3.add(\"Six\");        \n+    }\n+\n+    @Override\n+    public LazyIteratorChain<String> makeEmptyIterator() {\n+        return new LazyIteratorChain<String>() {\n+            @Override\n+            protected Iterator<String> nextIterator(int count) {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public LazyIteratorChain<String> makeObject() {\n+        final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {\n+            @Override\n+            protected Iterator<String> nextIterator(int count) {\n+                switch (count) {\n+                case 1:\n+                    return list1.iterator();\n+                case 2:\n+                    return list2.iterator();\n+                case 3:\n+                    return list3.iterator();\n+                }\n+                return null;\n+            }\n+        };\n+\n+        return chain;\n+    }\n+\n+    public void testIterator() {\n+        final Iterator<String> iter = makeObject();\n+        for (final String testValue : testArray) {\n+            final Object iterValue = iter.next();\n+\n+            assertEquals( \"Iteration value is correct\", testValue, iterValue );\n+        }\n+\n+        assertTrue(\"Iterator should now be empty\", !iter.hasNext());\n+\n+        try {\n+            iter.next();\n+        } catch (final Exception e) {\n+            assertTrue(\"NoSuchElementException must be thrown\", \n+                       e.getClass().equals(new NoSuchElementException().getClass()));\n+        }\n+    }\n+\n+    public void testRemoveFromFilteredIterator() {\n+\n+        final Predicate<Integer> myPredicate = new Predicate<Integer>() {\n+            public boolean evaluate(final Integer i) {\n+                return i.compareTo(new Integer(4)) < 0;\n+            }\n+        };\n+\n+        final List<Integer> list1 = new ArrayList<Integer>();\n+        final List<Integer> list2 = new ArrayList<Integer>();\n+\n+        list1.add(new Integer(1));\n+        list1.add(new Integer(2));\n+        list2.add(new Integer(3));\n+        list2.add(new Integer(4)); // will be ignored by the predicate\n+\n+        final Iterator<Integer> it1 = IteratorUtils.filteredIterator(list1.iterator(), myPredicate);\n+        final Iterator<Integer> it2 = IteratorUtils.filteredIterator(list2.iterator(), myPredicate);\n+\n+        final Iterator<Integer> it = IteratorUtils.chainedIterator(it1, it2);\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, list1.size());\n+        assertEquals(1, list2.size());\n+    }\n+    \n+    @Override\n+    public void testRemove() {\n+        final Iterator<String> iter = makeObject();\n+\n+        try {\n+            iter.remove();\n+            fail(\"Calling remove before the first call to next() should throw an exception\");\n+        } catch (final IllegalStateException e) {\n+\n+        }\n+\n+        for (final String testValue : testArray) {\n+            final String iterValue = iter.next();\n+\n+            assertEquals(\"Iteration value is correct\", testValue, iterValue);\n+\n+            if (!iterValue.equals(\"Four\")) {\n+                iter.remove();\n+            }\n+        }\n+\n+        assertTrue(\"List is empty\",list1.size() == 0);\n+        assertTrue(\"List is empty\",list2.size() == 1);\n+        assertTrue(\"List is empty\",list3.size() == 0);\n+    }\n+\n+    public void testFirstIteratorIsEmptyBug() {\n+        final List<String> empty = new ArrayList<String>();\n+        final List<String> notEmpty = new ArrayList<String>();\n+        notEmpty.add(\"A\");\n+        notEmpty.add(\"B\");\n+        notEmpty.add(\"C\");\n+        final LazyIteratorChain<String> chain = new LazyIteratorChain<String>() {\n+            @Override\n+            protected Iterator<String> nextIterator(int count) {\n+                switch (count) {\n+                case 1:\n+                    return empty.iterator();\n+                case 2:\n+                    return notEmpty.iterator();\n+                }\n+                return null;\n+            }\n+        };\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"A\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"B\",chain.next());\n+        assertTrue(\"should have next\",chain.hasNext());\n+        assertEquals(\"C\",chain.next());\n+        assertTrue(\"should not have next\",!chain.hasNext());\n+    }\n+    \n+    public void testEmptyChain() {\n+        final LazyIteratorChain<String> chain = makeEmptyIterator();\n+        assertEquals(false, chain.hasNext());\n+        try {\n+            chain.next();\n+            fail();\n+        } catch (final NoSuchElementException ex) {}\n+        try {\n+            chain.remove();\n+            fail();\n+        } catch (final IllegalStateException ex) {}\n+    }\n+\n+}", "timestamp": 1362061542, "metainfo": ""}