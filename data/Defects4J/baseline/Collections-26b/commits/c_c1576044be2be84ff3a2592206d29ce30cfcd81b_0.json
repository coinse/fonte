{"sha": "c1576044be2be84ff3a2592206d29ce30cfcd81b", "log": "Change MultiKeyMap to be a decorator   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n  */\n package org.apache.commons.collections.map;\n \n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.Map;\n-\n+import java.util.Set;\n+\n+import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.MapIterator;\n import org.apache.commons.collections.keyvalue.MultiKey;\n \n  * <code>remove</code> for individual keys which operate without extra object creation.\n  * <p>\n  * The additional methods are the main interface of this map.\n- * As such, you will not mormally hold this map in a variable of type <code>Map</code>.\n+ * As such, you will not normally hold this map in a variable of type <code>Map</code>.\n+ * <p>\n  * The normal map methods take in and return a {@link MultiKey}.\n+ * If you try to use <code>put()</code> with any other object type a\n+ * <code>ClassCastException</code> is thrown. If you try to use <code>null</code> as\n+ * the key in <code>put()</code> a <code>NullPointerException</code> is thrown.\n  * <p>\n- * As an example, consider a cache that uses a String airline code and a Locale\n- * to lookup the airline's name:\n+ * This map is implemented as a decorator of a <code>AbstractHashedMap</code> which\n+ * enables extra behaviour to be added easily.\n+ * <ul>\n+ * <li><code>MultiKeyMap.decorate(new LinkedMap())</code> creates an ordered map.\n+ * <li><code>MultiKeyMap.decorate(new LRUMap())</code> creates an least recently used map.\n+ * <li><code>MultiKeyMap.decorate(new ReferenceMap())</code> creates a garbage collector sensitive map.\n+ * </ul>\n+ * Note that <code>IdentityMap</code> and <code>ReferenceIdentityMap</code> are unsuitable\n+ * for use as the key comparison would work on the whole MultiKey, not the elements within.\n+ * <p>\n+ * As an example, consider a least recently used cache that uses a String airline code\n+ * and a Locale to lookup the airline's name:\n  * <pre>\n+ * private MultiKeyMap cache = MultiKeyMap.decorate(new LRUMap(50));\n+ * \n  * public String getAirlineName(String code, String locale) {\n- *   MultiKeyMap cache = getCache();\n  *   String name = (String) cache.get(code, locale);\n  *   if (name == null) {\n  *     name = getAirlineNameFromDB(code, locale);\n  * </pre>\n  *\n  * @since Commons Collections 3.1\n- * @version $Revision: 1.1 $ $Date: 2004/04/12 12:05:30 $\n+ * @version $Revision: 1.2 $ $Date: 2004/04/30 23:51:36 $\n  *\n  * @author Stephen Colebourne\n  */\n public class MultiKeyMap\n-        extends AbstractHashedMap implements Serializable, Cloneable {\n+        implements IterableMap, Serializable {\n \n     /** Serialisation version */\n     private static final long serialVersionUID = -1788199231038721040L;\n-    \n-    /**\n-     * Constructs a new empty map with default size and load factor.\n+\n+    /** The decorated map */\n+    protected final AbstractHashedMap map;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Decorates the specified map to add the MultiKeyMap API and fast query.\n+     * The map must not be null and must be empty.\n+     *\n+     * @param map  the map to decorate, not null\n+     * @throws IllegalArgumentException if the map is null or not empty\n+     */\n+    public static MultiKeyMap decorate(AbstractHashedMap map) {\n+        if (map == null) {\n+            throw new IllegalArgumentException(\"Map must not be null\");\n+        }\n+        if (map.size() > 0) {\n+            throw new IllegalArgumentException(\"Map must be empty\");\n+        }\n+        return new MultiKeyMap(map);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n+    /**\n+     * Constructs a new MultiKeyMap that decorates a <code>HashedMap</code>.\n      */\n     public MultiKeyMap() {\n-        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n-    }\n-\n-    /**\n-     * Constructs a new, empty map with the specified initial capacity. \n+        super();\n+        map = new HashedMap();\n+    }\n+\n+    /**\n+     * Constructor that decorates the specified map.\n+     * The map must not be null and should be empty or only contain valid keys.\n+     * This constructor performs no validation.\n      *\n-     * @param initialCapacity  the initial capacity\n-     * @throws IllegalArgumentException if the initial capacity is less than one\n-     */\n-    public MultiKeyMap(int initialCapacity) {\n-        super(initialCapacity);\n-    }\n-\n-    /**\n-     * Constructs a new, empty map with the specified initial capacity and\n-     * load factor. \n-     *\n-     * @param initialCapacity  the initial capacity\n-     * @param loadFactor  the load factor\n-     * @throws IllegalArgumentException if the initial capacity is less than one\n-     * @throws IllegalArgumentException if the load factor is less than zero\n-     */\n-    public MultiKeyMap(int initialCapacity, float loadFactor) {\n-        super(initialCapacity, loadFactor);\n-    }\n-\n-    /**\n-     * Constructor copying elements from another map.\n-     *\n-     * @param map  the map to copy\n-     * @throws NullPointerException if the map is null\n-     */\n-    public MultiKeyMap(Map map) {\n-        super(map);\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Clones the map without cloning the keys or values.\n-     *\n-     * @return a shallow clone\n-     */\n-    public Object clone() {\n-        return super.clone();\n-    }\n-    \n-    /**\n-     * Write the map out using a custom routine.\n-     */\n-    private void writeObject(ObjectOutputStream out) throws IOException {\n-        out.defaultWriteObject();\n-        doWriteObject(out);\n-    }\n-\n-    /**\n-     * Read the map in using a custom routine.\n-     */\n-    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n-        in.defaultReadObject();\n-        doReadObject(in);\n+     * @param map  the map to decorate\n+     */\n+    protected MultiKeyMap(AbstractHashedMap map) {\n+        super();\n+        this.map = map;\n     }\n \n     //-----------------------------------------------------------------------\n      */\n     public Object get(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 return true;\n      */\n     public Object put(Object key1, Object key2, Object value) {\n         int hashCode = hash(key1, key2);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 Object oldValue = entry.getValue();\n-                updateEntry(entry, value);\n+                map.updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n         \n-        addMapping(index, hashCode, new MultiKey(key1, key2), value);\n+        map.addMapping(index, hashCode, new MultiKey(key1, key2), value);\n         return null;\n     }\n \n      */\n     public Object remove(Object key1, Object key2) {\n         int hashCode = hash(key1, key2);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        HashEntry previous = null;\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n+        AbstractHashedMap.HashEntry previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n                 Object oldValue = entry.getValue();\n-                removeMapping(entry, index, previous);\n+                map.removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key2  the second key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2) {\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2) {\n         MultiKey multi = (MultiKey) entry.getKey();\n         return\n             multi.size() == 2 &&\n      */\n     public Object get(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 return true;\n      */\n     public Object put(Object key1, Object key2, Object key3, Object value) {\n         int hashCode = hash(key1, key2, key3);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 Object oldValue = entry.getValue();\n-                updateEntry(entry, value);\n+                map.updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n         \n-        addMapping(index, hashCode, new MultiKey(key1, key2, key3), value);\n+        map.addMapping(index, hashCode, new MultiKey(key1, key2, key3), value);\n         return null;\n     }\n \n      */\n     public Object remove(Object key1, Object key2, Object key3) {\n         int hashCode = hash(key1, key2, key3);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        HashEntry previous = null;\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n+        AbstractHashedMap.HashEntry previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n                 Object oldValue = entry.getValue();\n-                removeMapping(entry, index, previous);\n+                map.removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key3  the third key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2, Object key3) {\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2, Object key3) {\n         MultiKey multi = (MultiKey) entry.getKey();\n         return\n             multi.size() == 3 &&\n      */\n     public Object get(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 return true;\n      */\n     public Object put(Object key1, Object key2, Object key3, Object key4, Object value) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 Object oldValue = entry.getValue();\n-                updateEntry(entry, value);\n+                map.updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n         \n-        addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4), value);\n+        map.addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4), value);\n         return null;\n     }\n \n      */\n     public Object remove(Object key1, Object key2, Object key3, Object key4) {\n         int hashCode = hash(key1, key2, key3, key4);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        HashEntry previous = null;\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n+        AbstractHashedMap.HashEntry previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n                 Object oldValue = entry.getValue();\n-                removeMapping(entry, index, previous);\n+                map.removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key4  the fourth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2, Object key3, Object key4) {\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2, Object key3, Object key4) {\n         MultiKey multi = (MultiKey) entry.getKey();\n         return\n             multi.size() == 4 &&\n      */\n     public Object get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 return entry.getValue();\n      */\n     public boolean containsKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        AbstractHashedMap.HashEntry entry = map.data[map.hashIndex(hashCode, map.data.length)];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 return true;\n      */\n     public Object put(Object key1, Object key2, Object key3, Object key4, Object key5, Object value) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 Object oldValue = entry.getValue();\n-                updateEntry(entry, value);\n+                map.updateEntry(entry, value);\n                 return oldValue;\n             }\n             entry = entry.next;\n         }\n         \n-        addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4, key5), value);\n+        map.addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4, key5), value);\n         return null;\n     }\n \n      */\n     public Object remove(Object key1, Object key2, Object key3, Object key4, Object key5) {\n         int hashCode = hash(key1, key2, key3, key4, key5);\n-        int index = hashIndex(hashCode, data.length);\n-        HashEntry entry = data[index];\n-        HashEntry previous = null;\n+        int index = map.hashIndex(hashCode, map.data.length);\n+        AbstractHashedMap.HashEntry entry = map.data[index];\n+        AbstractHashedMap.HashEntry previous = null;\n         while (entry != null) {\n             if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n                 Object oldValue = entry.getValue();\n-                removeMapping(entry, index, previous);\n+                map.removeMapping(entry, index, previous);\n                 return oldValue;\n             }\n             previous = entry;\n      * @param key5  the fifth key\n      * @return true if the key matches\n      */\n-    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2, Object key3, Object key4, Object key5) {\n+    protected boolean isEqualKey(AbstractHashedMap.HashEntry entry, Object key1, Object key2, Object key3, Object key4, Object key5) {\n         MultiKey multi = (MultiKey) entry.getKey();\n         return\n             multi.size() == 5 &&\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Override superclass to ensure that input keys are valid MultiKey objects.\n+     * Check to ensure that input keys are valid MultiKey objects.\n      * \n      * @param key  the key to check\n-     * @return the validated key\n-     */\n-    protected Object convertKey(Object key) {\n+     */\n+    protected void checkKey(Object key) {\n         if (key == null) {\n             throw new NullPointerException(\"Key must not be null\");\n         }\n         if (key instanceof MultiKey == false) {\n             throw new ClassCastException(\"Key must be a MultiKey\");\n         }\n-        return key;\n+    }\n+\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    public Object clone() {\n+        return new MultiKeyMap((AbstractHashedMap) map.clone());\n+    }\n+\n+    /**\n+     * Puts the key and value into the map, where the key must be a non-null\n+     * MultiKey object.\n+     * \n+     * @param key  the non-null MultiKey object\n+     * @param value  the value to store\n+     * @return the previous value for the key\n+     * @throws NullPointerException if the key is null\n+     * @throws ClassCastException if the key is not a MultiKey\n+     */\n+    public Object put(Object key, Object value) {\n+        checkKey(key);\n+        return map.put(key, value);\n+    }\n+\n+    /**\n+     * Puts all the keys and values into this map.\n+     * Each key must be non-null and a MultiKey object.\n+     * \n+     * @param key  the non-null MultiKey object\n+     * @param value  the value to store\n+     * @return the previous value for the key\n+     * @throws NullPointerException if the mapToCopy or any key within is null\n+     * @throws ClassCastException if any key is not a MultiKey\n+     */\n+    public void putAll(Map mapToCopy) {\n+        for (Iterator it = mapToCopy.keySet().iterator(); it.hasNext();) {\n+            Object key = it.next();\n+            checkKey(key);\n+        }\n+        map.putAll(mapToCopy);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public MapIterator mapIterator() {\n+        return map.mapIterator();\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return map.containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return map.containsValue(value);\n+    }\n+\n+    public Object get(Object key) {\n+        return map.get(key);\n+    }\n+\n+    public Object remove(Object key) {\n+        return map.remove(key);\n+    }\n+\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    public Set keySet() {\n+        return map.keySet();\n+    }\n+\n+    public Collection values() {\n+        return map.values();\n+    }\n+\n+    public Set entrySet() {\n+        return map.entrySet();\n+    }\n+\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        return map.equals(obj);\n+    }\n+\n+    public int hashCode() {\n+        return map.hashCode();\n+    }\n+\n+    public String toString() {\n+        return map.toString();\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n+++ b/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n /**\n  * JUnit tests.\n  * \n- * @version $Revision: 1.1 $ $Date: 2004/04/12 12:05:30 $\n+ * @version $Revision: 1.2 $ $Date: 2004/04/30 23:51:36 $\n  * \n  * @author Stephen Colebourne\n  */\n     }\n \n     //-----------------------------------------------------------------------\n+    public void testNullHandling() {\n+        resetFull();\n+        assertEquals(null, map.get(null));\n+        assertEquals(false, map.containsKey(null));\n+        assertEquals(false, map.containsValue(null));\n+        assertEquals(null, map.remove(null));\n+        assertEquals(false, map.entrySet().contains(null));\n+        assertEquals(false, map.keySet().contains(null));\n+        assertEquals(false, map.values().contains(null));\n+        try {\n+            map.put(null, null);\n+            fail();\n+        } catch (NullPointerException ex) {}\n+        assertEquals(null, map.put(new MultiKey(null, null), null));\n+        try {\n+            map.put(null, new Object());\n+            fail();\n+        } catch (NullPointerException ex) {}\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public void testMultiKeyGet() {\n         resetFull();\n         MultiKeyMap multimap = (MultiKeyMap) map;\n         assertSame(map.get(new MultiKey(I1, I2)), cloned.get(new MultiKey(I1, I2)));\n     }\n \n+    //-----------------------------------------------------------------------\n+    public void testLRUMultiKeyMap() {\n+        MultiKeyMap map = MultiKeyMap.decorate(new LRUMap(2));\n+        map.put(I1, I2, \"1-2\");\n+        map.put(I1, I3, \"1-3\");\n+        assertEquals(2, map.size());\n+        map.put(I1, I4, \"1-4\");\n+        assertEquals(2, map.size());\n+        assertEquals(true, map.containsKey(I1, I3));\n+        assertEquals(true, map.containsKey(I1, I4));\n+        assertEquals(false, map.containsKey(I1, I2));\n+        \n+        MultiKeyMap cloned = (MultiKeyMap) map.clone();\n+        assertEquals(2, map.size());\n+        assertEquals(true, cloned.containsKey(I1, I3));\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(false, cloned.containsKey(I1, I2));\n+        cloned.put(I1, I5, \"1-5\");\n+        assertEquals(2, cloned.size());\n+        assertEquals(true, cloned.containsKey(I1, I4));\n+        assertEquals(true, cloned.containsKey(I1, I5));\n+    }\n+\n+    //-----------------------------------------------------------------------\n     public String getCompatibilityVersion() {\n         return \"3.1\";\n     }", "timestamp": 1083369096, "metainfo": ""}