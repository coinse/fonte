{"sha": "9fa82c7fb4272bff2bcdc8492bee5f3230891ed0", "log": "[COLLECTIONS-322] Added new NodeListIterator to iterate over a dom NodeList, thanks to Thomas Vahrst.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/IteratorUtils.java\n import org.apache.commons.collections.iterators.ListIteratorWrapper;\n import org.apache.commons.collections.iterators.LoopingIterator;\n import org.apache.commons.collections.iterators.LoopingListIterator;\n+import org.apache.commons.collections.iterators.NodeListIterator;\n import org.apache.commons.collections.iterators.ObjectArrayIterator;\n import org.apache.commons.collections.iterators.ObjectArrayListIterator;\n import org.apache.commons.collections.iterators.ObjectGraphIterator;\n import org.apache.commons.collections.iterators.UnmodifiableIterator;\n import org.apache.commons.collections.iterators.UnmodifiableListIterator;\n import org.apache.commons.collections.iterators.UnmodifiableMapIterator;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n \n /**\n  * Provides static utility methods and decorators for {@link Iterator}\n         return new LoopingListIterator<E>(list);\n     }\n \n+    // org.w3c.dom.NodeList iterators\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an {@link Iterator} that wraps the specified {@link NodeList}.\n+     * The returned {@link Iterator} can be used for a single iteration.\n+     *\n+     * @param nodeList the node list to use, not null\n+     * @return a new, single use {@link Iterator}\n+     * @throws NullPointerException if nodeList is null\n+     */\n+    public static NodeListIterator nodeListIterator(final NodeList nodeList) {\n+        if (nodeList == null) {\n+            throw new NullPointerException(\"NodeList must not be null\");\n+        }\n+        return new NodeListIterator(nodeList);\n+    }\n+\n+    /**\n+     * Gets an {@link Iterator} that wraps the specified node's childNodes.\n+     * The returned {@link Iterator} can be used for a single iteration.\n+     * <p>\n+     * Convenience method, allows easy iteration over NodeLists:\n+     * <pre>\n+     *   for(Node childNode : IteratorUtils.asIterable(node)){\n+     *     ...\n+     *   }\n+     * </pre>\n+     *\n+     * @param node the node to use, not null\n+     * @return a new, single use {@link Iterator}\n+     * @throws NullPointerException if node is null\n+     */\n+    public static NodeListIterator nodeListIterator(final Node node) {\n+        if (node == null) {\n+            throw new NullPointerException(\"Node must not be null\");\n+        }\n+        return new NodeListIterator(node);\n+    }\n+\n     // Views\n     //-----------------------------------------------------------------------\n     /**\n         return new IteratorIterable<E>(iterator, false);\n     }\n \n+    \n     /**\n      * Gets an iterable that wraps an iterator.  The returned iterable can be\n      * used for multiple iterations.\n      * <li>array - iterator over array returned\n      * <li>object with iterator() public method accessed by reflection\n      * <li>object - singleton iterator\n+     * <li>NodeList - iterator over the list\n+     * <li>Node - iterator over the child nodes\n      * </ul>\n      *\n      * @param obj  the object to convert to an iterator\n         }\n         if (obj instanceof Map) {\n             return ((Map<?, ?>) obj).values().iterator();\n+        }\n+        if (obj instanceof NodeList) {\n+            return new NodeListIterator((NodeList) obj);\n+        }\n+        if (obj instanceof Node) {\n+            return new NodeListIterator((Node) obj);\n         }\n         if (obj instanceof Dictionary) {\n             return new EnumerationIterator<Object>(((Dictionary<?, ?>) obj).elements());\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/iterators/NodeListIterator.java\n+/*\n+ * Copyright 2013 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * An {@link Iterator} over a {@link NodeList}.\n+ * <p>\n+ * This iterator does not support {@link #remove()} as a {@link NodeList} does not support\n+ * removal of items.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ * @see org.w3c.NodeList\n+ */\n+public class NodeListIterator implements Iterator<Node> {\n+\n+    /** the original NodeList instance */\n+    private NodeList nodeList;\n+    /** The current iterator index */\n+    protected int index = 0;\n+\n+    /**\n+     * Convenience constructor, which creates a new NodeListIterator from \n+     * the specified node's childNodes.\n+     *\n+     * @param node Node, who's child nodes are wrapped by this class. Must not be null\n+     * @throws IllegalArgumentException if node is null\n+     */\n+    public NodeListIterator(Node node) {\n+        if (node == null) {\n+            throw new IllegalArgumentException(\"node must not be null!\");\n+        }\n+        this.nodeList = node.getChildNodes();\n+    }\n+\n+    /**\n+     * Constructor, that creates a new NodeListIterator from the specified\n+     * <code>org.w3c.NodeList</code>\n+     *\n+     * @param nodeList node list, which is wrapped by this class. Must not be null\n+     * @throws IllegalArgumentException if nodeList is null\n+     */\n+    public NodeListIterator(NodeList nodeList) {\n+        if (nodeList == null) {\n+            throw new IllegalArgumentException(\"nodeList must not be null!\");\n+        }\n+        this.nodeList = nodeList;\n+    }\n+    \n+    public boolean hasNext() {\n+        return nodeList == null ? false : index < nodeList.getLength();\n+    }\n+\n+    public Node next() {\n+        if (nodeList != null && index < nodeList.getLength()) {\n+            return nodeList.item(index++);\n+        } else {\n+            throw new NoSuchElementException(\"underlying nodeList has no more elements\");\n+        }\n+    }\n+\n+    /**\n+     * Throws {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException always\n+     */\n+    public void remove() {\n+        throw new UnsupportedOperationException(\"remove() method not supported for an NodeListIterator.\");\n+    }\n+}\n--- a/src/test/java/org/apache/commons/collections/IteratorUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections/IteratorUtilsTest.java\n import org.apache.commons.collections.iterators.EmptyMapIterator;\n import org.apache.commons.collections.iterators.EmptyOrderedIterator;\n import org.apache.commons.collections.iterators.EmptyOrderedMapIterator;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n \n /**\n  * Tests for IteratorUtils.\n  *\n- * @version $Revision$\n- *\n- * @author Unknown\n+ * @version $Id$\n  */\n public class IteratorUtilsTest extends BulkTest {\n \n             fail(\"should not be able to iterate twice\");\n         }\n     }\n-\n+    \n     public void testAsIterableNull() {\n         try {\n             IteratorUtils.asIterable(null);\n         }\n     }\n \n+    /**\n+     * Tests method nodeListIterator(NodeList)\n+     */\n+    public void testNodeListIterator() {\n+        Node[] nodes = createNodes();\n+        NodeList nodeList = createNodeList(nodes);\n+        \n+        final Iterator<Node> iterator = IteratorUtils.nodeListIterator(nodeList);\n+        int expectedNodeIndex = 0;\n+        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n+            assertEquals(nodes[expectedNodeIndex], actual);\n+            ++expectedNodeIndex;\n+        }\n+\n+        // insure iteration occurred\n+        assertTrue(expectedNodeIndex > 0);\n+\n+        // single use iterator\n+        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+    /**\n+     * Tests method nodeListIterator(Node)\n+     */\n+    public void testNodeIterator() {\n+        Node[] nodes = createNodes();\n+        NodeList nodeList = createNodeList(nodes);\n+        Node parentNode = createMock(Node.class);\n+        expect(parentNode.getChildNodes()).andStubReturn(nodeList);\n+        replay(parentNode);\n+        \n+        final Iterator<Node> iterator = IteratorUtils.nodeListIterator(parentNode);\n+        int expectedNodeIndex = 0;\n+        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n+            assertEquals(nodes[expectedNodeIndex], actual);\n+            ++expectedNodeIndex;\n+        }\n+\n+        // insure iteration occurred\n+        assertTrue(expectedNodeIndex > 0);\n+\n+        // single use iterator\n+        for (final Node actual : IteratorUtils.asIterable(iterator)) {\n+            fail(\"should not be able to iterate twice\");\n+        }\n+    }\n+    \n+    /**\n+     * creates an array of four Node instances, mocked by EasyMock.\n+     * @return \n+     */\n+    private Node[] createNodes() {\n+        Node node1 = createMock(Node.class);\n+        Node node2 = createMock(Node.class);\n+        Node node3 = createMock(Node.class);\n+        Node node4 = createMock(Node.class);\n+        replay(node1);\n+        replay(node2);\n+        replay(node3);\n+        replay(node4);\n+\n+        return new Node[]{node1, node2, node3, node4};\n }\n+\n+    /**\n+     * Creates a NodeList containing the specified nodes.\n+     */\n+    private NodeList createNodeList(final Node[] nodes) {\n+        return new NodeList() {\n+            public Node item(int index) {\n+                return nodes[index];\n+            }\n+            public int getLength() {\n+                return nodes.length;\n+            }\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/iterators/NodeListIteratorTest.java\n+/*\n+ * Copyright 2013 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.iterators;\n+\n+import java.util.Iterator;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+\n+/**\n+ * Tests the NodeListIterator.\n+ */\n+public class NodeListIteratorTest extends AbstractIteratorTest<Node> {\n+\n+    // Node array to be filled with mocked Node instances \n+    private Node[] nodes;\n+    \n+    // NodeListIterator supports two constructors. This flag allows to\n+    // control, which constructor to use in makeObject() and makeEmtpyIterator\n+    private boolean createIteratorWithStandardConstr = true;\n+    \n+    /**\n+     * Constructor \n+     * @param testName \n+     */\n+    public NodeListIteratorTest(final String testName) {\n+        super(testName);\n+    }\n+    \n+    @Override\n+    protected void setUp() throws Exception {\n+        super.setUp(); \n+\n+        // Default: use standard constr.\n+        createIteratorWithStandardConstr = true;\n+        \n+        \n+        // create mocked Node Instances and fill Node[] to be used by test cases\n+        Node node1 = createMock(Element.class);\n+        Node node2 = createMock(Element.class);\n+        Node node3 = createMock(Text.class);\n+        Node node4 = createMock(Element.class);\n+        nodes = new Node[] {node1, node2, node3, node4};\n+        \n+        replay(node1);\n+        replay(node2);\n+        replay(node3);\n+        replay(node4);\n+    }\n+\n+    @Override\n+    public Iterator<Node> makeEmptyIterator() {\n+        NodeList emptyNodeList = new NodeList() {\n+            public Node item(int index) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+            public int getLength() {\n+                return 0;\n+            }\n+        };\n+        \n+        if (createIteratorWithStandardConstr) {\n+            return new NodeListIterator(emptyNodeList);\n+        } else {\n+            Node parentNode = createMock(Node.class);\n+            expect(parentNode.getChildNodes()).andStubReturn(emptyNodeList);\n+            replay(parentNode);\n+            \n+            return new NodeListIterator(parentNode);\n+        }\n+    }\n+\n+    @Override\n+    public Iterator<Node> makeObject() {\n+        NodeList nodeList = new NodeList() {\n+            public Node item(int index) {\n+                return nodes[index];\n+            }\n+            public int getLength() {\n+                return nodes.length;\n+            }\n+        };\n+\n+        return new NodeListIterator(nodeList);\n+    }\n+\n+    @Override\n+    public boolean supportsRemove() {\n+        return false;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testNullConstructor(){\n+        try{\n+            @SuppressWarnings(\"unused\")\n+            NodeListIterator iter = new NodeListIterator((Node) null);\n+            fail(\"IllegalArgumentException expected!\");\n+        }catch(IllegalArgumentException e){\n+            // expected.\n+        }\n+    }\n+\n+    /**\n+     * tests the convenience Constructor with parameter type org.w3c.Node\n+     */\n+    public void testEmptyIteratorWithNodeConstructor(){\n+        createIteratorWithStandardConstr = false;\n+        testEmptyIterator();\n+    }\n+\n+    /**\n+     * tests the convenience Constructor with parameter type org.w3c.Node\n+     */\n+    public void testFullIteratorWithNodeConstructor(){\n+        createIteratorWithStandardConstr = false;\n+        testFullIterator();\n+    }\n+}", "timestamp": 1359231283, "metainfo": ""}