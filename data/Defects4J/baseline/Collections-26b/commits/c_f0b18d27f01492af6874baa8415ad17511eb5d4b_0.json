{"sha": "f0b18d27f01492af6874baa8415ad17511eb5d4b", "log": "Statement unnecessarily nested within else clause.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/list/TreeList.java\n+++ b/src/main/java/org/apache/commons/collections4/list/TreeList.java\n                     s = sAncestor.balance();\n                 }\n                 return s;\n-            } else {\n-                // CASE 2: This tree is taller. This is symmetric to case 1.\n-                // We merge otherTree into this tree by finding a subtree s of this\n-                // tree that is of similar height to otherTree and replacing it\n-                // with a new subtree whose root is otherTreeMin and whose\n-                // children are otherTree and s.\n-\n-                otherTree = otherTree.removeMin();\n-\n-                final ArrayStack<AVLNode<E>> sAncestors = new ArrayStack<AVLNode<E>>();\n-                AVLNode<E> s = this;\n-                int sAbsolutePosition = s.relativePosition;\n-                int sParentAbsolutePosition = 0;\n-                while (s != null && s.height > getHeight(otherTree)) {\n-                    sParentAbsolutePosition = sAbsolutePosition;\n-                    sAncestors.push(s);\n-                    s = s.right;\n-                    if (s != null) {\n-                        sAbsolutePosition += s.relativePosition;\n-                    }\n-                }\n-\n-                otherTreeMin.setRight(otherTree, null);\n-                otherTreeMin.setLeft(s, maxNode);\n-                if (otherTree != null) {\n-                    otherTree.min().setLeft(null, otherTreeMin);\n-                    otherTree.relativePosition++;\n-                }\n+            }\n+            otherTree = otherTree.removeMin();\n+\n+            final ArrayStack<AVLNode<E>> sAncestors = new ArrayStack<AVLNode<E>>();\n+            AVLNode<E> s = this;\n+            int sAbsolutePosition = s.relativePosition;\n+            int sParentAbsolutePosition = 0;\n+            while (s != null && s.height > getHeight(otherTree)) {\n+                sParentAbsolutePosition = sAbsolutePosition;\n+                sAncestors.push(s);\n+                s = s.right;\n                 if (s != null) {\n-                    s.max().setRight(null, otherTreeMin);\n-                    s.relativePosition = sAbsolutePosition - currentSize;\n-                }\n-                otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n-\n-                s = otherTreeMin;\n-                while (!sAncestors.isEmpty()) {\n-                    final AVLNode<E> sAncestor = sAncestors.pop();\n-                    sAncestor.setRight(s, null);\n-                    s = sAncestor.balance();\n-                }\n-                return s;\n-            }\n+                    sAbsolutePosition += s.relativePosition;\n+                }\n+            }\n+\n+            otherTreeMin.setRight(otherTree, null);\n+            otherTreeMin.setLeft(s, maxNode);\n+            if (otherTree != null) {\n+                otherTree.min().setLeft(null, otherTreeMin);\n+                otherTree.relativePosition++;\n+            }\n+            if (s != null) {\n+                s.max().setRight(null, otherTreeMin);\n+                s.relativePosition = sAbsolutePosition - currentSize;\n+            }\n+            otherTreeMin.relativePosition = currentSize - sParentAbsolutePosition;\n+\n+            s = otherTreeMin;\n+            while (!sAncestors.isEmpty()) {\n+                final AVLNode<E> sAncestor = sAncestors.pop();\n+                sAncestor.setRight(s, null);\n+                s = sAncestor.balance();\n+            }\n+            return s;\n         }\n \n //      private void checkFaedelung() {", "timestamp": 1414671886, "metainfo": ""}