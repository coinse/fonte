{"sha": "8e3968cd11c98e0c8db30b225164474d00d2b32e", "log": "Bug 37472: Implement a TimeoutBuffer class  ", "commit": "\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n import org.apache.commons.collections.buffer.TransformedBuffer;\n import org.apache.commons.collections.buffer.TypedBuffer;\n import org.apache.commons.collections.buffer.UnmodifiableBuffer;\n+import org.apache.commons.collections.buffer.TimeoutBuffer;\n \n /**\n  * Provides utility methods and decorators for {@link Buffer} instances.\n      * An empty unmodifiable buffer.\n      */\n     public static final Buffer EMPTY_BUFFER = UnmodifiableBuffer.decorate(new ArrayStack(1));\n-    \n+\n     /**\n      * <code>BufferUtils</code> should not normally be instantiated.\n      */\n         return BlockingBuffer.decorate(buffer);\n     }\n \n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#get()} and {@link Buffer#remove()} operations until\n+     * <code>timeout</code> expires.  If the buffer is empty, then the\n+     * {@link Buffer#get()} and {@link Buffer#remove()} operations will block\n+     * until new elements are added to the buffer, rather than immediately throwing a\n+     * <code>BufferUnderflowException</code>.\n+     *\n+     * @param buffer  the buffer to synchronize, must not be null\n+     * @return a blocking buffer backed by that buffer\n+     * @throws IllegalArgumentException  if the Buffer is null\n+     */\n+    public static Buffer timeoutBuffer(Buffer buffer, long timeout) {\n+        return TimeoutBuffer.decorate(buffer, timeout);\n+    }\n+    \n     /**\n      * Returns an unmodifiable buffer backed by the given buffer.\n      *\n     public static Buffer transformedBuffer(Buffer buffer, Transformer transformer) {\n         return TransformedBuffer.decorate(buffer, transformer);\n     }\n-    \n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/TimeoutBuffer.java\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import org.apache.commons.collections.Buffer;\n+\n+/**\n+ * Decorates another <code>Buffer</code> to make {@link #get()} and\n+ * {@link #remove()} block (until timeout expires) when the <code>Buffer</code> is empty.\n+ * <p>\n+ * If either <code>get</code> or <code>remove</code> is called on an empty\n+ * <code>Buffer</code>, the calling thread waits (until timeout expires) for notification that\n+ * an <code>add</code> or <code>addAll</code> operation has completed.\n+ * <p>\n+ * When one or more entries are added to an empty <code>Buffer</code>,\n+ * all threads blocked in <code>get</code> or <code>remove</code> are notified.\n+ * There is no guarantee that concurrent blocked <code>get</code> or\n+ * <code>remove</code> requests will be \"unblocked\" and receive data in the\n+ * order that they arrive.\n+ * <p>\n+ * This class is Serializable from Commons Collections 3.2.\n+ *\n+ * @author James Carman\n+ * @version $Revision$ $Date$\n+ * @since Commons Collections 3.2\n+ */\n+public class TimeoutBuffer extends BlockingBuffer {\n+//----------------------------------------------------------------------------------------------------------------------\n+// Fields\n+//----------------------------------------------------------------------------------------------------------------------\n+    private static final long serialVersionUID = 1719328905017860541L;\n+\n+    private final long timeout;\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// Static Methods\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public static Buffer decorate( Buffer buffer, long timeout ) {\n+        return new TimeoutBuffer( buffer, timeout );\n+    }\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// Constructors\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public TimeoutBuffer( Buffer buffer, long timeout ) {\n+        super( buffer );\n+        this.timeout = timeout;\n+    }\n+\n+    public long getTimeout() {\n+        return timeout;\n+    }\n+//----------------------------------------------------------------------------------------------------------------------\n+// Buffer Implementation\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public Object get() {\n+        return get( timeout );\n+    }\n+\n+    public Object remove() {\n+        return remove( timeout );\n+    }\n+\n+    public boolean equals( Object o ) {\n+        if( this == o ) {\n+            return true;\n+        }\n+        if( o == null || getClass() != o.getClass() ) {\n+            return false;\n+        }\n+        if( !super.equals( o ) ) {\n+            return false;\n+        }\n+        final TimeoutBuffer that = ( TimeoutBuffer ) o;\n+        if( timeout != that.timeout ) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    public int hashCode() {\n+        int result = super.hashCode();\n+        result = 29 * result + ( int ) ( timeout ^ ( timeout >>> 32 ) );\n+        return result;\n+    }\n+}\n+\n--- a/src/test/org/apache/commons/collections/buffer/TestAll.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestAll.java\n         suite.addTest(TestSynchronizedBuffer.suite());\n         suite.addTest(TestTransformedBuffer.suite());\n         suite.addTest(TestUnmodifiableBuffer.suite());\n-        \n+        suite.addTest(TestTimeoutBuffer.suite());\n         return suite;\n     }\n         \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestTimeoutBuffer.java\n+/*\n+ *  Copyright 2001-2005 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+import org.apache.commons.collections.AbstractTestObject;\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BufferUtils;\n+\n+/**\n+ * @author James Carman\n+ * @version 1.0\n+ */\n+public class TestTimeoutBuffer extends AbstractTestObject {\n+//----------------------------------------------------------------------------------------------------------------------\n+// Fields\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    private static final int FULL_SIZE = 100;\n+\n+    private static final int TIMEOUT = 100;\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// Static Methods\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public static Test suite() {\n+        return new TestSuite( TestTimeoutBuffer.class );\n+    }\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// Constructors\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public TestTimeoutBuffer( String testName ) {\n+        super( testName );\n+    }\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// Other Methods\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public String getCompatibilityVersion() {\n+        return \"3.2\";\n+    }\n+\n+    public boolean isEqualsCheckable() {\n+        return false;\n+    }\n+\n+    public Object makeObject() {\n+        return BufferUtils.timeoutBuffer( new ArrayStack(), TIMEOUT );\n+    }\n+\n+    public void testEmptySerialization() {\n+        try {\n+            final TimeoutBuffer b = ( TimeoutBuffer ) readExternalFormFromDisk(\n+                    getCanonicalEmptyCollectionName( makeObject() ) );\n+            assertTrue( b.isEmpty() );\n+        }\n+        catch( Exception e ) {\n+            fail( \"Could not read object from disk.\" );\n+        }\n+    }\n+\n+    public void testFullSerialization() {\n+        try {\n+            final TimeoutBuffer b = ( TimeoutBuffer ) readExternalFormFromDisk(\n+                    getCanonicalFullCollectionName( makeObject() ) );\n+            assertEquals( FULL_SIZE, b.size() );\n+        }\n+        catch( Exception e ) {\n+            fail( \"Could not read object from disk.\" );\n+        }\n+    }\n+\n+    public void testSuccessfulWaitOnGet() {\n+        Buffer b = ( Buffer ) makeObject();\n+        executeAsynchronously( new Getter( b ) );\n+        executeAsynchronously( new Adder( b, \"Hello\" ) );\n+    }\n+\n+    private static void executeAsynchronously( Runnable r ) {\n+        new Thread( r ).start();\n+    }\n+\n+    public void testSuccessfulWaitOnRemove() {\n+        Buffer b = ( Buffer ) makeObject();\n+        executeAsynchronously( new Remover( b ) );\n+        executeAsynchronously( new Adder( b, \"Hello\" ) );\n+    }\n+\n+    public void testTimeoutOnGet() {\n+        final Buffer buffer = makeBuffer();\n+        try {\n+            Getter remover = new Getter( buffer );\n+            executeAsynchronously( remover );\n+            executeAsynchronously( new Adder( buffer, \"Howdy\" ), TIMEOUT * 2 );\n+            assertFalse( remover.isSuccesful() );\n+        }\n+        catch( BufferUnderflowException e ) {\n+        }\n+    }\n+\n+    private TimeoutBuffer makeBuffer() {\n+        return ( TimeoutBuffer ) makeObject();\n+    }\n+\n+    private static void executeAsynchronously( Runnable r, long delay ) {\n+        new Thread( new DelayedRunnable( r, delay ) ).start();\n+    }\n+\n+    public void testTimeoutOnRemove() {\n+        final Buffer buffer = makeBuffer();\n+        try {\n+            Remover remover = new Remover( buffer );\n+            executeAsynchronously( remover );\n+            executeAsynchronously( new Adder( buffer, \"Howdy\" ), TIMEOUT * 2 );\n+            assertFalse( remover.isSuccesful() );\n+        }\n+        catch( BufferUnderflowException e ) {\n+        }\n+    }\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// Inner Classes\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    private static class DelayedRunnable implements Runnable {\n+        private final Runnable r;\n+\n+        private final long delay;\n+        public DelayedRunnable( Runnable r, long delay ) {\n+            this.r = r;\n+            this.delay = delay;\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep( delay );\n+            }\n+            catch( InterruptedException e ) {\n+                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.\n+            }\n+            r.run();\n+        }\n+    }\n+\n+    private static class Adder implements Runnable {\n+        private final Buffer b;\n+\n+        private final Object o;\n+        public Adder( Buffer b, Object o ) {\n+            this.b = b;\n+            this.o = o;\n+        }\n+\n+        public void run() {\n+            b.add( o );\n+        }\n+    }\n+\n+    private static class Remover extends BufferReader {\n+        public Remover( Buffer b ) {\n+            super( b );\n+        }\n+\n+        protected void performOperation() {\n+            b.remove();\n+        }\n+    }\n+\n+    private static abstract class BufferReader implements Runnable {\n+\n+        protected final Buffer b;\n+        private Boolean succesful;\n+\n+        protected BufferReader( Buffer b ) {\n+            this.b = b;\n+        }\n+\n+        protected abstract void performOperation();\n+\n+        public final synchronized void run() {\n+            try {\n+                performOperation();\n+                succesful = Boolean.TRUE;\n+            }\n+            catch( BufferUnderflowException e ) {\n+                succesful = Boolean.FALSE;\n+            }\n+            notifyAll();\n+        }\n+\n+        public synchronized boolean isSuccesful() {\n+            while( succesful == null ) {\n+                try {\n+                    wait();\n+                }\n+                catch( InterruptedException e ) {\n+                }\n+            }\n+            return succesful.booleanValue();\n+        }\n+    }\n+\n+    private static class Getter extends BufferReader {\n+        public Getter( Buffer b ) {\n+            super( b );\n+        }\n+\n+        protected void performOperation() {\n+            b.get();\n+        }\n+    }\n+\n+//----------------------------------------------------------------------------------------------------------------------\n+// main() method\n+//----------------------------------------------------------------------------------------------------------------------\n+\n+    public static void main( String args[] ) {\n+        String[] testCaseName = {TestTimeoutBuffer.class.getName()};\n+        junit.textui.TestRunner.main( testCaseName );\n+    }\n+}\n+", "timestamp": 1131741553, "metainfo": ""}