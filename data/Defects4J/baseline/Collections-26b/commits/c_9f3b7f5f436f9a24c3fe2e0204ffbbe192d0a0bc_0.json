{"sha": "9f3b7f5f436f9a24c3fe2e0204ffbbe192d0a0bc", "log": "Add Buffer implementations, utilities, and tests.  BoundedFifoBuffer is renamed from Avalon's FixedSizeBuffer. Made it extend AbstractCollection, provided an iterator. Removed \"final\" from class and method declarations. Added javadoc.  UnboundedFifoBuffer is renamed from Avalon's VariableSizeBuffer. Made it extend AbstractCollection, provided an iterator. Removed \"final\" from class and method delcarations. Added javadoc.  BufferUtils provides Buffer decorators for synchronized, unmodifiable, and predicated Buffers.   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.collections;\n+\n+\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * The BoundedFifoBuffer is a <strong>very</strong> efficient implementation of\n+ * Buffer that does not alter the size of the buffer at runtime.<P>\n+ *\n+ * The removal order of a <Code>BoundedFifoBuffer</Code> is based on the \n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.<P>\n+ *\n+ * The {@link add(Object}, {@link remove()} and {@link get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ *\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <COde>BoundedFifoBuffer</Code>:\n+ *\n+ * <Pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifoBuffer());\n+ * </Pre>\n+ *\n+ * @author <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n+ * @author Paul Jack\n+ * @version $Id: BoundedFifoBuffer.java,v 1.1 2002/07/03 01:57:08 mas Exp $\n+ */\n+public class BoundedFifoBuffer extends AbstractCollection implements Buffer\n+{\n+    private final Object[] m_elements;\n+    private int m_start = 0;\n+    private int m_end = 0;\n+    private boolean m_full = false;\n+\n+\n+    /**\n+     *  Constructs a new <Code>BoundedFifoBuffer</Code> big enough to hold\n+     *  the specified number of elements.\n+     *\n+     *  @param size  the maximum number of elements for this fifo\n+     */\n+    public BoundedFifoBuffer( int size )\n+    {\n+        m_elements = new Object[ size ];\n+    }\n+\n+\n+    /**\n+     *  Constructs a new <Code>BoundedFifoBuffer</Code> big enough to hold\n+     *  32 elements.\n+     */\n+    public BoundedFifoBuffer()\n+    {\n+        this( 32 );\n+    }\n+\n+\n+    /**\n+     *  Constructs a new <Code>BoundedFifoBuffer</Code> big enough to hold all\n+     *  of the elements in the specified collection.  That collection's\n+     *  elements will also be added to the fifo.\n+     *\n+     *  @param c  the collection whose elements to add\n+     */\n+    public BoundedFifoBuffer(Collection c) {\n+        this(c.size());\n+        addAll(c);\n+    }\n+\n+\n+    /**\n+     *  Returns this fifo's size.\n+     *\n+     *  @return this fifo's size\n+     */\n+    public int size()\n+    {\n+        int size = 0;\n+\n+        if( m_end < m_start )\n+        {\n+            size = m_elements.length - m_start + m_end;\n+        }\n+        else if( m_end == m_start )\n+        {\n+            size = ( m_full ? m_elements.length : 0 );\n+        }\n+        else\n+        {\n+            size = m_end - m_start;\n+        }\n+\n+        return size;\n+    }\n+\n+\n+    /**\n+     *  Returns true if this fifo is empty; false otherwise.\n+     *\n+     *  @return true if this fifo is empty\n+     */\n+    public boolean isEmpty()\n+    {\n+        return size() == 0;\n+    }\n+\n+\n+    /**\n+     *  Adds the given element to this fifo.\n+     *\n+     *  @param element  the element to add\n+     *  @return true, always\n+     *  @throws NullPointerException if the given element is null\n+     *  @throws BufferOverflowException if this fifo is full\n+     */\n+    public boolean add( Object element )\n+    {\n+        if( null == element )\n+        {\n+            throw new NullPointerException( \"Attempted to add null object to buffer\" );\n+        }\n+\n+        if( m_full )\n+        {\n+            throw new BufferOverflowException( \"The buffer cannot hold more than \"\n+                                               + m_elements.length + \" objects.\" );\n+        }\n+\n+        m_elements[ m_end++ ] = element;\n+\n+        if( m_end >= m_elements.length )\n+        {\n+            m_end = 0;\n+        }\n+\n+        if( m_end == m_start )\n+        {\n+            m_full = true;\n+        }\n+\n+        return true;\n+    }\n+\n+\n+    /**\n+     *  Returns the least recently inserted element in this fifo.\n+     *\n+     *  @return the least recently inserted element\n+     *  @throws BufferUnderflowException if the fifo is empty\n+     */\n+    public Object get() {\n+        if( isEmpty() )\n+        {\n+            throw new BufferUnderflowException( \"The buffer is already empty\" );\n+        }\n+\n+        return m_elements[ m_start ];\n+    }\n+\n+\n+    /**\n+     *  Removes the least recently inserted element from this fifo.\n+     *\n+     *  @return the least recently inserted element\n+     *  @throws BufferUnderflowException if the fifo is empty\n+     */\n+    public Object remove()\n+    {\n+        if( isEmpty() )\n+        {\n+            throw new BufferUnderflowException( \"The buffer is already empty\" );\n+        }\n+\n+        Object element = m_elements[ m_start ];\n+\n+        if( null != element )\n+        {\n+            m_elements[ m_start++ ] = null;\n+\n+            if( m_start >= m_elements.length )\n+            {\n+                m_start = 0;\n+            }\n+\n+            m_full = false;\n+        }\n+\n+        return element;\n+    }\n+\n+\n+    private int increment(int index) {\n+        index++; \n+        if (index >= m_elements.length) index = 0;\n+        return index;\n+    }\n+\n+\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) index = m_elements.length - 1;\n+        return index;\n+    }\n+\n+\n+    /**\n+     *  Returns an iterator over this fifo's elements.\n+     *\n+     *  @return an iterator over this fifo's elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator() {\n+\n+            private int index = m_start;\n+            private int lastReturnedIndex = -1;\n+            private boolean isFirst = m_full;\n+\n+            public boolean hasNext() {\n+                return isFirst || (index != m_end);\n+                \n+            }\n+\n+            public Object next() {\n+                if (!hasNext()) throw new NoSuchElementException();\n+                isFirst = false;\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return m_elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == m_start) {\n+                    BoundedFifoBuffer.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                // Other elements require us to shift the subsequent elements\n+                int i = lastReturnedIndex + 1;\n+                while (i != m_end) {\n+                    if (i >= m_elements.length) {\n+                        m_elements[i - 1] = m_elements[0];\n+                        i = 0;\n+                    } else {\n+                        m_elements[i - 1] = m_elements[i];\n+                        i++;\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                m_end = decrement(m_end);\n+                m_elements[m_end] = null;\n+                m_full = false;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+\n+\n+    /**\n+     *  Clears this fifo.\n+     */\n+    public void clear() {\n+        m_full = false;\n+        m_start = 0;\n+        m_end = 0;\n+        Arrays.fill(m_elements, null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n+package org.apache.commons.collections;\n+\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+\n+/**\n+ *  Contains static utility methods for operating on {@link Buffer} objects.\n+ *\n+ *  @author Paul Jack\n+ *  @version $Id: BufferUtils.java,v 1.1 2002/07/03 01:57:08 mas Exp $\n+ */\n+public class BufferUtils {\n+\n+\n+    /**\n+     *  Returns a synchronized buffer backed by the given buffer.\n+     *  Much like the synchronized collections returned by \n+     *  {@link java.util.Collections}, you must manually synchronize on \n+     *  the returned buffer's iterator to avoid non-deterministic behavior:\n+     *  \n+     *  <Pre>\n+     *  Buffer b = BufferUtils.synchronizedBuffer(myBuffer);\n+     *  synchronized (b) {\n+     *      Iterator i = b.iterator();\n+     *      while (i.hasNext()) {\n+     *          process (i.next());\n+     *      }\n+     *  }\n+     *  </Pre>\n+     *\n+     *  @param b  the buffer to synchronize\n+     *  @return  a synchronized buffer backed by that buffer\n+     */\n+    public static Buffer synchronizedBuffer(final Buffer b) {\n+        return new SynchronizedBuffer(b);\n+    }\n+\n+\n+    /**\n+     *  Returns a synchronized buffer backed by the given buffer that will\n+     *  block on {@link Buffer.get()} and {@link Buffer.remove()} operations.\n+     *  If the buffer is empty, then the {@link Buffer.get()} and \n+     *  {@link Buffer.remove()} operations will block until new elements\n+     *  are added to the buffer, rather than immediately throwing a \n+     *  <Code>BufferUnderflowException</Code>.\n+     *\n+     *  @param buf  the buffer to synchronize\n+     *  @return  a blocking buffer backed by that buffer\n+     */\n+    public static Buffer blockingBuffer(Buffer buf) {\n+        return new SynchronizedBuffer(buf) {\n+\n+            public synchronized boolean add(Object o) {\n+                boolean r = b.add(o);\n+                notify();\n+                return r;\n+            }\n+\n+            public synchronized boolean addAll(Collection c) {\n+                boolean r = b.addAll(c);\n+                notifyAll();\n+                return r;\n+            }\n+\n+            public synchronized Object get() {\n+                while (b.isEmpty()) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new BufferUnderflowException();\n+                    }\n+                }\n+                return b.get();\n+            }\n+\n+            public synchronized Object remove() {\n+                while (b.isEmpty()) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new BufferUnderflowException();\n+                    }\n+                }\n+                return b.remove();\n+            }\n+        };\n+    }\n+\n+\n+    private static class SynchronizedBuffer implements Buffer {\n+\n+            Buffer b;\n+\n+\n+            public SynchronizedBuffer(Buffer b) {\n+                 this.b = b;\n+            }\n+\n+            public synchronized int size() {\n+                return b.size();\n+            }\n+\n+            public synchronized boolean isEmpty() {\n+                return b.isEmpty();\n+            }\n+\n+            public synchronized boolean contains(Object o) {\n+                return b.contains(o);\n+            }\n+\n+            public Iterator iterator() {\n+                return b.iterator();\n+            }\n+\n+            public synchronized Object[] toArray() {\n+                return b.toArray();\n+            }\n+\n+            public synchronized Object[] toArray(Object[] o) {\n+                return b.toArray(o);\n+            }\n+\n+            public synchronized boolean add(Object o) {\n+                return b.add(o);\n+            }\n+\n+            public synchronized boolean remove(Object o) {\n+                return b.remove(o);\n+            }\n+\n+            public synchronized boolean containsAll(Collection c) {\n+                return b.containsAll(c);\n+            }\n+\n+            public synchronized boolean addAll(Collection c) {\n+                return b.addAll(c);\n+            }\n+\n+            public synchronized boolean removeAll(Collection c) {\n+                return b.removeAll(c);\n+            }\n+\n+            public synchronized boolean retainAll(Collection c) {\n+                return b.retainAll(c);\n+            }\n+\n+            public synchronized void clear() {\n+                b.clear();\n+            }\n+\n+            public synchronized boolean equals(Object o) {\n+                return b.equals(o);\n+            }\n+\n+            public synchronized int hashCode() {\n+                return b.hashCode();\n+            }\n+\n+            public synchronized String toString() {\n+                return b.toString();\n+            }\n+\n+            public synchronized Object get() {\n+                return b.get();\n+            }\n+\n+            public synchronized Object remove() {\n+                return b.remove();\n+            }          \n+\n+        \n+    }\n+\n+\n+    /**\n+     *  Returns an unmodifiable buffer backed by the given buffer.\n+     *\n+     *  @param b  the buffer to make unmodifiable\n+     *  @return  an unmodifiable buffer backed by that buffer\n+     */\n+    public static Buffer unmodifiableBuffer(Buffer b) {\n+        return new BufferDecorator(b) {\n+            public boolean addAll(Collection c) {\n+                throw new UnsupportedOperationException();\n+            } \n+\n+            public boolean removeAll(Collection c) {\n+                throw new UnsupportedOperationException();\n+            } \n+\n+            public boolean retainAll(Collection c) {\n+                throw new UnsupportedOperationException();\n+            } \n+\n+            public boolean add(Object o) {\n+                throw new UnsupportedOperationException();\n+            } \n+\n+            public boolean remove(Object o) {\n+                throw new UnsupportedOperationException();\n+            } \n+\n+            public void clear() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            public Object remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated buffer backed by the given buffer.  Elements are\n+     *  evaluated with the given predicate before being added to the buffer.\n+     *  If the predicate evaluation returns false, then an \n+     *  IllegalArgumentException is raised and the element is not added to\n+     *  the buffer.\n+     *\n+     *  @param buf  the buffer to predicate\n+     *  @param p  the predicate used to evaluate new elements\n+     *  @return  a predicated buffer\n+     */\n+    public static Buffer predicatedBuffer(Buffer buf, final Predicate p) {\n+        if (buf == null) {\n+            throw new IllegalArgumentException(\"Buffer must not be null.\");\n+        }\n+        if (p == null) {\n+            throw new IllegalArgumentException(\"Predicate must not be null.\");\n+        }\n+        return new BufferDecorator(buf) {\n+\n+            public boolean add(Object o) {\n+                test(o);\n+                return b.add(o);\n+            }\n+\n+            public boolean addAll(Collection c) {\n+                Iterator iterator = c.iterator();\n+                while (iterator.hasNext()) {\n+                    test(iterator.next());\n+                }\n+                return b.addAll(c);\n+            }\n+\n+            private void test(Object o) {\n+                if (!p.evaluate(o)) {\n+                    throw new IllegalArgumentException(\"Invalid: \" + o);\n+                }\n+            }\n+        };\n+    }\n+\n+\n+    private static class BufferDecorator implements Buffer {\n+\n+        Buffer b;\n+\n+        BufferDecorator(Buffer b) {\n+            this.b = b;\n+        }\n+\n+        public int size() {\n+            return b.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return b.isEmpty();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return b.contains(o);\n+        }\n+\n+        public Iterator iterator() {\n+            return b.iterator();\n+        }\n+\n+        public Object[] toArray() {\n+            return b.toArray();\n+        }\n+\n+        public Object[] toArray(Object[] o) {\n+            return b.toArray(o);\n+        }\n+\n+        public boolean add(Object o) {\n+            return b.add(o);\n+        }\n+\n+        public boolean remove(Object o) {\n+            return b.remove(o);\n+        }\n+\n+        public boolean containsAll(Collection c) {\n+            return b.containsAll(c);\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            return b.addAll(c);\n+        }\n+\n+        public boolean removeAll(Collection c) {\n+            return b.removeAll(c);\n+        }\n+\n+        public boolean retainAll(Collection c) {\n+            return b.retainAll(c);\n+        }\n+\n+        public void clear() {\n+            b.clear();\n+        }\n+\n+        public boolean equals(Object o) {\n+            return b.equals(o);\n+        }\n+\n+        public int hashCode() {\n+            return b.hashCode();\n+        }\n+\n+        public String toString() {\n+            return b.toString();\n+        }\n+\n+        public Object get() {\n+            return b.get();\n+        }\n+\n+        public Object remove() {\n+            return b.remove();\n+        }\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java\n+/*\n+ * Copyright (C) The Apache Software Foundation. All rights reserved.\n+ *\n+ * This software is published under the terms of the Apache Software License\n+ * version 1.1, a copy of which has been included with this distribution in\n+ * the LICENSE.txt file.\n+ */\n+package org.apache.commons.collections;\n+\n+\n+import java.util.AbstractCollection;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+\n+/**\n+ * UnboundedFifoBuffer is a <strong>very</strong> efficient buffer implementation.\n+ * According to performance testing, it exhibits a constant access time, but it\n+ * also outperforms ArrayList when used for the same purpose.\n+ * <P>\n+ * The removal order of an <Code>UnboundedFifoBuffer</Code> is based on the insertion\n+ * order; elements are removed in the same order in which they were added.\n+ * The iteration order is the same as the removal order.<P>\n+ *\n+ * The {@link remove()} and {@link get()} operations perform in constant time.\n+ * The {@link add()} operation performs in amortized constant time.  All\n+ * other operations perform in linear time or worse.<P>\n+ *\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <COde>BoundedFifo</Code>:\n+ *\n+ * <Pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifo());\n+ * </Pre>\n+ *\n+ * @author  <a href=\"fede@apache.org\">Federico Barbieri</a>\n+ * @author  <a href=\"bloritsch@apache.org\">Berin Loritsch</a>\n+ * @author Paul Jack\n+ * @version CVS $Revision: 1.1 $ $Date: 2002/07/03 01:57:08 $\n+ * @since Avalon 4.0\n+ */\n+public final class UnboundedFifoBuffer extends AbstractCollection implements Buffer\n+{\n+    protected Object[] m_buffer;\n+    protected int m_head;\n+    protected int m_tail;\n+\n+    /**\n+     * Initialize the UnboundedFifoBuffer with the specified number of elements.  The\n+     * integer must be a positive integer.\n+     */\n+    public UnboundedFifoBuffer( int size )\n+    {\n+        m_buffer = new Object[ size + 1 ];\n+        m_head = 0;\n+        m_tail = 0;\n+    }\n+\n+    /**\n+     * Initialize the UnboundedFifoBuffer with the default number of elements.  It is\n+     * exactly the same as performing the following:\n+     *\n+     * <pre>\n+     *   new UnboundedFifoBuffer( 32 );\n+     * </pre>\n+     */\n+    public UnboundedFifoBuffer()\n+    {\n+        this( 32 );\n+    }\n+\n+    /**\n+     * Tests to see if the CircularBuffer is empty.\n+     */\n+    public final boolean isEmpty()\n+    {\n+        return ( size() == 0 );\n+    }\n+\n+    /**\n+     * Returns the number of elements stored in the buffer.\n+     */\n+    public int size()\n+    {\n+        int size = 0;\n+\n+        if( m_tail < m_head )\n+        {\n+            size = m_buffer.length - m_head + m_tail;\n+        }\n+        else\n+        {\n+            size = m_tail - m_head;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Add an object into the buffer\n+     */\n+    public boolean add( final Object o )\n+    {\n+        if( null == o )\n+        {\n+            throw new NullPointerException( \"Attempted to add null object to buffer\" );\n+        }\n+\n+        if( size() + 1 >= m_buffer.length )\n+        {\n+            Object[] tmp = new Object[ ( ( m_buffer.length - 1 ) * 2 ) + 1 ];\n+\n+            int j = 0;\n+            for( int i = m_head; i != m_tail; )\n+            {\n+                tmp[ j ] = m_buffer[ i ];\n+                m_buffer[ i ] = null;\n+\n+                j++;\n+                i++;\n+                if( i == m_buffer.length )\n+                {\n+                    i = 0;\n+                }\n+            }\n+\n+            m_buffer = tmp;\n+            m_head = 0;\n+            m_tail = j;\n+        }\n+\n+        m_buffer[ m_tail ] = o;\n+        m_tail++;\n+        if( m_tail >= m_buffer.length )\n+        {\n+            m_tail = 0;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the next object in the buffer.\n+     *\n+     * @return the next object in the buffer\n+     * @throws BufferUnderflowException if this buffer is empty\n+     */\n+    public Object get()\n+    {\n+        if( isEmpty() )\n+        {\n+            throw new BufferUnderflowException( \"The buffer is already empty\" );\n+        }\n+\n+        return m_buffer[ m_head ];\n+    }\n+\n+\n+    /**\n+     * Removes the next object from the buffer\n+     *\n+     * @return the removed object\n+     * @throws BufferUnderflowException if this buffer is empty\n+     */\n+    public Object remove()\n+    {\n+        if( isEmpty() )\n+        {\n+            throw new BufferUnderflowException( \"The buffer is already empty\" );\n+        }\n+\n+        Object element = m_buffer[ m_head ];\n+\n+        if( null != element )\n+        {\n+            m_buffer[ m_head ] = null;\n+\n+            m_head++;\n+            if( m_head >= m_buffer.length )\n+            {\n+                m_head = 0;\n+            }\n+        }\n+\n+        return element;\n+    }\n+\n+\n+    private int increment(int index) {\n+        index++; \n+        if (index >= m_buffer.length) index = 0;\n+        return index;\n+    }\n+\n+\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) index = m_buffer.length - 1;\n+        return index;\n+    }\n+\n+\n+    /**\n+     *  Returns an iterator over this fifo's elements.\n+     *\n+     *  @return an iterator over this fifo's elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator() {\n+\n+            private int index = m_head;\n+            private int lastReturnedIndex = -1;\n+\n+            public boolean hasNext() {\n+                return index != m_tail;\n+                \n+            }\n+\n+            public Object next() {\n+                if (!hasNext()) throw new NoSuchElementException();\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return m_buffer[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == m_head) {\n+                    UnboundedFifoBuffer.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                // Other elements require us to shift the subsequent elements\n+                int i = lastReturnedIndex + 1;\n+                while (i != m_tail) {\n+                    if (i >= m_buffer.length) {\n+                        m_buffer[i - 1] = m_buffer[0];\n+                        i = 0;\n+                    } else {\n+                        m_buffer[i - 1] = m_buffer[i];\n+                        i++;\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                m_tail = decrement(m_tail);\n+                m_buffer[m_tail] = null;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+\n+}\n+\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.28 2002/06/21 06:17:45 mas Exp $\n- * $Revision: 1.28 $\n- * $Date: 2002/06/21 06:17:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.29 2002/07/03 01:57:08 mas Exp $\n+ * $Revision: 1.29 $\n+ * $Date: 2002/07/03 01:57:08 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.28 2002/06/21 06:17:45 mas Exp $\n+ * @version $Id: TestAll.java,v 1.29 2002/07/03 01:57:08 mas Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestArrayStack.suite());\n         suite.addTest(TestBeanMap.suite());\n         suite.addTest(TestBinaryHeap.suite());\n+        suite.addTest(TestBoundedFifoBuffer.suite());\n+        suite.addTest(TestBoundedFifoBuffer2.suite());\n         suite.addTest(TestCollectionUtils.suite());\n         suite.addTest(TestComparableComparator.suite());\n         suite.addTest(TestComparatorChain.suite());\n         suite.addTest(TestSingletonIterator.suite());\n         suite.addTest(TestStaticBucketMap.suite());\n         suite.addTest(TestTreeBag.suite());\n+        suite.addTest(TestUnboundedFifoBuffer.suite());\n         suite.addTest(TestUniqueFilterIterator.suite());\n         suite.addTest(org.apache.commons.collections.primitives.TestAll.suite());\n         return suite;\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestBoundedFifoBuffer.java\n+package org.apache.commons.collections;\n+\n+\n+import junit.framework.Test;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+\n+/**\n+ *  Test cases for BoundedFifoBuffer.\n+ */\n+public class TestBoundedFifoBuffer extends TestCollection {\n+\n+    public TestBoundedFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBoundedFifoBuffer.class);\n+    }\n+\n+    /**\n+     *  Returns an empty BoundedFifoBuffer that won't overflow.  \n+     *  \n+     *  @return an empty BoundedFifoBuffer\n+     */\n+    public Collection makeCollection() {\n+        return new BoundedFifoBuffer(100);\n+    }\n+\n+\n+\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    public Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+\n+    /**\n+     *  Overridden because BoundedFifoBuffer doesn't support null elements.\n+     *\n+     *  @return an array of random objects without a null element\n+     */\n+    public Object[] getFullElements() {\n+        return getFullNonNullElements();\n+    }\n+\n+\n+    /**\n+     *  Overridden, because BoundedFifoBuffer's iterators aren't fail-fast.\n+     */\n+    public void testCollectionIteratorFailFast() {\n+    }\n+\n+\n+    /**\n+     *  Runs through the regular verifications, but also verifies that \n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    public void verify() {\n+        super.verify();\n+        Iterator iterator1 = collection.iterator();\n+        Iterator iterator2 = confirmed.iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testBoundedFifoBufferRemove() {\n+        resetFull();\n+        int size = confirmed.size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = ((BoundedFifoBuffer)collection).remove();\n+            Object o2 = ((ArrayList)confirmed).remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            ((BoundedFifoBuffer)collection).remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestBoundedFifoBuffer2.java\n+package org.apache.commons.collections;\n+\n+\n+import junit.framework.Test;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+\n+/**\n+ * Runs tests against a full BoundedFifoBuffer, since many of the algorithms\n+ * differ depending on whether the fifo is full or not.\n+ */\n+public class TestBoundedFifoBuffer2 extends TestBoundedFifoBuffer {\n+\n+    public TestBoundedFifoBuffer2(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBoundedFifoBuffer2.class);\n+    }\n+\n+    /**\n+     *  Returns a BoundedFifoBuffer that's filled to capacity.\n+     *  Any attempt to add to the returned buffer will result in a \n+     *  BufferOverflowException.\n+     *\n+     *  @return a full BoundedFifoBuffer\n+     */\n+    public Collection makeFullCollection() {\n+        return new BoundedFifoBuffer(Arrays.asList(getFullElements()));\n+    }\n+\n+\n+    /**\n+     *  Overridden to skip the add tests.  All of them would fail with a \n+     *  BufferOverflowException.\n+     *\n+     *  @return false\n+     */\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+\n+    /**\n+     *  Overridden because the add operations raise BufferOverflowException\n+     *  instead of UnsupportedOperationException.\n+     */\n+    public void testUnsupportedAdd() {\n+    }\n+\n+\n+    /**\n+     *  Tests to make sure the add operations raise BufferOverflowException.\n+     */\n+    public void testBufferOverflow() {\n+        resetFull();\n+        try {\n+            collection.add(getOtherElements()[0]);\n+            fail(\"add should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            collection.addAll(Arrays.asList(getOtherElements()));\n+            fail(\"addAll should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestUnboundedFifoBuffer.java\n+package org.apache.commons.collections;\n+\n+\n+import junit.framework.Test;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+\n+/**\n+ *  Test cases for UnboundedFifoBuffer.\n+ */\n+public class TestUnboundedFifoBuffer extends TestCollection {\n+\n+    public TestUnboundedFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnboundedFifoBuffer.class);\n+    }\n+\n+    /**\n+     *  Returns an empty UnboundedFifoBuffer with a small capacity.\n+     *\n+     *  @return an empty UnboundedFifoBuffer\n+     */\n+    public Collection makeCollection() {\n+        return new UnboundedFifoBuffer(5);\n+    }\n+\n+\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    public Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+\n+    /**\n+     *  Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     *\n+     *  @return an array of random elements without the null element\n+     */\n+    public Object[] getFullElements() {\n+        return getFullNonNullElements();\n+    }\n+\n+\n+    /**\n+     *  Overridden because UnboundedFifoBuffer's iterators aren't fail-fast.\n+     */\n+    public void testCollectionIteratorFailFast() {\n+    }\n+\n+\n+    /**\n+     *  Verifies that the ArrayList has the same elements in the same \n+     *  sequence as the UnboundedFifoBuffer.\n+     */\n+    public void verify() {\n+        super.verify();\n+        Iterator iterator1 = collection.iterator();\n+        Iterator iterator2 = confirmed.iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Tests that UnboundedFifoBuffer removes elements in the right order.\n+     */\n+    public void testUnboundedFifoBufferRemove() {\n+        resetFull();\n+        int size = confirmed.size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = ((UnboundedFifoBuffer)collection).remove();\n+            Object o2 = ((ArrayList)confirmed).remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+}\n+", "timestamp": 1025661428, "metainfo": ""}