{"sha": "c07fc446f6a77142c1f05fda2dd5d46f294927d7", "log": "Improve performance of clear() Update licence Javadoc and formatting   ", "commit": "\n--- a/src/java/org/apache/commons/collections/FastTreeMap.java\n+++ b/src/java/org/apache/commons/collections/FastTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.10 2002/10/12 22:15:18 scolebourne Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/10/12 22:15:18 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.11 2003/01/18 14:03:28 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  * <http://www.apache.org/>.\n  *\n  */\n-\n-\n package org.apache.commons.collections;\n-\n \n import java.util.Collection;\n import java.util.Comparator;\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.TreeMap;\n-\n \n /**\n  * <p>A customized implementation of <code>java.util.TreeMap</code> designed\n  * Double-Checked Locking Idiom Is Broken Declartion</A>.</P>\n  *\n  * @since 1.0\n+ * @version $Revision: 1.11 $ $Date: 2003/01/18 14:03:28 $\n+ * \n  * @author Craig R. McClanahan\n- * @version $Revision: 1.10 $ $Date: 2002/10/12 22:15:18 $\n+ * @author Stephen Colebourne\n  */\n-\n public class FastTreeMap extends TreeMap {\n \n-\n-    // ----------------------------------------------------------- Constructors\n-\n+    /**\n+     * The underlying map we are managing.\n+     */\n+    protected TreeMap map = null;\n+\n+    /**\n+     * Are we operating in \"fast\" mode?\n+     */\n+    protected boolean fast = false;\n+\n+\n+    // Constructors\n+    // ----------------------------------------------------------------------\n \n     /**\n      * Construct a an empty map.\n      */\n     public FastTreeMap() {\n-\n         super();\n         this.map = new TreeMap();\n-\n-    }\n-\n+    }\n \n     /**\n      * Construct an empty map with the specified comparator.\n      *\n-     * @param comparator The comparator to use for ordering tree elements\n+     * @param comparator  the comparator to use for ordering tree elements\n      */\n     public FastTreeMap(Comparator comparator) {\n-\n         super();\n         this.map = new TreeMap(comparator);\n-\n-    }\n-\n+    }\n \n     /**\n      * Construct a new map with the same mappings as the specified map,\n      * sorted according to the keys's natural order\n      *\n-     * @param map The map whose mappings are to be copied\n+     * @param map  the map whose mappings are to be copied\n      */\n     public FastTreeMap(Map map) {\n-\n         super();\n         this.map = new TreeMap(map);\n-\n-    }\n-\n+    }\n \n     /**\n      * Construct a new map with the same mappings as the specified map,\n      * sorted according to the same ordering\n      *\n-     * @param map The map whose mappings are to be copied\n+     * @param map  the map whose mappings are to be copied\n      */\n     public FastTreeMap(SortedMap map) {\n-\n         super();\n         this.map = new TreeMap(map);\n-\n-    }\n-\n-\n-    // ----------------------------------------------------- Instance Variables\n-\n-\n-    /**\n-     * The underlying map we are managing.\n-     */\n-    protected TreeMap map = null;\n-\n-\n-    // ------------------------------------------------------------- Properties\n-\n-\n-    /**\n-     * Are we operating in \"fast\" mode?\n-     */\n-    protected boolean fast = false;\n-\n+    }\n+\n+\n+    // Property access\n+    // ----------------------------------------------------------------------\n \n     /**\n      *  Returns true if this map is operating in fast mode.\n     }\n \n \n-    // --------------------------------------------------------- Public Methods\n-\n-\n-    /**\n-     * Remove all mappings from this map.\n-     */\n-    public void clear() {\n-\n+    // Map access\n+    // ----------------------------------------------------------------------\n+    // These methods can forward straight to the wrapped Map in 'fast' mode.\n+    // (because they are query methods)\n+\n+    /**\n+     * Return the value to which this map maps the specified key.  Returns\n+     * <code>null</code> if the map contains no mapping for this key, or if\n+     * there is a mapping with a value of <code>null</code>.  Use the\n+     * <code>containsKey()</code> method to disambiguate these cases.\n+     *\n+     * @param key  the key whose value is to be returned\n+     * @return the value mapped to that key, or null\n+     */\n+    public Object get(Object key) {\n+        if (fast) {\n+            return (map.get(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.get(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the number of key-value mappings in this map.\n+     * \n+     * @return the current size of the map\n+     */\n+    public int size() {\n+        if (fast) {\n+            return (map.size());\n+        } else {\n+            synchronized (map) {\n+                return (map.size());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this map contains no mappings.\n+     * \n+     * @return is the map currently empty\n+     */\n+    public boolean isEmpty() {\n+        if (fast) {\n+            return (map.isEmpty());\n+        } else {\n+            synchronized (map) {\n+                return (map.isEmpty());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this map contains a mapping for the\n+     * specified key.\n+     *\n+     * @param key  the key to be searched for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        if (fast) {\n+            return (map.containsKey(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsKey(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return <code>true</code> if this map contains one or more keys mapping\n+     * to the specified value.\n+     *\n+     * @param value  the value to be searched for\n+     * @return true if the map contains the value\n+     */\n+    public boolean containsValue(Object value) {\n+        if (fast) {\n+            return (map.containsValue(value));\n+        } else {\n+            synchronized (map) {\n+                return (map.containsValue(value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the comparator used to order this map, or <code>null</code>\n+     * if this map uses its keys' natural order.\n+     * \n+     * @return the comparator used to order the map, or null if natural order\n+     */\n+    public Comparator comparator() {\n+        if (fast) {\n+            return (map.comparator());\n+        } else {\n+            synchronized (map) {\n+                return (map.comparator());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the first (lowest) key currently in this sorted map.\n+     * \n+     * @return the first key in the map\n+     */\n+    public Object firstKey() {\n+        if (fast) {\n+            return (map.firstKey());\n+        } else {\n+            synchronized (map) {\n+                return (map.firstKey());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the last (highest) key currently in this sorted map.\n+     * \n+     * @return the last key in the map\n+     */\n+    public Object lastKey() {\n+        if (fast) {\n+            return (map.lastKey());\n+        } else {\n+            synchronized (map) {\n+                return (map.lastKey());\n+            }\n+        }\n+    }\n+\n+\n+    // Map modification\n+    // ----------------------------------------------------------------------\n+    // These methods perform special behaviour in 'fast' mode.\n+    // The map is cloned, updated and then assigned back.\n+    // See the comments at the top as to why this won't always work.\n+\n+    /**\n+     * Associate the specified value with the specified key in this map.\n+     * If the map previously contained a mapping for this key, the old\n+     * value is replaced and returned.\n+     *\n+     * @param key  the key with which the value is to be associated\n+     * @param value  the value to be associated with this key\n+     * @return the value previously mapped to the key, or null\n+     */\n+    public Object put(Object key, Object value) {\n         if (fast) {\n             synchronized (this) {\n                 TreeMap temp = (TreeMap) map.clone();\n-                temp.clear();\n+                Object result = temp.put(key, value);\n                 map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.put(key, value));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy all of the mappings from the specified map to this one, replacing\n+     * any mappings with the same keys.\n+     *\n+     * @param in  the map whose mappings are to be copied\n+     */\n+    public void putAll(Map in) {\n+        if (fast) {\n+            synchronized (this) {\n+                TreeMap temp = (TreeMap) map.clone();\n+                temp.putAll(in);\n+                map = temp;\n+            }\n+        } else {\n+            synchronized (map) {\n+                map.putAll(in);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove any mapping for this key, and return any previously\n+     * mapped value.\n+     *\n+     * @param key  the key whose mapping is to be removed\n+     * @return the value removed, or null\n+     */\n+    public Object remove(Object key) {\n+        if (fast) {\n+            synchronized (this) {\n+                TreeMap temp = (TreeMap) map.clone();\n+                Object result = temp.remove(key);\n+                map = temp;\n+                return (result);\n+            }\n+        } else {\n+            synchronized (map) {\n+                return (map.remove(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Remove all mappings from this map.\n+     */\n+    public void clear() {\n+        if (fast) {\n+            synchronized (this) {\n+                map = new TreeMap();\n             }\n         } else {\n             synchronized (map) {\n                 map.clear();\n             }\n         }\n-\n-    }\n-\n-\n-    /**\n-     * Return a shallow copy of this <code>FastTreeMap</code> instance.\n-     * The keys and values themselves are not copied.\n-     */\n-    public Object clone() {\n-\n-        FastTreeMap results = null;\n-        if (fast) {\n-            results = new FastTreeMap(map);\n-        } else {\n-            synchronized (map) {\n-                results = new FastTreeMap(map);\n-            }\n-        }\n-        results.setFast(getFast());\n-        return (results);\n-\n-    }\n-\n-\n-    /**\n-     * Return the comparator used to order this map, or <code>null</code>\n-     * if this map uses its keys' natural order.\n-     */\n-    public Comparator comparator() {\n-\n-        if (fast) {\n-            return (map.comparator());\n-        } else {\n-            synchronized (map) {\n-                return (map.comparator());\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return <code>true</code> if this map contains a mapping for the\n-     * specified key.\n-     *\n-     * @param key Key to be searched for\n-     */\n-    public boolean containsKey(Object key) {\n-\n-        if (fast) {\n-            return (map.containsKey(key));\n-        } else {\n-            synchronized (map) {\n-                return (map.containsKey(key));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return <code>true</code> if this map contains one or more keys mapping\n-     * to the specified value.\n-     *\n-     * @param value Value to be searched for\n-     */\n-    public boolean containsValue(Object value) {\n-\n-        if (fast) {\n-            return (map.containsValue(value));\n-        } else {\n-            synchronized (map) {\n-                return (map.containsValue(value));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return a collection view of the mappings contained in this map.  Each\n-     * element in the returned collection is a <code>Map.Entry</code>.\n-     */\n-    public Set entrySet() {\n-        return new EntrySet();\n-    }\n-\n-\n+    }\n+    \n+    \n+    // Basic object methods\n+    // ----------------------------------------------------------------------\n+    \n     /**\n      * Compare the specified object with this list for equality.  This\n      * implementation uses exactly the code that is used to define the\n      * list equals function in the documentation for the\n      * <code>Map.equals</code> method.\n      *\n-     * @param o Object to be compared to this list\n+     * @param o  the object to be compared to this list\n+     * @return true if the two maps are equal\n      */\n     public boolean equals(Object o) {\n-\n         // Simple tests that require no synchronization\n-        if (o == this)\n+        if (o == this) {\n             return (true);\n-        else if (!(o instanceof Map))\n+        } else if (!(o instanceof Map)) {\n             return (false);\n+        }\n         Map mo = (Map) o;\n \n         // Compare the two maps for equality\n         if (fast) {\n-            if (mo.size() != map.size())\n+            if (mo.size() != map.size()) {\n                 return (false);\n-            java.util.Iterator i = map.entrySet().iterator();\n+            }\n+            Iterator i = map.entrySet().iterator();\n             while (i.hasNext()) {\n                 Map.Entry e = (Map.Entry) i.next();\n                 Object key = e.getKey();\n                 Object value = e.getValue();\n                 if (value == null) {\n-                    if (!(mo.get(key) == null && mo.containsKey(key)))\n+                    if (!(mo.get(key) == null && mo.containsKey(key))) {\n                         return (false);\n+                    }\n                 } else {\n-                    if (!value.equals(mo.get(key)))\n+                    if (!value.equals(mo.get(key))) {\n                         return (false);\n+                    }\n                 }\n             }\n             return (true);\n         } else {\n             synchronized (map) {\n-                if (mo.size() != map.size())\n+                if (mo.size() != map.size()) {\n                     return (false);\n-                java.util.Iterator i = map.entrySet().iterator();\n+                }\n+                Iterator i = map.entrySet().iterator();\n                 while (i.hasNext()) {\n                     Map.Entry e = (Map.Entry) i.next();\n                     Object key = e.getKey();\n                     Object value = e.getValue();\n                     if (value == null) {\n-                        if (!(mo.get(key) == null && mo.containsKey(key)))\n+                        if (!(mo.get(key) == null && mo.containsKey(key))) {\n                             return (false);\n+                        }\n                     } else {\n-                        if (!value.equals(mo.get(key)))\n+                        if (!value.equals(mo.get(key))) {\n                             return (false);\n+                        }\n                     }\n                 }\n                 return (true);\n             }\n         }\n-\n-    }\n-\n-\n-    /**\n-     * Return the first (lowest) key currently in this sorted map.\n-     */\n-    public Object firstKey() {\n-\n-        if (fast) {\n-            return (map.firstKey());\n-        } else {\n-            synchronized (map) {\n-                return (map.firstKey());\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return the value to which this map maps the specified key.  Returns\n-     * <code>null</code> if the map contains no mapping for this key, or if\n-     * there is a mapping with a value of <code>null</code>.  Use the\n-     * <code>containsKey()</code> method to disambiguate these cases.\n-     *\n-     * @param key Key whose value is to be returned\n-     */\n-    public Object get(Object key) {\n-\n-        if (fast) {\n-            return (map.get(key));\n-        } else {\n-            synchronized (map) {\n-                return (map.get(key));\n-            }\n-        }\n-\n-    }\n-\n+    }\n \n     /**\n      * Return the hash code value for this map.  This implementation uses\n      * exactly the code that is used to define the list hash function in the\n      * documentation for the <code>Map.hashCode</code> method.\n+     * \n+     * @return a suitable integer hashcode\n      */\n     public int hashCode() {\n-\n         if (fast) {\n             int h = 0;\n-            java.util.Iterator i = map.entrySet().iterator();\n-            while (i.hasNext())\n+            Iterator i = map.entrySet().iterator();\n+            while (i.hasNext()) {\n                 h += i.next().hashCode();\n+            }\n             return (h);\n         } else {\n             synchronized (map) {\n                 int h = 0;\n-                java.util.Iterator i = map.entrySet().iterator();\n-                while (i.hasNext())\n+                Iterator i = map.entrySet().iterator();\n+                while (i.hasNext()) {\n                     h += i.next().hashCode();\n+                }\n                 return (h);\n             }\n         }\n-\n-    }\n-\n-\n+    }\n+\n+    /**\n+     * Return a shallow copy of this <code>FastTreeMap</code> instance.\n+     * The keys and values themselves are not copied.\n+     * \n+     * @return a clone of this map\n+     */\n+    public Object clone() {\n+        FastTreeMap results = null;\n+        if (fast) {\n+            results = new FastTreeMap(map);\n+        } else {\n+            synchronized (map) {\n+                results = new FastTreeMap(map);\n+            }\n+        }\n+        results.setFast(getFast());\n+        return (results);\n+    }\n+\n+\n+    // Sub map views\n+    // ----------------------------------------------------------------------\n+    \n     /**\n      * Return a view of the portion of this map whose keys are strictly\n      * less than the specified key.\n      *\n      * @param key Key higher than any in the returned map\n+     * @return a head map\n      */\n     public SortedMap headMap(Object key) {\n-\n         if (fast) {\n             return (map.headMap(key));\n         } else {\n                 return (map.headMap(key));\n             }\n         }\n-\n-    }\n-\n-\n-    /**\n-     * Test if this list has no elements.\n-     */\n-    public boolean isEmpty() {\n-\n-        if (fast) {\n-            return (map.isEmpty());\n-        } else {\n-            synchronized (map) {\n-                return (map.isEmpty());\n-            }\n-        }\n-\n-    }\n-\n+    }\n+\n+    /**\n+     * Return a view of the portion of this map whose keys are in the\n+     * range fromKey (inclusive) to toKey (exclusive).\n+     *\n+     * @param fromKey Lower limit of keys for the returned map\n+     * @param toKey Upper limit of keys for the returned map\n+     * @return a sub map\n+     */\n+    public SortedMap subMap(Object fromKey, Object toKey) {\n+        if (fast) {\n+            return (map.subMap(fromKey, toKey));\n+        } else {\n+            synchronized (map) {\n+                return (map.subMap(fromKey, toKey));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return a view of the portion of this map whose keys are greater than\n+     * or equal to the specified key.\n+     *\n+     * @param key Key less than or equal to any in the returned map\n+     * @return a tail map\n+     */\n+    public SortedMap tailMap(Object key) {\n+        if (fast) {\n+            return (map.tailMap(key));\n+        } else {\n+            synchronized (map) {\n+                return (map.tailMap(key));\n+            }\n+        }\n+    }\n+\n+\n+    // Map views\n+    // ----------------------------------------------------------------------\n+    \n+    /**\n+     * Return a collection view of the mappings contained in this map.  Each\n+     * element in the returned collection is a <code>Map.Entry</code>.\n+     */\n+    public Set entrySet() {\n+        return new EntrySet();\n+    }\n \n     /**\n      * Return a set view of the keys contained in this map.\n         return new KeySet();\n     }\n \n-\n-    /**\n-     * Return the last (highest) key currently in this sorted map.\n-     */\n-    public Object lastKey() {\n-\n-        if (fast) {\n-            return (map.lastKey());\n-        } else {\n-            synchronized (map) {\n-                return (map.lastKey());\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Associate the specified value with the specified key in this map.\n-     * If the map previously contained a mapping for this key, the old\n-     * value is replaced and returned.\n-     *\n-     * @param key The key with which the value is to be associated\n-     * @param value The value to be associated with this key\n-     */\n-    public Object put(Object key, Object value) {\n-\n-        if (fast) {\n-            synchronized (this) {\n-                TreeMap temp = (TreeMap) map.clone();\n-                Object result = temp.put(key, value);\n-                map = temp;\n-                return (result);\n-            }\n-        } else {\n-            synchronized (map) {\n-                return (map.put(key, value));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Copy all of the mappings from the specified map to this one, replacing\n-     * any mappings with the same keys.\n-     *\n-     * @param in Map whose mappings are to be copied\n-     */\n-    public void putAll(Map in) {\n-\n-        if (fast) {\n-            synchronized (this) {\n-                TreeMap temp = (TreeMap) map.clone();\n-                temp.putAll(in);\n-                map = temp;\n-            }\n-        } else {\n-            synchronized (map) {\n-                map.putAll(in);\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Remove any mapping for this key, and return any previously\n-     * mapped value.\n-     *\n-     * @param key Key whose mapping is to be removed\n-     */\n-    public Object remove(Object key) {\n-\n-        if (fast) {\n-            synchronized (this) {\n-                TreeMap temp = (TreeMap) map.clone();\n-                Object result = temp.remove(key);\n-                map = temp;\n-                return (result);\n-            }\n-        } else {\n-            synchronized (map) {\n-                return (map.remove(key));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return the number of key-value mappings in this map.\n-     */\n-    public int size() {\n-\n-        if (fast) {\n-            return (map.size());\n-        } else {\n-            synchronized (map) {\n-                return (map.size());\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return a view of the portion of this map whose keys are in the\n-     * range fromKey (inclusive) to toKey (exclusive).\n-     *\n-     * @param fromKey Lower limit of keys for the returned map\n-     * @param toKey Upper limit of keys for the returned map\n-     */\n-    public SortedMap subMap(Object fromKey, Object toKey) {\n-\n-        if (fast) {\n-            return (map.subMap(fromKey, toKey));\n-        } else {\n-            synchronized (map) {\n-                return (map.subMap(fromKey, toKey));\n-            }\n-        }\n-\n-    }\n-\n-\n-    /**\n-     * Return a view of the portion of this map whose keys are greater than\n-     * or equal to the specified key.\n-     *\n-     * @param key Key less than or equal to any in the returned map\n-     */\n-    public SortedMap tailMap(Object key) {\n-\n-        if (fast) {\n-            return (map.tailMap(key));\n-        } else {\n-            synchronized (map) {\n-                return (map.tailMap(key));\n-            }\n-        }\n-\n-    }\n-\n-\n     /**\n      * Return a collection view of the values contained in this map.\n      */\n         return new Values();\n     }\n \n-\n-\n+    // Map view inner classes\n+    // ----------------------------------------------------------------------\n+\n+    /**\n+     * Abstract collection implementation shared by ketSet(), values() and entrySet().\n+     */\n     private abstract class CollectionView implements Collection {\n \n         public CollectionView() {\n         public void clear() {\n             if (fast) {\n                 synchronized (FastTreeMap.this) {\n-                    TreeMap temp = (TreeMap) map.clone();\n-                    get(temp).clear();\n-                    map = temp;\n+                    map = new TreeMap();\n                 }\n             } else {\n                 synchronized (map) {\n         }\n    }\n \n-\n+   /**\n+    * Set implementation over the keys of the FastTreeMap\n+    */\n    private class KeySet extends CollectionView implements Set {\n \n        protected Collection get(Map map) {\n \n    }\n \n-\n+   /**\n+    * Collection implementation over the values of the FastTreeMap\n+    */\n    private class Values extends CollectionView {\n \n        protected Collection get(Map map) {\n        }\n    }\n \n-\n+   /**\n+    * Set implementation over the entries of the FastTreeMap\n+    */\n    private class EntrySet extends CollectionView implements Set {\n \n        protected Collection get(Map map) {\n \n    }\n \n-\n }", "timestamp": 1042898608, "metainfo": ""}