{"sha": "9cfe01cf6d5cf0a6c06f2c30910bb4a3b5d6c2bf", "log": "Add MultiKeyMap implementation   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/MultiKeyMap.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.MultiKey;\n+\n+/**\n+ * A <code>Map</code> implementation that uses multiple keys to map the value.\n+ * <p>\n+ * This class is the most efficient way to uses multiple keys to map to a value.\n+ * The best way to use this class is via the additional map-style methods.\n+ * These provide <code>get</code>, <code>containsKey</code>, <code>put</code> and\n+ * <code>remove</code> for individual keys which operate without extra object creation.\n+ * <p>\n+ * The additional methods are the main interface of this map.\n+ * As such, you will not mormally hold this map in a variable of type <code>Map</code>.\n+ * The normal map methods take in and return a {@link MultiKey}.\n+ * <p>\n+ * As an example, consider a cache that uses a String airline code and a Locale\n+ * to lookup the airline's name:\n+ * <pre>\n+ * public String getAirlineName(String code, String locale) {\n+ *   MultiKeyMap cache = getCache();\n+ *   String name = (String) cache.get(code, locale);\n+ *   if (name == null) {\n+ *     name = getAirlineNameFromDB(code, locale);\n+ *     cache.put(code, locale, name);\n+ *   }\n+ *   return name;\n+ * }\n+ * </pre>\n+ *\n+ * @since Commons Collections 3.1\n+ * @version $Revision: 1.1 $ $Date: 2004/04/12 12:05:30 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class MultiKeyMap\n+        extends AbstractHashedMap implements Serializable, Cloneable {\n+\n+    /** Serialisation version */\n+    private static final long serialVersionUID = -1788199231038721040L;\n+    \n+    /**\n+     * Constructs a new empty map with default size and load factor.\n+     */\n+    public MultiKeyMap() {\n+        super(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_THRESHOLD);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     */\n+    public MultiKeyMap(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    /**\n+     * Constructs a new, empty map with the specified initial capacity and\n+     * load factor. \n+     *\n+     * @param initialCapacity  the initial capacity\n+     * @param loadFactor  the load factor\n+     * @throws IllegalArgumentException if the initial capacity is less than one\n+     * @throws IllegalArgumentException if the load factor is less than zero\n+     */\n+    public MultiKeyMap(int initialCapacity, float loadFactor) {\n+        super(initialCapacity, loadFactor);\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     * @throws NullPointerException if the map is null\n+     */\n+    public MultiKeyMap(Map map) {\n+        super(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Clones the map without cloning the keys or values.\n+     *\n+     * @return a shallow clone\n+     */\n+    public Object clone() {\n+        return super.clone();\n+    }\n+    \n+    /**\n+     * Write the map out using a custom routine.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        doWriteObject(out);\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     */\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        doReadObject(in);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key1, Object key2) {\n+        int hashCode = hash(key1, key2);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2) {\n+        int hashCode = hash(key1, key2);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public Object put(Object key1, Object key2, Object value) {\n+        int hashCode = hash(key1, key2);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                Object oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        \n+        addMapping(index, hashCode, new MultiKey(key1, key2), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key1, Object key2) {\n+        int hashCode = hash(key1, key2);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        HashEntry previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2)) {\n+                Object oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2) {\n+        MultiKey multi = (MultiKey) entry.getKey();\n+        return\n+            multi.size() == 2 &&\n+            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key1, Object key2, Object key3) {\n+        int hashCode = hash(key1, key2, key3);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2, Object key3) {\n+        int hashCode = hash(key1, key2, key3);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public Object put(Object key1, Object key2, Object key3, Object value) {\n+        int hashCode = hash(key1, key2, key3);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                Object oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        \n+        addMapping(index, hashCode, new MultiKey(key1, key2, key3), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key1, Object key2, Object key3) {\n+        int hashCode = hash(key1, key2, key3);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        HashEntry previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3)) {\n+                Object oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2, Object key3) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2, Object key3) {\n+        MultiKey multi = (MultiKey) entry.getKey();\n+        return\n+            multi.size() == 3 &&\n+            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+            (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key1, Object key2, Object key3, Object key4) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2, Object key3, Object key4) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public Object put(Object key1, Object key2, Object key3, Object key4, Object value) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                Object oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        \n+        addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key1, Object key2, Object key3, Object key4) {\n+        int hashCode = hash(key1, key2, key3, key4);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        HashEntry previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4)) {\n+                Object oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2, Object key3, Object key4) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        if (key4 != null) {\n+            h ^= key4.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2, Object key3, Object key4) {\n+        MultiKey multi = (MultiKey) entry.getKey();\n+        return\n+            multi.size() == 4 &&\n+            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+            (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n+            (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                return entry.getValue();\n+            }\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        HashEntry entry = data[hashIndex(hashCode, data.length)];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                return true;\n+            }\n+            entry = entry.next;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Stores the value against the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @param value  the value to store\n+     * @return the value previously mapped to this combined key, null if none\n+     */\n+    public Object put(Object key1, Object key2, Object key3, Object key4, Object key5, Object value) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                Object oldValue = entry.getValue();\n+                updateEntry(entry, value);\n+                return oldValue;\n+            }\n+            entry = entry.next;\n+        }\n+        \n+        addMapping(index, hashCode, new MultiKey(key1, key2, key3, key4, key5), value);\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified multi-key from this map.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int hashCode = hash(key1, key2, key3, key4, key5);\n+        int index = hashIndex(hashCode, data.length);\n+        HashEntry entry = data[index];\n+        HashEntry previous = null;\n+        while (entry != null) {\n+            if (entry.hashCode == hashCode && isEqualKey(entry, key1, key2, key3, key4, key5)) {\n+                Object oldValue = entry.getValue();\n+                removeMapping(entry, index, previous);\n+                return oldValue;\n+            }\n+            previous = entry;\n+            entry = entry.next;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the hash code for the specified multi-key.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return the hash code\n+     */\n+    protected int hash(Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        int h = 0;\n+        if (key1 != null) {\n+            h ^= key1.hashCode();\n+        }\n+        if (key2 != null) {\n+            h ^= key2.hashCode();\n+        }\n+        if (key3 != null) {\n+            h ^= key3.hashCode();\n+        }\n+        if (key4 != null) {\n+            h ^= key4.hashCode();\n+        }\n+        if (key5 != null) {\n+            h ^= key5.hashCode();\n+        }\n+        h += ~(h << 9);\n+        h ^=  (h >>> 14);\n+        h +=  (h << 4);\n+        h ^=  (h >>> 10);\n+        return h;\n+    }\n+\n+    /**\n+     * Is the key equal to the combined key.\n+     * \n+     * @param entry  the entry to compare to\n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @param key5  the fifth key\n+     * @return true if the key matches\n+     */\n+    protected boolean isEqualKey(HashEntry entry, Object key1, Object key2, Object key3, Object key4, Object key5) {\n+        MultiKey multi = (MultiKey) entry.getKey();\n+        return\n+            multi.size() == 5 &&\n+            (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+            (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+            (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n+            (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3))) &&\n+            (key5 == null ? multi.getKey(4) == null : key5.equals(multi.getKey(4)));\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Removes all mappings where the first key is that specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has one or more keys, and the first matches that specified.\n+     * \n+     * @param key1  the first key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1) {\n+        boolean modified = false;\n+        MapIterator it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey multi = (MultiKey) it.next();\n+            if (multi.size() >= 1 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first two keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has two or more keys, and the first two match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1, Object key2) {\n+        boolean modified = false;\n+        MapIterator it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey multi = (MultiKey) it.next();\n+            if (multi.size() >= 2 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first three keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has three or more keys, and the first three match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1, Object key2, Object key3) {\n+        boolean modified = false;\n+        MapIterator it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey multi = (MultiKey) it.next();\n+            if (multi.size() >= 3 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    /**\n+     * Removes all mappings where the first four keys are those specified.\n+     * <p>\n+     * This method removes all the mappings where the <code>MultiKey</code>\n+     * has four or more keys, and the first four match those specified.\n+     * \n+     * @param key1  the first key\n+     * @param key2  the second key\n+     * @param key3  the third key\n+     * @param key4  the fourth key\n+     * @return true if any elements were removed\n+     */\n+    public boolean removeAll(Object key1, Object key2, Object key3, Object key4) {\n+        boolean modified = false;\n+        MapIterator it = mapIterator();\n+        while (it.hasNext()) {\n+            MultiKey multi = (MultiKey) it.next();\n+            if (multi.size() >= 4 &&\n+                (key1 == null ? multi.getKey(0) == null : key1.equals(multi.getKey(0))) &&\n+                (key2 == null ? multi.getKey(1) == null : key2.equals(multi.getKey(1))) &&\n+                (key3 == null ? multi.getKey(2) == null : key3.equals(multi.getKey(2))) &&\n+                (key4 == null ? multi.getKey(3) == null : key4.equals(multi.getKey(3)))) {\n+                it.remove();\n+                modified = true;\n+            }\n+        }\n+        return modified;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Override superclass to ensure that input keys are valid MultiKey objects.\n+     * \n+     * @param key  the key to check\n+     * @return the validated key\n+     */\n+    protected Object convertKey(Object key) {\n+        if (key == null) {\n+            throw new NullPointerException(\"Key must not be null\");\n+        }\n+        if (key instanceof MultiKey == false) {\n+            throw new ClassCastException(\"Key must be a MultiKey\");\n+        }\n+        return key;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/map/TestAll.java\n+++ b/src/test/org/apache/commons/collections/map/TestAll.java\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.16 $ $Date: 2004/04/10 21:24:21 $\n+ * @version $Revision: 1.17 $ $Date: 2004/04/12 12:05:29 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestIdentityMap.suite());\n         suite.addTest(TestLinkedMap.suite());\n         suite.addTest(TestLRUMap.suite());\n+        suite.addTest(TestMultiKeyMap.suite());\n         suite.addTest(TestReferenceMap.suite());\n         suite.addTest(TestStaticBucketMap.suite());\n         suite.addTest(TestSingletonMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestMultiKeyMap.java\n+/*\n+ *  Copyright 2004 The Apache Software Foundation\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.MapIterator;\n+import org.apache.commons.collections.keyvalue.MultiKey;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/04/12 12:05:30 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestMultiKeyMap extends AbstractTestIterableMap {\n+    \n+    static final Integer I1 = new Integer(1);\n+    static final Integer I2 = new Integer(2);\n+    static final Integer I3 = new Integer(3);\n+    static final Integer I4 = new Integer(4);\n+    static final Integer I5 = new Integer(5);\n+    static final Integer I6 = new Integer(6);\n+    static final Integer I7 = new Integer(7);\n+    static final Integer I8 = new Integer(8);\n+\n+    public TestMultiKeyMap(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestMultiKeyMap.class);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new MultiKeyMap();\n+    }\n+\n+    public Object[] getSampleKeys() {\n+        return getMultiKeyKeys();\n+    }\n+\n+    private MultiKey[] getMultiKeyKeys() {\n+        return new MultiKey[] {\n+            new MultiKey(I1, I2),\n+            new MultiKey(I2, I3),\n+            new MultiKey(I3, I4),\n+            new MultiKey(I1, I1, I2),\n+            new MultiKey(I2, I3, I4),\n+            new MultiKey(I3, I7, I6),\n+            new MultiKey(I1, I1, I2, I3),\n+            new MultiKey(I2, I4, I5, I6),\n+            new MultiKey(I3, I6, I7, I8),\n+            new MultiKey(I1, I1, I2, I3, I4),\n+            new MultiKey(I2, I3, I4, I5, I6),\n+            new MultiKey(I3, I5, I6, I7, I8),\n+        };\n+    }\n+\n+    public Object[] getSampleValues() {\n+        return new Object[] {\n+            \"2A\", \"2B\", \"2C\",\n+            \"3D\", \"3E\", \"3F\",\n+            \"4G\", \"4H\", \"4I\",\n+            \"5J\", \"5K\", \"5L\",\n+        };\n+    }\n+\n+    public Object[] getNewSampleValues() {\n+        return new Object[] {\n+            \"1a\", \"1b\", \"1c\",\n+            \"2d\", \"2e\", \"2f\",\n+            \"3g\", \"3h\", \"3i\",\n+            \"4j\", \"4k\", \"4l\",\n+        };\n+    }\n+\n+    public Object[] getOtherKeys() {\n+        return new Object[] {\n+            new MultiKey(I1, I7),\n+            new MultiKey(I1, I8),\n+            new MultiKey(I2, I4),\n+            new MultiKey(I2, I5),\n+        };\n+    }\n+    \n+    public boolean isAllowNullKey() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMultiKeyGet() {\n+        resetFull();\n+        MultiKeyMap multimap = (MultiKeyMap) map;\n+        MultiKey[] keys = getMultiKeyKeys();\n+        Object[] values = getSampleValues();\n+        \n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKey key = keys[i];\n+            Object value = values[i];\n+            \n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(null, multimap.get(null, key.getKey(1)));\n+                assertEquals(null, multimap.get(key.getKey(0), null));\n+                assertEquals(null, multimap.get(null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null));\n+                assertEquals(null, multimap.get(null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(null, multimap.get(null, null, null, null));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(null, multimap.get(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+    \n+    public void testMultiKeyContainsKey() {\n+        resetFull();\n+        MultiKeyMap multimap = (MultiKeyMap) map;\n+        MultiKey[] keys = getMultiKeyKeys();\n+        Object[] values = getSampleValues();\n+        \n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKey key = keys[i];\n+            Object value = values[i];\n+            \n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null));\n+                assertEquals(false, multimap.containsKey(null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, null, null));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null));\n+                assertEquals(false, multimap.containsKey(null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, null));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(null, key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), null, key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), null, key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), null, key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(false, multimap.containsKey(null, null, null, null, null));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+    \n+    public void testMultiKeyPut() {\n+        MultiKey[] keys = getMultiKeyKeys();\n+        Object[] values = getSampleValues();\n+        \n+        for (int i = 0; i < keys.length; i++) {\n+            MultiKeyMap multimap = new MultiKeyMap();\n+            \n+            MultiKey key = keys[i];\n+            Object value = values[i];\n+            \n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1), key.getKey(2))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(null, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), value));\n+                assertEquals(1, multimap.size());\n+                assertEquals(value, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(new MultiKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4))));\n+                assertEquals(value, multimap.put(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4), null));\n+                assertEquals(1, multimap.size());\n+                assertEquals(null, multimap.get(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+    \n+    public void testMultiKeyRemove() {\n+        MultiKey[] keys = getMultiKeyKeys();\n+        Object[] values = getSampleValues();\n+        \n+        for (int i = 0; i < keys.length; i++) {\n+            resetFull();\n+            MultiKeyMap multimap = (MultiKeyMap) map;\n+            int size = multimap.size();\n+            \n+            MultiKey key = keys[i];\n+            Object value = values[i];\n+            \n+            switch (key.size()) {\n+                case 2:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1)));\n+                break;\n+                case 3:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2)));\n+                break;\n+                case 4:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3)));\n+                break;\n+                case 5:\n+                assertEquals(true, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(value, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(size - 1, multimap.size());\n+                assertEquals(null, multimap.remove(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                assertEquals(false, multimap.containsKey(key.getKey(0), key.getKey(1), key.getKey(2), key.getKey(3), key.getKey(4)));\n+                break;\n+                default:\n+                fail(\"Invalid key size\");\n+            }\n+        }\n+    }\n+    \n+    public void testMultiKeyRemoveAll1() {\n+        resetFull();\n+        MultiKeyMap multimap = (MultiKeyMap) map;\n+        assertEquals(12, multimap.size());\n+        \n+        multimap.removeAll(I1);\n+        assertEquals(8, multimap.size());\n+        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey key = (MultiKey) it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)));\n+        }\n+    }\n+    \n+    public void testMultiKeyRemoveAll2() {\n+        resetFull();\n+        MultiKeyMap multimap = (MultiKeyMap) map;\n+        assertEquals(12, multimap.size());\n+        \n+        multimap.removeAll(I2, I3);\n+        assertEquals(9, multimap.size());\n+        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey key = (MultiKey) it.next();\n+            assertEquals(false, I2.equals(key.getKey(0)) && I3.equals(key.getKey(1)));\n+        }\n+    }\n+    \n+    public void testMultiKeyRemoveAll3() {\n+        resetFull();\n+        MultiKeyMap multimap = (MultiKeyMap) map;\n+        assertEquals(12, multimap.size());\n+        \n+        multimap.removeAll(I1, I1, I2);\n+        assertEquals(9, multimap.size());\n+        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey key = (MultiKey) it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)));\n+        }\n+    }\n+    \n+    public void testMultiKeyRemoveAll4() {\n+        resetFull();\n+        MultiKeyMap multimap = (MultiKeyMap) map;\n+        assertEquals(12, multimap.size());\n+        \n+        multimap.removeAll(I1, I1, I2, I3);\n+        assertEquals(10, multimap.size());\n+        for (MapIterator it = multimap.mapIterator(); it.hasNext();) {\n+            MultiKey key = (MultiKey) it.next();\n+            assertEquals(false, I1.equals(key.getKey(0)) && I1.equals(key.getKey(1)) && I2.equals(key.getKey(2)) && key.size() >= 4 && I3.equals(key.getKey(3)));\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testClone() {\n+        MultiKeyMap map = new MultiKeyMap();\n+        map.put(new MultiKey(I1, I2), \"1-2\");\n+        Map cloned = (Map) map.clone();\n+        assertEquals(map.size(), cloned.size());\n+        assertSame(map.get(new MultiKey(I1, I2)), cloned.get(new MultiKey(I1, I2)));\n+    }\n+\n+    public String getCompatibilityVersion() {\n+        return \"3.1\";\n+    }\n+\n+//    public void testCreate() throws Exception {\n+//        resetEmpty();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/MultiKeyMap.emptyCollection.version3.1.obj\");\n+//        resetFull();\n+//        writeExternalFormToDisk(\n+//            (java.io.Serializable) map,\n+//            \"D:/dev/collections/data/test/MultiKeyMap.fullCollection.version3.1.obj\");\n+//    }\n+}", "timestamp": 1081771530, "metainfo": ""}