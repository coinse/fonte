{"sha": "c460996e75df489d6bbcb732763c10d01e62516f", "log": "Statement unnecessarily nested within else clause.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n+++ b/src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java\n     TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n         if (node == null) {\n             return firstEntry();\n-        } else {\n-            return nextEntryImpl(node.predecessor, node, null);\n-        }\n+        }\n+        return nextEntryImpl(node.predecessor, node, null);\n     }\n \n     /**\n         final TrieEntry<K, V> entry = lastEntry();\n         if (entry != null) {\n             return entry.getKey();\n-        } else {\n-            throw new NoSuchElementException();\n-        }\n+        }\n+        throw new NoSuchElementException();\n     }\n \n     public K nextKey(final K key) {\n         if (entry != null) {\n             final TrieEntry<K, V> nextEntry = nextEntry(entry);\n             return nextEntry != null ? nextEntry.getKey() : null;\n-        } else {\n-            return null;\n-        }\n+        }\n+        return null;\n     }\n \n     public K previousKey(final K key) {\n         if (entry != null) {\n             final TrieEntry<K, V> prevEntry = previousEntry(entry);\n             return prevEntry != null ? prevEntry.getKey() : null;\n-        } else {\n-            return null;\n-        }\n+        }\n+        return null;\n     }\n \n     public OrderedMapIterator<K, V> mapIterator() {\n                 // If data in root, and more after -- return it.\n                 if (size() > 1) {\n                     return nextEntry(root);\n-                } else { // If no more after, no higher entry.\n-                    return null;\n-                }\n-            } else {\n-                // Root is empty & we want something after empty, return first.\n-                return firstEntry();\n-            }\n+                }\n+                // If no more after, no higher entry.\n+                return null;\n+            }\n+            // Root is empty & we want something after empty, return first.\n+            return firstEntry();\n         }\n \n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n                 return root;\n-            } else {\n-                return firstEntry();\n-            }\n+            }\n+            return firstEntry();\n         }\n \n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n             if (!root.isEmpty()) {\n                 return root;\n-            } else {\n-                return firstEntry();\n-            }\n+            }\n+            return firstEntry();\n         } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n             return found;\n         }\n         if (lengthInBits == 0) {\n             if (!root.isEmpty()) {\n                 return root;\n-            } else {\n-                return null;\n-            }\n+            }\n+            return null;\n         }\n \n         final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n         } else if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n             if (!root.isEmpty()) {\n                 return root;\n-            } else {\n-                return null;\n-            }\n+            }\n+            return null;\n         } else if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n             return found;\n         }\n         if (start.predecessor.right == start) {\n             if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                 return start.predecessor.left;\n-            } else {\n-                return followRight(start.predecessor.left);\n-            }\n-        } else {\n-            TrieEntry<K, V> node = start.predecessor;\n-            while (node.parent != null && node == node.parent.left) {\n-                node = node.parent;\n-            }\n-\n-            if (node.parent == null) { // can be null if we're looking up root.\n-                return null;\n-            }\n-\n-            if (isValidUplink(node.parent.left, node.parent)) {\n-                if (node.parent.left == root) {\n-                    if (root.isEmpty()) {\n-                        return null;\n-                    } else {\n-                        return root;\n-                    }\n-\n-                } else {\n-                    return node.parent.left;\n-                }\n-            } else {\n-                return followRight(node.parent.left);\n-            }\n-        }\n+            }\n+            return followRight(start.predecessor.left);\n+        }\n+        TrieEntry<K, V> node = start.predecessor;\n+        while (node.parent != null && node == node.parent.left) {\n+            node = node.parent;\n+        }\n+\n+        if (node.parent == null) { // can be null if we're looking up root.\n+            return null;\n+        }\n+\n+        if (isValidUplink(node.parent.left, node.parent)) {\n+            if (node.parent.left == root) {\n+                if (root.isEmpty()) {\n+                    return null;\n+                }\n+                return root;\n+\n+            }\n+            return node.parent.left;\n+        }\n+        return followRight(node.parent.left);\n     }\n \n     /**\n             final TrieEntry<K, V> parentOfSubtree) {\n         if (node == null) {\n             return firstEntry();\n-        } else {\n-            return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n-        }\n+        }\n+        return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n     }\n \n     /**\n             final int ret = getKeyAnalyzer().compare(key, fromKey);\n             if (fromInclusive || forceInclusive) {\n                 return ret >= 0;\n-            } else {\n-                return ret > 0;\n-            }\n+            }\n+            return ret > 0;\n         }\n \n         /**\n             final int ret = getKeyAnalyzer().compare(key, toKey);\n             if (toInclusive || forceInclusive) {\n                 return ret <= 0;\n-            } else {\n-                return ret < 0;\n-            }\n+            }\n+            return ret < 0;\n         }\n \n         /**", "timestamp": 1414671621, "metainfo": ""}