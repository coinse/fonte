{"sha": "7941b5f452eabbd1f1e2c5988c605104f7af07f3", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r555925 | skestle | 2007-07-13 03:39:24 -0700 (Fri, 13 Jul 2007) | 2 lines          Added Edwin Tellman's patch for COLLECTIONS-243.       It all seems pretty reasonable, and it should all be checked again as the project is worked through     ------------------------------------------------------------------------     r471166 | scolebourne | 2006-11-04 03:33:22 -0800 (Sat, 04 Nov 2006) | 1 line          Removed Typed* containers such as TypedList and TypedMap as generics now provides type safety     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BagUtils.java\n+++ b/src/java/org/apache/commons/collections/BagUtils.java\n import org.apache.commons.collections.bag.TransformedBag;\n import org.apache.commons.collections.bag.TransformedSortedBag;\n import org.apache.commons.collections.bag.TreeBag;\n-import org.apache.commons.collections.bag.TypedBag;\n-import org.apache.commons.collections.bag.TypedSortedBag;\n import org.apache.commons.collections.bag.UnmodifiableBag;\n import org.apache.commons.collections.bag.UnmodifiableSortedBag;\n \n /**\n- * Provides utility methods and decorators for\n- * {@link Bag} and {@link SortedBag} instances.\n+ * Provides utility methods and decorators for {@link Bag} and {@link SortedBag}\n+ * instances.\n  *\n  * @since Commons Collections 2.1\n- * @version $Revision$ $Date$\n+ * @version $Revision$ $Date: 2007-07-13 05:39:24 -0500 (Fri, 13 Jul\n+ * 2007) $\n  *\n  * @author Paul Jack\n  * @author Stephen Colebourne\n     /**\n      * An empty unmodifiable bag.\n      */\n-    public static final Bag EMPTY_BAG = UnmodifiableBag.decorate(new HashBag());\n+    public static final Bag<Object> EMPTY_BAG = UnmodifiableBag.decorate(new HashBag<Object>());\n \n     /**\n      * An empty unmodifiable sorted bag.\n      */\n-    public static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.decorate(new TreeBag());\n-\n-    /**\n-     * Instantiation of BagUtils is not intended or required.\n-     * However, some tools require an instance to operate.\n+    public static final Bag<Object> EMPTY_SORTED_BAG = UnmodifiableSortedBag.decorate(new TreeBag<Object>());\n+\n+    /**\n+     * Instantiation of BagUtils is not intended or required. However, some\n+     * tools require an instance to operate.\n      */\n     public BagUtils() {\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Returns a synchronized (thread-safe) bag backed by the given bag.\n-     * In order to guarantee serial access, it is critical that all \n-     * access to the backing bag is accomplished through the returned bag.\n-     * <p>\n-     * It is imperative that the user manually synchronize on the returned\n-     * bag when iterating over it:\n-     *\n+     * Returns a synchronized (thread-safe) bag backed by the given bag. In\n+     * order to guarantee serial access, it is critical that all access to the\n+     * backing bag is accomplished through the returned bag.\n+     * <p>\n+     * It is imperative that the user manually synchronize on the returned bag\n+     * when iterating over it:\n+     * \n      * <pre>\n      * Bag bag = BagUtils.synchronizedBag(new HashBag());\n      * ...\n      *     }\n      * }\n      * </pre>\n-     *\n-     * Failure to follow this advice may result in non-deterministic \n-     * behavior.\n-     *\n-     * @param bag  the bag to synchronize, must not be null\n+     * \n+     * Failure to follow this advice may result in non-deterministic behavior.\n+     * \n+     * @param bag the bag to synchronize, must not be null\n      * @return a synchronized bag backed by that bag\n-     * @throws IllegalArgumentException  if the Bag is null\n-     */\n-    public static Bag synchronizedBag(Bag bag) {\n+     * @throws IllegalArgumentException if the Bag is null\n+     */\n+    public static <E> Bag<E> synchronizedBag(Bag<E> bag) {\n         return SynchronizedBag.decorate(bag);\n     }\n \n     /**\n-     * Returns an unmodifiable view of the given bag.  Any modification\n-     * attempts to the returned bag will raise an \n-     * {@link UnsupportedOperationException}.\n-     *\n-     * @param bag  the bag whose unmodifiable view is to be returned, must not be null\n+     * Returns an unmodifiable view of the given bag. Any modification attempts\n+     * to the returned bag will raise an {@link UnsupportedOperationException}.\n+     * \n+     * @param bag the bag whose unmodifiable view is to be returned, must not be\n+     * null\n      * @return an unmodifiable view of that bag\n-     * @throws IllegalArgumentException  if the Bag is null\n-     */\n-    public static Bag unmodifiableBag(Bag bag) {\n+     * @throws IllegalArgumentException if the Bag is null\n+     */\n+    public static <E> Bag<E> unmodifiableBag(Bag<E> bag) {\n         return UnmodifiableBag.decorate(bag);\n     }\n-    \n+\n     /**\n      * Returns a predicated (validating) bag backed by the given bag.\n      * <p>\n-     * Only objects that pass the test in the given predicate can be added to the bag.\n-     * Trying to add an invalid object results in an IllegalArgumentException.\n+     * Only objects that pass the test in the given predicate can be added to\n+     * the bag. Trying to add an invalid object results in an\n+     * IllegalArgumentException. It is important not to use the original bag\n+     * after invoking this method, as it is a backdoor for adding invalid\n+     * objects.\n+     * \n+     * @param bag the bag to predicate, must not be null\n+     * @param predicate the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException if the Bag or Predicate is null\n+     */\n+    public static <E> Bag<E> predicatedBag(Bag<E> bag, Predicate<? super E> predicate) {\n+        return PredicatedBag.decorate(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed bag backed by the given bag.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the Bag.\n      * It is important not to use the original bag after invoking this method,\n-     * as it is a backdoor for adding invalid objects.\n-     *\n-     * @param bag  the bag to predicate, must not be null\n-     * @param predicate  the predicate for the bag, must not be null\n-     * @return a predicated bag backed by the given bag\n-     * @throws IllegalArgumentException  if the Bag or Predicate is null\n-     */\n-    public static Bag predicatedBag(Bag bag, Predicate predicate) {\n-        return PredicatedBag.decorate(bag, predicate);\n-    }\n-    \n-    /**\n-     * Returns a typed bag backed by the given bag.\n-     * <p>\n-     * Only objects of the specified type can be added to the bag.\n-     * \n-     * @param bag  the bag to limit to a specific type, must not be null\n-     * @param type  the type of objects which may be added to the bag\n-     * @return a typed bag backed by the specified bag\n-     */\n-    public static Bag typedBag(Bag bag, Class type) {\n-        return TypedBag.decorate(bag, type);\n-    }\n-    \n-    /**\n-     * Returns a transformed bag backed by the given bag.\n-     * <p>\n-     * Each object is passed through the transformer as it is added to the\n-     * Bag. It is important not to use the original bag after invoking this \n-     * method, as it is a backdoor for adding untransformed objects.\n+     * as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified bag will not be transformed.\n      * If you want that behaviour, see {@link TransformedBag#decorateTransform}.\n-     *\n-     * @param bag  the bag to predicate, must not be null\n-     * @param transformer  the transformer for the bag, must not be null\n+     * \n+     * @param bag the bag to predicate, must not be null\n+     * @param transformer the transformer for the bag, must not be null\n      * @return a transformed bag backed by the given bag\n-     * @throws IllegalArgumentException  if the Bag or Transformer is null\n-     */\n-    public static Bag transformedBag(Bag bag, Transformer transformer) {\n+     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     */\n+    public static <E> Bag<E> transformedBag(Bag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         return TransformedBag.decorate(bag, transformer);\n     }\n-    \n+\n     //-----------------------------------------------------------------------\n     /**\n-     * Returns a synchronized (thread-safe) sorted bag backed by the given \n-     * sorted bag.\n-     * In order to guarantee serial access, it is critical that all \n+     * Returns a synchronized (thread-safe) sorted bag backed by the given\n+     * sorted bag. In order to guarantee serial access, it is critical that all\n      * access to the backing bag is accomplished through the returned bag.\n      * <p>\n-     * It is imperative that the user manually synchronize on the returned\n-     * bag when iterating over it:\n-     *\n+     * It is imperative that the user manually synchronize on the returned bag\n+     * when iterating over it:\n+     * \n      * <pre>\n      * SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n      * ...\n      *     }\n      * }\n      * </pre>\n-     *\n-     * Failure to follow this advice may result in non-deterministic \n-     * behavior.\n-     *\n-     * @param bag  the bag to synchronize, must not be null\n+     * \n+     * Failure to follow this advice may result in non-deterministic behavior.\n+     * \n+     * @param bag the bag to synchronize, must not be null\n      * @return a synchronized bag backed by that bag\n-     * @throws IllegalArgumentException  if the SortedBag is null\n-     */\n-    public static SortedBag synchronizedSortedBag(SortedBag bag) {\n+     * @throws IllegalArgumentException if the SortedBag is null\n+     */\n+    public static <E> SortedBag<E> synchronizedSortedBag(SortedBag<E> bag) {\n         return SynchronizedSortedBag.decorate(bag);\n     }\n-    \n-    /**\n-     * Returns an unmodifiable view of the given sorted bag.  Any modification\n-     * attempts to the returned bag will raise an \n+\n+    /**\n+     * Returns an unmodifiable view of the given sorted bag. Any modification\n+     * attempts to the returned bag will raise an\n      * {@link UnsupportedOperationException}.\n-     *\n-     * @param bag  the bag whose unmodifiable view is to be returned, must not be null\n+     * \n+     * @param bag the bag whose unmodifiable view is to be returned, must not be\n+     * null\n      * @return an unmodifiable view of that bag\n-     * @throws IllegalArgumentException  if the SortedBag is null\n-     */\n-    public static SortedBag unmodifiableSortedBag(SortedBag bag) {\n+     * @throws IllegalArgumentException if the SortedBag is null\n+     */\n+    public static <E> SortedBag<E> unmodifiableSortedBag(SortedBag<E> bag) {\n         return UnmodifiableSortedBag.decorate(bag);\n     }\n-    \n-    /**\n-     * Returns a predicated (validating) sorted bag backed by the given sorted bag.\n-     * <p>\n-     * Only objects that pass the test in the given predicate can be added to the bag.\n-     * Trying to add an invalid object results in an IllegalArgumentException.\n+\n+    /**\n+     * Returns a predicated (validating) sorted bag backed by the given sorted\n+     * bag.\n+     * <p>\n+     * Only objects that pass the test in the given predicate can be added to\n+     * the bag. Trying to add an invalid object results in an\n+     * IllegalArgumentException. It is important not to use the original bag\n+     * after invoking this method, as it is a backdoor for adding invalid\n+     * objects.\n+     * \n+     * @param bag the sorted bag to predicate, must not be null\n+     * @param predicate the predicate for the bag, must not be null\n+     * @return a predicated bag backed by the given bag\n+     * @throws IllegalArgumentException if the SortedBag or Predicate is null\n+     */\n+    public static <E> SortedBag<E> predicatedSortedBag(SortedBag<E> bag,\n+            Predicate<? super E> predicate) {\n+        return PredicatedSortedBag.decorate(bag, predicate);\n+    }\n+\n+    /**\n+     * Returns a transformed sorted bag backed by the given bag.\n+     * <p>\n+     * Each object is passed through the transformer as it is added to the Bag.\n      * It is important not to use the original bag after invoking this method,\n-     * as it is a backdoor for adding invalid objects.\n-     *\n-     * @param bag  the sorted bag to predicate, must not be null\n-     * @param predicate  the predicate for the bag, must not be null\n-     * @return a predicated bag backed by the given bag\n-     * @throws IllegalArgumentException  if the SortedBag or Predicate is null\n-     */\n-    public static SortedBag predicatedSortedBag(SortedBag bag, Predicate predicate) {\n-        return PredicatedSortedBag.decorate(bag, predicate);\n-    }\n-    \n-    /**\n-     * Returns a typed sorted bag backed by the given bag.\n-     * <p>\n-     * Only objects of the specified type can be added to the bag.\n-     * \n-     * @param bag  the bag to limit to a specific type, must not be null\n-     * @param type  the type of objects which may be added to the bag\n-     * @return a typed bag backed by the specified bag\n-     */\n-    public static SortedBag typedSortedBag(SortedBag bag, Class type) {\n-        return TypedSortedBag.decorate(bag, type);\n-    }\n-    \n-    /**\n-     * Returns a transformed sorted bag backed by the given bag.\n-     * <p>\n-     * Each object is passed through the transformer as it is added to the\n-     * Bag. It is important not to use the original bag after invoking this \n-     * method, as it is a backdoor for adding untransformed objects.\n+     * as it is a backdoor for adding untransformed objects.\n      * <p>\n      * Existing entries in the specified bag will not be transformed.\n      * If you want that behaviour, see {@link TransformedSortedBag#decorateTransform}.\n-     *\n-     * @param bag  the bag to predicate, must not be null\n-     * @param transformer  the transformer for the bag, must not be null\n+     * \n+     * @param bag the bag to predicate, must not be null\n+     * @param transformer the transformer for the bag, must not be null\n      * @return a transformed bag backed by the given bag\n-     * @throws IllegalArgumentException  if the Bag or Transformer is null\n-     */\n-    public static SortedBag transformedSortedBag(SortedBag bag, Transformer transformer) {\n+     * @throws IllegalArgumentException if the Bag or Transformer is null\n+     */\n+    public static <E> SortedBag<E> transformedSortedBag(SortedBag<E> bag, Transformer<? super E, ? extends E> transformer) {\n         return TransformedSortedBag.decorate(bag, transformer);\n     }\n-    \n+\n+    /**\n+     * Get an empty <code>Bag</code>.\n+     * @param <E>\n+     * @return Bag<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> Bag<E> emptyBag() {\n+        return (Bag<E>) EMPTY_BAG;        \n+    }\n+\n+    /**\n+     * Get an empty <code>SortedBag</code>.\n+     * @param <E>\n+     * @return SortedBag<E>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <E> SortedBag<E> emptySortedBag() {\n+        return (SortedBag<E>) EMPTY_SORTED_BAG;        \n+    }\n }", "timestamp": 1252994052, "metainfo": ""}