{"sha": "c72a7267db6074353ca8b27c632f63c8c366e614", "log": "Add Flat3Map, a new map design for small Maps that is faster than HashMap   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/Flat3Map.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/Flat3Map.java,v 1.1 2003/11/02 23:41:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import org.apache.commons.collections.iterators.DefaultMapIterator;\n+import org.apache.commons.collections.iterators.MapIterator;\n+import org.apache.commons.collections.iterators.ResetableMapIterator;\n+import org.apache.commons.collections.pairs.AbstractMapEntry;\n+\n+/**\n+ * A <code>Map</code> implementation that stores data in simple fields until\n+ * the size is greater than 3.\n+ * <p>\n+ * This map is designed for performance and can outstrip HashMap.\n+ * It also has good garbage collection characteristics.\n+ * <ul>\n+ * <li>Optimised for operation at size 3 or less.\n+ * <li>Still works well once size 3 exceeded.\n+ * <li>Gets at size 3 or less are about 0-10% faster than HashMap,\n+ * <li>Puts at size 3 or less are over 4 times faster than HashMap.\n+ * <li>Performance 5% slower than HashMap once size 3 exceeded once.\n+ * </ul>\n+ * The design uses two distinct modes of operation - flat and delegate.\n+ * While the map is size 3 or less, operations map straight onto fields using\n+ * switch statements. Once size 4 is reached, the map switches to delegate mode\n+ * and never switches back. In delegate mode, all operations are forwarded \n+ * straight to a HashMap resulting in the 5% performance loss.\n+ * <p>\n+ * The performance gains on puts are due to not needing to create a Map Entry\n+ * object. This is a large saving not only in performance but in garbage collection.\n+ * <p>\n+ * Whilst in flat mode this map is also easy for the garbage collector to dispatch.\n+ * This is because it contains no complex objects or arrays which slow the progress.\n+ * (Note that the impact of this has not actually been tested!)\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/02 23:41:46 $\n+ *\n+ * @author Stephen Colebourne\n+ */\n+public class Flat3Map implements Map {\n+    \n+    /** The size of the map, used while in flat mode */\n+    private int iSize;\n+    /** Hash, used while in flat mode */\n+    private int iHash1;\n+    /** Hash, used while in flat mode */\n+    private int iHash2;\n+    /** Hash, used while in flat mode */\n+    private int iHash3;\n+    /** Key, used while in flat mode */\n+    private Object iKey1;\n+    /** Key, used while in flat mode */\n+    private Object iKey2;\n+    /** Key, used while in flat mode */\n+    private Object iKey3;\n+    /** Value, used while in flat mode */\n+    private Object iValue1;\n+    /** Value, used while in flat mode */\n+    private Object iValue2;\n+    /** Value, used while in flat mode */\n+    private Object iValue3;\n+    /** Map, used while in delegate mode */\n+    private HashMap iMap;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public Flat3Map() {\n+        super();\n+    }\n+\n+    /**\n+     * Constructor copying elements from another map.\n+     *\n+     * @param map  the map to copy\n+     */\n+    public Flat3Map(Map map) {\n+        super();\n+        putAll(map);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the value mapped to the key specified.\n+     * \n+     * @param key  the key\n+     * @return the mapped value, null if no match\n+     */\n+    public Object get(Object key) {\n+        if (iMap != null) {\n+            return iMap.get(key);\n+        }\n+        if (key == null) {\n+            switch (iSize) {\n+                // drop through\n+                case 3:\n+                    if (iKey3 == null) return iValue3;\n+                case 2:\n+                    if (iKey2 == null) return iValue2;\n+                case 1:\n+                    if (iKey1 == null) return iValue1;\n+            }\n+        } else {\n+            if (iSize > 0) {\n+                int hashCode = key.hashCode();\n+                switch (iSize) {\n+                    // drop through\n+                    case 3:\n+                        if (iHash3 == hashCode && key.equals(iKey3)) return iValue3;\n+                    case 2:\n+                        if (iHash2 == hashCode && key.equals(iKey2)) return iValue2;\n+                    case 1:\n+                        if (iHash1 == hashCode && key.equals(iKey1)) return iValue1;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets the size of the map.\n+     * \n+     * @return the size\n+     */\n+    public int size() {\n+        if (iMap != null) {\n+            return iMap.size();\n+        }\n+        return iSize;\n+    }\n+\n+    /**\n+     * Checks whether the map is currently empty.\n+     * \n+     * @return true if the map is currently size zero\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Checks whether the map contains the specified key.\n+     * \n+     * @param key  the key to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsKey(Object key) {\n+        if (iMap != null) {\n+            return iMap.containsKey(key);\n+        }\n+        if (key == null) {\n+            switch (iSize) {  // drop through\n+                case 3:\n+                    if (iKey3 == null) return true;\n+                case 2:\n+                    if (iKey2 == null) return true;\n+                case 1:\n+                    if (iKey1 == null) return true;\n+            }\n+        } else {\n+            if (iSize > 0) {\n+                int hashCode = key.hashCode();\n+                switch (iSize) {  // drop through\n+                    case 3:\n+                        if (iHash3 == hashCode && key.equals(iKey3)) return true;\n+                    case 2:\n+                        if (iHash2 == hashCode && key.equals(iKey2)) return true;\n+                    case 1:\n+                        if (iHash1 == hashCode && key.equals(iKey1)) return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks whether the map contains the specified value.\n+     * \n+     * @param value  the value to search for\n+     * @return true if the map contains the key\n+     */\n+    public boolean containsValue(Object value) {\n+        if (iMap != null) {\n+            return iMap.containsValue(value);\n+        }\n+        if (value == null) {  // drop through\n+            switch (iSize) {\n+                case 3:\n+                    if (iValue3 == null) return true;\n+                case 2:\n+                    if (iValue2 == null) return true;\n+                case 1:\n+                    if (iValue1 == null) return true;\n+            }\n+        } else {\n+            switch (iSize) {  // drop through\n+                case 3:\n+                    if (value.equals(iValue3)) return true;\n+                case 2:\n+                    if (value.equals(iValue2)) return true;\n+                case 1:\n+                    if (value.equals(iValue1)) return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a key-value mapping into this map.\n+     * \n+     * @param key  the key to add\n+     * @param value  the value to add\n+     * @return the value previously mapped to this key, null if none\n+     */\n+    public Object put(Object key, Object value) {\n+        if (iMap != null) {\n+            return iMap.put(key, value);\n+        }\n+        // change existing mapping\n+        if (key == null) {\n+            switch (iSize) {  // drop through\n+                case 3:\n+                    if (iKey3 == null) {\n+                        Object old = iValue3;\n+                        iValue3 = value;\n+                        return old;\n+                    }\n+                case 2:\n+                    if (iKey2 == null) {\n+                        Object old = iValue2;\n+                        iValue2 = value;\n+                        return old;\n+                    }\n+                case 1:\n+                    if (iKey1 == null) {\n+                        Object old = iValue1;\n+                        iValue1 = value;\n+                        return old;\n+                    }\n+            }\n+        } else {\n+            if (iSize > 0) {\n+                int hashCode = key.hashCode();\n+                switch (iSize) {  // drop through\n+                    case 3:\n+                        if (iHash3 == hashCode && key.equals(iKey3)) {\n+                            Object old = iValue3;\n+                            iValue3 = value;\n+                            return old;\n+                        }\n+                    case 2:\n+                        if (iHash2 == hashCode && key.equals(iKey2)) {\n+                            Object old = iValue2;\n+                            iValue2 = value;\n+                            return old;\n+                        }\n+                    case 1:\n+                        if (iHash1 == hashCode && key.equals(iKey1)) {\n+                            Object old = iValue1;\n+                            iValue1 = value;\n+                            return old;\n+                        }\n+                }\n+            }\n+        }\n+        \n+        // add new mapping\n+        switch (iSize) {\n+            default:\n+                convertToMap();\n+                iMap.put(key, value);\n+                return null;\n+            case 2:\n+                iHash3 = (key == null ? 0 : key.hashCode());\n+                iKey3 = key;\n+                iValue3 = value;\n+                break;\n+            case 1:\n+                iHash2 = (key == null ? 0 : key.hashCode());\n+                iKey2 = key;\n+                iValue2 = value;\n+                break;\n+            case 0:\n+                iHash1 = (key == null ? 0 : key.hashCode());\n+                iKey1 = key;\n+                iValue1 = value;\n+                break;\n+        }\n+        iSize++;\n+        return null;\n+    }\n+\n+    /**\n+     * Puts all the values from the specified map into this map.\n+     * \n+     * @param map\n+     */\n+    public void putAll(Map map) {\n+        int size = map.size();\n+        if (size == 0) {\n+            return;\n+        }\n+        if (iMap != null) {\n+            iMap.putAll(map);\n+        }\n+        if (size < 4) {\n+            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n+                Map.Entry entry = (Map.Entry) it.next();\n+                put(entry.getKey(), entry.getValue());\n+            }\n+        } else {\n+            convertToMap();\n+            iMap.putAll(map);\n+        }\n+    }\n+\n+    /**\n+     * Converts the flat map data to a HashMap.\n+     */\n+    private void convertToMap() {\n+        iMap = new HashMap();\n+        switch (iSize) {  // drop through\n+            case 3:\n+                iMap.put(iKey3, iValue3);\n+            case 2:\n+                iMap.put(iKey2, iValue2);\n+            case 1:\n+                iMap.put(iKey1, iValue1);\n+        }\n+        \n+        iSize = 0;\n+        iHash1 = iHash2 = iHash3 = 0;\n+        iKey1 = iKey2 = iKey3 = null;\n+        iValue1 = iValue2 = iValue3 = null;\n+    }\n+\n+    /**\n+     * Removes the specified mapping from this map.\n+     * \n+     * @param key  the mapping to remove\n+     * @return the value mapped to the removed key, null if key not in map\n+     */\n+    public Object remove(Object key) {\n+        if (iMap != null) {\n+            return iMap.remove(key);\n+        }\n+        if (iSize == 0) {\n+            return null;\n+        }\n+        if (key == null) {\n+            switch (iSize) {  // drop through\n+                case 3:\n+                    if (iKey3 == null) {\n+                        Object old = iValue3;\n+                        iHash3 = 0;\n+                        iKey3 = null;\n+                        iValue3 = null;\n+                        iSize = 2;\n+                        return old;\n+                    }\n+                    if (iKey2 == null) {\n+                        Object old = iValue3;\n+                        iHash2 = iHash3;\n+                        iKey2 = iKey3;\n+                        iValue2 = iValue3;\n+                        iHash3 = 0;\n+                        iKey3 = null;\n+                        iValue3 = null;\n+                        iSize = 2;\n+                        return old;\n+                    }\n+                    if (iKey1 == null) {\n+                        Object old = iValue3;\n+                        iHash1 = iHash3;\n+                        iKey1 = iKey3;\n+                        iValue1 = iValue3;\n+                        iHash3 = 0;\n+                        iKey3 = null;\n+                        iValue3 = null;\n+                        iSize = 2;\n+                        return old;\n+                    }\n+                    return null;\n+                case 2:\n+                    if (iKey2 == null) {\n+                        Object old = iValue2;\n+                        iHash2 = 0;\n+                        iKey2 = null;\n+                        iValue2 = null;\n+                        iSize = 1;\n+                        return old;\n+                    }\n+                    if (iKey1 == null) {\n+                        Object old = iValue2;\n+                        iHash1 = iHash2;\n+                        iKey1 = iKey2;\n+                        iValue1 = iValue2;\n+                        iHash2 = 0;\n+                        iKey2 = null;\n+                        iValue2 = null;\n+                        iSize = 1;\n+                        return old;\n+                    }\n+                    return null;\n+                case 1:\n+                    if (iKey1 == null) {\n+                        Object old = iValue1;\n+                        iHash1 = 0;\n+                        iKey1 = null;\n+                        iValue1 = null;\n+                        iSize = 0;\n+                        return old;\n+                    }\n+            }\n+        } else {\n+            if (iSize > 0) {\n+                int hashCode = key.hashCode();\n+                switch (iSize) {  // drop through\n+                    case 3:\n+                        if (iHash3 == hashCode && key.equals(iKey3)) {\n+                            Object old = iValue3;\n+                            iHash3 = 0;\n+                            iKey3 = null;\n+                            iValue3 = null;\n+                            iSize = 2;\n+                            return old;\n+                        }\n+                        if (iHash2 == hashCode && key.equals(iKey2)) {\n+                            Object old = iValue3;\n+                            iHash2 = iHash3;\n+                            iKey2 = iKey3;\n+                            iValue2 = iValue3;\n+                            iHash3 = 0;\n+                            iKey3 = null;\n+                            iValue3 = null;\n+                            iSize = 2;\n+                            return old;\n+                        }\n+                        if (iHash1 == hashCode && key.equals(iKey1)) {\n+                            Object old = iValue3;\n+                            iHash1 = iHash3;\n+                            iKey1 = iKey3;\n+                            iValue1 = iValue3;\n+                            iHash3 = 0;\n+                            iKey3 = null;\n+                            iValue3 = null;\n+                            iSize = 2;\n+                            return old;\n+                        }\n+                        return null;\n+                    case 2:\n+                        if (iHash2 == hashCode && key.equals(iKey2)) {\n+                            Object old = iValue2;\n+                            iHash2 = 0;\n+                            iKey2 = null;\n+                            iValue2 = null;\n+                            iSize = 1;\n+                            return old;\n+                        }\n+                        if (iHash1 == hashCode && key.equals(iKey1)) {\n+                            Object old = iValue2;\n+                            iHash1 = iHash2;\n+                            iKey1 = iKey2;\n+                            iValue1 = iValue2;\n+                            iHash2 = 0;\n+                            iKey2 = null;\n+                            iValue2 = null;\n+                            iSize = 1;\n+                            return old;\n+                        }\n+                        return null;\n+                    case 1:\n+                        if (iHash1 == hashCode && key.equals(iKey1)) {\n+                            Object old = iValue1;\n+                            iHash1 = 0;\n+                            iKey1 = null;\n+                            iValue1 = null;\n+                            iSize = 0;\n+                            return old;\n+                        }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Clears the map, resetting the size to zero and nullifying references\n+     * to avoid garbage collection issues.\n+     */\n+    public void clear() {\n+        if (iMap != null) {\n+            iMap.clear();\n+        }\n+        iSize = 0;\n+        iHash1 = iHash2 = iHash3 = 0;\n+        iKey1 = iKey2 = iKey3 = iValue1 = iValue2 = iValue3 = null;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets an iterator over the map.\n+     * Changes made to the iterator affect this map.\n+     * <p>\n+     * A MapIterator returns the keys in the map. It also provides convenient\n+     * methods to get the key and value, and set the value.\n+     * It avoids the need to create an entrySet/keySet/values object.\n+     * It also avoids creating the Mep Entry object.\n+     * \n+     * @return the map iterator\n+     */\n+    public MapIterator mapIterator() {\n+        if (iMap != null) {\n+            return new DefaultMapIterator(this);\n+        }\n+        if (iSize == 0) {\n+            return IteratorUtils.EMPTY_MAP_ITERATOR;\n+        }\n+        return new FlatMapIterator(this);\n+    }\n+\n+    /**\n+     * FlatMapIterator\n+     */\n+    static class FlatMapIterator implements ResetableMapIterator {\n+        private final Flat3Map iFlatMap;\n+        private int iIndex = 0;\n+        private boolean iCanRemove = false;\n+        \n+        FlatMapIterator(Flat3Map map) {\n+            super();\n+            iFlatMap = map;\n+        }\n+\n+        public boolean hasNext() {\n+            return (iIndex < iFlatMap.iSize);\n+        }\n+\n+        public Object next() {\n+            if (hasNext() == false) {\n+                throw new NoSuchElementException(\"No more elements in the iteration\");\n+            }\n+            iCanRemove = true;\n+            iIndex++;\n+            return getKey();\n+        }\n+\n+        public void remove() {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            iFlatMap.remove(getKey());\n+            iIndex--;\n+            iCanRemove = false;\n+        }\n+\n+        public Object getKey() {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+            }\n+            switch (iIndex) {\n+                case 3:\n+                    return iFlatMap.iKey3;\n+                case 2:\n+                    return iFlatMap.iKey2;\n+                case 1:\n+                    return iFlatMap.iKey1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public Object getValue() {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+            }\n+            switch (iIndex) {\n+                case 3:\n+                    return iFlatMap.iValue3;\n+                case 2:\n+                    return iFlatMap.iValue2;\n+                case 1:\n+                    return iFlatMap.iValue1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public Object setValue(Object value) {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Map Entry cannot be changed\");\n+            }\n+            Object old = getValue();\n+            switch (iIndex) {\n+                case 3: \n+                    iFlatMap.iValue3 = value;\n+                case 2:\n+                    iFlatMap.iValue2 = value;\n+                case 1:\n+                    iFlatMap.iValue1 = value;\n+            }\n+            return old;\n+        }\n+        \n+        public void reset() {\n+            iIndex = 0;\n+            iCanRemove = false;\n+        }\n+        \n+        public Entry asMapEntry() {\n+            return new AbstractMapEntry(getKey(), getValue()) {\n+                public Object setValue(Object value) {\n+                    FlatMapIterator.this.setValue(value);\n+                    return super.setValue(value);\n+                }\n+            };\n+        }\n+        \n+        public String toString() {\n+            if (iCanRemove) {\n+                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n+            } else {\n+                return \"MapIterator[]\";\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Gets the entrySet view of the map.\n+     * Changes made to the view affect this map.\n+     * The Map Entry is not an independent object and changes as the \n+     * iterator progresses.\n+     * To simply iterate through the entries, use {@link #mapIterator()}.\n+     * \n+     * @return the entrySet view\n+     */\n+    public Set entrySet() {\n+        if (iMap != null) {\n+            return iMap.entrySet();\n+        }\n+        return new EntrySet(this);\n+    }\n+    \n+    /**\n+     * EntrySet\n+     */\n+    static class EntrySet extends AbstractSet {\n+        private final Flat3Map iFlatMap;\n+        \n+        EntrySet(Flat3Map map) {\n+            super();\n+            iFlatMap = map;\n+        }\n+\n+        public int size() {\n+            return iFlatMap.size();\n+        }\n+        \n+        public void clear() {\n+            iFlatMap.clear();\n+        }\n+        \n+        public boolean remove(Object obj) {\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry entry = (Map.Entry) obj;\n+            Object key = entry.getKey();\n+            boolean result = iFlatMap.containsKey(key);\n+            iFlatMap.remove(key);\n+            return result;\n+        }\n+\n+        public Iterator iterator() {\n+            if (iFlatMap.iMap != null) {\n+                return iFlatMap.iMap.entrySet().iterator();\n+            }\n+            if (iFlatMap.size() == 0) {\n+                return IteratorUtils.EMPTY_ITERATOR;\n+            }\n+            return new EntrySetIterator(iFlatMap);\n+        }\n+    }\n+\n+    /**\n+     * EntrySetIterator and MapEntry\n+     */\n+    static class EntrySetIterator implements Iterator, Map.Entry {\n+        private final Flat3Map iFlatMap;\n+        private int iIndex = 0;\n+        private boolean iCanRemove = false;\n+        \n+        EntrySetIterator(Flat3Map map) {\n+            super();\n+            iFlatMap = map;\n+        }\n+\n+        public boolean hasNext() {\n+            return (iIndex < iFlatMap.iSize);\n+        }\n+\n+        public Object next() {\n+            if (hasNext() == false) {\n+                throw new NoSuchElementException(\"No more elements in the iteration\");\n+            }\n+            iCanRemove = true;\n+            iIndex++;\n+            return this;\n+        }\n+\n+        public void remove() {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n+            }\n+            iFlatMap.remove(getKey());\n+            iIndex--;\n+            iCanRemove = false;\n+        }\n+\n+        public Object getKey() {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+            }\n+            switch (iIndex) {\n+                case 3:\n+                    return iFlatMap.iKey3;\n+                case 2:\n+                    return iFlatMap.iKey2;\n+                case 1:\n+                    return iFlatMap.iKey1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public Object getValue() {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Map Entry cannot be queried\");\n+            }\n+            switch (iIndex) {\n+                case 3:\n+                    return iFlatMap.iValue3;\n+                case 2:\n+                    return iFlatMap.iValue2;\n+                case 1:\n+                    return iFlatMap.iValue1;\n+            }\n+            throw new IllegalStateException(\"Invalid map index\");\n+        }\n+\n+        public Object setValue(Object value) {\n+            if (iCanRemove == false) {\n+                throw new IllegalStateException(\"Map Entry cannot be changed\");\n+            }\n+            Object old = getValue();\n+            switch (iIndex) {\n+                case 3: \n+                    iFlatMap.iValue3 = value;\n+                case 2:\n+                    iFlatMap.iValue2 = value;\n+                case 1:\n+                    iFlatMap.iValue1 = value;\n+            }\n+            return old;\n+        }\n+        \n+        public boolean equals(Object obj) {\n+            if (iCanRemove == false) {\n+                return false;\n+            }\n+            if (obj instanceof Map.Entry == false) {\n+                return false;\n+            }\n+            Map.Entry other = (Map.Entry) obj;\n+            Object key = getKey();\n+            Object value = getValue();\n+            return (key == null ? other.getKey() == null : key.equals(other.getKey())) &&\n+                   (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+        }\n+        \n+        public int hashCode() {\n+            if (iCanRemove == false) {\n+                return 0;\n+            }\n+            Object key = getKey();\n+            Object value = getValue();\n+            return (key == null ? 0 : key.hashCode()) ^\n+                   (value == null ? 0 : value.hashCode());\n+        }\n+        \n+        public String toString() {\n+            if (iCanRemove) {\n+                return getKey() + \"=\" + getValue();\n+            } else {\n+                return \"\";\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Gets the keySet view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the keys, use {@link #mapIterator()}.\n+     * \n+     * @return the keySet view\n+     */\n+    public Set keySet() {\n+        if (iMap != null) {\n+            return iMap.keySet();\n+        }\n+        return new KeySet(this);\n+    }\n+\n+    /**\n+     * KeySet\n+     */\n+    static class KeySet extends AbstractSet {\n+        private final Flat3Map iFlatMap;\n+        \n+        KeySet(Flat3Map map) {\n+            super();\n+            iFlatMap = map;\n+        }\n+\n+        public int size() {\n+            return iFlatMap.size();\n+        }\n+        \n+        public void clear() {\n+            iFlatMap.clear();\n+        }\n+        \n+        public boolean contains(Object key) {\n+            return iFlatMap.containsKey(key);\n+        }\n+\n+        public boolean remove(Object key) {\n+            boolean result = iFlatMap.containsKey(key);\n+            iFlatMap.remove(key);\n+            return result;\n+        }\n+\n+        public Iterator iterator() {\n+            if (iFlatMap.iMap != null) {\n+                return iFlatMap.iMap.keySet().iterator();\n+            }\n+            if (iFlatMap.size() == 0) {\n+                return IteratorUtils.EMPTY_ITERATOR;\n+            }\n+            return new KeySetIterator(iFlatMap);\n+        }\n+    }\n+\n+    /**\n+     * KeySetIterator\n+     */\n+    static class KeySetIterator extends EntrySetIterator {\n+        \n+        KeySetIterator(Flat3Map map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            super.next();\n+            return getKey();\n+        }\n+    }\n+    \n+    /**\n+     * Gets the values view of the map.\n+     * Changes made to the view affect this map.\n+     * To simply iterate through the values, use {@link #mapIterator()}.\n+     * \n+     * @return the values view\n+     */\n+    public Collection values() {\n+        if (iMap != null) {\n+            return iMap.values();\n+        }\n+        return new Values(this);\n+    }\n+\n+    /**\n+     * Values\n+     */\n+    static class Values extends AbstractCollection {\n+        private final Flat3Map iFlatMap;\n+        \n+        Values(Flat3Map map) {\n+            super();\n+            iFlatMap = map;\n+        }\n+\n+        public int size() {\n+            return iFlatMap.size();\n+        }\n+        \n+        public void clear() {\n+            iFlatMap.clear();\n+        }\n+        \n+        public boolean contains(Object value) {\n+            return iFlatMap.containsValue(value);\n+        }\n+\n+        public Iterator iterator() {\n+            if (iFlatMap.iMap != null) {\n+                return iFlatMap.iMap.values().iterator();\n+            }\n+            if (iFlatMap.size() == 0) {\n+                return IteratorUtils.EMPTY_ITERATOR;\n+            }\n+            return new ValuesIterator(iFlatMap);\n+        }\n+    }\n+\n+    /**\n+     * ValuesIterator\n+     */\n+    static class ValuesIterator extends EntrySetIterator {\n+        \n+        ValuesIterator(Flat3Map map) {\n+            super(map);\n+        }\n+\n+        public Object next() {\n+            super.next();\n+            return getValue();\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Compares this map with another.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (iMap != null) {\n+            return iMap.equals(obj);\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map other = (Map) obj;\n+        if (iSize != other.size()) {\n+            return false;\n+        }\n+        if (iSize > 0) {\n+            Object otherValue = null;\n+            switch (iSize) {  // drop through\n+                case 3:\n+                    if (other.containsKey(iKey3) == false) {\n+                        otherValue = other.get(iKey3);\n+                        if (iValue3 == null ? otherValue != null : !iValue3.equals(otherValue)) {\n+                            return false;\n+                        }\n+                    }\n+                case 2:\n+                    if (other.containsKey(iKey2) == false) {\n+                        otherValue = other.get(iKey2);\n+                        if (iValue2 == null ? otherValue != null : !iValue2.equals(otherValue)) {\n+                            return false;\n+                        }\n+                    }\n+                case 1:\n+                    if (other.containsKey(iKey1) == false) {\n+                        otherValue = other.get(iKey1);\n+                        if (iValue1 == null ? otherValue != null : !iValue1.equals(otherValue)) {\n+                            return false;\n+                        }\n+                    }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Gets the standard Map hashCode.\n+     * \n+     * @return the hashcode defined in the Map interface\n+     */\n+    public int hashCode() {\n+        if (iMap != null) {\n+            return iMap.hashCode();\n+        }\n+        int total = 0;\n+        switch (iSize) {  // drop through\n+            case 3:\n+                total += (iHash3 ^ (iValue3 == null ? 0 : iValue3.hashCode()));\n+            case 2:\n+                total += (iHash2 ^ (iValue2 == null ? 0 : iValue2.hashCode()));\n+            case 1:\n+                total += (iHash1 ^ (iValue1 == null ? 0 : iValue1.hashCode()));\n+        }\n+        return total;\n+    }\n+\n+    /**\n+     * Gets the map as a String.\n+     * \n+     * @return a string version of the map\n+     */\n+    public String toString() {\n+        if (iMap != null) {\n+            return iMap.toString();\n+        }\n+        if (iSize == 0) {\n+            return \"{}\";\n+        }\n+        StringBuffer buf = new StringBuffer(128);\n+        buf.append('{');\n+        switch (iSize) {  // drop through\n+            case 3:\n+                buf.append(iKey3);\n+                buf.append('=');\n+                buf.append(iValue3);\n+                buf.append(',');\n+            case 2:\n+                buf.append(iKey2);\n+                buf.append('=');\n+                buf.append(iValue2);\n+                buf.append(',');\n+            case 1:\n+                buf.append(iKey1);\n+                buf.append('=');\n+                buf.append(iValue1);\n+        }\n+        buf.append('}');\n+        return buf.toString();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestFlat3Map.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestFlat3Map.java,v 1.1 2003/11/02 23:41:46 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.textui.TestRunner;\n+\n+import org.apache.commons.collections.iterators.AbstractTestMapIterator;\n+import org.apache.commons.collections.iterators.MapIterator;\n+\n+/**\n+ * JUnit tests.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/02 23:41:46 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestFlat3Map extends AbstractTestMap {\n+\n+    public TestFlat3Map(String testName) {\n+        super(testName);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestRunner.run(suite());\n+    }\n+    \n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestFlat3Map.class);\n+    }\n+\n+    protected Map makeEmptyMap() {\n+        return new Flat3Map();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public BulkTest bulkTestMapIterator() {\n+        return new TestFlatMapIterator();\n+    }\n+    \n+    public class TestFlatMapIterator extends AbstractTestMapIterator {\n+        public TestFlatMapIterator() {\n+            super(\"TestFlatMapIterator\");\n+        }\n+        \n+        protected Object addSetValue() {\n+            return TestFlat3Map.this.getNewSampleValues()[0];\n+        }\n+        \n+        protected boolean supportsRemove() {\n+            return TestFlat3Map.this.isRemoveSupported();\n+        }\n+\n+        protected boolean supportsSetValue() {\n+            return TestFlat3Map.this.isSetValueSupported();\n+        }\n+\n+        protected MapIterator makeEmptyMapIterator() {\n+            resetEmpty();\n+            return ((Flat3Map) TestFlat3Map.this.map).mapIterator();\n+        }\n+\n+        protected MapIterator makeFullMapIterator() {\n+            resetFull();\n+            return ((Flat3Map) TestFlat3Map.this.map).mapIterator();\n+        }\n+        \n+        protected Map getMap() {\n+            // assumes makeFullMapIterator() called first\n+            return TestFlat3Map.this.map;\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            // cannot cross verify as we don't know what superclass did\n+        }\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorRemove() {\n+        resetFull();\n+        Flat3Map testMap = (Flat3Map) map;\n+        MapIterator it = testMap.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key = it.next();\n+        \n+        if (isRemoveSupported() == false) {\n+            try {\n+                it.remove();\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+        \n+        it.remove();\n+        confirmed.remove(key);\n+        assertEquals(false, testMap.containsKey(key));\n+        verify();\n+        \n+        try {\n+            it.remove();  // second remove fails\n+        } catch (IllegalStateException ex) {\n+        }\n+        verify();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public void testMapIteratorSet() {\n+        Object newValue1 = getOtherValues()[0];\n+        Object newValue2 = getOtherValues()[1];\n+        \n+        resetFull();\n+        Flat3Map testMap = (Flat3Map) map;\n+        MapIterator it = testMap.mapIterator();\n+        assertEquals(true, it.hasNext());\n+        Object key1 = it.next();\n+        \n+        if (isSetValueSupported() == false) {\n+            try {\n+                it.setValue(newValue1);\n+                fail();\n+            } catch (UnsupportedOperationException ex) {\n+            }\n+            return;\n+        }\n+        \n+        it.setValue(newValue1);\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, testMap.containsKey(key1));\n+        assertEquals(true, testMap.containsValue(newValue1));\n+        assertEquals(newValue1, testMap.get(key1));\n+        verify();\n+        \n+        it.setValue(newValue1);  // same value - should be OK\n+        confirmed.put(key1, newValue1);\n+        assertSame(key1, it.getKey());\n+        assertSame(newValue1, it.getValue());\n+        assertEquals(true, testMap.containsKey(key1));\n+        assertEquals(true, testMap.containsValue(newValue1));\n+        assertEquals(newValue1, testMap.get(key1));\n+        verify();\n+        \n+        Object key2 = it.next();\n+        it.setValue(newValue2);\n+        confirmed.put(key2, newValue2);\n+        assertSame(key2, it.getKey());\n+        assertSame(newValue2, it.getValue());\n+        assertEquals(true, testMap.containsKey(key2));\n+        assertEquals(true, testMap.containsValue(newValue2));\n+        assertEquals(newValue2, testMap.get(key2));\n+        verify();\n+    }\n+\n+}", "timestamp": 1067816506, "metainfo": ""}