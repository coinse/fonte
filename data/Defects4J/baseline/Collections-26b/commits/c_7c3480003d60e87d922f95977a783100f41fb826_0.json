{"sha": "7c3480003d60e87d922f95977a783100f41fb826", "log": "Rename TestMap to AbstractTestMap Rename TestSortedMap to AbstractTestSortedMap Javadoc and tidy   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/AbstractTestMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestMap.java,v 1.1 2003/10/02 23:01:09 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Abstract test class for {@link java.util.Map} methods and contracts.\n+ * <p>\n+ * The forces at work here are similar to those in {@link AbstractTestCollection}.\n+ * If your class implements the full Map interface, including optional\n+ * operations, simply extend this class, and implement the {@link\n+ * #makeEmptyMap()} method.\n+ * <p>\n+ * On the other hand, if your map implementation is weird, you may have to\n+ * override one or more of the other protected methods.  They're described\n+ * below.\n+ * <p>\n+ * <B>Entry Population Methods</B><P>\n+ *\n+ * Override these methods if your map requires special entries:\n+ *\n+ * <UL>\n+ * <LI>{@link #getSampleKeys()}\n+ * <LI>{@link #getSampleValues()}\n+ * <LI>{@link #getNewSampleValues()}\n+ * <LI>{@link #getOtherKeys()}\n+ * <LI>{@link #getOtherValues()}\n+ * </UL>\n+ *\n+ * <B>Supported Operation Methods</B><P>\n+ *\n+ * Override these methods if your map doesn't support certain operations:\n+ *\n+ * <UL>\n+ * <LI> {@link #useDuplicateValues()}\n+ * <LI> {@link #useNullKey()}\n+ * <LI> {@link #useNullValue()}\n+ * <LI> {@link #isAddRemoveModifiable()}\n+ * <LI> {@link #isChangeable()}\n+ * </UL>\n+ *\n+ * <B>Fixture Methods</B><P>\n+ *\n+ * For tests on modification operations (puts and removes), fixtures are used\n+ * to verify that that operation results in correct state for the map and its\n+ * collection views.  Basically, the modification is performed against your\n+ * map implementation, and an identical modification is performed against\n+ * a <I>confirmed</I> map implementation.  A confirmed map implementation is\n+ * something like <Code>java.util.HashMap</Code>, which is known to conform\n+ * exactly to the {@link Map} contract.  After the modification takes place\n+ * on both your map implementation and the confirmed map implementation, the\n+ * two maps are compared to see if their state is identical.  The comparison\n+ * also compares the collection views to make sure they're still the same.<P>\n+ *\n+ * The upshot of all that is that <I>any</I> test that modifies the map in\n+ * <I>any</I> way will verify that <I>all</I> of the map's state is still\n+ * correct, including the state of its collection views.  So for instance\n+ * if a key is removed by the map's key set's iterator, then the entry set \n+ * is checked to make sure the key/value pair no longer appears.<P>\n+ *\n+ * The {@link #map} field holds an instance of your collection implementation.\n+ * The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold\n+ * that map's collection views.  And the {@link #confirmed} field holds\n+ * an instance of the confirmed collection implementation.  The \n+ * {@link #resetEmpty()} and {@link #resetFull()} methods set these fields to \n+ * empty or full maps, so that tests can proceed from a known state.<P>\n+ *\n+ * After a modification operation to both {@link #map} and {@link #confirmed},\n+ * the {@link #verify()} method is invoked to compare the results.  The {@link\n+ * verify()} method calls separate methods to verify the map and its three\n+ * collection views ({@link verifyMap(), {@link verifyEntrySet()}, {@link\n+ * verifyKeySet()}, and {@link verifyValues()}).  You may want to override one\n+ * of the verification methodsto perform additional verifications.  For\n+ * instance, {@link TestDoubleOrderedMap} would want override its\n+ * {@link #verifyValues()} method to verify that the values are unique and in\n+ * ascending order.<P>\n+ *  \n+ * <B>Other Notes</B><P>\n+ *\n+ * If your {@link Map} fails one of these tests by design, you may still use\n+ * this base set of cases.  Simply override the test case (method) your {@link\n+ * Map} fails and/or the methods that define the assumptions used by the test\n+ * cases.  For example, if your map does not allow duplicate values, override\n+ * {@link #useDuplicateValues()} and have it return <code>false</code>\n+ *\n+ * @author Michael Smith\n+ * @author Rodney Waldhoff\n+ * @author Paul Jack\n+ * @version $Revision: 1.1 $ $Date: 2003/10/02 23:01:09 $\n+ */\n+public abstract class AbstractTestMap extends AbstractTestObject {\n+\n+    // These instance variables are initialized with the reset method.\n+    // Tests for map methods that alter the map (put, putAll, remove) \n+    // first call reset() to create the map and its views; then perform\n+    // the modification on the map; perform the same modification on the\n+    // confirmed; and then call verify() to ensure that the map is equal\n+    // to the confirmed, that the already-constructed collection views\n+    // are still equal to the confirmed's collection views.\n+\n+\n+    /** Map created by reset(). */\n+    protected Map map;\n+\n+    /** Entry set of map created by reset(). */\n+    protected Set entrySet;\n+\n+    /** Key set of map created by reset(). */\n+    protected Set keySet;\n+\n+    /** Values collection of map created by reset(). */\n+    protected Collection values;\n+\n+    /** HashMap created by reset(). */\n+    protected Map confirmed;\n+\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public AbstractTestMap(String testName) {\n+        super(testName);\n+    }\n+\n+\n+    /**\n+     *  Override if your map does not allow a <code>null</code> key.  The\n+     *  default implementation returns <code>true</code>\n+     */\n+    protected boolean useNullKey() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map does not allow <code>null</code> values.  The\n+     *  default implementation returns <code>true</code>.\n+     */\n+    protected boolean useNullValue() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map does not allow duplicate values.  The default\n+     *  implementation returns <code>true</code>.\n+     */\n+    protected boolean useDuplicateValues() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map allows its mappings to be changed to new values.\n+     *  The default implementation returns <code>true</code>.\n+     */\n+    protected boolean isChangeable() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Override if your map does not allow add/remove modifications.  The\n+     *  default implementation returns <code>true</code>.\n+     */\n+    protected boolean isAddRemoveModifiable() {\n+        return true;\n+    }\n+\n+    /**\n+     *  Returns the set of keys in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleValues()} and all array elements must be different. The\n+     *  default implementation constructs a set of String keys, and includes a\n+     *  single null key if {@link #useNullKey()} returns <code>true</code>.\n+     */\n+    protected Object[] getSampleKeys() {\n+        Object[] result = new Object[] {\n+            \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\", \n+            \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\",\n+            \"key\",\n+            \"key2\",\n+            (useNullKey()) ? null : \"nonnullkey\"\n+        };\n+        return result;\n+    }\n+\n+\n+    protected Object[] getOtherKeys() {\n+        return getOtherNonNullStringElements();\n+    }\n+\n+    protected Object[] getOtherValues() {\n+        return getOtherNonNullStringElements();\n+    }\n+\n+    /**\n+     *  Returns a list of string elements suitable for return by\n+     *  {@link getOtherElements()}.  Override getOtherElements to return\n+     *  the results of this method if your collection does not support\n+     *  heterogenous elements or the null element.\n+     */\n+    protected Object[] getOtherNonNullStringElements() {\n+        return new Object[] {\n+            \"For\",\"then\",\"despite\",/* of */\"space\",\"I\",\"would\",\"be\",\"brought\",\n+            \"From\",\"limits\",\"far\",\"remote\",\"where\",\"thou\",\"dost\",\"stay\"\n+        };\n+    }\n+\n+    /**\n+     *  Returns the set of values in the mappings used to test the map.  This\n+     *  method must return an array with the same length as {@link\n+     *  #getSampleKeys()}.  The default implementation constructs a set of\n+     *  String values and includes a single null value if {@link\n+     *  #useNullValue()} returns <code>true</code>, and includes two values\n+     *  that are the same if {@link #useDuplicateValues()} returns\n+     *  <code>true</code>.\n+     */\n+    protected Object[] getSampleValues() {\n+        Object[] result = new Object[] {\n+            \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\",\n+            \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\", \"againv\",\n+            (useNullValue()) ? null : \"nonnullvalue\",\n+            \"value\",\n+            (useDuplicateValues()) ? \"value\" : \"value2\",\n+        };\n+        return result;\n+    }\n+\n+    /**\n+     *  Returns a the set of values that can be used to replace the values\n+     *  returned from {@link #getSampleValues()}.  This method must return an\n+     *  array with the same length as {@link #getSampleValues()}.  The values\n+     *  returned from this method should not be the same as those returned from\n+     *  {@link #getSampleValues()}.  The default implementation constructs a\n+     *  set of String values and includes a single null value if {@link\n+     *  #useNullValue()} returns <code>true</code>, and includes two values\n+     *  that are the same if {@link #useDuplicateValues()} returns\n+     *  <code>true</code>.  \n+     */\n+    protected Object[] getNewSampleValues() {\n+        Object[] result = new Object[] {\n+            (useNullValue()) ? null : \"newnonnullvalue\",\n+            \"newvalue\",\n+            (useDuplicateValues()) ? \"newvalue\" : \"newvalue2\",\n+            \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\", \n+            \"newgollyv\", \"newgeev\", \"newhellov\", \"newgoodbyev\", \"newwe'llv\", \n+            \"newseev\", \"newyouv\", \"newallv\", \"newagainv\",\n+        };\n+        return result;\n+    }\n+\n+    /**\n+     *  Helper method to add all the mappings described by {@link\n+     *  #getSampleKeys()} and {@link #getSampleValues()}.\n+     */\n+    protected void addSampleMappings(Map m) {\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        \n+        for(int i = 0; i < keys.length; i++) {\n+            try {\n+                m.put(keys[i], values[i]);\n+            } catch (NullPointerException exception) {\n+                assertTrue(\"NullPointerException only allowed to be thrown \" +\n+                           \"if either the key or value is null.\", \n+                           keys[i] == null || values[i] == null);\n+                \n+                assertTrue(\"NullPointerException on null key, but \" +\n+                           \"useNullKey is not overridden to return false.\", \n+                           keys[i] == null || !useNullKey());\n+                \n+                assertTrue(\"NullPointerException on null value, but \" +\n+                           \"useNullValue is not overridden to return false.\",\n+                           values[i] == null || !useNullValue());\n+                \n+                assertTrue(\"Unknown reason for NullPointer.\", false);\n+            }\n+        }\n+        assertEquals(\"size must reflect number of mappings added.\",\n+                     keys.length, m.size());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Return a new, empty {@link Map} to be used for testing. \n+     * \n+     * @return the map to be tested\n+     */\n+    protected abstract Map makeEmptyMap();\n+\n+    /**\n+     * Return a new, populated map.  The mappings in the map should match the\n+     * keys and values returned from {@link #getSampleKeys()} and {@link\n+     * #getSampleValues()}.  The default implementation uses makeEmptyMap()\n+     * and calls {@link #addSampleMappings()} to add all the mappings to the\n+     * map.\n+     * \n+     * @return the map to be tested\n+     */\n+    protected Map makeFullMap() {\n+        Map m = makeEmptyMap();\n+        addSampleMappings(m);\n+        return m;\n+    }\n+\n+    /**\n+     * Implements the superclass method to return the map to be tested.\n+     * \n+     * @return the map to be tested\n+     */\n+    public Object makeObject() {\n+        return makeEmptyMap();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Test to ensure the test setup is working properly.  This method checks\n+     *  to ensure that the getSampleKeys and getSampleValues methods are\n+     *  returning results that look appropriate.  That is, they both return a\n+     *  non-null array of equal length.  The keys array must not have any\n+     *  duplicate values, and may only contain a (single) null key if\n+     *  useNullKey() returns true.  The values array must only have a null\n+     *  value if useNullValue() is true and may only have duplicate values if\n+     *  useDuplicateValues() returns true.  \n+     */\n+    public void testSampleMappings() {\n+      Object[] keys = getSampleKeys();\n+      Object[] values = getSampleValues();\n+      Object[] newValues = getNewSampleValues();\n+\n+      assertTrue(\"failure in test: Must have keys returned from \" +\n+                 \"getSampleKeys.\", keys != null);\n+\n+      assertTrue(\"failure in test: Must have values returned from \" +\n+                 \"getSampleValues.\", values != null);\n+\n+      // verify keys and values have equivalent lengths (in case getSampleX are\n+      // overridden)\n+      assertEquals(\"failure in test: not the same number of sample \" +\n+                   \"keys and values.\",  keys.length, values.length);\n+      \n+      assertEquals(\"failure in test: not the same number of values and new values.\",\n+                   values.length, newValues.length);\n+\n+      // verify there aren't duplicate keys, and check values\n+      for(int i = 0; i < keys.length - 1; i++) {\n+          for(int j = i + 1; j < keys.length; j++) {\n+              assertTrue(\"failure in test: duplicate null keys.\",\n+                         (keys[i] != null || keys[j] != null));\n+              assertTrue(\"failure in test: duplicate non-null key.\",\n+                         (keys[i] == null || keys[j] == null || \n+                          (!keys[i].equals(keys[j]) && \n+                           !keys[j].equals(keys[i]))));\n+          }\n+          assertTrue(\"failure in test: found null key, but useNullKey \" +\n+                     \"is false.\", keys[i] != null || useNullKey());\n+          assertTrue(\"failure in test: found null value, but useNullValue \" +\n+                     \"is false.\", values[i] != null || useNullValue());\n+          assertTrue(\"failure in test: found null new value, but useNullValue \" +\n+                     \"is false.\", newValues[i] != null || useNullValue());\n+          assertTrue(\"failure in test: values should not be the same as new value\",\n+                     values[i] != newValues[i] && \n+                     (values[i] == null || !values[i].equals(newValues[i])));\n+      }\n+    }\n+    \n+    // tests begin here.  Each test adds a little bit of tested functionality.\n+    // Many methods assume previous methods passed.  That is, they do not\n+    // exhaustively recheck things that have already been checked in a previous\n+    // test methods.  \n+\n+    /**\n+     *  Test to ensure that makeEmptyMap and makeFull returns a new non-null\n+     *  map with each invocation.  \n+     */\n+    public void testMakeMap() {\n+        Map em = makeEmptyMap();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+        \n+        Map em2 = makeEmptyMap();\n+        assertTrue(\"failure in test: makeEmptyMap must return a non-null map.\",\n+                   em != null);\n+\n+        assertTrue(\"failure in test: makeEmptyMap must return a new map \" +\n+                   \"with each invocation.\", em != em2);\n+\n+        Map fm = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+        \n+        Map fm2 = makeFullMap();\n+        assertTrue(\"failure in test: makeFullMap must return a non-null map.\",\n+                   fm != null);\n+\n+        assertTrue(\"failure in test: makeFullMap must return a new map \" +\n+                   \"with each invocation.\", fm != fm2);\n+    }\n+\n+    /**\n+     *  Tests Map.isEmpty()\n+     */\n+    public void testMapIsEmpty() {\n+        resetEmpty();\n+        assertEquals(\"Map.isEmpty() should return true with an empty map\", \n+                     true, map.isEmpty());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.isEmpty() should return false with a non-empty map\",\n+                     false, map.isEmpty());\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests Map.size()\n+     */\n+    public void testMapSize() {\n+        resetEmpty();\n+        assertEquals(\"Map.size() should be 0 with an empty map\",\n+                     0, map.size());\n+        verify();\n+\n+        resetFull();\n+        assertEquals(\"Map.size() should equal the number of entries \" +\n+                     \"in the map\", getSampleKeys().length, map.size());\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests {@link Map#clear()}.  If the map {@link #isAddRemoveModifiable()\n+     *  can add and remove elements}, then {@link Map#size()} and {@link\n+     *  Map#isEmpty()} are used to ensure that map has no elements after a call\n+     *  to clear.  If the map does not support adding and removing elements,\n+     *  this method checks to ensure clear throws an\n+     *  UnsupportedOperationException.\n+     */\n+    public void testMapClear() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        resetEmpty();\n+        map.clear();\n+        confirmed.clear();\n+        verify();\n+        \n+        resetFull();\n+        map.clear();\n+        confirmed.clear();\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests Map.containsKey(Object) by verifying it returns false for all\n+     *  sample keys on a map created using an empty map and returns true for\n+     *  all sample keys returned on a full map. \n+     */\n+    public void testMapContainsKey() {\n+        Object[] keys = getSampleKeys();\n+\n+        resetEmpty();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must not contain key when map is empty\", \n+                       !map.containsKey(keys[i]));\n+        }\n+        verify();\n+\n+        resetFull();\n+        for(int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Map must contain key for a mapping in the map. \" +\n+                       \"Missing: \" + keys[i], map.containsKey(keys[i]));\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests Map.containsValue(Object) by verifying it returns false for all\n+     *  sample values on an empty map and returns true for all sample values on\n+     *  a full map.\n+     */\n+    public void testMapContainsValue() {\n+        Object[] values = getSampleValues();\n+\n+        resetEmpty();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Empty map must not contain value\", \n+                       !map.containsValue(values[i]));\n+        }\n+        verify();\n+        \n+        resetFull();\n+        for(int i = 0; i < values.length; i++) {\n+            assertTrue(\"Map must contain value for a mapping in the map.\", \n+                       map.containsValue(values[i]));\n+        }\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests Map.equals(Object)\n+     */\n+    public void testMapEquals() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps unequal.\", map.equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Full maps unequal.\", map.equals(confirmed));\n+        verify();\n+\n+        resetFull();\n+        // modify the HashMap created from the full map and make sure this\n+        // change results in map.equals() to return false.\n+        Iterator iter = confirmed.keySet().iterator();\n+        iter.next();\n+        iter.remove();\n+        assertTrue(\"Different maps equal.\", !map.equals(confirmed));\n+        \n+        resetFull();\n+        assertTrue(\"equals(null) returned true.\", !map.equals(null));\n+        assertTrue(\"equals(new Object()) returned true.\", \n+                   !map.equals(new Object()));\n+        verify();\n+    }\n+\n+\n+    /**\n+     *  Tests Map.get(Object)\n+     */\n+    public void testMapGet() {\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+\n+        for (int i = 0; i < keys.length; i++) {\n+            assertTrue(\"Empty map.get() should return null.\", \n+                       map.get(keys[i]) == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+        for (int i = 0; i < keys.length; i++) {\n+            assertEquals(\"Full map.get() should return value from mapping.\", \n+                         values[i], map.get(keys[i]));\n+        }\n+    }\n+\n+    /**\n+     *  Tests Map.hashCode()\n+     */\n+    public void testMapHashCode() {\n+        resetEmpty();\n+        assertTrue(\"Empty maps have different hashCodes.\", \n+                   map.hashCode() == confirmed.hashCode());\n+\n+        resetFull();\n+        assertTrue(\"Equal maps have different hashCodes.\", \n+                   map.hashCode() == confirmed.hashCode());\n+    }\n+\n+    /**\n+     *  Tests Map.toString().  Since the format of the string returned by the\n+     *  toString() method is not defined in the Map interface, there is no\n+     *  common way to test the results of the toString() method.  Thereforce,\n+     *  it is encouraged that Map implementations override this test with one\n+     *  that checks the format matches any format defined in its API.  This\n+     *  default implementation just verifies that the toString() method does\n+     *  not return null.\n+     */\n+    public void testMapToString() {\n+        resetEmpty();\n+        assertTrue(\"Empty map toString() should not return null\", \n+                   map.toString() != null);\n+        verify();\n+\n+        resetFull();\n+        assertTrue(\"Empty map toString() should not return null\", \n+                   map.toString() != null);\n+        verify();\n+    }\n+\n+\n+    /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in CVS.\n+     */\n+    public void testEmptyMapCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeEmptyMap();\n+        if (!(map instanceof Serializable)) return;\n+        \n+        writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        Map map = makeEmptyMap();\n+        if(map instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            Map map2 = (Map) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n+            assertTrue(\"Map is empty\",map2.isEmpty());\n+        }\n+    }\n+\n+        /**\n+     * Compare the current serialized form of the Map\n+     * against the canonical version in CVS.\n+     */\n+    public void testFullMapCompatibility() throws IOException, ClassNotFoundException {\n+        /**\n+         * Create canonical objects with this code\n+        Map map = makeFullMap();\n+        if (!(map instanceof Serializable)) return;\n+        \n+        writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));\n+        */\n+\n+        // test to make sure the canonical form has been preserved\n+        Map map = makeFullMap();\n+        if(map instanceof Serializable && !skipSerializedCanonicalTests()) {\n+            Map map2 = (Map) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n+            assertEquals(\"Map is the right size\",map2.size(), getSampleKeys().length);\n+        }\n+    }\n+\n+    /**\n+     *  Tests Map.put(Object, Object)\n+     */\n+    public void testMapPut() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        Object[] newValues = getNewSampleValues();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            Object o = map.put(keys[i], values[i]);\n+            confirmed.put(keys[i], values[i]);\n+            verify();\n+            assertTrue(\"First map.put should return null\", o == null);\n+            assertTrue(\"Map should contain key after put\", \n+                       map.containsKey(keys[i]));\n+            assertTrue(\"Map should contain value after put\", \n+                       map.containsValue(values[i]));\n+        }\n+        \n+        for(int i = 0; i < keys.length; i++) {\n+            Object o = map.put(keys[i], newValues[i]);\n+            confirmed.put(keys[i], newValues[i]);\n+            verify();\n+            assertEquals(\"Second map.put should return previous value\",\n+                         values[i], o);\n+            assertTrue(\"Map should still contain key after put\",\n+                       map.containsKey(keys[i]));\n+            assertTrue(\"Map should contain new value after put\",\n+                       map.containsValue(newValues[i]));\n+\n+            // if duplicates are allowed, we're not guaranteed that the value\n+            // no longer exists, so don't try checking that.\n+            if(!useDuplicateValues()) {\n+                assertTrue(\"Map should not contain old value after second put\",\n+                           !map.containsValue(values[i]));\n+            }\n+        }\n+    }\n+\n+    /**\n+     *  Tests Map.putAll(Collection)\n+     */\n+    public void testMapPutAll() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        resetEmpty();\n+\n+        Map m2 = makeFullMap();\n+\n+        map.putAll(m2);\n+        confirmed.putAll(m2);\n+        verify();\n+\n+        resetEmpty();\n+\n+        m2 = new HashMap();\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        for(int i = 0; i < keys.length; i++) {\n+            m2.put(keys[i], values[i]);\n+        }\n+\n+        map.putAll(m2);\n+        confirmed.putAll(m2);\n+        verify();\n+    }\n+\n+    /**\n+     *  Tests Map.remove(Object)\n+     */\n+    public void testMapRemove() {\n+        if (!isAddRemoveModifiable()) return;\n+\n+        resetEmpty();\n+\n+        Object[] keys = getSampleKeys();\n+        Object[] values = getSampleValues();\n+        for(int i = 0; i < keys.length; i++) {\n+            Object o = map.remove(keys[i]);\n+            assertTrue(\"First map.remove should return null\", o == null);\n+        }\n+        verify();\n+\n+        resetFull();\n+\n+        for(int i = 0; i < keys.length; i++) {\n+            Object o = map.remove(keys[i]);\n+            confirmed.remove(keys[i]);\n+            verify();\n+\n+            assertEquals(\"map.remove with valid key should return value\",\n+                         values[i], o);\n+        }\n+\n+        Object[] other = getOtherKeys();\n+\n+        resetFull();\n+        int size = map.size();\n+        for (int i = 0; i < other.length; i++) {\n+            Object o = map.remove(other[i]);\n+            assertEquals(\"map.remove for nonexistent key should return null\",\n+                         o, null);\n+            assertEquals(\"map.remove for nonexistent key should not \" +\n+                         \"shrink map\", size, map.size());\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#values} collection is backed by\n+     * the underlying map by removing from the values collection\n+     * and testing if the value was removed from the map.\n+     * <p/>\n+     * We should really test the \"vice versa\" case--that values removed\n+     * from the map are removed from the values collection--also,\n+     * but that's a more difficult test to construct (lacking a\n+     * \"removeValue\" method.)\n+     * \n+     * @see http://issues.apache.org/bugzilla/show_bug.cgi?id=9573\n+     */\n+    public void testValuesRemovedFromValuesCollectionAreRemovedFromMap() {\n+        resetFull();\n+        Object[] sampleValues = getSampleValues();\n+        Collection values = map.values();\n+        for(int i=0;i<sampleValues.length;i++) {\n+            if(map.containsValue(sampleValues[i])) {\n+                while(values.contains(sampleValues[i])) {\n+                    try {\n+                        values.remove(sampleValues[i]);\n+                    } catch(UnsupportedOperationException e) {\n+                        // if values.remove is unsupported, just skip this test\n+                        return;\n+                    }\n+                }\n+                assertTrue(\"Value should have been removed from the underlying map.\",!map.containsValue(sampleValues[i]));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#keySet} set is backed by\n+     * the underlying map by removing from the keySet set\n+     * and testing if the key was removed from the map.\n+     */\n+    public void testValuesRemovedFromKeySetAreRemovedFromMap() {\n+        resetFull();\n+        Object[] sampleKeys = getSampleKeys();\n+        Set keys = map.keySet();\n+        for(int i=0;i<sampleKeys.length;i++) {\n+            try {\n+                keys.remove(sampleKeys[i]);\n+            } catch(UnsupportedOperationException e) {\n+                // if key.remove is unsupported, just skip this test\n+                return;\n+            }\n+            assertTrue(\"Key should have been removed from the underlying map.\",!map.containsKey(sampleKeys[i]));\n+        }\n+    }\n+\n+    // TODO: Need:\n+    //    testValuesRemovedFromEntrySetAreRemovedFromMap\n+    //    same for EntrySet/KeySet/values's\n+    //      Iterator.remove, removeAll, retainAll, clear\n+    // TODO: Also need:\n+    //    Test that EntrySet/KeySet/values all do not allow add/addAll\n+\n+\n+    /**\n+     *  Utility methods to create an array of Map.Entry objects\n+     *  out of the given key and value arrays.<P>\n+     *\n+     *  @param keys    the array of keys\n+     *  @param values  the array of values\n+     *  @return an array of Map.Entry of those keys to those values\n+     */\n+    private Map.Entry[] makeEntryArray(Object[] keys, Object[] values) {\n+        Map.Entry[] result = new Map.Entry[keys.length];\n+        for (int i = 0; i < keys.length; i++) {\n+            result[i] = new DefaultMapEntry(keys[i], values[i]);\n+        }\n+        return result;\n+    }\n+\n+\n+    /**\n+     *  Bulk test {@link Map#entrySet()}.  This method runs through all of\n+     *  the tests in {@link TestSet}.  \n+     *  After modification operations, {@link #verify()} is invoked to ensure\n+     *  that the map and the other collection views are still valid.\n+     *\n+     *  @return a {@link TestSet} instance for testing the map's entry set\n+     */\n+    public BulkTest bulkTestMapEntrySet() {\n+        return new TestMapEntrySet();\n+    }\n+\n+    class TestMapEntrySet extends AbstractTestSet {\n+        public TestMapEntrySet() {\n+            super(\"\");\n+        }\n+\n+        // Have to implement manually; entrySet doesn't support addAll\n+        protected Object[] getFullElements() {\n+            Object[] k = getSampleKeys();\n+            Object[] v = getSampleValues();\n+            return makeEntryArray(k, v);\n+        }\n+        \n+        // Have to implement manually; entrySet doesn't support addAll\n+        protected Object[] getOtherElements() {\n+            Object[] k = getOtherKeys();\n+            Object[] v = getOtherValues();\n+            return makeEntryArray(k, v);\n+        }\n+        \n+        protected Set makeEmptySet() {\n+            return makeEmptyMap().entrySet();\n+        }\n+        \n+        protected Set makeFullSet() {\n+            return makeFullMap().entrySet();\n+        }\n+        \n+        protected boolean isAddSupported() {\n+            // Collection views don't support add operations.\n+            return false;\n+        }\n+        \n+        protected boolean isRemoveSupported() {\n+            // Entry set should only support remove if map does\n+            return isAddRemoveModifiable();\n+        }\n+        \n+        protected void resetFull() {\n+            AbstractTestMap.this.resetFull();\n+            collection = map.entrySet();\n+            TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();\n+        }\n+        \n+        protected void resetEmpty() {\n+            AbstractTestMap.this.resetEmpty();\n+            collection = map.entrySet();\n+            TestMapEntrySet.this.confirmed = AbstractTestMap.this.confirmed.entrySet();\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            AbstractTestMap.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Bulk test {@link Map#keySet()}.  This method runs through all of\n+     *  the tests in {@link TestSet}.  \n+     *  After modification operations, {@link #verify()} is invoked to ensure\n+     *  that the map and the other collection views are still valid.\n+     *\n+     *  @return a {@link TestSet} instance for testing the map's key set\n+     */\n+    public BulkTest bulkTestMapKeySet() {\n+        return new TestMapKeySet();\n+    }\n+\n+    class TestMapKeySet extends AbstractTestSet {\n+        public TestMapKeySet() {\n+            super(\"\");\n+        }\n+        protected Object[] getFullElements() {\n+            return getSampleKeys();\n+        }\n+        \n+        protected Object[] getOtherElements() {\n+            return getOtherKeys();\n+        }\n+        \n+        protected Set makeEmptySet() {\n+            return makeEmptyMap().keySet();\n+        }\n+        \n+        protected Set makeFullSet() {\n+            return makeFullMap().keySet();\n+        }\n+        \n+        protected boolean isAddSupported() {\n+            return false;\n+        }\n+        \n+        protected boolean isRemoveSupported() {\n+            return isAddRemoveModifiable();\n+        }\n+        \n+        protected void resetEmpty() {\n+            AbstractTestMap.this.resetEmpty();\n+            collection = map.keySet();\n+            TestMapKeySet.this.confirmed = AbstractTestMap.this.confirmed.keySet();\n+        }\n+        \n+        protected void resetFull() {\n+            AbstractTestMap.this.resetFull();\n+            collection = map.keySet();\n+            TestMapKeySet.this.confirmed = AbstractTestMap.this.confirmed.keySet();\n+        }\n+        \n+        protected void verify() {\n+            super.verify();\n+            AbstractTestMap.this.verify();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Bulk test {@link Map#values()}.  This method runs through all of\n+     *  the tests in {@link TestCollection}.  \n+     *  After modification operations, {@link #verify()} is invoked to ensure\n+     *  that the map and the other collection views are still valid.\n+     *\n+     *  @return a {@link TestCollection} instance for testing the map's \n+     *    values collection\n+     */\n+    public BulkTest bulkTestMapValues() {\n+        return new TestMapValues();\n+    }\n+\n+    class TestMapValues extends AbstractTestCollection {\n+        public TestMapValues() {\n+            super(\"\");\n+        }\n+\n+        protected Object[] getFullElements() {\n+            return getSampleValues();\n+        }\n+        \n+        protected Object[] getOtherElements() {\n+            return getOtherValues();\n+        }\n+        \n+        protected Collection makeCollection() {\n+            return makeEmptyMap().values();\n+        }\n+        \n+        protected Collection makeFullCollection() {\n+            return makeFullMap().values();\n+        }\n+        \n+        protected boolean isAddSupported() {\n+            return false;\n+        }\n+        \n+        protected boolean isRemoveSupported() {\n+            return isAddRemoveModifiable();\n+        }\n+\n+        protected boolean areEqualElementsDistinguishable() {\n+            // equal values are associated with different keys, so they are\n+            // distinguishable.  \n+            return true;\n+        }\n+\n+        protected Collection makeConfirmedCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+        \n+        protected Collection makeConfirmedFullCollection() {\n+            // never gets called, reset methods are overridden\n+            return null;\n+        }\n+        \n+        protected void resetFull() {\n+            AbstractTestMap.this.resetFull();\n+            collection = map.values();\n+            TestMapValues.this.confirmed = AbstractTestMap.this.confirmed.values();\n+        }\n+        \n+        protected void resetEmpty() {\n+            AbstractTestMap.this.resetEmpty();\n+            collection = map.values();\n+            TestMapValues.this.confirmed = AbstractTestMap.this.confirmed.values();\n+        }\n+\n+        protected void verify() {\n+            super.verify();\n+            AbstractTestMap.this.verify();\n+        }\n+\n+        // TODO: should test that a remove on the values collection view\n+        // removes the proper mapping and not just any mapping that may have\n+        // the value equal to the value returned from the values iterator.\n+    }\n+\n+\n+    /**\n+     *  Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     *  {@link #values} and {@link #confirmed} fields to empty.\n+     */\n+    protected void resetEmpty() {\n+        this.map = makeEmptyMap();\n+        views();\n+        this.confirmed = new HashMap();\n+    }\n+\n+\n+    /**\n+     *  Resets the {@link #map}, {@link #entrySet}, {@link #keySet},\n+     *  {@link #values} and {@link #confirmed} fields to full.\n+     */\n+    protected void resetFull() {\n+        this.map = makeFullMap();\n+        views();\n+        this.confirmed = new HashMap();\n+        Object[] k = getSampleKeys();\n+        Object[] v = getSampleValues();\n+        for (int i = 0; i < k.length; i++) {\n+            confirmed.put(k[i], v[i]);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Resets the collection view fields.\n+     */\n+    private void views() {\n+        this.keySet = map.keySet();\n+        this.values = map.values();\n+        this.entrySet = map.entrySet();\n+    }\n+\n+\n+    /**\n+     *  Verifies that {@link #map} is still equal to {@link #confirmed}.\n+     *  This method checks that the map is equal to the HashMap, \n+     *  <I>and</I> that the map's collection views are still equal to\n+     *  the HashMap's collection views.  An <Code>equals</Code> test\n+     *  is done on the maps and their collection views; their size and\n+     *  <Code>isEmpty</Code> results are compared; their hashCodes are\n+     *  compared; and <Code>containsAll</Code> tests are run on the \n+     *  collection views.\n+     */\n+    protected void verify() {\n+        verifyMap();\n+        verifyEntrySet();\n+        verifyKeySet();\n+        verifyValues();\n+    }\n+\n+    protected void verifyMap() {\n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"Map should be same size as HashMap\", \n+                     size, map.size());\n+        assertEquals(\"Map should be empty if HashMap is\", \n+                     empty, map.isEmpty());\n+        assertEquals(\"hashCodes should be the same\",\n+                     confirmed.hashCode(), map.hashCode());\n+        // this fails for LRUMap because confirmed.equals() somehow modifies\n+        // map, causing concurrent modification exceptions.\n+        //assertEquals(\"Map should still equal HashMap\", confirmed, map);\n+        // this works though and performs the same verification:\n+        assertTrue(\"Map should still equal HashMap\", map.equals(confirmed));\n+        // TODO: this should really be reexamined to figure out why LRU map\n+        // behaves like it does (the equals shouldn't modify since all accesses\n+        // by the confirmed collection should be through an iterator, thus not\n+        // causing LRUMap to change).\n+    }\n+\n+    protected void verifyEntrySet() {\n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"entrySet should be same size as HashMap's\",\n+                     size, entrySet.size());\n+        assertEquals(\"entrySet should be empty if HashMap is\", \n+                     empty, entrySet.isEmpty());\n+        assertTrue(\"entrySet should contain all HashMap's elements\",\n+                   entrySet.containsAll(confirmed.entrySet()));\n+        assertEquals(\"entrySet hashCodes should be the same\", \n+                     confirmed.entrySet().hashCode(), entrySet.hashCode());\n+        assertEquals(\"Map's entry set should still equal HashMap's\", \n+                     confirmed.entrySet(), entrySet);\n+    }\n+\n+    protected void verifyKeySet() { \n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"keySet should be same size as HashMap's\",\n+                     size, keySet.size());\n+        assertEquals(\"keySet should be empty if HashMap is\", \n+                     empty, keySet.isEmpty());\n+        assertTrue(\"keySet should contain all HashMap's elements\",\n+                   keySet.containsAll(confirmed.keySet()));\n+        assertEquals(\"keySet hashCodes should be the same\", \n+                     confirmed.keySet().hashCode(), keySet.hashCode());\n+        assertEquals(\"Map's key set should still equal HashMap's\",\n+                     confirmed.keySet(), keySet);\n+    }\n+\n+    protected void verifyValues() {\n+        Bag bag1 = new HashBag(confirmed.values());\n+        Bag bag2 = new HashBag(values);\n+\n+        int size = confirmed.size();\n+        boolean empty = confirmed.isEmpty();\n+        assertEquals(\"values should be same size as HashMap's\",\n+                     size, values.size());\n+        assertEquals(\"values should be empty if HashMap is\", \n+                     empty, values.isEmpty());\n+        assertTrue(\"values should contain all HashMap's elements\",\n+                   values.containsAll(confirmed.values()));\n+        assertEquals(\"Map's values should still equal HashMap's\",\n+                     bag1, bag2);\n+    }\n+\n+\n+    /**\n+     *  Erases any leftover instance variables by setting them to null.\n+     */\n+    protected void tearDown() throws Exception {\n+        map = null;\n+        keySet = null;\n+        entrySet = null;\n+        values = null;\n+        confirmed = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/AbstractTestSortedMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/AbstractTestSortedMap.java,v 1.1 2003/10/02 23:01:09 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+/**\n+ * Abstract test class for {@link java.util.SortedMap} methods and contracts.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2003/10/02 23:01:09 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public abstract class AbstractTestSortedMap extends AbstractTestMap {\n+\n+    /**\n+     * JUnit constructor.\n+     * \n+     * @param testName  the test name\n+     */\n+    public AbstractTestSortedMap(String testName) {\n+        super(testName);\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Can't sort null keys.\n+     * \n+     * @return false\n+     */\n+    protected boolean useNullKey() {\n+        return false;\n+    }\n+\n+\n+    // TODO: Add the SortedMap tests!\n+}\n--- a/src/test/org/apache/commons/collections/TestBeanMap.java\n+++ b/src/test/org/apache/commons/collections/TestBeanMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBeanMap.java,v 1.10 2003/08/31 17:28:43 scolebourne Exp $\n- * $Revision: 1.10 $\n- * $Date: 2003/08/31 17:28:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBeanMap.java,v 1.11 2003/10/02 23:01:10 scolebourne Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/10/02 23:01:10 $\n  *\n  * ====================================================================\n  *\n  * \n  * @author <a href=\"mailto:morgand@apache.org\">Morgan Delagrange</a>\n  */\n-public class TestBeanMap extends TestMap {\n+public class TestBeanMap extends AbstractTestMap {\n \n     public TestBeanMap(String testName) {\n         super(testName);\n      *  bean has.  Adding and removing mappings is not possible, thus this\n      *  method is overridden to return false.\n      **/\n-    public boolean isAddRemoveModifiable() {\n+    protected boolean isAddRemoveModifiable() {\n         return false;\n     }\n   \n-    public Map makeFullMap() {\n+    protected Map makeFullMap() {\n         // note: These values must match (i.e. .equals() must return true)\n         // those returned from getSampleValues().\n         BeanWithProperties bean = new BeanWithProperties();\n         return new BeanMap(bean);\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return new BeanMap();\n     }\n \n--- a/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n+++ b/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.7 2003/08/31 17:28:43 scolebourne Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/08/31 17:28:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestDoubleOrderedMap.java,v 1.8 2003/10/02 23:01:09 scolebourne Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/10/02 23:01:09 $\n  *\n  * ====================================================================\n  *\n  * \n  * @author Marc Johnson (marcj at users dot sourceforge dot net)\n  */\n-public class TestDoubleOrderedMap extends TestMap  {\n+public class TestDoubleOrderedMap extends AbstractTestMap  {\n \n     /**\n      * constructor\n         return false;\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return new DoubleOrderedMap();\n     }\n \n-    public Map makeMap() {\n+    protected Map makeMap() {\n         return new DoubleOrderedMap();\n     }\n \n--- a/src/test/org/apache/commons/collections/TestFastHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestFastHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap.java,v 1.9 2003/08/31 17:28:43 scolebourne Exp $\n- * $Revision: 1.9 $\n- * $Date: 2003/08/31 17:28:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap.java,v 1.10 2003/10/02 23:01:10 scolebourne Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2003/10/02 23:01:10 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastHashMap.java,v 1.9 2003/08/31 17:28:43 scolebourne Exp $\n+ * @version $Id: TestFastHashMap.java,v 1.10 2003/10/02 23:01:10 scolebourne Exp $\n  */\n-public class TestFastHashMap extends TestMap\n+public class TestFastHashMap extends AbstractTestMap\n {\n     public TestFastHashMap(String testName)\n     {\n--- a/src/test/org/apache/commons/collections/TestMapUtils.java\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.15 2003/09/20 17:02:03 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.16 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n /**\n  * Tests for MapUtils.\n  * \n- * @version $Revision: 1.15 $ $Date: 2003/09/20 17:02:03 $\n+ * @version $Revision: 1.16 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Stephen Colebourne\n  * @author Arun Mammen Thomas\n     }\n     \n     public BulkTest bulkTestTypedMap() {\n-        return new TestMap(\"\") {\n+        return new AbstractTestMap(\"\") {\n             public boolean useNullKey() {\n                 return false;\n             }\n--- a/src/test/org/apache/commons/collections/TestMultiHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestMultiHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.11 2003/08/31 17:28:43 scolebourne Exp $\n- * $Revision: 1.11 $\n- * $Date: 2003/08/31 17:28:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMultiHashMap.java,v 1.12 2003/10/02 23:01:10 scolebourne Exp $\n+ * $Revision: 1.12 $\n+ * $Date: 2003/10/02 23:01:10 $\n  *\n  * ====================================================================\n  *\n  * Unit Tests for <code>MultiHashMap</code>.\n  *\n  */\n-public class TestMultiHashMap extends TestMap\n+public class TestMultiHashMap extends AbstractTestMap\n {\n     public TestMultiHashMap(String testName)\n     {\n         return \"2\";\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return new MultiHashMap();\n     }\n     \n--- a/src/test/org/apache/commons/collections/TestReferenceMap.java\n+++ b/src/test/org/apache/commons/collections/TestReferenceMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestReferenceMap.java,v 1.10 2003/09/20 17:02:03 scolebourne Exp $\n- * $Revision: 1.10 $\n- * $Date: 2003/09/20 17:02:03 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestReferenceMap.java,v 1.11 2003/10/02 23:01:10 scolebourne Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2003/10/02 23:01:10 $\n  *\n  * ====================================================================\n  *\n  * Tests for ReferenceMap. \n  *\n  * @author Paul Jack\n- * @version $Id: TestReferenceMap.java,v 1.10 2003/09/20 17:02:03 scolebourne Exp $\n+ * @version $Id: TestReferenceMap.java,v 1.11 2003/10/02 23:01:10 scolebourne Exp $\n  */\n-public class TestReferenceMap extends TestMap {\n+public class TestReferenceMap extends AbstractTestMap {\n \n     public TestReferenceMap(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         ReferenceMap map = new ReferenceMap(ReferenceMap.WEAK, ReferenceMap.WEAK);\n         return map;\n     }\n--- a/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n+++ b/src/test/org/apache/commons/collections/TestSequencedHashMap.java\n  * @author <a href=\"mailto:hps@intermeta.de\">Henning P. Schmiedehausen</a>\n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  */\n-public class TestSequencedHashMap extends TestMap {\n+public class TestSequencedHashMap extends AbstractTestMap {\n     /**\n      * The instance to experiment on.\n      */\n         labRat = (SequencedHashMap) makeEmptyMap();\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return new SequencedHashMap();\n     }\n \n--- a/src/test/org/apache/commons/collections/TestStaticBucketMap.java\n+++ b/src/test/org/apache/commons/collections/TestStaticBucketMap.java\n  * \n  * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n  */\n-public class TestStaticBucketMap extends TestMap {\n+public class TestStaticBucketMap extends AbstractTestMap {\n \n     public TestStaticBucketMap(String name) {\n         super(name);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return new StaticBucketMap(30);\n     }\n \n--- a/src/test/org/apache/commons/collections/TestTreeMap.java\n+++ b/src/test/org/apache/commons/collections/TestTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestTreeMap.java,v 1.7 2003/08/31 17:28:43 scolebourne Exp $\n- * $Revision: 1.7 $\n- * $Date: 2003/08/31 17:28:43 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestTreeMap.java,v 1.8 2003/10/02 23:01:10 scolebourne Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2003/10/02 23:01:10 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestTreeMap.java,v 1.7 2003/08/31 17:28:43 scolebourne Exp $\n+ * @version $Id: TestTreeMap.java,v 1.8 2003/10/02 23:01:10 scolebourne Exp $\n  */\n-public abstract class TestTreeMap extends TestMap\n+public abstract class TestTreeMap extends AbstractTestMap\n {\n     public TestTreeMap(String testName)\n     {\n--- a/src/test/org/apache/commons/collections/decorators/TestFixedSizeMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestFixedSizeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestFixedSizeMap.java,v 1.3 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestFixedSizeMap.java,v 1.4 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.TestMap;\n+import org.apache.commons.collections.AbstractTestMap;\n \n /**\n- * Extension of {@link TestMap} for exercising the {@link FixedSizeMap}\n+ * Extension of {@link AbstractTestMap} for exercising the {@link FixedSizeMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.4 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Stephen Colebourne\n  */\n-public class TestFixedSizeMap extends TestMap {\n+public class TestFixedSizeMap extends AbstractTestMap {\n \n     public TestFixedSizeMap(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return FixedSizeMap.decorate(new HashMap());\n     }\n \n--- a/src/test/org/apache/commons/collections/decorators/TestFixedSizeSortedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestFixedSizeSortedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestFixedSizeSortedMap.java,v 1.3 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestFixedSizeSortedMap.java,v 1.4 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.TestSortedMap;\n+import org.apache.commons.collections.AbstractTestSortedMap;\n \n /**\n  * Extension of {@link TestSortedMap} for exercising the {@link FixedSizeSortedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.4 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Stephen Colebourne\n  */\n-public class TestFixedSizeSortedMap extends TestSortedMap {\n+public class TestFixedSizeSortedMap extends AbstractTestSortedMap {\n \n     public TestFixedSizeSortedMap(String testName) {\n         super(testName);\n--- a/src/test/org/apache/commons/collections/decorators/TestLazyMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestLazyMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestLazyMap.java,v 1.2 2003/09/20 17:05:36 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestLazyMap.java,v 1.3 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.collections.Factory;\n import org.apache.commons.collections.FactoryUtils;\n-import org.apache.commons.collections.TestMap;\n+import org.apache.commons.collections.AbstractTestMap;\n \n /**\n  * Extension of {@link TestMap} for exercising the \n  * {@link LazyMap} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/20 17:05:36 $\n+ * @version $Revision: 1.3 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Phil Steitz\n  */\n-public class TestLazyMap extends TestMap {\n+public class TestLazyMap extends AbstractTestMap {\n     \n     public TestLazyMap(String testName) {\n         super(testName);\n         return LazyMap.decorate(map, factory);\n     }\n     \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return decorateMap(new HashMap(), nullFactory);\n     }\n     \n--- a/src/test/org/apache/commons/collections/decorators/TestPredicatedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestPredicatedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestPredicatedMap.java,v 1.2 2003/09/20 17:05:36 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestPredicatedMap.java,v 1.3 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import org.apache.commons.collections.Predicate;\n import org.apache.commons.collections.PredicateUtils;\n-import org.apache.commons.collections.TestMap;\n+import org.apache.commons.collections.AbstractTestMap;\n \n /**\n  * Extension of {@link TestMap} for exercising the \n  * {@link PredicatedMap} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/09/20 17:05:36 $\n+ * @version $Revision: 1.3 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Phil Steitz\n  */\n-public class TestPredicatedMap extends TestMap{\n+public class TestPredicatedMap extends AbstractTestMap{\n     \n     public TestPredicatedMap(String testName) {\n         super(testName);\n         return PredicatedMap.decorate(map, keyPredicate, valuePredicate);\n     }\n     \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return decorateMap(new HashMap(), truePredicate, truePredicate);\n     }\n     \n--- a/src/test/org/apache/commons/collections/decorators/TestTransformedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestTransformedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedMap.java,v 1.2 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedMap.java,v 1.3 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.TestMap;\n+import org.apache.commons.collections.AbstractTestMap;\n \n /**\n  * Extension of {@link TestMap} for exercising the {@link TransformedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.3 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Stephen Colebourne\n  */\n-public class TestTransformedMap extends TestMap {\n+public class TestTransformedMap extends AbstractTestMap {\n     \n     public TestTransformedMap(String testName) {\n         super(testName);\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeEmptyMap() {\n+    protected Map makeEmptyMap() {\n         return TransformedMap.decorate(new HashMap(), TestTransformedCollection.NOOP_TRANSFORMER, TestTransformedCollection.NOOP_TRANSFORMER);\n     }\n \n--- a/src/test/org/apache/commons/collections/decorators/TestTransformedSortedMap.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestTransformedSortedMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedSortedMap.java,v 1.2 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestTransformedSortedMap.java,v 1.3 2003/10/02 23:01:09 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.Test;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.collections.TestSortedMap;\n+import org.apache.commons.collections.AbstractTestSortedMap;\n \n /**\n  * Extension of {@link TestSortedMap} for exercising the {@link TransformedSortedMap}\n  * implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.3 $ $Date: 2003/10/02 23:01:09 $\n  * \n  * @author Stephen Colebourne\n  */\n-public class TestTransformedSortedMap extends TestSortedMap {\n+public class TestTransformedSortedMap extends AbstractTestSortedMap {\n     \n     public TestTransformedSortedMap(String testName) {\n         super(testName);", "timestamp": 1065135670, "metainfo": ""}