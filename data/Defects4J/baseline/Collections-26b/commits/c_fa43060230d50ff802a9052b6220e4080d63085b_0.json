{"sha": "fa43060230d50ff802a9052b6220e4080d63085b", "log": "Removed ^M's from file because they were causing line numbers to be reported incorrectly when trying to track down failing test cases.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BeanMap.java\n+++ b/src/java/org/apache/commons/collections/BeanMap.java\n-/*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BeanMap.java,v 1.4 2002/02/22 07:00:30 mas Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/02/22 07:00:30 $\n- *\n- * ====================================================================\n- *\n- * The Apache Software License, Version 1.1\n- *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n- * reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in\n- *    the documentation and/or other materials provided with the\n- *    distribution.\n- *\n- * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n- *       \"This product includes software developed by the\n- *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n- *\n- * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n- *    Foundation\" must not be used to endorse or promote products derived\n- *    from this software without prior written permission. For written\n- *    permission, please contact apache@apache.org.\n- *\n- * 5. Products derived from this software may not be called \"Apache\"\n- *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n- *\n- * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n- * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n- * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n- * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n- * SUCH DAMAGE.\n- * ====================================================================\n- *\n- * This software consists of voluntary contributions made by many\n- * individuals on behalf of the Apache Software Foundation.  For more\n- * information on the Apache Software Foundation, please see\n- * <http://www.apache.org/>.\n- *\n- */\n-package org.apache.commons.collections;\n-\n-import java.beans.BeanInfo;\n-import java.beans.Introspector;\n-import java.beans.IntrospectionException;\n-import java.beans.PropertyDescriptor;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.AbstractMap;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Set;\n-\n-\n-/** An implementation of Map for JavaBeans which uses introspection to\n-  * get and put properties in the bean.\n-  *\n-  * If an exception occurs during attempts to get or set a property then the\n-  * property is considered non existent in the Map\n-  *\n-  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n-  */\n-\n-public class BeanMap extends AbstractMap {\n-\n-    private Object bean;\n-\n-    private HashMap readMethods = new HashMap();\n-    private HashMap writeMethods = new HashMap();\n-    private HashMap types = new HashMap();\n-\n-    public static final Object[] NULL_ARGUMENTS = {};\n-    public static HashMap defaultTransformers = new HashMap();\n-    \n-    static {\n-        defaultTransformers.put( \n-            Boolean.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Boolean.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Character.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return new Character( input.toString().charAt( 0 ) );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Byte.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Byte.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Short.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Short.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Integer.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Integer.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Long.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Long.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Float.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Float.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-        defaultTransformers.put( \n-            Double.TYPE, \n-            new Transformer() {\n-                public Object transform( Object input ) {\n-                    return Double.valueOf( input.toString() );\n-                }\n-            }\n-        );\n-    }\n-    \n-    \n-    // Constructors\n-    //-------------------------------------------------------------------------\n-    public BeanMap() {\n-    }\n-\n-    public BeanMap(Object bean) {\n-        this.bean = bean;\n-        initialise();\n-    }\n-\n-    // Map interface\n-    //-------------------------------------------------------------------------\n-\n-    public Object clone() {\n-        Class beanClass = null;\n-        try {\n-            beanClass = bean.getClass();\n-            Object newBean = beanClass.newInstance();\n-            Map newMap = new BeanMap( newBean );\n-            newMap.putAll( this );\n-            return newMap;\n-        } \n-        catch (Exception e) {\n-            throw new UnsupportedOperationException( \"Could not create new instance of class: \" + beanClass );\n-        }\n-    }\n-\n-    /**\n-     *  This method reinitializes the bean map to have default values for the\n-     *  bean's properties.  This is accomplished by constructing a new instance\n-     *  of the bean which th emap uses as its underlying data source.  This\n-     *  behavior for <code>clear()</code> differs from the Map contract in that\n-     *  the mappings are not actually removed from the map (the mappings for a\n-     *  BeanMap are fixed).\n-     **/\n-    public void clear() {\n-        Class beanClass = null;\n-        try {\n-            beanClass = bean.getClass();\n-            bean = beanClass.newInstance();\n-        }\n-        catch (Exception e) {\n-            throw new UnsupportedOperationException( \"Could not create new instance of class: \" + beanClass );\n-        }\n-    }\n-\n-    public boolean containsKey(Object name) {\n-        Method method = getReadMethod( name );\n-        return method != null;\n-    }\n-\n-    public boolean containsValue(Object value) {\n-        // use default implementation\n-        return super.containsValue( value );\n-    }\n-\n-    public Object get(Object name) {\n-        if ( bean != null ) {\n-            Method method = getReadMethod( name );\n-            if ( method != null ) {\n-                try {\n-                    return method.invoke( bean, NULL_ARGUMENTS );\n-                }\n-                catch (  IllegalAccessException e ) {\n-                    logWarn( e );\n-                }\n-                catch ( IllegalArgumentException e ) {\n-                    logWarn(  e );\n-                }\n-                catch ( InvocationTargetException e ) {\n-                    logWarn(  e );\n-                }\n-                catch ( NullPointerException e ) {\n-                    logWarn(  e );\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public Object put(Object name, Object value) throws IllegalArgumentException, ClassCastException {\n-        if ( bean != null ) {\n-            Object oldValue = get( name );\n-            Method method = getWriteMethod( name );\n-            if ( method == null ) {\n-                throw new IllegalArgumentException( \"The bean of type: \"+ bean.getClass().getName() + \" has no property called: \" + name );\n-            }\n-            try {\n-                Object[] arguments = createWriteMethodArguments( method, value );\n-                method.invoke( bean, arguments );\n-\n-                Object newValue = get( name );\n-                firePropertyChange( name, oldValue, newValue );\n-            }\n-            catch ( InvocationTargetException e ) {\n-                logInfo( e );\n-                throw new IllegalArgumentException( e.getMessage() );\n-            }\n-            catch ( IllegalAccessException e ) {\n-                logInfo( e );\n-                throw new IllegalArgumentException( e.getMessage() );\n-            }\n-            return oldValue;\n-        }\n-        return null;\n-    }\n-                    \n-    public int size() {\n-        return readMethods.size();\n-    }\n-\n-    \n-    public Set keySet() {\n-        return readMethods.keySet();\n-    }\n-\n-    public Set entrySet() {\n-        return readMethods.keySet();\n-    }\n-\n-    public Collection values() {\n-        ArrayList answer = new ArrayList( readMethods.size() );\n-        for ( Iterator iter = valueIterator(); iter.hasNext(); ) {\n-            answer.add( iter.next() );\n-        }\n-        return answer;\n-    }\n-\n-\n-    // Helper methods\n-    //-------------------------------------------------------------------------\n-    \n-    public Class getType(String name) {\n-        return (Class) types.get( name );\n-    }\n-\n-    public Iterator keyIterator() {\n-        return readMethods.keySet().iterator();\n-    }\n-\n-    public Iterator valueIterator() {\n-        final Iterator iter = keyIterator();\n-        return new Iterator() {            \n-            public boolean hasNext() {\n-                return iter.hasNext();\n-            }\n-            public Object next() {\n-                Object key = iter.next();\n-                return get( (String) key );\n-            }\n-            public void remove() {\n-                throw new UnsupportedOperationException( \"remove() not supported for BeanMap\" );\n-            }\n-        };\n-    }\n-\n-    public Iterator entryIterator() {\n-        final Iterator iter = keyIterator();\n-        return new Iterator() {            \n-            public boolean hasNext() {\n-                return iter.hasNext();\n-            }            \n-            public Object next() {\n-                Object key = iter.next();\n-                Object value = get( (String) key );\n-                return new MyMapEntry( BeanMap.this, key, value );\n-            }            \n-            public void remove() {\n-                throw new UnsupportedOperationException( \"remove() not supported for BeanMap\" );\n-            }\n-        };\n-    }\n-\n-\n-    // Properties\n-    //-------------------------------------------------------------------------\n-    public Object getBean() {\n-        return bean;\n-    }\n-\n-    public void setBean( Object newBean ) {\n-        bean = newBean;\n-        reinitialise();\n-    }\n-\n-\n-    // Implementation methods\n-    //-------------------------------------------------------------------------\n-\n-    protected Method getReadMethod( Object name ) {\n-        return (Method) readMethods.get( name );\n-    }\n-\n-    protected Method getWriteMethod( Object name ) {\n-        return (Method) writeMethods.get( name );\n-    }\n-\n-    protected void reinitialise() {\n-        readMethods.clear();\n-        writeMethods.clear();\n-        types.clear();\n-        initialise();\n-    }\n-\n-    private void initialise() {\n-        Class  beanClass = getBean().getClass();\n-        try {\n-            //BeanInfo beanInfo = Introspector.getBeanInfo( bean, null );\n-            BeanInfo beanInfo = Introspector.getBeanInfo( beanClass );\n-            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n-            if ( propertyDescriptors != null ) {\n-                for ( int i = 0; i < propertyDescriptors.length; i++ ) {\n-                    PropertyDescriptor propertyDescriptor = propertyDescriptors[i];\n-                    if ( propertyDescriptor != null ) {\n-                        String name = propertyDescriptor.getName();\n-                        Method readMethod = propertyDescriptor.getReadMethod();\n-                        Method writeMethod = propertyDescriptor.getWriteMethod();\n-                        Class aType = propertyDescriptor.getPropertyType();\n-\n-                        if ( readMethod != null ) {\n-                            readMethods.put( name, readMethod );\n-                        }\n-                        if ( writeMethods != null ) {\n-                            writeMethods.put( name, writeMethod );\n-                        }\n-                        types.put( name, aType );\n-                    }\n-                }\n-            }\n-        }\n-        catch ( IntrospectionException e ) {\n-            logWarn(  e );\n-        }\n-    }\n-\n-    protected void firePropertyChange( Object key, Object oldValue, Object newValue ) {\n-    }\n-\n-    // Implementation classes\n-    //-------------------------------------------------------------------------\n-    protected static class MyMapEntry extends DefaultMapEntry {        \n-        private BeanMap owner;\n-        \n-        protected MyMapEntry( BeanMap owner, Object key, Object value ) {\n-            super( key, value );\n-            this.owner = owner;\n-        }\n-\n-        public Object setValue(Object value) {\n-            Object key = getKey();\n-            Object oldValue = owner.get( key );\n-\n-            owner.put( key, value );\n-            Object newValue = owner.get( key );\n-            super.setValue( newValue );\n-            return oldValue;\n-        }\n-    }\n-    \n-    protected Object[] createWriteMethodArguments( Method method, Object value ) throws IllegalAccessException, ClassCastException {            \n-        try {\n-            if ( value != null ) {\n-                Class[] types = method.getParameterTypes();\n-                if ( types != null && types.length > 0 ) {\n-                    Class paramType = types[0];\n-                    if ( ! paramType.isAssignableFrom( value.getClass() ) ) {\n-                        value = convertType( paramType, value );\n-                    }\n-                }\n-            }\n-            Object[] answer = { value };\n-            return answer;\n-        }\n-        catch ( InvocationTargetException e ) {\n-            logInfo( e );\n-            throw new IllegalArgumentException( e.getMessage() );\n-        }\n-        catch ( InstantiationException e ) {\n-            logInfo( e );\n-            throw new IllegalArgumentException( e.getMessage() );\n-        }\n-    }\n-    \n-    protected Object convertType( Class newType, Object value ) \n-        throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n-        \n-        // try call constructor\n-        Class[] types = { value.getClass() };\n-        try {\n-            Constructor constructor = newType.getConstructor( types );        \n-            Object[] arguments = { value };\n-            return constructor.newInstance( arguments );\n-        }\n-        catch ( NoSuchMethodException e ) {\n-            // try using the transformers\n-            Transformer transformer = getTypeTransformer( newType );\n-            if ( transformer != null ) {\n-                return transformer.transform( value );\n-            }\n-            return value;\n-        }\n-    }\n-    \n-    protected Transformer getTypeTransformer( Class aType ) {\n-        return (Transformer) defaultTransformers.get( aType );\n-    }\n-    \n-    protected void logInfo(Exception e) {\n-        // XXXX: should probably use log4j here instead...\n-        System.out.println( \"INFO: Exception: \" + e );\n-    }\n-    \n-    protected void logWarn(Exception e) {\n-        // XXXX: should probably use log4j here instead...\n-        System.out.println( \"WARN: Exception: \" + e );\n-        e.printStackTrace();\n-    }\n-}\n-\n-\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BeanMap.java,v 1.5 2002/03/13 04:15:49 mas Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/03/13 04:15:49 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.beans.BeanInfo;\n+import java.beans.Introspector;\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.AbstractMap;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/** An implementation of Map for JavaBeans which uses introspection to\n+  * get and put properties in the bean.\n+  *\n+  * If an exception occurs during attempts to get or set a property then the\n+  * property is considered non existent in the Map\n+  *\n+  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n+  */\n+\n+public class BeanMap extends AbstractMap {\n+\n+    private Object bean;\n+\n+    private HashMap readMethods = new HashMap();\n+    private HashMap writeMethods = new HashMap();\n+    private HashMap types = new HashMap();\n+\n+    public static final Object[] NULL_ARGUMENTS = {};\n+    public static HashMap defaultTransformers = new HashMap();\n+    \n+    static {\n+        defaultTransformers.put( \n+            Boolean.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Boolean.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Character.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return new Character( input.toString().charAt( 0 ) );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Byte.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Byte.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Short.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Short.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Integer.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Integer.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Long.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Long.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Float.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Float.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+        defaultTransformers.put( \n+            Double.TYPE, \n+            new Transformer() {\n+                public Object transform( Object input ) {\n+                    return Double.valueOf( input.toString() );\n+                }\n+            }\n+        );\n+    }\n+    \n+    \n+    // Constructors\n+    //-------------------------------------------------------------------------\n+    public BeanMap() {\n+    }\n+\n+    public BeanMap(Object bean) {\n+        this.bean = bean;\n+        initialise();\n+    }\n+\n+    // Map interface\n+    //-------------------------------------------------------------------------\n+\n+    public Object clone() {\n+        Class beanClass = null;\n+        try {\n+            beanClass = bean.getClass();\n+            Object newBean = beanClass.newInstance();\n+            Map newMap = new BeanMap( newBean );\n+            newMap.putAll( this );\n+            return newMap;\n+        } \n+        catch (Exception e) {\n+            throw new UnsupportedOperationException( \"Could not create new instance of class: \" + beanClass );\n+        }\n+    }\n+\n+    /**\n+     *  This method reinitializes the bean map to have default values for the\n+     *  bean's properties.  This is accomplished by constructing a new instance\n+     *  of the bean which th emap uses as its underlying data source.  This\n+     *  behavior for <code>clear()</code> differs from the Map contract in that\n+     *  the mappings are not actually removed from the map (the mappings for a\n+     *  BeanMap are fixed).\n+     **/\n+    public void clear() {\n+        Class beanClass = null;\n+        try {\n+            beanClass = bean.getClass();\n+            bean = beanClass.newInstance();\n+        }\n+        catch (Exception e) {\n+            throw new UnsupportedOperationException( \"Could not create new instance of class: \" + beanClass );\n+        }\n+    }\n+\n+    public boolean containsKey(Object name) {\n+        Method method = getReadMethod( name );\n+        return method != null;\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        // use default implementation\n+        return super.containsValue( value );\n+    }\n+\n+    public Object get(Object name) {\n+        if ( bean != null ) {\n+            Method method = getReadMethod( name );\n+            if ( method != null ) {\n+                try {\n+                    return method.invoke( bean, NULL_ARGUMENTS );\n+                }\n+                catch (  IllegalAccessException e ) {\n+                    logWarn( e );\n+                }\n+                catch ( IllegalArgumentException e ) {\n+                    logWarn(  e );\n+                }\n+                catch ( InvocationTargetException e ) {\n+                    logWarn(  e );\n+                }\n+                catch ( NullPointerException e ) {\n+                    logWarn(  e );\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public Object put(Object name, Object value) throws IllegalArgumentException, ClassCastException {\n+        if ( bean != null ) {\n+            Object oldValue = get( name );\n+            Method method = getWriteMethod( name );\n+            if ( method == null ) {\n+                throw new IllegalArgumentException( \"The bean of type: \"+ bean.getClass().getName() + \" has no property called: \" + name );\n+            }\n+            try {\n+                Object[] arguments = createWriteMethodArguments( method, value );\n+                method.invoke( bean, arguments );\n+\n+                Object newValue = get( name );\n+                firePropertyChange( name, oldValue, newValue );\n+            }\n+            catch ( InvocationTargetException e ) {\n+                logInfo( e );\n+                throw new IllegalArgumentException( e.getMessage() );\n+            }\n+            catch ( IllegalAccessException e ) {\n+                logInfo( e );\n+                throw new IllegalArgumentException( e.getMessage() );\n+            }\n+            return oldValue;\n+        }\n+        return null;\n+    }\n+                    \n+    public int size() {\n+        return readMethods.size();\n+    }\n+\n+    \n+    public Set keySet() {\n+        return readMethods.keySet();\n+    }\n+\n+    public Set entrySet() {\n+        return readMethods.keySet();\n+    }\n+\n+    public Collection values() {\n+        ArrayList answer = new ArrayList( readMethods.size() );\n+        for ( Iterator iter = valueIterator(); iter.hasNext(); ) {\n+            answer.add( iter.next() );\n+        }\n+        return answer;\n+    }\n+\n+\n+    // Helper methods\n+    //-------------------------------------------------------------------------\n+    \n+    public Class getType(String name) {\n+        return (Class) types.get( name );\n+    }\n+\n+    public Iterator keyIterator() {\n+        return readMethods.keySet().iterator();\n+    }\n+\n+    public Iterator valueIterator() {\n+        final Iterator iter = keyIterator();\n+        return new Iterator() {            \n+            public boolean hasNext() {\n+                return iter.hasNext();\n+            }\n+            public Object next() {\n+                Object key = iter.next();\n+                return get( (String) key );\n+            }\n+            public void remove() {\n+                throw new UnsupportedOperationException( \"remove() not supported for BeanMap\" );\n+            }\n+        };\n+    }\n+\n+    public Iterator entryIterator() {\n+        final Iterator iter = keyIterator();\n+        return new Iterator() {            \n+            public boolean hasNext() {\n+                return iter.hasNext();\n+            }            \n+            public Object next() {\n+                Object key = iter.next();\n+                Object value = get( (String) key );\n+                return new MyMapEntry( BeanMap.this, key, value );\n+            }            \n+            public void remove() {\n+                throw new UnsupportedOperationException( \"remove() not supported for BeanMap\" );\n+            }\n+        };\n+    }\n+\n+\n+    // Properties\n+    //-------------------------------------------------------------------------\n+    public Object getBean() {\n+        return bean;\n+    }\n+\n+    public void setBean( Object newBean ) {\n+        bean = newBean;\n+        reinitialise();\n+    }\n+\n+\n+    // Implementation methods\n+    //-------------------------------------------------------------------------\n+\n+    protected Method getReadMethod( Object name ) {\n+        return (Method) readMethods.get( name );\n+    }\n+\n+    protected Method getWriteMethod( Object name ) {\n+        return (Method) writeMethods.get( name );\n+    }\n+\n+    protected void reinitialise() {\n+        readMethods.clear();\n+        writeMethods.clear();\n+        types.clear();\n+        initialise();\n+    }\n+\n+    private void initialise() {\n+        Class  beanClass = getBean().getClass();\n+        try {\n+            //BeanInfo beanInfo = Introspector.getBeanInfo( bean, null );\n+            BeanInfo beanInfo = Introspector.getBeanInfo( beanClass );\n+            PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n+            if ( propertyDescriptors != null ) {\n+                for ( int i = 0; i < propertyDescriptors.length; i++ ) {\n+                    PropertyDescriptor propertyDescriptor = propertyDescriptors[i];\n+                    if ( propertyDescriptor != null ) {\n+                        String name = propertyDescriptor.getName();\n+                        Method readMethod = propertyDescriptor.getReadMethod();\n+                        Method writeMethod = propertyDescriptor.getWriteMethod();\n+                        Class aType = propertyDescriptor.getPropertyType();\n+\n+                        if ( readMethod != null ) {\n+                            readMethods.put( name, readMethod );\n+                        }\n+                        if ( writeMethods != null ) {\n+                            writeMethods.put( name, writeMethod );\n+                        }\n+                        types.put( name, aType );\n+                    }\n+                }\n+            }\n+        }\n+        catch ( IntrospectionException e ) {\n+            logWarn(  e );\n+        }\n+    }\n+\n+    protected void firePropertyChange( Object key, Object oldValue, Object newValue ) {\n+    }\n+\n+    // Implementation classes\n+    //-------------------------------------------------------------------------\n+    protected static class MyMapEntry extends DefaultMapEntry {        \n+        private BeanMap owner;\n+        \n+        protected MyMapEntry( BeanMap owner, Object key, Object value ) {\n+            super( key, value );\n+            this.owner = owner;\n+        }\n+\n+        public Object setValue(Object value) {\n+            Object key = getKey();\n+            Object oldValue = owner.get( key );\n+\n+            owner.put( key, value );\n+            Object newValue = owner.get( key );\n+            super.setValue( newValue );\n+            return oldValue;\n+        }\n+    }\n+    \n+    protected Object[] createWriteMethodArguments( Method method, Object value ) throws IllegalAccessException, ClassCastException {            \n+        try {\n+            if ( value != null ) {\n+                Class[] types = method.getParameterTypes();\n+                if ( types != null && types.length > 0 ) {\n+                    Class paramType = types[0];\n+                    if ( ! paramType.isAssignableFrom( value.getClass() ) ) {\n+                        value = convertType( paramType, value );\n+                    }\n+                }\n+            }\n+            Object[] answer = { value };\n+            return answer;\n+        }\n+        catch ( InvocationTargetException e ) {\n+            logInfo( e );\n+            throw new IllegalArgumentException( e.getMessage() );\n+        }\n+        catch ( InstantiationException e ) {\n+            logInfo( e );\n+            throw new IllegalArgumentException( e.getMessage() );\n+        }\n+    }\n+    \n+    protected Object convertType( Class newType, Object value ) \n+        throws InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+        \n+        // try call constructor\n+        Class[] types = { value.getClass() };\n+        try {\n+            Constructor constructor = newType.getConstructor( types );        \n+            Object[] arguments = { value };\n+            return constructor.newInstance( arguments );\n+        }\n+        catch ( NoSuchMethodException e ) {\n+            // try using the transformers\n+            Transformer transformer = getTypeTransformer( newType );\n+            if ( transformer != null ) {\n+                return transformer.transform( value );\n+            }\n+            return value;\n+        }\n+    }\n+    \n+    protected Transformer getTypeTransformer( Class aType ) {\n+        return (Transformer) defaultTransformers.get( aType );\n+    }\n+    \n+    protected void logInfo(Exception e) {\n+        // XXXX: should probably use log4j here instead...\n+        System.out.println( \"INFO: Exception: \" + e );\n+    }\n+    \n+    protected void logWarn(Exception e) {\n+        // XXXX: should probably use log4j here instead...\n+        System.out.println( \"WARN: Exception: \" + e );\n+        e.printStackTrace();\n+    }\n+}\n+\n+", "timestamp": 1015992949, "metainfo": ""}