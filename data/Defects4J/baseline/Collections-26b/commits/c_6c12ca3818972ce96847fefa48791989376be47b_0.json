{"sha": "6c12ca3818972ce96847fefa48791989376be47b", "log": "Fixed BinaryHeap / BinaryBuffer remove(object) bug. PR #25818 Reported by: Steve Phelps   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BinaryHeap.java\n+++ b/src/java/org/apache/commons/collections/BinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.16 2004/01/01 19:00:20 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.17 2004/01/01 23:56:51 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * </pre>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.16 $ $Date: 2004/01/01 19:00:20 $\n+ * @version $Revision: 1.17 $ $Date: 2004/01/01 23:56:51 $\n  * \n  * @author Peter Donald\n  * @author Ram Chidambaram\n     }\n \n     /**\n-     * Percolates element down heap from top.\n-     * Assume it is a maximum heap.\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a mimimum heap.\n      *\n      * @param index the index for the element\n      */\n     }\n \n     /**\n-     * Percolates element down heap from top.\n-     * Assume it is a maximum heap.\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a maximum heap.\n      *\n      * @param index the index of the element\n      */\n     }\n \n     /**\n-     * Percolates element up heap from bottom.\n-     * Assume it is a maximum heap.\n-     *\n-     * @param element the element\n-     */\n-    protected void percolateUpMinHeap(final Object element) {\n-        int hole = ++m_size;\n-\n-        m_elements[hole] = element;\n-\n+     * Percolates element up heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param index the index of the element to be percolated up\n+     */\n+    protected void percolateUpMinHeap(final int index) {\n+        int hole = index;\n+        Object element = m_elements[hole];\n         while (hole > 1 && compare(element, m_elements[hole / 2]) < 0) {\n             // save element that is being pushed down\n             // as the element \"bubble\" is percolated up\n             m_elements[hole] = m_elements[next];\n             hole = next;\n         }\n-\n         m_elements[hole] = element;\n     }\n \n     /**\n-     * Percolates element up heap from bottom.\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMinHeap(final Object element) {\n+        m_elements[++m_size] = element;\n+        percolateUpMinHeap(m_size);\n+    }\n+\n+    /**\n+     * Percolates element up heap from from the position given by the index.\n+     * <p>\n      * Assume it is a maximum heap.\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMaxHeap(final Object element) {\n-        int hole = ++m_size;\n-\n+    protected void percolateUpMaxHeap(final int index) {\n+        int hole = index;\n+        Object element = m_elements[hole];\n+        \n         while (hole > 1 && compare(element, m_elements[hole / 2]) > 0) {\n             // save element that is being pushed down\n             // as the element \"bubble\" is percolated up\n     }\n     \n     /**\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMaxHeap(final Object element) {\n+        m_elements[++m_size] = element;\n+        percolateUpMaxHeap(m_size);\n+    }\n+    \n+    /**\n      * Compares two objects using the comparator if specified, or the\n      * natural order otherwise.\n      * \n             }\n \n             public void remove() {\n-                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+                if (lastReturnedIndex == -1) {\n+                    throw new IllegalStateException();\n+                }\n                 m_elements[ lastReturnedIndex ] = m_elements[ m_size ];\n                 m_elements[ m_size ] = null;\n-                m_size--;\n-                if( m_size != 0 )\n-                {\n-                    //percolate top element to it's place in tree\n-                    if( m_isMinHeap ) percolateDownMinHeap( lastReturnedIndex );\n-                    else percolateDownMaxHeap( lastReturnedIndex );\n+                m_size--;  \n+                if( m_size != 0 && lastReturnedIndex <= m_size) {\n+                    int compareToParent = 0;\n+                    if (lastReturnedIndex > 1) {\n+                        compareToParent = compare(m_elements[lastReturnedIndex], \n+                            m_elements[lastReturnedIndex / 2]);  \n+                    }\n+                    if (m_isMinHeap) {\n+                        if (lastReturnedIndex > 1 && compareToParent < 0) {\n+                            percolateUpMinHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMinHeap(lastReturnedIndex);\n+                        }\n+                    } else {  // max heap\n+                        if (lastReturnedIndex > 1 && compareToParent > 0) {\n+                            percolateUpMaxHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMaxHeap(lastReturnedIndex);\n+                        }\n+                    }          \n                 }\n                 index--;\n-                lastReturnedIndex = -1;        \n+                lastReturnedIndex = -1; \n             }\n \n         };\n--- a/src/java/org/apache/commons/collections/buffer/BinaryBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BinaryBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/Attic/BinaryBuffer.java,v 1.1 2004/01/01 19:01:34 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/Attic/BinaryBuffer.java,v 1.2 2004/01/01 23:56:51 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  * </pre>\n  *\n  * @since Commons Collections 3.0 (previously BinaryHeap v1.0)\n- * @version $Revision: 1.1 $ $Date: 2004/01/01 19:01:34 $\n+ * @version $Revision: 1.2 $ $Date: 2004/01/01 23:56:51 $\n  * \n  * @author Peter Donald\n  * @author Ram Chidambaram\n         return elements.length == size + 1;\n     }\n \n-    /**\n-     * Percolates element down heap from top.\n-     * Assume it is a minimum heap.\n+    \n+    /**\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a mimimum heap.\n      *\n      * @param index the index for the element\n      */\n     }\n \n     /**\n-     * Percolates element down heap from top.\n-     * Assume it is a maximum heap.\n+     * Percolates element down heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a maximum heap.\n      *\n      * @param index the index of the element\n      */\n     }\n \n     /**\n-     * Percolates element up heap from bottom.\n-     * Assume it is a minimum heap.\n-     *\n-     * @param element the element\n-     */\n-    protected void percolateUpMinHeap(final Object element) {\n-        int hole = ++size;\n-\n-        elements[hole] = element;\n-\n+     * Percolates element up heap from the position given by the index.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param index the index of the element to be percolated up\n+     */\n+    protected void percolateUpMinHeap(final int index) {\n+        int hole = index;\n+        Object element = elements[hole];\n         while (hole > 1 && compare(element, elements[hole / 2]) < 0) {\n             // save element that is being pushed down\n             // as the element \"bubble\" is percolated up\n             elements[hole] = elements[next];\n             hole = next;\n         }\n-\n         elements[hole] = element;\n     }\n \n     /**\n-     * Percolates element up heap from bottom.\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assumes it is a minimum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMinHeap(final Object element) {\n+        elements[++size] = element;\n+        percolateUpMinHeap(size);\n+    }\n+\n+    /**\n+     * Percolates element up heap from from the position given by the index.\n+     * <p>\n      * Assume it is a maximum heap.\n      *\n      * @param element the element\n      */\n-    protected void percolateUpMaxHeap(final Object element) {\n-        int hole = ++size;\n+    protected void percolateUpMaxHeap(final int index) {\n+        int hole = index;\n+        Object element = elements[hole];\n \n         while (hole > 1 && compare(element, elements[hole / 2]) > 0) {\n             // save element that is being pushed down\n         }\n \n         elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates a new element up heap from the bottom.\n+     * <p>\n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMaxHeap(final Object element) {\n+        elements[++size] = element;\n+        percolateUpMaxHeap(size);\n     }\n \n     /**\n                 if (lastReturnedIndex == -1) {\n                     throw new IllegalStateException();\n                 }\n-                elements[lastReturnedIndex] = elements[size];\n-                elements[size] = null;\n-                size--;\n-                if (size != 0) {\n-                    //percolate top element to it's place in tree\n+                elements[ lastReturnedIndex ] = elements[ size ];\n+                elements[ size ] = null;\n+                size--;  \n+                if( size != 0 && lastReturnedIndex <= size) {\n+                    int compareToParent = 0;\n+                    if (lastReturnedIndex > 1) {\n+                        compareToParent = compare(elements[lastReturnedIndex], \n+                            elements[lastReturnedIndex / 2]);  \n+                    }\n                     if (ascendingOrder) {\n-                        percolateDownMinHeap(lastReturnedIndex);\n-                    } else {\n-                        percolateDownMaxHeap(lastReturnedIndex);\n-                    }\n+                        if (lastReturnedIndex > 1 && compareToParent < 0) {\n+                            percolateUpMinHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMinHeap(lastReturnedIndex);\n+                        }\n+                    } else {  // max heap\n+                        if (lastReturnedIndex > 1 && compareToParent > 0) {\n+                            percolateUpMaxHeap(lastReturnedIndex); \n+                        } else {\n+                            percolateDownMaxHeap(lastReturnedIndex);\n+                        }\n+                    }          \n                 }\n                 index--;\n-                lastReturnedIndex = -1;\n+                lastReturnedIndex = -1; \n             }\n \n         };\n--- a/src/test/org/apache/commons/collections/TestBinaryHeap.java\n+++ b/src/test/org/apache/commons/collections/TestBinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBinaryHeap.java,v 1.13 2003/11/18 22:37:16 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBinaryHeap.java,v 1.14 2004/01/01 23:56:51 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n import java.util.Collection;\n import java.util.Comparator;\n import java.util.NoSuchElementException;\n+import java.util.Random;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n /**\n  * Tests the BinaryHeap.\n  * \n- * @version $Revision: 1.13 $ $Date: 2003/11/18 22:37:16 $\n+ * @version $Revision: 1.14 $ $Date: 2004/01/01 23:56:51 $\n  * \n  * @author Michael A. Smith\n  */\n             // expected\n         }\n     }\n+    \n+    /**\n+     * Illustrates bad internal heap state reported in Bugzilla PR #235818. \n+     */  \n+    public void testAddRemove() {\n+        resetEmpty();\n+        BinaryHeap heap = (BinaryHeap) collection;\n+        heap.add(new Integer(0));\n+        heap.add(new Integer(2));\n+        heap.add(new Integer(4));\n+        heap.add(new Integer(3));\n+        heap.add(new Integer(8));\n+        heap.add(new Integer(10));\n+        heap.add(new Integer(12));\n+        heap.add(new Integer(3));\n+        confirmed.addAll(heap);\n+        // System.out.println(heap);\n+        Object obj = new Integer(10);\n+        heap.remove(obj);\n+        confirmed.remove(obj);\n+        // System.out.println(heap);\n+        verify();\n+    }\n+    \n+    /**\n+     * Generate heaps staring with Integers from 0 - heapSize - 1.\n+     * Then perform random add / remove operations, checking\n+     * heap order after modifications. Alternates minHeaps, maxHeaps.\n+     *\n+     * Based on code provided by Steve Phelps in PR #25818\n+     *\n+     */\n+    public void testRandom() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        int operations = 20;\n+        Random randGenerator = new Random();\n+        BinaryHeap h = null;\n+        for(int i=0; i < iterations; i++) {\n+            if (i < iterations / 2) {          \n+                h = new BinaryHeap(true);\n+            } else {\n+                h = new BinaryHeap(false);\n+            }\n+            for(int r = 0; r < heapSize; r++) {\n+                h.add( new Integer( randGenerator.nextInt(heapSize)) );\n+            }\n+            for( int r = 0; r < operations; r++ ) {\n+                h.remove(new Integer(r));\n+                h.add(new Integer(randGenerator.nextInt(heapSize)));\n+            }\n+            checkOrder(h);\n+        }\n+    }\n+     \n+    /**\n+     * Pops all elements from the heap and verifies that the elements come off\n+     * in the correct order.  NOTE: this method empties the heap.\n+     */\n+    protected void checkOrder(BinaryHeap h) {\n+        Integer lastNum = null;\n+        Integer num = null;\n+        boolean fail = false;\n+        while (!h.isEmpty()) {\n+            num = (Integer) h.pop();\n+            if (h.m_isMinHeap) {\n+                assertTrue(lastNum == null || num.intValue() >= lastNum.intValue());\n+            } else { // max heap\n+                assertTrue(lastNum == null || num.intValue() <= lastNum.intValue());\n+            }\n+            lastNum = num;\n+            num = null;\n+        }\n+    }\n+    \n+    /**\n+     * Returns a string showing the contents of the heap formatted as a tree.\n+     * Makes no attempt at padding levels or handling wrapping. \n+     */\n+    protected String showTree(BinaryHeap h) {\n+        int count = 1;\n+        StringBuffer buffer = new StringBuffer();\n+        for (int offset = 1; count < h.size() + 1; offset *= 2) {\n+            for (int i = offset; i < offset * 2; i++) {\n+                if (i < h.m_elements.length && h.m_elements[i] != null) \n+                    buffer.append(h.m_elements[i] + \" \");\n+                count++;\n+            }\n+            buffer.append('\\n');\n+        }\n+        return buffer.toString();\n+    }\n \n }\n--- a/src/test/org/apache/commons/collections/buffer/TestBinaryBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBinaryBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/Attic/TestBinaryBuffer.java,v 1.1 2004/01/01 19:01:34 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/Attic/TestBinaryBuffer.java,v 1.2 2004/01/01 23:56:51 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2004 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Comparator;\n+import java.util.Random;\n \n import junit.framework.Test;\n import junit.framework.TestSuite;\n /**\n  * Tests the BinaryHeap.\n  * \n- * @version $Revision: 1.1 $ $Date: 2004/01/01 19:01:34 $\n+ * @version $Revision: 1.2 $ $Date: 2004/01/01 23:56:51 $\n  * \n  * @author Michael A. Smith\n  */\n         } catch (BufferUnderflowException ex) {}\n     }\n \n-//    public void testAddRemove() {\n-//        resetEmpty();\n-//        BinaryBuffer heap = (BinaryBuffer) collection;\n-//        heap.add(new Integer(0));\n-//        heap.add(new Integer(2));\n-//        heap.add(new Integer(4));\n-//        heap.add(new Integer(3));\n-//        heap.add(new Integer(8));\n-//        heap.add(new Integer(10));\n-//        heap.add(new Integer(12));\n-//        heap.add(new Integer(3));\n-//        confirmed.addAll(heap);\n-//        System.out.println(heap);\n-//        Object obj = new Integer(10);\n-//        heap.remove(obj);\n-//        confirmed.remove(obj);\n-//        System.out.println(heap);\n-//        verify();\n-//    }\n+    /**\n+     * Illustrates bad internal heap state reported in Bugzilla PR #235818. \n+     */  \n+    public void testAddRemove() {\n+        resetEmpty();\n+        BinaryBuffer heap = (BinaryBuffer) collection;\n+        heap.add(new Integer(0));\n+        heap.add(new Integer(2));\n+        heap.add(new Integer(4));\n+        heap.add(new Integer(3));\n+        heap.add(new Integer(8));\n+        heap.add(new Integer(10));\n+        heap.add(new Integer(12));\n+        heap.add(new Integer(3));\n+        confirmed.addAll(heap);\n+        // System.out.println(heap);\n+        Object obj = new Integer(10);\n+        heap.remove(obj);\n+        confirmed.remove(obj);\n+        // System.out.println(heap);\n+        verify();\n+    }\n+    \n+    /**\n+     * Generate heaps staring with Integers from 0 - heapSize - 1.\n+     * Then perform random add / remove operations, checking\n+     * heap order after modifications. Alternates minHeaps, maxHeaps.\n+     *\n+     * Based on code provided by Steve Phelps in PR #25818\n+     *\n+     */\n+    public void testRandom() {\n+        int iterations = 500;\n+        int heapSize = 100;\n+        int operations = 20;\n+        Random randGenerator = new Random();\n+        BinaryBuffer h = null;\n+        for(int i=0; i < iterations; i++) {\n+            if (i < iterations / 2) {          \n+                h = new BinaryBuffer(true);\n+            } else {\n+                h = new BinaryBuffer(false);\n+            }\n+            for(int r = 0; r < heapSize; r++) {\n+                h.add( new Integer( randGenerator.nextInt(heapSize)) );\n+            }\n+            for( int r = 0; r < operations; r++ ) {\n+                h.remove(new Integer(r));\n+                h.add(new Integer(randGenerator.nextInt(heapSize)));\n+            }\n+            checkOrder(h);\n+        }\n+    }\n+     \n+    /**\n+     * Pops all elements from the heap and verifies that the elements come off\n+     * in the correct order.  NOTE: this method empties the heap.\n+     */\n+    protected void checkOrder(BinaryBuffer h) {\n+        Integer lastNum = null;\n+        Integer num = null;\n+        boolean fail = false;\n+        while (!h.isEmpty()) {\n+            num = (Integer) h.remove();\n+            if (h.ascendingOrder) {\n+                assertTrue(lastNum == null || num.intValue() >= lastNum.intValue());\n+            } else { // max heap\n+                assertTrue(lastNum == null || num.intValue() <= lastNum.intValue());\n+            }\n+            lastNum = num;\n+            num = null;\n+        }\n+    }\n+    \n+    /**\n+     * Returns a string showing the contents of the heap formatted as a tree.\n+     * Makes no attempt at padding levels or handling wrapping. \n+     */\n+    protected String showTree(BinaryBuffer h) {\n+        int count = 1;\n+        StringBuffer buffer = new StringBuffer();\n+        for (int offset = 1; count < h.size() + 1; offset *= 2) {\n+            for (int i = offset; i < offset * 2; i++) {\n+                if (i < h.elements.length && h.elements[i] != null) \n+                    buffer.append(h.elements[i] + \" \");\n+                count++;\n+            }\n+            buffer.append('\\n');\n+        }\n+        return buffer.toString();\n+    }\n     \n }", "timestamp": 1073001411, "metainfo": ""}