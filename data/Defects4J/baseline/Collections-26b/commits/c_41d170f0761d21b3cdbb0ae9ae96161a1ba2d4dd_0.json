{"sha": "41d170f0761d21b3cdbb0ae9ae96161a1ba2d4dd", "log": "Added an implementation of Eugene Myers difference algorithm.  JIRA: COLLECTIONS-404  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/IndexedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/IndexedCollection.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-\n-import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n-\n-/**\n- * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n- * keyTransformer to define how the keys are converted from the values.\n- * <p>\n- * Modifications made to this decorator modify the index as well as the\n- * decorated {@link Collection}. However, modifications to the underlying\n- * {@link Collection} will not updated the index and it will get out of sync.\n- * <p>\n- * If modification to the decorated {@link Collection} is unavoidable, then a\n- * call to {@link #reindex()} will update the index to the current contents of\n- * the {@link Collection}.\n- *\n- * @param <K> the type of object in the index.\n- * @param <C> the type of object in the collection.\n- * @author Stephen Kestle\n- */\n-// TODO support MultiMap/non-unique index behavior\n-// TODO add support for remove and clear\n-public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n-    /**\n-     * .\n-     */\n-    private static final long serialVersionUID = -5512610452568370038L;\n-\n-    /**\n-     * Create an {@link IndexedCollection} for a unique index.\n-     *\n-     * @param <K> the index object type.\n-     * @param <C> the collection type.\n-     * @param coll the decorated {@link Collection}.\n-     * @param keyTransformer the {@link Transformer} for generating index keys.\n-     * @return the created {@link IndexedCollection}.\n-     */\n-    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n-        return new IndexedCollection<K, C>(coll, keyTransformer, new HashMap<K, C>());\n-    }\n-\n-    /**\n-     * The {@link Transformer} for generating index keys.\n-     */\n-    private final Transformer<C, K> keyTransformer;\n-\n-    /**\n-     * The map of indexes to collected objects.\n-     */\n-    private final HashMap<K, C> index;\n-\n-    /**\n-     * Create a {@link IndexedCollection} for a unique index.\n-     *\n-     * @param coll the decorated {@link Collection}.\n-     * @param keyTransformer the {@link Transformer} for generating index keys.\n-     */\n-    public IndexedCollection(Collection<C> coll, Transformer<C, K> keyTransformer, HashMap<K, C> map) {\n-        super(coll);\n-        this.keyTransformer = keyTransformer;\n-        this.index = map;\n-        reindex();\n-    }\n-\n-    /**\n-     * Clears the index and re-indexes the entire decorated {@link Collection}.\n-     */\n-    public void reindex() {\n-        index.clear();\n-        for (C c : decorated()) {\n-            addIndex(c);\n-        }\n-    }\n-\n-    /**\n-     * Adds an object to the collection and index.\n-     */\n-    @Override\n-    // TODO: Add error handling for when super.add() fails\n-    public boolean add(C object) {\n-        addIndex(object);\n-        return super.add(object);\n-    }\n-\n-    /**\n-     * Adds an entire collection to the collection and index.\n-     */\n-    @Override\n-    // TODO: Add error handling for when super.addAll() fails\n-    public boolean addAll(Collection<? extends C> coll) {\n-        for (C c : coll) {\n-            addIndex(c);\n-        }\n-        return super.addAll(coll);\n-    }\n-\n-    /**\n-     * Provides checking for adding the index.\n-     *\n-     * @param object the object to index.\n-     */\n-    private void addIndex(C object) {\n-        final C existingObject = index.put(keyTransformer.transform(object), object);\n-        if (existingObject != null) {\n-            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n-        }\n-    }\n-\n-    /**\n-     * Get the element associated with the given key.\n-     * @param key to look up\n-     * @return element found\n-     */\n-    public C get(K key) {\n-        return index.get(key);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.collection.AbstractCollectionDecorator;\n+\n+/**\n+ * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n+ * keyTransformer to define how the keys are converted from the values.\n+ * <p>\n+ * Modifications made to this decorator modify the index as well as the\n+ * decorated {@link Collection}. However, modifications to the underlying\n+ * {@link Collection} will not updated the index and it will get out of sync.\n+ * <p>\n+ * If modification to the decorated {@link Collection} is unavoidable, then a\n+ * call to {@link #reindex()} will update the index to the current contents of\n+ * the {@link Collection}.\n+ *\n+ * @param <K> the type of object in the index.\n+ * @param <C> the type of object in the collection.\n+ * @author Stephen Kestle\n+ */\n+// TODO support MultiMap/non-unique index behavior\n+// TODO add support for remove and clear\n+public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n+    /**\n+     * .\n+     */\n+    private static final long serialVersionUID = -5512610452568370038L;\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a unique index.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer, new HashMap<K, C>());\n+    }\n+\n+    /**\n+     * The {@link Transformer} for generating index keys.\n+     */\n+    private final Transformer<C, K> keyTransformer;\n+\n+    /**\n+     * The map of indexes to collected objects.\n+     */\n+    private final HashMap<K, C> index;\n+\n+    /**\n+     * Create a {@link IndexedCollection} for a unique index.\n+     *\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     */\n+    public IndexedCollection(Collection<C> coll, Transformer<C, K> keyTransformer, HashMap<K, C> map) {\n+        super(coll);\n+        this.keyTransformer = keyTransformer;\n+        this.index = map;\n+        reindex();\n+    }\n+\n+    /**\n+     * Clears the index and re-indexes the entire decorated {@link Collection}.\n+     */\n+    public void reindex() {\n+        index.clear();\n+        for (C c : decorated()) {\n+            addIndex(c);\n+        }\n+    }\n+\n+    /**\n+     * Adds an object to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.add() fails\n+    public boolean add(C object) {\n+        addIndex(object);\n+        return super.add(object);\n+    }\n+\n+    /**\n+     * Adds an entire collection to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.addAll() fails\n+    public boolean addAll(Collection<? extends C> coll) {\n+        for (C c : coll) {\n+            addIndex(c);\n+        }\n+        return super.addAll(coll);\n+    }\n+\n+    /**\n+     * Provides checking for adding the index.\n+     *\n+     * @param object the object to index.\n+     */\n+    private void addIndex(C object) {\n+        final C existingObject = index.put(keyTransformer.transform(object), object);\n+        if (existingObject != null) {\n+            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n+        }\n+    }\n+\n+    /**\n+     * Get the element associated with the given key.\n+     * @param key to look up\n+     * @return element found\n+     */\n+    public C get(K key) {\n+        return index.get(key);\n+    }\n+}\n--- a/src/main/java/org/apache/commons/collections/functors/CatchAndRethrowClosure.java\n+++ b/src/main/java/org/apache/commons/collections/functors/CatchAndRethrowClosure.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections.functors;\n-\n-import org.apache.commons.collections.Closure;\n-import org.apache.commons.collections.FunctorException;\n-\n-/**\n- * {@link Closure} that catches any checked exception and re-throws it as a\n- * {@link FunctorException} runtime exception. Example usage:\n- * \n- * <pre>\n- * // Create a catch and re-throw closure via anonymous subclass\n- * CatchAndRethrowClosure&lt;String&gt; writer = new ThrowingClosure() {\n- *     private java.io.Writer out = // some writer\n- *     \n- *     protected void executeAndThrow(String input) throws IOException {\n- *         out.write(input); // throwing of IOException allowed\n- *     }\n- * };\n- * \n- * // use catch and re-throw closure\n- * java.util.List<String> strList = // some list\n- * try {\n- *     CollctionUtils.forAllDo(strList, writer);\n- * } catch (FunctorException ex) {\n- *     Throwable originalError = ex.getCause();\n- *     // handle error\n- * }\n- * </pre>\n- * \n- * @since Commons Collections 4.0\n- * @version $Revision$\n- */\n-public abstract class CatchAndRethrowClosure<E> implements Closure<E> {\n-\n-    /**\n-     * Execute this closure on the specified input object.\n-     * \n-     * @param input the input to execute on\n-     * @throws FunctorException (runtime) if the closure execution resulted in a\n-     *             checked exception.\n-     */\n-    public void execute(E input) {\n-        try {\n-            executeAndThrow(input);\n-        } catch (RuntimeException ex) {\n-            throw ex;\n-        } catch (Throwable t) {\n-            throw new FunctorException(t);\n-        }\n-    }\n-\n-    /**\n-     * Execute this closure on the specified input object.\n-     * \n-     * @param input the input to execute on\n-     * @throws Throwable if the closure execution resulted in a checked\n-     *             exception.\n-     */\n-    protected abstract void executeAndThrow(E input) throws Throwable;\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.FunctorException;\n+\n+/**\n+ * {@link Closure} that catches any checked exception and re-throws it as a\n+ * {@link FunctorException} runtime exception. Example usage:\n+ * \n+ * <pre>\n+ * // Create a catch and re-throw closure via anonymous subclass\n+ * CatchAndRethrowClosure&lt;String&gt; writer = new ThrowingClosure() {\n+ *     private java.io.Writer out = // some writer\n+ *     \n+ *     protected void executeAndThrow(String input) throws IOException {\n+ *         out.write(input); // throwing of IOException allowed\n+ *     }\n+ * };\n+ * \n+ * // use catch and re-throw closure\n+ * java.util.List<String> strList = // some list\n+ * try {\n+ *     CollctionUtils.forAllDo(strList, writer);\n+ * } catch (FunctorException ex) {\n+ *     Throwable originalError = ex.getCause();\n+ *     // handle error\n+ * }\n+ * </pre>\n+ * \n+ * @since Commons Collections 4.0\n+ * @version $Revision$\n+ */\n+public abstract class CatchAndRethrowClosure<E> implements Closure<E> {\n+\n+    /**\n+     * Execute this closure on the specified input object.\n+     * \n+     * @param input the input to execute on\n+     * @throws FunctorException (runtime) if the closure execution resulted in a\n+     *             checked exception.\n+     */\n+    public void execute(E input) {\n+        try {\n+            executeAndThrow(input);\n+        } catch (RuntimeException ex) {\n+            throw ex;\n+        } catch (Throwable t) {\n+            throw new FunctorException(t);\n+        }\n+    }\n+\n+    /**\n+     * Execute this closure on the specified input object.\n+     * \n+     * @param input the input to execute on\n+     * @throws Throwable if the closure execution resulted in a checked\n+     *             exception.\n+     */\n+    protected abstract void executeAndThrow(E input) throws Throwable;\n+}\n--- a/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/ComparatorPredicate.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections.functors;\n-\n-import java.io.Serializable;\n-import java.util.Comparator;\n-\n-import org.apache.commons.collections.Predicate;\n-\n-/**\n- * Predicate that compares the input object with the one stored in the predicate using a comparator.\n- * In addition, the comparator result can be evaluated in accordance to a supplied criterion value.\n- *\n- * In order to demonstrate the use of the predicate, the following variables are declared:\n- *\n- * <pre>\n- * Integer ONE = new Integer(1);\n- * Integer TWO = new Integer(2);\n- *\n- * Comparator comparator = new Comparator() {\n- *\n- *     public int compare(Object first, Object second) {\n- *         return ((Integer) second) - ((Integer) first);\n- *     }\n- *\n- * };\n- * </pre>\n- *\n- * Using the declared variables, the <code>ComparatorPredicate</code> can be used used in the\n- * following way:\n- *\n- * <pre>\n- * ComparatorPredicate.getInstance(ONE, comparator).evaluate(TWO);\n- * </pre>\n- *\n- * The input variable <code>TWO</code> in compared to the stored variable <code>ONE</code> using\n- * the supplied <code>comparator</code>. This is the default usage of the predicate and will return\n- * <code>true</code> if the underlying comparator returns <code>0</code>. In addition to the default\n- * usage of the predicate, it is possible to evaluate the comparator's result in several ways. The\n- * following {@link Criterion} enumeration values are provided by the predicate:\n- * </p>\n- *\n- * <ul>\n- *     <li>EQUAL</li>\n- *     <li>GREATER</li>\n- *     <li>GREATER_OR_EQUAL</li>\n- *     <li>LESS</li>\n- *     <li>LESS_OR_EQUAL</li>\n- * </ul>\n- *\n- * The following examples demonstrates how these constants can be used in order to manipulate the\n- * evaluation of a comparator result.\n- *\n- * <pre>\n- * ComparatorPredicate.getInstance(ONE, comparator, <b>ComparatorPredicate.Criterion.GREATER</b>).evaluate(TWO);\n- * </pre>\n- *\n- * The input variable TWO is compared to the stored variable ONE using the supplied <code>comparator</code>\n- * using the <code>GREATER</code> evaluation criterion constant. This instructs the predicate to\n- * return <code>true</code> if the comparator returns a value greater than <code>0</code>.\n- *\n- * @since Commons Collections 4.0\n- * @version $Revision$\n- *\n- * @author Rune Peter Bjrnstad.\n- */\n-public class ComparatorPredicate<T> implements Predicate<T>, Serializable {\n-\n-    private static final long serialVersionUID = -1863209236504077399L;\n-\n-    public enum Criterion {\n-        EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL,\n-    }\n-\n-    // Instance variables:\n-\n-    /** The internal object to compare with */\n-    private final T object;\n-\n-    /** The comparator to use for comparison */\n-    private final Comparator<T> comparator;\n-\n-    /** The comparison evaluation criterion to use */\n-    private final Criterion criterion;\n-\n-    /**\n-     * Factory to create the comparator predicate\n-     *\n-     * @param object  the object to compare to\n-     * @param comparator  the comparator to use for comparison\n-     * @return the predicate\n-     * @throws IllegalArgumentException if comparator is null\n-     */\n-    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator) {\n-        return comparatorPredicate(object, comparator, Criterion.EQUAL);\n-    }\n-\n-    /**\n-     * Factory to create the comparator predicate\n-     *\n-     * @param object  the object to compare to\n-     * @param comparator  the comparator to use for comparison\n-     * @param criterion  the criterion to use to evaluate comparison\n-     * @return the predicate\n-     * @throws IllegalArgumentException if comparator is null of criterion is invalid\n-     */\n-    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n-        if (comparator == null) {\n-            throw new IllegalArgumentException(\"Comparator must not be null.\");\n-        }\n-        if (criterion == null) {\n-            throw new IllegalArgumentException(\"Criterion must not be null.\");\n-        }\n-        return new ComparatorPredicate<T>(object, comparator, criterion);\n-    }\n-\n-    /**\n-     * Constructor that performs no validation.\n-     * Use <code>getInstance</code> if you want.\n-     *\n-     * @param object  the object to compare to\n-     * @param comparator  the comparator to use for comparison\n-     * @param criterion  the criterion to use to evaluate comparison\n-     */\n-    public ComparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n-        super();\n-        this.object = object;\n-        this.comparator = comparator;\n-        this.criterion = criterion;\n-    }\n-\n-    /**\n-     * Evaluates the predicate. The predicate evaluates to <code>true</code> in the following cases:\n-     *\n-     * <ul>\n-     *     <li><code>comparator.compare(object, input) == 0 && criterion == EQUAL</code></li>\n-     *     <li><code>comparator.compare(object, input) < 0 && criterion == LESS</code></li>\n-     *     <li><code>comparator.compare(object, input) > 0 && criterion == GREATER</code></li>\n-     *     <li><code>comparator.compare(object, input) >= 0 && criterion == GREATER_OR_EQUAL</code></li>\n-     *     <li><code>comparator.compare(object, input) <= 0 && criterion == LESS_OR_EQUAL</code></li>\n-     * </ul>\n-     *\n-     * @see org.apache.commons.collections.Predicate#evaluate(java.lang.Object)\n-     * @see java.util.Comparator#compare(java.lang.Object first, java.lang.Object second)\n-     *\n-     * @throws IllegalStateException if the criterion is invalid (really not possible)\n-     */\n-    public boolean evaluate(T target) {\n-\n-        boolean result = false;\n-        int comparison = comparator.compare(object, target);\n-        switch (criterion) {\n-        case EQUAL:\n-            result = (comparison == 0);\n-            break;\n-        case GREATER:\n-            result = (comparison > 0);\n-            break;\n-        case LESS:\n-            result = (comparison < 0);\n-            break;\n-        case GREATER_OR_EQUAL:\n-            result = (comparison >= 0);\n-            break;\n-        case LESS_OR_EQUAL:\n-            result = (comparison <= 0);\n-            break;\n-        default:\n-            throw new IllegalStateException(\"The current criterion '\" + criterion + \"' is invalid.\");\n-        }\n-\n-        return result;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Predicate;\n+\n+/**\n+ * Predicate that compares the input object with the one stored in the predicate using a comparator.\n+ * In addition, the comparator result can be evaluated in accordance to a supplied criterion value.\n+ *\n+ * In order to demonstrate the use of the predicate, the following variables are declared:\n+ *\n+ * <pre>\n+ * Integer ONE = new Integer(1);\n+ * Integer TWO = new Integer(2);\n+ *\n+ * Comparator comparator = new Comparator() {\n+ *\n+ *     public int compare(Object first, Object second) {\n+ *         return ((Integer) second) - ((Integer) first);\n+ *     }\n+ *\n+ * };\n+ * </pre>\n+ *\n+ * Using the declared variables, the <code>ComparatorPredicate</code> can be used used in the\n+ * following way:\n+ *\n+ * <pre>\n+ * ComparatorPredicate.getInstance(ONE, comparator).evaluate(TWO);\n+ * </pre>\n+ *\n+ * The input variable <code>TWO</code> in compared to the stored variable <code>ONE</code> using\n+ * the supplied <code>comparator</code>. This is the default usage of the predicate and will return\n+ * <code>true</code> if the underlying comparator returns <code>0</code>. In addition to the default\n+ * usage of the predicate, it is possible to evaluate the comparator's result in several ways. The\n+ * following {@link Criterion} enumeration values are provided by the predicate:\n+ * </p>\n+ *\n+ * <ul>\n+ *     <li>EQUAL</li>\n+ *     <li>GREATER</li>\n+ *     <li>GREATER_OR_EQUAL</li>\n+ *     <li>LESS</li>\n+ *     <li>LESS_OR_EQUAL</li>\n+ * </ul>\n+ *\n+ * The following examples demonstrates how these constants can be used in order to manipulate the\n+ * evaluation of a comparator result.\n+ *\n+ * <pre>\n+ * ComparatorPredicate.getInstance(ONE, comparator, <b>ComparatorPredicate.Criterion.GREATER</b>).evaluate(TWO);\n+ * </pre>\n+ *\n+ * The input variable TWO is compared to the stored variable ONE using the supplied <code>comparator</code>\n+ * using the <code>GREATER</code> evaluation criterion constant. This instructs the predicate to\n+ * return <code>true</code> if the comparator returns a value greater than <code>0</code>.\n+ *\n+ * @since Commons Collections 4.0\n+ * @version $Revision$\n+ *\n+ * @author Rune Peter Bjrnstad.\n+ */\n+public class ComparatorPredicate<T> implements Predicate<T>, Serializable {\n+\n+    private static final long serialVersionUID = -1863209236504077399L;\n+\n+    public enum Criterion {\n+        EQUAL, GREATER, LESS, GREATER_OR_EQUAL, LESS_OR_EQUAL,\n+    }\n+\n+    // Instance variables:\n+\n+    /** The internal object to compare with */\n+    private final T object;\n+\n+    /** The comparator to use for comparison */\n+    private final Comparator<T> comparator;\n+\n+    /** The comparison evaluation criterion to use */\n+    private final Criterion criterion;\n+\n+    /**\n+     * Factory to create the comparator predicate\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if comparator is null\n+     */\n+    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator) {\n+        return comparatorPredicate(object, comparator, Criterion.EQUAL);\n+    }\n+\n+    /**\n+     * Factory to create the comparator predicate\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @param criterion  the criterion to use to evaluate comparison\n+     * @return the predicate\n+     * @throws IllegalArgumentException if comparator is null of criterion is invalid\n+     */\n+    public static <T> Predicate<T> comparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n+        if (comparator == null) {\n+            throw new IllegalArgumentException(\"Comparator must not be null.\");\n+        }\n+        if (criterion == null) {\n+            throw new IllegalArgumentException(\"Criterion must not be null.\");\n+        }\n+        return new ComparatorPredicate<T>(object, comparator, criterion);\n+    }\n+\n+    /**\n+     * Constructor that performs no validation.\n+     * Use <code>getInstance</code> if you want.\n+     *\n+     * @param object  the object to compare to\n+     * @param comparator  the comparator to use for comparison\n+     * @param criterion  the criterion to use to evaluate comparison\n+     */\n+    public ComparatorPredicate(T object, Comparator<T> comparator, Criterion criterion) {\n+        super();\n+        this.object = object;\n+        this.comparator = comparator;\n+        this.criterion = criterion;\n+    }\n+\n+    /**\n+     * Evaluates the predicate. The predicate evaluates to <code>true</code> in the following cases:\n+     *\n+     * <ul>\n+     *     <li><code>comparator.compare(object, input) == 0 && criterion == EQUAL</code></li>\n+     *     <li><code>comparator.compare(object, input) < 0 && criterion == LESS</code></li>\n+     *     <li><code>comparator.compare(object, input) > 0 && criterion == GREATER</code></li>\n+     *     <li><code>comparator.compare(object, input) >= 0 && criterion == GREATER_OR_EQUAL</code></li>\n+     *     <li><code>comparator.compare(object, input) <= 0 && criterion == LESS_OR_EQUAL</code></li>\n+     * </ul>\n+     *\n+     * @see org.apache.commons.collections.Predicate#evaluate(java.lang.Object)\n+     * @see java.util.Comparator#compare(java.lang.Object first, java.lang.Object second)\n+     *\n+     * @throws IllegalStateException if the criterion is invalid (really not possible)\n+     */\n+    public boolean evaluate(T target) {\n+\n+        boolean result = false;\n+        int comparison = comparator.compare(object, target);\n+        switch (criterion) {\n+        case EQUAL:\n+            result = (comparison == 0);\n+            break;\n+        case GREATER:\n+            result = (comparison > 0);\n+            break;\n+        case LESS:\n+            result = (comparison < 0);\n+            break;\n+        case GREATER_OR_EQUAL:\n+            result = (comparison >= 0);\n+            break;\n+        case LESS_OR_EQUAL:\n+            result = (comparison <= 0);\n+            break;\n+        default:\n+            throw new IllegalStateException(\"The current criterion '\" + criterion + \"' is invalid.\");\n+        }\n+\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/CommandVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+\n+/** This interface should be implemented by user object to walk\n+ * through {@link EditScript EditScript} objects.\n+\n+ * <p>Users should implement this interface in order to walk through\n+ * the {@link EditScript EditScript} object created by the comparison\n+ * of two sequences. This is a direct application of the visitor\n+ * design pattern. The {@link EditScript#visit EditScript.visit}\n+ * method takes an object implementing this interface as an argument,\n+ * it will perform the loop over all commands in the script and the\n+ * proper methods of the user class will be called as the commands are\n+ * encountered.</p>\n+\n+ * <p>The implementation of the user visitor class will depend on the\n+ * need. Here are two examples.\n+ * </p>\n+ * \n+ * <p>\n+ * The first example is a visitor that build the longest common\n+ * subsequence:\n+ * <pre>\n+ * import org.apache.commons.collections.list.difference.CommandVisitor;\n+ * \n+ * import java.util.ArrayList;\n+ *\n+ * public class LongestCommonSubSequence implements CommandVisitor {\n+ * \n+ *   public LongestCommonSubSequence() {\n+ *     a = new ArrayList();\n+ *   }\n+ * \n+ *   public void visitInsertCommand(Object object) {\n+ *   }\n+ * \n+ *   public void visitKeepCommand(Object object) {\n+ *     a.add(object);\n+ *   }\n+ * \n+ *   public void visitDeleteCommand(Object object) {\n+ *   }\n+ * \n+ *   public Object[] getSubSequence() {\n+ *     return a.toArray();\n+ *   }\n+ * \n+ *   private arrayList a;\n+ * \n+ * }\n+ * </pre>\n+ * </p>\n+ * \n+ * <p>\n+ * The second example is a visitor that shows the commands and the way\n+ * they transform the first sequence into the second one:\n+ * <pre>\n+ * import org.apache.commons.collections.list.difference.CommandVisitor;\n+ * \n+ * import java.util.Arrays;\n+ * import java.util.ArrayList;\n+ * import java.util.Iterator;\n+ *\n+ * public class ShowVisitor implements CommandVisitor {\n+ * \n+ *   public ShowVisitor(Object[] sequence1) {\n+ *     v = new ArrayList();\n+ *     v.addAll(Arrays.asList(sequence1));\n+ *     index = 0;\n+ *   }\n+ * \n+ *   public void visitInsertCommand(Object object) {\n+ *     v.insertElementAt(object, index++);\n+ *     display(\"insert\", object);\n+ *   }\n+ * \n+ *   public void visitKeepCommand(Object object) {\n+ *     ++index;\n+ *     display(\"keep  \", object);\n+ *   }\n+ * \n+ *   public void visitDeleteCommand(Object object) {\n+ *     v.remove(index);\n+ *     display(\"delete\", object);\n+ *   }\n+ * \n+ *   private void display(String commandName, Object object) {\n+ *     System.out.println(commandName + \" \" + object + \" ->\" + this);\n+ *   }\n+ * \n+ *   public String toString() {\n+ *     StringBuffer buffer = new StringBuffer();\n+ *     for (Iterator iter = v.iterator(); iter.hasNext();) {\n+ *       buffer.append(' ').append(iter.next());\n+ *     }\n+ *     return buffer.toString();\n+ *   }\n+ * \n+ *   private ArrayList v;\n+ *   private int index;\n+ * \n+ * }\n+ * </pre>\n+ * </p>\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+\n+ */\n+public interface CommandVisitor<T> {\n+\n+    /** Method called when an insert command is encountered.\n+     * @param object object to insert (this object comes from the\n+     * second sequence)\n+     */\n+    void visitInsertCommand(T object);\n+\n+    /** Method called when a keep command is encountered.\n+     * @param object object to keep (this object comes from the\n+     * first sequence)\n+     */\n+    void visitKeepCommand(T object);\n+\n+    /** Method called when a delete command is encountered.\n+     * @param object object to delete (this object comes from the\n+     * first sequence)\n+     */\n+    void visitDeleteCommand(T object);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/DeleteCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+\n+/** Command representing the deletion of one object of the first sequence.\n+\n+ * When one object of the first sequence has no corresponding object\n+ * in the second sequence at the right place, the {@link EditScript\n+ * edit script} transforming the first sequence into the second\n+ * sequence uses an instance of this class to represent the deletion\n+ * of this object. The objects embedded in these type of commands\n+ * always come from the first sequence.\n+\n+ * @see SequencesComparator\n+ * @see EditScript\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+ */\n+public class DeleteCommand<T> extends EditCommand<T> {\n+    \n+    /** Simple constructor.\n+     * Creates a new instance of DeleteCommand\n+     * @param object the object of the first sequence that should be deleted\n+     */\n+    public DeleteCommand(T object) {\n+      super(object);\n+    }\n+    \n+    /** Accept a visitor.\n+     * When a <code>DeleteCommand</code> accepts a visitor, it calls\n+     * its {@link CommandVisitor#visitDeleteCommand\n+     * visitDeleteCommand} method.\n+     * @param visitor the visitor to be accepted\n+     */    \n+    public void accept(CommandVisitor<T> visitor) {\n+      visitor.visitDeleteCommand(object);\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/EditCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+\n+/** Abstract base class for all commands used to transform an objects\n+ *  sequence into another one.\n+\n+ * <p>When two objects sequences are compared through the {@link\n+ * SequencesComparator#getScript SequencesComparator.getScript}\n+ * method, the result is provided has a {@link EditScript script}\n+ * containing the commands that progressively transform the first\n+ * sequence into the second one.</p>\n+\n+ * <p>There are only three types of commands, all of which are\n+ * subclasses of this abstract class. Each command is associated with\n+ * one object belonging to at least one of the sequences. These\n+ * commands are {@link InsertCommand InsertCommand} which correspond\n+ * to an object of the second sequence beeing inserted into the first\n+ * sequence, {@link DeleteCommand DeleteCommand} which correspond to\n+ * an object of the first sequence beeing removed and {@link\n+ * KeepCommand KeepCommand} which correspond to an object of the first\n+ * sequence which <code>equals</code> an object in the second\n+ * sequence. It is guaranteed that comparison is always performed this\n+ * way (i.e. the <code>equals</code> method of the object from the\n+ * first sequence is used and the object passed as an argument comes\n+ * from the second sequence) ; this can be important if subclassing is\n+ * used for some elements in the first sequence and the\n+ * <code>equals</code> method is specialized.</p>\n+\n+ * @see SequencesComparator\n+ * @see EditScript\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+ */\n+public abstract class EditCommand<T> {\n+\n+  /** Simple constructor.\n+   * Creates a new instance of EditCommand\n+   * @param object reference to the object associated with this\n+   * command, this refers to an element of one of the sequences\n+   * beeing compared\n+   */\n+  protected EditCommand(T object) {\n+    this.object = object;\n+  }\n+    \n+  /** Accept a visitor.\n+   * This method is invoked for each commands belonging to an {@link\n+   * EditScript EditScript}, in order to implement the visitor\n+   * design pattern\n+   * @param visitor the visitor to be accepted\n+   */    \n+  public abstract void accept(CommandVisitor<T> visitor);\n+    \n+  /** Object on which the command should be applied. */\n+  protected T object;\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/EditScript.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ *  This class gathers all the {@link EditCommand commands} needed to\n+ *  transform one objects sequence into another objects sequence.\n+\n+ * <p>An edit script is the most general view of the differences\n+ * between two sequences. It is built as the result of the comparison\n+ * between two sequences by the {@link SequencesComparator\n+ * SequencesComparator} class. The user can walk through it using\n+ * the <em>visitor</em> design pattern.</p>\n+\n+ * <p>It is guaranteed that the objects embedded in the {@link\n+ * InsertCommand insert commands} come from the second sequence and\n+ * that the objects embedded in either the {@link DeleteCommand delete\n+ * commands} or {@link KeepCommand keep commands} come from the first\n+ * sequence. This can be important if subclassing is used for some\n+ * elements in the first sequence and the <code>equals</code> method\n+ * is specialized.</p>\n+\n+ * @see SequencesComparator\n+ * @see EditCommand\n+ * @see CommandVisitor\n+ * @see ReplacementsHandler\n+ *\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+ */\n+public class EditScript<T> {\n+\n+  /** Container for the commands. */\n+  private List<EditCommand<T>> commands;\n+\n+  /** Length of the longest common subsequence. */\n+  private int lcsLength;\n+\n+  /** Number of modifications. */\n+  private int modifications;\n+\n+  /** Simple constructor.\n+   * Creates a new empty script.\n+   */\n+  public EditScript() {\n+    commands      = new ArrayList<EditCommand<T>>();\n+    lcsLength     = 0;\n+    modifications = 0;\n+  }\n+\n+  /** Add a keep command to the script.\n+   * @param command command to add\n+   */\n+  public void append(KeepCommand<T> command) {\n+    commands.add(command);\n+    ++lcsLength;\n+  }\n+\n+  /** Add an insert command to the script.\n+   * @param command command to add\n+   */\n+  public void append(InsertCommand<T> command) {\n+    commands.add(command);\n+    ++modifications;\n+  }\n+\n+  /** Add a delete command to the script.\n+   * @param command command to add\n+   */\n+  public void append(DeleteCommand<T> command) {\n+    commands.add(command);\n+    ++modifications;\n+  }\n+\n+  /** Visit the script.\n+   * The script implements the <em>visitor</em> design pattern, this\n+   * method is the entry point to which the user supplies its own\n+   * visitor, the script will be responsible to drive it through the\n+   * commands in order and call the appropriate method as each\n+   * command is encountered.\n+   * @param visitor the visitor that will visit all commands in turn\n+   */\n+  public void visit(CommandVisitor<T> visitor) {\n+    for (EditCommand<T> command : commands) {\n+      command.accept(visitor);\n+    }\n+  }\n+\n+  /** Get the length of the Longest Common Subsequence (LCS).\n+   * The length of the longest common subsequence is the number of\n+   * {@link KeepCommand keep commands} in the script.\n+   * @return length of the Longest Common Subsequence\n+   */\n+  public int getLCSLength() {\n+    return lcsLength;\n+  }\n+\n+  /** Get the number of effective modifications.\n+   * The number of effective modification is the number of {@link\n+   * DeleteCommand delete} and {@link InsertCommand insert} commands\n+   * in the script.\n+   * @return number of effective modifications\n+   */\n+  public int getModifications() {\n+    return modifications;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/InsertCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+\n+/** Command representing the insertion of one object of the second sequence.\n+\n+ * When one object of the second sequence has no corresponding object\n+ * in the first sequence at the right place, the {@link EditScript\n+ * edit script} transforming the first sequence into the second\n+ * sequence uses an instance of this class to represent the insertion\n+ * of this object. The objects embedded in these type of commands\n+ * always come from the second sequence.\n+\n+ * @see SequencesComparator\n+ * @see EditScript\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+ */\n+public class InsertCommand<T> extends EditCommand<T> {\n+    \n+    /** Simple constructor.\n+     * Creates a new instance of InsertCommand\n+     * @param object the object of the second sequence that should be inserted\n+     */\n+    public InsertCommand(T object) {\n+      super(object);\n+    }\n+    \n+    /** Accept a visitor.\n+     * When an <code>InsertCommand</code> accepts a visitor, it calls\n+     * its {@link CommandVisitor#visitInsertCommand\n+     * visitInsertCommand} method.\n+     * @param visitor the visitor to be accepted\n+     */    \n+    public void accept(CommandVisitor<T> visitor) {\n+      visitor.visitInsertCommand(object);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/KeepCommand.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+\n+/** Command representing the keeping of one object present in both sequences.\n+\n+ * When one object of the first sequence <code>equals</code> another\n+ * objects in the second sequence at the right place, the {@link\n+ * EditScript edit script} transforming the first sequence into the\n+ * second sequence uses an instance of this class to represent the\n+ * keeping of this object. The objects embedded in these type of\n+ * commands always come from the first sequence.\n+\n+ * @see SequencesComparator\n+ * @see EditScript\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+ */\n+public class KeepCommand<T> extends EditCommand<T> {\n+    \n+    /** Simple constructor.\n+     * Creates a new instance of KeepCommand\n+     * @param object the object belonging to both sequences (the\n+     * object is a reference to the instance in the first sequence\n+     * which is known to be equal to an instance in the second\n+     * sequence)\n+     */\n+    public KeepCommand(T object) {\n+      super(object);\n+    }\n+\n+    /** Accept a visitor.\n+     * When a <code>KeepCommand</code> accepts a visitor, it calls\n+     * its {@link CommandVisitor#visitKeepCommand visitKeepCommand} method.\n+     * @param visitor the visitor to be accepted\n+     */    \n+    public void accept(CommandVisitor<T> visitor) {\n+      visitor.visitKeepCommand(object);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/ReplacementsFinder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * This class handles sequences of replacements resulting from a\n+ * comparison.\n+\n+ * <p>The comparison of two objects sequences leads to the\n+ * identification of common parts and parts which only belong to the\n+ * first or to the second sequence. The common parts appear in the\n+ * edit script in the form of <em>keep</em> commands, they can be considered\n+ * as synchronization objects between the two sequences. These\n+ * synchronization objects split the two sequences in synchronized\n+ * sub-sequences. The first sequence can be transformed into the second\n+ * one by replacing each synchronized sub-sequence of the first\n+ * sequence by the corresponding sub-sequence of the second\n+ * sequence. This is a synthetic way to see an {@link EditScript edit\n+ * script}, replacing individual {@link DeleteCommand delete}, {@link\n+ * KeepCommand keep} and {@link InsertCommand insert} commands by\n+ * fewer replacements acting on complete sub-sequences.</p>\n+\n+ * <p>This class is devoted to perform this interpretation. It visits\n+ * an {@link EditScript edit script} (because it implements the {@link\n+ * CommandVisitor CommandVisitor} interface) and calls a user-supplied\n+ * handler implementing the {@link ReplacementsHandler\n+ * ReplacementsHandler} interface to process the sub-sequences.</p>\n+\n+ * @see ReplacementsHandler\n+ * @see EditScript\n+ * @see SequencesComparator\n+ \n+ * @since 4.0\n+ * @author Luc Maisonobe\n+ * @author Jordane Sarda\n+ * @version $Id$\n+ */\n+public class ReplacementsFinder<T> implements CommandVisitor<T> {\n+\n+  private List<T> pendingInsertions;\n+  private List<T> pendingDeletions;\n+  private int     skipped;\n+\n+  /** Handler to call when synchronized sequences are found. */\n+  private ReplacementsHandler<T> handler;\n+  \n+  /** Simple constructor.\n+   * Creates a new instance of ReplacementsFinder\n+   * @param handler handler to call when synchronized sequences are\n+   * found\n+   */\n+  public ReplacementsFinder(ReplacementsHandler<T> handler) {\n+    pendingInsertions = new ArrayList<T>();\n+    pendingDeletions  = new ArrayList<T>();\n+    skipped           = 0;\n+    this.handler      = handler;\n+  }\n+\n+  /** Add an object to the pending insertions set.\n+   * @param object object to insert\n+   */\n+  public void visitInsertCommand(T object) {\n+    pendingInsertions.add(object);\n+  }\n+  \n+  /** Handle a synchronization object.\n+   * <p>When a synchronization object is identified, the pending\n+   * insertions and pending deletions sets are provided to the user\n+   * handler as subsequences.</p>\n+   * @param object synchronization object detected\n+   */\n+  public void visitKeepCommand(T object) {\n+    if (pendingDeletions.isEmpty() && pendingInsertions.isEmpty()) {\n+      ++skipped;\n+    } else {\n+      handler.handleReplacement(skipped, pendingDeletions, pendingInsertions);\n+      pendingDeletions.clear();\n+      pendingInsertions.clear();\n+      skipped = 1;\n+    }\n+  }\n+  \n+  /** Add an object to the pending deletions set.\n+   * @param object object to delete\n+   */\n+  public void visitDeleteCommand(T object) {\n+    pendingDeletions.add(object);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/ReplacementsHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+import java.util.List;\n+\n+/** This interface is devoted to handle synchronized replacement sequences.\n+ * @see ReplacementsFinder\n+ * @since 4.0\n+ * @author Luc Maisonobe\n+ * @version $Id$\n+ */\n+public interface ReplacementsHandler<T> {\n+\n+  /** Handle two synchronized sequences.\n+   * <p>This method is called by a {@link ReplacementsFinder\n+   * ReplacementsFinder} instance when it has synchronized two\n+   * sub-sequences of object arrays being compared, and at least one\n+   * of the sequences is non-empty. Since the sequences are\n+   * synchronized, the objects before the two sub-sequences are equals\n+   * (if they exist). This property also holds for the objects after the\n+   * two sub-sequences.</p>\n+   * <p>The replacement is defined as replacing the <code>from</code>\n+   * sub-sequence into the <code>to</code> sub-sequence.</p>\n+   * @param skipped number of tokens skipped since the last call (i.e.\n+   * number of tokens that were in both sequences), this number should\n+   * be strictly positive except on the very first call where it can be\n+   * zero (if the first object of the two sequences are different)\n+   * @param from sub-sequence of objects coming from the first sequence\n+   * @param to sub-sequence of objects coming from the second sequence\n+   */\n+  public void handleReplacement(int skipped, List<T> from, List<T> to);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/SequencesComparator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+import java.util.List;\n+\n+\n+/**\n+\n+ * This class allows to compare two objects sequences.\n+\n+ * <p>The two sequences can hold any object type, as only the\n+ * <code>equals</code> method is used to compare the elements of the\n+ * sequences. It is guaranteed that the comparisons will always be\n+ * done as <code>o1.equals(o2)</code> where <code>o1</code> belongs to\n+ * the first sequence and <code>o2</code> belongs to the second\n+ * sequence. This can be important if subclassing is used for some\n+ * elements in the first sequence and the <code>equals</code> method\n+ * is specialized.</p>\n+\n+ * <p>Comparison can be seen from two points of view: either as\n+ * giving the smallest modification allowing to transform the first\n+ * sequence into the second one, or as giving the longest sequence\n+ * which is a subsequence of both initial sequences. The\n+ * <code>equals</code> method is used to compare objects, so any\n+ * object can be put into sequences. Modifications include deleting,\n+ * inserting or keeping one object, starting from the beginning of the\n+ * first sequence.</p>\n+\n+ * <p>This class implements the comparison algorithm, which is the\n+ * very efficient algorithm from Eugene W. Myers <a\n+ * href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">An\n+ * O(ND) Difference Algorithm and Its Variations</a>. This algorithm\n+ * produces the shortest possible {@link\n+ * org.apache.commons.collections.list.difference.EditScript edit script}\n+ * containing all the {@link\n+ * org.apache.commons.collections.list.difference.EditCommand commands} needed to\n+ * transform the first sequence into the second one.</p>\n+\n+ * @see EditScript\n+ * @see EditCommand\n+ * @see CommandVisitor\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @version $Id$\n+ */\n+public class SequencesComparator<T> {\n+\n+  /** First sequence. */\n+  private List<T> sequence1;\n+\n+  /** Second sequence. */\n+  private List<T> sequence2;\n+\n+  /** Temporary variables. */\n+  private int[] vDown;\n+  private int[] vUp;\n+\n+  /** Simple constructor.\n+   * <p>Creates a new instance of SequencesComparator</p>\n+   * <p>It is <em>guaranteed</em> that the comparisons will always be\n+   * done as <code>o1.equals(o2)</code> where <code>o1</code> belongs\n+   * to the first sequence and <code>o2</code> belongs to the second\n+   * sequence. This can be important if subclassing is used for some\n+   * elements in the first sequence and the <code>equals</code> method\n+   * is specialized.</p>\n+   * @param sequence1 first sequence to be compared\n+   * @param sequence2 second sequence to be compared\n+   */\n+  public SequencesComparator(List<T> sequence1, List<T> sequence2) {\n+    this.sequence1 = sequence1;\n+    this.sequence2 = sequence2;\n+\n+    int size = sequence1.size() + sequence2.size() + 2;\n+    vDown = new int[size];\n+    vUp   = new int[size];\n+\n+  }\n+\n+  /** Build a snake.\n+   * @param start the value of the start of the snake\n+   * @param diag the value of the diagonal of the snake\n+   * @param end1 the value of the end of the first sequence to be compared\n+   * @param end2 the value of the end of the second sequence to be compared\n+   * @return the snake built\n+   */\n+  private Snake buildSnake(int start, int diag, int end1, int end2) {\n+    int end = start;\n+    while (((end - diag) < end2)\n+           && (end < end1)\n+           && sequence1.get(end).equals(sequence2.get(end - diag))) {\n+      ++end;\n+    }\n+    return new Snake(start, end, diag);\n+  }\n+\n+  /** Get the middle snake corresponding to two subsequences of the\n+   * main sequences.\n+   * The snake is found using the MYERS Algorithm (this algorithms has\n+   * also been implemented in the GNU diff program). This algorithm is\n+   * explained in Eugene Myers article: <a\n+   * href=\"http://www.cs.arizona.edu/people/gene/PAPERS/diff.ps\">An\n+   * O(ND) Difference Algorithm and Its Variations</a>.\n+   * @param start1 the begin of the first sequence to be compared\n+   * @param end1 the end of the first sequence to be compared\n+   * @param start2 the begin of the second sequence to be compared\n+   * @param end2  the end of the second sequence to be compared\n+   * @return the middle snake\n+   */\n+  private Snake getMiddleSnake(int start1, int end1, int start2, int end2) {\n+    // Myers Algorithm\n+    //Initialisations\n+    int m = end1 - start1;\n+    int n = end2 - start2;\n+    if ((m == 0) || (n == 0)) {\n+      return null;\n+    }\n+\n+    int delta  = m - n;\n+    int sum    = n + m;\n+    int offset = ((sum % 2 == 0) ? sum : (sum + 1)) / 2;\n+    vDown[1+offset] = start1;\n+    vUp[1+offset]   = end1 + 1;\n+\n+    for (int d = 0; d <= offset ; ++d) {\n+      // Down\n+      for (int k = -d; k <= d; k += 2) {\n+        // First step\n+\n+        int i = k + offset;\n+        if ((k == -d) || ((k != d) && (vDown[i-1] < vDown[i+1]))) {\n+          vDown[i] = vDown[i+1];\n+        } else {\n+          vDown[i] = vDown[i-1] + 1;\n+        }\n+\n+        int x = vDown[i];\n+        int y = x - start1 + start2 - k;\n+\n+        while ((x < end1) && (y < end2) && (sequence1.get(x).equals(sequence2.get(y)))) {\n+          vDown[i] = ++x;\n+          ++y;\n+        }\n+        // Second step\n+        if (((delta % 2) != 0 ) && ((delta - d) <= k) && (k <= (delta + d))) {\n+          if (vUp[i-delta] <= vDown[i]) {\n+            return buildSnake(vUp[i-delta], k + start1 - start2, end1, end2);\n+          }\n+        }\n+      }\n+\n+      // Up\n+      for (int k = (delta - d); k <= (delta + d); k += 2) {\n+        // First step\n+        int i = k + offset - delta;\n+        if ((k == (delta - d))\n+            || ((k != (delta + d)) && (vUp[i+1] <= vUp[i-1]))) {\n+          vUp[i] = vUp[i+1] - 1;\n+        } else {\n+          vUp[i] = vUp[i-1];\n+        }\n+\n+        int x = vUp[i] - 1;\n+        int y = x - start1 + start2 - k;\n+        while ((x >= start1) && (y >= start2)\n+               && sequence1.get(x).equals(sequence2.get(y))) {\n+          vUp[i] = x--;\n+          y--;\n+        }\n+        // Second step\n+        if (((delta % 2) == 0) && (-d <= k) && (k <= d) ) {\n+          if (vUp[i] <= vDown[i + delta]) {\n+            return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n+          }\n+        }\n+      }\n+    }\n+\n+    // this should not happen\n+    throw new RuntimeException(\"Internal Error\");\n+\n+  }\n+\n+\n+  /** Build an edit script.\n+   * @param start1 the begin of the first sequence to be compared\n+   * @param end1 the end of the first sequence to be compared\n+   * @param start2 the begin of the second sequence to be compared\n+   * @param end2  the end of the second sequence to be compared\n+   * @param script the edited script\n+   */\n+  private void buildScript(int start1, int end1, int start2, int end2,\n+                           EditScript<T> script) {\n+\n+    Snake middle = getMiddleSnake(start1, end1, start2, end2);\n+\n+    if ((middle == null)\n+    || ((middle.getStart() == end1) && (middle.getDiag() == (end1 - end2)))\n+    || ((middle.getEnd() == start1) && (middle.getDiag() == (start1 - start2)))) {\n+\n+      int i = start1;\n+      int j = start2;\n+      while ((i < end1) || (j < end2)) {\n+        if ((i < end1) && (j < end2) && sequence1.get(i).equals(sequence2.get(j))) {\n+          script.append(new KeepCommand<T>(sequence1.get(i)));\n+          ++i;\n+          ++j;\n+        } else {\n+          if ((end1 - start1) > (end2 - start2)) {\n+            script.append(new DeleteCommand<T>(sequence1.get(i)));\n+            ++i;\n+          } else {\n+            script.append(new InsertCommand<T>(sequence2.get(j)));\n+            ++j;\n+          }\n+        }\n+      }\n+\n+    } else {\n+\n+      buildScript(start1, middle.getStart(),\n+      start2, middle.getStart() - middle.getDiag(),\n+      script);\n+      for (int i = middle.getStart(); i < middle.getEnd(); ++i) {\n+        script.append(new KeepCommand<T>(sequence1.get(i)));\n+      }\n+      buildScript(middle.getEnd(), end1,\n+      middle.getEnd() - middle.getDiag(), end2,\n+      script);\n+    }\n+  }\n+\n+  /** Get the edit script script.\n+   * <p>It is guaranteed that the objects embedded in the {@link\n+   * InsertCommand insert commands} come from the second sequence and\n+   * that the objects embedded in either the {@link DeleteCommand\n+   * delete commands} or {@link KeepCommand keep commands} come from\n+   * the first sequence. This can be important if subclassing is used\n+   * for some elements in the first sequence and the\n+   * <code>equals</code> method is specialized.</p>\n+   * @return the edit script resulting from the comparison of the two\n+   * sequences\n+   */\n+  public EditScript<T> getScript() {\n+    EditScript<T> script = new EditScript<T>();\n+    buildScript(0, sequence1.size(), 0, sequence2.size(), script);\n+    return script;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/list/difference/Snake.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+/**\n+ * This class is a simple placeholder to hold the end part of a path\n+ * under construction in a {@link SequencesComparator\n+ * SequencesComparator}.\n+\n+ * <p>A snake is an internal structure used in Eugene W. Myers\n+ * algorithm (<a\n+ * href=\"http://www.cis.upenn.edu/~bcpierce/courses/dd/papers/diff.ps\">An\n+ * O(ND) Difference Algorithm and Its Variations</a>).</p>\n+\n+ * @since 4.0\n+ * @author Jordane Sarda\n+ * @version $Id$\n+ */\n+  public class Snake {\n+\n+   /** Start index. */\n+   private int start;\n+\n+   /** End index. */\n+   private int end;\n+\n+   /** Diagonal number. */\n+   private int diag;\n+   \n+  /** Simple constructor.\n+   * Creates a new instance of Snake with default indices\n+   */\n+   public Snake() {\n+     start = -1;\n+     end   = -1;\n+     diag  =  0;\n+   }\n+\n+   /** Simple constructor.\n+   * Creates a new instance of Snake with specified indices\n+   * @param start start index of the snake\n+   * @param end end index of the snake\n+   * @param diag diagonal number\n+   */ \n+  public Snake(int start, int end, int diag) {\n+    this.start = start;\n+    this.end   = end;\n+    this.diag  = diag;\n+ }\n+  \n+  /** Get the start index of the snake.\n+   * @return start index of the snake\n+   */\n+  public int getStart() {\n+    return start;\n+  }\n+ \n+  /** Get the end index of the snake.\n+   * @return end index of the snake\n+   */\n+  public int getEnd() {\n+    return end;\n+  }\n+\n+  /** Get the diagonal number of the snake.\n+   * @return diagonal number of the snake\n+   */  \n+  public int getDiag() {\n+    return diag;\n+  }\n+  \n+}\n--- a/src/test/java/org/apache/commons/collections/AbstractDecoratedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/AbstractDecoratedCollectionTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-\n-import org.junit.Before;\n-\n-public abstract class AbstractDecoratedCollectionTest<C> {\n-    /**\n-     * The {@link Collection} being decorated.\n-     */\n-    protected Collection<C> original;\n-    /**\n-     * The Collection under test that decorates {@link #original}.\n-     */\n-    protected Collection<C> decorated;\n-    \n-    @Before\n-    public void setUpDecoratedCollection() throws Exception {\n-        original = new ArrayList<C>();\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+\n+import org.junit.Before;\n+\n+public abstract class AbstractDecoratedCollectionTest<C> {\n+    /**\n+     * The {@link Collection} being decorated.\n+     */\n+    protected Collection<C> original;\n+    /**\n+     * The Collection under test that decorates {@link #original}.\n+     */\n+    protected Collection<C> decorated;\n+    \n+    @Before\n+    public void setUpDecoratedCollection() throws Exception {\n+        original = new ArrayList<C>();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/collections/MockTestCase.java\n+++ b/src/test/java/org/apache/commons/collections/MockTestCase.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.ListIterator;\n-\n-import org.easymock.EasyMock;\n-import org.easymock.IExpectationSetters;\n-\n-/**\n- * Provides utilities for making mock-based tests.  Most notable is the generic \"type-safe\"\n- * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods\n- * that call the respective methods on all created mock objects.\n- * \n- * @author Stephen Kestle\n- */\n-public abstract class MockTestCase {\n-    private List<Object> mockObjects = new ArrayList<Object>();\n-\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T> T createMock(Class<?> name) {\n-        T mock = (T) EasyMock.createMock(name);\n-        return registerMock(mock);\n-    }\n-\n-    private <T> T registerMock(T mock) {\n-        mockObjects.add(mock);\n-        return mock;\n-    }\n-\n-    protected <T> IExpectationSetters<T> expect(T t) {\n-        return EasyMock.expect(t);\n-    }\n-\n-    protected final void replay() {\n-        for (Object o : mockObjects) {\n-            EasyMock.replay(o);\n-        }\n-    }\n-\n-    protected final void verify() {\n-        for (ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n-            try {\n-                EasyMock.verify(i.next());\n-            } catch (AssertionError e) {\n-                throw new AssertionError((i.previousIndex() + 1) + \"\"\n-                        + e.getMessage());\n-            }\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.ListIterator;\n+\n+import org.easymock.EasyMock;\n+import org.easymock.IExpectationSetters;\n+\n+/**\n+ * Provides utilities for making mock-based tests.  Most notable is the generic \"type-safe\"\n+ * {@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods\n+ * that call the respective methods on all created mock objects.\n+ * \n+ * @author Stephen Kestle\n+ */\n+public abstract class MockTestCase {\n+    private List<Object> mockObjects = new ArrayList<Object>();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T createMock(Class<?> name) {\n+        T mock = (T) EasyMock.createMock(name);\n+        return registerMock(mock);\n+    }\n+\n+    private <T> T registerMock(T mock) {\n+        mockObjects.add(mock);\n+        return mock;\n+    }\n+\n+    protected <T> IExpectationSetters<T> expect(T t) {\n+        return EasyMock.expect(t);\n+    }\n+\n+    protected final void replay() {\n+        for (Object o : mockObjects) {\n+            EasyMock.replay(o);\n+        }\n+    }\n+\n+    protected final void verify() {\n+        for (ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n+            try {\n+                EasyMock.verify(i.next());\n+            } catch (AssertionError e) {\n+                throw new AssertionError((i.previousIndex() + 1) + \"\"\n+                        + e.getMessage());\n+            }\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/collections/TestIndexedCollection.java\n+++ b/src/test/java/org/apache/commons/collections/TestIndexedCollection.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections;\n-\n-import static java.util.Arrays.asList;\n-import static junit.framework.Assert.assertEquals;\n-import static junit.framework.Assert.assertNull;\n-\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-@SuppressWarnings(\"boxing\")\n-public class TestIndexedCollection extends AbstractDecoratedCollectionTest<String> {\n-    private IndexedCollection<Integer, String> indexed;\n-\n-    @Before\n-    public void setUp() throws Exception {\n-        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n-            public Integer transform(String input) {\n-                return Integer.parseInt(input);\n-            }\n-        });\n-        decorated = indexed;\n-    }\n-    \n-    @Test\n-    public void addedObjectsCanBeRetrievedByKey() throws Exception {\n-        decorated.add(\"12\");\n-        decorated.add(\"16\");\n-        decorated.add(\"1\");\n-        decorated.addAll(asList(\"2\",\"3\",\"4\"));\n-        assertEquals(\"12\", indexed.get(12));\n-        assertEquals(\"16\", indexed.get(16));\n-        assertEquals(\"1\", indexed.get(1));\n-        assertEquals(\"2\", indexed.get(2));\n-        assertEquals(\"3\", indexed.get(3));\n-        assertEquals(\"4\", indexed.get(4));\n-    }\n-    \n-    @Test(expected=IllegalArgumentException.class)\n-    public void ensureDuplicateObjectsCauseException() throws Exception {\n-        decorated.add(\"1\");\n-        decorated.add(\"1\");\n-    }\n-    \n-    @Test\n-    public void decoratedCollectionIsIndexedOnCreation() throws Exception {\n-        original.add(\"1\");\n-        original.add(\"2\");\n-        original.add(\"3\");\n-        \n-        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n-            public Integer transform(String input) {\n-                return Integer.parseInt(input);\n-            }\n-        });\n-        assertEquals(\"1\", indexed.get(1));\n-        assertEquals(\"2\", indexed.get(2));\n-        assertEquals(\"3\", indexed.get(3));\n-    }\n-    \n-    @Test\n-    public void reindexUpdatesIndexWhenTheDecoratedCollectionIsModifiedSeparately() throws Exception {\n-        original.add(\"1\");\n-        original.add(\"2\");\n-        original.add(\"3\");\n-        \n-        assertNull(indexed.get(1));\n-        assertNull(indexed.get(2));\n-        assertNull(indexed.get(3));\n-        indexed.reindex();\n-        assertEquals(\"1\", indexed.get(1));\n-        assertEquals(\"2\", indexed.get(2));\n-        assertEquals(\"3\", indexed.get(3));\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections;\n+\n+import static java.util.Arrays.asList;\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertNull;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+@SuppressWarnings(\"boxing\")\n+public class TestIndexedCollection extends AbstractDecoratedCollectionTest<String> {\n+    private IndexedCollection<Integer, String> indexed;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n+            public Integer transform(String input) {\n+                return Integer.parseInt(input);\n+            }\n+        });\n+        decorated = indexed;\n+    }\n+    \n+    @Test\n+    public void addedObjectsCanBeRetrievedByKey() throws Exception {\n+        decorated.add(\"12\");\n+        decorated.add(\"16\");\n+        decorated.add(\"1\");\n+        decorated.addAll(asList(\"2\",\"3\",\"4\"));\n+        assertEquals(\"12\", indexed.get(12));\n+        assertEquals(\"16\", indexed.get(16));\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+        assertEquals(\"4\", indexed.get(4));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void ensureDuplicateObjectsCauseException() throws Exception {\n+        decorated.add(\"1\");\n+        decorated.add(\"1\");\n+    }\n+    \n+    @Test\n+    public void decoratedCollectionIsIndexedOnCreation() throws Exception {\n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+        \n+        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n+            public Integer transform(String input) {\n+                return Integer.parseInt(input);\n+            }\n+        });\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+    \n+    @Test\n+    public void reindexUpdatesIndexWhenTheDecoratedCollectionIsModifiedSeparately() throws Exception {\n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+        \n+        assertNull(indexed.get(1));\n+        assertNull(indexed.get(2));\n+        assertNull(indexed.get(3));\n+        indexed.reindex();\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+}\n--- a/src/test/java/org/apache/commons/collections/functors/BasicClosureTestBase.java\n+++ b/src/test/java/org/apache/commons/collections/functors/BasicClosureTestBase.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections.functors;\n-\n-import org.apache.commons.collections.Closure;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-public abstract class BasicClosureTestBase {\n-\n-    @Test\n-    public void closureSanityTests() throws Exception {\n-        Closure<?> closure = generateClosure();\n-        Assert.assertNotNull(closure);\n-    }\n-\n-    /**\n-     * @return a closure for general sanity tests.\n-     */\n-    protected abstract <T> Closure<T> generateClosure();\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import org.apache.commons.collections.Closure;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public abstract class BasicClosureTestBase {\n+\n+    @Test\n+    public void closureSanityTests() throws Exception {\n+        Closure<?> closure = generateClosure();\n+        Assert.assertNotNull(closure);\n+    }\n+\n+    /**\n+     * @return a closure for general sanity tests.\n+     */\n+    protected abstract <T> Closure<T> generateClosure();\n+}\n--- a/src/test/java/org/apache/commons/collections/functors/TestCatchAndRethrowClosure.java\n+++ b/src/test/java/org/apache/commons/collections/functors/TestCatchAndRethrowClosure.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections.functors;\n-\n-import java.io.IOException;\n-\n-import org.apache.commons.collections.Closure;\n-import org.apache.commons.collections.FunctorException;\n-import org.junit.Assert;\n-import org.junit.Test;\n-\n-public class TestCatchAndRethrowClosure extends BasicClosureTestBase {\n-\n-    private static <T> Closure<T> generateIOExceptionClosure() {\n-        return new CatchAndRethrowClosure<T>() {\n-\n-            @Override\n-            protected void executeAndThrow(T input) throws IOException  {\n-                throw new IOException();\n-            }\n-        };\n-    }\n-\n-    private static <T> Closure<T> generateNullPointerExceptionClosure() {\n-        return new CatchAndRethrowClosure<T>() {\n-\n-            @Override\n-            protected void executeAndThrow(T input) {\n-                throw new NullPointerException();\n-            }\n-        };\n-    }\n-\n-    private static <T> Closure<T> generateNoExceptionClosure() {\n-        return new CatchAndRethrowClosure<T>() {\n-\n-            @Override\n-            protected void executeAndThrow(T input) {\n-            }\n-        };\n-    }\n-\n-    @Override\n-    protected <T> Closure<T> generateClosure() {\n-        return generateNoExceptionClosure();\n-    }\n-    \n-    @Test\n-    public void testThrowingClosure() {\n-        Closure<Integer> closure = generateNoExceptionClosure();\n-        try {\n-            closure.execute(Integer.valueOf(0));\n-        } catch (FunctorException ex) {\n-            Assert.fail();\n-        } catch (RuntimeException ex) {\n-            Assert.fail();\n-        }\n-        \n-        closure = generateIOExceptionClosure();\n-        try {\n-            closure.execute(Integer.valueOf(0));\n-            Assert.fail();\n-        } catch (FunctorException ex) {\n-            Assert.assertTrue(ex.getCause() instanceof IOException);\n-        } catch (RuntimeException ex) {\n-            Assert.fail();\n-        }\n-\n-        closure = generateNullPointerExceptionClosure();\n-        try {\n-            closure.execute(Integer.valueOf(0));\n-            Assert.fail();\n-        } catch (FunctorException ex) {\n-            Assert.fail();\n-        } catch (RuntimeException ex) {\n-            Assert.assertTrue(ex instanceof NullPointerException);\n-        }\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.collections.Closure;\n+import org.apache.commons.collections.FunctorException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestCatchAndRethrowClosure extends BasicClosureTestBase {\n+\n+    private static <T> Closure<T> generateIOExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(T input) throws IOException  {\n+                throw new IOException();\n+            }\n+        };\n+    }\n+\n+    private static <T> Closure<T> generateNullPointerExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(T input) {\n+                throw new NullPointerException();\n+            }\n+        };\n+    }\n+\n+    private static <T> Closure<T> generateNoExceptionClosure() {\n+        return new CatchAndRethrowClosure<T>() {\n+\n+            @Override\n+            protected void executeAndThrow(T input) {\n+            }\n+        };\n+    }\n+\n+    @Override\n+    protected <T> Closure<T> generateClosure() {\n+        return generateNoExceptionClosure();\n+    }\n+    \n+    @Test\n+    public void testThrowingClosure() {\n+        Closure<Integer> closure = generateNoExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+        } catch (FunctorException ex) {\n+            Assert.fail();\n+        } catch (RuntimeException ex) {\n+            Assert.fail();\n+        }\n+        \n+        closure = generateIOExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+            Assert.fail();\n+        } catch (FunctorException ex) {\n+            Assert.assertTrue(ex.getCause() instanceof IOException);\n+        } catch (RuntimeException ex) {\n+            Assert.fail();\n+        }\n+\n+        closure = generateNullPointerExceptionClosure();\n+        try {\n+            closure.execute(Integer.valueOf(0));\n+            Assert.fail();\n+        } catch (FunctorException ex) {\n+            Assert.fail();\n+        } catch (RuntimeException ex) {\n+            Assert.assertTrue(ex instanceof NullPointerException);\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/collections/functors/TestComparatorPredicate.java\n+++ b/src/test/java/org/apache/commons/collections/functors/TestComparatorPredicate.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.commons.collections.functors;\n-\n-import static org.apache.commons.collections.functors.ComparatorPredicate.*;\n-import java.util.Comparator;\n-\n-import org.apache.commons.collections.Predicate;\n-import org.junit.Test;\n-\n-\n-public class TestComparatorPredicate extends BasicPredicateTestBase {\n-    private class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n-        public int compare(T first, T second) {\n-            return first.compareTo(second);\n-        }\n-    }\n-\n-    @Test\n-    public void compareEquals() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n-        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n-        assertTrue(p, Integer.valueOf(value.intValue()));\n-        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n-    }\n-\n-    @Test\n-    public void compareGreater() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n-        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n-        assertFalse(p, Integer.valueOf(value.intValue()));\n-        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n-    }\n-\n-    @Test\n-    public void compareLess() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n-        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n-        assertFalse(p, Integer.valueOf(value.intValue()));\n-        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n-    }\n-\n-    @Test\n-    public void compareGreaterOrEqual() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n-        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n-        assertTrue(p, Integer.valueOf(value.intValue()));\n-        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n-    }\n-\n-    @Test\n-    public void compareLessOrEqual() {\n-        Integer value = Integer.valueOf(10);\n-        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n-        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n-        assertTrue(p, Integer.valueOf(value.intValue()));\n-        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n-    }\n-    \n-    @Override\n-    protected Predicate<?> generatePredicate() {\n-        return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());\n-    }    \n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.functors;\n+\n+import static org.apache.commons.collections.functors.ComparatorPredicate.*;\n+import java.util.Comparator;\n+\n+import org.apache.commons.collections.Predicate;\n+import org.junit.Test;\n+\n+\n+public class TestComparatorPredicate extends BasicPredicateTestBase {\n+    private class TestComparator<T extends Comparable<T>> implements Comparator<T> {\n+        public int compare(T first, T second) {\n+            return first.compareTo(second);\n+        }\n+    }\n+\n+    @Test\n+    public void compareEquals() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>());\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareGreater() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER);\n+        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n+        assertFalse(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareLess() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS);\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertFalse(p, Integer.valueOf(value.intValue()));\n+        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareGreaterOrEqual() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.GREATER_OR_EQUAL);\n+        assertTrue(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertFalse(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+\n+    @Test\n+    public void compareLessOrEqual() {\n+        Integer value = Integer.valueOf(10);\n+        Predicate<Integer> p = comparatorPredicate(value, new TestComparator<Integer>(), Criterion.LESS_OR_EQUAL);\n+        assertFalse(p, Integer.valueOf(value.intValue() - 1));\n+        assertTrue(p, Integer.valueOf(value.intValue()));\n+        assertTrue(p, Integer.valueOf(value.intValue() + 1));\n+    }\n+    \n+    @Override\n+    protected Predicate<?> generatePredicate() {\n+        return comparatorPredicate(Integer.valueOf(10), new TestComparator<Integer>());\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/list/difference/SequencesComparatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.list.difference;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class SequencesComparatorTest {\n+\n+    @Test\n+    public void testLength() {\n+        for (int i = 0; i < before.size(); ++i) {\n+            SequencesComparator<Character> comparator =\n+                    new SequencesComparator<Character>(sequence(before.get(i)),\n+                                                       sequence(after.get(i)));\n+            Assert.assertEquals(length[i], comparator.getScript().getModifications());\n+        }\n+    }\n+\n+    @Test\n+    public void testExecution() {\n+        ExecutionVisitor<Character> ev = new ExecutionVisitor<Character>();\n+        for (int i = 0; i < before.size(); ++i) {\n+            ev.setList(sequence(before.get(i)));\n+            new SequencesComparator<Character>(sequence(before.get(i)),\n+                    sequence(after.get(i))).getScript().visit(ev);\n+            Assert.assertEquals(after.get(i), ev.getString());\n+        }\n+    }\n+\n+    @Test\n+    public void testMinimal() {\n+        String[] shadokAlph = new String[] {\n+            new String(\"GA\"),\n+            new String(\"BU\"),\n+            new String(\"ZO\"),\n+            new String(\"MEU\")\n+        };\n+        List<String> sentenceBefore = new ArrayList<String>();\n+        List<String> sentenceAfter  = new ArrayList<String>();\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[2]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[1]);\n+        sentenceBefore.add(shadokAlph[3]);\n+        sentenceBefore.add(shadokAlph[0]);\n+        sentenceBefore.add(shadokAlph[3]);\n+\n+        Random random = new Random(4564634237452342L);\n+\n+        for (int nbCom = 0; nbCom <= 40; nbCom+=5) {\n+            sentenceAfter.clear();\n+            sentenceAfter.addAll(sentenceBefore);\n+            for (int i = 0; i<nbCom; i++) {\n+                if (random.nextInt(2) == 0) {\n+                    sentenceAfter.add(random.nextInt(sentenceAfter.size() + 1),\n+                                      shadokAlph[random.nextInt(4)]);\n+                } else {\n+                    sentenceAfter.remove(random.nextInt(sentenceAfter.size()));\n+                }\n+            }\n+\n+            SequencesComparator<String> comparator =\n+                    new SequencesComparator<String>(sentenceBefore, sentenceAfter);\n+            Assert.assertTrue(comparator.getScript().getModifications() <= nbCom);\n+        }\n+    }\n+\n+    @Test\n+    public void testShadok() {\n+        int lgMax = 5;\n+        String[] shadokAlph = new String[] {\n+            new String(\"GA\"),\n+            new String(\"BU\"),\n+            new String(\"ZO\"),\n+            new String(\"MEU\")\n+        };\n+        List<List<String>> shadokSentences = new ArrayList<List<String>>();\n+        for (int lg=0; lg<lgMax; ++lg) {\n+            List<List<String>> newTab = new ArrayList<List<String>>();\n+            newTab.add(new ArrayList<String>());\n+            for (int k = 0; k < shadokAlph.length; k++) {\n+                for (List<String> sentence : shadokSentences) {\n+                    List<String> newSentence = new ArrayList<String>(sentence);\n+                    newSentence.add(shadokAlph[k]);\n+                    newTab.add(newSentence);\n+                }\n+            }\n+            shadokSentences = newTab;\n+        }\n+\n+        ExecutionVisitor<String> ev = new ExecutionVisitor<String>();\n+\n+        for (int i = 0; i < shadokSentences.size(); ++i) {\n+            for (int j = 0; j < shadokSentences.size(); ++j) {\n+                ev.setList(shadokSentences.get(i));\n+                new SequencesComparator<String>(shadokSentences.get(i),\n+                                                shadokSentences.get(j)).getScript().visit(ev);\n+\n+                StringBuilder concat = new StringBuilder();\n+                for (final String s : shadokSentences.get(j)) {\n+                    concat.append(s);\n+                }\n+                Assert.assertEquals(concat.toString(), ev.getString());\n+            }\n+        }\n+    }\n+\n+    private List<Character> sequence(String string) {\n+        List<Character> list = new ArrayList<Character>();\n+        for (int i = 0; i < string.length(); ++i) {\n+            list.add(new Character(string.charAt(i)));\n+        }\n+        return list;\n+    }\n+\n+    private class ExecutionVisitor<T> implements CommandVisitor<T> {\n+\n+        private List<T> v;\n+        private int index;\n+\n+        public void setList(List<T> array) {\n+            v = new ArrayList<T>(array);\n+            index = 0;\n+        }\n+\n+        public void visitInsertCommand(T object) {\n+            v.add(index++, object);\n+        }\n+\n+        public void visitKeepCommand(T object) {\n+            ++index;\n+        }\n+\n+        public void visitDeleteCommand(T object) {\n+            v.remove(index);\n+        }\n+\n+        public String getString() {\n+            StringBuffer buffer = new StringBuffer();\n+            for (T c : v) {\n+                buffer.append(c);\n+            }\n+            return buffer.toString();\n+        }\n+\n+    }\n+\n+    @Before\n+    public void setUp() {\n+\n+        before = Arrays.asList(new String[] {\n+            \"bottle\",\n+            \"nematode knowledge\",\n+            \"\",\n+            \"aa\",\n+            \"prefixed string\",\n+            \"ABCABBA\",\n+            \"glop glop\",\n+            \"coq\",\n+            \"spider-man\"\n+        });\n+\n+        after = Arrays.asList(new String[] {\n+            \"noodle\",\n+            \"empty bottle\",\n+            \"\",\n+            \"C\",\n+            \"prefix\",\n+            \"CBABAC\",\n+            \"pas glop pas glop\",\n+            \"ane\",\n+            \"klingon\"\n+        });\n+\n+        length = new int[] {\n+            6,\n+            16,\n+            0,\n+            3,\n+            9,\n+            5,\n+            8,\n+            6,\n+            13\n+        };\n+\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        before = null;\n+        after  = null;\n+        length = null;\n+    }\n+\n+    private List<String> before;\n+    private List<String> after;\n+    private int[]        length;\n+\n+}", "timestamp": 1334082149, "metainfo": ""}