{"sha": "ed085d064c0f80b0bcf382550d10fe6b6fc9f283", "log": "[COLLECTIONS-470] Renamed TransformedMap class in splitmap package to TransformedSplitMap.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/map/TransformedMap.java\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n  * <p>\n- * @see org.apache.commons.collections4.splitmap.TransformedMap\n+ * @see org.apache.commons.collections4.splitmap.TransformedSplitMap\n  *\n  * @since 3.0\n  * @version $Id$\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/splitmap/TransformedSplitMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.splitmap;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+import org.apache.commons.collections4.Put;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.map.LinkedMap;\n+\n+/**\n+ * Decorates another {@link Map} to transform objects that are added.\n+ * <p>\n+ * The Map put methods and Map.Entry setValue method are affected by this class.\n+ * Thus objects must be removed or searched for using their transformed form.\n+ * For example, if the transformation converts Strings to Integers, you must use\n+ * the Integer form to remove objects.\n+ * <p>\n+ * <strong>Note that TransformedMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. The simplest approach\n+ * is to wrap this map using {@link java.util.Collections#synchronizedMap(Map)}.\n+ * This class may throw exceptions when accessed by concurrent threads without\n+ * synchronization.\n+ * <p>\n+ * The \"put\" and \"get\" type constraints of this class are mutually independent;\n+ * contrast with {@link org.apache.commons.collections4.map.TransformedMap} which,\n+ * by virtue of its implementing {@link Map}&lt;K, V&gt;, must be constructed in such\n+ * a way that its read and write parameters are generalized to a common (super-)type.\n+ * In practice this would often mean <code>&gt;Object, Object&gt;</code>, defeating\n+ * much of the usefulness of having parameterized types.\n+ * <p>\n+ * On the downside, this class is not drop-in compatible with {@link java.util.Map}\n+ * but is intended to be worked with either directly or by {@link Put} and\n+ * {@link org.apache.commons.collections4.Get Get} generalizations.\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ *\n+ * @see org.apache.commons.collections4.SplitMapUtils#readableMap(Get)\n+ * @see org.apache.commons.collections4.SplitMapUtils#writableMap(Put)\n+ */\n+public class TransformedSplitMap<J, K, U, V> extends AbstractIterableGetMapDecorator<K, V>\n+        implements Put<J, U>, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = 5966875321133456994L;\n+\n+    /** The transformer to use for the key */\n+    private final Transformer<? super J, ? extends K> keyTransformer;\n+    /** The transformer to use for the value */\n+    private final Transformer<? super U, ? extends V> valueTransformer;\n+\n+    /**\n+     * Factory method to create a transforming map.\n+     * <p>\n+     * If there are any elements already in the map being decorated, they are\n+     * NOT transformed.\n+     *\n+     * @param <J>  the input key type\n+     * @param <K>  the output key type\n+     * @param <U>  the input value type\n+     * @param <V>  the output value type\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     *   means no transformation\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     *   means no transformation\n+     * @return a new transformed map\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    public static <J, K, U, V> TransformedSplitMap<J, K, U, V> transformingMap(final Map<K, V> map,\n+            final Transformer<? super J, ? extends K> keyTransformer,\n+            final Transformer<? super U, ? extends V> valueTransformer) {\n+        return new TransformedSplitMap<J, K, U, V>(map, keyTransformer, valueTransformer);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Constructor that wraps (not copies).\n+     * <p>\n+     * If there are any elements already in the collection being decorated, they\n+     * are NOT transformed.\n+     *\n+     * @param map the map to decorate, must not be null\n+     * @param keyTransformer the transformer to use for key conversion, null\n+     * means no conversion\n+     * @param valueTransformer the transformer to use for value conversion, null\n+     * means no conversion\n+     * @throws IllegalArgumentException if map is null\n+     */\n+    protected TransformedSplitMap(final Map<K, V> map, final Transformer<? super J, ? extends K> keyTransformer,\n+            final Transformer<? super U, ? extends V> valueTransformer) {\n+        super(map);\n+        if (keyTransformer == null) {\n+            throw new IllegalArgumentException(\"keyTransformer cannot be null\");\n+        }\n+        this.keyTransformer = keyTransformer;\n+        if (valueTransformer == null) {\n+            throw new IllegalArgumentException(\"valueTransformer cannot be null\");\n+        }\n+        this.valueTransformer = valueTransformer;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Write the map out using a custom routine.\n+     *\n+     * @param out the output stream\n+     * @throws IOException\n+     */\n+    private void writeObject(final ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeObject(decorated());\n+    }\n+\n+    /**\n+     * Read the map in using a custom routine.\n+     *\n+     * @param in the input stream\n+     * @throws IOException\n+     * @throws ClassNotFoundException\n+     * @since 3.1\n+     */\n+    @SuppressWarnings(\"unchecked\") // (1) should only fail if input stream is incorrect\n+    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        map = (Map<K, V>) in.readObject(); // (1)\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Transforms a key.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @return the transformed object\n+     */\n+    protected K transformKey(final J object) {\n+        return keyTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a value.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param object the object to transform\n+     * @return the transformed object\n+     */\n+    protected V transformValue(final U object) {\n+        return valueTransformer.transform(object);\n+    }\n+\n+    /**\n+     * Transforms a map.\n+     * <p>\n+     * The transformer itself may throw an exception if necessary.\n+     *\n+     * @param map the map to transform\n+     * @return the transformed object\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(final Map<? extends J, ? extends U> map) {\n+        if (map.isEmpty()) {\n+            return (Map<K, V>) map;\n+        }\n+        final Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (final Map.Entry<? extends J, ? extends U> entry : map.entrySet()) {\n+            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Override to transform the value when using <code>setValue</code>.\n+     *\n+     * @param value the value to transform\n+     * @return the transformed value\n+     */\n+    protected V checkSetValue(final U value) {\n+        return valueTransformer.transform(value);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    public V put(final J key, final U value) {\n+        return decorated().put(transformKey(key), transformValue(value));\n+    }\n+\n+    public void putAll(final Map<? extends J, ? extends U> mapToCopy) {\n+        decorated().putAll(transformMap(mapToCopy));\n+    }\n+\n+    public void clear() {\n+        decorated().clear();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/SplitMapUtilsTest.java\n import org.apache.commons.collections4.Unmodifiable;\n import org.apache.commons.collections4.functors.NOPTransformer;\n import org.apache.commons.collections4.map.HashedMap;\n-import org.apache.commons.collections4.splitmap.TransformedMap;\n+import org.apache.commons.collections4.splitmap.TransformedSplitMap;\n \n /**\n- * Tests for {@link TransformedMap}\n+ * Tests for {@link TransformedSplitMap}\n  *\n  * @since 4.0\n  * @version $Id$\n @SuppressWarnings(\"boxing\")\n public class SplitMapUtilsTest extends BulkTest {\n     private Map<String, Integer> backingMap;\n-    private TransformedMap<String, String, String, Integer> transformedMap;\n+    private TransformedSplitMap<String, String, String, Integer> transformedMap;\n \n     private final Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n         public Integer transform(final String input) {\n     protected void setUp() throws Exception {\n         super.setUp();\n         backingMap = new HashMap<String, Integer>();\n-        transformedMap = TransformedMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n+        transformedMap = TransformedSplitMap.transformingMap(backingMap, NOPTransformer.<String> nopTransformer(),\n                 stringToInt);\n         for (int i = 0; i < 10; i++) {\n             transformedMap.put(String.valueOf(i), String.valueOf(i));\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/splitmap/TransformedSplitMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.splitmap;\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections4.BulkTest;\n+import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.Transformer;\n+import org.apache.commons.collections4.functors.NOPTransformer;\n+\n+/**\n+ * Tests for {@link TransformedSplitMap}\n+ *\n+ * @since 4.0\n+ * @version $Id$\n+ */\n+@SuppressWarnings(\"boxing\")\n+public class TransformedSplitMapTest extends BulkTest {\n+\n+    private final Transformer<Integer, String> intToString = new Transformer<Integer, String>() {\n+        public String transform(final Integer input) {\n+            return String.valueOf(input);\n+        }\n+    };\n+\n+    private final Transformer<Object, Class<?>> objectToClass = new Transformer<Object, Class<?>>() {\n+        public java.lang.Class<?> transform(final Object input) {\n+            return input == null ? null : input.getClass();\n+        }\n+    };\n+\n+    private final Transformer<String, Integer> stringToInt = new Transformer<String, Integer>() {\n+        public Integer transform(final String input) {\n+            return Integer.valueOf(input);\n+        }\n+    };\n+\n+    public TransformedSplitMapTest(final String testName) {\n+        super(testName);\n+    }\n+\n+    // -----------------------------------------------------------------------\n+    public void testTransformedMap() {\n+        final TransformedSplitMap<Integer, String, Object, Class<?>> map = TransformedSplitMap.transformingMap(\n+                new HashMap<String, Class<?>>(), intToString, objectToClass);\n+\n+        final Integer[] k = new Integer[] { 0, 1, 2, 3, 4, 5, 6 };\n+        final Object[] v = new Object[] { \"\", new Object(), new HashMap<Object, Object>(), 0, BigInteger.TEN, null,\n+                new Object[0] };\n+\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < k.length; i++) {\n+            map.put(k[i], v[i]);\n+            assertEquals(i + 1, map.size());\n+            assertTrue(map.containsKey(intToString.transform(k[i])));\n+            assertFalse(map.containsKey(k[i]));\n+            assertTrue(map.containsValue(objectToClass.transform(v[i])));\n+            assertTrue(objectToClass.transform(v[i]) != v[i] ^ map.containsValue(v[i]));\n+            assertEquals(objectToClass.transform(v[i]), map.get(intToString.transform(k[i])));\n+        }\n+\n+        int sz = map.size();\n+        assertEquals(null, map.remove(k[0]));\n+        assertEquals(sz, map.size());\n+        assertEquals(objectToClass.transform(v[0]), map.remove(intToString.transform(k[0])));\n+        assertEquals(--sz, map.size());\n+\n+        final TransformedSplitMap<String, String, String, Integer> map2 = TransformedSplitMap.transformingMap(\n+                new HashMap<String, Integer>(), NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map2.size());\n+        for (int i = 0; i < 6; i++) {\n+            map2.put(String.valueOf(i), String.valueOf(i));\n+            assertEquals(i + 1, map2.size());\n+            assertTrue(map2.containsValue(i));\n+            assertFalse(map2.containsValue(String.valueOf(i)));\n+            assertTrue(map2.containsKey(String.valueOf(i)));\n+            assertEquals(i, map2.get(String.valueOf(i)).intValue());\n+        }\n+\n+        int sz2 = map2.size();\n+        assertEquals(Integer.valueOf(0), map2.remove(\"0\"));\n+        assertEquals(--sz2, map2.size());\n+    }\n+\n+    // -----------------------------------------------------------------------\n+\n+    public void testMapIterator() {\n+        final TransformedSplitMap<String, String, String, Integer> map =\n+                TransformedSplitMap.transformingMap(new HashMap<String, Integer>(),\n+                                                    NOPTransformer.<String> nopTransformer(), stringToInt);\n+        assertEquals(0, map.size());\n+        for (int i = 0; i < 6; i++) {\n+            map.put(String.valueOf(i), String.valueOf(i));\n+        }\n+\n+        for (final MapIterator<String, Integer> it = map.mapIterator(); it.hasNext();) {\n+            final String k = it.next();\n+            assertEquals(k, it.getKey());\n+            assertEquals(map.get(k), it.getValue());\n+        }\n+    }\n+\n+    public void testEmptyMap() throws IOException, ClassNotFoundException {\n+        final TransformedSplitMap<String, String, String, String> map =\n+                TransformedSplitMap.transformingMap(new HashMap<String, String>(),\n+                                                    NOPTransformer.<String>nopTransformer(),\n+                                                    NOPTransformer.<String>nopTransformer() );\n+\n+        final ObjectInputStream in =\n+                new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"/TransformedSplitMap.emptyCollection.version4.obj\" ) );\n+        final Object readObject = in.readObject();\n+        in.close();\n+\n+        final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;\n+        assertTrue( \"Map should be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+\n+    public void testFullMap() throws IOException, ClassNotFoundException {\n+        final TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap(\n+                new HashMap<String, String>(),\n+                NOPTransformer.<String>nopTransformer(),\n+                NOPTransformer.<String>nopTransformer() );\n+        map.put( \"a\", \"b\" );\n+        map.put( \"c\", \"d\" );\n+        map.put( \"e\", \"f\" );\n+        map.put( \"g\", \"h\" );\n+\n+        final ObjectInputStream in =\n+                new ObjectInputStream( new FileInputStream( TEST_DATA_PATH+\"TransformedSplitMap.fullCollection.version4.obj\" ) );\n+        final Object readObject = in.readObject();\n+        in.close();\n+\n+        final TransformedSplitMap<?, ?, ?, ?> readMap = (TransformedSplitMap<?, ?, ?, ?>) readObject;\n+        assertFalse( \"Map should not be empty\", readMap.size() == 0 );\n+        assertEquals( map.entrySet(), readMap.entrySet() );\n+    }\n+\n+//    public void testCreate() throws IOException {\n+//        TransformedSplitMap<String, String, String, String> map = TransformedSplitMap.transformingMap(\n+//                new HashMap<String, String>(),\n+//                NOPTransformer.<String>nopTransformer(),\n+//                NOPTransformer.<String>nopTransformer() );\n+//\n+//        ObjectOutputStream out = new ObjectOutputStream(\n+//                new FileOutputStream( \"src/test/resources/data/test/TransformedSplitMap.emptyCollection.version4.obj\" ) );\n+//        out.writeObject( map );\n+//\n+//        map.put( \"a\", \"b\" );\n+//        map.put( \"c\", \"d\" );\n+//        map.put( \"e\", \"f\" );\n+//        map.put( \"g\", \"h\" );\n+//\n+//        out = new ObjectOutputStream(\n+//                new FileOutputStream( \"src/test/resources/data/test/TransformedSplitMap.fullCollection.version4.obj\" ) );\n+//        out.writeObject( map );\n+//    }\n+}", "timestamp": 1370982562, "metainfo": ""}