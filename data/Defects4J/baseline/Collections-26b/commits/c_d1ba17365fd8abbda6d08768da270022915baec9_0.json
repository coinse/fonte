{"sha": "d1ba17365fd8abbda6d08768da270022915baec9", "log": "[COLLECTIONS-275] Finished IndexedCollection by supporting non-uniqueness of keys, fixes tests.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n \n import java.util.Collection;\n import java.util.HashMap;\n-import java.util.Map;\n-\n+\n+import org.apache.commons.collections.MultiMap;\n import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.map.MultiValueMap;\n \n /**\n  * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n  * @since 4.0\n  * @version $Id$\n  */\n-// TODO support MultiMap/non-unique index behavior\n public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n \n     /** Serialization version */\n     private final Transformer<C, K> keyTransformer;\n \n     /** The map of indexes to collected objects. */\n-    private final Map<K, C> index;\n+    private final MultiMap<K, C> index;\n+    \n+    /** The uniqueness constraint for the index. */\n+    private final boolean uniqueIndex;\n \n     /**\n      * Create an {@link IndexedCollection} for a unique index.\n+     * <p>\n+     * If an element is added, which maps to an existing key, an {@link IllegalArgumentException}\n+     * will be thrown.\n      *\n      * @param <K> the index object type.\n      * @param <C> the collection type.\n      */\n     public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll,\n                                                                          final Transformer<C, K> keyTransformer) {\n-        return new IndexedCollection<K, C>(coll, keyTransformer, new HashMap<K, C>());\n-    }\n-\n-    /**\n-     * Create a {@link IndexedCollection} for a unique index.\n+        return new IndexedCollection<K, C>(coll, keyTransformer,\n+                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n+                                           true);\n+    }\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a non-unique index.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> nonUniqueIndexedCollection(final Collection<C> coll,\n+                                                                            final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer,\n+                                           MultiValueMap.<K, C>multiValueMap(new HashMap<K, Collection<C>>()),\n+                                           false);\n+    }\n+\n+    /**\n+     * Create a {@link IndexedCollection}.\n      *\n      * @param coll  decorated {@link Collection}\n      * @param keyTransformer  {@link Transformer} for generating index keys\n      * @param map  map to use as index\n+     * @param uniqueIndex  if the index shall enforce uniqueness of index keys\n      */\n     public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer,\n-                             final HashMap<K, C> map) {\n+                             final MultiMap<K, C> map, final boolean uniqueIndex) {\n         super(coll);\n         this.keyTransformer = keyTransformer;\n-        this.index = new HashMap<K, C>();\n+        this.index = map;\n+        this.uniqueIndex = uniqueIndex;\n         reindex();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws IllegalArgumentException if the object maps to an existing key and the index\n+     *   enforces a uniqueness constraint\n+     */\n     @Override\n     public boolean add(final C object) {\n         final boolean added = super.add(object);\n \n     /**\n      * Get the element associated with the given key.\n+     * <p>\n+     * In case of a non-unique index, this method will return the first\n+     * value associated with the given key. To retrieve all elements associated\n+     * with a key, use {@link #values(Object)}.\n      *\n      * @param key  key to look up\n      * @return element found\n+     * @see #values(Object)\n      */\n     public C get(final K key) {\n-        return index.get(key);\n+        @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n+        Collection<C> coll = (Collection<C>) index.get(key);\n+        return coll == null ? null : coll.iterator().next();\n+    }\n+\n+    /**\n+     * Get all elements associated with the given key.\n+     *\n+     * @param key  key to look up\n+     * @return a collection of elements found, or null if {@code contains(key) == false}\n+     */\n+    @SuppressWarnings(\"unchecked\") // index is a MultiMap which returns a Collection\n+    public Collection<C> values(final K key) {\n+        return (Collection<C>) index.get(key);\n     }\n \n     /**\n      * Provides checking for adding the index.\n      *\n      * @param object the object to index\n+     * @throws IllegalArgumentException if the object maps to an existing key and the index\n+     *   enforces a uniqueness constraint\n      */\n     private void addToIndex(final C object) {\n-        final C existingObject = index.put(keyTransformer.transform(object), object);\n-        if (existingObject != null) {\n+        final K key = keyTransformer.transform(object);\n+        if (uniqueIndex && index.containsKey(key)) {\n             throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n         }\n+        index.put(key, object);\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/collections/collection/IndexedCollectionTest.java\n+++ b/src/test/java/org/apache/commons/collections/collection/IndexedCollectionTest.java\n \n import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.collection.IndexedCollection;\n-import org.junit.Test;\n \n /**\n  * Extension of {@link AbstractCollectionTest} for exercising the \n    //------------------------------------------------------------------------\n \n     protected Collection<String> decorateCollection(final Collection<String> collection) {\n+        return IndexedCollection.nonUniqueIndexedCollection(collection, new IntegerTransformer());\n+    }\n+\n+    protected IndexedCollection<Integer, String> decorateUniqueCollection(final Collection<String> collection) {\n         return IndexedCollection.uniqueIndexedCollection(collection, new IntegerTransformer());\n     }\n \n         return list;\n     }\n \n+    public Collection<String> makeTestCollection() {\n+        return decorateCollection(new ArrayList<String>());\n+    }\n+\n+    public Collection<String> makeUniqueTestCollection() {\n+        return decorateUniqueCollection(new ArrayList<String>());\n+    }\n+    \n     @Override\n     protected boolean skipSerializedCanonicalTests() {\n         // FIXME: support canonical tests\n \n     //------------------------------------------------------------------------\n \n-    @Override\n-    public void testCollectionAddAll() {\n-        // FIXME: does not work as we do not support multi-keys yet\n-    }\n-\n-    @Test\n-    public void addedObjectsCanBeRetrievedByKey() throws Exception {\n-        final Collection<String> coll = getCollection();\n+    public void testAddedObjectsCanBeRetrievedByKey() throws Exception {\n+        final Collection<String> coll = makeTestCollection();\n         coll.add(\"12\");\n         coll.add(\"16\");\n         coll.add(\"1\");\n         coll.addAll(asList(\"2\",\"3\",\"4\"));\n         \n         @SuppressWarnings(\"unchecked\")\n-        final\n-        IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;\n+        final IndexedCollection<Integer, String> indexed = (IndexedCollection<Integer, String>) coll;\n         assertEquals(\"12\", indexed.get(12));\n         assertEquals(\"16\", indexed.get(16));\n         assertEquals(\"1\", indexed.get(1));\n         assertEquals(\"4\", indexed.get(4));\n     }\n     \n-    @Test(expected=IllegalArgumentException.class)\n-    public void ensureDuplicateObjectsCauseException() throws Exception {\n-        getCollection().add(\"1\");\n-        getCollection().add(\"1\");\n+    public void testEnsureDuplicateObjectsCauseException() throws Exception {\n+        final Collection<String> coll = makeUniqueTestCollection();\n+\n+        coll.add(\"1\");\n+        try {\n+            coll.add(\"1\");\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n     }\n     \n-//    @Test\n-//    public void decoratedCollectionIsIndexedOnCreation() throws Exception {\n-//        original.add(\"1\");\n-//        original.add(\"2\");\n-//        original.add(\"3\");\n-//        \n-//        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n-//            public Integer transform(String input) {\n-//                return Integer.parseInt(input);\n-//            }\n-//        });\n-//        assertEquals(\"1\", indexed.get(1));\n-//        assertEquals(\"2\", indexed.get(2));\n-//        assertEquals(\"3\", indexed.get(3));\n-//    }\n-//    \n-//    @Test\n-//    public void reindexUpdatesIndexWhenTheDecoratedCollectionIsModifiedSeparately() throws Exception {\n-//        original.add(\"1\");\n-//        original.add(\"2\");\n-//        original.add(\"3\");\n-//        \n-//        assertNull(indexed.get(1));\n-//        assertNull(indexed.get(2));\n-//        assertNull(indexed.get(3));\n-//        indexed.reindex();\n-//        assertEquals(\"1\", indexed.get(1));\n-//        assertEquals(\"2\", indexed.get(2));\n-//        assertEquals(\"3\", indexed.get(3));\n-//    }\n+    public void testDecoratedCollectionIsIndexedOnCreation() throws Exception {\n+        Collection<String> original = makeFullCollection();\n+        IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n+        \n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+    \n+    public void testReindexUpdatesIndexWhenDecoratedCollectionIsModifiedSeparately() throws Exception {\n+        Collection<String> original = new ArrayList<String>();\n+        IndexedCollection<Integer, String> indexed = decorateUniqueCollection(original);\n+        \n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+\n+        assertNull(indexed.get(1));\n+        assertNull(indexed.get(2));\n+        assertNull(indexed.get(3));\n+\n+        indexed.reindex();\n+\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n }", "timestamp": 1362228887, "metainfo": ""}