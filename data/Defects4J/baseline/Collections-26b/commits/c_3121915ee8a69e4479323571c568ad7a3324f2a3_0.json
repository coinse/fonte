{"sha": "3121915ee8a69e4479323571c568ad7a3324f2a3", "log": "Tidy up formatting for BoundedBuffer and BlockingBuffer  ", "commit": "\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n /*\n- *  Copyright 2002-2004 The Apache Software Foundation\n+ *  Copyright 2002-2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n     /**\n      * Returns a synchronized buffer backed by the given buffer that will\n-     * block on {@link Buffer#get()} and {@link Buffer#remove()} operations until\n-     * <code>timeout</code> expires.  If the buffer is empty, then the\n+     * block on {@link Buffer#get()} and {@link Buffer#remove()} operations\n+     * until <code>timeout</code> expires.  If the buffer is empty, then the\n      * {@link Buffer#get()} and {@link Buffer#remove()} operations will block\n-     * until new elements are added to the buffer, rather than immediately throwing a\n-     * <code>BufferUnderflowException</code>.\n+     * until new elements are added to the buffer, rather than immediately\n+     * throwing a <code>BufferUnderflowException</code>.\n      *\n      * @param buffer  the buffer to synchronize, must not be null\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n      * @return a blocking buffer backed by that buffer\n      * @throws IllegalArgumentException  if the Buffer is null\n      * @since Commons Collections 3.2\n      */\n-    public static Buffer blockingBuffer(Buffer buffer, long timeout) {\n-        return BlockingBuffer.decorate(buffer, timeout);\n-    }\n-\n-    /**\n-     * Returns a synchronized buffer backed by the given buffer that will block on {@link Buffer#add(Object)} and\n-     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are removed from the buffer to allow\n-     * the object(s) to be added and still maintain the maximum size.\n-     * @param buffer the buffer to make bounded\n-     * @param maximumSize the maximum size\n+    public static Buffer blockingBuffer(Buffer buffer, long timeoutMillis) {\n+        return BlockingBuffer.decorate(buffer, timeoutMillis);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#add(Object)} and\n+     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are\n+     * removed from the buffer to allow the object(s) to be added and still\n+     * maintain the maximum size.\n+     *\n+     * @param buffer  the buffer to make bounded,  must not be null\n+     * @param maximumSize  the maximum size\n      * @return a bounded buffer backed by the given buffer\n      * @throws IllegalArgumentException if the given buffer is null\n-     */\n-    public static Buffer boundedBuffer( Buffer buffer, int maximumSize ) {\n-        return BoundedBuffer.decorate( buffer, maximumSize );\n-    }\n-\n-    /**\n-     * Returns a synchronized buffer backed by the given buffer that will block on {@link Buffer#add(Object)} and\n-     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are removed from the buffer to allow\n-     * the object(s) to be added and still maintain the maximum size or the timeout expires.\n-     * @param buffer the buffer to make bounded\n+     * @since Commons Collections 3.2\n+     */\n+    public static Buffer boundedBuffer(Buffer buffer, int maximumSize) {\n+        return BoundedBuffer.decorate(buffer, maximumSize);\n+    }\n+\n+    /**\n+     * Returns a synchronized buffer backed by the given buffer that will\n+     * block on {@link Buffer#add(Object)} and\n+     * {@link Buffer#addAll(java.util.Collection)} until enough object(s) are\n+     * removed from the buffer to allow the object(s) to be added and still\n+     * maintain the maximum size or the timeout expires.\n+     *\n+     * @param buffer the buffer to make bounded, must not be null\n      * @param maximumSize the maximum size\n-     * @param timeout the maximum time to wait\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n      * @return a bounded buffer backed by the given buffer\n      * @throws IllegalArgumentException if the given buffer is null\n-     */\n-    public static Buffer boundedBuffer( Buffer buffer, int maximumSize, long timeout ) {\n-        return BoundedBuffer.decorate( buffer, maximumSize, timeout );\n-    }\n-    \n+     * @since Commons Collections 3.2\n+     */\n+    public static Buffer boundedBuffer(Buffer buffer, int maximumSize, long timeoutMillis) {\n+        return BoundedBuffer.decorate(buffer, maximumSize, timeoutMillis);\n+    }\n+\n     /**\n      * Returns an unmodifiable buffer backed by the given buffer.\n      *\n--- a/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BlockingBuffer.java\n  */\n package org.apache.commons.collections.buffer;\n \n-import org.apache.commons.collections.Buffer;\n-import org.apache.commons.collections.BufferUnderflowException;\n-\n import java.io.PrintWriter;\n import java.io.StringWriter;\n import java.util.Collection;\n \n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n /**\n- * Decorates another <code>Buffer</code> to make {@link #get()} and {@link #remove()} block when the <code>Buffer</code>\n- * is empty.\n- * <p/>\n- * If either <code>get</code> or <code>remove</code> is called on an empty <code>Buffer</code>, the calling thread waits\n- * for notification that an <code>add</code> or <code>addAll</code> operation has completed.\n- * <p/>\n- * When one or more entries are added to an empty <code>Buffer</code>, all threads blocked in <code>get</code> or\n- * <code>remove</code> are notified. There is no guarantee that concurrent blocked <code>get</code> or\n- * <code>remove</code> requests will be \"unblocked\" and receive data in the order that they arrive.\n- * <p/>\n+ * Decorates another <code>Buffer</code> to make {@link #get()} and\n+ * {@link #remove()} block when the <code>Buffer</code> is empty.\n+ * <p>\n+ * If either <code>get</code> or <code>remove</code> is called on an empty\n+ * <code>Buffer</code>, the calling thread waits for notification that\n+ * an <code>add</code> or <code>addAll</code> operation has completed.\n+ * <p>\n+ * When one or more entries are added to an empty <code>Buffer</code>,\n+ * all threads blocked in <code>get</code> or <code>remove</code> are notified.\n+ * There is no guarantee that concurrent blocked <code>get</code> or\n+ * <code>remove</code> requests will be \"unblocked\" and receive data in the\n+ * order that they arrive.\n+ * <p>\n  * This class is Serializable from Commons Collections 3.1.\n+ * This class contains an extra field in 3.2, however the serialization\n+ * specification will handle this gracefully.\n  *\n  * @author Stephen Colebourne\n  * @author Janek Bogucki\n  */\n public class BlockingBuffer extends SynchronizedBuffer {\n \n-    /**\n-     * Serialization version\n-     */\n+    /** Serialization version. */\n     private static final long serialVersionUID = 1719328905017860541L;\n-\n-    private long timeout;\n+    /** The timeout value in milliseconds. */\n+    private final long timeout;\n \n     /**\n      * Factory method to create a blocking buffer.\n      * @return a new blocking Buffer\n      * @throws IllegalArgumentException if buffer is null\n      */\n-    public static Buffer decorate( Buffer buffer ) {\n-        return new BlockingBuffer( buffer );\n+    public static Buffer decorate(Buffer buffer) {\n+        return new BlockingBuffer(buffer);\n     }\n \n     /**\n      * Factory method to create a blocking buffer with a timeout value.\n      *\n      * @param buffer  the buffer to decorate, must not be null\n-     * @param timeout the maximum amount of time to block\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n      * @return a new blocking buffer\n      * @throws IllegalArgumentException if the buffer is null\n-     */\n-    public static Buffer decorate( Buffer buffer, long timeout ) {\n-        return new BlockingBuffer( buffer, timeout );\n-    }\n-\n-    //-----------------------------------------------------------------------\n-\n+     * @since Commons Collections 3.2\n+     */\n+    public static Buffer decorate(Buffer buffer, long timeoutMillis) {\n+        return new BlockingBuffer(buffer, timeoutMillis);\n+    }\n+\n+    //-----------------------------------------------------------------------    \n     /**\n      * Constructor that wraps (not copies).\n      *\n      * @param buffer the buffer to decorate, must not be null\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    protected BlockingBuffer( Buffer buffer ) {\n-        super( buffer );\n+    protected BlockingBuffer(Buffer buffer) {\n+        super(buffer);\n+        this.timeout = 0;\n     }\n \n     /**\n      * Constructor that wraps (not copies).\n      *\n      * @param buffer  the buffer to decorate, must not be null\n-     * @param timeout the maximum amount of time to block\n+     * @param timeoutMillis  the timeout value in milliseconds, zero or less for no timeout\n      * @throws IllegalArgumentException if the buffer is null\n-     */\n-    protected BlockingBuffer( Buffer buffer, long timeout ) {\n-        super( buffer );\n-        this.timeout = timeout < 0 ? 0 : timeout;\n+     * @since Commons Collections 3.2\n+     */\n+    protected BlockingBuffer(Buffer buffer, long timeoutMillis) {\n+        super(buffer);\n+        this.timeout = (timeoutMillis < 0 ? 0 : timeoutMillis);\n     }\n \n     //-----------------------------------------------------------------------\n-    public boolean add( Object o ) {\n-        synchronized( lock ) {\n-            boolean result = collection.add( o );\n+    public boolean add(Object o) {\n+        synchronized (lock) {\n+            boolean result = collection.add(o);\n             lock.notifyAll();\n             return result;\n         }\n     }\n \n-    public boolean addAll( Collection c ) {\n-        synchronized( lock ) {\n-            boolean result = collection.addAll( c );\n+    public boolean addAll(Collection c) {\n+        synchronized (lock) {\n+            boolean result = collection.addAll(c);\n             lock.notifyAll();\n             return result;\n         }\n     }\n \n     /**\n-     * Gets the next value from the buffer, waiting until an object is added if the buffer is empty.\n+     * Gets the next value from the buffer, waiting until an object is\n+     * added if the buffer is empty. This method uses the default timeout\n+     * set in the constructor.\n      *\n      * @throws BufferUnderflowException if an interrupt is received\n      */\n     public Object get() {\n-        synchronized( lock ) {\n-            while( collection.isEmpty() ) {\n-                try {\n-                    if( timeout <= 0 ) {\n+        synchronized (lock) {\n+            while (collection.isEmpty()) {\n+                try {\n+                    if (timeout <= 0) {\n                         lock.wait();\n+                    } else {\n+                        return get(timeout);\n                     }\n-                    else {\n-                        return get( timeout );\n-                    }\n-                }\n-                catch( InterruptedException e ) {\n-                    PrintWriter out = new PrintWriter( new StringWriter() );\n-                    e.printStackTrace( out );\n-                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n+                } catch (InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n             return getBuffer().get();\n     }\n \n     /**\n-     * Gets the next value from the buffer, waiting until an object is added for up to the specified timeout value if\n-     * the buffer is empty.\n-     *\n-     * @param timeout the timeout value in milliseconds\n+     * Gets the next value from the buffer, waiting until an object is\n+     * added for up to the specified timeout value if the buffer is empty.\n+     *\n+     * @param timeout  the timeout value in milliseconds\n      * @throws BufferUnderflowException if an interrupt is received\n      * @throws BufferUnderflowException if the timeout expires\n      * @since Commons Collections 3.2\n      */\n-    public Object get( final long timeout ) {\n-        synchronized( lock ) {\n+    public Object get(final long timeout) {\n+        synchronized (lock) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while( timeLeft > 0 && collection.isEmpty() ) {\n-                try {\n-                    lock.wait( timeLeft );\n+            while (timeLeft > 0 && collection.isEmpty()) {\n+                try {\n+                    lock.wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                }\n-                catch( InterruptedException e ) {\n-                    PrintWriter out = new PrintWriter( new StringWriter() );\n-                    e.printStackTrace( out );\n-                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n-                }\n-            }\n-            if( collection.isEmpty() ) {\n-                throw new BufferUnderflowException( \"Timeout expired.\" );\n+                } catch(InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            if (collection.isEmpty()) {\n+                throw new BufferUnderflowException(\"Timeout expired\");\n             }\n             return getBuffer().get();\n         }\n     }\n \n     /**\n-     * Removes the next value from the buffer, waiting until an object is added if the buffer is empty.\n+     * Removes the next value from the buffer, waiting until an object is\n+     * added if the buffer is empty. This method uses the default timeout\n+     * set in the constructor.\n      *\n      * @throws BufferUnderflowException if an interrupt is received\n      */\n     public Object remove() {\n-        synchronized( lock ) {\n-            while( collection.isEmpty() ) {\n-                try {\n-                    if( timeout <= 0 ) {\n+        synchronized (lock) {\n+            while (collection.isEmpty()) {\n+                try {\n+                    if (timeout <= 0) {\n                         lock.wait();\n+                    } else {\n+                        return remove(timeout);\n                     }\n-                    else {\n-                        return remove( timeout );\n-                    }\n-                }\n-                catch( InterruptedException e ) {\n-                    PrintWriter out = new PrintWriter( new StringWriter() );\n-                    e.printStackTrace( out );\n-                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n+                } catch (InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n             return getBuffer().remove();\n     }\n \n     /**\n-     * Removes the next value from the buffer, waiting until an object is added for up to the specified timeout value if\n-     * the buffer is empty.\n-     *\n-     * @param timeout the timeout value in milliseconds\n+     * Removes the next value from the buffer, waiting until an object is\n+     * added for up to the specified timeout value if the buffer is empty.\n+     *\n+     * @param timeout  the timeout value in milliseconds\n      * @throws BufferUnderflowException if an interrupt is received\n      * @throws BufferUnderflowException if the timeout expires\n      * @since Commons Collections 3.2\n      */\n-    public Object remove( final long timeout ) {\n-        synchronized( lock ) {\n+    public Object remove(final long timeout) {\n+        synchronized (lock) {\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while( timeLeft > 0 && collection.isEmpty() ) {\n-                try {\n-                    lock.wait( timeLeft );\n+            while (timeLeft > 0 && collection.isEmpty()) {\n+                try {\n+                    lock.wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                }\n-                catch( InterruptedException e ) {\n-                    PrintWriter out = new PrintWriter( new StringWriter() );\n-                    e.printStackTrace( out );\n-                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n-                }\n-            }\n-            if( collection.isEmpty() ) {\n-                throw new BufferUnderflowException( \"Timeout expired.\" );\n+                } catch(InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\"Caused by InterruptedException: \" + out.toString());\n+                }\n+            }\n+            if (collection.isEmpty()) {\n+                throw new BufferUnderflowException(\"Timeout expired\");\n             }\n             return getBuffer().remove();\n         }\n     }\n+\n }\n--- a/src/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n+++ b/src/java/org/apache/commons/collections/buffer/BoundedBuffer.java\n /*\n- *  Copyright 2001-2005 The Apache Software Foundation\n+ *  Copyright 2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n import org.apache.commons.collections.Buffer;\n import org.apache.commons.collections.BufferOverflowException;\n import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.iterators.AbstractIteratorDecorator;\n \n import java.io.PrintWriter;\n import java.io.StringWriter;\n \n /**\n  * A wrapper class for buffers which makes them bounded.\n+ *\n  * @author James Carman\n- * @since 3.2\n+ * @version $Revision: $ $Date: $\n+ * @since Commons Collections 3.2\n  */\n public class BoundedBuffer extends SynchronizedBuffer {\n \n+    /** The serialization version. */\n     private static final long serialVersionUID = 1536432911093974264L;\n-\n+    /** The maximum size. */\n     private final int maximumSize;\n+    /** The timeout milliseconds. */\n     private final long timeout;\n \n     /**\n      * Factory method to create a bounded buffer.\n-     * @param buffer the buffer to decorate, must not be null\n-     * @param maximumSize the maximum size\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param maximumSize  the maximum size\n      * @return a new bounded buffer\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    public static Buffer decorate( Buffer buffer, int maximumSize ) {\n-        return new BoundedBuffer( buffer, maximumSize );\n+    public static Buffer decorate(Buffer buffer, int maximumSize) {\n+        return new BoundedBuffer(buffer, maximumSize, 0L);\n     }\n \n     /**\n      * Factory method to create a bounded buffer that blocks for a maximum\n      * amount of time.\n-     * @param buffer the buffer to decorate, must not be null\n-     * @param maximumSize the maximum size\n-     * @param timeout the maximum amount of time to wait.\n+     *\n+     * @param buffer  the buffer to decorate, must not be null\n+     * @param maximumSize  the maximum size\n+     * @param timeout  the maximum amount of time to wait in milliseconds\n      * @return a new bounded buffer\n      * @throws IllegalArgumentException if the buffer is null\n      */\n-    public static Buffer decorate( Buffer buffer, int maximumSize, long timeout ) {\n-        return new BoundedBuffer( buffer, maximumSize, timeout );\n+    public static Buffer decorate(Buffer buffer, int maximumSize, long timeout) {\n+        return new BoundedBuffer(buffer, maximumSize, timeout);\n     }\n \n-    /**\n-     * Constructor that wraps (not copies) another buffer, making it bounded.\n-     * @param buffer the buffer to wrap, must not be null\n-     * @param maximumSize the maximum size of the buffer\n-     * @throws IllegalArgumentException if the buffer is null\n-     */\n-    protected BoundedBuffer( Buffer buffer, int maximumSize ) {\n-        this( buffer, maximumSize, -1 );\n-    }\n-\n+    //-----------------------------------------------------------------------\n     /**\n      * Constructor that wraps (not copies) another buffer, making it bounded waiting only up to\n      * a maximum amount of time.\n         this.timeout = timeout;\n     }\n \n+    //-----------------------------------------------------------------------\n     public Object remove() {\n-        synchronized( lock ) {\n+        synchronized (lock) {\n             Object returnValue = getBuffer().remove();\n             lock.notifyAll();\n             return returnValue;\n         }\n     }\n \n-    public boolean add( Object o ) {\n-        synchronized( lock ) {\n-            timeoutWait( 1 );\n-            return getBuffer().add( o );\n+    public boolean add(Object o) {\n+        synchronized (lock) {\n+            timeoutWait(1);\n+            return getBuffer().add(o);\n         }\n     }\n \n-    public boolean addAll( final Collection c ) {\n-        synchronized( lock ) {\n-            timeoutWait( c.size() );\n-            return getBuffer().addAll( c );\n+    public boolean addAll(final Collection c) {\n+        synchronized (lock) {\n+            timeoutWait(c.size());\n+            return getBuffer().addAll(c);\n         }\n     }\n \n     public Iterator iterator() {\n-        return new NotifyingIterator( collection.iterator() );\n+        return new NotifyingIterator(collection.iterator());\n     }\n \n-    private void timeoutWait( final int nAdditions ) {\n-        synchronized( lock ) {\n-            if( timeout < 0 && getBuffer().size() + nAdditions > maximumSize ) {\n-                throw new BufferOverflowException( \"Buffer size cannot exceed \" + maximumSize + \".\" );\n+    private void timeoutWait(final int nAdditions) {\n+        synchronized (lock) {\n+            if (timeout < 0 && getBuffer().size() + nAdditions > maximumSize) {\n+                throw new BufferOverflowException(\n+                    \"Buffer size cannot exceed \" + maximumSize);\n             }\n             final long expiration = System.currentTimeMillis() + timeout;\n             long timeLeft = expiration - System.currentTimeMillis();\n-            while( timeLeft > 0 && getBuffer().size() + nAdditions > maximumSize ) {\n+            while (timeLeft > 0 && getBuffer().size() + nAdditions > maximumSize) {\n                 try {\n-                    lock.wait( timeLeft );\n+                    lock.wait(timeLeft);\n                     timeLeft = expiration - System.currentTimeMillis();\n-                }\n-                catch( InterruptedException e ) {\n-                    PrintWriter out = new PrintWriter( new StringWriter() );\n-                    e.printStackTrace( out );\n-                    throw new BufferUnderflowException( \"Caused by InterruptedException: \" + out.toString() );\n+                } catch (InterruptedException e) {\n+                    PrintWriter out = new PrintWriter(new StringWriter());\n+                    e.printStackTrace(out);\n+                    throw new BufferUnderflowException(\n+                        \"Caused by InterruptedException: \" + out.toString());\n                 }\n             }\n-            if( getBuffer().size() + nAdditions > maximumSize ) {\n-                throw new BufferOverflowException( \"Timeout expired.\" );\n+            if (getBuffer().size() + nAdditions > maximumSize) {\n+                throw new BufferOverflowException(\"Timeout expired\");\n             }\n         }\n     }\n \n-    private class NotifyingIterator implements Iterator {\n+    //-----------------------------------------------------------------------\n+    /**\n+     * BoundedBuffer iterator.\n+     */\n+    private class NotifyingIterator extends AbstractIteratorDecorator {\n \n-        private final Iterator i;\n-\n-        public NotifyingIterator( Iterator i ) {\n-            this.i = i;\n+        public NotifyingIterator(Iterator it) {\n+            super(it);\n         }\n \n         public void remove() {\n-            synchronized( lock ) {\n-                i.remove();\n+            synchronized (lock) {\n+                iterator.remove();\n                 lock.notifyAll();\n             }\n         }\n-\n-        public boolean hasNext() {\n-            return i.hasNext();\n-        }\n-\n-        public Object next() {\n-            return i.next();\n-        }\n     }\n }\n-\n--- a/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedBuffer.java\n /*\n- *  Copyright 2001-2005 The Apache Software Foundation\n+ *  Copyright 2005 The Apache Software Foundation\n  *\n  *  Licensed under the Apache License, Version 2.0 (the \"License\");\n  *  you may not use this file except in compliance with the License.\n \n public class TestBoundedBuffer extends AbstractTestObject {\n \n-    public TestBoundedBuffer( String testName ) {\n-        super( testName );\n+    public TestBoundedBuffer(String testName) {\n+        super(testName);\n     }\n \n     public String getCompatibilityVersion() {\n     }\n \n     public Object makeObject() {\n-        return BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1 );\n+        return BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n     }\n \n     public void testAddToFullBufferNoTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1 );\n+        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n         bounded.add( \"Hello\" );\n         try {\n-            bounded.add( \"World\" );\n+            bounded.add(\"World\");\n             fail();\n-        }\n-        catch( BufferOverflowException e ) {\n+        } catch (BufferOverflowException e) {\n         }\n     }\n \n     public void testAddAllToFullBufferNoTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1 );\n+        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1);\n         bounded.add( \"Hello\" );\n         try {\n-            bounded.addAll( Collections.singleton( \"World\" ) );\n+            bounded.addAll(Collections.singleton(\"World\"));\n             fail();\n-        }\n-        catch( BufferOverflowException e ) {\n+        } catch (BufferOverflowException e) {\n         }\n     }\n \n     public void testAddToFullBufferRemoveViaIterator() {\n-        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1, 500 );\n+        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1, 500);\n         bounded.add( \"Hello\" );\n         new DelayedIteratorRemove( bounded, 200 ).start();\n         bounded.add( \"World\" );\n     }\n \n     public void testAddAllToFullBufferRemoveViaIterator() {\n-        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 2, 500 );\n+        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 2, 500);\n         bounded.add( \"Hello\" );\n         bounded.add( \"World\" );\n         new DelayedIteratorRemove( bounded, 200, 2 ).start();\n     }\n \n     public void testAddToFullBufferWithTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 1, 500 );\n+        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 1, 500);\n         bounded.add( \"Hello\" );\n         new DelayedRemove( bounded, 200 ).start();\n         bounded.add( \"World\" );\n     }\n \n     public void testAddAllToFullBufferWithTimeout() {\n-        final Buffer bounded = BoundedBuffer.decorate( new UnboundedFifoBuffer(), 2, 500 );\n+        final Buffer bounded = BoundedBuffer.decorate(new UnboundedFifoBuffer(), 2, 500);\n         bounded.add( \"Hello\" );\n         bounded.add( \"World\" );\n         new DelayedRemove( bounded, 200, 2 ).start();\n \n         private final int nToRemove;\n \n-        public DelayedIteratorRemove( Buffer buffer, long delay, int nToRemove ) {\n+        public DelayedIteratorRemove(Buffer buffer, long delay, int nToRemove) {\n             this.buffer = buffer;\n             this.delay = delay;\n             this.nToRemove = nToRemove;\n         }\n \n-        public DelayedIteratorRemove( Buffer buffer, long delay ) {\n-            this( buffer, delay, 1 );\n+        public DelayedIteratorRemove(Buffer buffer, long delay) {\n+            this(buffer, delay, 1);\n         }\n \n         public void run() {\n             try {\n-                Thread.sleep( delay );\n+                Thread.sleep(delay);\n                 Iterator iter = buffer.iterator();\n-                for( int i = 0; i < nToRemove; ++i ) {\n+                for (int i = 0; i < nToRemove; ++i) {\n                     iter.next();\n                     iter.remove();\n                 }\n \n-            }\n-            catch( InterruptedException e ) {\n+            } catch (InterruptedException e) {\n             }\n         }\n     }\n \n         private final int nToRemove;\n \n-        public DelayedRemove( Buffer buffer, long delay, int nToRemove ) {\n+        public DelayedRemove(Buffer buffer, long delay, int nToRemove) {\n             this.buffer = buffer;\n             this.delay = delay;\n             this.nToRemove = nToRemove;\n         }\n \n-        public DelayedRemove( Buffer buffer, long delay ) {\n-            this( buffer, delay, 1 );\n+        public DelayedRemove(Buffer buffer, long delay) {\n+            this(buffer, delay, 1);\n         }\n \n         public void run() {\n             try {\n-                Thread.sleep( delay );\n-                for( int i = 0; i < nToRemove; ++i ) {\n+                Thread.sleep(delay);\n+                for (int i = 0; i < nToRemove; ++i) {\n                     buffer.remove();\n                 }\n-            }\n-            catch( InterruptedException e ) {\n+            } catch (InterruptedException e) {\n             }\n         }\n     }", "timestamp": 1132868109, "metainfo": ""}