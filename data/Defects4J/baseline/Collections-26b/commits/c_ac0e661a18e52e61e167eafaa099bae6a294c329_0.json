{"sha": "ac0e661a18e52e61e167eafaa099bae6a294c329", "log": "Refactor Buffer implementations to buffer subpackage   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BinaryHeap.java\n+++ b/src/java/org/apache/commons/collections/BinaryHeap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.14 2003/08/31 17:26:44 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BinaryHeap.java,v 1.15 2003/11/29 18:04:57 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Buffer heap = BufferUtils.synchronizedBuffer(new BinaryHeap());\n  * </pre>\n  *\n+ * @deprecated Moved to buffer subpackage. Due to be removed in v4.0.\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.14 $ $Date: 2003/08/31 17:26:44 $\n+ * @version $Revision: 1.15 $ $Date: 2003/11/29 18:04:57 $\n  * \n  * @author <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n  * @author <a href=\"mailto:ram.chidambaram@telus.com\">Ram Chidambaram</a>\n--- a/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/BoundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BoundedFifoBuffer.java,v 1.11 2003/11/18 22:50:44 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BoundedFifoBuffer.java,v 1.12 2003/11/29 18:04:57 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <p>\n  * This buffer prevents null objects from being added.\n  *\n+ * @deprecated Moved to buffer subpackage. Due to be removed in v4.0.\n  * @since 2.1\n- * @version $Revision: 1.11 $ $Date: 2003/11/18 22:50:44 $\n+ * @version $Revision: 1.12 $ $Date: 2003/11/29 18:04:57 $\n  * \n  * @author Avalon\n  * @author Berin Loritsch\n  * @author Stephen Colebourne\n  * @author Herve Quiroz\n  */\n-public class BoundedFifoBuffer extends AbstractCollection implements Buffer, BoundedCollection {\n+public class BoundedFifoBuffer extends AbstractCollection\n+        implements Buffer, BoundedCollection {\n+            \n     private final Object[] m_elements;\n     private int m_start = 0;\n     private int m_end = 0;\n--- a/src/java/org/apache/commons/collections/CircularFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/CircularFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/CircularFifoBuffer.java,v 1.4 2003/08/31 17:26:44 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/Attic/CircularFifoBuffer.java,v 1.5 2003/11/29 18:04:57 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n \n import java.util.Collection;\n \n-import org.apache.commons.collections.BoundedFifoBuffer;\n-\n /** \n  * CircularFifoBuffer is a first in first out buffer with a fixed size that\n  * replaces its oldest element if full.\n  * <p>\n  * This buffer prevents null objects from being added.\n  * \n+ * @deprecated WILL BE REMOVED BEFORE v3.0\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.4 $ $Date: 2003/08/31 17:26:44 $\n+ * @version $Revision: 1.5 $ $Date: 2003/11/29 18:04:57 $\n  * \n  * @author Stefano Fornari\n  * @author Stephen Colebourne\n--- a/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java\n+++ b/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java,v 1.11 2003/10/14 18:06:41 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/UnboundedFifoBuffer.java,v 1.12 2003/11/29 18:04:57 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * <p>\n  * This buffer prevents null objects from being added.\n  * \n+ * @deprecated Moved to buffer subpackage. Due to be removed in v4.0.\n  * @since Commons Collections 2.1\n- * @version $Revision: 1.11 $ $Date: 2003/10/14 18:06:41 $\n+ * @version $Revision: 1.12 $ $Date: 2003/11/29 18:04:57 $\n  *\n  * @author Avalon\n  * @author Federico Barbieri\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/BinaryHeap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/Attic/BinaryHeap.java,v 1.1 2003/11/29 18:04:57 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.AbstractCollection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.PriorityQueue;\n+\n+/**\n+ * Binary heap implementation of {@link PriorityQueue} and {@link Buffer}.\n+ * <p>\n+ * The removal order of a binary heap is based on either the natural sort\n+ * order of its elements or a specified {@link Comparator}.  The \n+ * {@link #remove()} method always returns the first element as determined\n+ * by the sort order.  (The <code>isMinHeap</code> flag in the constructors\n+ * can be used to reverse the sort order, in which case {@link #remove()}\n+ * will always remove the last element.)  The removal order is \n+ * <i>not</i> the same as the order of iteration; elements are\n+ * returned by the iterator in no particular order.\n+ * <p>\n+ * The {@link #add(Object)} and {@link #remove()} operations perform\n+ * in logarithmic time.  The {@link #get()} operation performs in constant\n+ * time.  All other operations perform in linear time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  Use \n+ * {@link BufferUtils#synchronizedBuffer(Buffer)} to provide\n+ * synchronized access to a <code>BinaryHeap</code>:\n+ *\n+ * <pre>\n+ * Buffer heap = BufferUtils.synchronizedBuffer(new BinaryHeap());\n+ * </pre>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:57 $\n+ * \n+ * @author Peter Donald\n+ * @author Ram Chidambaram\n+ * @author Michael A. Smith\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public final class BinaryHeap extends AbstractCollection\n+        implements PriorityQueue, Buffer {\n+\n+    /**\n+     * The default capacity for a binary heap.\n+     */\n+    private final static int DEFAULT_CAPACITY = 13;\n+    /**\n+     * The number of elements currently in this heap.\n+     */\n+    int m_size;  // package scoped for testing\n+    /**\n+     * The elements in this heap.\n+     */\n+    Object[] m_elements;  // package scoped for testing\n+    /**\n+     * If true, the first element as determined by the sort order will \n+     * be returned.  If false, the last element as determined by the\n+     * sort order will be returned.\n+     */\n+    boolean m_isMinHeap;  // package scoped for testing\n+    /**\n+     * The comparator used to order the elements\n+     */\n+    Comparator m_comparator;  // package scoped for testing\n+\n+    /**\n+     * Constructs a new minimum binary heap.\n+     */\n+    public BinaryHeap() {\n+        this(DEFAULT_CAPACITY, true);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code> that will use the given\n+     * comparator to order its elements.\n+     * \n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     */\n+    public BinaryHeap(Comparator comparator) {\n+        this();\n+        m_comparator = comparator;\n+    }\n+    \n+    /**\n+     * Constructs a new minimum binary heap with the specified initial capacity.\n+     *  \n+     * @param capacity  The initial capacity for the heap.  This value must\n+     *  be greater than zero.\n+     * @throws IllegalArgumentException  \n+     *  if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public BinaryHeap(int capacity) {\n+        this(capacity, true);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code>.\n+     *\n+     * @param capacity  the initial capacity for the heap\n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     * @throws IllegalArgumentException  \n+     *  if <code>capacity</code> is &lt;= <code>0</code>\n+     */\n+    public BinaryHeap(int capacity, Comparator comparator) {\n+        this(capacity);\n+        m_comparator = comparator;\n+    }\n+\n+    /**\n+     * Constructs a new minimum or maximum binary heap\n+     *\n+     * @param isMinHeap  if <code>true</code> the heap is created as a \n+     * minimum heap; otherwise, the heap is created as a maximum heap\n+     */\n+    public BinaryHeap(boolean isMinHeap) {\n+        this(DEFAULT_CAPACITY, isMinHeap);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code>.\n+     *\n+     * @param isMinHeap  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     */\n+    public BinaryHeap(boolean isMinHeap, Comparator comparator) {\n+        this(isMinHeap);\n+        m_comparator = comparator;\n+    }\n+\n+    /**\n+     * Constructs a new minimum or maximum binary heap with the specified \n+     * initial capacity.\n+     *\n+     * @param capacity the initial capacity for the heap.  This value must \n+     * be greater than zero.\n+     * @param isMinHeap if <code>true</code> the heap is created as a \n+     *  minimum heap; otherwise, the heap is created as a maximum heap.\n+     * @throws IllegalArgumentException \n+     *  if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public BinaryHeap(int capacity, boolean isMinHeap) {\n+        if (capacity <= 0) {\n+            throw new IllegalArgumentException(\"invalid capacity\");\n+        }\n+        m_isMinHeap = isMinHeap;\n+\n+        //+1 as 0 is noop\n+        m_elements = new Object[capacity + 1];\n+    }\n+\n+    /**\n+     * Constructs a new <code>BinaryHeap</code>.\n+     *\n+     * @param capacity  the initial capacity for the heap\n+     * @param isMinHeap  true to use the order imposed by the given \n+     *   comparator; false to reverse that order\n+     * @param comparator  the comparator used to order the elements, null\n+     *  means use natural order\n+     * @throws IllegalArgumentException \n+     *  if <code>capacity</code> is <code>&lt;= 0</code>\n+     */\n+    public BinaryHeap(int capacity, boolean isMinHeap, Comparator comparator) {\n+        this(capacity, isMinHeap);\n+        m_comparator = comparator;\n+    }\n+\n+    \n+    /**\n+     * Clears all elements from queue.\n+     */\n+    public void clear() {\n+        m_elements = new Object[m_elements.length];  // for gc\n+        m_size = 0;\n+    }\n+\n+    /**\n+     * Tests if queue is empty.\n+     *\n+     * @return <code>true</code> if queue is empty; <code>false</code> \n+     *  otherwise.\n+     */\n+    public boolean isEmpty() {\n+        return m_size == 0;\n+    }\n+\n+    /**\n+     * Tests if queue is full.\n+     *\n+     * @return <code>true</code> if queue is full; <code>false</code>\n+     *  otherwise.\n+     */\n+    public boolean isFull() {\n+        //+1 as element 0 is noop\n+        return m_elements.length == m_size + 1;\n+    }\n+\n+    /**\n+     * Inserts an element into queue.\n+     *\n+     * @param element  the element to be inserted\n+     */\n+    public void insert(Object element) {\n+        if (isFull()) {\n+            grow();\n+        }\n+        //percolate element to it's place in tree\n+        if (m_isMinHeap) {\n+            percolateUpMinHeap(element);\n+        } else {\n+            percolateUpMaxHeap(element);\n+        }\n+    }\n+\n+    /**\n+     * Returns the element on top of heap but don't remove it.\n+     *\n+     * @return the element at top of heap\n+     * @throws NoSuchElementException  if <code>isEmpty() == true</code>\n+     */\n+    public Object peek() throws NoSuchElementException {\n+        if (isEmpty()) {\n+            throw new NoSuchElementException();\n+        } else {\n+            return m_elements[1];\n+        }\n+    }\n+\n+    /**\n+     * Returns the element on top of heap and remove it.\n+     *\n+     * @return the element at top of heap\n+     * @throws NoSuchElementException  if <code>isEmpty() == true</code>\n+     */\n+    public Object pop() throws NoSuchElementException {\n+        final Object result = peek();\n+        m_elements[1] = m_elements[m_size--];\n+\n+        // set the unused element to 'null' so that the garbage collector\n+        // can free the object if not used anywhere else.(remove reference)\n+        m_elements[m_size + 1] = null;\n+\n+        if (m_size != 0) {\n+            // percolate top element to it's place in tree\n+            if (m_isMinHeap) {\n+                percolateDownMinHeap(1);\n+            } else {\n+                percolateDownMaxHeap(1);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Percolates element down heap from top.\n+     * Assume it is a maximum heap.\n+     *\n+     * @param index the index for the element\n+     */\n+    protected void percolateDownMinHeap(final int index) {\n+        final Object element = m_elements[index];\n+        int hole = index;\n+\n+        while ((hole * 2) <= m_size) {\n+            int child = hole * 2;\n+\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != m_size && compare(m_elements[child + 1], m_elements[child]) < 0) {\n+                child++;\n+            }\n+\n+            // if we found resting place of bubble then terminate search\n+            if (compare(m_elements[child], element) >= 0) {\n+                break;\n+            }\n+\n+            m_elements[hole] = m_elements[child];\n+            hole = child;\n+        }\n+\n+        m_elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element down heap from top.\n+     * Assume it is a maximum heap.\n+     *\n+     * @param index the index of the element\n+     */\n+    protected void percolateDownMaxHeap(final int index) {\n+        final Object element = m_elements[index];\n+        int hole = index;\n+\n+        while ((hole * 2) <= m_size) {\n+            int child = hole * 2;\n+\n+            // if we have a right child and that child can not be percolated\n+            // up then move onto other child\n+            if (child != m_size && compare(m_elements[child + 1], m_elements[child]) > 0) {\n+                child++;\n+            }\n+\n+            // if we found resting place of bubble then terminate search\n+            if (compare(m_elements[child], element) <= 0) {\n+                break;\n+            }\n+\n+            m_elements[hole] = m_elements[child];\n+            hole = child;\n+        }\n+\n+        m_elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element up heap from bottom.\n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMinHeap(final Object element) {\n+        int hole = ++m_size;\n+\n+        m_elements[hole] = element;\n+\n+        while (hole > 1 && compare(element, m_elements[hole / 2]) < 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            m_elements[hole] = m_elements[next];\n+            hole = next;\n+        }\n+\n+        m_elements[hole] = element;\n+    }\n+\n+    /**\n+     * Percolates element up heap from bottom.\n+     * Assume it is a maximum heap.\n+     *\n+     * @param element the element\n+     */\n+    protected void percolateUpMaxHeap(final Object element) {\n+        int hole = ++m_size;\n+\n+        while (hole > 1 && compare(element, m_elements[hole / 2]) > 0) {\n+            // save element that is being pushed down\n+            // as the element \"bubble\" is percolated up\n+            final int next = hole / 2;\n+            m_elements[hole] = m_elements[next];\n+            hole = next;\n+        }\n+\n+        m_elements[hole] = element;\n+    }\n+    \n+    /**\n+     * Compares two objects using the comparator if specified, or the\n+     * natural order otherwise.\n+     * \n+     * @param a  the first object\n+     * @param b  the second object\n+     * @return -ve if a less than b, 0 if they are equal, +ve if a greater than b\n+     */\n+    private int compare(Object a, Object b) {\n+        if (m_comparator != null) {\n+            return m_comparator.compare(a, b);\n+        } else {\n+            return ((Comparable) a).compareTo(b);\n+        }\n+    }\n+\n+    /**\n+     * Increases the size of the heap to support additional elements\n+     */\n+    protected void grow() {\n+        final Object[] elements = new Object[m_elements.length * 2];\n+        System.arraycopy(m_elements, 0, elements, 0, m_elements.length);\n+        m_elements = elements;\n+    }\n+\n+    /**\n+     * Returns a string representation of this heap.  The returned string\n+     * is similar to those produced by standard JDK collections.\n+     *\n+     * @return a string representation of this heap\n+     */\n+    public String toString() {\n+        final StringBuffer sb = new StringBuffer();\n+\n+        sb.append(\"[ \");\n+\n+        for (int i = 1; i < m_size + 1; i++) {\n+            if (i != 1) {\n+                sb.append(\", \");\n+            }\n+            sb.append(m_elements[i]);\n+        }\n+\n+        sb.append(\" ]\");\n+\n+        return sb.toString();\n+    }\n+\n+\n+    /**\n+     * Returns an iterator over this heap's elements.\n+     *\n+     * @return an iterator over this heap's elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator() {\n+\n+            private int index = 1;\n+            private int lastReturnedIndex = -1;\n+\n+            public boolean hasNext() {\n+                return index <= m_size;\n+            }\n+\n+            public Object next() {\n+                if (!hasNext()) throw new NoSuchElementException();\n+                lastReturnedIndex = index;\n+                index++;\n+                return m_elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+                m_elements[ lastReturnedIndex ] = m_elements[ m_size ];\n+                m_elements[ m_size ] = null;\n+                m_size--;\n+                if( m_size != 0 )\n+                {\n+                    //percolate top element to it's place in tree\n+                    if( m_isMinHeap ) percolateDownMinHeap( lastReturnedIndex );\n+                    else percolateDownMaxHeap( lastReturnedIndex );\n+                }\n+                index--;\n+                lastReturnedIndex = -1;        \n+            }\n+\n+        };\n+    }\n+\n+\n+    /**\n+     * Adds an object to this heap. Same as {@link #insert(Object)}.\n+     *\n+     * @param object  the object to add\n+     * @return true, always\n+     */\n+    public boolean add(Object object) {\n+        insert(object);\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the priority element. Same as {@link #peek()}.\n+     *\n+     * @return the priority element\n+     * @throws BufferUnderflowException if this heap is empty\n+     */\n+    public Object get() {\n+        try {\n+            return peek();\n+        } catch (NoSuchElementException e) {\n+            throw new BufferUnderflowException();\n+        }\n+    }\n+\n+    /**\n+     * Removes the priority element. Same as {@link #pop()}.\n+     *\n+     * @return the removed priority element\n+     * @throws BufferUnderflowException if this heap is empty\n+     */\n+    public Object remove() {\n+        try {\n+            return pop();\n+        } catch (NoSuchElementException e) {\n+            throw new BufferUnderflowException();\n+        }\n+    }\n+\n+    /**\n+     * Returns the number of elements in this heap.\n+     *\n+     * @return the number of elements in this heap\n+     */\n+    public int size() {\n+        return m_size;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/BoundedFifoBuffer.java,v 1.1 2003/11/29 18:04:57 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.AbstractCollection;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.collection.BoundedCollection;\n+\n+/**\n+ * The BoundedFifoBuffer is a <strong>very</strong> efficient implementation of\n+ * Buffer that does not alter the size of the buffer at runtime.\n+ * <p>\n+ * The removal order of a <code>BoundedFifoBuffer</code> is based on the \n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <code>BoundedFifoBuffer</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new BoundedFifoBuffer());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:57 $\n+ * \n+ * @author Avalon\n+ * @author Berin Loritsch\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ * @author Herve Quiroz\n+ */\n+public class BoundedFifoBuffer extends AbstractCollection\n+        implements Buffer, BoundedCollection {\n+            \n+    private final Object[] m_elements;\n+    private int m_start = 0;\n+    private int m_end = 0;\n+    private boolean m_full = false;\n+    private final int maxElements;\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n+     * 32 elements.\n+     */\n+    public BoundedFifoBuffer() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold\n+     * the specified number of elements.\n+     *\n+     * @param size  the maximum number of elements for this fifo\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    public BoundedFifoBuffer(int size) {\n+        if (size <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        m_elements = new Object[size];\n+        maxElements = m_elements.length;\n+    }\n+\n+    /**\n+     * Constructs a new <code>BoundedFifoBuffer</code> big enough to hold all\n+     * of the elements in the specified collection. That collection's\n+     * elements will also be added to the buffer.\n+     *\n+     * @param coll  the collection whose elements to add, may not be null\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public BoundedFifoBuffer(Collection coll) {\n+        this(coll.size());\n+        addAll(coll);\n+    }\n+\n+    /**\n+     * Returns the number of elements stored in the buffer.\n+     *\n+     * @return this buffer's size\n+     */\n+    public int size() {\n+        int size = 0;\n+\n+        if (m_end < m_start) {\n+            size = maxElements - m_start + m_end;\n+        } else if (m_end == m_start) {\n+            size = (m_full ? maxElements : 0);\n+        } else {\n+            size = m_end - m_start;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if this buffer is empty; false otherwise.\n+     *\n+     * @return true if this buffer is empty\n+     */\n+    public boolean isEmpty() {\n+        return size() == 0;\n+    }\n+\n+    /**\n+     * Returns true if this collection is full and no new elements can be added.\n+     *\n+     * @return <code>true</code> if the collection is full\n+     */\n+    public boolean isFull() {\n+        return size() == maxElements;\n+    }\n+    \n+    /**\n+     * Gets the maximum size of the collection (the bound).\n+     *\n+     * @return the maximum number of elements the collection can hold\n+     */\n+    public int maxSize() {\n+        return maxElements;\n+    }\n+    \n+    /**\n+     * Clears this buffer.\n+     */\n+    public void clear() {\n+        m_full = false;\n+        m_start = 0;\n+        m_end = 0;\n+        Arrays.fill(m_elements, null);\n+    }\n+\n+    /**\n+     * Adds the given element to this buffer.\n+     *\n+     * @param element  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     * @throws BufferOverflowException  if this buffer is full\n+     */\n+    public boolean add(Object element) {\n+        if (null == element) {\n+            throw new NullPointerException(\"Attempted to add null object to buffer\");\n+        }\n+\n+        if (m_full) {\n+            throw new BufferOverflowException(\"The buffer cannot hold more than \" + maxElements + \" objects.\");\n+        }\n+\n+        m_elements[m_end++] = element;\n+\n+        if (m_end >= maxElements) {\n+            m_end = 0;\n+        }\n+\n+        if (m_end == m_start) {\n+            m_full = true;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the least recently inserted element in this buffer.\n+     *\n+     * @return the least recently inserted element\n+     * @throws BufferUnderflowException  if the buffer is empty\n+     */\n+    public Object get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        return m_elements[m_start];\n+    }\n+\n+    /**\n+     * Removes the least recently inserted element from this buffer.\n+     *\n+     * @return the least recently inserted element\n+     * @throws BufferUnderflowException  if the buffer is empty\n+     */\n+    public Object remove() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        Object element = m_elements[m_start];\n+\n+        if (null != element) {\n+            m_elements[m_start++] = null;\n+\n+            if (m_start >= maxElements) {\n+                m_start = 0;\n+            }\n+\n+            m_full = false;\n+        }\n+\n+        return element;\n+    }\n+\n+    /**\n+     * Increments the internal index.\n+     * \n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n+    private int increment(int index) {\n+        index++; \n+        if (index >= maxElements) {\n+            index = 0;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Decrements the internal index.\n+     * \n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) {\n+            index = maxElements - 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Returns an iterator over this buffer's elements.\n+     *\n+     * @return an iterator over this buffer's elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator() {\n+\n+            private int index = m_start;\n+            private int lastReturnedIndex = -1;\n+            private boolean isFirst = m_full;\n+\n+            public boolean hasNext() {\n+                return isFirst || (index != m_end);\n+                \n+            }\n+\n+            public Object next() {\n+                if (!hasNext()) throw new NoSuchElementException();\n+                isFirst = false;\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return m_elements[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1) throw new IllegalStateException();\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == m_start) {\n+                    BoundedFifoBuffer.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                // Other elements require us to shift the subsequent elements\n+                int i = lastReturnedIndex + 1;\n+                while (i != m_end) {\n+                    if (i >= maxElements) {\n+                        m_elements[i - 1] = m_elements[0];\n+                        i = 0;\n+                    } else {\n+                        m_elements[i - 1] = m_elements[i];\n+                        i++;\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                m_end = decrement(m_end);\n+                m_elements[m_end] = null;\n+                m_full = false;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/CircularFifoBuffer.java,v 1.1 2003/11/29 18:04:57 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Collection;\n+\n+/** \n+ * CircularFifoBuffer is a first in first out buffer with a fixed size that\n+ * replaces its oldest element if full.\n+ * <p>\n+ * The removal order of a <code>CircularFifoBuffer</code> is based on the \n+ * insertion order; elements are removed in the same order in which they\n+ * were added.  The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #add(Object)}, {@link #remove()} and {@link #get()} operations\n+ * all perform in constant time.  All other operations perform in linear\n+ * time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <code>CircularFifoBuffer</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new CircularFifoBuffer());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:57 $\n+ * \n+ * @author Stefano Fornari\n+ * @author Stephen Colebourne\n+ */\n+public class CircularFifoBuffer extends BoundedFifoBuffer {\n+\n+    /**\n+     * Constructor that creates a buffer with the default size of 32.\n+     */\n+    public CircularFifoBuffer() {\n+        super(32);\n+    }\n+\n+    /**\n+     * Constructor that creates a buffer with the specified size.\n+     * \n+     * @param size  the size of the buffer (cannot be changed)\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    public CircularFifoBuffer(int size) {\n+        super(size);\n+    }\n+\n+    /**\n+     * Constructor that creates a buffer from the specified collection.\n+     * The collection size also sets the buffer size\n+     * \n+     * @param coll  the collection to copy into the buffer, may not be null\n+     * @throws NullPointerException if the collection is null\n+     */\n+    public CircularFifoBuffer(Collection coll) {\n+        super(coll);\n+    }\n+\n+    /**\n+     * If the buffer is full, the least recently added element is discarded so\n+     * that a new element can be inserted.\n+     *\n+     * @param element the element to add\n+     * @return true, always\n+     */\n+    public boolean add(Object element) {\n+        if (isFull()) {\n+            remove();\n+        }\n+        return super.add(element);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/buffer/UnboundedFifoBuffer.java,v 1.1 2003/11/29 18:04:57 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.AbstractCollection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+\n+/**\n+ * UnboundedFifoBuffer is a <strong>very</strong> efficient buffer implementation.\n+ * According to performance testing, it exhibits a constant access time, but it\n+ * also outperforms ArrayList when used for the same purpose.\n+ * <p>\n+ * The removal order of an <code>UnboundedFifoBuffer</code> is based on the insertion\n+ * order; elements are removed in the same order in which they were added.\n+ * The iteration order is the same as the removal order.\n+ * <p>\n+ * The {@link #remove()} and {@link #get()} operations perform in constant time.\n+ * The {@link #add(Object)} operation performs in amortized constant time.  All\n+ * other operations perform in linear time or worse.\n+ * <p>\n+ * Note that this implementation is not synchronized.  The following can be\n+ * used to provide synchronized access to your <code>UnboundedFifoBuffer</code>:\n+ * <pre>\n+ *   Buffer fifo = BufferUtils.synchronizedBuffer(new UnboundedFifoBuffer());\n+ * </pre>\n+ * <p>\n+ * This buffer prevents null objects from being added.\n+ * \n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:57 $\n+ *\n+ * @author Avalon\n+ * @author Federico Barbieri\n+ * @author Berin Loritsch\n+ * @author Paul Jack\n+ * @author Stephen Colebourne\n+ */\n+public class UnboundedFifoBuffer extends AbstractCollection implements Buffer {\n+    \n+    protected Object[] m_buffer;\n+    protected int m_head;\n+    protected int m_tail;\n+\n+    /**\n+     * Constructs an UnboundedFifoBuffer with the default number of elements.\n+     * It is exactly the same as performing the following:\n+     *\n+     * <pre>\n+     *   new UnboundedFifoBuffer(32);\n+     * </pre>\n+     */\n+    public UnboundedFifoBuffer() {\n+        this(32);\n+    }\n+\n+    /**\n+     * Constructs an UnboundedFifoBuffer with the specified number of elements.\n+     * The integer must be a positive integer.\n+     * \n+     * @param initialSize  the initial size of the buffer\n+     * @throws IllegalArgumentException  if the size is less than 1\n+     */\n+    public UnboundedFifoBuffer(int initialSize) {\n+        if (initialSize <= 0) {\n+            throw new IllegalArgumentException(\"The size must be greater than 0\");\n+        }\n+        m_buffer = new Object[initialSize + 1];\n+        m_head = 0;\n+        m_tail = 0;\n+    }\n+\n+    /**\n+     * Returns the number of elements stored in the buffer.\n+     *\n+     * @return this buffer's size\n+     */\n+    public int size() {\n+        int size = 0;\n+\n+        if (m_tail < m_head) {\n+            size = m_buffer.length - m_head + m_tail;\n+        } else {\n+            size = m_tail - m_head;\n+        }\n+\n+        return size;\n+    }\n+\n+    /**\n+     * Returns true if this buffer is empty; false otherwise.\n+     *\n+     * @return true if this buffer is empty\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    /**\n+     * Adds the given element to this buffer.\n+     *\n+     * @param obj  the element to add\n+     * @return true, always\n+     * @throws NullPointerException  if the given element is null\n+     * @throws BufferOverflowException  if this buffer is full\n+     */\n+    public boolean add(final Object obj) {\n+        if (obj == null) {\n+            throw new NullPointerException(\"Attempted to add null object to buffer\");\n+        }\n+\n+        if (size() + 1 >= m_buffer.length) {\n+            Object[] tmp = new Object[((m_buffer.length - 1) * 2) + 1];\n+\n+            int j = 0;\n+            for (int i = m_head; i != m_tail;) {\n+                tmp[j] = m_buffer[i];\n+                m_buffer[i] = null;\n+\n+                j++;\n+                i++;\n+                if (i == m_buffer.length) {\n+                    i = 0;\n+                }\n+            }\n+\n+            m_buffer = tmp;\n+            m_head = 0;\n+            m_tail = j;\n+        }\n+\n+        m_buffer[m_tail] = obj;\n+        m_tail++;\n+        if (m_tail >= m_buffer.length) {\n+            m_tail = 0;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns the next object in the buffer.\n+     *\n+     * @return the next object in the buffer\n+     * @throws BufferUnderflowException  if this buffer is empty\n+     */\n+    public Object get() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        return m_buffer[m_head];\n+    }\n+\n+    /**\n+     * Removes the next object from the buffer\n+     *\n+     * @return the removed object\n+     * @throws BufferUnderflowException  if this buffer is empty\n+     */\n+    public Object remove() {\n+        if (isEmpty()) {\n+            throw new BufferUnderflowException(\"The buffer is already empty\");\n+        }\n+\n+        Object element = m_buffer[m_head];\n+\n+        if (null != element) {\n+            m_buffer[m_head] = null;\n+\n+            m_head++;\n+            if (m_head >= m_buffer.length) {\n+                m_head = 0;\n+            }\n+        }\n+\n+        return element;\n+    }\n+\n+    /**\n+     * Increments the internal index.\n+     * \n+     * @param index  the index to increment\n+     * @return the updated index\n+     */\n+    private int increment(int index) {\n+        index++;\n+        if (index >= m_buffer.length) {\n+            index = 0;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Decrements the internal index.\n+     * \n+     * @param index  the index to decrement\n+     * @return the updated index\n+     */\n+    private int decrement(int index) {\n+        index--;\n+        if (index < 0) {\n+            index = m_buffer.length - 1;\n+        }\n+        return index;\n+    }\n+\n+    /**\n+     * Returns an iterator over this buffer's elements.\n+     *\n+     * @return an iterator over this buffer's elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator() {\n+\n+            private int index = m_head;\n+            private int lastReturnedIndex = -1;\n+\n+            public boolean hasNext() {\n+                return index != m_tail;\n+\n+            }\n+\n+            public Object next() {\n+                if (!hasNext())\n+                    throw new NoSuchElementException();\n+                lastReturnedIndex = index;\n+                index = increment(index);\n+                return m_buffer[lastReturnedIndex];\n+            }\n+\n+            public void remove() {\n+                if (lastReturnedIndex == -1)\n+                    throw new IllegalStateException();\n+\n+                // First element can be removed quickly\n+                if (lastReturnedIndex == m_head) {\n+                    UnboundedFifoBuffer.this.remove();\n+                    lastReturnedIndex = -1;\n+                    return;\n+                }\n+\n+                // Other elements require us to shift the subsequent elements\n+                int i = lastReturnedIndex + 1;\n+                while (i != m_tail) {\n+                    if (i >= m_buffer.length) {\n+                        m_buffer[i - 1] = m_buffer[0];\n+                        i = 0;\n+                    } else {\n+                        m_buffer[i - 1] = m_buffer[i];\n+                        i++;\n+                    }\n+                }\n+\n+                lastReturnedIndex = -1;\n+                m_tail = decrement(m_tail);\n+                m_buffer[m_tail] = null;\n+                index = decrement(index);\n+            }\n+\n+        };\n+    }\n+    \n+}\n--- a/src/test/org/apache/commons/collections/buffer/TestAll.java\n+++ b/src/test/org/apache/commons/collections/buffer/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestAll.java,v 1.1 2003/11/16 00:05:46 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestAll.java,v 1.2 2003/11/29 18:04:56 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.1 $ $Date: 2003/11/16 00:05:46 $\n+ * @version $Revision: 1.2 $ $Date: 2003/11/29 18:04:56 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n+        suite.addTest(TestBinaryHeap.suite());\n         suite.addTest(TestBlockingBuffer.suite());\n+        suite.addTest(TestBoundedFifoBuffer.suite());\n+        suite.addTest(TestBoundedFifoBuffer2.suite());\n+        suite.addTest(TestCircularFifoBuffer.suite());\n         suite.addTest(TestPredicatedBuffer.suite());\n         suite.addTest(TestTransformedBuffer.suite());\n+        suite.addTest(TestUnboundedFifoBuffer.suite());\n         \n         return suite;\n     }\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestBinaryHeap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/Attic/TestBinaryHeap.java,v 1.1 2003/11/29 18:04:56 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.NoSuchElementException;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.ComparatorUtils;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.comparators.ComparableComparator;\n+import org.apache.commons.collections.comparators.ReverseComparator;\n+\n+/**\n+ * Tests the BinaryHeap.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:56 $\n+ * \n+ * @author Michael A. Smith\n+ */\n+public class TestBinaryHeap extends AbstractTestCollection {\n+\n+    public static Test suite() {\n+        return new TestSuite(TestBinaryHeap.class);\n+    }\n+\n+    public TestBinaryHeap(String testName) {\n+        super(testName);\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public void verify() {\n+        super.verify();\n+        BinaryHeap heap = (BinaryHeap) collection;\n+\n+        Comparator c = heap.m_comparator;\n+        if (c == null)\n+            c = ComparatorUtils.naturalComparator();\n+        if (!heap.m_isMinHeap)\n+            c = ComparatorUtils.reversedComparator(c);\n+\n+        Object[] tree = heap.m_elements;\n+        for (int i = 1; i <= heap.m_size; i++) {\n+            Object parent = tree[i];\n+            if (i * 2 <= heap.m_size) {\n+                assertTrue(\"Parent is less than or equal to its left child\", c.compare(parent, tree[i * 2]) <= 0);\n+            }\n+            if (i * 2 + 1 < heap.m_size) {\n+                assertTrue(\"Parent is less than or equal to its right child\", c.compare(parent, tree[i * 2 + 1]) <= 0);\n+            }\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    public Collection makeConfirmedFullCollection() {\n+        ArrayList list = new ArrayList();\n+        list.addAll(Arrays.asList(getFullElements()));\n+        return list;\n+    }\n+\n+    /**\n+     * Return a new, empty {@link Object} to used for testing.\n+     */\n+    public Collection makeCollection() {\n+        return new BinaryHeap();\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public Object[] getFullElements() {\n+        return getFullNonNullStringElements();\n+    }\n+\n+    public Object[] getOtherElements() {\n+        return getOtherNonNullStringElements();\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    public void testBasicOps() {\n+        BinaryHeap heap = new BinaryHeap();\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        heap.insert(\"a\");\n+        heap.insert(\"c\");\n+        heap.insert(\"e\");\n+        heap.insert(\"b\");\n+        heap.insert(\"d\");\n+        heap.insert(\"n\");\n+        heap.insert(\"m\");\n+        heap.insert(\"l\");\n+        heap.insert(\"k\");\n+        heap.insert(\"j\");\n+        heap.insert(\"i\");\n+        heap.insert(\"h\");\n+        heap.insert(\"g\");\n+        heap.insert(\"f\");\n+\n+        assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+            assertEquals(\n+                \"peek using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.peek());\n+\n+            assertEquals(\n+                \"pop using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('a' + i)),\n+                heap.pop());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are popped\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are popped\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+    public void testBasicComparatorOps() {\n+        BinaryHeap heap = new BinaryHeap(new ReverseComparator(new ComparableComparator()));\n+\n+        assertTrue(\"heap should be empty after create\", heap.isEmpty());\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called before any elements are inserted\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        heap.insert(\"a\");\n+        heap.insert(\"c\");\n+        heap.insert(\"e\");\n+        heap.insert(\"b\");\n+        heap.insert(\"d\");\n+        heap.insert(\"n\");\n+        heap.insert(\"m\");\n+        heap.insert(\"l\");\n+        heap.insert(\"k\");\n+        heap.insert(\"j\");\n+        heap.insert(\"i\");\n+        heap.insert(\"h\");\n+        heap.insert(\"g\");\n+        heap.insert(\"f\");\n+\n+        assertTrue(\"heap should not be empty after inserts\", !heap.isEmpty());\n+\n+        for (int i = 0; i < 14; i++) {\n+\n+            // note: since we're using a comparator that reverses items, the\n+            // \"minimum\" item is \"n\", and the \"maximum\" item is \"a\".\n+\n+            assertEquals(\n+                \"peek using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.peek());\n+\n+            assertEquals(\n+                \"pop using default constructor should return minimum value in the binary heap\",\n+                String.valueOf((char) ('n' - i)),\n+                heap.pop());\n+\n+            if (i + 1 < 14) {\n+                assertTrue(\"heap should not be empty before all elements are popped\", !heap.isEmpty());\n+            } else {\n+                assertTrue(\"heap should be empty after all elements are popped\", heap.isEmpty());\n+            }\n+        }\n+\n+        try {\n+            heap.peek();\n+            fail(\"NoSuchElementException should be thrown if peek is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+\n+        try {\n+            heap.pop();\n+            fail(\"NoSuchElementException should be thrown if pop is called after all elements are popped\");\n+        } catch (NoSuchElementException e) {\n+            // expected\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer.java,v 1.1 2003/11/29 18:04:56 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Test cases for BoundedFifoBuffer.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:56 $\n+ * \n+ * @author Paul Jack\n+ */\n+public class TestBoundedFifoBuffer extends AbstractTestCollection {\n+\n+    public TestBoundedFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBoundedFifoBuffer.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that \n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    public void verify() {\n+        super.verify();\n+        Iterator iterator1 = collection.iterator();\n+        Iterator iterator2 = confirmed.iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    public Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty BoundedFifoBuffer that won't overflow.  \n+     *  \n+     *  @return an empty BoundedFifoBuffer\n+     */\n+    public Collection makeCollection() {\n+        return new BoundedFifoBuffer(100);\n+    }\n+\n+    //-----------------------------------------------------------------------  \n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testBoundedFifoBufferRemove() {\n+        resetFull();\n+        int size = confirmed.size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = ((BoundedFifoBuffer)collection).remove();\n+            Object o2 = ((ArrayList)confirmed).remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            ((BoundedFifoBuffer)collection).remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new BoundedFifoBuffer(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new BoundedFifoBuffer(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new BoundedFifoBuffer(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer2.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestBoundedFifoBuffer2.java,v 1.1 2003/11/29 18:04:56 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BufferOverflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.BoundedCollection;\n+\n+/**\n+ * Runs tests against a full BoundedFifoBuffer, since many of the algorithms\n+ * differ depending on whether the fifo is full or not.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:56 $\n+ * \n+ * @author Unknown\n+ */\n+public class TestBoundedFifoBuffer2 extends TestBoundedFifoBuffer {\n+\n+    public TestBoundedFifoBuffer2(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBoundedFifoBuffer2.class);\n+    }\n+\n+    /**\n+     *  Returns a BoundedFifoBuffer that's filled to capacity.\n+     *  Any attempt to add to the returned buffer will result in a \n+     *  BufferOverflowException.\n+     *\n+     *  @return a full BoundedFifoBuffer\n+     */\n+    public Collection makeFullCollection() {\n+        return new BoundedFifoBuffer(Arrays.asList(getFullElements()));\n+    }\n+\n+\n+    /**\n+     *  Overridden to skip the add tests.  All of them would fail with a \n+     *  BufferOverflowException.\n+     *\n+     *  @return false\n+     */\n+    public boolean isAddSupported() {\n+        return false;\n+    }\n+\n+\n+    /**\n+     *  Overridden because the add operations raise BufferOverflowException\n+     *  instead of UnsupportedOperationException.\n+     */\n+    public void testUnsupportedAdd() {\n+    }\n+\n+\n+    /**\n+     *  Tests to make sure the add operations raise BufferOverflowException.\n+     */\n+    public void testBufferOverflow() {\n+        resetFull();\n+        try {\n+            collection.add(getOtherElements()[0]);\n+            fail(\"add should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+\n+        try {\n+            collection.addAll(Arrays.asList(getOtherElements()));\n+            fail(\"addAll should raise BufferOverflow.\");\n+        } catch (BufferOverflowException e) {\n+            // expected\n+        }\n+        verify();\n+    }\n+\n+    /**\n+     * Tests is full\n+     */\n+    public void testIsFull() {\n+        resetFull();\n+        assertEquals(true, ((BoundedCollection) collection).isFull());\n+        ((BoundedFifoBuffer) collection).remove();\n+        assertEquals(false, ((BoundedCollection) collection).isFull());\n+        ((BoundedFifoBuffer) collection).add(\"jj\");\n+        assertEquals(true, ((BoundedCollection) collection).isFull());\n+    }\n+\n+    /**\n+     * Tests max size\n+     */\n+    public void testMaxSize() {\n+        resetFull();\n+        assertEquals(getFullElements().length, ((BoundedCollection) collection).maxSize());\n+        ((BoundedFifoBuffer) collection).remove();\n+        assertEquals(getFullElements().length, ((BoundedCollection) collection).maxSize());\n+        ((BoundedFifoBuffer) collection).add(\"jj\");\n+        assertEquals(getFullElements().length, ((BoundedCollection) collection).maxSize());\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestCircularFifoBuffer.java,v 1.1 2003/11/29 18:04:56 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Test cases for CircularFifoBuffer.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:56 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public class TestCircularFifoBuffer extends AbstractTestCollection {\n+\n+    public TestCircularFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestCircularFifoBuffer.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Runs through the regular verifications, but also verifies that \n+     *  the buffer contains the same elements in the same sequence as the\n+     *  list.\n+     */\n+    public void verify() {\n+        super.verify();\n+        Iterator iterator1 = collection.iterator();\n+        Iterator iterator2 = confirmed.iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Returns an empty ArrayList.\n+     *\n+     * @return an empty ArrayList\n+     */\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    /**\n+     * Returns a full ArrayList.\n+     *\n+     * @return a full ArrayList\n+     */\n+    public Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     * Returns an empty BoundedFifoBuffer that won't overflow.  \n+     *  \n+     * @return an empty BoundedFifoBuffer\n+     */\n+    public Collection makeCollection() {\n+        return new CircularFifoBuffer(100);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testCircularFifoBufferCircular() {\n+        List list = new ArrayList();\n+        list.add(\"A\");\n+        list.add(\"B\");\n+        list.add(\"C\");\n+        Buffer buf = new CircularFifoBuffer(list);\n+        \n+        assertEquals(true, buf.contains(\"A\"));\n+        assertEquals(true, buf.contains(\"B\"));\n+        assertEquals(true, buf.contains(\"C\"));\n+        \n+        buf.add(\"D\");\n+        \n+        assertEquals(false, buf.contains(\"A\"));\n+        assertEquals(true, buf.contains(\"B\"));\n+        assertEquals(true, buf.contains(\"C\"));\n+        assertEquals(true, buf.contains(\"D\"));\n+        \n+        assertEquals(\"B\", buf.get());\n+        assertEquals(\"B\", buf.remove());\n+        assertEquals(\"C\", buf.remove());\n+        assertEquals(\"D\", buf.remove());\n+    }\n+\n+    /**\n+     * Tests that the removal operation actually removes the first element.\n+     */\n+    public void testCircularFifoBufferRemove() {\n+        resetFull();\n+        int size = confirmed.size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = ((CircularFifoBuffer) collection).remove();\n+            Object o2 = ((ArrayList) confirmed).remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+\n+        try {\n+            ((CircularFifoBuffer) collection).remove();\n+            fail(\"Empty buffer should raise Underflow.\");\n+        } catch (BufferUnderflowException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new CircularFifoBuffer(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new CircularFifoBuffer(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException3() {\n+        try {\n+            new CircularFifoBuffer(null);\n+        } catch (NullPointerException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/buffer/TestUnboundedFifoBuffer.java,v 1.1 2003/11/29 18:04:56 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.buffer;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.collection.AbstractTestCollection;\n+\n+/**\n+ * Test cases for UnboundedFifoBuffer.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/11/29 18:04:56 $\n+ * \n+ * @author Unknown\n+ */\n+public class TestUnboundedFifoBuffer extends AbstractTestCollection {\n+\n+    public TestUnboundedFifoBuffer(String n) {\n+        super(n);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestUnboundedFifoBuffer.class);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Verifies that the ArrayList has the same elements in the same \n+     *  sequence as the UnboundedFifoBuffer.\n+     */\n+    public void verify() {\n+        super.verify();\n+        Iterator iterator1 = collection.iterator();\n+        Iterator iterator2 = confirmed.iterator();\n+        while (iterator2.hasNext()) {\n+            assertTrue(iterator1.hasNext());\n+            Object o1 = iterator1.next();\n+            Object o2 = iterator2.next();\n+            assertEquals(o1, o2);\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Overridden because UnboundedFifoBuffer doesn't allow null elements.\n+     * @return false\n+     */\n+    public boolean isNullSupported() {\n+        return false;\n+    }\n+\n+    /**\n+     * Overridden because UnboundedFifoBuffer isn't fail fast.\n+     * @return false\n+     */\n+    public boolean isFailFastSupported() {\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Returns an empty ArrayList.\n+     *\n+     *  @return an empty ArrayList\n+     */\n+    public Collection makeConfirmedCollection() {\n+        return new ArrayList();\n+    }\n+\n+    /**\n+     *  Returns a full ArrayList.\n+     *\n+     *  @return a full ArrayList\n+     */\n+    public Collection makeConfirmedFullCollection() {\n+        Collection c = makeConfirmedCollection();\n+        c.addAll(java.util.Arrays.asList(getFullElements()));\n+        return c;\n+    }\n+\n+    /**\n+     *  Returns an empty UnboundedFifoBuffer with a small capacity.\n+     *\n+     *  @return an empty UnboundedFifoBuffer\n+     */\n+    public Collection makeCollection() {\n+        return new UnboundedFifoBuffer(5);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests that UnboundedFifoBuffer removes elements in the right order.\n+     */\n+    public void testUnboundedFifoBufferRemove() {\n+        resetFull();\n+        int size = confirmed.size();\n+        for (int i = 0; i < size; i++) {\n+            Object o1 = ((UnboundedFifoBuffer)collection).remove();\n+            Object o2 = ((ArrayList)confirmed).remove(0);\n+            assertEquals(\"Removed objects should be equal\", o1, o2);\n+            verify();\n+        }\n+    }\n+\n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException1() {\n+        try {\n+            new UnboundedFifoBuffer(0);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+    \n+    /**\n+     * Tests that the constructor correctly throws an exception.\n+     */\n+    public void testConstructorException2() {\n+        try {\n+            new UnboundedFifoBuffer(-20);\n+        } catch (IllegalArgumentException ex) {\n+            return;\n+        }\n+        fail();\n+    }\n+}\n+", "timestamp": 1070129097, "metainfo": ""}