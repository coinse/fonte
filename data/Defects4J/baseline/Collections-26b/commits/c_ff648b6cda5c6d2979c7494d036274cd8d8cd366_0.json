{"sha": "ff648b6cda5c6d2979c7494d036274cd8d8cd366", "log": "Remove decorator inner classes. Transfer static method calls to use new decorators package.   ", "commit": "\n--- a/src/java/org/apache/commons/collections/BagUtils.java\n+++ b/src/java/org/apache/commons/collections/BagUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BagUtils.java,v 1.9 2003/04/04 22:22:29 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BagUtils.java,v 1.10 2003/05/09 18:41:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  */\n package org.apache.commons.collections;\n \n-import java.util.Comparator;\n-import java.util.Set;\n+import org.apache.commons.collections.decorators.PredicatedBag;\n+import org.apache.commons.collections.decorators.PredicatedSortedBag;\n+import org.apache.commons.collections.decorators.SynchronizedBag;\n+import org.apache.commons.collections.decorators.SynchronizedSortedBag;\n+import org.apache.commons.collections.decorators.TypedBag;\n+import org.apache.commons.collections.decorators.TypedSortedBag;\n+import org.apache.commons.collections.decorators.UnmodifiableBag;\n+import org.apache.commons.collections.decorators.UnmodifiableSortedBag;\n \n /**\n  * Provides utility methods and decorators for {@link Bag} \n  * and {@link SortedBag} instances.\n  *\n  * @since Commons Collections 2.1\n- * @version $Revision: 1.9 $ $Date: 2003/04/04 22:22:29 $\n+ * @version $Revision: 1.10 $ $Date: 2003/05/09 18:41:34 $\n  * \n  * @author Paul Jack\n  * @author Stephen Colebourne\n public class BagUtils {\n \n     /**\n+     * An empty unmodifiable bag.\n+     */\n+    public static final Bag EMPTY_BAG = UnmodifiableBag.decorate(new HashBag());\n+\n+    /**\n+     * An empty unmodifiable sorted bag.\n+     */\n+    public static final Bag EMPTY_SORTED_BAG = UnmodifiableSortedBag.decorate(new TreeBag());\n+\n+    /**\n      * Instantiation of BagUtils is not intended or required.\n      * However, some tools require an instance to operate.\n      */\n     public BagUtils() {\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Implementation of a Bag that validates elements before they are added.\n-     */\n-    static class PredicatedBag \n-            extends CollectionUtils.PredicatedCollection \n-            implements Bag {\n-\n-        public PredicatedBag(Bag b, Predicate p) {\n-            super(b, p);\n-        }\n-\n-        public boolean add(Object o, int count) {\n-            validate(o);\n-            return getBag().add(o, count);\n-        }\n-\n-        public boolean remove(Object o, int count) {\n-            return getBag().remove(o, count);\n-        }\n-\n-        public Set uniqueSet() {\n-            return getBag().uniqueSet();\n-        }\n-\n-        public int getCount(Object o) {\n-            return getBag().getCount(o);\n-        }\n-\n-        private Bag getBag() {\n-            return (Bag) collection;\n-        }\n-    }\n-\n-\n-    /**\n-     * Implementation of a Bag that is synchronized.\n-     */\n-    static class SynchronizedBag\n-            extends CollectionUtils.SynchronizedCollection\n-            implements Bag {\n-\n-        public SynchronizedBag(Bag bag) {\n-            super(bag);\n-        }\n-\n-        public synchronized boolean add(Object o, int count) {\n-            return getBag().add(o, count);\n-        }\n-\n-        public synchronized boolean remove(Object o, int count) {\n-            return getBag().remove(o, count);\n-        }\n-\n-        public synchronized Set uniqueSet() {\n-            return getBag().uniqueSet();\n-        }\n-\n-        public synchronized int getCount(Object o) {\n-            return getBag().getCount(o);\n-        }\n-\n-        private Bag getBag() {\n-            return (Bag) collection;\n-        }\n-    }\n-\n-\n-    /**\n-     * Implementation of a Bag that is unmodifiable.\n-     */\n-    static class UnmodifiableBag \n-            extends CollectionUtils.UnmodifiableCollection\n-            implements Bag {\n-\n-        public UnmodifiableBag(Bag bag) {\n-            super(bag);\n-        }\n-\n-        public boolean add(Object o, int count) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public boolean remove(Object o, int count) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public Set uniqueSet() {\n-            return getBag().uniqueSet();\n-        }\n-\n-        public int getCount(Object o) {\n-            return getBag().getCount(o);\n-        }\n-        \n-        private Bag getBag() {\n-            return (Bag) collection;\n-        }\n-    }\n-\n-\n-    /**\n-     * Implementation of a SortedBag that validates elements before they are added.\n-     */\n-    static class PredicatedSortedBag \n-            extends PredicatedBag \n-            implements SortedBag {\n-\n-        public PredicatedSortedBag(SortedBag sb, Predicate p) {\n-            super(sb, p);\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedBag().comparator();\n-        }\n-\n-        public Object first() {\n-            return getSortedBag().first();\n-        }\n-\n-        public Object last() {\n-            return getSortedBag().last();\n-        }\n-\n-        private SortedBag getSortedBag() {\n-            return (SortedBag) collection;\n-        }\n-    }\n-\n-\n-    /**\n-     * Implementation of a SortedBag that is synchronized.\n-     */\n-    static class SynchronizedSortedBag \n-            extends SynchronizedBag\n-            implements SortedBag {\n-\n-        public SynchronizedSortedBag(SortedBag bag) {\n-            super(bag);\n-        }\n-\n-        public synchronized Comparator comparator() {\n-            return getSortedBag().comparator();\n-        }\n-\n-        public synchronized Object first() {\n-            return getSortedBag().first();\n-        }\n-\n-        public synchronized Object last() {\n-            return getSortedBag().last();\n-        }\n-\n-        private SortedBag getSortedBag() {\n-            return (SortedBag) collection;\n-        }\n-    }\n-\n-\n-    /**\n-     * Implementation of a SortedBag that is unmodifiable.\n-     */\n-    static class UnmodifiableSortedBag\n-            extends UnmodifiableBag\n-            implements SortedBag {\n-\n-        public UnmodifiableSortedBag(SortedBag bag) {\n-            super(bag);\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedBag().comparator();\n-        }\n-\n-        public Object first() {\n-            return getSortedBag().first();\n-        }\n-\n-        public Object last() {\n-            return getSortedBag().last();\n-        }\n-\n-        private SortedBag getSortedBag() {\n-            return (SortedBag) collection;\n-        }\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException  if the Bag is null\n      */\n     public static Bag synchronizedBag(Bag bag) {\n-        return new SynchronizedBag(bag);\n+        return SynchronizedBag.decorate(bag);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Bag is null\n      */\n     public static Bag unmodifiableBag(Bag bag) {\n-        return new UnmodifiableBag(bag);\n+        return UnmodifiableBag.decorate(bag);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the Bag or Predicate is null\n      */\n     public static Bag predicatedBag(Bag bag, Predicate predicate) {\n-        return new PredicatedBag(bag, predicate);\n+        return PredicatedBag.decorate(bag, predicate);\n     }\n \n     /**\n      * @return a typed bag backed by the specified bag\n      */\n     public static Bag typedBag(Bag bag, Class type) {\n-        return predicatedBag(bag, new CollectionUtils.InstanceofPredicate(type));\n+        return TypedBag.decorate(bag, type);\n     }\n     \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException  if the SortedBag is null\n      */\n     public static SortedBag synchronizedSortedBag(SortedBag bag) {\n-        return new SynchronizedSortedBag(bag);\n+        return SynchronizedSortedBag.decorate(bag);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the SortedBag is null\n      */\n     public static SortedBag unmodifiableSortedBag(SortedBag bag) {\n-        return new UnmodifiableSortedBag(bag);\n+        return UnmodifiableSortedBag.decorate(bag);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the SortedBag or Predicate is null\n      */\n     public static SortedBag predicatedSortedBag(SortedBag bag, Predicate predicate) {\n-        return new PredicatedSortedBag(bag, predicate);\n+        return PredicatedSortedBag.decorate(bag, predicate);\n     }\n     \n     /**\n      * @return a typed bag backed by the specified bag\n      */\n     public static SortedBag typedSortedBag(SortedBag bag, Class type) {\n-        return predicatedSortedBag(bag, new CollectionUtils.InstanceofPredicate(type));\n+        return TypedSortedBag.decorate(bag, type);\n     }\n         \n }\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUtils.java,v 1.10 2002/12/15 13:05:03 scolebourne Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/12/15 13:05:03 $\n- *\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUtils.java,v 1.11 2003/05/09 18:41:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n  */\n package org.apache.commons.collections;\n \n-import java.util.Collection;\n+import org.apache.commons.collections.decorators.BlockingBuffer;\n+import org.apache.commons.collections.decorators.PredicatedBuffer;\n+import org.apache.commons.collections.decorators.SynchronizedBuffer;\n+import org.apache.commons.collections.decorators.TypedBuffer;\n+import org.apache.commons.collections.decorators.UnmodifiableBuffer;\n+\n /**\n  * Contains static utility methods for operating on {@link Buffer} objects.\n  *\n+ * @since Commons Collections 2.1\n+ * @version $Revision: 1.11 $ $Date: 2003/05/09 18:41:34 $\n+ * \n  * @author Paul Jack\n  * @author Stephen Colebourne\n- * @version $Id: BufferUtils.java,v 1.10 2002/12/15 13:05:03 scolebourne Exp $\n- * @since 2.1\n  */\n public class BufferUtils {\n \n     /**\n      * An empty unmodifiable buffer.\n      */\n-    public static final Buffer EMPTY_BUFFER = BufferUtils.unmodifiableBuffer(new ArrayStack());\n+    public static final Buffer EMPTY_BUFFER = UnmodifiableBuffer.decorate(new ArrayStack());\n     \n     /**\n      * <code>BufferUtils</code> should not normally be instantiated.\n      * @return a synchronized buffer backed by that buffer\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n-    public static Buffer synchronizedBuffer(final Buffer buffer) {\n-        return new SynchronizedBuffer(buffer);\n+    public static Buffer synchronizedBuffer(Buffer buffer) {\n+        return SynchronizedBuffer.decorate(buffer);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n     public static Buffer blockingBuffer(Buffer buffer) {\n-        return new SynchronizedBuffer(buffer) {\n-\n-            public synchronized boolean add(Object o) {\n-                boolean r = collection.add(o);\n-                notify();\n-                return r;\n-            }\n-\n-            public synchronized boolean addAll(Collection c) {\n-                boolean r = collection.addAll(c);\n-                notifyAll();\n-                return r;\n-            }\n-\n-            public synchronized Object get() {\n-                while (collection.isEmpty()) {\n-                    try {\n-                        wait();\n-                    } catch (InterruptedException e) {\n-                        throw new BufferUnderflowException();\n-                    }\n-                }\n-                return ((Buffer)collection).get();\n-            }\n-\n-            public synchronized Object remove() {\n-                while (collection.isEmpty()) {\n-                    try {\n-                        wait();\n-                    } catch (InterruptedException e) {\n-                        throw new BufferUnderflowException();\n-                    }\n-                }\n-                return ((Buffer)collection).remove();\n-            }\n-        };\n+        return BlockingBuffer.decorate(buffer);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Buffer is null\n      */\n     public static Buffer unmodifiableBuffer(Buffer buffer) {\n-        return new UnmodifiableBuffer(buffer);\n+        return UnmodifiableBuffer.decorate(buffer);\n     }\n \n     /**\n      * @return a predicated buffer\n      * @throws IllegalArgumentException  if the Buffer or Predicate is null\n      */\n-    public static Buffer predicatedBuffer(Buffer buffer, final Predicate predicate) {\n-        return new PredicatedBuffer(buffer, predicate);\n+    public static Buffer predicatedBuffer(Buffer buffer, Predicate predicate) {\n+        return PredicatedBuffer.decorate(buffer, predicate);\n     }\n \n-\n-\n-    static class SynchronizedBuffer \n-            extends CollectionUtils.SynchronizedCollection\n-            implements Buffer {\n-\n-        public SynchronizedBuffer(Buffer b) {\n-            super(b);\n-        }\n-\n-        public synchronized Object get() {\n-            return ((Buffer)collection).get();\n-        }\n-\n-        public synchronized Object remove() {\n-            return ((Buffer)collection).remove();\n-        }        \n+    /**\n+     * Returns a typed buffer backed by the given buffer.\n+     * <p>\n+     * Only elements of the specified type can be added to the buffer.\n+     *\n+     * @param buffer  the buffer to predicate, must not be null\n+     * @param type  the type to allow into the buffer, must not be null\n+     * @return a typed buffer\n+     * @throws IllegalArgumentException  if the buffer or type is null\n+     */\n+    public static Buffer typedBuffer(Buffer buffer, Class type) {\n+        return TypedBuffer.decorate(buffer, type);\n     }\n \n-\n-    static class UnmodifiableBuffer \n-            extends CollectionUtils.UnmodifiableCollection\n-            implements Buffer {\n-\n-        public UnmodifiableBuffer(Buffer b) {\n-            super(b);\n-        }\n-\n-        public Object get() {\n-            return ((Buffer)collection).get();\n-        }\n-\n-        public Object remove() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-    }\n-\n-\n-    static class PredicatedBuffer \n-            extends CollectionUtils.PredicatedCollection\n-            implements Buffer {\n-\n-        public PredicatedBuffer(Buffer b, Predicate p) {\n-            super(b, p);\n-        }\n-\n-        public Object get() {\n-            return ((Buffer)collection).get();\n-        }\n-\n-        public Object remove() {\n-            return ((Buffer)collection).remove();\n-        }\n-\n-    }\n-\n-\n }\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.29 2003/04/04 22:22:29 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.30 2003/05/09 18:41:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections;\n \n-import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.NoSuchElementException;\n import java.util.Set;\n \n+import org.apache.commons.collections.decorators.PredicatedCollection;\n+import org.apache.commons.collections.decorators.TypedCollection;\n+import org.apache.commons.collections.decorators.UnmodifiableBoundedCollection;\n import org.apache.commons.collections.iterators.ArrayIterator;\n import org.apache.commons.collections.iterators.EnumerationIterator;\n \n  * A set of {@link Collection} related utility methods.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.29 $ $Date: 2003/04/04 22:22:29 $\n+ * @version $Revision: 1.30 $ $Date: 2003/05/09 18:41:34 $\n  * \n  * @author Rodney Waldhoff\n  * @author Paul Jack\n      * This method uses the {@link BoundedCollection} class to determine the\n      * full status. If the collection does not implement this interface then\n      * false is returned.\n-     * <p>\n-     * This method handles the synchronized, blocking, unmodifiable \n-     * and predicated decorators.\n      *\n      * @return  true if the Collection is full\n      * @throws NullPointerException if the collection is null\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n-        Collection unwrappedCollection = coll;\n-        \n-        // handle decorators\n-        while (true) {\n-            if (unwrappedCollection instanceof CollectionUtils.CollectionWrapper) {\n-                unwrappedCollection = ((CollectionUtils.CollectionWrapper) unwrappedCollection).collection;\n-            } else if (unwrappedCollection instanceof CollectionUtils.SynchronizedCollection) {\n-                unwrappedCollection = ((CollectionUtils.SynchronizedCollection) unwrappedCollection).collection;\n-            } else {\n-                break;\n-            }\n-        }\n-        \n-        // is it full\n-        if (unwrappedCollection instanceof BoundedCollection) {\n-            return ((BoundedCollection) unwrappedCollection).isFull();\n-        }\n-        return false;\n+        try {\n+            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n+            return bcoll.isFull();\n+            \n+        } catch (IllegalArgumentException ex) {\n+            return false;\n+        }\n     }\n \n     /**\n      * This method uses the {@link BoundedCollection} class to determine the\n      * maximum size. If the collection does not implement this interface then\n      * -1 is returned.\n-     * <p>\n-     * This method handles the synchronized, blocking, unmodifiable \n-     * and predicated decorators.\n      *\n      * @return the maximum size of the Collection, -1 if no maximum size\n      * @throws NullPointerException if the collection is null\n         if (coll == null) {\n             throw new NullPointerException(\"The collection must not be null\");\n         }\n-        Collection unwrappedCollection = coll;\n-        \n-        // handle decorators\n-        while (true) {\n-            if (unwrappedCollection instanceof CollectionUtils.CollectionWrapper) {\n-                unwrappedCollection = ((CollectionUtils.CollectionWrapper) unwrappedCollection).collection;\n-            } else if (unwrappedCollection instanceof CollectionUtils.SynchronizedCollection) {\n-                unwrappedCollection = ((CollectionUtils.SynchronizedCollection) unwrappedCollection).collection;\n-            } else {\n-                break;\n-            }\n-        }\n-        \n-        // get max size\n-        if (unwrappedCollection instanceof BoundedCollection) {\n-            return ((BoundedCollection) unwrappedCollection).maxSize();\n-        }\n-        return -1;\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Base class for collection decorators.  I decided to do it this way\n-     * because it seemed to result in the most reuse.  \n-     * \n-     * Inner class tree looks like:\n-     * <pre>\n-     *       CollectionWrapper\n-     *          PredicatedCollection\n-     *             PredicatedSet\n-     *             PredicatedList\n-     *             PredicatedBag\n-     *             PredicatedBuffer\n-     *          UnmodifiableCollection\n-     *             UnmodifiableBag\n-     *             UnmodifiableBuffer\n-     *          LazyCollection\n-     *             LazyList\n-     *             LazyBag\n-     *       SynchronizedCollection\n-     *          SynchronizedBuffer\n-     *          SynchronizedBag\n-     *          SynchronizedBuffer\n-     * </pre>\n-     */\n-    static class CollectionWrapper \n-            implements Collection {\n-\n-        protected final Collection collection;\n-\n-        public CollectionWrapper(Collection collection) {\n-            if (collection == null) {\n-                throw new IllegalArgumentException(\"Collection must not be null\");\n-            }\n-            this.collection = collection;\n-        }\n-\n-        public int size() {\n-            return collection.size();\n-        }\n-\n-        public boolean isEmpty() {\n-            return collection.isEmpty();\n-        }\n-\n-        public boolean contains(Object o) {\n-            return collection.contains(o);\n-        }\n-\n-        public Iterator iterator() {\n-            return collection.iterator();\n-        }\n-\n-        public Object[] toArray() {\n-            return collection.toArray();\n-        }\n-\n-        public Object[] toArray(Object[] o) {\n-            return collection.toArray(o);\n-        }\n-\n-        public boolean add(Object o) {\n-            return collection.add(o);\n-        }\n-\n-        public boolean remove(Object o) {\n-            return collection.remove(o);\n-        }\n-\n-        public boolean containsAll(Collection c2) {\n-            return collection.containsAll(c2);\n-        }\n-\n-        public boolean addAll(Collection c2) {\n-            return collection.addAll(c2);\n-        }\n-\n-        public boolean removeAll(Collection c2) {\n-            return collection.removeAll(c2);\n-        }\n-\n-        public boolean retainAll(Collection c2) {\n-            return collection.retainAll(c2);\n-        }\n-\n-        public void clear() {\n-            collection.clear();\n-        }\n-\n-        public boolean equals(Object o) {\n-            if (o == this) return true;\n-            return collection.equals(o);\n-        }\n-\n-        public int hashCode() {\n-            return collection.hashCode();\n-        }\n-\n-        public String toString() {\n-            return collection.toString();\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a collection that checks entries.\n-     */\n-    static class PredicatedCollection \n-            extends CollectionWrapper {\n-\n-        protected final Predicate predicate;\n-\n-        public PredicatedCollection(Collection c, Predicate p) {\n-            super(c);\n-            if (p == null) {\n-                throw new IllegalArgumentException(\"Predicate must not be null\");\n-            }\n-            this.predicate = p;\n-            for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n-                validate(iter.next());\n-            }\n-        }\n-\n-        public boolean add(Object o) {\n-            validate(o);\n-            return collection.add(o);\n-        }\n-\n-        public boolean addAll(Collection c2) {\n-            for (Iterator iter = c2.iterator(); iter.hasNext(); ) {\n-                validate(iter.next());\n-            }\n-            return collection.addAll(c2);\n-        }\n-\n-        protected void validate(Object o) {\n-            if (!predicate.evaluate(o)) {\n-                throw new IllegalArgumentException(\"Cannot add Object - Predicate rejected it\");\n-            }\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a collection that is unmodifiable.\n-     */\n-    static class UnmodifiableCollection \n-            extends CollectionWrapper {\n-\n-        public UnmodifiableCollection(Collection c) {\n-            super(c);\n-        }\n-\n-        public boolean add(Object o) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public boolean addAll(Collection c) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public boolean remove(Object o) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public boolean removeAll(Collection c) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public boolean retainAll(Collection c) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void clear() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public Iterator iterator() {\n-            return new IteratorUtils.UnmodifiableIterator(collection.iterator());\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a collection that is synchronized.\n-     */\n-    static class SynchronizedCollection {\n-\n-        protected final Collection collection;\n-\n-        public SynchronizedCollection(Collection collection) {\n-            if (collection == null) {\n-                throw new IllegalArgumentException(\"Collection must not be null\");\n-            }\n-            this.collection = collection;\n-        }\n-\n-        public synchronized int size() {\n-            return collection.size();\n-        }\n-\n-        public synchronized boolean isEmpty() {\n-            return collection.isEmpty();\n-        }\n-\n-        public synchronized boolean contains(Object o) {\n-            return collection.contains(o);\n-        }\n-\n-        public Iterator iterator() {\n-            return collection.iterator();\n-        }\n-\n-        public synchronized Object[] toArray() {\n-            return collection.toArray();\n-        }\n-\n-        public synchronized Object[] toArray(Object[] o) {\n-            return collection.toArray(o);\n-        }\n-\n-        public synchronized boolean add(Object o) {\n-            return collection.add(o);\n-        }\n-\n-        public synchronized boolean remove(Object o) {\n-            return collection.remove(o);\n-        }\n-\n-        public synchronized boolean containsAll(Collection c2) {\n-            return collection.containsAll(c2);\n-        }\n-\n-        public synchronized boolean addAll(Collection c2) {\n-            return collection.addAll(c2);\n-        }\n-\n-        public synchronized boolean removeAll(Collection c2) {\n-            return collection.removeAll(c2);\n-        }\n-\n-        public synchronized boolean retainAll(Collection c2) {\n-            return collection.retainAll(c2);\n-        }\n-\n-        public synchronized void clear() {\n-            collection.clear();\n-        }\n-\n-        public synchronized boolean equals(Object o) {\n-            return collection.equals(o);\n-        }\n-\n-        public synchronized int hashCode() {\n-            return collection.hashCode();\n-        }\n-\n-        public synchronized String toString() {\n-            return collection.toString();\n-        }\n-\n-    }\n-\n-    /**\n-     * <code>Predicate</code> implementation that checks the type of an object.\n-     * This class may eventually be replaced by \n-     * <code>org.apache.commons.lang.functor.PredicateUtils.instanceofPredicate()</code>.\n-     */\n-    static class InstanceofPredicate implements Predicate, Serializable {\n-        private final Class type;\n-\n-        /**\n-         * Constructor\n-         */\n-        public InstanceofPredicate(Class type) {\n-            if (type == null) {\n-                throw new IllegalArgumentException(\"Type must not be null\");\n-            }\n-            this.type = type;\n-        }\n-\n-        /**\n-         * Return true if the object is an instanceof the type of the predicate.\n-         * @param object an <code>Object</code>\n-         * @return <code>true</code> if the object is an instanceof the type of the predicate\n-         */\n-        public boolean evaluate(Object object) {\n-            return type.isInstance(object);\n+        try {\n+            BoundedCollection bcoll = UnmodifiableBoundedCollection.decorateUsing(coll);\n+            return bcoll.maxSize();\n+            \n+        } catch (IllegalArgumentException ex) {\n+            return -1;\n         }\n     }\n \n      * @throws IllegalArgumentException  if the Collection is null\n      */\n     public static Collection predicatedCollection(Collection collection, Predicate predicate) {\n-        return new PredicatedCollection(collection, predicate);\n+        return PredicatedCollection.decorate(collection, predicate);\n     }\n \n     /**\n      * @return a typed collection backed by the specified collection\n      */\n     public static Collection typedCollection(Collection collection, Class type) {\n-        return predicatedCollection(collection, new InstanceofPredicate(type));\n+        return TypedCollection.decorate(collection, type);\n     }\n     \n }\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ListUtils.java,v 1.16 2003/04/09 23:37:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ListUtils.java,v 1.17 2003/05/09 18:41:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.ListIterator;\n+\n+import org.apache.commons.collections.decorators.FixedSizeList;\n+import org.apache.commons.collections.decorators.LazyList;\n+import org.apache.commons.collections.decorators.PredicatedList;\n+import org.apache.commons.collections.decorators.TypedList;\n \n /**\n  * Contains static utility methods and decorators for {@link List} \n  * instances.\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.16 $ $Date: 2003/04/09 23:37:54 $\n+ * @version $Revision: 1.17 $ $Date: 2003/05/09 18:41:34 $\n  * \n  * @author  <a href=\"mailto:fede@apache.org\">Federico Barbieri</a>\n  * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n \n     //-----------------------------------------------------------------------\n     /**\n-     * Implementation of a ListIterator that wraps an original.\n-     */\n-    static class ListIteratorWrapper \n-            implements ListIterator {\n-\n-        final protected ListIterator iterator;\n-\n-        public ListIteratorWrapper(ListIterator iterator) {\n-            this.iterator = iterator;\n-        }\n-\n-        public boolean hasNext() {\n-            return iterator.hasNext();\n-        }\n-\n-        public Object next() {\n-            return iterator.next();\n-        }\n-\n-        public boolean hasPrevious() {\n-            return iterator.hasPrevious();\n-        }\n-\n-        public Object previous() {\n-            return iterator.previous();\n-        }\n-\n-        public int nextIndex() {\n-            return iterator.nextIndex();\n-        }\n-\n-        public int previousIndex() {\n-            return iterator.previousIndex();\n-        }\n-\n-        public void remove() {\n-            iterator.remove();\n-        }\n-\n-        public void set(Object o) {\n-            iterator.set(o);\n-        }\n-\n-        public void add(Object o) {\n-            iterator.add(o);\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a list that checks (predicates) each entry.\n-     */\n-    static class PredicatedList \n-            extends CollectionUtils.PredicatedCollection\n-            implements List {\n-\n-        public PredicatedList(List list, Predicate p) {\n-            super(list, p);\n-        }\n-\n-        public boolean addAll(int i, Collection c) {\n-            for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n-                validate(iter.next());\n-            }\n-            return getList().addAll(i, c);\n-        }\n-\n-        public Object get(int i) {\n-            return getList().get(i);\n-        }\n-\n-        public Object set(int i, Object o) {\n-            validate(o);\n-            return getList().set(i, o);\n-        }\n-\n-        public void add(int i, Object o) {\n-            validate(o);\n-            getList().add(i, o);\n-        }\n-\n-        public Object remove(int i) {\n-            return getList().remove(i);\n-        }\n-\n-        public int indexOf(Object o) {\n-            return getList().indexOf(o);\n-        }\n-\n-        public int lastIndexOf(Object o) {\n-            return getList().lastIndexOf(o);\n-        }\n-\n-        public ListIterator listIterator() {\n-            return listIterator(0);\n-        }\n-\n-        public ListIterator listIterator(int i) {\n-            return new ListIteratorWrapper(getList().listIterator(i)) {\n-                public void add(Object o) {\n-                    validate(o);\n-                    iterator.add(o);\n-                }\n-\n-                public void set(Object o) {\n-                    validate(o);\n-                    iterator.set(o);\n-                }\n-            };\n-        }\n-\n-        public List subList(int i1, int i2) {\n-            List sub = getList().subList(i1, i2);\n-            return new PredicatedList(sub, predicate);\n-        }\n-\n-        private List getList() {\n-            return (List)collection;\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a list that has a fixed size.\n-     */\n-    static class FixedSizeList \n-            extends CollectionUtils.UnmodifiableCollection\n-            implements List {\n-\n-        public FixedSizeList(List list) {\n-            super(list);\n-        }\n-\n-        public boolean addAll(int i, Collection c) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public Object get(int i) {\n-            return getList().get(i);\n-        }\n-\n-        public Object set(int i, Object o) {\n-            return getList().set(i, o);\n-        }\n-\n-        public void add(int i, Object o) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public Object remove(int i) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public int indexOf(Object o) {\n-            return getList().indexOf(o);\n-        }\n-\n-        public int lastIndexOf(Object o) {\n-            return getList().lastIndexOf(o);\n-        }\n-\n-        public ListIterator listIterator() {\n-            return listIterator(0);\n-        }\n-\n-        public ListIterator listIterator(int i) {\n-            return new ListIteratorWrapper(getList().listIterator(i)) {\n-                public void remove() {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                public void add(Object o) {\n-                    throw new UnsupportedOperationException();\n-                }\n-\n-                public void remove(Object o) {\n-                    throw new UnsupportedOperationException();\n-                }\n-            };\n-        }\n-\n-        public List subList(int i1, int i2) {\n-            List sub = getList().subList(i1, i2);\n-            return new FixedSizeList(sub);\n-        }\n-\n-        private List getList() {\n-            return (List)collection;\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a list that creates objects on demand.\n-     */\n-    static class LazyList \n-            extends CollectionUtils.CollectionWrapper \n-            implements List {\n-\n-        protected final Factory factory;\n-\n-        public LazyList(List list, Factory factory) {\n-            super(list);\n-            if (factory == null) {\n-                throw new IllegalArgumentException(\"Factory must not be null\");\n-            }\n-            this.factory = factory;\n-        }\n-\n-        \n-        /* Proxy method to the impl's get method. With the exception that if it's out\n-         * of bounds, then the collection will grow, leaving place-holders in its\n-         * wake, so that an item can be set at any given index. Later the\n-         * place-holders are removed to return to a pure collection.\n-         *\n-         * If there's a place-holder at the index, then it's replaced with a proper\n-         * object to be used.\n-         */\n-        public Object get(int index) {\n-            Object obj;\n-            if (index < (getList().size())) {\n-            /* within bounds, get the object */\n-                obj = getList().get(index);\n-                if (obj == null) {\n-                    /* item is a place holder, create new one, set and return */\n-                    obj = this.factory.create();\n-                    this.getList().set(index, obj);\n-                    return obj;\n-                } else {\n-                    /* good and ready to go */\n-                    return obj;\n-                }\n-            } else {\n-                /* we have to grow the list */\n-                for (int i = getList().size(); i < index; i++) {\n-                    getList().add(null);\n-                }\n-                /* create our last object, set and return */\n-                obj = this.factory.create();\n-                getList().add(obj);\n-                return obj;\n-            }\n-        }\n-\n-\n-        /* proxy the call to the provided list implementation. */\n-        public List subList(int fromIndex, int toIndex) {\n-            /* wrap the returned sublist so it can continue the functionality */\n-            return new LazyList(getList().subList(fromIndex, toIndex), factory);\n-        }\n-\n-        public boolean addAll(int i, Collection c) {\n-            return getList().addAll(i, c);\n-        }\n-\n-        public Object set(int i, Object o) {\n-            return getList().set(i, o);\n-        }\n-\n-        public void add(int i, Object o) {\n-            getList().add(i, o);\n-        }\n-\n-        public Object remove(int i) {\n-            return getList().remove(i);\n-        }\n-\n-        public int indexOf(Object o) {\n-            return getList().indexOf(o);\n-        }\n-\n-        public int lastIndexOf(Object o) {\n-            return getList().lastIndexOf(o);\n-        }\n-\n-        public ListIterator listIterator() {\n-            return getList().listIterator();\n-        }\n-\n-        public ListIterator listIterator(int i) {\n-            return getList().listIterator(i);\n-        }\n-\n-        private List getList() {\n-            return (List)collection;\n-        }\n-\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n      * Returns a synchronized list backed by the given list.\n      * <p>\n      * You must manually synchronize on the returned buffer's iterator to \n      * @throws IllegalArgumentException  if the List or Predicate is null\n      */\n     public static List predicatedList(List list, Predicate predicate) {\n-        return new PredicatedList(list, predicate);\n+        return PredicatedList.decorate(list, predicate);\n     }\n \n     /**\n      * @return a typed list backed by the specified list\n      */\n     public static List typedList(List list, Class type) {\n-        return predicatedList(list, new CollectionUtils.InstanceofPredicate(type));\n+        return TypedList.decorate(list, type);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the List or Factory is null\n      */\n     public static List lazyList(List list, Factory factory) {\n-        return new LazyList(list, factory);\n+        return LazyList.decorate(list, factory);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the List is null\n      */\n     public static List fixedSizeList(List list) {\n-        return new FixedSizeList(list);\n+        return FixedSizeList.decorate(list);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.22 2003/04/26 14:28:31 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.23 2003/05/09 18:41:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n  *    distribution.\n  *\n  * 3. The end-user documentation included with the redistribution, if\n- *    any, must include the following acknowlegement:\n+ *    any, must include the following acknowledgment:\n  *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n- *    Alternately, this acknowlegement may appear in the software itself,\n- *    if and wherever such third-party acknowlegements normally appear.\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n  *\n  * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n  *    Foundation\" must not be used to endorse or promote products derived\n  *\n  * 5. Products derived from this software may not be called \"Apache\"\n  *    nor may \"Apache\" appear in their names without prior written\n- *    permission of the Apache Group.\n+ *    permission of the Apache Software Foundation.\n  *\n  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n import java.text.NumberFormat;\n import java.text.ParseException;\n import java.util.Collections;\n-import java.util.Comparator;\n import java.util.Enumeration;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Properties;\n import java.util.ResourceBundle;\n-import java.util.Set;\n import java.util.SortedMap;\n import java.util.TreeMap;\n+\n+import org.apache.commons.collections.decorators.FixedSizeMap;\n+import org.apache.commons.collections.decorators.FixedSizeSortedMap;\n+import org.apache.commons.collections.decorators.LazyMap;\n+import org.apache.commons.collections.decorators.LazySortedMap;\n+import org.apache.commons.collections.decorators.PredicatedMap;\n+import org.apache.commons.collections.decorators.PredicatedSortedMap;\n+import org.apache.commons.collections.decorators.TypedMap;\n+import org.apache.commons.collections.decorators.TypedSortedMap;\n \n /** \n  * A helper class for using {@link Map Map} instances.\n  *  </ul>\n  *\n  * @since Commons Collections 1.0\n- * @version $Revision: 1.22 $ $Date: 2003/04/26 14:28:31 $\n+ * @version $Revision: 1.23 $ $Date: 2003/05/09 18:41:34 $\n  * \n  * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n  * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n         } else {\n            map.put ( key, value );\n         }\n-    }\n-\n-    //-----------------------------------------------------------------------\n-    /**\n-     * Implementation of a map that checks (predicates) additions.\n-     */\n-    static class PredicatedMap \n-            extends ProxyMap {\n-\n-        protected final Predicate keyPredicate;\n-        protected final Predicate valuePredicate;\n-\n-        public PredicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n-            super(map);\n-            if (map == null) {\n-                throw new IllegalArgumentException(\"Map must not be null\");\n-            }\n-            if (keyPred == null) {\n-                throw new IllegalArgumentException(\"Key Predicate must not be null\");\n-            }\n-            if (valuePred == null) {\n-                throw new IllegalArgumentException(\"Value Predicate must not be null\");\n-            }\n-            this.keyPredicate = keyPred;\n-            this.valuePredicate = valuePred;\n-            Iterator iter = map.entrySet().iterator();\n-            while (iter.hasNext()) {\n-                Map.Entry entry = (Map.Entry)iter.next();\n-                Object key = entry.getKey();\n-                Object value = entry.getValue();\n-                validate(key, value);\n-            }\n-        }\n-\n-        public Object put(Object key, Object value) {\n-            validate(key, value);\n-            return map.put(key, value);\n-        }\n-\n-        public void putAll(Map m) {\n-            Iterator iter = m.entrySet().iterator();\n-            while (iter.hasNext()) {\n-                Map.Entry entry = (Map.Entry)iter.next();\n-                Object key = entry.getKey();\n-                Object value = entry.getValue();\n-                validate(key, value);\n-            }\n-            map.putAll(m);\n-        }\n-\n-        public Set entrySet() {\n-            return new PredicatedMapEntrySet(map.entrySet(), valuePredicate);\n-        }\n-\n-\n-        private void validate(Object key, Object value) {\n-            if (!keyPredicate.evaluate(key)) {\n-                throw new IllegalArgumentException(\"Cannot add key - Predicate rejected it\");\n-            }\n-            if (!valuePredicate.evaluate(value)) {\n-                throw new IllegalArgumentException(\"Cannot add value - Predicate rejected it\");\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Implementation of an entry set that checks (predicates) additions.\n-     */\n-    static class PredicatedMapEntrySet \n-            extends CollectionUtils.CollectionWrapper\n-            implements Set {\n-\n-        private final Predicate predicate;\n-\n-        public PredicatedMapEntrySet(Set set, Predicate p) {\n-            super(set);\n-            this.predicate = p;\n-        }\n-\n-        public Iterator iterator() {\n-            final Iterator iterator = collection.iterator();\n-            return new Iterator() {\n-                public boolean hasNext() {\n-                    return iterator.hasNext();\n-                }\n-\n-                public Object next() {\n-                    Map.Entry entry = (Map.Entry)iterator.next();\n-                    return new PredicatedMapEntry(entry, predicate);\n-                }\n-\n-                public void remove() {\n-                    iterator.remove();\n-                }\n-            };\n-        }\n-    }\n-\n-    /**\n-     * Implementation of a map entry that checks (predicates) additions.\n-     */\n-    static class PredicatedMapEntry \n-            implements Map.Entry {\n-\n-        private final Map.Entry entry;\n-        private final Predicate predicate;\n-\n-\n-        public PredicatedMapEntry(Map.Entry entry, Predicate p) {\n-            if (entry == null) {\n-                throw new IllegalArgumentException(\"Map.Entry must not be null\");\n-            }\n-            if (p == null) {\n-                throw new IllegalArgumentException(\"Predicate must not be null\");\n-            }\n-            this.entry = entry;\n-            this.predicate = p;\n-        }\n-\n-        public boolean equals(Object o) {\n-            return entry.equals(o);\n-        }\n-\n-        public int hashCode() {\n-            return entry.hashCode();\n-        }\n-\n-        public String toString() {\n-            return entry.toString();\n-        }\n-\n-        public Object getKey() {\n-            return entry.getKey();\n-        }\n-\n-        public Object getValue() {\n-            return entry.getValue();\n-        }\n-\n-        public Object setValue(Object o) {\n-            if (!predicate.evaluate(o)) {\n-                throw new IllegalArgumentException(\"Cannot set value - Predicate rejected it\");\n-            }\n-            return entry.setValue(o);\n-        }\n-    }\n-\n-    /**\n-     * Implementation of a map that is fixed in size.\n-     */\n-    static class FixedSizeMap \n-            extends ProxyMap {\n-\n-        public FixedSizeMap(Map map) {\n-            super(map);\n-            if (map == null) {\n-                throw new IllegalArgumentException(\"Map must not be null\");\n-            }\n-        }\n-\n-\n-        public Object put(Object key, Object value) {\n-            if (!map.containsKey(key)) {\n-                throw new IllegalArgumentException(\"Cannot put new key/value pair - List is fixed size\");\n-            }\n-            return map.put(key, value);\n-        }\n-\n-\n-        public void putAll(Map m) {\n-            for (Iterator iter = m.keySet().iterator(); iter.hasNext(); ) {\n-                if (!map.containsKey(iter.next())) {\n-                    throw new IllegalArgumentException(\"Cannot put new key/value pair - List is fixed size\");\n-                }\n-            }\n-            map.putAll(m);\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a map that creates objects on demand.\n-     */\n-    static class LazyMap \n-            extends ProxyMap {\n-\n-        protected final Factory factory;\n-\n-        public LazyMap(Map map, Factory factory) {\n-            super(map);\n-            if (map == null) {\n-                throw new IllegalArgumentException(\"Map must not be null\");\n-            }\n-            if (factory == null) {\n-                throw new IllegalArgumentException(\"Factory must not be null\");\n-            }\n-            this.factory = factory;\n-        }\n-\n-\n-        public Object get(Object key) {\n-            if (!map.containsKey(key)) {\n-                Object value = factory.create();\n-                map.put(key, value);\n-                return value;\n-            }\n-            return map.get(key);\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a map that creates objects on demand.\n-     */\n-    static class LazyTransformerMap \n-            extends ProxyMap {\n-\n-        protected final Transformer transformer;\n-\n-        public LazyTransformerMap(Map map, Transformer transformer) {\n-            super(map);\n-            if (map == null) {\n-                throw new IllegalArgumentException(\"Map must not be null\");\n-            }\n-            if (transformer == null) {\n-                throw new IllegalArgumentException(\"Transformer must not be null\");\n-            }\n-            this.transformer = transformer;\n-        }\n-\n-\n-        public Object get(Object key) {\n-            if (!map.containsKey(key)) {\n-                Object value = transformer.transform(key);\n-                map.put(key, value);\n-                return value;\n-            }\n-            return map.get(key);\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a sorted map that checks additions.\n-     */\n-    static class PredicatedSortedMap \n-            extends PredicatedMap \n-            implements SortedMap {\n-\n-        public PredicatedSortedMap(SortedMap map, Predicate k, Predicate v) {\n-            super(map, k, v);\n-        }\n-\n-        public Object firstKey() {\n-            return getSortedMap().firstKey();\n-        }\n-\n-        public Object lastKey() {\n-            return getSortedMap().lastKey();\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedMap().comparator();\n-        }\n-\n-        public SortedMap subMap(Object o1, Object o2) {\n-            SortedMap sub = getSortedMap().subMap(o1, o2);\n-            return new PredicatedSortedMap(sub, keyPredicate, valuePredicate);\n-        }\n-\n-        public SortedMap headMap(Object o1) {\n-            SortedMap sub = getSortedMap().headMap(o1);\n-            return new PredicatedSortedMap(sub, keyPredicate, valuePredicate);\n-        }\n-\n-        public SortedMap tailMap(Object o1) {\n-            SortedMap sub = getSortedMap().tailMap(o1);\n-            return new PredicatedSortedMap(sub, keyPredicate, valuePredicate);\n-        }\n-\n-        private SortedMap getSortedMap() {\n-            return (SortedMap)map;\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a sorted map that is fixed in size.\n-     */\n-    static class FixedSizeSortedMap \n-            extends FixedSizeMap \n-            implements SortedMap {\n-\n-        public FixedSizeSortedMap(SortedMap m) {\n-            super(m);\n-        }\n-\n-        public Object firstKey() {\n-            return getSortedMap().firstKey();\n-        }\n-\n-        public Object lastKey() {\n-            return getSortedMap().lastKey();\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedMap().comparator();\n-        }\n-\n-        public SortedMap subMap(Object o1, Object o2) {\n-            return new FixedSizeSortedMap(getSortedMap().subMap(o1, o2));\n-        }\n-\n-        public SortedMap headMap(Object o1) {\n-            return new FixedSizeSortedMap(getSortedMap().headMap(o1));\n-        }\n-\n-        public SortedMap tailMap(Object o1) {\n-            return new FixedSizeSortedMap(getSortedMap().tailMap(o1));\n-        }\n-\n-        private SortedMap getSortedMap() {\n-            return (SortedMap)map;\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a sorted map that creates objects on demand.\n-     */\n-    static class LazySortedMap \n-            extends LazyMap \n-            implements SortedMap {\n-\n-        public LazySortedMap(SortedMap m, Factory factory) {\n-            super(m, factory);\n-        }\n-\n-        public Object firstKey() {\n-            return getSortedMap().firstKey();\n-        }\n-\n-        public Object lastKey() {\n-            return getSortedMap().lastKey();\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedMap().comparator();\n-        }\n-\n-        public SortedMap subMap(Object o1, Object o2) {\n-            return new LazySortedMap(getSortedMap().subMap(o1, o2), factory);\n-        }\n-\n-        public SortedMap headMap(Object o1) {\n-            return new LazySortedMap(getSortedMap().headMap(o1), factory);\n-        }\n-\n-        public SortedMap tailMap(Object o1) {\n-            return new LazySortedMap(getSortedMap().tailMap(o1), factory);\n-        }\n-\n-        private SortedMap getSortedMap() {\n-            return (SortedMap)map;\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a sorted map that creates objects on demand.\n-     */\n-    static class LazyTransformerSortedMap \n-            extends LazyTransformerMap \n-            implements SortedMap {\n-\n-        public LazyTransformerSortedMap(SortedMap m, Transformer transformer) {\n-            super(m, transformer);\n-        }\n-\n-        public Object firstKey() {\n-            return getSortedMap().firstKey();\n-        }\n-\n-        public Object lastKey() {\n-            return getSortedMap().lastKey();\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedMap().comparator();\n-        }\n-\n-        public SortedMap subMap(Object o1, Object o2) {\n-            return new LazyTransformerSortedMap(getSortedMap().subMap(o1, o2), transformer);\n-        }\n-\n-        public SortedMap headMap(Object o1) {\n-            return new LazyTransformerSortedMap(getSortedMap().headMap(o1), transformer);\n-        }\n-\n-        public SortedMap tailMap(Object o1) {\n-            return new LazyTransformerSortedMap(getSortedMap().tailMap(o1), transformer);\n-        }\n-\n-        private SortedMap getSortedMap() {\n-            return (SortedMap)map;\n-        }\n-\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException  if the Map or Predicates are null\n      */\n     public static Map predicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n-        return new PredicatedMap(map, keyPred, valuePred);\n+        return PredicatedMap.decorate(map, keyPred, valuePred);\n     }\n \n     /**\n      * @return a typed map backed by the specified map\n      */\n     public static Map typedMap(Map map, Class keyType, Class valueType) {\n-        return predicatedMap(\n-            map, \n-            new CollectionUtils.InstanceofPredicate(keyType),\n-            new CollectionUtils.InstanceofPredicate(valueType));\n+        return TypedMap.decorate(map, keyType, valueType);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the Map is null\n      */\n     public static Map fixedSizeMap(Map map) {\n-        return new FixedSizeMap(map);\n+        return FixedSizeMap.decorate(map);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map or Factory is null\n      */\n     public static Map lazyMap(Map map, Factory factory) {\n-        return new LazyMap(map, factory);\n+        return LazyMap.decorate(map, factory);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n     public static Map lazyMap(Map map, Transformer transformerFactory) {\n-        return new LazyTransformerMap(map, transformerFactory);\n+        return LazyMap.decorate(map, transformerFactory);\n     }\n \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException  if the SortedMap or Predicates are null\n      */\n     public static SortedMap predicatedSortedMap(SortedMap map, Predicate keyPred, Predicate valuePred) {\n-        return new PredicatedSortedMap(map, keyPred, valuePred);\n+        return PredicatedSortedMap.decorate(map, keyPred, valuePred);\n     }\n \n     /**\n      * @return a typed map backed by the specified map\n      */\n     public static SortedMap typedSortedMap(SortedMap map, Class keyType, Class valueType) {\n-        return predicatedSortedMap(\n-            map, \n-            new CollectionUtils.InstanceofPredicate(keyType),\n-            new CollectionUtils.InstanceofPredicate(valueType));\n+        return TypedSortedMap.decorate(map, keyType, valueType);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the SortedMap is null\n      */\n     public static SortedMap fixedSizeSortedMap(SortedMap map) {\n-        return new FixedSizeSortedMap(map);\n+        return FixedSizeSortedMap.decorate(map);\n     }\n \n     /**\n      * @throws IllegalArgumentException  if the SortedMap or Factory is null\n      */\n     public static SortedMap lazySortedMap(SortedMap map, Factory factory) {\n-        return new LazySortedMap(map, factory);\n+        return LazySortedMap.decorate(map, factory);\n     }\n     \n     /**\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n     public static SortedMap lazySortedMap(SortedMap map, Transformer transformerFactory) {\n-        return new LazyTransformerSortedMap(map, transformerFactory);\n+        return LazySortedMap.decorate(map, transformerFactory);\n     }\n \n }\n--- a/src/java/org/apache/commons/collections/SetUtils.java\n+++ b/src/java/org/apache/commons/collections/SetUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SetUtils.java,v 1.12 2003/04/09 23:37:54 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/SetUtils.java,v 1.13 2003/05/09 18:41:34 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  *\n- * Copyright (c) 1999-2003 The Apache Software Foundation.  All rights\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n  * reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without\n \n import java.util.Collection;\n import java.util.Collections;\n-import java.util.Comparator;\n import java.util.Iterator;\n import java.util.Set;\n import java.util.SortedSet;\n import java.util.TreeSet;\n \n+import org.apache.commons.collections.decorators.PredicatedSet;\n+import org.apache.commons.collections.decorators.PredicatedSortedSet;\n+import org.apache.commons.collections.decorators.TypedSet;\n+import org.apache.commons.collections.decorators.TypedSortedSet;\n+\n /**\n  * Provides static utility methods and decorators for {@link Set} \n  * and {@link SortedSet} instances.\n  *\n- * @version $Revision: 1.12 $ $Date: 2003/04/09 23:37:54 $\n- * @since Commons Collection 2.1\n+ * @since Commons Collections 2.1\n+ * @version $Revision: 1.13 $ $Date: 2003/05/09 18:41:34 $\n  * \n  * @author Paul Jack\n  * @author Stephen Colebourne\n         return hashCode;\n     }\n     \n-    //-----------------------------------------------------------------------\n-    /**\n-     * Implementation of a set that checks new entries.\n-     */\n-    static class PredicatedSet \n-            extends CollectionUtils.PredicatedCollection\n-            implements Set {\n-\n-        public PredicatedSet(Set set, Predicate predicate) {\n-            super(set, predicate);\n-        }\n-\n-    }\n-\n-    /**\n-     * Implementation of a sorted set that checks new entries.\n-     */\n-    static class PredicatedSortedSet \n-            extends PredicatedSet \n-            implements SortedSet {\n-\n-        public PredicatedSortedSet(SortedSet set, Predicate predicate) {\n-            super(set, predicate);\n-        }\n-\n-        public SortedSet subSet(Object o1, Object o2) {\n-            SortedSet sub = getSortedSet().subSet(o1, o2);\n-            return new PredicatedSortedSet(sub, predicate);\n-        }\n-\n-        public SortedSet headSet(Object o1) {\n-            SortedSet sub = getSortedSet().headSet(o1);\n-            return new PredicatedSortedSet(sub, predicate);\n-        }\n-\n-        public SortedSet tailSet(Object o1) {\n-            SortedSet sub = getSortedSet().tailSet(o1);\n-            return new PredicatedSortedSet(sub, predicate);\n-        }\n-\n-        public Object first() {\n-            return getSortedSet().first();\n-        }\n-\n-        public Object last() {\n-            return getSortedSet().last();\n-        }\n-\n-        public Comparator comparator() {\n-            return getSortedSet().comparator();\n-        }\n-\n-        private SortedSet getSortedSet() {\n-            return (SortedSet)collection;\n-        }\n-\n-    }\n-\n     //-----------------------------------------------------------------------\n     /**\n      * Returns a synchronized set backed by the given set.\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n     public static Set predicatedSet(Set set, Predicate predicate) {\n-        return new PredicatedSet(set, predicate);\n+        return PredicatedSet.decorate(set, predicate);\n     }\n \n     /**\n      * @return a typed set backed by the specified set\n      */\n     public static Set typedSet(Set set, Class type) {\n-        return predicatedSet(set, new CollectionUtils.InstanceofPredicate(type));\n+        return TypedSet.decorate(set, type);\n     }\n     \n     //-----------------------------------------------------------------------\n      * @throws IllegalArgumentException  if the Set or Predicate is null\n      */\n     public static SortedSet predicatedSortedSet(SortedSet set, Predicate predicate) {\n-        return new PredicatedSortedSet(set, predicate);\n+        return PredicatedSortedSet.decorate(set, predicate);\n     }\n \n     /**\n      * @return a typed set backed by the specified set\n      */\n     public static SortedSet typedSortedSet(SortedSet set, Class type) {\n-        return predicatedSortedSet(set, new CollectionUtils.InstanceofPredicate(type));\n+        return TypedSortedSet.decorate(set, type);\n     }\n     \n }", "timestamp": 1052505694, "metainfo": ""}