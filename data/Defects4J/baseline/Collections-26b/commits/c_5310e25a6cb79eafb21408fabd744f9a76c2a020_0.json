{"sha": "5310e25a6cb79eafb21408fabd744f9a76c2a020", "log": "[COLLECTIONS-533] Initial commit for MultiValuedLinkedHashMap implementation & tests. Thanks to Geoff Schoeman.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections4/multimap/MultiValuedLinkedHashMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.collections4.ListValuedMap;\n+import org.apache.commons.collections4.MultiValuedMap;\n+import org.apache.commons.collections4.SetValuedMap;\n+\n+/**\n+ * Implements a {@link MultiValuedMap}, using a {@link LinkedHashMap} to provide data\n+ * storage. This MultiValuedMap implementation the allows insertion order to be\n+ * maintained.\n+ * <p>\n+ * A <code>MultiValuedMap</code> is a Map with slightly different semantics.\n+ * Putting a value into the map will add the value to a Collection at that key.\n+ * Getting a value will return a Collection, holding all the values put to that\n+ * key\n+ * <p>\n+ * In addition, this implementation allows the type of collection used for the\n+ * values to be controlled. By default, an <code>LinkedList</code> is used,\n+ * however a <code>Class<? extends Collection></code> to instantiate the value\n+ * collection may be specified.\n+ * <p>\n+ * <strong>Note that MultiValuedLinkedHashMap is not synchronized and is not\n+ * thread-safe.</strong> If you wish to use this map from multiple threads\n+ * concurrently, you must use appropriate synchronization. This class may throw\n+ * exceptions when accessed by concurrent threads without synchronization.\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class MultiValuedLinkedHashMap<K, V> extends AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V> {\n+\n+    /** Serialization Version */\n+    private static final long serialVersionUID = -5845183518195365857L;\n+\n+    /**\n+     * The initial capacity used when none specified in constructor.\n+     */\n+    static final int DEFAULT_INITIAL_CAPACITY = 16;\n+\n+    /**\n+     * The load factor used when none specified in constructor.\n+     */\n+    static final float DEFAULT_LOAD_FACTOR = 0.75f;\n+\n+    /**\n+     * Creates a {@link ListValuedMap} with a {@link LinkedHashMap} as its internal\n+     * storage\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return a new <code>ListValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> ListValuedMap<K, V> listValuedLinkedHashMap() {\n+        return new ListValuedLinkedHashMap(LinkedList.class);\n+    }\n+\n+    /**\n+     * Creates a {@link ListValuedMap} with a {@link LinkedHashMap} as its internal\n+     * storage which maps the keys to list of type <code>listClass</code>\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the List class type\n+     * @param listClass the class of the list\n+     * @return a new <code>ListValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V, C extends List<V>> ListValuedMap<K, V> listValuedLinkedHashMap(final Class<C> listClass) {\n+        return new ListValuedLinkedHashMap(listClass);\n+    }\n+\n+    /**\n+     * Creates a {@link SetValuedMap} with a {@link LinkedHashMap} as its internal\n+     * storage\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @return a new <code>SetValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V> SetValuedMap<K, V> setValuedLinkedHashMap() {\n+        return new SetValuedLinkedHashMap(HashSet.class);\n+    }\n+\n+    /**\n+     * Creates a {@link SetValuedMap} with a {@link LinkedHashMap} as its internal\n+     * storage which maps the keys to a set of type <code>setClass</code>\n+     *\n+     * @param <K> the key type\n+     * @param <V> the value type\n+     * @param <C> the Set class type\n+     * @param setClass the class of the set\n+     * @return a new <code>SetValuedMap</code>\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static <K, V, C extends Set<V>> SetValuedMap<K, V> setValuedLinkedHashMap(final Class<C> setClass) {\n+        return new SetValuedLinkedHashMap(setClass);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>LinkedHashMap</code> with the default\n+     * initial capacity (16) and the default load factor (0.75), which stores\n+     * the multiple values in an <code>LinkedList</code>.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedLinkedHashMap() {\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, LinkedList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>LinkedHashMap</code> with the initial\n+     * capacity and the default load factor (0.75), which stores the multiple\n+     * values in an <code>LinkedList</code>.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying hash map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedLinkedHashMap(int initialCapacity) {\n+        this(initialCapacity, DEFAULT_LOAD_FACTOR, LinkedList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>LinkedHashMap</code> with the initial\n+     * capacity and the load factor, which stores the multiple values in an\n+     * <code>LinkedList</code>.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying hash map\n+     * @param loadFactor the load factor of the underlying hash map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedLinkedHashMap(int initialCapacity, float loadFactor) {\n+        this(initialCapacity, loadFactor, LinkedList.class);\n+    }\n+\n+    /**\n+     * Creates a MultiValueMap based on a <code>LinkedHashMap</code> with the initial\n+     * capacity and the load factor, which stores the multiple values in an\n+     * <code>LinkedList</code> with the initial collection capacity.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying hash map\n+     * @param loadFactor the load factor of the underlying hash map\n+     * @param initialCollectionCapacity the initial capacity of the Collection\n+     *        of values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedLinkedHashMap(int initialCapacity, float loadFactor, int initialCollectionCapacity) {\n+        this(initialCapacity, loadFactor, LinkedList.class, initialCollectionCapacity);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedLinkedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a <code>MultiValuedMap</code> to copy into this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedLinkedHashMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, LinkedList.class);\n+        super.putAll(map);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedLinkedHashMap copying all the mappings of the given map.\n+     *\n+     * @param map a <code>Map</code> to copy into this map\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public MultiValuedLinkedHashMap(final Map<? extends K, ? extends V> map) {\n+        this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, LinkedList.class);\n+        super.putAll(map);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedLinkedHashMap which creates the value collections using\n+     * the supplied <code>collectionClazz</code>.\n+     *\n+     * @param initialCapacity the initial capacity of the underlying\n+     *        <code>LinkedHashMap</code>\n+     * @param loadFactor the load factor of the underlying <code>LinkedHashMap</code>\n+     * @param <C> the collection type\n+     * @param collectionClazz the class of the <code>Collection</code> to use to\n+     *        create the value collections\n+     */\n+    protected <C extends Collection<V>> MultiValuedLinkedHashMap(int initialCapacity, float loadFactor,\n+            final Class<C> collectionClazz) {\n+        super(new LinkedHashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz);\n+    }\n+\n+    /**\n+     * Creates a MultiValuedLinkedHashMap which creates the value collections using\n+     * the supplied <code>collectionClazz</code> and the initial collection\n+     * capacity .\n+     *\n+     * @param initialCapacity the initial capacity of the underlying\n+     *        <code>LinkedHashMap</code>\n+     * @param loadFactor the load factor of the underlying <code>LinkedHashMap</code>\n+     * @param initialCollectionCapacity the initial capacity of the\n+     *        <code>Collection</code>\n+     * @param <C> the collection type\n+     * @param collectionClazz the class of the <code>Collection</code> to use to\n+     *        create the value collections\n+     */\n+    protected <C extends Collection<V>> MultiValuedLinkedHashMap(int initialCapacity, float loadFactor,\n+            final Class<C> collectionClazz, int initialCollectionCapacity) {\n+        super(new LinkedHashMap<K, Collection<V>>(initialCapacity, loadFactor), collectionClazz, initialCollectionCapacity);\n+    }\n+\n+    /** Inner class for ListValuedLinkedMap */\n+    private static class ListValuedLinkedHashMap<K, V> extends AbstractListValuedMap<K, V> {\n+\n+        private static final long serialVersionUID = 3667581458573135234L;\n+\n+        public <C extends List<V>> ListValuedLinkedHashMap(Class<C> listClazz) {\n+            super(new LinkedHashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz);\n+        }\n+\n+        public <C extends List<V>> ListValuedLinkedHashMap(Class<C> listClazz, int initialListCapacity) {\n+            super(new LinkedHashMap<K, List<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), listClazz,\n+                    initialListCapacity);\n+        }\n+\n+    }\n+\n+    /** Inner class for SetValuedLinkedMap */\n+    private static class SetValuedLinkedHashMap<K, V> extends AbstractSetValuedMap<K, V> {\n+\n+        private static final long serialVersionUID = -3817515514829894543L;\n+\n+        public <C extends Set<V>> SetValuedLinkedHashMap(Class<C> setClazz) {\n+            super(new LinkedHashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz);\n+        }\n+\n+        public <C extends Set<V>> SetValuedLinkedHashMap(Class<C> setClazz, int initialSetCapacity) {\n+            super(new LinkedHashMap<K, Set<V>>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR), setClazz,\n+                    initialSetCapacity);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections4/multimap/MultiValuedLinkedHashMapTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections4.multimap;\n+\n+import java.util.*;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections4.*;\n+\n+/**\n+ * Test MultiValuedLinkedHashMap\n+ *\n+ * @since 4.1\n+ * @version $Id$\n+ */\n+public class MultiValuedLinkedHashMapTest<K, V> extends AbstractMultiValuedMapTest<K, V> {\n+\n+    public MultiValuedLinkedHashMapTest(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(MultiValuedLinkedHashMapTest.class);\n+    }\n+\n+    @Override\n+    public MultiValuedMap<K, V> makeObject() {\n+        final MultiValuedMap<K, V> m = new MultiValuedLinkedHashMap<K, V>();\n+        return m;\n+    }\n+\n+    public void testIterationOrder() {\n+        MultiValuedMap<K, V> map = makeFullMap();\n+        MapIterator<K, V> mapIt = map.mapIterator();\n+        Iterator keyIt = Arrays.asList(getSampleKeys()).iterator();\n+        Iterator valueIt = Arrays.asList(getSampleValues()).iterator();\n+\n+        while(mapIt.hasNext()) {\n+            mapIt.next();\n+            assertEquals(mapIt.getKey(), keyIt.next());\n+            assertEquals(mapIt.getValue(), valueIt.next());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapAdd() {\n+        final SetValuedMap<K, V> setMap = MultiValuedLinkedHashMap.setValuedLinkedHashMap();\n+        assertTrue(setMap.get(\"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get(\"A\");\n+        assertTrue(set.add((V) \"a1\"));\n+        assertTrue(set.add((V) \"a2\"));\n+        assertFalse(set.add((V) \"a1\"));\n+        assertEquals(2, setMap.size());\n+        assertTrue(setMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapRemove() {\n+        final SetValuedMap<K, V> setMap = MultiValuedLinkedHashMap.setValuedLinkedHashMap();\n+        assertTrue(setMap.get(\"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get(\"A\");\n+        assertTrue(set.add((V) \"a1\"));\n+        assertTrue(set.add((V) \"a2\"));\n+        assertFalse(set.add((V) \"a1\"));\n+        assertEquals(2, setMap.size());\n+        assertTrue(setMap.containsKey(\"A\"));\n+\n+        assertTrue(set.remove(\"a1\"));\n+        assertTrue(set.remove(\"a2\"));\n+        assertFalse(set.remove(\"a1\"));\n+\n+        assertEquals(0, setMap.size());\n+        assertFalse(setMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSetValuedMapRemoveViaIterator() {\n+        final SetValuedMap<K, V> setMap = MultiValuedLinkedHashMap.setValuedLinkedHashMap();\n+        assertTrue(setMap.get(\"whatever\") instanceof Set);\n+\n+        Set<V> set = setMap.get(\"A\");\n+        set.add((V) \"a1\");\n+        set.add((V) \"a2\");\n+        set.add((V) \"a1\");\n+\n+        Iterator<V> it = set.iterator();\n+        while (it.hasNext()) {\n+            it.next();\n+            it.remove();\n+        }\n+        assertEquals(0, setMap.size());\n+        assertFalse(setMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapAdd() {\n+        final ListValuedMap<K, V> listMap = MultiValuedLinkedHashMap.listValuedLinkedHashMap();\n+        assertTrue(listMap.get(\"whatever\") instanceof List);\n+        List<V> list = listMap.get(\"A\");\n+        list.add((V) \"a1\");\n+        assertEquals(1, listMap.size());\n+        assertTrue(listMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapAddViaListIterator() {\n+        final ListValuedMap<K, V> listMap = MultiValuedLinkedHashMap.listValuedLinkedHashMap();\n+        ListIterator<V> listIt = listMap.get(\"B\").listIterator();\n+        assertFalse(listIt.hasNext());\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        listIt.add((V) \"b3\");\n+        assertEquals(3, listMap.size());\n+        assertTrue(listMap.containsKey(\"B\"));\n+        // As ListIterator always adds before the current cursor\n+        assertFalse(listIt.hasNext());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapRemove() {\n+        final ListValuedMap<K, V> listMap = MultiValuedLinkedHashMap.listValuedLinkedHashMap();\n+        List<V> list = listMap.get(\"A\");\n+        list.add((V) \"a1\");\n+        list.add((V) \"a2\");\n+        list.add((V) \"a3\");\n+        assertEquals(3, listMap.size());\n+        assertEquals(\"a1\", list.remove(0));\n+        assertEquals(2, listMap.size());\n+        assertEquals(\"a2\", list.remove(0));\n+        assertEquals(1, listMap.size());\n+        assertEquals(\"a3\", list.remove(0));\n+        assertEquals(0, listMap.size());\n+        assertFalse(listMap.containsKey(\"A\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testListValuedMapRemoveViaListIterator() {\n+        final ListValuedMap<K, V> listMap = MultiValuedLinkedHashMap.listValuedLinkedHashMap();\n+        ListIterator<V> listIt = listMap.get(\"B\").listIterator();\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        assertEquals(2, listMap.size());\n+        assertTrue(listMap.containsKey(\"B\"));\n+        listIt = listMap.get(\"B\").listIterator();\n+        while (listIt.hasNext()) {\n+            listIt.next();\n+            listIt.remove();\n+        }\n+        assertFalse(listMap.containsKey(\"B\"));\n+        listIt.add((V) \"b1\");\n+        listIt.add((V) \"b2\");\n+        assertTrue(listMap.containsKey(\"B\"));\n+        assertEquals(2, listMap.get(\"B\").size());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public void testEqualsHashCodeContract() {\n+        MultiValuedMap map1 = new MultiValuedLinkedHashMap();\n+        MultiValuedMap map2 = new MultiValuedLinkedHashMap();\n+\n+        map1.put(\"a\", \"a1\");\n+        map1.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a1\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map2.put(\"a\", \"a2\");\n+        assertNotSame(map1, map2);\n+        assertNotSame(map1.hashCode(), map2.hashCode());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public void testListValuedMapEqualsHashCodeContract() {\n+        ListValuedMap map1 = MultiValuedLinkedHashMap.listValuedLinkedHashMap();\n+        ListValuedMap map2 = MultiValuedLinkedHashMap.listValuedLinkedHashMap();\n+\n+        map1.put(\"a\", \"a1\");\n+        map1.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a1\");\n+        map2.put(\"a\", \"a2\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map1.put(\"b\", \"b1\");\n+        map1.put(\"b\", \"b2\");\n+        map2.put(\"b\", \"b2\");\n+        map2.put(\"b\", \"b1\");\n+        assertNotSame(map1, map2);\n+        assertNotSame(map1.hashCode(), map2.hashCode());\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public void testSetValuedMapEqualsHashCodeContract() {\n+        SetValuedMap map1 = MultiValuedLinkedHashMap.setValuedLinkedHashMap();\n+        SetValuedMap map2 = MultiValuedLinkedHashMap.setValuedLinkedHashMap();\n+\n+        map1.put(\"a\", \"a1\");\n+        map1.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a2\");\n+        map2.put(\"a\", \"a1\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map2.put(\"a\", \"a2\");\n+        assertEquals(map1, map2);\n+        assertEquals(map1.hashCode(), map2.hashCode());\n+\n+        map2.put(\"a\", \"a3\");\n+        assertNotSame(map1, map2);\n+        assertNotSame(map1.hashCode(), map2.hashCode());\n+    }\n+}", "timestamp": 1413543083, "metainfo": ""}