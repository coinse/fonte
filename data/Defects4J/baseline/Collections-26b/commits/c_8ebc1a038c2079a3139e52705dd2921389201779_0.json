{"sha": "8ebc1a038c2079a3139e52705dd2921389201779", "log": "Javadoc fixes, removed unneeded imports.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/Bag.java\n+++ b/src/main/java/org/apache/commons/collections/Bag.java\n  * <p>\n  * Suppose you have a Bag that contains <code>{a, a, b, c}</code>.\n  * Calling {@link #getCount(Object)} on <code>a</code> would return 2, while\n- * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.\n+ * calling {@link #uniqueSet()} would return <code>{a, b, c}</code>.</p>\n  * <p>\n  * <i>NOTE: This interface violates the {@link Collection} contract.</i> \n  * The behavior specified in many of these methods is <i>not</i> the same\n  * as the behavior specified by <code>Collection</code>.\n  * The noncompliant methods are clearly marked with \"(Violation)\".\n- * Exercise caution when using a bag as a <code>Collection</code>.\n+ * Exercise caution when using a bag as a <code>Collection</code>.</p>\n  * <p>\n  * This violation resulted from the original specification of this interface.\n  * In an ideal world, the interface would be changed to fix the problems, however\n- * it has been decided to maintain backwards compatibility instead.\n+ * it has been decided to maintain backwards compatibility instead.</p>\n  *\n  * @param <E> the type held in the bag\n  * @since Commons Collections 2.0\n      * <p>\n      * If the object is already in the {@link #uniqueSet()} then increment its\n      * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n-     * {@link #uniqueSet()} and report its count as 1.\n+     * {@link #uniqueSet()} and report its count as 1.</p>\n      * <p>\n      * Since this method always increases the size of the bag,\n      * according to the {@link Collection#add(Object)} contract, it \n      * should always return <code>true</code>.  Since it sometimes returns\n-     * <code>false</code>, this method violates the contract.\n+     * <code>false</code>, this method violates the contract.</p>\n      *\n      * @param object  the object to add\n      * @return <code>true</code> if the object was not already in the <code>uniqueSet</code>\n      * <p>\n      * If the object is already in the {@link #uniqueSet()} then increment its\n      * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n-     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.\n+     * {@link #uniqueSet()} and report its count as <code>nCopies</code>.</p>\n      * \n      * @param object  the object to add\n      * @param nCopies  the number of copies to add\n      * <i>(Violation)</i>\n      * Removes all occurrences of the given object from the bag.\n      * <p>\n-     * This will also remove the object from the {@link #uniqueSet()}.\n+     * This will also remove the object from the {@link #uniqueSet()}.</p>\n      * <p>\n      * According to the {@link Collection#remove(Object)} method,\n      * this method should only remove the <i>first</i> occurrence of the\n-     * given object, not <i>all</i> occurrences.\n-     *\n+     * given object, not <i>all</i> occurrences.</p>\n+     *\n+     * @param object  the object to remove\n      * @return <code>true</code> if this call changed the collection\n      */\n     boolean remove(Object object);\n      * Removes <code>nCopies</code> copies of the specified object from the Bag.\n      * <p>\n      * If the number of copies to remove is greater than the actual number of\n-     * copies in the Bag, no error is thrown.\n+     * copies in the Bag, no error is thrown.</p>\n      * \n      * @param object  the object to remove\n      * @param nCopies  the number of copies to remove\n     /**\n      * Returns a {@link Set} of unique elements in the Bag.\n      * <p>\n-     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n+     * Uniqueness constraints are the same as those in {@link java.util.Set}.</p>\n      * \n      * @return the Set of unique Bag elements\n      */\n      * The {@link Collection#containsAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n      * return true if the bag contains at least one of every object contained\n-     * in the given collection.\n+     * in the given collection.</p>\n      * \n      * @param coll  the collection to check against\n      * @return <code>true</code> if the Bag contains all the collection\n      * the bag will have <code>n</code> fewer copies, assuming the bag\n      * had at least <code>n</code> copies to begin with.\n      *\n-     * <P>The {@link Collection#removeAll(Collection)} method specifies\n+     * <p>The {@link Collection#removeAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n      * remove <i>all</i> occurrences of every object contained in the \n-     * given collection.\n+     * given collection.</p>\n      *\n      * @param coll  the collection to remove\n      * @return <code>true</code> if this call changed the collection\n      * <code>!coll.contains(e)</code>, then remove <code>e</code> and any\n      * of its copies.\n      *\n-     * <P>The {@link Collection#retainAll(Collection)} method specifies\n+     * <p>The {@link Collection#retainAll(Collection)} method specifies\n      * that cardinality should <i>not</i> be respected; this method should\n      * keep <i>all</i> occurrences of every object contained in the \n-     * given collection.\n+     * given collection.</p>\n      *\n      * @param coll  the collection to retain\n      * @return <code>true</code> if this call changed the collection\n--- a/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n+++ b/src/main/java/org/apache/commons/collections/splitmap/TransformedMap.java\n import java.io.Serializable;\n import java.util.Map;\n \n-import org.apache.commons.collections.Get;\n import org.apache.commons.collections.Put;\n import org.apache.commons.collections.Transformer;\n import org.apache.commons.collections.map.LinkedMap;", "timestamp": 1340466011, "metainfo": ""}