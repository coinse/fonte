{"sha": "e18f4e691a54a18ebb9e14a00c914155c855522c", "log": "Added new decorators, and modified existing decorators to fit the conventions outlined in the developer's guide.  Decorators are package-protected inner classes, not part of the public API.  Existing lazy and predicated decorators were moved to CollectionUtils, ListUtils etc.  New classes SetUtils, BagUtils were added for decorators of those types.  New bounded and fixed size decorators were added for appropriate types. Unmodifiable and synchronized decorators were added for Buffers and Bags.  Unit tests were added where possible.  No unit tests for synchronized collection wrappers; not sure how to implement a valid test for proper synchronization.  Also, no unit tests for Bag decorators, because the decorator unit tests require the TestCollection framework, which won't work with Bag since it violates the Collection contract.  Modified Files:  \tsrc/java/org/apache/commons/collections/BufferUtils.java  \tsrc/java/org/apache/commons/collections/CollectionUtils.java  \tsrc/java/org/apache/commons/collections/ListUtils.java  \tsrc/java/org/apache/commons/collections/MapUtils.java  \tsrc/java/org/apache/commons/collections/PredicateUtils.java  \tsrc/test/org/apache/commons/collections/TestAll.java  \tsrc/test/org/apache/commons/collections/TestCollectionUtils.java  \tsrc/test/org/apache/commons/collections/TestList.java Added Files:  \tsrc/java/org/apache/commons/collections/BagUtils.java  \tsrc/java/org/apache/commons/collections/SetUtils.java  \tsrc/test/org/apache/commons/collections/TestBoundedCollection.java  \tsrc/test/org/apache/commons/collections/TestBufferUtils.java  \tsrc/test/org/apache/commons/collections/TestListUtils.java  \tsrc/test/org/apache/commons/collections/TestMapUtils.java  \tsrc/test/org/apache/commons/collections/TestPredicatedCollection.java  \tsrc/test/org/apache/commons/collections/TestSetUtils.java Removed Files:  \tsrc/java/org/apache/commons/collections/LazyCollections.java   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/BagUtils.java\n+package org.apache.commons.collections;\n+\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Set;\n+\n+\n+/**\n+ *  Provides utility methods and decorators for {@link Bag} \n+ *  and {@link SortedBag} instances.<P>\n+ *\n+ *  @author Paul Jack\n+ *  @version $Id: BagUtils.java,v 1.1 2002/08/13 00:26:51 pjack Exp $\n+ */\n+public class BagUtils {\n+\n+\n+    /**\n+     *  Prevents instantiation.\n+     */\n+    private BagUtils() {\n+    }\n+\n+\n+    static class PredicatedBag extends CollectionUtils.PredicatedCollection \n+    implements Bag {\n+\n+        public PredicatedBag(Bag b, Predicate p) {\n+            super(b, p);\n+        }\n+\n+        public boolean add(Object o, int count) {\n+            validate(o);\n+            return getBag().add(o, count);\n+        }\n+\n+        public boolean remove(Object o, int count) {\n+            return getBag().remove(o, count);\n+        }\n+\n+        public Set uniqueSet() {\n+            return getBag().uniqueSet();\n+        }\n+\n+        public int getCount(Object o) {\n+            return getBag().getCount(o);\n+        }\n+\n+        private Bag getBag() {\n+            return (Bag)collection;\n+        }\n+    }\n+\n+\n+    static class UnmodifiableBag \n+    extends CollectionUtils.UnmodifiableCollection\n+    implements Bag {\n+\n+        public UnmodifiableBag(Bag bag) {\n+            super(bag);\n+        }\n+\n+        private Bag getBag() {\n+            return (Bag)collection;\n+        }\n+\n+        public boolean add(Object o, int count) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean remove(Object o, int count) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Set uniqueSet() {\n+            return ((Bag)collection).uniqueSet();\n+        }\n+\n+        public int getCount(Object o) {\n+            return ((Bag)collection).getCount(o);\n+        }\n+    }\n+\n+\n+    static class SynchronizedBag\n+    extends CollectionUtils.SynchronizedCollection\n+    implements Bag {\n+\n+        public SynchronizedBag(Bag bag) {\n+            super(bag);\n+        }\n+\n+        public synchronized boolean add(Object o, int count) {\n+            return getBag().add(o, count);\n+        }\n+\n+        public synchronized boolean remove(Object o, int count) {\n+            return getBag().remove(o, count);\n+        }\n+\n+        public synchronized Set uniqueSet() {\n+            return getBag().uniqueSet();\n+        }\n+\n+        public synchronized int getCount(Object o) {\n+            return getBag().getCount(o);\n+        }\n+\n+        private Bag getBag() {\n+            return (Bag)collection;\n+        }\n+\n+    }\n+\n+\n+    static class BoundedBag extends CollectionUtils.CollectionWrapper\n+    implements Bag {\n+\n+        final protected int maxSize;\n+\n+        public BoundedBag(Bag bag, int maxSize) {\n+            super(bag);\n+            this.maxSize = maxSize;\n+        }\n+\n+        public boolean add(Object o) {\n+            validate(1);\n+            return collection.add(o);\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            validate(c.size());\n+            return collection.addAll(c);\n+        }\n+\n+        public boolean add(Object o, int count) {\n+            validate(count);\n+            return getBag().add(o, count);\n+        }\n+\n+        public boolean remove(Object o, int count) {\n+            return getBag().remove(o, count);\n+        }\n+\n+        public Set uniqueSet() {\n+            return getBag().uniqueSet();\n+        }\n+\n+        public int getCount(Object o) {\n+            return getBag().getCount(o);\n+        }\n+\n+        private Bag getBag() {\n+            return (Bag)collection;\n+        }\n+\n+        protected void validate(int delta) {\n+            if (delta + size() > maxSize) {\n+                throw new IllegalStateException(\"Maximum size reached.\");\n+            }\n+        }\n+    }\n+\n+\n+    static class PredicatedSortedBag extends PredicatedBag \n+    implements SortedBag {\n+\n+        public PredicatedSortedBag(SortedBag sb, Predicate p) {\n+            super(sb, p);\n+        }\n+\n+        public Comparator comparator() {\n+            return getSortedBag().comparator();\n+        }\n+\n+        public Object first() {\n+            return getSortedBag().first();\n+        }\n+\n+        public Object last() {\n+            return getSortedBag().last();\n+        }\n+\n+        private SortedBag getSortedBag() {\n+            return (SortedBag)collection;\n+        }\n+    }\n+\n+\n+    static class SynchronizedSortedBag extends SynchronizedBag\n+    implements SortedBag {\n+\n+        public SynchronizedSortedBag(SortedBag bag) {\n+            super(bag);\n+        }\n+\n+        public synchronized Comparator comparator() {\n+            return getSortedBag().comparator();\n+        }\n+\n+        public synchronized Object first() {\n+            return getSortedBag().first();\n+        }\n+\n+        public synchronized Object last() {\n+            return getSortedBag().last();\n+        }\n+\n+        private SortedBag getSortedBag() {\n+            return (SortedBag)collection;\n+        }\n+\n+    }\n+\n+\n+    static class UnmodifiableSortedBag extends UnmodifiableBag\n+    implements SortedBag {\n+\n+        public UnmodifiableSortedBag(SortedBag bag) {\n+            super(bag);\n+        }\n+\n+        public Comparator comparator() {\n+            return getSortedBag().comparator();\n+        }\n+\n+        public Object first() {\n+            return getSortedBag().first();\n+        }\n+\n+        public Object last() {\n+            return getSortedBag().last();\n+        }\n+\n+        private SortedBag getSortedBag() {\n+            return (SortedBag)collection;\n+        }\n+\n+    }\n+\n+\n+    static class BoundedSortedBag extends BoundedBag\n+    implements SortedBag {\n+\n+        public BoundedSortedBag(SortedBag bag, int maxSize) {\n+            super(bag, maxSize);\n+        }\n+\n+        public Comparator comparator() {\n+            return getSortedBag().comparator();\n+        }\n+\n+        public Object first() {\n+            return getSortedBag().first();\n+        }\n+\n+        public Object last() {\n+            return getSortedBag().last();\n+        }\n+\n+        private SortedBag getSortedBag() {\n+            return (SortedBag)collection;\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated bag backed by the given bag.  Only objects\n+     *  that pass the test in the given predicate can be added to the bag.\n+     *  It is important not to use the original bag after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param b  the bag to predicate\n+     *  @param p  the predicate for the bag\n+     *  @return  a predicated bag backed by the given bag\n+     */\n+    public static Bag predicatedBag(Bag b, Predicate p) {\n+        return new PredicatedBag(b, p);\n+    }\n+\n+\n+    /**\n+     *  Returns an unmodifiable view of the given bag.  Any modification\n+     *  attempts to the returned bag will raise an \n+     *  {@link UnsupportedOperationException}.\n+     *\n+     *  @param b  the bag whose unmodifiable view is to be returned\n+     *  @return  an unmodifiable view of that bag\n+     */\n+    public static Bag unmodifiableBag(Bag b) {\n+        return new UnmodifiableBag(b);\n+    }\n+\n+\n+    /**\n+     *  Returns a synchronized (thread-safe) bag backed by the given bag.\n+     *  In order to guarantee serial access, it is critical that all \n+     *  access to the backing bag is accomplished through the returned bag.\n+     *  <P>\n+     *  It is imperative that the user manually synchronize on the returned\n+     *  bag when iterating over it:\n+     *\n+     *  <Pre>\n+     *  Bag bag = BagUtils.synchronizedBag(new HashBag());\n+     *  ...\n+     *  synchronized(bag) {\n+     *      Iterator i = bag.iterator(); // Must be in synchronized block\n+     *      while (i.hasNext())\n+     *          foo(i.next());\n+     *      }\n+     *  }\n+     *  </Pre>\n+     *\n+     *  Failure to follow this advice may result in non-deterministic \n+     *  behavior.\n+     *\n+     *  @param b  the bag to synchronize\n+     *  @return  a synchronized bag backed by that bag\n+     */\n+    public static Bag synchronizedBag(Bag b) {\n+        return new SynchronizedBag(b);\n+    }\n+\n+\n+    /**\n+     *  Returns a bounded bag backed by the given bag.\n+     *  New elements may only be added to the returned bag if its \n+     *  size is less than the specified maximum; otherwise, an\n+     *  {@link IllegalStateException} will be thrown.\n+     *\n+     *  @param b  the bag whose size to bind\n+     *  @param maxSize  the maximum size of the returned bag\n+     *  @return  a bounded bag \n+     */\n+    public static Bag boundedBag(Bag b, int maxSize) {\n+        return new BoundedBag(b, maxSize);\n+    }\n+\n+\n+\n+\n+    /**\n+     *  Returns a predicated sorted bag backed by the given sorted bag.  \n+     *  Only objects that pass the test in the given predicate can be \n+     *  added to the bag.\n+     *  It is important not to use the original bag after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param b  the sorted bag to predicate\n+     *  @param p  the predicate for the bag\n+     *  @return  a predicated bag backed by the given bag\n+     */\n+    public static SortedBag predicatedSortedBag(SortedBag b, Predicate p) {\n+        return new PredicatedSortedBag(b, p);\n+    }\n+\n+\n+    /**\n+     *  Returns an unmodifiable view of the given sorted bag.  Any modification\n+     *  attempts to the returned bag will raise an \n+     *  {@link UnsupportedOperationException}.\n+     *\n+     *  @param b  the bag whose unmodifiable view is to be returned\n+     *  @return  an unmodifiable view of that bag\n+     */\n+    public static SortedBag unmodifiableSortedBag(SortedBag b) {\n+        return new UnmodifiableSortedBag(b);\n+    }\n+\n+\n+    /**\n+     *  Returns a synchronized (thread-safe) sorted bag backed by the given \n+     *  sorted bag.\n+     *  In order to guarantee serial access, it is critical that all \n+     *  access to the backing bag is accomplished through the returned bag.\n+     *  <P>\n+     *  It is imperative that the user manually synchronize on the returned\n+     *  bag when iterating over it:\n+     *\n+     *  <Pre>\n+     *  SortedBag bag = BagUtils.synchronizedSortedBag(new TreeBag());\n+     *  ...\n+     *  synchronized(bag) {\n+     *      Iterator i = bag.iterator(); // Must be in synchronized block\n+     *      while (i.hasNext())\n+     *          foo(i.next());\n+     *      }\n+     *  }\n+     *  </Pre>\n+     *\n+     *  Failure to follow this advice may result in non-deterministic \n+     *  behavior.\n+     *\n+     *  @param b  the bag to synchronize\n+     *  @return  a synchronized bag backed by that bag\n+     */\n+    public static SortedBag synchronizedSortedBag(SortedBag b) {\n+        return new SynchronizedSortedBag(b);\n+    }\n+\n+\n+    /**\n+     *  Returns a bounded sorted bag backed by the given sorted bag.\n+     *  New elements may only be added to the returned bag if its \n+     *  size is less than the specified maximum; otherwise, an\n+     *  {@link IllegalStateException} will be thrown.\n+     *\n+     *  @param b  the bag whose size to bind\n+     *  @param maxSize  the maximum size of the returned bag\n+     *  @return  a bounded bag \n+     */\n+    public static SortedBag boundedSortedBag(SortedBag b, int maxSize) {\n+        return new BoundedSortedBag(b, maxSize);\n+    }\n+\n+\n+}\n--- a/src/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/java/org/apache/commons/collections/BufferUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUtils.java,v 1.3 2002/07/03 02:16:48 mas Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/07/03 02:16:48 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/BufferUtils.java,v 1.4 2002/08/13 00:26:51 pjack Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/08/13 00:26:51 $\n  *\n  * ====================================================================\n  *\n  *  Contains static utility methods for operating on {@link Buffer} objects.\n  *\n  *  @author Paul Jack\n- *  @version $Id: BufferUtils.java,v 1.3 2002/07/03 02:16:48 mas Exp $\n+ *  @version $Id: BufferUtils.java,v 1.4 2002/08/13 00:26:51 pjack Exp $\n  */\n public class BufferUtils {\n+\n+\n+    private BufferUtils() {\n+    }\n \n \n     /**\n         return new SynchronizedBuffer(buf) {\n \n             public synchronized boolean add(Object o) {\n-                boolean r = b.add(o);\n+                boolean r = collection.add(o);\n                 notify();\n                 return r;\n             }\n \n             public synchronized boolean addAll(Collection c) {\n-                boolean r = b.addAll(c);\n+                boolean r = collection.addAll(c);\n                 notifyAll();\n                 return r;\n             }\n \n             public synchronized Object get() {\n-                while (b.isEmpty()) {\n+                while (collection.isEmpty()) {\n                     try {\n                         wait();\n                     } catch (InterruptedException e) {\n                         throw new BufferUnderflowException();\n                     }\n                 }\n-                return b.get();\n+                return ((Buffer)collection).get();\n             }\n \n             public synchronized Object remove() {\n-                while (b.isEmpty()) {\n+                while (collection.isEmpty()) {\n                     try {\n                         wait();\n                     } catch (InterruptedException e) {\n                         throw new BufferUnderflowException();\n                     }\n                 }\n-                return b.remove();\n+                return ((Buffer)collection).remove();\n             }\n         };\n-    }\n-\n-\n-    private static class SynchronizedBuffer implements Buffer {\n-\n-            Buffer b;\n-\n-\n-            public SynchronizedBuffer(Buffer b) {\n-                 this.b = b;\n-            }\n-\n-            public synchronized int size() {\n-                return b.size();\n-            }\n-\n-            public synchronized boolean isEmpty() {\n-                return b.isEmpty();\n-            }\n-\n-            public synchronized boolean contains(Object o) {\n-                return b.contains(o);\n-            }\n-\n-            public Iterator iterator() {\n-                return b.iterator();\n-            }\n-\n-            public synchronized Object[] toArray() {\n-                return b.toArray();\n-            }\n-\n-            public synchronized Object[] toArray(Object[] o) {\n-                return b.toArray(o);\n-            }\n-\n-            public synchronized boolean add(Object o) {\n-                return b.add(o);\n-            }\n-\n-            public synchronized boolean remove(Object o) {\n-                return b.remove(o);\n-            }\n-\n-            public synchronized boolean containsAll(Collection c) {\n-                return b.containsAll(c);\n-            }\n-\n-            public synchronized boolean addAll(Collection c) {\n-                return b.addAll(c);\n-            }\n-\n-            public synchronized boolean removeAll(Collection c) {\n-                return b.removeAll(c);\n-            }\n-\n-            public synchronized boolean retainAll(Collection c) {\n-                return b.retainAll(c);\n-            }\n-\n-            public synchronized void clear() {\n-                b.clear();\n-            }\n-\n-            public synchronized boolean equals(Object o) {\n-                return b.equals(o);\n-            }\n-\n-            public synchronized int hashCode() {\n-                return b.hashCode();\n-            }\n-\n-            public synchronized String toString() {\n-                return b.toString();\n-            }\n-\n-            public synchronized Object get() {\n-                return b.get();\n-            }\n-\n-            public synchronized Object remove() {\n-                return b.remove();\n-            }          \n-\n-        \n     }\n \n \n      *  @return  an unmodifiable buffer backed by that buffer\n      */\n     public static Buffer unmodifiableBuffer(Buffer b) {\n-        return new BufferDecorator(b) {\n-            public boolean addAll(Collection c) {\n-                throw new UnsupportedOperationException();\n-            } \n-\n-            public boolean removeAll(Collection c) {\n-                throw new UnsupportedOperationException();\n-            } \n-\n-            public boolean retainAll(Collection c) {\n-                throw new UnsupportedOperationException();\n-            } \n-\n-            public boolean add(Object o) {\n-                throw new UnsupportedOperationException();\n-            } \n-\n-            public boolean remove(Object o) {\n-                throw new UnsupportedOperationException();\n-            } \n-\n-            public void clear() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            public Object remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n+        return new UnmodifiableBuffer(b);\n     }\n \n \n      *  @return  a predicated buffer\n      */\n     public static Buffer predicatedBuffer(Buffer buf, final Predicate p) {\n-        if (buf == null) {\n-            throw new IllegalArgumentException(\"Buffer must not be null.\");\n-        }\n-        if (p == null) {\n-            throw new IllegalArgumentException(\"Predicate must not be null.\");\n-        }\n-        return new BufferDecorator(buf) {\n-\n-            public boolean add(Object o) {\n-                test(o);\n-                return b.add(o);\n-            }\n-\n-            public boolean addAll(Collection c) {\n-                Iterator iterator = c.iterator();\n-                while (iterator.hasNext()) {\n-                    test(iterator.next());\n-                }\n-                return b.addAll(c);\n-            }\n-\n-            private void test(Object o) {\n-                if (!p.evaluate(o)) {\n-                    throw new IllegalArgumentException(\"Invalid: \" + o);\n-                }\n-            }\n-        };\n-    }\n-\n-\n-    private static class BufferDecorator implements Buffer {\n-\n-        Buffer b;\n-\n-        BufferDecorator(Buffer b) {\n-            this.b = b;\n-        }\n-\n-        public int size() {\n-            return b.size();\n-        }\n-\n-        public boolean isEmpty() {\n-            return b.isEmpty();\n-        }\n-\n-        public boolean contains(Object o) {\n-            return b.contains(o);\n-        }\n-\n-        public Iterator iterator() {\n-            return b.iterator();\n-        }\n-\n-        public Object[] toArray() {\n-            return b.toArray();\n-        }\n-\n-        public Object[] toArray(Object[] o) {\n-            return b.toArray(o);\n-        }\n-\n-        public boolean add(Object o) {\n-            return b.add(o);\n-        }\n-\n-        public boolean remove(Object o) {\n-            return b.remove(o);\n-        }\n-\n-        public boolean containsAll(Collection c) {\n-            return b.containsAll(c);\n-        }\n-\n-        public boolean addAll(Collection c) {\n-            return b.addAll(c);\n-        }\n-\n-        public boolean removeAll(Collection c) {\n-            return b.removeAll(c);\n-        }\n-\n-        public boolean retainAll(Collection c) {\n-            return b.retainAll(c);\n-        }\n-\n-        public void clear() {\n-            b.clear();\n-        }\n-\n-        public boolean equals(Object o) {\n-            return b.equals(o);\n-        }\n-\n-        public int hashCode() {\n-            return b.hashCode();\n-        }\n-\n-        public String toString() {\n-            return b.toString();\n+        return new PredicatedBuffer(buf, p);\n+    }\n+\n+\n+    public static Buffer boundedBuffer(Buffer buf, int maxSize) {\n+        return new BoundedBuffer(buf, maxSize);\n+    }\n+\n+\n+    private static class SynchronizedBuffer \n+    extends CollectionUtils.SynchronizedCollection\n+    implements Buffer {\n+\n+        public SynchronizedBuffer(Buffer b) {\n+            super(b);\n+        }\n+\n+        public synchronized Object get() {\n+            return ((Buffer)collection).get();\n+        }\n+\n+        public synchronized Object remove() {\n+            return ((Buffer)collection).remove();\n+        }        \n+    }\n+\n+\n+    private static class UnmodifiableBuffer \n+    extends CollectionUtils.UnmodifiableCollection\n+    implements Buffer {\n+\n+        public UnmodifiableBuffer(Buffer b) {\n+            super(b);\n         }\n \n         public Object get() {\n-            return b.get();\n+            return ((Buffer)collection).get();\n         }\n \n         public Object remove() {\n-            return b.remove();\n-        }\n-    }\n-\n+            throw new UnsupportedOperationException();\n+        }\n+\n+    }\n+\n+\n+    private static class PredicatedBuffer \n+    extends CollectionUtils.PredicatedCollection\n+    implements Buffer {\n+\n+        public PredicatedBuffer(Buffer b, Predicate p) {\n+            super(b, p);\n+        }\n+\n+        public Object get() {\n+            return ((Buffer)collection).get();\n+        }\n+\n+        public Object remove() {\n+            return ((Buffer)collection).remove();\n+        }\n+\n+    }\n+\n+\n+    private static class BoundedBuffer\n+    extends CollectionUtils.BoundedCollection\n+    implements Buffer {\n+\n+        public BoundedBuffer(Buffer b, int maxSize) {\n+            super(b, maxSize);\n+        }\n+\n+        public Object get() {\n+            return ((Buffer)collection).get();\n+        }\n+\n+        public Object remove() {\n+            return ((Buffer)collection).remove();\n+        }\n+\n+    }\n \n }\n--- a/src/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/java/org/apache/commons/collections/CollectionUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.9 2002/08/10 00:36:34 pjack Exp $\n- * $Revision: 1.9 $\n- * $Date: 2002/08/10 00:36:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/CollectionUtils.java,v 1.10 2002/08/13 00:26:51 pjack Exp $\n+ * $Revision: 1.10 $\n+ * $Date: 2002/08/13 00:26:51 $\n  *\n  * ====================================================================\n  *\n  * @author Rodney Waldhoff\n  *\n  * @since 1.0\n- * @version $Id: CollectionUtils.java,v 1.9 2002/08/10 00:36:34 pjack Exp $\n+ * @version $Id: CollectionUtils.java,v 1.10 2002/08/13 00:26:51 pjack Exp $\n  */\n public class CollectionUtils {\n \n         }\n         return 0;\n     }\n+\n+\n+    /**\n+     *  Base class for collection decorators.  I decided to do it this way\n+     *  because it seemed to result in the most reuse.  \n+     *\n+     *  Inner class tree looks like:\n+     *       CollectionWrapper\n+     *          PredicatedCollection\n+     *             PredicatedSet\n+     *             PredicatedList\n+     *             PredicatedBag\n+     *          BoundedCollection\n+     *             BoundedSet\n+     *             BoundedList\n+     *             BoundedBag\n+     *          LazyCollection\n+     *             LazyList\n+     *             LazyBag\n+     *       SynchronizedCollection\n+     *          SynchronizedBuffer\n+     *          SynchronizedBag\n+     */\n+    static class CollectionWrapper implements Collection {\n+\n+        final protected Collection collection;\n+\n+        public CollectionWrapper(Collection collection) {\n+            if (collection == null) {\n+                throw new IllegalArgumentException(\"Collection must not be null.\");\n+            }\n+            this.collection = collection;\n+        }\n+\n+        public int size() {\n+            return collection.size();\n+        }\n+\n+        public boolean isEmpty() {\n+            return collection.isEmpty();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return collection.contains(o);\n+        }\n+\n+        public Iterator iterator() {\n+            return collection.iterator();\n+        }\n+\n+        public Object[] toArray() {\n+            return collection.toArray();\n+        }\n+\n+        public Object[] toArray(Object[] o) {\n+            return collection.toArray(o);\n+        }\n+\n+        public boolean add(Object o) {\n+            return collection.add(o);\n+        }\n+\n+        public boolean remove(Object o) {\n+            return collection.remove(o);\n+        }\n+\n+        public boolean containsAll(Collection c2) {\n+            return collection.containsAll(c2);\n+        }\n+\n+        public boolean addAll(Collection c2) {\n+            return collection.addAll(c2);\n+        }\n+\n+        public boolean removeAll(Collection c2) {\n+            return collection.removeAll(c2);\n+        }\n+\n+        public boolean retainAll(Collection c2) {\n+            return collection.retainAll(c2);\n+        }\n+\n+        public void clear() {\n+            collection.clear();\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            return collection.equals(o);\n+        }\n+\n+        public int hashCode() {\n+            return collection.hashCode();\n+        }\n+\n+        public String toString() {\n+            return collection.toString();\n+        }\n+\n+    }\n+\n+\n+    static class PredicatedCollection extends CollectionWrapper {\n+\n+        final protected Predicate predicate;\n+\n+        public PredicatedCollection(Collection c, Predicate p) {\n+            super(c);\n+            if (p == null) {\n+                throw new IllegalArgumentException(\"Predicate must not be null.\");\n+            }\n+            this.predicate = p;\n+            for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n+                validate(iter.next());\n+            }\n+        }\n+\n+        public boolean add(Object o) {\n+            validate(o);\n+            return collection.add(o);\n+        }\n+\n+\n+        public boolean addAll(Collection c2) {\n+            for (Iterator iter = c2.iterator(); iter.hasNext(); ) {\n+                validate(iter.next());\n+            }\n+            return collection.addAll(c2);\n+        }\n+\n+\n+        protected void validate(Object o) {\n+            if (!predicate.evaluate(o)) {\n+                throw new IllegalArgumentException(\"Object failed predicate.\");\n+            }\n+        }\n+\n+    }\n+\n+\n+    static class UnmodifiableCollection extends CollectionWrapper {\n+\n+\n+        public UnmodifiableCollection(Collection c) {\n+            super(c);\n+        }\n+\n+        public boolean add(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean remove(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean removeAll(Collection c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean retainAll(Collection c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public void clear() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Iterator iterator() {\n+            return new UnmodifiableIterator(collection.iterator());\n+        }\n+\n+    }\n+\n+\n+    static class BoundedCollection extends CollectionWrapper {\n+\n+        final protected int maxSize;\n+\n+\n+        public BoundedCollection(Collection c, int maxSize) {\n+            super(c);\n+            this.maxSize = maxSize;\n+        }\n+\n+        public boolean add(Object o) {\n+            if (!collection.contains(o)) {\n+                validate(1);\n+            }\n+            return collection.add(o);\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            int delta = 0;\n+            for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n+                if (!collection.contains(iter.next())) delta++;\n+            }\n+            validate(delta);\n+            return collection.addAll(c);\n+        }\n+\n+\n+        protected void validate(int delta) {\n+            if (delta + size() > maxSize) {\n+                throw new IllegalStateException(\"Maximum size reached.\");\n+            }\n+        }\n+\n+    }\n+\n+\n+\n+\n+    static class SynchronizedCollection {\n+\n+        final protected Collection collection;\n+\n+        public SynchronizedCollection(Collection collection) {\n+            if (collection == null) {\n+                throw new IllegalArgumentException(\"Collection must not be null.\");\n+            }\n+            this.collection = collection;\n+        }\n+\n+        public synchronized int size() {\n+            return collection.size();\n+        }\n+\n+        public synchronized boolean isEmpty() {\n+            return collection.isEmpty();\n+        }\n+\n+        public synchronized boolean contains(Object o) {\n+            return collection.contains(o);\n+        }\n+\n+        public Iterator iterator() {\n+            return collection.iterator();\n+        }\n+\n+        public synchronized Object[] toArray() {\n+            return collection.toArray();\n+        }\n+\n+        public synchronized Object[] toArray(Object[] o) {\n+            return collection.toArray(o);\n+        }\n+\n+        public synchronized boolean add(Object o) {\n+            return collection.add(o);\n+        }\n+\n+        public synchronized boolean remove(Object o) {\n+            return collection.remove(o);\n+        }\n+\n+        public synchronized boolean containsAll(Collection c2) {\n+            return collection.containsAll(c2);\n+        }\n+\n+        public synchronized boolean addAll(Collection c2) {\n+            return collection.addAll(c2);\n+        }\n+\n+        public synchronized boolean removeAll(Collection c2) {\n+            return collection.removeAll(c2);\n+        }\n+\n+        public synchronized boolean retainAll(Collection c2) {\n+            return collection.retainAll(c2);\n+        }\n+\n+        public synchronized void clear() {\n+            collection.clear();\n+        }\n+\n+        public synchronized boolean equals(Object o) {\n+            return collection.equals(o);\n+        }\n+\n+        public synchronized int hashCode() {\n+            return collection.hashCode();\n+        }\n+\n+        public synchronized String toString() {\n+            return collection.toString();\n+        }\n+\n+    }\n+\n+\n+    static class UnmodifiableIterator implements Iterator {\n+\n+        final protected Iterator iterator;\n+\n+        public UnmodifiableIterator(Iterator iterator) {\n+            this.iterator = iterator;\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public Object next() {\n+            return iterator.next();\n+        }\n+\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated collection backed by the given collection.\n+     *  Only objects that pass the test in the given predicate can be \n+     *  added to the collection.\n+     *  It is important not to use the original collection after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param b  the collection to predicate\n+     *  @param p  the predicate for the collection\n+     *  @return  a predicated collection backed by the given collection\n+     */\n+    public static Collection predicatedCollection(Collection c, Predicate p) {\n+        return new PredicatedCollection(c, p);\n+    }\n+\n+\n }\n--- a/src/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/java/org/apache/commons/collections/ListUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ListUtils.java,v 1.4 2002/06/12 03:59:15 mas Exp $\n- * $Revision: 1.4 $\n- * $Date: 2002/06/12 03:59:15 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/ListUtils.java,v 1.5 2002/08/13 00:26:51 pjack Exp $\n+ * $Revision: 1.5 $\n+ * $Date: 2002/08/13 00:26:51 $\n  *\n  * ====================================================================\n  *\n package org.apache.commons.collections;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.ListIterator;\n \n /**\n- * Miscelaneous utilities to manipulate Lists.\n+ * Contains static utility methods and decorators for {@link List} \n+ * instances.\n  *\n  * @since 1.0\n  * @author  <a href=\"mailto:fede@apache.org\">Federico Barbieri</a>\n  * @author  <a href=\"mailto:donaldp@apache.org\">Peter Donald</a>\n- * @deprecated See {@link org.apache.commons.collections.CollectionUtils}.\n+ * @author Paul Jack\n  */\n public class ListUtils\n {\n         result.addAll( list2 );\n         return result;\n     }\n+\n+\n+    static class ListIteratorWrapper implements ListIterator {\n+\n+        final protected ListIterator iterator;\n+\n+        public ListIteratorWrapper(ListIterator iterator) {\n+            this.iterator = iterator;\n+        }\n+\n+        public boolean hasNext() {\n+            return iterator.hasNext();\n+        }\n+\n+        public Object next() {\n+            return iterator.next();\n+        }\n+\n+        public boolean hasPrevious() {\n+            return iterator.hasPrevious();\n+        }\n+\n+        public Object previous() {\n+            return iterator.previous();\n+        }\n+\n+        public int nextIndex() {\n+            return iterator.nextIndex();\n+        }\n+\n+        public int previousIndex() {\n+            return iterator.previousIndex();\n+        }\n+\n+        public void remove() {\n+            iterator.remove();\n+        }\n+\n+        public void set(Object o) {\n+            iterator.set(o);\n+        }\n+\n+        public void add(Object o) {\n+            iterator.add(o);\n+        }\n+\n+    }\n+\n+\n+    static class PredicatedList extends CollectionUtils.PredicatedCollection\n+    implements List {\n+\n+        public PredicatedList(List list, Predicate p) {\n+            super(list, p);\n+        }\n+\n+        public boolean addAll(int i, Collection c) {\n+            for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n+                validate(iter.next());\n+            }\n+            return getList().addAll(i, c);\n+        }\n+\n+        public Object get(int i) {\n+            return getList().get(i);\n+        }\n+\n+        public Object set(int i, Object o) {\n+            validate(o);\n+            return getList().set(i, o);\n+        }\n+\n+        public void add(int i, Object o) {\n+            validate(o);\n+            getList().add(i, o);\n+        }\n+\n+        public Object remove(int i) {\n+            return getList().remove(i);\n+        }\n+\n+        public int indexOf(Object o) {\n+            return getList().indexOf(o);\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            return getList().lastIndexOf(o);\n+        }\n+\n+        public ListIterator listIterator() {\n+            return listIterator(0);\n+        }\n+\n+        public ListIterator listIterator(int i) {\n+            return new ListIteratorWrapper(getList().listIterator(i)) {\n+                public void add(Object o) {\n+                    validate(o);\n+                    iterator.add(o);\n+                }\n+\n+                public void set(Object o) {\n+                    validate(o);\n+                    iterator.set(o);\n+                }\n+            };\n+        }\n+\n+        public List subList(int i1, int i2) {\n+            List sub = getList().subList(i1, i2);\n+            return new PredicatedList(sub, predicate);\n+        }\n+\n+        private List getList() {\n+            return (List)collection;\n+        }\n+\n+    }\n+\n+\n+    static class FixedSizeList extends CollectionUtils.UnmodifiableCollection\n+    implements List {\n+\n+        public FixedSizeList(List list) {\n+            super(list);\n+        }\n+\n+        public boolean addAll(int i, Collection c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Object get(int i) {\n+            return getList().get(i);\n+        }\n+\n+        public Object set(int i, Object o) {\n+            return getList().set(i, o);\n+        }\n+\n+        public void add(int i, Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Object remove(int i) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public int indexOf(Object o) {\n+            return getList().indexOf(o);\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            return getList().lastIndexOf(o);\n+        }\n+\n+        public ListIterator listIterator() {\n+            return listIterator(0);\n+        }\n+\n+        public ListIterator listIterator(int i) {\n+            return new ListIteratorWrapper(getList().listIterator(i)) {\n+                public void remove() {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                public void add(Object o) {\n+                    throw new UnsupportedOperationException();\n+                }\n+\n+                public void remove(Object o) {\n+                    throw new UnsupportedOperationException();\n+                }\n+            };\n+        }\n+\n+        public List subList(int i1, int i2) {\n+            List sub = getList().subList(i1, i2);\n+            return new FixedSizeList(sub);\n+        }\n+\n+        private List getList() {\n+            return (List)collection;\n+        }\n+\n+    }\n+\n+\n+    static class BoundedList extends CollectionUtils.CollectionWrapper \n+    implements List {\n+\n+        final protected int maxSize;\n+\n+        public BoundedList(List list, int maxSize) {\n+            super(list);\n+            this.maxSize = maxSize;\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            validate(c.size());\n+            return collection.addAll(c);\n+        }\n+\n+        public boolean add(Object o) {\n+            validate(1);\n+            return collection.add(o);\n+        }\n+\n+        public boolean addAll(int i, Collection c) {\n+            validate(c.size());\n+            return getList().addAll(i, c);\n+        }\n+\n+        public void add(int i, Object o) {\n+            validate(1);\n+            getList().add(i, o);\n+        }\n+\n+        public Object get(int i) {\n+            return getList().get(i);\n+        }\n+\n+        public Object set(int i, Object o) {\n+            return getList().set(i, o);\n+        }\n+\n+        public Object remove(int i) {\n+            return getList().remove(i);\n+        }\n+\n+        public int indexOf(Object o) {\n+            return getList().indexOf(o);\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            return getList().lastIndexOf(o);\n+        }\n+\n+        public ListIterator listIterator() {\n+            return listIterator(0);\n+        }\n+\n+        public ListIterator listIterator(int i) {\n+            return new ListIteratorWrapper(getList().listIterator(i)) {\n+                public void add(Object o) {\n+                    validate(1);\n+                    iterator.add(o);\n+                }\n+            };\n+        }\n+\n+        public List subList(int i1, int i2) {\n+            return getList().subList(i1, i2);\n+        }\n+\n+        private List getList() {\n+            return (List)collection;\n+        }\n+\n+        private void validate(int delta) {\n+            if (delta + size() > maxSize) {\n+                throw new IllegalStateException(\"Maximum size reached.\");\n+            }\n+        }\n+\n+    }\n+\n+\n+    static class LazyList extends CollectionUtils.CollectionWrapper \n+    implements List {\n+\n+        final protected SimpleObjectFactory factory;\n+\n+        public LazyList(List list, SimpleObjectFactory factory) {\n+            super(list);\n+            this.factory = factory;\n+        }\n+\n+        \n+        /* Proxy method to the impl's get method. With the exception that if it's out\n+         * of bounds, then the collection will grow, leaving place-holders in its\n+         * wake, so that an item can be set at any given index. Later the\n+         * place-holders are removed to return to a pure collection.\n+         *\n+         * If there's a place-holder at the index, then it's replaced with a proper\n+         * object to be used.\n+         */\n+        public Object get(int index) {\n+            Object obj;\n+            if (index < (getList().size())) {\n+            /* within bounds, get the object */\n+                obj = getList().get(index);\n+                if (obj == null) {\n+                    /* item is a place holder, create new one, set and return */\n+                    obj = this.factory.createObject();\n+                    this.getList().set(index, obj);\n+                    return obj;\n+                } else {\n+                    /* good and ready to go */\n+                    return obj;\n+                }\n+            } else {\n+                /* we have to grow the list */\n+                for (int i = getList().size(); i < index; i++) {\n+                    getList().add(null);\n+                }\n+                /* create our last object, set and return */\n+                obj = this.factory.createObject();\n+                getList().add(obj);\n+                return obj;\n+            }\n+        }\n+\n+\n+        /* proxy the call to the provided list implementation. */\n+        public List subList(int fromIndex, int toIndex) {\n+            /* wrap the returned sublist so it can continue the functionality */\n+            return new LazyList(getList().subList(fromIndex, toIndex), factory);\n+        }\n+\n+        public boolean addAll(int i, Collection c) {\n+            return getList().addAll(i, c);\n+        }\n+\n+        public Object set(int i, Object o) {\n+            return getList().set(i, o);\n+        }\n+\n+        public void add(int i, Object o) {\n+            getList().add(i, o);\n+        }\n+\n+        public Object remove(int i) {\n+            return getList().remove(i);\n+        }\n+\n+        public int indexOf(Object o) {\n+            return getList().indexOf(o);\n+        }\n+\n+        public int lastIndexOf(Object o) {\n+            return getList().lastIndexOf(o);\n+        }\n+\n+        public ListIterator listIterator() {\n+            return getList().listIterator();\n+        }\n+\n+        public ListIterator listIterator(int i) {\n+            return getList().listIterator(i);\n+        }\n+\n+        private List getList() {\n+            return (List)collection;\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated list backed by the given list.  Only objects\n+     *  that pass the test in the given predicate can be added to the list.\n+     *  It is important not to use the original list after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param list  the list to predicate\n+     *  @param p  the predicate for the list\n+     *  @return  a predicated list backed by the given list\n+     */\n+    public static List predicatedList(List list, Predicate p) {\n+        return new PredicatedList(list, p);\n+    }\n+\n+\n+    /**\n+     *  Returns a \"lazy\" list whose elements will be created on demand.<P>\n+     *  <P>\n+     *  When the index passed to the returned list's {@link List#get(int) get}\n+     *  method is greater than the list's size, then the factory will be used\n+     *  to create a new object and that object will be inserted at that index.\n+     *  <P>\n+     *  For instance:\n+     *\n+     *  <Pre>\n+     *  SimpleObjectFactory factory = new SimpleObjectFactory() {\n+     *      public Object createObject() {\n+     *          return new Date();\n+     *      }\n+     *  }\n+     *  List lazy = ListUtils.lazyList(new ArrayList(), factory);\n+     *  Object obj = lazy.get(3);\n+     *  </Pre>\n+     *\n+     *  After the above code is executed, <Code>obj</Code> will contain\n+     *  a new <Code>Date</Code> instance.  Furthermore, that <Code>Date</Code>\n+     *  instance is the fourth element in the list.  The first, second, \n+     *  and third element are all set to <Code>null</Code>.<P>\n+     *\n+     *  @param list  the list to make lazy\n+     *  @param factory  the factory for creating new objects\n+     *  @return a lazy list backed by the given list\n+     */\n+    public static List lazyList(List list, SimpleObjectFactory factory) {\n+        return new LazyList(list, factory);\n+    }\n+\n+\n+    /**\n+     *  Returns a fixed-sized list backed by the given list.\n+     *  Elements may not be added or removed from the returned list, but \n+     *  existing elements can be changed (for instance, via the \n+     *  {@link List#set(int,Object)} method).\n+     *\n+     *  @param list  the list whose size to fix\n+     *  @return  a fixed-size list backed by that list\n+     */\n+    public static List fixedSizeList(List list) {\n+        return new FixedSizeList(list);\n+    }\n+\n+\n+    /**\n+     *  Returns a bounded list backed by the given list.\n+     *  New elements may only be added to the returned list if its \n+     *  size is less than the specified maximum; otherwise, an\n+     *  {@link IllegalStateException} will be thrown.\n+     *\n+     *  @param list  the list whose size to bind\n+     *  @param maxSize  the maximum size of the returned list\n+     *  @return  a bounded list \n+     */\n+    public static List boundedList(List list, int maxSize) {\n+        return new BoundedList(list, maxSize);\n+    }\n+\n+\n }\n--- a/src/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/java/org/apache/commons/collections/MapUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.5 2002/06/12 03:59:15 mas Exp $\n- * $Revision: 1.5 $\n- * $Date: 2002/06/12 03:59:15 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/MapUtils.java,v 1.6 2002/08/13 00:26:51 pjack Exp $\n+ * $Revision: 1.6 $\n+ * $Date: 2002/08/13 00:26:51 $\n  *\n  * ====================================================================\n  *\n   * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan</a>\n   * @author <a href=\"mailto:nissim@nksystems.com\">Nissim Karpenstein</a>\n   * @author <a href=\"mailto:knielsen@apache.org\">Kasper Nielsen</a>\n+  * @author Paul Jack\n   */\n public class MapUtils {\n \n     }\n     \n     protected static void logInfo(Exception e) {\n-        // XXXX: should probably use log4j here instead...\n+        // mapX: should probably use log4j here instead...\n         System.out.println( \"INFO: Exception: \" + e );\n     }\n \n     }\n \n \n+    static class PredicatedMap extends ProxyMap {\n+\n+        final protected Predicate keyPredicate;\n+        final protected Predicate valuePredicate;\n+\n+\n+        public PredicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n+            super(map);\n+            this.keyPredicate = keyPred;\n+            this.valuePredicate = valuePred;\n+            Iterator iter = map.entrySet().iterator();\n+            while (iter.hasNext()) {\n+                Map.Entry entry = (Map.Entry)iter.next();\n+                Object key = entry.getKey();\n+                Object value = entry.getValue();\n+                validate(key, value);\n+            }\n+        }\n+\n+        public Object put(Object key, Object value) {\n+            validate(key, value);\n+            return map.put(key, value);\n+        }\n+\n+        public void putAll(Map m) {\n+            Iterator iter = m.entrySet().iterator();\n+            while (iter.hasNext()) {\n+                Map.Entry entry = (Map.Entry)iter.next();\n+                Object key = entry.getKey();\n+                Object value = entry.getValue();\n+                validate(key, value);\n+            }\n+            map.putAll(m);\n+        }\n+\n+        public Set entrySet() {\n+            return new PredicatedMapEntrySet(map.entrySet(), valuePredicate);\n+        }\n+\n+\n+        private void validate(Object key, Object value) {\n+            if (!keyPredicate.evaluate(key)) {\n+                throw new IllegalArgumentException(\"Invalid key.\");\n+            }\n+            if (!valuePredicate.evaluate(value)) {\n+                throw new IllegalArgumentException(\"Invalid value.\");\n+            }\n+        }\n+    }\n+\n+\n+    static class PredicatedMapEntrySet \n+    extends CollectionUtils.CollectionWrapper\n+    implements Set {\n+\n+        final private Predicate predicate;\n+\n+        public PredicatedMapEntrySet(Set set, Predicate p) {\n+            super(set);\n+            this.predicate = p;\n+        }\n+\n+        public Iterator iterator() {\n+            final Iterator iterator = collection.iterator();\n+            return new Iterator() {\n+                public boolean hasNext() {\n+                    return iterator.hasNext();\n+                }\n+\n+                public Object next() {\n+                    Map.Entry entry = (Map.Entry)iterator.next();\n+                    return new PredicatedMapEntry(entry, predicate);\n+                }\n+\n+                public void remove() {\n+                    iterator.remove();\n+                }\n+            };\n+        }\n+    }\n+\n+\n+    static class PredicatedMapEntry implements Map.Entry {\n+\n+        final private Map.Entry entry;\n+        final private Predicate predicate;\n+\n+\n+        public PredicatedMapEntry(Map.Entry entry, Predicate p) {\n+            this.entry = entry;\n+            this.predicate = p;\n+        }\n+\n+        public boolean equals(Object o) {\n+            return entry.equals(o);\n+        }\n+\n+        public int hashCode() {\n+            return entry.hashCode();\n+        }\n+\n+        public String toString() {\n+            return entry.toString();\n+        }\n+\n+        public Object getKey() {\n+            return entry.getKey();\n+        }\n+\n+        public Object getValue() {\n+            return entry.getValue();\n+        }\n+\n+        public Object setValue(Object o) {\n+            if (!predicate.evaluate(o)) {\n+                throw new IllegalArgumentException(\"Invalid value.\");\n+            }\n+            return entry.setValue(o);\n+        }\n+    }\n+\n+\n+    static class BoundedMap extends ProxyMap {\n+\n+        final protected int maxSize;\n+\n+        public BoundedMap(Map map, int maxSize) {\n+            super(map);\n+            this.maxSize = maxSize;\n+        }\n+\n+        public Object put(Object key, Object value) {\n+            if (!containsKey(key)) validate(1);\n+            return map.put(key, value);\n+        }\n+\n+        public void putAll(Map m) {\n+            int delta = 0;\n+            for (Iterator iter = m.keySet().iterator(); iter.hasNext(); ) {\n+                 if (!map.containsKey(iter.next())) delta++;\n+            }\n+            validate(delta);\n+            map.putAll(m);\n+        }\n+\n+\n+        protected void validate(int delta) {\n+            if (map.size() + delta > maxSize) {\n+                throw new IllegalStateException(\"Maximum size reached.\");\n+            }\n+        }\n+    }\n+\n+\n+    static class FixedSizeMap extends ProxyMap {\n+\n+        public FixedSizeMap(Map map) {\n+            super(map);\n+        }\n+\n+\n+        public Object put(Object key, Object value) {\n+            if (!map.containsKey(key)) {\n+                throw new IllegalArgumentException(\"Can't add new keys.\");\n+            }\n+            return map.put(key, value);\n+        }\n+\n+\n+        public void putAll(Map m) {\n+            for (Iterator iter = m.keySet().iterator(); iter.hasNext(); ) {\n+                if (!map.containsKey(iter.next())) {\n+                    throw new IllegalArgumentException(\"Can't add new keys.\");\n+                }\n+            }\n+            map.putAll(m);\n+        }\n+\n+    }\n+\n+\n+    static class LazyMap extends ProxyMap {\n+\n+        final protected SimpleObjectFactory factory;\n+\n+\n+        public LazyMap(Map map, SimpleObjectFactory factory) {\n+            super(map);\n+            this.factory = factory;\n+        }\n+\n+\n+        public Object get(Object key) {\n+            if (!map.containsKey(key)) {\n+                Object value = factory.createObject();\n+                map.put(key, value);\n+                return value;\n+            }\n+            return map.get(key);\n+        }\n+\n+    }\n+\n+\n+\n+    static class PredicatedSortedMap extends PredicatedMap \n+    implements SortedMap {\n+\n+        public PredicatedSortedMap(SortedMap map, Predicate k, Predicate v) {\n+            super(map, k, v);\n+        }\n+\n+        public Object firstKey() {\n+            return getSortedMap().firstKey();\n+        }\n+\n+\n+        public Object lastKey() {\n+            return getSortedMap().lastKey();\n+        }\n+\n+\n+        public Comparator comparator() {\n+            return getSortedMap().comparator();\n+        }\n+\n+\n+        public SortedMap subMap(Object o1, Object o2) {\n+            SortedMap sub = getSortedMap().subMap(o1, o2);\n+            return new PredicatedSortedMap(sub, keyPredicate, valuePredicate);\n+        }\n+\n+        public SortedMap headMap(Object o1) {\n+            SortedMap sub = getSortedMap().headMap(o1);\n+            return new PredicatedSortedMap(sub, keyPredicate, valuePredicate);\n+        }\n+\n+        public SortedMap tailMap(Object o1) {\n+            SortedMap sub = getSortedMap().tailMap(o1);\n+            return new PredicatedSortedMap(sub, keyPredicate, valuePredicate);\n+        }\n+\n+        private SortedMap getSortedMap() {\n+            return (SortedMap)map;\n+        }\n+\n+    }\n+\n+\n+    static class FixedSizeSortedMap extends FixedSizeMap implements SortedMap {\n+\n+        public FixedSizeSortedMap(SortedMap m) {\n+            super(m);\n+        }\n+\n+        public Object firstKey() {\n+            return getSortedMap().firstKey();\n+        }\n+\n+\n+        public Object lastKey() {\n+            return getSortedMap().lastKey();\n+        }\n+\n+\n+        public Comparator comparator() {\n+            return getSortedMap().comparator();\n+        }\n+\n+\n+        public SortedMap subMap(Object o1, Object o2) {\n+            return new FixedSizeSortedMap(getSortedMap().subMap(o1, o2));\n+        }\n+\n+        public SortedMap headMap(Object o1) {\n+            return new FixedSizeSortedMap(getSortedMap().headMap(o1));\n+        }\n+\n+        public SortedMap tailMap(Object o1) {\n+            return new FixedSizeSortedMap(getSortedMap().tailMap(o1));\n+        }\n+\n+        private SortedMap getSortedMap() {\n+            return (SortedMap)map;\n+        }\n+\n+    }\n+\n+\n+    static class LazySortedMap extends LazyMap implements SortedMap {\n+\n+        public LazySortedMap(SortedMap m, SimpleObjectFactory factory) {\n+            super(m, factory);\n+        }\n+\n+        public Object firstKey() {\n+            return getSortedMap().firstKey();\n+        }\n+\n+\n+        public Object lastKey() {\n+            return getSortedMap().lastKey();\n+        }\n+\n+\n+        public Comparator comparator() {\n+            return getSortedMap().comparator();\n+        }\n+\n+\n+        public SortedMap subMap(Object o1, Object o2) {\n+            return new LazySortedMap(getSortedMap().subMap(o1, o2), factory);\n+        }\n+\n+        public SortedMap headMap(Object o1) {\n+            return new LazySortedMap(getSortedMap().headMap(o1), factory);\n+        }\n+\n+        public SortedMap tailMap(Object o1) {\n+            return new LazySortedMap(getSortedMap().tailMap(o1), factory);\n+        }\n+\n+        private SortedMap getSortedMap() {\n+            return (SortedMap)map;\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated map backed by the given map.  Only keys and\n+     *  values that pass the given predicates can be added to the map.\n+     *  It is important not to use the original map after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param map  the map to predicate\n+     *  @param keyPred  the predicate for keys\n+     *  @param valuePred  the predicate for values\n+     *  @return  a predicated map backed by the given map\n+     */\n+    public static Map predicatedMap(Map map, Predicate keyPred, Predicate valuePred) {\n+        return new PredicatedMap(map, keyPred, valuePred);\n+    }\n+\n+\n+    /**\n+     *  Returns a bounded map backed by the given map.\n+     *  New pairs may only be added to the returned map if its \n+     *  size is less than the specified maximum; otherwise, an\n+     *  {@link IllegalStateException} will be thrown.\n+     *\n+     *  @param b  the map whose size to bind\n+     *  @param maxSize  the maximum size of the returned map\n+     *  @return  a bounded map \n+     */\n+    public static Map boundedMap(Map map, int maxSize) {\n+        return new BoundedMap(map, maxSize);\n+    }\n+\n+\n+    /**\n+     *  Returns a fixed-sized map backed by the given map.\n+     *  Elements may not be added or removed from the returned map, but \n+     *  existing elements can be changed (for instance, via the \n+     *  {@link Map#put(Object,Object)} method).\n+     *\n+     *  @param map  the map whose size to fix\n+     *  @return  a fixed-size map backed by that map\n+     */\n+    public static Map fixedSizeMap(Map map) {\n+        return new FixedSizeMap(map);\n+    }\n+\n+\n+    /**\n+     *  Returns a \"lazy\" map whose values will be created on demand.<P>\n+     *  <P>\n+     *  When the key passed to the returned map's {@link Map#get(Object)}\n+     *  method is not present in the map, then the factory will be used\n+     *  to create a new object and that object will become the value\n+     *  associated with that key.\n+     *  <P>\n+     *  For instance:\n+     *\n+     *  <Pre>\n+     *  SimpleObjectFactory factory = new SimpleObjectFactory() {\n+     *      public Object createObject() {\n+     *          return new Date();\n+     *      }\n+     *  }\n+     *  Map lazy = MapUtils.lazyMap(new HashMap(), factory);\n+     *  Object obj = lazy.get(\"test\");\n+     *  </Pre>\n+     *\n+     *  After the above code is executed, <Code>obj</Code> will contain\n+     *  a new <Code>Date</Code> instance.  Furthermore, that <Code>Date</Code>\n+     *  instance is the value for the <Code>test</Code> key.<P>\n+     *\n+     *  @param map  the map to make lazy\n+     *  @param factory  the factory for creating new objects\n+     *  @return a lazy map backed by the given map\n+     */\n+    public static Map lazyMap(Map map, SimpleObjectFactory factory) {\n+        return new LazyMap(map, factory);\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated sorted map backed by the given map.  Only keys and\n+     *  values that pass the given predicates can be added to the map.\n+     *  It is important not to use the original map after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param map  the map to predicate\n+     *  @param keyPred  the predicate for keys\n+     *  @param valuePred  the predicate for values\n+     *  @return  a predicated map backed by the given map\n+     */\n+    public static SortedMap predicatedSortedMap(SortedMap map, Predicate keyPred, Predicate valuePred) {\n+        return new PredicatedSortedMap(map, keyPred, valuePred);\n+    }\n+\n+\n+    /**\n+     *  Returns a fixed-sized sorted map backed by the given sorted map.\n+     *  Elements may not be added or removed from the returned map, but \n+     *  existing elements can be changed (for instance, via the \n+     *  {@link Map#put(Object,Object)} method).\n+     *\n+     *  @param map  the map whose size to fix\n+     *  @return  a fixed-size map backed by that map\n+     */\n+    public static SortedMap fixedSizeSortedMap(SortedMap map) {\n+        return new FixedSizeSortedMap(map);\n+    }\n+\n+\n+    /**\n+     *  Returns a \"lazy\" sorted map whose values will be created on demand.\n+     *  <P>\n+     *  When the key passed to the returned map's {@link Map#get(Object)}\n+     *  method is not present in the map, then the factory will be used\n+     *  to create a new object and that object will become the value\n+     *  associated with that key.\n+     *  <P>\n+     *  For instance:\n+     *\n+     *  <Pre>\n+     *  SimpleObjectFactory factory = new SimpleObjectFactory() {\n+     *      public Object createObject() {\n+     *          return new Date();\n+     *      }\n+     *  }\n+     *  SortedMap lazy = MapUtils.lazySortedMap(new TreeMap(), factory);\n+     *  Object obj = lazy.get(\"test\");\n+     *  </Pre>\n+     *\n+     *  After the above code is executed, <Code>obj</Code> will contain\n+     *  a new <Code>Date</Code> instance.  Furthermore, that <Code>Date</Code>\n+     *  instance is the value for the <Code>test</Code> key.<P>\n+     *\n+     *  @param map  the map to make lazy\n+     *  @param factory  the factory for creating new objects\n+     *  @return a lazy map backed by the given map\n+     */\n+    public static SortedMap lazySortedMap(SortedMap map, SimpleObjectFactory factory) {\n+        return new LazySortedMap(map, factory);\n+    }\n }\n--- a/src/java/org/apache/commons/collections/PredicateUtils.java\n+++ b/src/java/org/apache/commons/collections/PredicateUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PredicateUtils.java,v 1.2 2002/06/16 03:39:40 mas Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/16 03:39:40 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/PredicateUtils.java,v 1.3 2002/08/13 00:26:51 pjack Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/08/13 00:26:51 $\n  *\n  * ====================================================================\n  *\n \t}\n \n \t/**\n-\t * Create a new Collection that wraps another Collection and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original collection is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param coll  the collection to wrap and restrict\n-\t * @param predicate  the predicate to control what to allow into the collection\n-\t */\n-\tpublic static Collection predicateCollection(Collection coll, Predicate predicate) {\n-         return new PredicateCollection(coll, predicate);\n-    }\n-\n-\t/**\n-\t * Create a new List that wraps another List and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original list is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param list  the list to wrap and restrict\n-\t * @param predicate  the predicate to control what to allow into the list\n-\t */\n-\tpublic static List predicateList(List list, Predicate predicate) {\n-         return new PredicateList(list, predicate);\n-    }\n-\n-\t/**\n-\t * Create a new Set that wraps another Set and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original set is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param set  the set to wrap and restrict\n-\t * @param predicate  the predicate to control what to allow into the set\n-\t */\n-\tpublic static Set predicateSet(Set set, Predicate predicate) {\n-         return new PredicateSet(set, predicate);\n-    }\n-\n-\t/**\n-\t * Create a new SortedSet that wraps another SortedSet and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original set is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param set  the set to wrap and restrict\n-\t * @param predicate  the predicate to control what to allow into the set\n-\t */\n-\tpublic static SortedSet predicateSortedSet(SortedSet set, Predicate predicate) {\n-         return new PredicateSortedSet(set, predicate);\n-    }\n-\n-\t/**\n-\t * Create a new Bag that wraps another Bag and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original bag is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param bag  the bag to wrap and restrict\n-\t * @param predicate  the predicate to control what to allow into the bag\n-\t */\n-\tpublic static Bag predicateBag(Bag bag, Predicate predicate) {\n-         return new PredicateBag(bag, predicate);\n-    }\n-\n-\t/**\n-\t * Create a new SortedBag that wraps another SortedBag and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original bag is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param bag  the bag to wrap and restrict\n-\t * @param predicate  the predicate to control what to allow into the bag\n-\t */\n-\tpublic static SortedBag predicateSortedBag(SortedBag bag, Predicate predicate) {\n-         return new PredicateSortedBag(bag, predicate);\n-    }\n-\n-\t/**\n-\t * Create a new Map that wraps another Map and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original map is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param map  the map to wrap and restrict\n-\t * @param keyPredicate  the predicate to control what to allow into the bag\n-\t * @param valuePredicate  the predicate to control what to allow into the bag\n-\t */\n-\tpublic static Map predicateMap(Map map, Predicate keyPredicate, Predicate valuePredicate) {\n-         return new PredicateMap(map, keyPredicate, valuePredicate);\n-    }\n-\n-\t/**\n-\t * Create a new SortedMap that wraps another SortedMap and validates\n-\t * entries. Only objects that pass the test in the predicate can be\n-\t * added to the list.\n-\t * It is important that the original map is not used again after\n-\t * this call, as it is a backdoor to add non-validated objects.\n-\t * @param map  the map to wrap and restrict\n-\t * @param keyPredicate  the predicate to control what to allow into the bag\n-\t * @param valuePredicate  the predicate to control what to allow into the bag\n-\t */\n-\tpublic static SortedMap predicateSortedMap(SortedMap map, Predicate keyPredicate, Predicate valuePredicate) {\n-         return new PredicateSortedMap(map, keyPredicate, valuePredicate);\n-    }\n-\n-\t/**\n \t * Create a new predicate that returns true only if both of the passed\n \t * in predicates are true.\n \t * @param predicate1  the first predicate\n \t    }\n \t}\n \n-\t/**\n-\t * PredicateCollection validates a Collection\n-\t */\n-\tprivate static class PredicateCollection \n-\t\t\timplements Collection, Serializable {\n-\t\t\t    \n-        /** The predicate to control entry into the collection */\n-        protected final Predicate iPredicate;\n-        /** The collection being wrapped */\n-        protected final Collection iCollection;\n-\t\t\t    \n-    \t/**\n-    \t * Create a new PredicateCollection that wraps another collection.\n-    \t * It is important that the original collection is not used again\n-    \t * after this call, as it is a backdoor to add non-validated objects.\n-    \t * @param coll  the collection to wrap and restrict\n-    \t * @param predicate  the predicate used to validate entry into the list\n-    \t */\n-    \tpublic PredicateCollection(Collection coll, Predicate predicate) {\n-    \t    super();\n-    \t    if (coll == null) {\n-    \t        throw new IllegalArgumentException(\"Collection to be wrapped must not be null\");\n-    \t    }\n-    \t    if (predicate == null) {\n-    \t        throw new IllegalArgumentException(\"Predicate must not be null\");\n-    \t    }\n-    \t    iPredicate = predicate;\n-    \t    iCollection = coll;\n-            Iterator it = iCollection.iterator();\n-            while (it.hasNext()) {\n-                validate(iPredicate, it.next());\n-            }\n-    \t}\n-    \n-        /**\n-         * Add an item to the end of the list. If the item is not an instance\n-         * of the list's validation type an exception is thrown. The state of\n-         * the list will be unaltered if an exception is thrown.\n-         * @see Collection#add(Object)\n-         * @param item  the item to add\n-         * @throws IllegalArgumentException if the object is not of a valid type\n-         */\n-        public boolean add(Object item) {\n-            validate(iPredicate, item);\n-            return iCollection.add(item);\n-        }\n-    \n-        /**\n-         * Add a collection to the end of the list. If any of the items in the\n-         * collection is not an instance of the list's validation type an\n-         * exception is thrown. The state of the list will be unaltered if an\n-         * exception is thrown.\n-         * @see Collection#addAll(Collection)\n-         * @param coll  the collection to add\n-         * @throws IllegalArgumentException if the object is not of a valid type\n-         */\n-        public boolean addAll(Collection coll) {\n-            Iterator it = coll.iterator();\n-            while (it.hasNext()) {\n-    \t        validate(iPredicate, it.next());\n-            }\n-            return iCollection.addAll(coll);\n-        }\n-    \n-        /**\n-         * @see Collection#iterator()\n-         */\n-        public Iterator iterator() {\n-            return iCollection.iterator();\n-        }\n-\n-        /**\n-         * @see Collection#size()\n-         */\n-        public int size() {\n-            return iCollection.size();\n-        }\n-\n-        /**\n-         * @see Collection#clear()\n-         */\n-        public void clear() {\n-            iCollection.clear();\n-        }\n-\n-        /**\n-         * @see Collection#isEmpty()\n-         */\n-        public boolean isEmpty() {\n-            return iCollection.isEmpty();\n-        }\n-\n-        /**\n-         * @see Collection#contains(Object)\n-         */\n-        public boolean contains(Object item) {\n-            return iCollection.contains(item);\n-        }\n-\n-        /**\n-         * @see Collection#containsAll(Collection)\n-         */\n-        public boolean containsAll(Collection coll) {\n-            return iCollection.containsAll(coll);\n-        }\n-\n-        /**\n-         * @see Collection#remove(Object)\n-         */\n-        public boolean remove(Object item) {\n-            return iCollection.remove(item);\n-        }\n-\n-        /**\n-         * @see Collection#removeAll(Collection)\n-         */\n-        public boolean removeAll(Collection coll) {\n-            return iCollection.remove(coll);\n-        }\n-\n-        /**\n-         * @see Collection#retainAll(Collection)\n-         */\n-        public boolean retainAll(Collection coll) {\n-            return iCollection.retainAll(coll);\n-        }\n-\n-        /**\n-         * @see Collection#toArray()\n-         */\n-        public Object[] toArray() {\n-            return iCollection.toArray();\n-        }\n-\n-        /**\n-         * @see Collection#toArray(Object[])\n-         */\n-        public Object[] toArray(Object[] array) {\n-            return iCollection.toArray(array);\n-        }\n-\n-        /**\n-         * @see Object#equals(Object)\n-         */\n-        public boolean equals(Object obj) {\n-            return iCollection.equals(obj);\n-        }\n-    \n-        /**\n-         * @see Object#hashCode()\n-         */\n-        public int hashCode() {\n-            return iCollection.hashCode();\n-        }\n-    \n-        /**\n-         * @see Object#toString()\n-         */\n-        public String toString() {\n-            return iCollection.toString();\n-        }\n-\t}\n-\t\n-\t/**\n-\t * PredicateList validates a List\n-\t */\n-\tprivate static class PredicateList\n-\t\t\textends PredicateCollection\n-\t\t\timplements List {\n-\t\n-    \t/**\n-    \t * Create a new PredicateList that wraps another list.\n-    \t * It is important that the original list is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param list  the list to wrap and restrict\n-    \t * @param predicate  the predicate used to validate entry into the list\n-    \t */\n-    \tpublic PredicateList(List list, Predicate predicate) {\n-    \t    super(list, predicate);\n-    \t}\n-    \t\n-        /**\n-         * Add an item to the list at the specified index. If the item is\n-         * not an instance of the list's validation type an exception is\n-         * thrown. The state of the list will be unaltered if an exception \n-         * is thrown.\n-         * @see List#add(int, Object)\n-         * @param index  the index at which to add the item\n-         * @param item  the item to add\n-         * @throws IllegalArgumentException if the object is not of a valid type\n-         */\n-        public void add(int index, Object item) {\n-            validate(iPredicate, item);\n-            ((List) iCollection).add(index, item);\n-        }\n-    \n-        /**\n-         * Add a collection at the specified index. If any of the items in the\n-         * collection is not an instance of the list's validation type an\n-         * exception is thrown. The state of the list will be unaltered if an\n-         * exception is thrown.\n-         * @see List#addAll(int, Collection)\n-         * @param index  the index at which to add the collection\n-         * @param coll  the collection to add\n-         * @throws IllegalArgumentException if the object is not of a valid type\n-         */\n-        public boolean addAll(int index, Collection coll) {\n-            Iterator it = coll.iterator();\n-            while (it.hasNext()) {\n-    \t        validate(iPredicate, it.next());\n-            }\n-            return ((List) iCollection).addAll(index, coll);\n-        }\n-    \n-        /**\n-         * Set the value at the specified index. If the item is not an instance\n-         * of the list's validation type an exception is thrown. The state of\n-         * the list will be unaltered if an exception is thrown.\n-         * @see List#set(int, Object)\n-         * @param index  the index to change\n-         * @param item  the item to change to\n-         * @throws IllegalArgumentException if the object is not of a valid type\n-         */\n-        public Object set(int index, Object item) {\n-            validate(iPredicate, item);\n-            return ((List) iCollection).set(index, item);\n-        }\n-        \n-        /**\n-         * @see List#listIterator()\n-         */\n-        public ListIterator listIterator() {\n-            return new PredicateListIterator(((List) iCollection).listIterator(), iPredicate);\n-        }\n-    \n-        /**\n-         * @see List#listIterator(int)\n-         */\n-        public ListIterator listIterator(int index) {\n-            return new PredicateListIterator(((List) iCollection).listIterator(index), iPredicate);\n-        }\n-    \n-        /**\n-         * @see List#subList(int, int)\n-         */\n-        public List subList(int fromIndex, int toIndex) {\n-            return new PredicateList(((List) iCollection).subList(fromIndex, toIndex), iPredicate);\n-        }\n-\n-        /**\n-         * @see List#get(int)\n-         */\n-        public Object get(int index) {\n-            return ((List) iCollection).get(index);\n-        }\n-    \n-        /**\n-         * @see List#indexOf(Object)\n-         */\n-        public int indexOf(Object item) {\n-            return ((List) iCollection).indexOf(item);\n-        }\n-    \n-        /**\n-         * @see List#lastIndexOf(Object)\n-         */\n-        public int lastIndexOf(Object item) {\n-            return ((List) iCollection).lastIndexOf(item);\n-        }\n-    \n-        /**\n-         * @see List#remove(int)\n-         */\n-        public Object remove(int index) {\n-            return ((List) iCollection).remove(index);\n-        }\n-\t}\n-\n-\t/**\n-\t * PredicateListIterator handles the list iterator for PredicateList\n-\t */\n-\tprivate static class PredicateListIterator implements ListIterator {\n-\t    \n-\t    private final ListIterator iIterator;\n-\t    private final Predicate iPredicate;\n-\t    \n-\t    /**\n-\t     * Constructor\n-\t     */\n-\t    private PredicateListIterator(ListIterator iterator, Predicate predicate) {\n-\t        super();\n-\t        iIterator = iterator;\n-\t        iPredicate = predicate;\n-\t\t}\n-\t\t\n-        /**\n-         * @see Iterator#hasNext()\n-         */\n-        public boolean hasNext() {\n-            return iIterator.hasNext();\n-        }\n-\n-        /**\n-         * @see ListIterator#hasPrevious()\n-         */\n-        public boolean hasPrevious() {\n-            return iIterator.hasPrevious();\n-        }\n-\n-        /**\n-         * @see Iterator#next()\n-         */\n-        public Object next() {\n-            return iIterator.next();\n-        }\n-\n-        /**\n-         * @see ListIterator#nextIndex()\n-         */\n-        public int nextIndex() {\n-            return iIterator.nextIndex();\n-        }\n-\n-        /**\n-         * @see ListIterator#previous()\n-         */\n-        public Object previous() {\n-            return iIterator.previous();\n-        }\n-\n-        /**\n-         * @see ListIterator#previousIndex()\n-         */\n-        public int previousIndex() {\n-            return iIterator.previousIndex();\n-        }\n-\n-        /**\n-         * @see Iterator#remove()\n-         */\n-        public void remove() {\n-            iIterator.remove();\n-        }\n-\n-        /**\n-         * @see ListIterator#add(Object)\n-         */\n-        public void add(Object item) {\n-\t        validate(iPredicate, item);\n-            iIterator.add(item);\n-        }\n-\n-        /**\n-         * @see ListIterator#set(Object)\n-         */\n-        public void set(Object item) {\n-\t        validate(iPredicate, item);\n-            iIterator.set(item);\n-        }\n-\t}\n-\t\n-\t/**\n-\t * PredicateSet validates a Set\n-\t */\n-\tprivate static class PredicateSet\n-\t\t\textends PredicateCollection\n-\t\t\timplements Set {\n-\t\n-    \t/**\n-    \t * Create a new PredicateSet that wraps another Set.\n-    \t * It is important that the original set is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param set  the set to wrap and restrict\n-    \t * @param predicate  the predicate used to validate entry into the set\n-    \t */\n-    \tpublic PredicateSet(Set set, Predicate predicate) {\n-    \t    super(set, predicate);\n-    \t}\n-\t}\n-\t\n-\t/**\n-\t * PredicateSet validates a SortedSet\n-\t */\n-\tprivate static class PredicateSortedSet\n-\t\t\textends PredicateSet\n-\t\t\timplements SortedSet {\n-\t\n-    \t/**\n-    \t * Create a new PredicateSortedSet that wraps another SortedSet.\n-    \t * It is important that the original SortedSet is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param set  the set to wrap and restrict\n-    \t * @param predicate  the predicate used to validate entry into the SortedSet\n-    \t */\n-    \tpublic PredicateSortedSet(SortedSet set, Predicate predicate) {\n-    \t    super(set, predicate);\n-    \t}\n-    \t\n-        /**\n-         * @see SortedSet#headSet(Object)\n-         */\n-        public SortedSet headSet(Object toElement) {\n-            return new PredicateSortedSet(((SortedSet) iCollection).headSet(toElement), iPredicate);\n-        }\n-    \n-        /**\n-         * @see SortedSet#subSet(Object, Object)\n-         */\n-        public SortedSet subSet(Object fromElement, Object toElement) {\n-            return new PredicateSortedSet(((SortedSet) iCollection).subSet(fromElement, toElement), iPredicate);\n-        }\n-    \n-        /**\n-         * @see SortedSet#tailSet(Object)\n-         */\n-        public SortedSet tailSet(Object fromElement) {\n-            return new PredicateSortedSet(((SortedSet) iCollection).tailSet(fromElement), iPredicate);\n-        }\n-    \n-        /**\n-         * @see SortedSet#first()\n-         */\n-        public Object first() {\n-            return ((SortedSet) iCollection).first();\n-        }\n-    \n-        /**\n-         * @see SortedSet#last()\n-         */\n-        public Object last() {\n-            return ((SortedSet) iCollection).last();\n-        }\n-        \n-        /**\n-         * @see SortedSet#comparator()\n-         */\n-        public Comparator comparator() {\n-            return ((SortedSet) iCollection).comparator();\n-        }\n-\t}\n-\t\n-\t/**\n-\t * PredicateBag validates a Bag\n-\t */\n-\tprivate static class PredicateBag\n-\t\t\textends PredicateCollection\n-\t\t\timplements Bag {\n-\t\n-    \t/**\n-    \t * Create a new PredicateBag that wraps another Bag.\n-    \t * It is important that the original Bag is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param bag  the bag to wrap and restrict\n-    \t * @param predicate  the predicate used to validate entry into the Bag\n-    \t */\n-    \tpublic PredicateBag(Bag bag, Predicate predicate) {\n-    \t    super(bag, predicate);\n-    \t}\n-    \t\n-        /**\n-         * @see Bag#add(Object, int)\n-         */\n-        public boolean add(Object item, int i) {\n-            validate(iPredicate, item);\n-            return ((Bag) iCollection).add(item, i);\n-        }\n-\n-        /**\n-         * @see Bag#getCount(Object)\n-         */\n-        public int getCount(Object item) {\n-            return ((Bag) iCollection).getCount(item);\n-        }\n-\n-        /**\n-         * @see Bag#remove(Object, int)\n-         */\n-        public boolean remove(Object item, int i) {\n-            return ((Bag) iCollection).remove(item, i);\n-        }\n-\n-        /**\n-         * @see Bag#uniqueSet()\n-         */\n-        public Set uniqueSet() {\n-            return ((Bag) iCollection).uniqueSet();\n-        }\n-\t}\n-\t\n-\t/**\n-\t * PredicateSortedBag validates a SortedBag\n-\t */\n-\tprivate static class PredicateSortedBag\n-\t\t\textends PredicateBag\n-\t\t\timplements SortedBag {\n-\t\n-    \t/**\n-    \t * Create a new PredicateSortedBag that wraps another SortedBag.\n-    \t * It is important that the original SortedBag is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param bag  the bag to wrap and restrict\n-    \t * @param predicate  the predicate used to validate entry into the SortedBag\n-    \t */\n-    \tpublic PredicateSortedBag(SortedBag bag, Predicate predicate) {\n-    \t    super(bag, predicate);\n-    \t}\n-    \t\n-        /**\n-         * @see SortedBag#comparator()\n-         */\n-        public Comparator comparator() {\n-            return ((SortedBag) iCollection).comparator();\n-        }\n-\n-        /**\n-         * @see SortedBag#first()\n-         */\n-        public Object first() {\n-            return ((SortedBag) iCollection).first();\n-        }\n-\n-        /**\n-         * @see SortedBag#last()\n-         */\n-        public Object last() {\n-            return ((SortedBag) iCollection).last();\n-        }\n-\t}\n-\t\n-\t/**\n-\t * PredicateBag validates a Map\n-\t */\n-\tprivate static class PredicateMap\n-\t\t\timplements Map {\n-\t\n-        /** The predicate to control entry into the map */\n-        protected final Predicate iKeyPredicate;\n-        /** The predicate to control entry into the map */\n-        protected final Predicate iValuePredicate;\n-        /** The list being wrapped */\n-        protected final Map iMap;\n-\t\t\t    \n-    \t/**\n-    \t * Create a new PredicateMap that wraps another Map.\n-    \t * It is important that the original Map is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param map  the map to wrap and restrict\n-    \t * @param keyPredicate  the predicate used to validate entry into the SortedMap\n-    \t * @param valuePredicate  the predicate used to validate entry into the SortedMap\n-    \t */\n-    \tpublic PredicateMap(Map map, Predicate keyPredicate, Predicate valuePredicate) {\n-    \t    super();\n-    \t    if (map == null) {\n-    \t        throw new IllegalArgumentException(\"Collection to be wrapped must not be null\");\n-    \t    }\n-    \t    if (keyPredicate == null) {\n-    \t        throw new IllegalArgumentException(\"Key Predicate must not be null\");\n-    \t    }\n-    \t    if (valuePredicate == null) {\n-    \t        throw new IllegalArgumentException(\"Value Predicate must not be null\");\n-    \t    }\n-    \t    iKeyPredicate = keyPredicate;\n-    \t    iValuePredicate = valuePredicate;\n-    \t    iMap = map;\n-    \t    for (Iterator it = iMap.keySet().iterator(); it.hasNext();) {\n-                validate(iKeyPredicate, it.next());\n-            }\n-    \t    for (Iterator it = iMap.values().iterator(); it.hasNext();) {\n-                validate(iValuePredicate, it.next());\n-            }\n-    \t}\n-    \t\n-        /**\n-         * @see Map#put(Object, Object)\n-         */\n-        public Object put(Object key, Object value) {\n-            validate(iKeyPredicate, key);\n-            validate(iValuePredicate, value);\n-            return iMap.put(key, value);\n-        }\n-\n-        /**\n-         * @see Map#putAll(Map)\n-         */\n-        public void putAll(Map map) {\n-            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n-\t            validate(iKeyPredicate, entry.getKey());\n-    \t        validate(iValuePredicate, entry.getValue());\n-            }\n-            iMap.putAll(map);\n-        }\n-\n-        /**\n-         * @see Map#entrySet()\n-         */\n-        public Set entrySet() {\n-            return new PredicateMapEntrySet(iMap.entrySet(), iValuePredicate);\n-        }\n-\n-        /**\n-         * @see Map#keySet()\n-         */\n-        public Set keySet() {\n-            return new PredicateSet(iMap.keySet(), iKeyPredicate);\n-        }\n-\n-        /**\n-         * @see Map#values()\n-         */\n-        public Collection values() {\n-            return new PredicateCollection(iMap.values(), iValuePredicate);\n-        }\n-\n-        /**\n-         * @see Map#get(Object)\n-         */\n-        public Object get(Object key) {\n-            return iMap.get(key);\n-        }\n-\n-        /**\n-         * @see Map#size()\n-         */\n-        public int size() {\n-            return iMap.size();\n-        }\n-\n-        /**\n-         * @see Map#clear()\n-         */\n-        public void clear() {\n-            iMap.clear();\n-        }\n-\n-        /**\n-         * @see Map#isEmpty()\n-         */\n-        public boolean isEmpty() {\n-            return iMap.isEmpty();\n-        }\n-\n-        /**\n-         * @see Map#containsKey(Object)\n-         */\n-        public boolean containsKey(Object key) {\n-            return iMap.containsKey(key);\n-        }\n-\n-        /**\n-         * @see Map#containsValue(Object)\n-         */\n-        public boolean containsValue(Object value) {\n-            return iMap.containsValue(value);\n-        }\n-\n-        /**\n-         * @see Map#remove(Object)\n-         */\n-        public Object remove(Object key) {\n-            return iMap.remove(key);\n-        }\n-\n-        /**\n-         * @see Object#equals(Object)\n-         */\n-        public boolean equals(Object obj) {\n-            return iMap.equals(obj);\n-        }\n-    \n-        /**\n-         * @see Object#hashCode()\n-         */\n-        public int hashCode() {\n-            return iMap.hashCode();\n-        }\n-    \n-        /**\n-         * @see Object#toString()\n-         */\n-        public String toString() {\n-            return iMap.toString();\n-        }\n-\t}   \n-\t\n-\t/**\n-\t * PredicateSortedBag validates a SortedMap\n-\t */\n-\tprivate static class PredicateSortedMap\n-\t\t\textends PredicateMap\n-\t\t\timplements SortedMap {\n-\t\n-    \t/**\n-    \t * Create a new PredicateSortedMap that wraps another SortedMap.\n-    \t * It is important that the original SortedBag is not used again after\n-    \t * this call, as it is a backdoor to add non-validated objects.\n-    \t * @param bag  the bag to wrap and restrict\n-    \t * @param keyPredicate  the predicate used to validate entry into the SortedMap\n-    \t * @param valuePredicate  the predicate used to validate entry into the SortedMap\n-    \t */\n-    \tpublic PredicateSortedMap(SortedMap map, Predicate keyPredicate, Predicate valuePredicate) {\n-    \t    super(map, keyPredicate, valuePredicate);\n-    \t}\n-    \t\n-        /**\n-         * @see SortedMap#comparator()\n-         */\n-        public Comparator comparator() {\n-            return ((SortedMap) iMap).comparator();\n-        }\n-\n-        /**\n-         * @see SortedMap#firstKey()\n-         */\n-        public Object firstKey() {\n-            return ((SortedMap) iMap).firstKey();\n-        }\n-\n-        /**\n-         * @see SortedMap#lastKey()\n-         */\n-        public Object lastKey() {\n-            return ((SortedMap) iMap).lastKey();\n-        }\n-\n-        /**\n-         * @see SortedMap#headMap(Object)\n-         */\n-        public SortedMap headMap(Object toKey) {\n-            return new PredicateSortedMap(\n-            \t((SortedMap) iMap).headMap(toKey), iKeyPredicate, iValuePredicate);\n-        }\n-\n-        /**\n-         * @see SortedMap#tailMap(Object)\n-         */\n-        public SortedMap tailMap(Object fromKey) {\n-            return new PredicateSortedMap(\n-            \t((SortedMap) iMap).tailMap(fromKey), iKeyPredicate, iValuePredicate);\n-        }\n-\n-        /**\n-         * @see SortedMap#subMap(Object, Object)\n-         */\n-        public SortedMap subMap(Object fromKey, Object toKey) {\n-            return new PredicateSortedMap(\n-            \t((SortedMap) iMap).subMap(fromKey, toKey), iKeyPredicate, iValuePredicate);\n-        }\n-\t}\n-\t\n-\t/**\n-\t * Map helper class to access iterator\n-\t */\n-\tpublic static class PredicateMapEntrySet\n-\t        extends AbstractSet {\n-\t    private final Set iSet;\n-        private final Predicate iValuePredicate;\n-\t    \n-\t    /**\n-\t     * Constructor\n-\t     */\n-\t    private PredicateMapEntrySet(Set set, Predicate predicate) {\n-\t        super();\n-\t        iSet = set;\n-\t        iValuePredicate = predicate;\n-\t    }\n-            \n-        /**\n-         * @see Collection#clear()\n-         */\n-        public void clear() {\n-            iSet.clear();\n-        }\n-\n-        /**\n-         * @see Collection#iterator()\n-         */\n-        public Iterator iterator() {\n-            return new PredicateMapEntrySetIterator(iSet.iterator(), iValuePredicate);\n-        }\n-\n-        /**\n-         * @see Collection#remove(Object)\n-         */\n-        public boolean remove(Object obj) {\n-            return iSet.remove(obj);\n-        }\n-\n-        /**\n-         * @see Collection#size()\n-         */\n-        public int size() {\n-            return iSet.size();\n-        }\n-\n-\t}\n-\t\n-\t/**\n-\t * Iterator to protect the setValue method of Map.Entry\n-\t */\n-    public static class PredicateMapEntrySetIterator\n-    \t\timplements Iterator {\n-\t    private final Iterator iIterator;\n-        private final Predicate iValuePredicate;\n-\t    \n-\t    /**\n-\t     * Constructor\n-\t     */\n-\t    private PredicateMapEntrySetIterator(Iterator iterator, Predicate predicate) {\n-\t        super();\n-\t        iIterator = iterator;\n-\t        iValuePredicate = predicate;\n-\t    }\n-            \n-        /**\n-         * @see Iterator#next()\n-         */\n-        public Object next() {\n-            Object obj = iIterator.next();\n-            return new PredicateMapEntry((Map.Entry) obj, iValuePredicate);\n-        }\n-\n-        /**\n-         * @see Iterator#hasNext()\n-         */\n-        public boolean hasNext() {\n-            return iIterator.hasNext();\n-        }\n-\n-        /**\n-         * @see Iterator#remove()\n-         */\n-        public void remove() {\n-            iIterator.remove();\n-        }\n-\n-    }\n-    \n-\t/**\n-\t * MapEntry to protect the setValue method\n-\t */\n-    public static class PredicateMapEntry\n-    \t\timplements Map.Entry {\n-\t    private final Map.Entry iEntry;\n-        private final Predicate iValuePredicate;\n-        \n-\t    /**\n-\t     * Constructor\n-\t     */\n-\t    private PredicateMapEntry(Map.Entry entry, Predicate predicate) {\n-\t        super();\n-\t        iEntry = entry;\n-\t        iValuePredicate = predicate;\n-\t    }\n-\t    \n-        /**\n-         * @see java.util.Map.Entry#getKey()\n-         */\n-        public Object getKey() {\n-            return iEntry.getKey();\n-        }\n-\n-        /**\n-         * @see java.util.Map.Entry#getValue()\n-         */\n-        public Object getValue() {\n-            return iEntry.getValue();\n-        }\n-\n-        /**\n-         * @see java.util.Map.Entry#setValue(Object)\n-         */\n-        public Object setValue(Object object) {\n-            validate(iValuePredicate, object);\n-            return iEntry.setValue(object);\n-        }\n-\n-    }\n-    \n \t/**\n \t * True predicate implementation\n \t */    \n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/SetUtils.java\n+package org.apache.commons.collections;\n+\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.SortedSet;\n+\n+\n+/**\n+ *  Provides static utility methods and decorators for {@link Set} \n+ *  and {@link SortedSet} instances.\n+ *\n+ *  @author Paul Jack\n+ *  @version $Id: SetUtils.java,v 1.1 2002/08/13 00:26:51 pjack Exp $\n+ */\n+public class SetUtils {\n+\n+\n+    /**\n+     *  Prevents instantiation.\n+     */\n+    private SetUtils() {\n+    }\n+\n+\n+    static class PredicatedSet extends CollectionUtils.PredicatedCollection\n+    implements Set {\n+\n+        public PredicatedSet(Set set, Predicate p) {\n+            super(set, p);\n+        }\n+\n+    }\n+\n+    static class BoundedSet extends CollectionUtils.CollectionWrapper\n+    implements Set {\n+\n+        final protected int maxSize;\n+\n+\n+        public BoundedSet(Set set, int maxSize) {\n+            super(set);\n+            this.maxSize = maxSize;\n+        }\n+\n+        public boolean add(Object o) {\n+            if (!collection.contains(o)) {\n+                validate(1);\n+            }\n+            return collection.add(o);\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            int delta = 0;\n+            for (Iterator iter = c.iterator(); iter.hasNext(); ) {\n+                if (!collection.contains(iter.next())) delta++;\n+            }\n+            validate(delta);\n+            return collection.addAll(c);\n+        }\n+\n+\n+        private void validate(int delta) {\n+            if (delta + size() > maxSize) {\n+                throw new IllegalStateException(\"Maximum size reached.\");\n+            }\n+        }\n+\n+    }\n+\n+\n+    static class PredicatedSortedSet extends PredicatedSet \n+    implements SortedSet {\n+\n+        public PredicatedSortedSet(SortedSet s, Predicate p) {\n+            super(s, p);\n+        }\n+\n+        public SortedSet subSet(Object o1, Object o2) {\n+            SortedSet sub = getSortedSet().subSet(o1, o2);\n+            return new PredicatedSortedSet(sub, predicate);\n+        }\n+\n+        public SortedSet headSet(Object o1) {\n+            SortedSet sub = getSortedSet().headSet(o1);\n+            return new PredicatedSortedSet(sub, predicate);\n+        }\n+\n+        public SortedSet tailSet(Object o1) {\n+            SortedSet sub = getSortedSet().tailSet(o1);\n+            return new PredicatedSortedSet(sub, predicate);\n+        }\n+\n+        public Object first() {\n+            return getSortedSet().first();\n+        }\n+\n+        public Object last() {\n+            return getSortedSet().last();\n+        }\n+\n+        public Comparator comparator() {\n+            return getSortedSet().comparator();\n+        }\n+\n+        private SortedSet getSortedSet() {\n+            return (SortedSet)collection;\n+        }\n+\n+    }\n+\n+    /**\n+     *  Returns a predicated set backed by the given set.  Only objects\n+     *  that pass the test in the given predicate can be added to the set.\n+     *  It is important not to use the original set after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param set  the set to predicate\n+     *  @param p  the predicate for the set\n+     *  @return  a predicated set backed by the given set\n+     */\n+    public static Set predicatedSet(Set set, Predicate p) {\n+        return new PredicatedSet(set, p);\n+    }\n+\n+\n+    /**\n+     *  Returns a bounded set backed by the given set.\n+     *  New elements may only be added to the returned set if its \n+     *  size is less than the specified maximum; otherwise, an\n+     *  {@link IllegalStateException} will be thrown.\n+     *\n+     *  @param set  the set whose size to bind\n+     *  @param maxSize  the maximum size of the returned set\n+     *  @return  a bounded set \n+     */\n+    public static Set boundedSet(Set set, int maxSize) {\n+        return new BoundedSet(set, maxSize);\n+    }\n+\n+\n+    /**\n+     *  Returns a predicated sorted set backed by the given sorted set.  \n+     *  Only objects that pass the test in the given predicate can be added\n+     *  to the sorted set.\n+     *  It is important not to use the original sorted set after invoking this \n+     *  method, as it is a backdoor for adding unvalidated objects.\n+     *\n+     *  @param set  the sorted set to predicate\n+     *  @param p  the predicate for the sorted set\n+     *  @return  a predicated sorted set backed by the given sorted set\n+     */\n+    public static SortedSet predicatedSortedSet(SortedSet set, Predicate p) {\n+        return new PredicatedSortedSet(set, p);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.31 2002/08/12 18:13:09 pjack Exp $\n- * $Revision: 1.31 $\n- * $Date: 2002/08/12 18:13:09 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.32 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.32 $\n+ * $Date: 2002/08/13 00:26:52 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.31 2002/08/12 18:13:09 pjack Exp $\n+ * @version $Id: TestAll.java,v 1.32 2002/08/13 00:26:52 pjack Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n         suite.addTest(TestBoundedFifoBuffer2.suite());\n         suite.addTest(TestCollatingIterator.suite());\n         suite.addTest(TestCollectionUtils.suite());\n+        suite.addTest(TestBufferUtils.suite());\n+        suite.addTest(TestSetUtils.suite());\n+        suite.addTest(TestListUtils.suite());\n+        suite.addTest(TestMapUtils.suite());\n         suite.addTest(TestComparableComparator.suite());\n         suite.addTest(TestComparatorChain.suite());\n         suite.addTest(TestCursorableLinkedList.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestBoundedCollection.java\n+package org.apache.commons.collections;\n+\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\n+public abstract class TestBoundedCollection extends BulkTest {\n+\n+    public TestBoundedCollection(String name) {\n+        super(name);\n+    }\n+\n+\n+    public abstract Collection boundedCollection();\n+\n+\n+    public void testIllegalAdd() {\n+        Collection c = boundedCollection();\n+        Integer i = new Integer(3);\n+        try {\n+            c.add(i);\n+            fail(\"Collection should be full.\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(i));\n+    }\n+\n+\n+    public void testIllegalAddAll() {\n+        Collection c = boundedCollection();\n+        List elements = new ArrayList();\n+        elements.add(\"one\");\n+        elements.add(\"two\");\n+        elements.add(new Integer(3));\n+        elements.add(\"four\");\n+        try {\n+            c.addAll(elements);\n+            fail(\"Collection should be full.\");\n+        } catch (IllegalStateException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"one\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"two\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(new Integer(3)));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"four\"));   \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestBufferUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestBufferUtils.java,v 1.1 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/13 00:26:52 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import java.util.Collection;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+\n+\n+/**\n+ *  Tests for BufferUtils.\n+ */\n+public class TestBufferUtils extends BulkTest {\n+\n+    public TestBufferUtils(String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestBufferUtils.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public BulkTest bulkTestPredicatedBuffer() {\n+        return new TestPredicatedCollection(\"\") {\n+\n+            public Collection predicatedCollection() {\n+                Predicate p = getPredicate();\n+                return BufferUtils.predicatedBuffer(new ArrayStack(), p);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestCollection(\"\") {\n+                    public Collection makeCollection() {\n+                        return predicatedCollection();\n+                    }\n+\n+                    public Collection makeConfirmedCollection() {\n+                        return new ArrayStack();\n+                    }\n+\n+                    public Collection makeConfirmedFullCollection() {\n+                        ArrayStack list = new ArrayStack();\n+                        list.addAll(java.util.Arrays.asList(getFullElements()));\n+                        return list;\n+                    }\n+\n+                    public Object[] getFullElements() {\n+                        return getFullNonNullStringElements();\n+                    }\n+\n+                    public Object[] getOtherElements() {\n+                        return getOtherNonNullStringElements();\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n+\n+    public BulkTest bulkTestBoundedBuffer() {\n+        return new TestBoundedCollection(\"\") {\n+\n+            public Collection boundedCollection() {\n+                return BufferUtils.boundedBuffer(new ArrayStack(), 0);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestCollection(\"\") {\n+                    public Collection makeCollection() {\n+                        Object[] full = getFullElements();\n+                        Object[] other = getOtherElements();\n+                        int maxSize = full.length + other.length;\n+                        return BufferUtils.boundedBuffer(new ArrayStack(), maxSize);\n+                    }\n+\n+                    public Collection makeConfirmedCollection() {\n+                        return new ArrayStack();\n+                    }\n+\n+                    public Collection makeConfirmedFullCollection() {\n+                        ArrayStack list = new ArrayStack();\n+                        list.addAll(java.util.Arrays.asList(getFullElements()));\n+                        return list;\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n+\n+    public BulkTest bulkTestUnmodifiableBuffer() {\n+        return new TestCollection(\"\") {\n+            public boolean isAddSupported() {\n+                return false;\n+            }\n+\n+            public boolean isRemoveSupported() {\n+                return false;\n+            }\n+\n+            public Collection makeCollection() {\n+                return BufferUtils.unmodifiableBuffer(new ArrayStack());\n+            }\n+\n+            public Collection makeFullCollection() {\n+                ArrayStack a = new ArrayStack();\n+                a.addAll(Arrays.asList(getFullElements()));\n+                return BufferUtils.unmodifiableBuffer(a);\n+            }\n+\n+\n+            public Collection makeConfirmedCollection() {\n+                return new ArrayStack();\n+            }\n+\n+            public Collection makeConfirmedFullCollection() {\n+                ArrayStack a = new ArrayStack();\n+                a.addAll(Arrays.asList(getFullElements()));\n+                return a;\n+            }\n+\n+        };\n+    }\n+\n+\n+}\n+\n+\n--- a/src/test/org/apache/commons/collections/TestCollectionUtils.java\n+++ b/src/test/org/apache/commons/collections/TestCollectionUtils.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestCollectionUtils.java,v 1.3 2002/08/10 00:36:34 pjack Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/08/10 00:36:34 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestCollectionUtils.java,v 1.4 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/08/13 00:26:52 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author Rodney Waldhoff\n- * @version $Id: TestCollectionUtils.java,v 1.3 2002/08/10 00:36:34 pjack Exp $\n+ * @version $Id: TestCollectionUtils.java,v 1.4 2002/08/13 00:26:52 pjack Exp $\n  */\n public class TestCollectionUtils extends TestCase {\n     public TestCollectionUtils(String testName) {\n         test = CollectionUtils.index(bag, 0);\n         assertTrue(test.equals(\"element\"));\n     }\n+\n+\n+    public BulkTest bulkTestPredicatedCollection1() {\n+        return new TestPredicatedCollection(\"\") {\n+            public Collection predicatedCollection() {\n+                Predicate p = getPredicate();\n+                return CollectionUtils.predicatedCollection(new ArrayList(), p);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestCollection(\"\") {\n+                    public Collection makeCollection() {\n+                        return predicatedCollection();\n+                    }\n+\n+                    public Collection makeConfirmedCollection() {\n+                        return new ArrayList();\n+                    }\n+\n+                    public Collection makeConfirmedFullCollection() {\n+                        ArrayList list = new ArrayList();\n+                        list.addAll(java.util.Arrays.asList(getFullElements()));\n+                        return list;\n+                    }\n+\n+                    public Object[] getFullElements() {\n+                        return getFullNonNullStringElements();\n+                    }\n+\n+                    public Object[] getOtherElements() {\n+                        return getOtherNonNullStringElements();\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n }\n--- a/src/test/org/apache/commons/collections/TestList.java\n+++ b/src/test/org/apache/commons/collections/TestList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.10 2002/06/21 03:28:54 mas Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/06/21 03:28:54 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestList.java,v 1.11 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/08/13 00:26:52 $\n  *\n  * ====================================================================\n  *\n  *\n  * @author Rodney Waldhoff\n  * @author Paul Jack\n- * @version $Id: TestList.java,v 1.10 2002/06/21 03:28:54 mas Exp $\n+ * @version $Id: TestList.java,v 1.11 2002/08/13 00:26:52 pjack Exp $\n  */\n public abstract class TestList extends TestCollection {\n \n      *  modified when the sublist is.\n      */\n     public BulkTest bulkTestSubList() {\n-        if (getFullElements().length < 10) return null;\n+        if (getFullElements().length - 6 < 10) return null;\n         return new BulkTestSubList(this);\n     }\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestListUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestListUtils.java,v 1.1 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/13 00:26:52 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+\n+\n+public class TestListUtils extends BulkTest {\n+\n+    public TestListUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestListUtils.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public BulkTest bulkTestPredicatedList() {\n+        return new TestPredicatedCollection(\"\") {\n+\n+            public Collection predicatedCollection() {\n+                Predicate p = getPredicate();\n+                return ListUtils.predicatedList(new ArrayList(), p);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestList(\"\") {\n+                    public List makeEmptyList() {\n+                        return (List)predicatedCollection();\n+                    }\n+\n+                    public Object[] getFullElements() {\n+                        return getFullNonNullStringElements();\n+                    }\n+\n+                    public Object[] getOtherElements() {\n+                        return getOtherNonNullStringElements();\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n+\n+\n+    public BulkTest bulkTestBoundedList() {\n+        return new TestBoundedCollection(\"\") {\n+\n+            public Collection boundedCollection() {\n+                return ListUtils.boundedList(new ArrayList(), 0);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestList(\"\") {\n+                    public List makeEmptyList() {\n+                        Object[] full = getFullElements();\n+                        Object[] other = getOtherElements();\n+                        int maxSize = full.length * 2; // + other.length;\n+                        return ListUtils.boundedList(new ArrayList(), maxSize);\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n+\n+    public void testLazyList() {\n+        List list = ListUtils.lazyList(new ArrayList(), new SimpleObjectFactory() {\n+\n+            private int index;\n+\n+            public Object createObject() {\n+                index++;\n+                return new Integer(index);\n+            }\n+        });\n+\n+        Integer I = (Integer)list.get(5);\n+        assertEquals(6, list.size());\n+\n+        I = (Integer)list.get(5);\n+        assertEquals(6, list.size());\n+    }\n+\n+\n+}\n+\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestMapUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestMapUtils.java,v 1.1 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/13 00:26:52 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+\n+/**\n+ *  Tests for MapUtils.\n+ */\n+public class TestMapUtils extends BulkTest {\n+\n+    public TestMapUtils(String name) {\n+        super(name);\n+    }\n+\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestMapUtils.class);\n+    }\n+\n+    public Predicate getPredicate() {\n+        return new Predicate() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+\n+    public void testPredicatedMapIllegalPut() {\n+        Predicate p = getPredicate();\n+        Map map = MapUtils.predicatedMap(new HashMap(), p, p);\n+        try {\n+            map.put(\"Hi\", new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        try {\n+            map.put(new Integer(3), \"Hi\");\n+            fail(\"Illegal key should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        assertTrue(!map.containsKey(new Integer(3)));\n+        assertTrue(!map.containsValue(new Integer(3)));\n+\n+        Map map2 = new HashMap();\n+        map2.put(\"A\", \"a\");\n+        map2.put(\"B\", \"b\");\n+        map2.put(\"C\", \"c\");\n+        map2.put(\"c\", new Integer(3));\n+\n+        try {\n+            map.putAll(map2);\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+\n+        map.put(\"E\", \"e\");\n+        Iterator iterator = map.entrySet().iterator();\n+        try {\n+            Map.Entry entry = (Map.Entry)iterator.next();\n+            entry.setValue(new Integer(3));\n+            fail(\"Illegal value should raise IllegalArgument\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    public BulkTest bulkTestPredicatedMap() {\n+        return new TestMap(\"\") {\n+            public boolean useNullKey() {\n+                return false;\n+            }\n+\n+            public boolean useNullValue() {\n+                return false;\n+            }\n+\n+            public Map makeEmptyMap() {\n+                Predicate p = getPredicate();\n+                return MapUtils.predicatedMap(new HashMap(), p, p);\n+            }\n+        };\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestPredicatedCollection.java\n+package org.apache.commons.collections;\n+\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+\n+public abstract class TestPredicatedCollection extends BulkTest {\n+\n+    public TestPredicatedCollection(String name) {\n+        super(name);\n+    }\n+\n+\n+    protected abstract Collection predicatedCollection();\n+\n+    protected Predicate getPredicate() {\n+        return new Predicate() {\n+            public boolean evaluate(Object o) {\n+                return o instanceof String;\n+            }\n+        };\n+    }\n+\n+\n+    public void testIllegalAdd() {\n+        Collection c = predicatedCollection();\n+        Integer i = new Integer(3);\n+        try {\n+            c.add(i);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(i));   \n+    }\n+\n+\n+    public void testIllegalAddAll() {\n+        Collection c = predicatedCollection();\n+        List elements = new ArrayList();\n+        elements.add(\"one\");\n+        elements.add(\"two\");\n+        elements.add(new Integer(3));\n+        elements.add(\"four\");\n+        try {\n+            c.addAll(elements);\n+            fail(\"Integer should fail string predicate.\");\n+        } catch (IllegalArgumentException e) {\n+            // expected\n+        }\n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"one\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"two\"));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(new Integer(3)));   \n+        assertTrue(\"Collection shouldn't contain illegal element\", \n+         !c.contains(\"four\"));   \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestSetUtils.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestSetUtils.java,v 1.1 2002/08/13 00:26:52 pjack Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/08/13 00:26:52 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import junit.framework.Test;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.HashSet;\n+\n+\n+/**\n+ *  Tests for SetUtils.\n+ */\n+public class TestSetUtils extends BulkTest {\n+\n+    public TestSetUtils(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestSetUtils.class);\n+    }\n+\n+    public void testNothing() {\n+    }\n+\n+    public BulkTest bulkTestPredicatedSet() {\n+        return new TestPredicatedCollection(\"\") {\n+\n+            public Collection predicatedCollection() {\n+                Predicate p = getPredicate();\n+                return SetUtils.predicatedSet(new HashSet(), p);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestSet(\"\") {\n+                    public Set makeEmptySet() {\n+                        return (Set)predicatedCollection();\n+                    }\n+\n+                    public Object[] getFullElements() {\n+                        return getFullNonNullStringElements();\n+                    }\n+\n+                    public Object[] getOtherElements() {\n+                        return getOtherNonNullStringElements();\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n+\n+\n+    public BulkTest bulkTestBoundedSet() {\n+        return new TestBoundedCollection(\"\") {\n+\n+            public Collection boundedCollection() {\n+                return SetUtils.boundedSet(new HashSet(), 0);\n+            }\n+\n+            public BulkTest bulkTestAll() {\n+                return new TestSet(\"\") {\n+                    public Set makeEmptySet() {\n+                        Object[] full = getFullElements();\n+                        Object[] other = getOtherElements();\n+                        int maxSize = full.length + other.length;\n+                        return SetUtils.boundedSet(new HashSet(), maxSize);\n+                    }\n+\n+                };\n+            }\n+        };\n+    }\n+\n+\n+\n+\n+}\n+\n+", "timestamp": 1029198412, "metainfo": ""}