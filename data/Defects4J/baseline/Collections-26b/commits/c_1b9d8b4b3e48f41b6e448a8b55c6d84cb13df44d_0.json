{"sha": "1b9d8b4b3e48f41b6e448a8b55c6d84cb13df44d", "log": "Fix checkstyle warnings: line longer than 120 chars.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections/BufferUtils.java\n+++ b/src/main/java/org/apache/commons/collections/BufferUtils.java\n      * @return a transformed buffer backed by the given buffer\n      * @throws IllegalArgumentException  if the Buffer or Transformer is null\n      */\n-    public static <E> Buffer<E> transformingBuffer(final Buffer<E> buffer, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Buffer<E> transformingBuffer(final Buffer<E> buffer,\n+            final Transformer<? super E, ? extends E> transformer) {\n         return TransformedBuffer.transformingBuffer(buffer, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/ClosureUtils.java\n+++ b/src/main/java/org/apache/commons/collections/ClosureUtils.java\n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes, final Object[] args) {\n+    public static <E> Closure<E> invokerClosure(final String methodName, final Class<?>[] paramTypes,\n+                                                final Object[] args) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asClosure(InvokerTransformer.<E, Object>invokerTransformer(methodName, paramTypes, args));\n     }\n      * @throws IllegalArgumentException if the closure is null\n      * @since 3.2\n      */\n-    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate, final Closure<? super E> trueClosure) {\n+    public static <E> Closure<E> ifClosure(final Predicate<? super E> predicate,\n+                                           final Closure<? super E> trueClosure) {\n         return IfClosure.<E>ifClosure(predicate, trueClosure);\n     }\n \n      * @throws IllegalArgumentException if any element in the arrays is null\n      * @throws IllegalArgumentException if the arrays are different sizes\n      */\n-    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates, final Closure<? super E>[] closures) {\n+    public static <E> Closure<E> switchClosure(final Predicate<? super E>[] predicates,\n+                                               final Closure<? super E>[] closures) {\n         return SwitchClosure.<E>switchClosure(predicates, closures, null);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections/CollectionUtils.java\n      *            and predicate or not null\n      * @return outputCollection\n      */\n-    public static <O, R extends Collection<? super O>> R selectRejected(\n-            final Collection<? extends O> inputCollection, final Predicate<? super O> predicate, final R outputCollection) {\n+    public static <O, R extends Collection<? super O>> R selectRejected(final Collection<? extends O> inputCollection,\n+            final Predicate<? super O> predicate, final R outputCollection) {\n+\n         if (inputCollection != null && predicate != null) {\n             for (final O item : inputCollection) {\n                 if (!predicate.evaluate(item)) {\n             return ((BoundedCollection<?>) coll).isFull();\n         }\n         try {\n-            final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n+            final BoundedCollection<?> bcoll =\n+                    UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n             return bcoll.isFull();\n         } catch (final IllegalArgumentException ex) {\n             return false;\n             return ((BoundedCollection<?>) coll).maxSize();\n         }\n         try {\n-            final BoundedCollection<?> bcoll = UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n+            final BoundedCollection<?> bcoll =\n+                    UnmodifiableBoundedCollection.unmodifiableBoundedCollection((Collection<Object>) coll);\n             return bcoll.maxSize();\n         } catch (final IllegalArgumentException ex) {\n             return -1;\n      * @return a predicated collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection is null\n      */\n-    public static <C> Collection<C> predicatedCollection(final Collection<C> collection, final Predicate<? super C> predicate) {\n+    public static <C> Collection<C> predicatedCollection(final Collection<C> collection,\n+                                                         final Predicate<? super C> predicate) {\n         return PredicatedCollection.predicatedCollection(collection, predicate);\n     }\n \n      * @return a transformed collection backed by the given collection\n      * @throws IllegalArgumentException  if the Collection or Transformer is null\n      */\n-    public static <E> Collection<E> transformingCollection(final Collection<E> collection, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Collection<E> transformingCollection(final Collection<E> collection,\n+            final Transformer<? super E, ? extends E> transformer) {\n         return TransformedCollection.transformingCollection(collection, transformer);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/ComparatorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/ComparatorUtils.java\n      * @throws NullPointerException if comparators array is null or contains a null\n      * @see ComparatorChain\n      */\n-    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(final Comparator<E>[] comparators) {\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(\n+            final Comparator<E>[] comparators) {\n+\n         final ComparatorChain<E> chain = new ComparatorChain<E>();\n         for (final Comparator<E> comparator : comparators) {\n             if (comparator == null) {\n      * @see ComparatorChain\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(final Collection<Comparator<E>> comparators) {\n+    public static <E extends Comparable<? super E>> Comparator<E> chainedComparator(\n+            final Collection<Comparator<E>> comparators) {\n+        \n         return chainedComparator(\n             (Comparator<E>[]) comparators.toArray(new Comparator[comparators.size()])\n         );\n      * @see  TransformingComparator\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <E> Comparator<E> transformedComparator(Comparator<E> comparator, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Comparator<E> transformedComparator(Comparator<E> comparator,\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n         if (comparator == null) {\n             comparator = NATURAL_COMPARATOR;\n         }\n--- a/src/main/java/org/apache/commons/collections/FactoryUtils.java\n+++ b/src/main/java/org/apache/commons/collections/FactoryUtils.java\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      * @throws IllegalArgumentException if the constructor doesn't exist\n      */\n-    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes, final Object[] args) {\n+    public static <T> Factory<T> instantiateFactory(final Class<T> classToInstantiate, final Class<?>[] paramTypes,\n+                                                    final Object[] args) {\n         return InstantiateFactory.instantiateFactory(classToInstantiate, paramTypes, args);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/IteratorUtils.java\n+++ b/src/main/java/org/apache/commons/collections/IteratorUtils.java\n     /**\n      * An ordered map iterator over no elements.\n      */\n-    public static final OrderedMapIterator<Object, Object> EMPTY_ORDERED_MAP_ITERATOR = EmptyOrderedMapIterator.INSTANCE;\n+    public static final OrderedMapIterator<Object, Object> EMPTY_ORDERED_MAP_ITERATOR =\n+            EmptyOrderedMapIterator.INSTANCE;\n \n     /**\n      * IteratorUtils is not normally instantiated.\n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if either iterator is null\n      */\n-    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n+    public static <E> Iterator<E> chainedIterator(final Iterator<? extends E> iterator1,\n+                                                  final Iterator<? extends E> iterator2) {\n         return new IteratorChain<E>(iterator1, iterator2);\n     }\n \n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if either iterator is null\n      */\n-    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E> iterator1, final Iterator<? extends E> iterator2) {\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n+                                                   final Iterator<? extends E> iterator1,\n+                                                   final Iterator<? extends E> iterator2) {\n         return new CollatingIterator<E>(comparator, iterator1, iterator2);\n     }\n \n      * @return a combination iterator over the iterators\n      * @throws NullPointerException if iterators array is null or contains a null\n      */\n-    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator, final Iterator<? extends E>[] iterators) {\n+    public static <E> Iterator<E> collatedIterator(final Comparator<? super E> comparator,\n+                                                   final Iterator<? extends E>[] iterators) {\n         return new CollatingIterator<E>(comparator, iterators);\n     }\n \n      * @return a new object graph iterator\n      * @since 3.1\n      */\n-    public static <E> Iterator<E> objectGraphIterator(final E root, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> Iterator<E> objectGraphIterator(final E root,\n+            final Transformer<? super E, ? extends E> transformer) {\n         return new ObjectGraphIterator<E>(root, transformer);\n     }\n \n      * @return a new transforming iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator, final Transformer<? super I, ? extends O> transform) {\n+    public static <I, O> Iterator<O> transformedIterator(final Iterator<? extends I> iterator,\n+            final Transformer<? super I, ? extends O> transform) {\n+\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new filtered iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator, final Predicate<? super E> predicate) {\n+    public static <E> Iterator<E> filteredIterator(final Iterator<? extends E> iterator,\n+                                                   final Predicate<? super E> predicate) {\n         if (iterator == null) {\n             throw new NullPointerException(\"Iterator must not be null\");\n         }\n      * @return a new filtered iterator\n      * @throws NullPointerException if either parameter is null\n      */\n-    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator, final Predicate<? super E> predicate) {\n+    public static <E> ListIterator<E> filteredListIterator(final ListIterator<? extends E> listIterator,\n+            final Predicate<? super E> predicate) {\n+\n         if (listIterator == null) {\n             throw new NullPointerException(\"ListIterator must not be null\");\n         }\n      * @param removeCollection  the collection to remove elements from\n      * @return a new iterator\n      */\n-    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration, final Collection<? super E> removeCollection) {\n+    public static <E> Iterator<E> asIterator(final Enumeration<? extends E> enumeration,\n+                                             final Collection<? super E> removeCollection) {\n         if (enumeration == null) {\n             throw new NullPointerException(\"Enumeration must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/ListUtils.java\n+++ b/src/main/java/org/apache/commons/collections/ListUtils.java\n      * @return a transformed list backed by the given list\n      * @throws IllegalArgumentException  if the List or Transformer is null\n      */\n-    public static <E> List<E> transformedList(final List<E> list, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> List<E> transformedList(final List<E> list,\n+                                              final Transformer<? super E, ? extends E> transformer) {\n         return TransformedList.transformingList(list, transformer);\n     }\n     \n--- a/src/main/java/org/apache/commons/collections/MapUtils.java\n+++ b/src/main/java/org/apache/commons/collections/MapUtils.java\n      * @param value  the value, null converted to \"\"\n      * @throws NullPointerException if the map is null\n      */\n-    public static <K> void safeAddToMap(final Map<? super K, Object> map, final K key, final Object value) throws NullPointerException {\n+    public static <K> void safeAddToMap(final Map<? super K, Object> map, final K key, final Object value)\n+            throws NullPointerException {\n         map.put(key, value == null ? \"\" : value);\n     }\n \n      * @return a predicated map backed by the given map\n      * @throws IllegalArgumentException  if the Map is null\n      */\n-    public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred, final Predicate<? super V> valuePred) {\n+    public static <K, V> IterableMap<K, V> predicatedMap(final Map<K, V> map, final Predicate<? super K> keyPred,\n+                                                         final Predicate<? super V> valuePred) {\n         return PredicatedMap.predicatedMap(map, keyPred, valuePred);\n     }\n \n      * @return a lazy map backed by the given map\n      * @throws IllegalArgumentException  if the Map or Transformer is null\n      */\n-    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformerFactory) {\n+    public static <K, V> IterableMap<K, V> lazyMap(final Map<K, V> map,\n+            final Transformer<? super K, ? extends V> transformerFactory) {\n         return LazyMap.lazyMap(map, transformerFactory);\n     }\n \n      * @see MultiValueMap\n      * @since 3.2\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Class<C> collectionClass) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map,\n+            final Class<C> collectionClass) {\n         return MultiValueMap.multiValueMap(map, collectionClass);\n     }\n \n      * @see MultiValueMap\n      * @since 3.2\n      */\n-    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map, final Factory<C> collectionFactory) {\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, C> map,\n+            final Factory<C> collectionFactory) {\n         return MultiValueMap.multiValueMap(map, collectionFactory);\n     }\n \n      * @param keyTransformer the <code>Transformer</code> used to transform the collection value into a key value\n      * @throws NullPointerException if the map, collection or transformer are null\n      */\n-    public static <K, V> void populateMap(final Map<K, V> map, final Collection<? extends V> collection, final Transformer<V, K> keyTransformer) {\n+    public static <K, V> void populateMap(final Map<K, V> map, final Collection<? extends V> collection,\n+                                          final Transformer<V, K> keyTransformer) {\n         populateMap(map, collection, keyTransformer, TransformerUtils.<V>nopTransformer());\n     }\n \n      * @throws NullPointerException if the map, collection or transformers are null\n      */\n     public static <K, V, E> void populateMap(final Map<K, V> map, final Collection<? extends E> collection, \n-            final Transformer<E, K> keyTransformer, \n-            final Transformer<E, V> valueTransformer) {\n+                                             final Transformer<E, K> keyTransformer, \n+                                             final Transformer<E, V> valueTransformer) {\n         final Iterator<? extends E> iter = collection.iterator();\n         while (iter.hasNext()) {\n             final E temp = iter.next();\n--- a/src/main/java/org/apache/commons/collections/PredicateUtils.java\n+++ b/src/main/java/org/apache/commons/collections/PredicateUtils.java\n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes, final Object[] args){\n+    public static <T> Predicate<T> invokerPredicate(final String methodName, final Class<?>[] paramTypes,\n+                                                    final Object[] args) {\n         // reuse transformer as it has caching - this is lazy really, should have inner class here\n         return asPredicate(InvokerTransformer.<Object, Boolean>invokerTransformer(methodName, paramTypes, args));\n     }\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n+                                                final Predicate<? super T> predicate2) {\n         return AndPredicate.<T>andPredicate(predicate1, predicate2);\n     }\n \n      * @return the <code>or</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> orPredicate(final Predicate<? super T> predicate1,\n+                                               final Predicate<? super T> predicate2) {\n         return OrPredicate.<T>orPredicate(predicate1, predicate2);\n     }\n \n      * @return the <code>either</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> eitherPredicate(final Predicate<? super T> predicate1,\n+                                                   final Predicate<? super T> predicate2) {\n         @SuppressWarnings(\"unchecked\")\n         final\n         Predicate<T> onePredicate = PredicateUtils.<T>onePredicate(predicate1, predicate2);\n      * @return the <code>neither</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> neitherPredicate(final Predicate<? super T> predicate1,\n+                                                    final Predicate<? super T> predicate2) {\n         @SuppressWarnings(\"unchecked\")\n         final\n         Predicate<T> nonePredicate = PredicateUtils.<T>nonePredicate(predicate1, predicate2);\n--- a/src/main/java/org/apache/commons/collections/TransformerUtils.java\n+++ b/src/main/java/org/apache/commons/collections/TransformerUtils.java\n      * @throws IllegalArgumentException if any transformer in the map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <I, O> Transformer<I, O> switchMapTransformer(final Map<I, Transformer<I, O>> objectsAndTransformers) {\n+    public static <I, O> Transformer<I, O> switchMapTransformer(\n+            final Map<I, Transformer<I, O>> objectsAndTransformers) {\n+\n         Transformer<? super I, ? extends O>[] trs = null;\n         Predicate<I>[] preds = null;\n         if (objectsAndTransformers == null) {\n      * @return the transformer\n      * @throws IllegalArgumentException if the methodName is null.\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName){\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName) {\n         return InvokerTransformer.<I, O>invokerTransformer(methodName, null, null);\n     }\n \n      * @throws IllegalArgumentException if the method name is null\n      * @throws IllegalArgumentException if the paramTypes and args don't match\n      */\n-    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes, final Object[] args){\n+    public static <I, O> Transformer<I, O> invokerTransformer(final String methodName, final Class<?>[] paramTypes,\n+                                                              final Object[] args) {\n         return InvokerTransformer.<I, O>invokerTransformer(methodName, paramTypes, args);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/PredicatedSortedBag.java\n      * @throws IllegalArgumentException if bag or predicate is null\n      * @throws IllegalArgumentException if the bag contains invalid elements\n      */\n-    public static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag, final Predicate<? super E> predicate) {\n+    public static <E> PredicatedSortedBag<E> predicatedSortedBag(final SortedBag<E> bag,\n+                                                                 final Predicate<? super E> predicate) {\n         return new PredicatedSortedBag<E>(bag, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n+++ b/src/main/java/org/apache/commons/collections/bag/TransformedSortedBag.java\n      * @throws IllegalArgumentException if bag or transformer is null\n      */\n     public static <E> TransformedSortedBag<E> transformingSortedBag(final SortedBag<E> bag,\n-                                                                    final Transformer<? super E, ? extends E> transformer) {\n+            final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedBag<E>(bag, transformer);\n     }\n     \n      * @since 3.3\n      */\n     public static <E> TransformedSortedBag<E> transformedSortedBag(final SortedBag<E> bag,\n-                                                                   final Transformer<? super E, ? extends E> transformer) {\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n         final TransformedSortedBag<E>  decorated = new TransformedSortedBag<E>(bag, transformer);\n         if (transformer != null && bag != null && bag.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // bag is type E\n--- a/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/AbstractDualBidiMap.java\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap, final BidiMap<V, K> inverseBidiMap) {\n+    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                                  final BidiMap<V, K> inverseBidiMap) {\n         super();\n         this.normalMap = normalMap;\n         this.reverseMap = reverseMap;\n--- a/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualHashBidiMap.java\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected DualHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap, final BidiMap<V, K> inverseBidiMap) {\n+    protected DualHashBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                              final BidiMap<V, K> inverseBidiMap) {\n         super(normalMap, reverseMap, inverseBidiMap);\n     }\n \n      * @return new bidi map\n      */\n     @Override\n-    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap, final BidiMap<K, V> inverseBidiMap) {\n+    protected BidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n+                                          final BidiMap<K, V> inverseBidiMap) {\n         return new DualHashBidiMap<V, K>(normalMap, reverseMap, inverseBidiMap);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n+++ b/src/main/java/org/apache/commons/collections/bidimap/DualTreeBidiMap.java\n      * @param reverseMap  the reverse direction map\n      * @param inverseBidiMap  the inverse BidiMap\n      */\n-    protected DualTreeBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap, final BidiMap<V, K> inverseBidiMap) {\n+    protected DualTreeBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n+                              final BidiMap<V, K> inverseBidiMap) {\n         super(normalMap, reverseMap, inverseBidiMap);\n         this.comparator = ((SortedMap<K, V>) normalMap).comparator();\n         this.valueComparator = ((SortedMap<V, K>) reverseMap).comparator();\n      * @return new bidi map\n      */\n     @Override\n-    protected DualTreeBidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap, final BidiMap<K, V> inverseMap) {\n+    protected DualTreeBidiMap<V, K> createBidiMap(final Map<V, K> normalMap, final Map<K, V> reverseMap,\n+                                                  final BidiMap<K, V> inverseMap) {\n         return new DualTreeBidiMap<V, K>(normalMap, reverseMap, inverseMap);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n      * @param keyTransformer  {@link Transformer} for generating index keys\n      * @param map  map to use as index\n      */\n-    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer, final HashMap<K, C> map) {\n+    public IndexedCollection(final Collection<C> coll, final Transformer<C, K> keyTransformer,\n+                             final HashMap<K, C> map) {\n         super(coll);\n         this.keyTransformer = keyTransformer;\n         this.index = new HashMap<K, C>();\n--- a/src/main/java/org/apache/commons/collections/collection/TransformedCollection.java\n+++ b/src/main/java/org/apache/commons/collections/collection/TransformedCollection.java\n      * @throws IllegalArgumentException if collection or transformer is null\n      */\n     public static <E> TransformedCollection<E> transformingCollection(final Collection<E> coll,\n-                                                                      final Transformer<? super E, ? extends E> transformer) {\n+            final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedCollection<E>(coll, transformer);\n     }\n \n      * @since 3.3\n      */\n     public static <E> TransformedCollection<E> transformedCollection(final Collection<E> collection,\n-                                                                     final Transformer<? super E, ? extends E> transformer) {\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n         final TransformedCollection<E> decorated = new TransformedCollection<E>(collection, transformer);\n         // null collection & transformer are disallowed by the constructor call above \n         if (collection.size() > 0) {\n--- a/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n+++ b/src/main/java/org/apache/commons/collections/comparators/TransformingComparator.java\n      * @param transformer  what will transform the arguments to <code>compare</code>\n      * @param decorated  the decorated Comparator\n      */\n-    public TransformingComparator(final Transformer<? super E, ? extends E> transformer, final Comparator<E> decorated) {\n+    public TransformingComparator(final Transformer<? super E, ? extends E> transformer,\n+                                  final Comparator<E> decorated) {\n         this.decorated = decorated;\n         this.transformer = transformer;\n     }\n--- a/src/main/java/org/apache/commons/collections/functors/AndPredicate.java\n+++ b/src/main/java/org/apache/commons/collections/functors/AndPredicate.java\n      * @return the <code>and</code> predicate\n      * @throws IllegalArgumentException if either predicate is null\n      */\n-    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1, final Predicate<? super T> predicate2) {\n+    public static <T> Predicate<T> andPredicate(final Predicate<? super T> predicate1,\n+                                                final Predicate<? super T> predicate2) {\n         if (predicate1 == null || predicate2 == null) {\n             throw new IllegalArgumentException(\"Predicate must not be null\");\n         }\n--- a/src/main/java/org/apache/commons/collections/list/TreeList.java\n+++ b/src/main/java/org/apache/commons/collections/list/TreeList.java\n          * @param rightFollower the node with the value following this one\n          * @param leftFollower the node with the value leading this one\n          */\n-        private AVLNode(final int relativePosition, final E obj, final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n+        private AVLNode(final int relativePosition, final E obj,\n+                        final AVLNode<E> rightFollower, final AVLNode<E> leftFollower) {\n             this.relativePosition = relativePosition;\n             value = obj;\n             rightIsNext = true;\n--- a/src/main/java/org/apache/commons/collections/map/AbstractHashedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractHashedMap.java\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void reuseEntry(final HashEntry<K, V> entry, final int hashIndex, final int hashCode, final K key, final V value) {\n+    protected void reuseEntry(final HashEntry<K, V> entry, final int hashIndex, final int hashCode,\n+                              final K key, final V value) {\n         entry.next = data[hashIndex];\n         entry.hashCode = hashCode;\n         entry.key = key;\n--- a/src/main/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractInputCheckedMapDecorator.java\n         /** The parent map */\n         private final AbstractInputCheckedMapDecorator<K, V> parent;\n \n-        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractInputCheckedMapDecorator<K, V> parent) {\n+        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator,\n+                                   final AbstractInputCheckedMapDecorator<K, V> parent) {\n             super(iterator);\n             this.parent = parent;\n         }\n--- a/src/main/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/AbstractReferenceMap.java\n      * @return the newly created entry\n      */\n     @Override\n-    protected ReferenceEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+    protected ReferenceEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n+                                               final K key, final V value) {\n         return new ReferenceEntry<K, V>(this, next, hashCode, key, value);\n     }\n \n          * @param key  the key\n          * @param value  the value\n          */\n-        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next,\n+                              final int hashCode, final K key, final V value) {\n             super(next, hashCode, null, null);\n             this.parent = parent;\n             this.key = toReference(parent.keyType, key, hashCode);\n--- a/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/DefaultedMap.java\n      * @return a new defaulting map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map, final Transformer<? super K, ? extends V> transformer) {\n+    public static <K, V> Map<K, V> defaultedMap(final Map<K, V> map,\n+                                                final Transformer<? super K, ? extends V> transformer) {\n         if (transformer == null) {\n            throw new IllegalArgumentException(\"Transformer must not be null\");\n        }\n--- a/src/main/java/org/apache/commons/collections/map/IdentityMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/IdentityMap.java\n      * @return the newly created entry\n      */\n     @Override\n-    protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n+    protected IdentityEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n+                                              final K key, final V value) {\n         return new IdentityEntry<K, V>(next, hashCode, key, value);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/LRUMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LRUMap.java\n      * @param key  the key to add\n      * @param value  the value to add\n      */\n-    protected void reuseMapping(final LinkEntry<K, V> entry, final int hashIndex, final int hashCode, final K key, final V value) {\n+    protected void reuseMapping(final LinkEntry<K, V> entry, final int hashIndex, final int hashCode,\n+                                final K key, final V value) {\n         // find the entry before the entry specified in the hash table\n         // remember that the parameters (except the first) refer to the new entry,\n         // not the old one\n--- a/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/LazySortedMap.java\n      * @return a new lazy sorted map\n      * @throws IllegalArgumentException if map or factory is null\n      */\n-    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map, final Factory<? extends V> factory) {\n+    public static <K, V> LazySortedMap<K, V> lazySortedMap(final SortedMap<K, V> map,\n+                                                           final Factory<? extends V> factory) {\n         return new LazySortedMap<K,V>(map, factory);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/MultiKeyMap.java\n      * @param key5  the fifth key\n      * @return true if the map contains the key\n      */\n-    public boolean containsKey(final Object key1, final Object key2, final Object key3, final Object key4, final Object key5) {\n+    public boolean containsKey(final Object key1, final Object key2, final Object key3,\n+                               final Object key4, final Object key5) {\n         final int hashCode = hash(key1, key2, key3, key4, key5);\n         AbstractHashedMap.HashEntry<MultiKey<? extends K>, V> entry =\n                 decorated().data[decorated().hashIndex(hashCode, decorated().data.length)];\n--- a/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/MultiValueMap.java\n      * @return a new multi-value map\n      */\n     public static <K, V, C extends Collection<V>> MultiValueMap<K, V> multiValueMap(final Map<K, ? super C> map,\n-                                                                                    final Factory<C> collectionFactory) {\n+            final Factory<C> collectionFactory) {\n         return new MultiValueMap<K, V>(map, collectionFactory);\n     }\n \n      * @param collectionFactory  the collection factory which must return a Collection instance\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map, final Factory<C> collectionFactory) {\n+    protected <C extends Collection<V>> MultiValueMap(final Map<K, ? super C> map,\n+                                                      final Factory<C> collectionFactory) {\n         super((Map<K, Object>) map);\n         if (collectionFactory == null) {\n             throw new IllegalArgumentException(\"The factory must not be null\");\n--- a/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/PredicatedMap.java\n      * @param valuePredicate  the predicate to validate to values, null means no check\n      * @throws IllegalArgumentException if the map is null\n      */\n-    protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate, final Predicate<? super V> valuePredicate) {\n+    protected PredicatedMap(final Map<K, V> map, final Predicate<? super K> keyPredicate,\n+                            final Predicate<? super V> valuePredicate) {\n         super(map);\n         this.keyPredicate = keyPredicate;\n         this.valuePredicate = valuePredicate;\n--- a/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n+++ b/src/main/java/org/apache/commons/collections/map/TransformedSortedMap.java\n     public static <K, V> TransformedSortedMap<K, V> transformedSortedMap(final SortedMap<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n             final Transformer<? super V, ? extends V> valueTransformer) {\n-        final TransformedSortedMap<K, V> decorated = new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n+\n+        final TransformedSortedMap<K, V> decorated =\n+                new TransformedSortedMap<K, V>(map, keyTransformer, valueTransformer);\n         if (map.size() > 0) {\n             final Map<K, V> transformed = decorated.transformMap(map);\n             decorated.clear();\n--- a/src/main/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/PredicatedSortedSet.java\n      * @throws IllegalArgumentException if set or predicate is null\n      * @throws IllegalArgumentException if the set contains invalid elements\n      */\n-    public static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set, final Predicate<? super E> predicate) {\n+    public static <E> PredicatedSortedSet<E> predicatedSortedSet(final SortedSet<E> set,\n+                                                                 final Predicate<? super E> predicate) {\n         return new PredicatedSortedSet<E>(set, predicate);\n     }\n \n--- a/src/main/java/org/apache/commons/collections/set/TransformedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/TransformedSet.java\n      * @return a new transformed set\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n-    public static <E> TransformedSet<E> transformingSet(final Set<E> set, final Transformer<? super E, ? extends E> transformer) {\n+    public static <E> TransformedSet<E> transformingSet(final Set<E> set,\n+            final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSet<E>(set, transformer);\n     }\n     \n--- a/src/main/java/org/apache/commons/collections/set/TransformedSortedSet.java\n+++ b/src/main/java/org/apache/commons/collections/set/TransformedSortedSet.java\n      * @throws IllegalArgumentException if set or transformer is null\n      */\n     public static <E> TransformedSortedSet<E> transformingSortedSet(final SortedSet<E> set,\n-                                                                    final Transformer<? super E, ? extends E> transformer) {\n+            final Transformer<? super E, ? extends E> transformer) {\n         return new TransformedSortedSet<E>(set, transformer);\n     }\n     \n      * @since 3.3\n      */\n     public static <E> TransformedSortedSet<E> transformedSortedSet(final SortedSet<E> set,\n-                                                                   final Transformer<? super E, ? extends E> transformer) {\n+            final Transformer<? super E, ? extends E> transformer) {\n+\n         final TransformedSortedSet<E> decorated = new TransformedSortedSet<E>(set, transformer);\n         if (transformer != null && set != null && set.size() > 0) {\n             @SuppressWarnings(\"unchecked\") // set is type E\n--- a/src/main/java/org/apache/commons/collections/trie/PatriciaTrieBase.java\n+++ b/src/main/java/org/apache/commons/collections/trie/PatriciaTrieBase.java\n             if (child.bitIndex > parent.bitIndex) {\n                 child.parent = parent;\n             }\n-        };\n+        }\n         \n         // Fix H's parent and child Nodes\n         {         \n             } else {\n                 h.parent.right = p;\n             }\n-        };\n+        }\n         \n         // Copy the remaining fields from H to P\n         //p.bitIndex = h.bitIndex;", "timestamp": 1358682077, "metainfo": ""}