{"sha": "3fa63e40d4627790aa0ac7391ae341dcacbbb951", "log": "Added a test class for BlockingBuffer. Patch submitted by Janek Bogucki (Pr# 23158). Reviewed (and extended slightly) by Phil Steitz. The test case testBlockedGetWithAdd() verifies the current behavior of BlockingBuffer.add() as described in Pr# 23159, i.e., the add method uses notify, not notifyAll, so only one waiting thread is \"unblocked\" by add.   ", "commit": "\n--- a/src/test/org/apache/commons/collections/decorators/TestAll.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.12 2003/09/14 03:30:23 psteitz Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestAll.java,v 1.13 2003/09/15 03:50:41 psteitz Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for all collections decorators tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.12 $ $Date: 2003/09/14 03:30:23 $\n+ * @version $Revision: 1.13 $ $Date: 2003/09/15 03:50:41 $\n  * \n  * @author Stephen Colebourne\n  */\n         suite.addTest(TestPredicatedSortedMap.suite());\n         suite.addTest(TestLazyMap.suite());\n         suite.addTest(TestLazySortedMap.suite());\n+        suite.addTest(TestBlockingBuffer.suite());\n         \n         return suite;\n     }\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/decorators/TestBlockingBuffer.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestBlockingBuffer.java,v 1.1 2003/09/15 03:50:41 psteitz Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.decorators;\n+\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.ArrayList;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.collections.Buffer;\n+import org.apache.commons.collections.ArrayStack;\n+import org.apache.commons.collections.BufferUnderflowException;\n+import org.apache.commons.collections.decorators.BlockingBuffer;\n+\n+import org.apache.commons.collections.TestObject;\n+\n+/**\n+ * Extension of {@link TestObject} for exercising the {@link BlockingBuffer}\n+ * implementation.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $\n+ * \n+ * @author Janek Bogucki\n+ * @author Phil Steitz\n+ */\n+public class TestBlockingBuffer extends TestObject {\n+\n+    public TestBlockingBuffer(String testName) {\n+        super(testName);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestBlockingBuffer.class);\n+    }\n+\n+    public static void main(String args[]) {\n+        String[] testCaseName = { TestBlockingBuffer.class.getName()};\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    protected Object makeObject() {\n+        return BlockingBuffer.decorate(new MyBuffer());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#get()}.\n+     */\n+    public void testGetWithAdd() {\n+      \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+\n+        new DelayedAdd(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#get()}.\n+     */\n+    public void testGetWithAddAll() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+\n+        new DelayedAddAll(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.get());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#remove()}.\n+     */\n+    public void testRemoveWithAdd() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+\n+        new DelayedAdd(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.remove());\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests {@link BlockingBuffer#remove()}.\n+     */\n+    public void testRemoveWithAddAll() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+\n+        new DelayedAddAll(blockingBuffer, obj).start();\n+\n+        // verify does not throw BufferUnderflowException; should block until other thread has added to the buffer .\n+        assertSame(obj, blockingBuffer.remove());\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     *  Tests get using multiple read threads.\n+     *\n+     *  Verifies that multiple adds are required to allow gets by\n+     *  multiple threads on an empty buffer to complete.\n+     */\n+    public void testBlockedGetWithAdd() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+        \n+        // run methods will get and compare -- must wait for adds\n+        Thread thread1 = new ReadThread(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread(blockingBuffer, obj);\n+        thread1.start();\n+        thread2.start();\n+        \n+        // give hungry read threads ample time to hang\n+        try {\n+            Thread.currentThread().sleep(100);\n+        } catch (InterruptedException e) {}\n+           \n+        // notify should allow one read thread to complete\n+        blockingBuffer.add(obj);\n+        \n+        // allow notified thread(s) to complete \n+        try {\n+            Thread.currentThread().sleep(100);\n+        } catch (InterruptedException e) {}\n+        \n+        // There shoould still be one thread waiting.  Verify this.\n+        // This check will fail if add is changed to notifyAll.\n+        assertTrue(\"One read thread should be waiting\", \n+            thread1.isAlive() || thread2.isAlive());\n+ \n+        // now add again so the second thread will be notified\n+        blockingBuffer.add(obj);\n+        \n+        // wait to exit until both threads are dead, or appear to be hung\n+        boolean finished = false;\n+        for (int i = 1; i < 10; i++) {\n+            if (thread1.isAlive() || thread2.isAlive()) {\n+                try {\n+                    Thread.currentThread().sleep(100);\n+                }\n+                catch (InterruptedException e) {}\n+            } else {\n+                finished = true;\n+                break;\n+            }\n+        }\n+        if (!finished) {\n+            fail(\"Read thread did not finish.\");\n+        }\n+    }\n+    \n+    /**\n+     *  Tests get using multiple read threads.\n+     *  Shows that one addAll allows multiple gets to complete.\n+     */\n+    public void testBlockedGetWithAddAll() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+        \n+        // run methods will get and compare -- must wait for adds\n+        Thread thread1 = new ReadThread(blockingBuffer, obj);\n+        Thread thread2 = new ReadThread(blockingBuffer, obj);\n+        thread1.start();\n+        thread2.start();\n+        \n+        // give hungry read threads ample time to hang\n+        try {\n+            Thread.currentThread().sleep(100);\n+        } catch (InterruptedException e) {}\n+           \n+        // notifyAll should allow both read threads to complete\n+        blockingBuffer.addAll(Collections.singleton(obj));\n+               \n+        // wait to exit until both threads are dead, or appear to be hung\n+        boolean finished = false;\n+        for (int i = 1; i < 10; i++) {\n+            if (thread1.isAlive() || thread2.isAlive()) {\n+                try {\n+                    Thread.currentThread().sleep(100);\n+                }\n+                catch (InterruptedException e) {}\n+            } else {\n+                finished = true;\n+                break;\n+            }  \n+        }\n+        if (!finished) {\n+            fail(\"Read thread did not finish.\");\n+        }\n+    }\n+    \n+    /**\n+     *  Tests interrupted get.\n+     */\n+    public void testInterruptedGet() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+        \n+        // spawn a read thread to wait on the empty buffer\n+        ArrayList exceptionList = new ArrayList();\n+        Thread thread = new ReadThread(blockingBuffer, obj, exceptionList);\n+        thread.start();\n+        \n+        // Interrupting the thread should cause it to throw BufferUnderflowException\n+        thread.interrupt();\n+        \n+        // Chill, so thread can throw and add message to exceptionList\n+        try {\n+            Thread.currentThread().sleep(100);\n+        } catch (InterruptedException e) {}\n+        \n+        assertTrue(\"Thread interrupt should have led to underflow\", \n+            exceptionList.contains(\"BufferUnderFlow\"));\n+        \n+        if (thread.isAlive()) {\n+            fail(\"Hung read thread\");\n+        }\n+        \n+    }\n+    \n+    /**\n+     *  Tests interrupted remove.\n+     */\n+    public void testInterruptedRemove() {\n+        \n+        Buffer blockingBuffer = BlockingBuffer.decorate(new MyBuffer());\n+        Object obj = new Object();\n+        \n+        // spawn a read thread to wait on the empty buffer\n+        ArrayList exceptionList = new ArrayList();\n+        Thread thread = new ReadThread(blockingBuffer, obj, exceptionList, \"remove\");\n+        thread.start();\n+        \n+        // Interrupting the thread should cause it to throw BufferUnderflowException\n+        thread.interrupt();\n+        \n+        // Chill, so thread can throw and add message to exceptionList\n+        try {\n+            Thread.currentThread().sleep(100);\n+        } catch (InterruptedException e) {}\n+        \n+        assertTrue(\"Thread interrupt should have led to underflow\", \n+            exceptionList.contains(\"BufferUnderFlow\"));\n+        \n+        if (thread.isAlive()) {\n+            fail(\"Hung read thread\");\n+        }\n+        \n+    }\n+    \n+    protected static class DelayedAdd extends Thread {\n+\n+        Buffer buffer;\n+        Object obj;\n+\n+        DelayedAdd (Buffer buffer, Object obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+                \n+        public void run() {\n+\n+            try {\n+                // wait for other thread to block on get() or remove()\n+                Thread.currentThread().sleep(100);\n+            }\n+            catch (InterruptedException e) {}\n+\n+            buffer.add(obj);\n+        }\n+    }\n+    \n+    protected static class DelayedAddAll extends Thread {\n+\n+        Buffer buffer;\n+        Object obj;\n+\n+        DelayedAddAll (Buffer buffer, Object obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+                \n+        public void run() {\n+\n+            try {\n+                // wait for other thread to block on get() or remove()\n+                Thread.currentThread().sleep(100);\n+            }\n+            catch (InterruptedException e) {}\n+\n+            buffer.addAll(Collections.singleton(obj));\n+        }\n+    }\n+    \n+    protected static class ReadThread extends Thread {\n+\n+        Buffer buffer;\n+        Object obj;\n+        ArrayList exceptionList = null;\n+        String action = \"get\";\n+        \n+        ReadThread (Buffer buffer, Object obj) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+        }\n+\n+        ReadThread (Buffer buffer, Object obj, ArrayList exceptionList) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.exceptionList = exceptionList;\n+        }\n+        \n+        ReadThread (Buffer buffer, Object obj, ArrayList exceptionList, String action) {\n+            super();\n+            this.buffer = buffer;\n+            this.obj = obj;\n+            this.exceptionList = exceptionList;\n+            this.action = action;\n+        }\n+                \n+        public void run()  {\n+            try {\n+                if (action == \"get\") {\n+                    assertSame(obj, buffer.get());\n+                } else {\n+                    assertSame(obj, buffer.remove());\n+                }\n+            } catch (BufferUnderflowException ex) {\n+                exceptionList.add(\"BufferUnderFlow\");\n+            }\n+        }\n+    }\n+        \n+\n+    protected static class MyBuffer extends LinkedList implements Buffer {\n+\n+        public Object get() {\n+            if(isEmpty())\n+                throw new BufferUnderflowException();\n+            return get(0);\n+        }\n+\n+        public Object remove() {\n+            if(isEmpty())\n+                throw new BufferUnderflowException();\n+            return remove(0);\n+        }\n+    }\n+}", "timestamp": 1063597841, "metainfo": ""}