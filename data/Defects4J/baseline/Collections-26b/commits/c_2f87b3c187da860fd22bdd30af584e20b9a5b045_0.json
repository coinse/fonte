{"sha": "2f87b3c187da860fd22bdd30af584e20b9a5b045", "log": "Moved IndexedCollection to collection package. Only interfaces and utilities shall reside in the top-level package.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/collections/collection/IndexedCollection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.apache.commons.collections.Transformer;\n+\n+/**\n+ * An IndexedCollection is a Map-like view onto a Collection. It accepts a\n+ * keyTransformer to define how the keys are converted from the values.\n+ * <p>\n+ * Modifications made to this decorator modify the index as well as the\n+ * decorated {@link Collection}. However, modifications to the underlying\n+ * {@link Collection} will not updated the index and it will get out of sync.\n+ * <p>\n+ * If modification to the decorated {@link Collection} is unavoidable, then a\n+ * call to {@link #reindex()} will update the index to the current contents of\n+ * the {@link Collection}.\n+ *\n+ * @param <K> the type of object in the index.\n+ * @param <C> the type of object in the collection.\n+ * \n+ * @since 4.0\n+ * @version $Id$\n+ */\n+// TODO support MultiMap/non-unique index behavior\n+// TODO add support for remove and clear\n+public class IndexedCollection<K, C> extends AbstractCollectionDecorator<C> {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -5512610452568370038L;\n+\n+    /**\n+     * Create an {@link IndexedCollection} for a unique index.\n+     *\n+     * @param <K> the index object type.\n+     * @param <C> the collection type.\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     * @return the created {@link IndexedCollection}.\n+     */\n+    public static <K, C> IndexedCollection<K, C> uniqueIndexedCollection(final Collection<C> coll,\n+                                                                         final Transformer<C, K> keyTransformer) {\n+        return new IndexedCollection<K, C>(coll, keyTransformer, new HashMap<K, C>());\n+    }\n+\n+    /**\n+     * The {@link Transformer} for generating index keys.\n+     */\n+    private final Transformer<C, K> keyTransformer;\n+\n+    /**\n+     * The map of indexes to collected objects.\n+     */\n+    private final HashMap<K, C> index;\n+\n+    /**\n+     * Create a {@link IndexedCollection} for a unique index.\n+     *\n+     * @param coll the decorated {@link Collection}.\n+     * @param keyTransformer the {@link Transformer} for generating index keys.\n+     */\n+    public IndexedCollection(Collection<C> coll, Transformer<C, K> keyTransformer, HashMap<K, C> map) {\n+        super(coll);\n+        this.keyTransformer = keyTransformer;\n+        this.index = map;\n+        reindex();\n+    }\n+\n+    /**\n+     * Clears the index and re-indexes the entire decorated {@link Collection}.\n+     */\n+    public void reindex() {\n+        index.clear();\n+        for (C c : decorated()) {\n+            addIndex(c);\n+        }\n+    }\n+\n+    /**\n+     * Adds an object to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.add() fails\n+    public boolean add(C object) {\n+        addIndex(object);\n+        return super.add(object);\n+    }\n+\n+    /**\n+     * Adds an entire collection to the collection and index.\n+     */\n+    @Override\n+    // TODO: Add error handling for when super.addAll() fails\n+    public boolean addAll(Collection<? extends C> coll) {\n+        for (C c : coll) {\n+            addIndex(c);\n+        }\n+        return super.addAll(coll);\n+    }\n+\n+    /**\n+     * Provides checking for adding the index.\n+     *\n+     * @param object the object to index.\n+     */\n+    private void addIndex(C object) {\n+        final C existingObject = index.put(keyTransformer.transform(object), object);\n+        if (existingObject != null) {\n+            throw new IllegalArgumentException(\"Duplicate key in uniquely indexed collection.\");\n+        }\n+    }\n+\n+    /**\n+     * Get the element associated with the given key.\n+     * @param key to look up\n+     * @return element found\n+     */\n+    public C get(K key) {\n+        return index.get(key);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/collections/collection/IndexedCollectionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.collections.collection;\n+\n+import static java.util.Arrays.asList;\n+import static junit.framework.Assert.assertEquals;\n+import static junit.framework.Assert.assertNull;\n+\n+import org.apache.commons.collections.AbstractDecoratedCollectionTest;\n+import org.apache.commons.collections.Transformer;\n+import org.apache.commons.collections.collection.IndexedCollection;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+@SuppressWarnings(\"boxing\")\n+public class IndexedCollectionTest extends AbstractDecoratedCollectionTest<String> {\n+    private IndexedCollection<Integer, String> indexed;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n+            public Integer transform(String input) {\n+                return Integer.parseInt(input);\n+            }\n+        });\n+        decorated = indexed;\n+    }\n+    \n+    @Test\n+    public void addedObjectsCanBeRetrievedByKey() throws Exception {\n+        decorated.add(\"12\");\n+        decorated.add(\"16\");\n+        decorated.add(\"1\");\n+        decorated.addAll(asList(\"2\",\"3\",\"4\"));\n+        assertEquals(\"12\", indexed.get(12));\n+        assertEquals(\"16\", indexed.get(16));\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+        assertEquals(\"4\", indexed.get(4));\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void ensureDuplicateObjectsCauseException() throws Exception {\n+        decorated.add(\"1\");\n+        decorated.add(\"1\");\n+    }\n+    \n+    @Test\n+    public void decoratedCollectionIsIndexedOnCreation() throws Exception {\n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+        \n+        indexed = IndexedCollection.uniqueIndexedCollection(original, new Transformer<String, Integer>() {\n+            public Integer transform(String input) {\n+                return Integer.parseInt(input);\n+            }\n+        });\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+    \n+    @Test\n+    public void reindexUpdatesIndexWhenTheDecoratedCollectionIsModifiedSeparately() throws Exception {\n+        original.add(\"1\");\n+        original.add(\"2\");\n+        original.add(\"3\");\n+        \n+        assertNull(indexed.get(1));\n+        assertNull(indexed.get(2));\n+        assertNull(indexed.get(3));\n+        indexed.reindex();\n+        assertEquals(\"1\", indexed.get(1));\n+        assertEquals(\"2\", indexed.get(2));\n+        assertEquals(\"3\", indexed.get(3));\n+    }\n+}", "timestamp": 1345230830, "metainfo": ""}