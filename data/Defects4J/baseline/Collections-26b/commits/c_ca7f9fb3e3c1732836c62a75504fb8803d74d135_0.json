{"sha": "ca7f9fb3e3c1732836c62a75504fb8803d74d135", "log": "Refactor events so pre and post more separated   ", "commit": "\n--- a/src/java/org/apache/commons/collections/decorators/ObservedCollection.java\n+++ b/src/java/org/apache/commons/collections/decorators/ObservedCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedCollection.java,v 1.3 2003/08/31 21:09:49 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedCollection.java,v 1.4 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.event.ModificationHandler;\n import org.apache.commons.collections.event.StandardModificationHandler;\n import org.apache.commons.collections.event.StandardModificationListener;\n+import org.apache.commons.collections.event.StandardPostModificationListener;\n+import org.apache.commons.collections.event.StandardPreModificationListener;\n \n /**\n  * <code>ObservedCollection</code> decorates a <code>Collection</code>\n  * uses a technique other than listeners to communicate events.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 21:09:49 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n \n     /**\n      * Factory method to create an observable collection and register one\n-     * listener to receive all events.\n+     * listener to receive events before the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n      */\n     public static ObservedCollection decorate(\n             final Collection coll,\n-            final StandardModificationListener listener) {\n-        \n-        return decorate(coll, listener, -1, -1);\n+            final StandardPreModificationListener listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            listener, -1, null, 0\n+        );\n+        return new ObservedCollection(coll, handler);\n     }\n \n     /**\n      * Factory method to create an observable collection and register one\n-     * listener to receive all post events.\n+     * listener to receive events after the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n      * @return the observed collection\n      * @throws IllegalArgumentException if the collection or listener is null\n      */\n-    public static ObservedCollection decoratePostEventsOnly(\n-            final Collection coll,\n-            final StandardModificationListener listener) {\n-        \n-        return decorate(coll, listener, 0, -1);\n-    }\n-\n-    /**\n-     * Factory method to create an observable collection and\n-     * register one listener using event masks.\n+    public static ObservedCollection decorate(\n+            final Collection coll,\n+            final StandardPostModificationListener listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Collection must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            null, 0, listener, -1\n+        );\n+        return new ObservedCollection(coll, handler);\n+    }\n+\n+    /**\n+     * Factory method to create an observable collection and register one\n+     * listener to receive events both before and after the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n-     * The masks are defined in \n-     * {@link org.apache.commons.collections.event.ModificationEventType ModificationEventType}.\n      *\n      * @param coll  the collection to decorate, must not be null\n      * @param listener  collection listener, must not be null\n-     * @param preEventMask  mask for pre events (0 for none, -1 for all)\n-     * @param postEventMask  mask for post events (0 for none, -1 for all)\n      * @return the observed collection\n      * @throws IllegalArgumentException if the collection or listener is null\n      */\n     public static ObservedCollection decorate(\n             final Collection coll,\n-            final StandardModificationListener listener,\n-            final int preEventMask,\n-            final int postEventMask) {\n-            \n+            final StandardModificationListener listener) {\n+        \n         if (coll == null) {\n             throw new IllegalArgumentException(\"Collection must not be null\");\n         }\n         if (listener == null) {\n             throw new IllegalArgumentException(\"Listener must not be null\");\n         }\n-        StandardModificationHandler handler = new StandardModificationHandler();\n-        ObservedCollection oc = new ObservedCollection(coll, handler);\n-        handler.addModificationListener(listener, preEventMask, postEventMask);\n-        return oc;\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            listener, -1, listener, -1\n+        );\n+        return new ObservedCollection(coll, handler);\n     }\n \n     /**\n     // Listener convenience methods\n     //----------------------------------------------------------------------\n     /**\n-     * Gets an array of all the listeners active in the handler.\n-     * This method simply delegates to the handler.\n-     * \n-     * @return the listeners\n-     * @throws UnsupportedOperationException if the handler does not support listeners\n-     */\n-    public Object[] getModificationListeners() {\n-        return getHandler().getModificationListeners();\n-    }\n-    \n-    /**\n-     * Adds a listener to the list held in the handler.\n+     * Adds a listener to the handler to receive pre modification events.\n      * This method simply delegates to the handler.\n      * <p>\n      * No error occurs if the listener is <code>null</code>.\n      * @throws ClassCastException if the listener is not of the correct type\n      * @throws UnsupportedOperationException if the handler does not support listeners\n      */\n-    public void addModificationListener(Object listener) {\n-        getHandler().addModificationListener(listener);\n+    public void addPreModificationListener(Object listener) {\n+        getHandler().addPreModificationListener(listener);\n     }\n     \n     /**\n-     * Removes a listener to the list held in the handler. \n+     * Adds a listener to the handler to receive post modification events.\n      * This method simply delegates to the handler.\n      * <p>\n-     * No error occurs if the listener is not in the list or the type\n-     * of the listener is incorrect.\n-     * <p>\n-     * This implementation throws UnsupportedOperationException.\n+     * No error occurs if the listener is <code>null</code>.\n+     * <p>\n+     * The listener does not necessarily have to be a listener in the classic\n+     * JavaBean sense. It is entirely up to the handler as to how it interprets\n+     * the listener parameter. A ClassCastException is thrown if the handler\n+     * cannot interpret the parameter.\n      * \n-     * @param listener  the listener to remove, may be null (ignored)\n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not of the correct type\n      * @throws UnsupportedOperationException if the handler does not support listeners\n      */\n-    public void removeModificationListener(Object listener) {\n-        getHandler().removeModificationListener(listener);\n+    public void addPostModificationListener(Object listener) {\n+        getHandler().addPostModificationListener(listener);\n     }\n     \n     // Collection\n--- a/src/java/org/apache/commons/collections/decorators/ObservedList.java\n+++ b/src/java/org/apache/commons/collections/decorators/ObservedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedList.java,v 1.2 2003/08/31 17:24:46 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedList.java,v 1.3 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.event.ModificationHandler;\n import org.apache.commons.collections.event.StandardModificationHandler;\n import org.apache.commons.collections.event.StandardModificationListener;\n+import org.apache.commons.collections.event.StandardPostModificationListener;\n+import org.apache.commons.collections.event.StandardPreModificationListener;\n \n /**\n  * <code>ObservedList</code> decorates a <code>List</code>\n  * uses a technique other than listeners to communicate events.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:24:46 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n \n     /**\n      * Factory method to create an observable list and register one\n-     * listener to receive all events.\n+     * listener to receive events before the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n      *\n-     * @param list  the list to decorate, must not be null\n-     * @param listener  the listener, must not be null\n+     * @param coll  the list to decorate, must not be null\n+     * @param listener  list listener, must not be null\n      * @return the observed list\n      * @throws IllegalArgumentException if the list or listener is null\n      */\n     public static ObservedList decorate(\n-            final List list,\n-            final StandardModificationListener listener) {\n-        \n-        return decorate(list, listener, -1, -1);\n+            final List coll,\n+            final StandardPreModificationListener listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            listener, -1, null, 0\n+        );\n+        return new ObservedList(coll, handler);\n     }\n \n     /**\n      * Factory method to create an observable list and register one\n-     * listener to receive all post events.\n+     * listener to receive events after the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n      *\n-     * @param list  the list to decorate, must not be null\n-     * @param listener  the listener, must not be null\n+     * @param coll  the list to decorate, must not be null\n+     * @param listener  list listener, must not be null\n      * @return the observed list\n      * @throws IllegalArgumentException if the list or listener is null\n      */\n-    public static ObservedList decoratePostEventsOnly(\n-            final List list,\n-            final StandardModificationListener listener) {\n-        \n-        return decorate(list, listener, 0, -1);\n-    }\n-\n-    /**\n-     * Factory method to create an observable list and\n-     * register one listener using event masks.\n+    public static ObservedList decorate(\n+            final List coll,\n+            final StandardPostModificationListener listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"List must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            null, 0, listener, -1\n+        );\n+        return new ObservedList(coll, handler);\n+    }\n+\n+    /**\n+     * Factory method to create an observable list and register one\n+     * listener to receive events both before and after the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n-     * The masks are defined in \n-     * {@link org.apache.commons.collections.event.ModificationEventType ModificationEventType}.\n-     *\n-     * @param list  the list to decorate, must not be null\n-     * @param listener  the listener, must not be null\n-     * @param preEventMask  mask for pre events (0 for none, -1 for all)\n-     * @param postEventMask  mask for post events (0 for none, -1 for all)\n+     *\n+     * @param coll  the list to decorate, must not be null\n+     * @param listener  list listener, must not be null\n      * @return the observed list\n      * @throws IllegalArgumentException if the list or listener is null\n      */\n     public static ObservedList decorate(\n-            final List list,\n-            final StandardModificationListener listener,\n-            final int preEventMask,\n-            final int postEventMask) {\n-            \n-        if (list == null) {\n+            final List coll,\n+            final StandardModificationListener listener) {\n+        \n+        if (coll == null) {\n             throw new IllegalArgumentException(\"List must not be null\");\n         }\n         if (listener == null) {\n             throw new IllegalArgumentException(\"Listener must not be null\");\n         }\n-        StandardModificationHandler handler = new StandardModificationHandler();\n-        ObservedList oc = new ObservedList(list, handler);\n-        handler.addModificationListener(listener, preEventMask, postEventMask);\n-        return oc;\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            listener, -1, listener, -1\n+        );\n+        return new ObservedList(coll, handler);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/collections/decorators/ObservedSet.java\n+++ b/src/java/org/apache/commons/collections/decorators/ObservedSet.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedSet.java,v 1.2 2003/08/31 17:24:46 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/decorators/Attic/ObservedSet.java,v 1.3 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.event.ModificationHandler;\n import org.apache.commons.collections.event.StandardModificationHandler;\n import org.apache.commons.collections.event.StandardModificationListener;\n+import org.apache.commons.collections.event.StandardPostModificationListener;\n+import org.apache.commons.collections.event.StandardPreModificationListener;\n \n /**\n  * <code>ObservedSet</code> decorates a <code>Set</code>\n  * uses a technique other than listeners to communicate events.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:24:46 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n \n     /**\n      * Factory method to create an observable set and register one\n-     * listener to receive all events.\n+     * listener to receive events before the change is made.\n      * <p>\n      * A {@link StandardModificationHandler} will be created.\n      * The listener will be added to the handler.\n      *\n-     * @param set  the set to decorate, must not be null\n-     * @param listener  the listener, must not be null\n+     * @param coll  the set to decorate, must not be null\n+     * @param listener  set listener, must not be null\n      * @return the observed set\n      * @throws IllegalArgumentException if the set or listener is null\n      */\n     public static ObservedSet decorate(\n-            final Set set,\n+            final Set coll,\n+            final StandardPreModificationListener listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            listener, -1, null, 0\n+        );\n+        return new ObservedSet(coll, handler);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set and register one\n+     * listener to receive events after the change is made.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param coll  the set to decorate, must not be null\n+     * @param listener  set listener, must not be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set or listener is null\n+     */\n+    public static ObservedSet decorate(\n+            final Set coll,\n+            final StandardPostModificationListener listener) {\n+        \n+        if (coll == null) {\n+            throw new IllegalArgumentException(\"Set must not be null\");\n+        }\n+        if (listener == null) {\n+            throw new IllegalArgumentException(\"Listener must not be null\");\n+        }\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            null, 0, listener, -1\n+        );\n+        return new ObservedSet(coll, handler);\n+    }\n+\n+    /**\n+     * Factory method to create an observable set and register one\n+     * listener to receive events both before and after the change is made.\n+     * <p>\n+     * A {@link StandardModificationHandler} will be created.\n+     * The listener will be added to the handler.\n+     *\n+     * @param coll  the set to decorate, must not be null\n+     * @param listener  set listener, must not be null\n+     * @return the observed set\n+     * @throws IllegalArgumentException if the set or listener is null\n+     */\n+    public static ObservedSet decorate(\n+            final Set coll,\n             final StandardModificationListener listener) {\n         \n-        return decorate(set, listener, -1, -1);\n-    }\n-\n-    /**\n-     * Factory method to create an observable set and register one\n-     * listener to receive all post events.\n-     * <p>\n-     * A {@link StandardModificationHandler} will be created.\n-     * The listener will be added to the handler.\n-     *\n-     * @param set  the set to decorate, must not be null\n-     * @param listener  the listener, must not be null\n-     * @return the observed set\n-     * @throws IllegalArgumentException if the set or listener is null\n-     */\n-    public static ObservedSet decoratePostEventsOnly(\n-            final Set set,\n-            final StandardModificationListener listener) {\n-        \n-        return decorate(set, listener, 0, -1);\n-    }\n-\n-    /**\n-     * Factory method to create an observable set and\n-     * register one listener using event masks.\n-     * <p>\n-     * A {@link StandardModificationHandler} will be created.\n-     * The listener will be added to the handler.\n-     * The masks are defined in \n-     * {@link org.apache.commons.collections.event.ModificationEventType ModificationEventType}.\n-     *\n-     * @param set  the set to decorate, must not be null\n-     * @param listener  the listener, must not be null\n-     * @param preEventMask  mask for pre events (0 for none, -1 for all)\n-     * @param postEventMask  mask for post events (0 for none, -1 for all)\n-     * @return the observed set\n-     * @throws IllegalArgumentException if the set or listener is null\n-     */\n-    public static ObservedSet decorate(\n-            final Set set,\n-            final StandardModificationListener listener,\n-            final int preEventMask,\n-            final int postEventMask) {\n-            \n-        if (set == null) {\n+        if (coll == null) {\n             throw new IllegalArgumentException(\"Set must not be null\");\n         }\n         if (listener == null) {\n             throw new IllegalArgumentException(\"Listener must not be null\");\n         }\n-        StandardModificationHandler handler = new StandardModificationHandler();\n-        ObservedSet oc = new ObservedSet(set, handler);\n-        handler.addModificationListener(listener, preEventMask, postEventMask);\n-        return oc;\n+        StandardModificationHandler handler = new StandardModificationHandler(\n+            listener, -1, listener, -1\n+        );\n+        return new ObservedSet(coll, handler);\n     }\n \n     /**\n      * \n      * @param set  the set to decorate, must not be null\n      * @param handler  the observing handler, may be null\n-     * @throws IllegalArgumentException if the collection is null\n+     * @throws IllegalArgumentException if the set is null\n      */\n     protected ObservedSet(\n             final Set set,\n--- a/src/java/org/apache/commons/collections/event/ModificationHandler.java\n+++ b/src/java/org/apache/commons/collections/event/ModificationHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationHandler.java,v 1.3 2003/08/31 21:09:49 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationHandler.java,v 1.4 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * that forwards to single points.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 21:09:49 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n         return collection;\n     }\n     \n-    // Listeners\n+    // PreListeners\n     //----------------------------------------------------------------------\n     /**\n-     * Gets an array of all the listeners active in the handler.\n+     * Gets an array of all the pre listeners active in the handler.\n      * <p>\n      * This implementation throws UnsupportedOperationException.\n      * \n      * @return the listeners\n      * @throws UnsupportedOperationException if the handler does not support listeners\n      */\n-    public Object[] getModificationListeners() {\n+    public Object[] getPreModificationListeners() {\n         throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n     }\n     \n     /**\n-     * Adds a listener to the list held in the handler.\n+     * Adds a pre listener to the list held in the handler.\n      * <p>\n      * No error occurs if the listener is <code>null</code>.\n      * <p>\n      * @throws ClassCastException if the listener is not of the correct type\n      * @throws UnsupportedOperationException if the handler does not support listeners\n      */\n-    public void addModificationListener(Object listener) {\n+    public void addPreModificationListener(Object listener) {\n         throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n     }\n     \n     /**\n-     * Removes a listener to the list held in the handler.\n+     * Removes a pre listener to the list held in the handler.\n      * <p>\n      * No error occurs if the listener is not in the list or the type\n      * of the listener is incorrect.\n      * @param listener  the listener to remove, may be null (ignored)\n      * @throws UnsupportedOperationException if the handler does not support listeners\n      */\n-    public void removeModificationListener(Object listener) {\n+    public void removePreModificationListener(Object listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    // PostListeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the post listeners active in the handler.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @return the listeners\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public Object[] getPostModificationListeners() {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Adds a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * <p>\n+     * The listener does not necessarily have to be a listener in the classic\n+     * JavaBean sense. It is entirely up to the handler as to how it interprets\n+     * the listener parameter. A ClassCastException is thrown if the handler\n+     * cannot interpret the parameter.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not of the correct type\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void addPostModificationListener(Object listener) {\n+        throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n+    }\n+    \n+    /**\n+     * Removes a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * <p>\n+     * This implementation throws UnsupportedOperationException.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     * @throws UnsupportedOperationException if the handler does not support listeners\n+     */\n+    public void removePostModificationListener(Object listener) {\n         throw new UnsupportedOperationException(\"Listeners not supported by \" + getClass().getName());\n     }\n     \n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/ModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/ModificationListener.java,v 1.4 2003/08/31 22:44:54 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+import java.util.EventListener;\n+\n+/**\n+ * An empty listener designed to be subclassed.\n+ * <p>\n+ * This interface exists to mark independent subclasses as fulfilling the\n+ * role of an event listener for collection modification events.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.4 $ $Date: 2003/08/31 22:44:54 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface ModificationListener extends EventListener {\n+\n+    // no methods - subinterfaces define them\n+    \n+}\n--- a/src/java/org/apache/commons/collections/event/StandardModificationHandler.java\n+++ b/src/java/org/apache/commons/collections/event/StandardModificationHandler.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationHandler.java,v 1.3 2003/08/31 21:09:49 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationHandler.java,v 1.4 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * In addition, the <code>size</code> method is used on the collection.\n  * All objects used are the real objects from the method calls, not clones.\n  * <p>\n- * Each listener can be filtered. There are separate filters for pre events\n- * (modificationOccurring) and post events (modificationOccurred).\n- * <p>\n- * This implementation is the standard one. Most listeners will probably be\n- * content with the events generated from here. However, if you need something\n- * extra then this class can be subclassed or replaced as required. For example:\n- * <ul>\n- * <li>to store the state of the collection before the change\n- * <li>to change the event classes\n- * <li>to change the event dispatch mechanism to something other than listeners\n- * <li>to clone the objects before placing them in the event\n- * </ul>\n+ * Each listener can be filtered. There are separate filters for pre and post\n+ * modification events.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 21:09:49 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n public class StandardModificationHandler extends ModificationHandler {\n \n     /** A reusable empty holders array. */    \n-    protected static final Holder[] EMPTY_HOLDERS = new Holder[0];\n+    protected static final PreHolder[] EMPTY_PRE_HOLDERS = new PreHolder[0];\n+    /** A reusable empty holders array. */    \n+    protected static final PostHolder[] EMPTY_POST_HOLDERS = new PostHolder[0];\n     \n     /** The event mask as to which event types to send on pre events. */\n     protected int preMask = ModificationEventType.GROUP_NONE;\n     /** The event mask as to which event types to send on post events. */\n     protected int postMask = ModificationEventType.GROUP_NONE;\n+    \n     /** The event listeners. */\n-    protected Holder[] holders = EMPTY_HOLDERS;\n+    protected PreHolder[] preHolder = EMPTY_PRE_HOLDERS;\n+    /** The event listeners. */\n+    protected PostHolder[] postHolder = EMPTY_POST_HOLDERS;\n     /**\n      * Temporary store for the size.\n      * This makes the class thread-unsafe, but you should sync collections anyway.\n         super();\n     }\n \n-    // Listeners\n+    /**\n+     * Constructor the creates the handler but leaves it invalid.\n+     * <p>\n+     * The handler can only be used after {@link #init(ObservedCollection)} is\n+     * called. This is normally done automatically by\n+     * {@link ObservedCollection#decorate(Collection, ModificationHandler)}.\n+     * \n+     * @param pre  the pre listener\n+     * @param preMask  the mask for the pre listener\n+     * @param post  the post listener\n+     * @param postMask  the mask for the post listener\n+     */\n+    public StandardModificationHandler(\n+            StandardPreModificationListener pre, int preMask,\n+            StandardPostModificationListener post, int postMask) {\n+        super();\n+        if (pre != null) {\n+            preHolder = new PreHolder[1];\n+            preHolder[0] = new PreHolder(pre, preMask);\n+            this.preMask = preMask;\n+        }\n+        if (post != null) {\n+            postHolder = new PostHolder[1];\n+            postHolder[0] = new PostHolder(post, postMask);\n+            this.postMask = postMask;\n+        }\n+    }\n+\n+    // Pre Listeners\n     //----------------------------------------------------------------------\n     /**\n-     * Gets an array of all the listeners active in the handler.\n-     * <p>\n-     * All listeners will be instances of StandardModificationListener.\n+     * Gets an array of all the pre listeners active in the handler.\n+     * <p>\n+     * All listeners will be instances of StandardPreModificationListener.\n      * \n      * @return the listeners\n      */\n-    public synchronized Object[] getModificationListeners() {\n-        Object[] lnrs = new Object[holders.length];\n-        for (int i = 0; i < holders.length; i++) {\n-            lnrs[i] = holders[i].listener;\n+    public synchronized Object[] getPreModificationListeners() {\n+        Object[] lnrs = new Object[preHolder.length];\n+        for (int i = 0; i < preHolder.length; i++) {\n+            lnrs[i] = preHolder[i].listener;\n         }\n         return lnrs;\n     }\n     \n     /**\n-     * Adds a listener to the list held in the handler.\n+     * Adds a listener to the handler for pre modification events.\n      * <p>\n      * No error occurs if the listener is <code>null</code>.\n      * \n      * @param listener  the listener to add, may be null (ignored)\n-     * @throws ClassCastException if the listener is not a StandardModificationListener\n-     */\n-    public void addModificationListener(Object listener) {\n-        addModificationListener((StandardModificationListener) listener, -1, -1);\n-    }\n-    \n-    /**\n-     * Adds a listener to the list held in the handler.\n+     * @throws ClassCastException if the listener is not a StandardPreModificationListener\n+     */\n+    public void addPreModificationListener(Object listener) {\n+        addPreModificationListener((StandardPreModificationListener) listener, -1);\n+    }\n+    \n+    /**\n+     * Adds a pre listener to the list held in the handler.\n      * <p>\n      * No error occurs if the listener is <code>null</code>.\n      * \n      * @param listener  the listener to add, may be null (ignored)\n-     * @param preMask  the mask for pre events (0 for none, -1 for all)\n-     * @param postMask  the mask for post events (0 for none, -1 for all)\n-     */\n-    public synchronized void addModificationListener(StandardModificationListener listener, int preMask, int postMask) {\n+     * @param mask  the mask for events (0 for none, -1 for all)\n+     */\n+    public synchronized void addPreModificationListener(StandardPreModificationListener listener, int mask) {\n         if (listener != null) {\n-            int oldSize = holders.length;\n-            Holder[] array = new Holder[oldSize + 1];\n-            System.arraycopy(holders, 0, array, 0, oldSize);\n-            array[oldSize] = new Holder(listener, preMask, postMask);\n-            holders = array;\n-            calculateMasks();\n-        }\n-    }\n-    \n-    /**\n-     * Removes a listener to the list held in the handler.\n+            int oldSize = preHolder.length;\n+            PreHolder[] array = new PreHolder[oldSize + 1];\n+            System.arraycopy(preHolder, 0, array, 0, oldSize);\n+            array[oldSize] = new PreHolder(listener, mask);\n+            preHolder = array;\n+            calculatePreMask();\n+        }\n+    }\n+    \n+    /**\n+     * Removes a pre listener to the list held in the handler.\n      * <p>\n      * No error occurs if the listener is not in the list or the type\n      * of the listener is incorrect.\n      * \n      * @param listener  the listener to remove, may be null (ignored)\n      */\n-    public synchronized void removeModificationListener(Object listener) {\n+    public synchronized void removePreModificationListener(Object listener) {\n         if (listener != null) {\n-            switch (holders.length) {\n+            switch (preHolder.length) {\n                 case 0:\n                 return;\n                 \n                 case 1:\n-                if (holders[0].listener == listener) {\n-                    holders = EMPTY_HOLDERS;\n-                    calculateMasks();\n+                if (preHolder[0].listener == listener) {\n+                    preHolder = EMPTY_PRE_HOLDERS;\n+                    calculatePreMask();\n                 }\n                 return;\n                 \n                 default:\n-                Holder[] array = new Holder[holders.length - 1];\n+                PreHolder[] array = new PreHolder[preHolder.length - 1];\n                 boolean match = false;\n-                for (int i = 0; i < holders.length; i++) {\n+                for (int i = 0; i < preHolder.length; i++) {\n                     if (match) {\n-                        array[i - 1] = holders[i];\n-                    } else if (holders[i].listener == listener) {\n+                        array[i - 1] = preHolder[i];\n+                    } else if (preHolder[i].listener == listener) {\n                         match = true;\n                     } else {\n-                        array[i] = holders[i];\n+                        array[i] = preHolder[i];\n                     }\n                 }\n-                holders = array;\n-                calculateMasks();\n+                preHolder = array;\n+                calculatePreMask();\n                 return;\n             }\n         }\n      * No error occurs if the listener is not in the list.\n      * The listener is matched using ==.\n      * \n+     * @param listener  the listener to change, may be null\n+     * @param mask  the new mask (0 for none, -1 for all)\n      * @return a non-null array of listeners\n      */\n-    public synchronized void setModificationListenerMasks(StandardModificationListener listener, int preMask, int postMask) {\n+    public synchronized void setPreModificationListenerMask(StandardPreModificationListener listener, int mask) {\n         if (listener != null) {\n-            for (int i = 0; i < holders.length; i++) {\n-                if (holders[i].listener == listener) {\n-                    holders[i].preMask = preMask;\n-                    holders[i].postMask = postMask;\n-                    calculateMasks();\n+            for (int i = 0; i < preHolder.length; i++) {\n+                if (preHolder[i].listener == listener) {\n+                    preHolder[i].mask = mask;\n+                    calculatePreMask();\n                     break;\n                 }\n             }\n         }\n     }\n     \n-    // Holder for listener and masks\n-    //-----------------------------------------------------------------------\n-    protected static class Holder {\n-        StandardModificationListener listener;\n-        int preMask;\n-        int postMask;\n+    /**\n+     * Calculate the combined masks.\n+     */\n+    protected void calculatePreMask() {\n+        preMask = ModificationEventType.GROUP_NONE;\n+        for (int i = 0; i < preHolder.length; i++) {\n+            preMask |= preHolder[i].mask;\n+        }\n+    }\n+    \n+    protected static class PreHolder {\n+        final StandardPreModificationListener listener;\n+        int mask;\n         \n-        Holder(StandardModificationListener listener, int preMask, int postMask) {\n+        PreHolder(StandardPreModificationListener listener, int mask) {\n             this.listener = listener;\n-            this.preMask = preMask;\n-            this.postMask = postMask;\n+            this.mask = mask;\n         }\n         \n         public String toString() {\n-            return \"[\" + listener + \",\"\n-                + ModificationEventType.toString(preMask) + \",\"\n-                + ModificationEventType.toString(postMask) + \"]\";\n-        }\n-\n-    }\n-    \n-    // Masks\n-    //-----------------------------------------------------------------------\n+            return \"[\" + listener + \",\" + ModificationEventType.toString(mask) + \"]\";\n+        }\n+\n+    }\n+    \n+    // Post Listeners\n+    //----------------------------------------------------------------------\n+    /**\n+     * Gets an array of all the post listeners active in the handler.\n+     * <p>\n+     * All listeners will be instances of StandardModificationListener.\n+     * \n+     * @return the listeners\n+     */\n+    public synchronized Object[] getPostModificationListeners() {\n+        Object[] lnrs = new Object[postHolder.length];\n+        for (int i = 0; i < postHolder.length; i++) {\n+            lnrs[i] = postHolder[i].listener;\n+        }\n+        return lnrs;\n+    }\n+    \n+    /**\n+     * Adds a listener to the handler for post modification events.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @throws ClassCastException if the listener is not a StandardPreModificationListener\n+     */\n+    public void addPostModificationListener(Object listener) {\n+        addPostModificationListener((StandardPostModificationListener) listener, -1);\n+    }\n+    \n+    /**\n+     * Adds a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is <code>null</code>.\n+     * \n+     * @param listener  the listener to add, may be null (ignored)\n+     * @param mask  the mask for events (0 for none, -1 for all)\n+     */\n+    public synchronized void addPostModificationListener(StandardPostModificationListener listener, int mask) {\n+        if (listener != null) {\n+            int oldSize = postHolder.length;\n+            PostHolder[] array = new PostHolder[oldSize + 1];\n+            System.arraycopy(postHolder, 0, array, 0, oldSize);\n+            array[oldSize] = new PostHolder(listener, mask);\n+            postHolder = array;\n+            calculatePostMask();\n+        }\n+    }\n+    \n+    /**\n+     * Removes a post listener to the list held in the handler.\n+     * <p>\n+     * No error occurs if the listener is not in the list or the type\n+     * of the listener is incorrect.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to remove, may be null (ignored)\n+     */\n+    public synchronized void removePostModificationListener(Object listener) {\n+        if (listener != null) {\n+            switch (postHolder.length) {\n+                case 0:\n+                return;\n+                \n+                case 1:\n+                if (postHolder[0].listener == listener) {\n+                    postHolder = EMPTY_POST_HOLDERS;\n+                    calculatePostMask();\n+                }\n+                return;\n+                \n+                default:\n+                PostHolder[] array = new PostHolder[postHolder.length - 1];\n+                boolean match = false;\n+                for (int i = 0; i < postHolder.length; i++) {\n+                    if (match) {\n+                        array[i - 1] = postHolder[i];\n+                    } else if (postHolder[i].listener == listener) {\n+                        match = true;\n+                    } else {\n+                        array[i] = postHolder[i];\n+                    }\n+                }\n+                postHolder = array;\n+                calculatePostMask();\n+                return;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Sets the masks of a listener.\n+     * <p>\n+     * No error occurs if the listener is not in the list.\n+     * The listener is matched using ==.\n+     * \n+     * @param listener  the listener to change, may be null\n+     * @param mask  the new mask (0 for none, -1 for all)\n+     * @return a non-null array of listeners\n+     */\n+    public synchronized void setPostModificationListenerMask(StandardPostModificationListener listener, int mask) {\n+        if (listener != null) {\n+            for (int i = 0; i < postHolder.length; i++) {\n+                if (postHolder[i].listener == listener) {\n+                    postHolder[i].mask = mask;\n+                    calculatePostMask();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n     /**\n      * Calculate the combined masks.\n      */\n-    protected void calculateMasks() {\n-        preMask = ModificationEventType.GROUP_NONE;\n+    protected void calculatePostMask() {\n         postMask = ModificationEventType.GROUP_NONE;\n-        for (int i = 0; i < holders.length; i++) {\n-            preMask |= holders[i].preMask;\n-            postMask |= holders[i].postMask;\n-        }\n-    }\n-\n+        for (int i = 0; i < postHolder.length; i++) {\n+            postMask |= postHolder[i].mask;\n+        }\n+    }\n+\n+    protected static class PostHolder {\n+        final StandardPostModificationListener listener;\n+        int mask;\n+        \n+        PostHolder(StandardPostModificationListener listener, int mask) {\n+            this.listener = listener;\n+            this.mask = mask;\n+        }\n+        \n+        public String toString() {\n+            return \"[\" + listener + \",\" + ModificationEventType.toString(mask) + \"]\";\n+        }\n+\n+    }\n+    \n     // Pre event sending\n     //-----------------------------------------------------------------------\n     /**\n         if ((preMask & type) > 0) {\n             StandardModificationEvent event = null;\n             synchronized (this) {\n-                for (int i = 0; i < holders.length; i++) {\n-                    Holder holder = holders[i];\n-                    if ((holder.preMask & type) > 0) {\n+                for (int i = 0; i < preHolder.length; i++) {\n+                    PreHolder holder = preHolder[i];\n+                    if ((holder.mask & type) > 0) {\n                         if (event == null) {\n                             event = new StandardModificationEvent(\n                                 getCollection(), this, type, preSize, index, object, repeat, null);\n         if ((postMask & type) > 0) {\n             StandardModificationEvent event = null;\n             synchronized (this) {\n-                for (int i = 0; i < holders.length; i++) {\n-                    Holder holder = holders[i];\n-                    if ((holder.postMask & type) > 0) {\n+                for (int i = 0; i < postHolder.length; i++) {\n+                    PostHolder holder = postHolder[i];\n+                    if ((holder.mask & type) > 0) {\n                         if (event == null) {\n                             event = new StandardModificationEvent(\n                                 getCollection(), this, type, preSize, index, object, repeat, result);\n--- a/src/java/org/apache/commons/collections/event/StandardModificationListener.java\n+++ b/src/java/org/apache/commons/collections/event/StandardModificationListener.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationListener.java,v 1.3 2003/08/31 21:09:49 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardModificationListener.java,v 1.4 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  */\n package org.apache.commons.collections.event;\n \n-import java.util.EventListener;\n-\n /**\n- * A listener that receives events from the <code>StandardModificationHandler</code>.\n- * <p>\n- * This listener has two methods.\n- * <ol>\n- * <li><code>modificationOccurring</code> - called before the modification\n- * occurs and can veto the change.\n- * <li><code>modificationOccurred</code> - called after the change and is\n- * for information.\n- * </ol>\n+ * A listener for the <code>StandardModificationHandler</code> that is called\n+ * both before the collection is changed and after the change has occurred.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 21:09:49 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n-public interface StandardModificationListener extends EventListener {\n+public interface StandardModificationListener \n+    extends StandardPreModificationListener, StandardPostModificationListener {\n \n-    /**\n-     * A collection modification is occurring.\n-     * <p>\n-     * To veto the change, throw <code>ModicationVetoedException</code>.\n-     * <p>\n-     * This method should be processed quickly, as with all event handling.\n-     * It should also avoid modifying the event source (the collection).\n-     * \n-     * @param event  the event detail\n-     * @throws ModicationVetoedException to veto\n-     */\n-    public void modificationOccurring(StandardModificationEvent event);\n-    \n-    /**\n-     * A collection modification occurred.\n-     * <p>\n-     * This method should be processed quickly, as with all event handling.\n-     * It should also avoid modifying the event source (the collection).\n-     * Finally it should avoid throwing an exception.\n-     * \n-     * @param event  the event detail\n-     */\n-    public void modificationOccurred(StandardModificationEvent event);\n-    \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/StandardPostModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardPostModificationListener.java,v 1.1 2003/08/31 22:44:54 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * A listener for the <code>StandardModificationHandler</code> that is called\n+ * when a collection has been changed.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/31 22:44:54 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface StandardPostModificationListener extends ModificationListener {\n+\n+    /**\n+     * A collection modification occurred.\n+     * <p>\n+     * This method should be processed quickly, as with all event handling.\n+     * It should also avoid modifying the event source (the collection).\n+     * Finally it should avoid throwing an exception.\n+     * \n+     * @param event  the event detail\n+     */\n+    public void modificationOccurred(StandardModificationEvent event);\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/event/StandardPreModificationListener.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/event/Attic/StandardPreModificationListener.java,v 1.1 2003/08/31 22:44:54 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.event;\n+\n+/**\n+ * A listener for the <code>StandardModificationHandler</code> that is called\n+ * when a collection is about to be modified.\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/08/31 22:44:54 $\n+ * \n+ * @author Stephen Colebourne\n+ */\n+public interface StandardPreModificationListener extends ModificationListener {\n+\n+    /**\n+     * A collection modification is occurring.\n+     * <p>\n+     * To veto the change, throw <code>ModicationVetoedException</code>.\n+     * <p>\n+     * This method should be processed quickly, as with all event handling.\n+     * It should also avoid modifying the event source (the collection).\n+     * \n+     * @param event  the event detail\n+     * @throws ModicationVetoedException to veto\n+     */\n+    public void modificationOccurring(StandardModificationEvent event);\n+    \n+}\n--- a/src/test/org/apache/commons/collections/decorators/ObservedTestHelper.java\n+++ b/src/test/org/apache/commons/collections/decorators/ObservedTestHelper.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/ObservedTestHelper.java,v 1.3 2003/08/31 21:09:49 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/ObservedTestHelper.java,v 1.4 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import org.apache.commons.collections.event.StandardModificationEvent;\n import org.apache.commons.collections.event.StandardModificationHandler;\n import org.apache.commons.collections.event.StandardModificationListener;\n+import org.apache.commons.collections.event.StandardPostModificationListener;\n+import org.apache.commons.collections.event.StandardPreModificationListener;\n \n /**\n  * Helper for testing\n  * {@link ObservedCollection} implementations.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.3 $ $Date: 2003/08/31 21:09:49 $\n+ * @version $Revision: 1.4 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n         }\n     }\n     \n+    public static class PreListener implements StandardPreModificationListener {\n+        public StandardModificationEvent preEvent = null;\n+        \n+        public void modificationOccurring(StandardModificationEvent event) {\n+            this.preEvent = event;\n+        }\n+    }\n+    \n+    public static class PostListener implements StandardPostModificationListener {\n+        public StandardModificationEvent postEvent = null;\n+        \n+        public void modificationOccurred(StandardModificationEvent event) {\n+            this.postEvent = event;\n+        }\n+    }\n+    \n     public static final Listener LISTENER = new Listener();\n     public static final Listener LISTENER2 = new Listener();\n+    public static final PreListener PRE_LISTENER = new PreListener();\n+    public static final PostListener POST_LISTENER = new PostListener();\n     \n     public ObservedTestHelper() {\n         super();\n     //-----------------------------------------------------------------------\n     public static void doTestFactoryPlain(ObservedCollection coll) {\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n-        Assert.assertEquals(0, coll.getModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+    public static void doTestFactoryWithPreListener(ObservedCollection coll) {\n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(PRE_LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        PRE_LISTENER.preEvent = null;\n+        coll.add(SIX);\n+        Assert.assertTrue(PRE_LISTENER.preEvent != null);\n+    }\n+    \n+    public static void doTestFactoryWithPostListener(ObservedCollection coll) {\n+        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(POST_LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        POST_LISTENER.postEvent = null;\n+        coll.add(SIX);\n+        Assert.assertTrue(POST_LISTENER.postEvent != null);\n     }\n     \n     public static void doTestFactoryWithListener(ObservedCollection coll) {\n         Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n-        Assert.assertEquals(1, coll.getModificationListeners().length);\n-        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n-    }\n-    \n-    public static void doTestFactoryPostEvents(ObservedCollection coll) {\n-        Assert.assertEquals(StandardModificationHandler.class, coll.getHandler().getClass());\n-        Assert.assertEquals(1, coll.getModificationListeners().length);\n-        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n         \n         LISTENER.preEvent = null;\n         LISTENER.postEvent = null;\n         coll.add(SIX);\n-        Assert.assertTrue(LISTENER.preEvent == null);\n+        Assert.assertTrue(LISTENER.preEvent != null);\n         Assert.assertTrue(LISTENER.postEvent != null);\n     }\n     \n     //-----------------------------------------------------------------------\n-    public static void doTestAddRemoveGetListeners(ObservedCollection coll) {\n-        Assert.assertEquals(0, coll.getModificationListeners().length);\n-        coll.addModificationListener(LISTENER);\n-        Assert.assertEquals(1, coll.getModificationListeners().length);\n-        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n-        \n-        coll.addModificationListener(LISTENER2);\n-        Assert.assertEquals(2, coll.getModificationListeners().length);\n-        Assert.assertSame(LISTENER, coll.getModificationListeners()[0]);\n-        Assert.assertSame(LISTENER2, coll.getModificationListeners()[1]);\n-        \n-        coll.removeModificationListener(LISTENER);\n-        Assert.assertEquals(1, coll.getModificationListeners().length);\n-        Assert.assertSame(LISTENER2, coll.getModificationListeners()[0]);\n-        \n-        coll.removeModificationListener(LISTENER);  // check no error if not present\n-        Assert.assertEquals(1, coll.getModificationListeners().length);\n-        Assert.assertSame(LISTENER2, coll.getModificationListeners()[0]);\n-        \n-        coll.removeModificationListener(LISTENER2);\n-        Assert.assertEquals(0, coll.getModificationListeners().length);\n+    public static void doTestAddRemoveGetPreListeners(ObservedCollection coll) {\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        coll.getHandler().addPreModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        coll.getHandler().addPreModificationListener(LISTENER2);\n+        Assert.assertEquals(2, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPreModificationListeners()[0]);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPreModificationListeners()[1]);\n+        \n+        coll.getHandler().removePreModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        coll.getHandler().removePreModificationListener(LISTENER);  // check no error if not present\n+        Assert.assertEquals(1, coll.getHandler().getPreModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPreModificationListeners()[0]);\n+        \n+        coll.getHandler().removePreModificationListener(LISTENER2);\n+        Assert.assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n         \n         try {\n-            coll.addModificationListener(new Object());\n+            coll.getHandler().addPreModificationListener(new Object());\n+            Assert.fail();\n+        } catch (ClassCastException ex) {\n+        }\n+    }\n+    \n+    public static void doTestAddRemoveGetPostListeners(ObservedCollection coll) {\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+        coll.getHandler().addPostModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        coll.getHandler().addPostModificationListener(LISTENER2);\n+        Assert.assertEquals(2, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER, coll.getHandler().getPostModificationListeners()[0]);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPostModificationListeners()[1]);\n+        \n+        coll.getHandler().removePostModificationListener(LISTENER);\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        coll.getHandler().removePostModificationListener(LISTENER);  // check no error if not present\n+        Assert.assertEquals(1, coll.getHandler().getPostModificationListeners().length);\n+        Assert.assertSame(LISTENER2, coll.getHandler().getPostModificationListeners()[0]);\n+        \n+        coll.getHandler().removePostModificationListener(LISTENER2);\n+        Assert.assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+        \n+        try {\n+            coll.getHandler().addPostModificationListener(new Object());\n             Assert.fail();\n         } catch (ClassCastException ex) {\n         }\n--- a/src/test/org/apache/commons/collections/decorators/TestObservedCollection.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestObservedCollection.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedCollection.java,v 1.2 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedCollection.java,v 1.3 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.TestCollection;\n-import org.apache.commons.collections.event.ModificationEventType;\n import org.apache.commons.collections.event.StandardModificationHandler;\n \n /**\n  * {@link ObservedCollection} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n     private static Integer SEVEN = new Integer(7);\n     private static Integer EIGHT = new Integer(8);\n     private static final ObservedTestHelper.Listener LISTENER = ObservedTestHelper.LISTENER;\n+    private static final ObservedTestHelper.PreListener PRE_LISTENER = ObservedTestHelper.PRE_LISTENER;\n+    private static final ObservedTestHelper.PostListener POST_LISTENER = ObservedTestHelper.POST_LISTENER;\n     \n     public TestObservedCollection(String testName) {\n         super(testName);\n         coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n         ObservedTestHelper.doTestFactoryWithListener(coll);\n         \n-        coll = ObservedCollection.decoratePostEventsOnly(new ArrayList(), LISTENER);\n-        ObservedTestHelper.doTestFactoryPostEvents(coll);\n+        coll = ObservedCollection.decorate(new ArrayList(), PRE_LISTENER);\n+        ObservedTestHelper.doTestFactoryWithPreListener(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList(), POST_LISTENER);\n+        ObservedTestHelper.doTestFactoryWithPostListener(coll);\n         \n         coll = ObservedCollection.decorate(new ArrayList());\n-        ObservedTestHelper.doTestAddRemoveGetListeners(coll);\n+        ObservedTestHelper.doTestAddRemoveGetPreListeners(coll);\n+        \n+        coll = ObservedCollection.decorate(new ArrayList());\n+        ObservedTestHelper.doTestAddRemoveGetPostListeners(coll);\n         \n         coll = ObservedCollection.decorate(new ArrayList(), LISTENER);\n         ObservedTestHelper.doTestAdd(coll);\n         ObservedCollection coll = ObservedCollection.decorate(new ArrayList(), handler);\n         \n         assertSame(handler, coll.getHandler());\n-        assertEquals(0, coll.getModificationListeners().length);\n-    }\n-    \n-    public void testFactoryWithMasks() {\n-        ObservedCollection coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, 0);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent == null);\n-        \n-        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, -1);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent == null);\n-        assertTrue(LISTENER.postEvent != null);\n-        \n-        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, -1);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent != null);\n-        \n-        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, 0);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent == null);\n-        assertTrue(LISTENER.postEvent == null);\n-        \n-        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent == null);\n-    }\n-    \n+        assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+//    public void testFactoryWithMasks() {\n+//        ObservedCollection coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, 0);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//        \n+//        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, -1);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent == null);\n+//        assertTrue(LISTENER.postEvent != null);\n+//        \n+//        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, -1, -1);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent != null);\n+//        \n+//        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, 0, 0);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent == null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//        \n+//        coll = ObservedCollection.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//    }\n+//    \n }\n--- a/src/test/org/apache/commons/collections/decorators/TestObservedList.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestObservedList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedList.java,v 1.2 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedList.java,v 1.3 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.TestList;\n-import org.apache.commons.collections.event.ModificationEventType;\n import org.apache.commons.collections.event.StandardModificationHandler;\n \n /**\n  * {@link ObservedList} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n     private static Integer SEVEN = new Integer(7);\n     private static Integer EIGHT = new Integer(8);\n     private static final ObservedTestHelper.Listener LISTENER = ObservedTestHelper.LISTENER;\n+    private static final ObservedTestHelper.PreListener PRE_LISTENER = ObservedTestHelper.PRE_LISTENER;\n+    private static final ObservedTestHelper.PostListener POST_LISTENER = ObservedTestHelper.POST_LISTENER;\n     \n     public TestObservedList(String testName) {\n         super(testName);\n         coll = ObservedList.decorate(new ArrayList(), LISTENER);\n         ObservedTestHelper.doTestFactoryWithListener(coll);\n         \n-        coll = ObservedList.decoratePostEventsOnly(new ArrayList(), LISTENER);\n-        ObservedTestHelper.doTestFactoryPostEvents(coll);\n+        coll = ObservedList.decorate(new ArrayList(), PRE_LISTENER);\n+        ObservedTestHelper.doTestFactoryWithPreListener(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList(), POST_LISTENER);\n+        ObservedTestHelper.doTestFactoryWithPostListener(coll);\n         \n         coll = ObservedList.decorate(new ArrayList());\n-        ObservedTestHelper.doTestAddRemoveGetListeners(coll);\n+        ObservedTestHelper.doTestAddRemoveGetPreListeners(coll);\n+        \n+        coll = ObservedList.decorate(new ArrayList());\n+        ObservedTestHelper.doTestAddRemoveGetPostListeners(coll);\n         \n         coll = ObservedList.decorate(new ArrayList(), LISTENER);\n         ObservedTestHelper.doTestAdd(coll);\n         ObservedList coll = ObservedList.decorate(new ArrayList(), handler);\n         \n         assertSame(handler, coll.getHandler());\n-        assertEquals(0, coll.getModificationListeners().length);\n-    }\n-    \n-    public void testFactoryWithMasks() {\n-        ObservedList coll = ObservedList.decorate(new ArrayList(), LISTENER, -1, 0);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent == null);\n-        \n-        coll = ObservedList.decorate(new ArrayList(), LISTENER, 0, -1);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent == null);\n-        assertTrue(LISTENER.postEvent != null);\n-        \n-        coll = ObservedList.decorate(new ArrayList(), LISTENER, -1, -1);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent != null);\n-        \n-        coll = ObservedList.decorate(new ArrayList(), LISTENER, 0, 0);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent == null);\n-        assertTrue(LISTENER.postEvent == null);\n-        \n-        coll = ObservedList.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent == null);\n-    }\n-    \n+        assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+//    public void testFactoryWithMasks() {\n+//        ObservedList coll = ObservedList.decorate(new ArrayList(), LISTENER, -1, 0);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//        \n+//        coll = ObservedList.decorate(new ArrayList(), LISTENER, 0, -1);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent == null);\n+//        assertTrue(LISTENER.postEvent != null);\n+//        \n+//        coll = ObservedList.decorate(new ArrayList(), LISTENER, -1, -1);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent != null);\n+//        \n+//        coll = ObservedList.decorate(new ArrayList(), LISTENER, 0, 0);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent == null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//        \n+//        coll = ObservedList.decorate(new ArrayList(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//    }\n+//    \n }\n--- a/src/test/org/apache/commons/collections/decorators/TestObservedSet.java\n+++ b/src/test/org/apache/commons/collections/decorators/TestObservedSet.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedSet.java,v 1.2 2003/08/31 17:28:42 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/decorators/Attic/TestObservedSet.java,v 1.3 2003/08/31 22:44:54 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n import junit.framework.TestSuite;\n \n import org.apache.commons.collections.TestSet;\n-import org.apache.commons.collections.event.ModificationEventType;\n import org.apache.commons.collections.event.StandardModificationHandler;\n \n /**\n  * {@link ObservedSet} implementation.\n  *\n  * @since Commons Collections 3.0\n- * @version $Revision: 1.2 $ $Date: 2003/08/31 17:28:42 $\n+ * @version $Revision: 1.3 $ $Date: 2003/08/31 22:44:54 $\n  * \n  * @author Stephen Colebourne\n  */\n     private static Integer SEVEN = new Integer(7);\n     private static Integer EIGHT = new Integer(8);\n     private static final ObservedTestHelper.Listener LISTENER = ObservedTestHelper.LISTENER;\n+    private static final ObservedTestHelper.PreListener PRE_LISTENER = ObservedTestHelper.PRE_LISTENER;\n+    private static final ObservedTestHelper.PostListener POST_LISTENER = ObservedTestHelper.POST_LISTENER;\n     \n     public TestObservedSet(String testName) {\n         super(testName);\n         coll = ObservedSet.decorate(new HashSet(), LISTENER);\n         ObservedTestHelper.doTestFactoryWithListener(coll);\n         \n-        coll = ObservedSet.decoratePostEventsOnly(new HashSet(), LISTENER);\n-        ObservedTestHelper.doTestFactoryPostEvents(coll);\n+        coll = ObservedSet.decorate(new HashSet(), PRE_LISTENER);\n+        ObservedTestHelper.doTestFactoryWithPreListener(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet(), POST_LISTENER);\n+        ObservedTestHelper.doTestFactoryWithPostListener(coll);\n         \n         coll = ObservedSet.decorate(new HashSet());\n-        ObservedTestHelper.doTestAddRemoveGetListeners(coll);\n+        ObservedTestHelper.doTestAddRemoveGetPreListeners(coll);\n+        \n+        coll = ObservedSet.decorate(new HashSet());\n+        ObservedTestHelper.doTestAddRemoveGetPostListeners(coll);\n         \n         coll = ObservedSet.decorate(new HashSet(), LISTENER);\n         ObservedTestHelper.doTestAdd(coll);\n         ObservedSet coll = ObservedSet.decorate(new HashSet(), handler);\n         \n         assertSame(handler, coll.getHandler());\n-        assertEquals(0, coll.getModificationListeners().length);\n-    }\n-    \n-    public void testFactoryWithMasks() {\n-        ObservedSet coll = ObservedSet.decorate(new HashSet(), LISTENER, -1, 0);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent == null);\n-        \n-        coll = ObservedSet.decorate(new HashSet(), LISTENER, 0, -1);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent == null);\n-        assertTrue(LISTENER.postEvent != null);\n-        \n-        coll = ObservedSet.decorate(new HashSet(), LISTENER, -1, -1);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent != null);\n-        \n-        coll = ObservedSet.decorate(new HashSet(), LISTENER, 0, 0);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent == null);\n-        assertTrue(LISTENER.postEvent == null);\n-        \n-        coll = ObservedSet.decorate(new HashSet(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n-        LISTENER.preEvent = null;\n-        LISTENER.postEvent = null;\n-        coll.add(SIX);\n-        assertTrue(LISTENER.preEvent != null);\n-        assertTrue(LISTENER.postEvent == null);\n-    }\n-    \n+        assertEquals(0, coll.getHandler().getPreModificationListeners().length);\n+        assertEquals(0, coll.getHandler().getPostModificationListeners().length);\n+    }\n+    \n+//    public void testFactoryWithMasks() {\n+//        ObservedSet coll = ObservedSet.decorate(new HashSet(), LISTENER, -1, 0);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//        \n+//        coll = ObservedSet.decorate(new HashSet(), LISTENER, 0, -1);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent == null);\n+//        assertTrue(LISTENER.postEvent != null);\n+//        \n+//        coll = ObservedSet.decorate(new HashSet(), LISTENER, -1, -1);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent != null);\n+//        \n+//        coll = ObservedSet.decorate(new HashSet(), LISTENER, 0, 0);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent == null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//        \n+//        coll = ObservedSet.decorate(new HashSet(), LISTENER, ModificationEventType.ADD, ModificationEventType.ADD_ALL);\n+//        LISTENER.preEvent = null;\n+//        LISTENER.postEvent = null;\n+//        coll.add(SIX);\n+//        assertTrue(LISTENER.preEvent != null);\n+//        assertTrue(LISTENER.postEvent == null);\n+//    }\n+//    \n }", "timestamp": 1062369894, "metainfo": ""}