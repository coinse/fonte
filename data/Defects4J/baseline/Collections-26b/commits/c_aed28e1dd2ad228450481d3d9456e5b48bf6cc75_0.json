{"sha": "aed28e1dd2ad228450481d3d9456e5b48bf6cc75", "log": "Added framework to modularize collections tests such the testing code used for testing collections, maps, etc., can be reused to test collections, maps, etc. that are returned from other collections.  For example, the Map interface defines entrySet() which is supposed to return a valid Set.  The framework added here would allow the Set testing code to be used for testing Sets and the set returned from Map's entrySet() method.  Submitted by: Paul Jack < pjack at sfaf dot org >   ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/BulkTest.java\n+package org.apache.commons.collections;\n+\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ *  A {@link TestCase} that can define both simple and bulk test methods.<P>\n+ *\n+ *  A <I>simple test method</I> is the type of test traditionally \n+ *  supplied by by {@link TestCase}.  To define a simple test, create a public \n+ *  no-argument method whose name starts with \"test\".  You can specify the\n+ *  the name of simple test in the constructor of <Code>BulkTest</Code>;\n+ *  a subsequent call to {@link TestCase#run} will run that simple test.<P>\n+ *\n+ *  A <I>bulk test method</I>, on the other hand, returns a new instance\n+ *  of <Code>BulkTest</Code>, which can itself define new simple and bulk\n+ *  test methods.  By using the {@link #makeSuite} method, you can \n+ *  automatically create a hierarchal suite of tests and child bulk tests.<P>\n+ *\n+ *  For instance, consider the following two classes:\n+ *\n+ *  <Pre>\n+ *  public class TestSet extends BulkTest {\n+ *\n+ *      private Set set;\n+ *\n+ *      public TestSet(Set set) {\n+ *          this.set = set;\n+ *      }\n+ *\n+ *      public void testContains() {\n+ *          boolean r = set.contains(set.iterator().next()));\n+ *          assertTrue(\"Set should contain first element, r);\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          set.clear();\n+ *          assertTrue(\"Set should be empty after clear\", set.isEmpty());\n+ *      }\n+ *  }\n+ *\n+ *\n+ *  public class TestHashMap extends BulkTest {\n+ *\n+ *      private Map makeFullMap() {\n+ *          HashMap result = new HashMap();\n+ *          result.put(\"1\", \"One\");\n+ *          result.put(\"2\", \"Two\");\n+ *          return result;\n+ *      }\n+ *\n+ *      public void testClear() {\n+ *          Map map = makeFullMap();\n+ *          map.clear();\n+ *          assertTrue(\"Map empty after clear\", map.isEmpty());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestKeySet() {\n+ *          return new TestSet(makeFullMap().keySet());\n+ *      }\n+ *\n+ *      public BulkTest bulkTestEntrySet() {\n+ *          return new TestSet(makeFullMap().entrySet());\n+ *      }\n+ *  }\n+ *  </Pre>\n+ *\n+ *  In the above examples, <Code>TestSet</Code> defines two\n+ *  simple test methods and no bulk test methods; <Code>TestHashMap</Code>\n+ *  defines one simple test method and two bulk test methods.  When\n+ *  <Code>makeSuite(TestHashMap.class).run</Code> is executed, \n+ *  <I>five</I> simple test methods will be run, in this order:<P>\n+ *\n+ *  <Ol>\n+ *  <Li>TestHashMap.testClear()\n+ *  <Li>TestHashMap.bulkTestKeySet().testContains();\n+ *  <Li>TestHashMap.bulkTestKeySet().testClear();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testContains();\n+ *  <Li>TestHashMap.bulkTestEntrySet().testClear();\n+ *  </Ol>\n+ *\n+ *  In the graphical junit test runners, the tests would be displayed in\n+ *  the following tree:<P>\n+ *\n+ *  <UL>\n+ *  <LI>TestHashMap</LI>\n+ *      <UL>\n+ *      <LI>testClear\n+ *      <LI>bulkTestKeySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      <LI>bulkTestEntrySet\n+ *          <UL>\n+ *          <LI>testContains\n+ *          <LI>testClear\n+ *          </UL>\n+ *      </UL>\n+ *  </UL>\n+ *\n+ *  A subclass can override a superclass's bulk test by\n+ *  returning <Code>null</Code> from the bulk test method.  If you only\n+ *  want to override specific simple tests within a bulk test, use the\n+ *  {@link #ignoredSimpleTests} method.<P>\n+ *\n+ *  Note that if you want to use the bulk test methods, you <I>must</I>\n+ *  define your <Code>suite()</Code> method to use {@link #makeSuite}.\n+ *  The ordinary {@link TestSuite} constructor doesn't know how to \n+ *  interpret bulk test methods.\n+ *\n+ *  @author Paul Jack\n+ *  @version $Id: BulkTest.java,v 1.1 2002/06/18 01:04:03 mas Exp $\n+ */\n+public class BulkTest extends TestCase implements Cloneable {\n+\n+\n+    // Note:  BulkTest is Cloneable to make it easier to construct \n+    // BulkTest instances for simple test methods that are defined in \n+    // anonymous inner classes.  Basically we don't have to worry about\n+    // finding wierd constructors.  (And even if we found them, techinically\n+    // it'd be illegal for anyone but the outer class to invoke them).  \n+    // Given one BulkTest instance, we can just clone it and reset the \n+    // method name for every simple test it defines.  \n+\n+\n+    /**\n+     *  The full name of this bulk test instance.  This is the full name\n+     *  that is compared to {@link #ignoredSimpleTests} to see if this\n+     *  test should be ignored.  It's also displayed in the text runner\n+     *  to ease debugging.\n+     */\n+    String verboseName;\n+\n+\n+    /**\n+     *  Constructs a new <Code>BulkTest</Code> instance that will run the\n+     *  specified simple test.\n+     *\n+     *  @param name  the name of the simple test method to run\n+     */\n+    public BulkTest(String name) {\n+        super(name);\n+        this.verboseName = getClass().getName();\n+    }\n+\n+\n+    /**\n+     *  Creates a clone of this <Code>BulkTest</Code>.<P>\n+     *\n+     *  @return  a clone of this <Code>BulkTest</Code>\n+     */\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new Error(); // should never happen\n+        }\n+    }\n+\n+\n+    /**\n+     *  Returns an array of simple test names to ignore.<P>\n+     *\n+     *  If a simple test that's defined by this <Code>BulkTest</Code> or\n+     *  by one of its bulk test methods has a name that's in the returned\n+     *  array, then that simple test will not be executed.<P>\n+     *\n+     *  A simple test's name is formed by taking the class name of the\n+     *  root <Code>BulkTest</Code>, eliminating the package name, then\n+     *  appending the names of any bulk test methods that were invoked\n+     *  to get to the simple test, and then appending the simple test\n+     *  method name.  The method names are delimited by periods:\n+     *\n+     *  <Pre>\n+     *  TestHashMap.bulkTestEntrySet.testClear\n+     *  </Pre>\n+     *\n+     *  is the name of one of the simple tests defined in the sample classes\n+     *  described above.  If the sample <Code>TestHashMap</Code> class\n+     *  included this method:\n+     *\n+     *  <Pre>\n+     *  public String[] ignoredSimpleTests() {\n+     *      return new String[] { \"TestHashMap.bulkTestEntrySet.testClear\" };\n+     *  }\n+     *  </Pre>\n+     *\n+     *  then the entry set's clear method wouldn't be tested, but the key\n+     *  set's clear method would.\n+     *\n+     *  @return an array of the names of simple tests to ignore, or null if\n+     *   no tests should be ignored\n+     */\n+    public String[] ignoredSimpleTests() {\n+        return null;\n+    }\n+\n+\n+    /**\n+     *  Returns the display name of this <Code>BulkTest</Code>.\n+     *\n+     *  @return the display name of this <Code>BulkTest</Code>\n+     */\n+    public String toString() {\n+        return getName() + \"(\" + verboseName + \") \";\n+    }\n+\n+\n+    /**\n+     *  Returns a {@link TestSuite} for testing all of the simple tests\n+     *  <I>and</I> all the bulk tests defined by the given class.<P>\n+     *\n+     *  The class is examined for simple and bulk test methods; any child\n+     *  bulk tests are also examined recursively; and the results are stored\n+     *  in a hierarchal {@link TestSuite}.<P>\n+     *\n+     *  The given class must be a subclass of <Code>BulkTest</Code> and must\n+     *  not be abstract.<P>\n+     *\n+     *  @param c  the class to examine for simple and bulk tests\n+     *  @return  a {@link TestSuite} containing all the simple and bulk tests\n+     *    defined by that class\n+     */\n+    public static TestSuite makeSuite(Class c) {\n+        if (Modifier.isAbstract(c.getModifiers())) {\n+            throw new IllegalArgumentException(\"Class must not be abstract.\");\n+        }\n+        if (!BulkTest.class.isAssignableFrom(c)) {\n+            throw new IllegalArgumentException(\"Class must extend BulkTest.\");\n+        }\n+        return new BulkTestSuiteMaker(c).make();\n+    }\n+\n+}\n+\n+\n+// It was easier to use a separate class to do all the reflection stuff\n+// for making the TestSuite instances.  Having permanent state around makes\n+// it easier to handle the recursion.\n+class BulkTestSuiteMaker {\n+\n+\n+    /** The class that defines simple and bulk tests methods. */\n+    private Class startingClass;\n+\n+\n+    /** List of ignored simple test names. */\n+    private List ignored;\n+\n+   \n+    /** The TestSuite we're currently populating.  Can change over time. */\n+    private TestSuite result;\n+\n+\n+    /** \n+     *  The prefix for simple test methods.  Used to check if a test is in \n+     *  the ignored list.\n+     */ \n+    private String prefix;\n+\n+\n+    /** \n+     *  Constructor.\n+     *\n+     *  @param startingClass  the starting class\n+     */     \n+    public BulkTestSuiteMaker(Class startingClass) {\n+        this.startingClass = startingClass;\n+    }\n+\n+\n+    /**\n+     *  Makes a hierarchal TestSuite based on the starting class.\n+     *\n+     *  @return  the hierarchal TestSuite for startingClass\n+     */\n+    public TestSuite make() {\n+         this.result = new TestSuite();\n+         this.prefix = getBaseName(startingClass);\n+         result.setName(prefix);\n+\n+         BulkTest bulk = makeFirstTestCase(startingClass);\n+         ignored = new ArrayList();\n+         String[] s = bulk.ignoredSimpleTests();\n+         if (s != null) {\n+             ignored.addAll(Arrays.asList(s));\n+         }\n+         make(bulk);\n+         return result;\n+    }\n+\n+\n+    /**\n+     *  Appends all the simple tests and bulk tests defined by the given\n+     *  instance's class to the current TestSuite.\n+     *\n+     *  @param bulk  An instance of the class that defines simple and bulk\n+     *    tests for us to append\n+     */\n+    void make(BulkTest bulk) {\n+        Class c = bulk.getClass();\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) addTest(bulk, all[i]);\n+            if (isBulk(all[i])) addBulk(bulk, all[i]);\n+        }\n+    }\n+\n+\n+    /**\n+     *  Adds the simple test defined by the given method to the TestSuite.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *   (I know it's wierd.  But the point is, we can clone the instance\n+     *   and not have to worry about constructors.)\n+     *  @param m  The simple test method\n+     */\n+    void addTest(BulkTest bulk, Method m) {\n+        BulkTest bulk2 = (BulkTest)bulk.clone();\n+        bulk2.setName(m.getName());\n+        bulk2.verboseName = prefix + \".\" + m.getName();\n+        if (ignored.contains(bulk2.verboseName)) return;\n+        result.addTest(bulk2);\n+    }\n+\n+\n+    /**\n+     *  Adds a whole new suite of tests that are defined by the result of\n+     *  the given bulk test method.  In other words, the given bulk test\n+     *  method is invoked, and the resulting BulkTest instance is examined\n+     *  for yet more simple and bulk tests.\n+     *\n+     *  @param bulk  The instance of the class that defined the method\n+     *  @param m  The bulk test method\n+     */\n+    void addBulk(BulkTest bulk, Method m) {\n+        BulkTest bulk2;\n+        try {\n+            bulk2 = (BulkTest)m.invoke(bulk, null);\n+            if (bulk2 == null) return;\n+        } catch (InvocationTargetException e) {\n+            throw new Error(); // FIXME;\n+        } catch (IllegalAccessException e) {\n+            throw new Error(); // FIXME;\n+        }\n+\n+        // Save current state on the stack.\n+        String oldPrefix = prefix;\n+        TestSuite oldResult = result;\n+\n+        prefix = prefix + \".\" + m.getName();\n+        result = new TestSuite();\n+        result.setName(m.getName());\n+\n+        make(bulk2);\n+\n+        oldResult.addTest(result);\n+\n+        // Restore the old state\n+        prefix = oldPrefix;\n+        result = oldResult;\n+    }\n+\n+\n+    /**\n+     *  Returns the base name of the given class.\n+     *\n+     *  @param c  the class\n+     *  @return the name of that class, minus any package names\n+     */\n+    private static String getBaseName(Class c) {\n+        String name = c.getName();\n+        int p = name.lastIndexOf('.');\n+        if (p > 0) {\n+            name = name.substring(p + 1);\n+        }\n+        return name;\n+    }\n+\n+\n+    // These three methods are used to create a valid BulkTest instance\n+    // from a class.\n+\n+    private static Constructor getTestCaseConstructor(Class c) {\n+        try {\n+            return c.getConstructor(new Class[] { String.class });\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(c + \" must provide \" +\n+             \"a (String) constructor\");\n+        }\n+    }\n+\n+\n+    private static BulkTest makeTestCase(Class c, Method m) {\n+        Constructor con = getTestCaseConstructor(c);\n+        try {\n+            return (BulkTest)con.newInstance(new String[] { m.getName() });\n+        } catch (InvocationTargetException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(); // FIXME;\n+        } catch (IllegalAccessException e) {\n+            throw new Error(); // should never occur\n+        } catch (InstantiationException e) {\n+            throw new RuntimeException(); // FIXME;\n+        }\n+    }\n+\n+\n+    private static BulkTest makeFirstTestCase(Class c) {\n+        Method[] all = c.getMethods();\n+        for (int i = 0; i < all.length; i++) {\n+            if (isTest(all[i])) return makeTestCase(c, all[i]);\n+        }\n+        throw new IllegalArgumentException(c.getName() + \" must provide \" \n+          + \" at least one test method.\");\n+    }\n+\n+\n+    /**\n+     *  Returns true if the given method is a simple test method.\n+     */\n+    private static boolean isTest(Method m) {\n+        if (!m.getName().startsWith(\"test\")) return false;\n+        if (m.getReturnType() != Void.TYPE) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+\n+    /**\n+     *  Returns true if the given method is a bulk test method.\n+     */\n+    private static boolean isBulk(Method m) {\n+        if (!m.getName().startsWith(\"bulkTest\")) return false;\n+        if (m.getReturnType() != BulkTest.class) return false;\n+        if (m.getParameterTypes().length != 0) return false;\n+        int mods = m.getModifiers();\n+        if (Modifier.isStatic(mods)) return false;\n+        if (Modifier.isAbstract(mods)) return false;\n+        return true;\n+    }\n+\n+\n+}\n--- a/src/test/org/apache/commons/collections/TestObject.java\n+++ b/src/test/org/apache/commons/collections/TestObject.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestObject.java,v 1.10 2002/03/01 18:36:21 morgand Exp $\n- * $Revision: 1.10 $\n- * $Date: 2002/03/01 18:36:21 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/Attic/TestObject.java,v 1.11 2002/06/18 01:04:03 mas Exp $\n+ * $Revision: 1.11 $\n+ * $Date: 2002/06/18 01:04:03 $\n  *\n  * ====================================================================\n  *\n  * test case (method) your {@link Object} fails.\n  *\n  * @author Rodney Waldhoff\n- * @version $Id: TestObject.java,v 1.10 2002/03/01 18:36:21 morgand Exp $\n+ * @version $Id: TestObject.java,v 1.11 2002/06/18 01:04:03 mas Exp $\n  */\n-public abstract class TestObject extends TestCase {\n+public abstract class TestObject extends BulkTest {\n     public TestObject(String testName) {\n         super(testName);\n     }", "timestamp": 1024362243, "metainfo": ""}