{"sha": "39dd7c6f92e66d07842fd8a517cb750d4c912126", "log": "Added BucketMap, renamed to StaticBucketMap, from Avalon Excaliber.  I made the following changes to the Avalon implementation:  Changed improper short form of license to the approved long form.  Changed package from org.apache.avalon.excaliber.collections to org.apache.commons.collections.  Altered to allow null keys and null values.  Fixed the values() method to return all values from the map.  That is, when a particular value is mapped to from two different keys, it should be included twice in the values() collection; however the avalon implementation was using a Set (thus not including duplicates). The new implementation uses a list which does not restrict duplicate elements.  Fixed the put(Object,Object) method to return null rather than the value being put into the map when the key does not already exist in the map (per the Map contract).  Added equals(Object) and hashCode() implementations to conform to the Map contract.  Altered the Node inner class's hashCode() method to return the hashCode of the Map.Entry as defined in the Map.Entry's contract.  Added an equals(Object) method to the Node inner class to conform to the Map.Entry contract.   Things left todo:  Alter the keySet(), values(), and entrySet() methods to return collections that are backed by the map per the Map contract.  Add a constructor that takes another Map and adds all the mappings from that map (per the Map recommendation).  Implement a DynamicBucketMap that will allow for dynamic resizing of the hashtable's structure such that the map will not suffer a performance penalty when the number of elements in the map exceeds the number of buckets in the map.  Improve the documentation to indicate the performance problems when specifying a size that is smaller than the expected number of elements.  Other general documentation cleanup   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/StaticBucketMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/StaticBucketMap.java,v 1.1 2002/06/21 06:17:45 mas Exp $\n+ * $Revision: 1.1 $\n+ * $Date: 2002/06/21 06:17:45 $\n+ *\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 1999-2002 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Group.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.ArrayList;\n+\n+/**\n+ * A StaticBucketMap is an efficient thread-safe implementation of the\n+ * <code>java.util.Map</code>.  The map supports <code>get</code>,\n+ * <code>put</code>, and <code>contains</code> methods most efficiently.\n+ * The other methods are supported, but are ver inneficient compared to\n+ * other <code>java.util.Map</code> implementations.\n+ *\n+ * @author  <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n+ * @author  <a href=\"mailto:g-froehlich@gmx.de\">Gerhard Froehlich</a>\n+ * @author  <a href-\"mailto:mas@apache.org\">Michael A. Smith</a>\n+ * @version CVS $Revision: 1.1 $ $Date: 2002/06/21 06:17:45 $\n+ * @since Avalon 4.0\n+ */\n+public final class StaticBucketMap implements Map\n+{\n+    private static final int DEFAULT_BUCKETS = 255;\n+    private final Node[] m_buckets;\n+    private final Object[] m_locks;\n+\n+    /**\n+     * Initializes the map with the default number of buckets (255).\n+     */\n+    public StaticBucketMap()\n+    {\n+        this( DEFAULT_BUCKETS );\n+    }\n+\n+    /**\n+     * Initializes the map with a specified number of buckets.  The number\n+     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n+     * ensures this). The number of buckets is inversely proportional to the\n+     * chances for thread contention.  The fewer buckets, the more chances for\n+     * thread contention.  The more buckets the fewer chances for thread\n+     * contention.\n+     */\n+    public StaticBucketMap( int numBuckets )\n+    {\n+        int size = Math.max( 17, numBuckets );\n+\n+        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n+        if( size % 2 == 0 )\n+        {\n+            size--;\n+        }\n+\n+        m_buckets = new Node[ size ];\n+        m_locks = new Object[ size ];\n+\n+        for( int i = 0; i < size; i++ )\n+        {\n+            m_locks[ i ] = new Object();\n+        }\n+    }\n+\n+    /**\n+     * Determine the exact hash entry for the key.  The hash algorithm\n+     * is rather simplistic, but it does the job:\n+     *\n+     * <pre>\n+     *   He = |Hk mod n|\n+     * </pre>\n+     *\n+     * <p>\n+     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n+     *   the number of buckets.\n+     * </p>\n+     */\n+    private final int getHash( Object key )\n+    {\n+        if( key == null ) return 0;\n+        final int hash = key.hashCode() % m_buckets.length;\n+        return ( hash < 0 ) ? hash * -1 : hash;\n+    }\n+\n+    /**\n+     * Obtain a Set for the keys.  This operation crosses bucket boundaries,\n+     * so it is less efficient, and greatly increases the chance for thread\n+     * contention.\n+     */\n+    public Set keySet()\n+    {\n+        Set keySet = new HashSet();\n+\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            synchronized( m_locks[ i ] )\n+            {\n+                Node n = m_buckets[ i ];\n+\n+                while( n != null )\n+                {\n+                    keySet.add( n.key );\n+                    n = n.next;\n+                }\n+            }\n+        }\n+\n+        return keySet;\n+    }\n+\n+    /**\n+     * Returns the current number of key, value pairs.\n+     */\n+    public int size()\n+    {\n+        int cnt = 0;\n+\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            synchronized( m_locks[ i ] )\n+            {\n+                Node n = m_buckets[ i ];\n+\n+                while( n != null )\n+                {\n+                    cnt++;\n+                    n = n.next;\n+                }\n+            }\n+        }\n+\n+        return cnt;\n+    }\n+\n+    /**\n+     * Put a reference in the Map.\n+     */\n+    public Object put( final Object key, final Object value )\n+    {\n+        int hash = getHash( key );\n+\n+        synchronized( m_locks[ hash ] )\n+        {\n+            Node n = m_buckets[ hash ];\n+\n+            if( n == null )\n+            {\n+                n = new Node();\n+                n.key = key;\n+                n.value = value;\n+                m_buckets[ hash ] = n;\n+                return null;\n+            }\n+\n+            // Set n to the last node in the linked list.  Check each key along the way\n+            //  If the key is found, then change the value of that node and return\n+            //  the old value.\n+            for( Node next = n; next != null; next = next.next )\n+            {\n+                n = next;\n+\n+                if( n.key == key || ( n.key != null && n.key.equals( key ) ) )\n+                {\n+                    Object returnVal = n.value;\n+                    n.value = value;\n+                    return returnVal;\n+                }\n+            }\n+\n+            // The key was not found in the current list of nodes, add it to the end\n+            //  in a new node.\n+            Node newNode = new Node();\n+            newNode.key = key;\n+            newNode.value = value;\n+            n.next = newNode;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Get an object from the Map by the key\n+     */\n+    public Object get( final Object key )\n+    {\n+        int hash = getHash( key );\n+\n+        synchronized( m_locks[ hash ] )\n+        {\n+            Node n = m_buckets[ hash ];\n+\n+            while( n != null )\n+            {\n+                if( n.key == key || ( n.key != null && n.key.equals( key ) ) )\n+                {\n+                    return n.value;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Checks to see if the provided key exists in the Map.\n+     */\n+    public boolean containsKey( final Object key )\n+    {\n+        int hash = getHash( key );\n+\n+        synchronized( m_locks[ hash ] )\n+        {\n+            Node n = m_buckets[ hash ];\n+\n+            while( n != null )\n+            {\n+                if( n.key == null || ( n.key != null && n.key.equals( key ) ) )\n+                {\n+                    return true;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Checks to see if a value exists.  This operation crosses bucket\n+     * boundaries, so it is less efficient, and greatly increases the chance\n+     * for thread contention.\n+     */\n+    public boolean containsValue( final Object value )\n+    {\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            synchronized( m_locks[ i ] )\n+            {\n+                Node n = m_buckets[ i ];\n+\n+                while( n != null )\n+                {\n+                    if( n.value == value || \n+                        (n.value != null && n.value.equals( value ) ) )\n+                    {\n+                        return true;\n+                    }\n+\n+                    n = n.next;\n+                }\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * Obtain a Set for the values.  This operation crosses bucket boundaries,\n+     * so it is less efficient, and greatly increases the chance for thread\n+     * contention.\n+     */\n+    public Collection values()\n+    {\n+        ArrayList values = new ArrayList();\n+\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            synchronized( m_locks[ i ] )\n+            {\n+                Node n = m_buckets[ i ];\n+\n+                while( n != null )\n+                {\n+                    values.add( n.value );\n+                    n = n.next;\n+                }\n+            }\n+        }\n+\n+        return values;\n+    }\n+\n+    /**\n+     * Obtain a Set for the entries.  This operation crosses bucket boundaries,\n+     * so it is less efficient, and greatly increases the chance for thread\n+     * contention.\n+     */\n+    public Set entrySet()\n+    {\n+        Set entrySet = new HashSet();\n+\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            synchronized( m_locks[ i ] )\n+            {\n+                Node n = m_buckets[ i ];\n+\n+                while( n != null )\n+                {\n+                    entrySet.add( n );\n+                    n = n.next;\n+                }\n+            }\n+        }\n+\n+        return entrySet;\n+    }\n+\n+    /**\n+     * Add all the contents of one Map into this one.\n+     */\n+    public void putAll( Map other )\n+    {\n+        Iterator i = other.keySet().iterator();\n+\n+        while( i.hasNext() )\n+        {\n+            Object key = i.next();\n+            put( key, other.get( key ) );\n+        }\n+    }\n+\n+    /**\n+     * Removes the object from the Map based on the key.\n+     */\n+    public Object remove( Object key )\n+    {\n+        int hash = getHash( key );\n+\n+        synchronized( m_locks[ hash ] )\n+        {\n+            Node n = m_buckets[ hash ];\n+            Node prev = null;\n+\n+            while( n != null )\n+            {\n+                if( n.key == null || ( n.key != null && n.key.equals( key ) ) )\n+                {\n+                    // Remove this node from the linked list of nodes.\n+                    if( null == prev )\n+                    {\n+                        // This node was the head, set the next node to be the new head.\n+                        m_buckets[ hash ] = n.next;\n+                    }\n+                    else\n+                    {\n+                        // Set the next node of the previous node to be the node after this one.\n+                        prev.next = n.next;\n+                    }\n+\n+                    return n.value;\n+                }\n+\n+                prev = n;\n+                n = n.next;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Tests if the Map is empty.\n+     */\n+    public final boolean isEmpty()\n+    {\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            if( m_buckets[ i ] != null )\n+            {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Removes all the entries from the Map.\n+     */\n+    public final void clear()\n+    {\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            m_buckets[ i ] = null;\n+        }\n+    }\n+\n+    public final boolean equals( Object obj )\n+    {\n+        if( obj == null ) return false;\n+        if( obj == this ) return true;\n+\n+        if( !( obj instanceof Map ) ) return false;\n+\n+        Map other = (Map)obj;\n+        \n+        return entrySet().equals(other.entrySet());\n+    }\n+\n+    public final int hashCode() \n+    {\n+        int hashCode = 0;\n+\n+        for( int i = 0; i < m_buckets.length; i++ )\n+        {\n+            synchronized( m_locks[ i ] )\n+            {\n+                Node n = m_buckets[ i ];\n+\n+                while( n != null )\n+                {\n+                    hashCode += n.hashCode();\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * The Map.Entry for the StaticBucketMap.\n+     */\n+    private final class Node implements Map.Entry\n+    {\n+        protected Object key;\n+        protected Object value;\n+        protected Node next;\n+\n+        public Object getKey()\n+        {\n+            return key;\n+        }\n+\n+        public Object getValue()\n+        {\n+            return value;\n+        }\n+\n+        public int hashCode()\n+        {\n+            return ( ( key == null ? 0 : key.hashCode() ) ^\n+                     ( value == null ? 0 : value.hashCode() ) ); \n+        }\n+\n+        public boolean equals(Object o) {\n+            if( o == null ) return false;\n+            if( o == this ) return true;        \n+            \n+            if ( ! (o instanceof Map.Entry ) )\n+                return false;\n+\n+            Map.Entry e2 = (Map.Entry)o;\n+\n+            return ((key == null ?\n+                     e2.getKey() == null : key.equals(e2.getKey())) &&\n+                    (value == null ?\n+                     e2.getValue() == null : value.equals(e2.getValue())));\n+        }\n+\n+        public Object setValue( Object val )\n+        {\n+            Object retVal = value;\n+            value = val;\n+            return retVal;\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/collections/TestAll.java\n+++ b/src/test/org/apache/commons/collections/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.27 2002/06/09 19:23:53 mas Exp $\n- * $Revision: 1.27 $\n- * $Date: 2002/06/09 19:23:53 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestAll.java,v 1.28 2002/06/21 06:17:45 mas Exp $\n+ * $Revision: 1.28 $\n+ * $Date: 2002/06/21 06:17:45 $\n  *\n  * ====================================================================\n  *\n /**\n  * Entry point for all Collections tests.\n  * @author Rodney Waldhoff\n- * @version $Id: TestAll.java,v 1.27 2002/06/09 19:23:53 mas Exp $\n+ * @version $Id: TestAll.java,v 1.28 2002/06/21 06:17:45 mas Exp $\n  */\n public class TestAll extends TestCase {\n     public TestAll(String testName) {\n \tsuite.addTest(TestNullComparator.suite());\n         suite.addTest(TestSequencedHashMap.suite());\n         suite.addTest(TestSingletonIterator.suite());\n+        suite.addTest(TestStaticBucketMap.suite());\n         suite.addTest(TestTreeBag.suite());\n         suite.addTest(TestUniqueFilterIterator.suite());\n         suite.addTest(org.apache.commons.collections.primitives.TestAll.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/TestStaticBucketMap.java\n+package org.apache.commons.collections;\n+\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution,\n+ *    if any, must include the following acknowledgment:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgment may appear in the software itself,\n+ *    if and wherever such third-party acknowledgments normally appear.\n+ *\n+ * 4. The names \"Apache\" and \"Apache Software Foundation\" and\n+ *    \"Apache Turbine\" must not be used to endorse or promote products\n+ *    derived from this software without prior written permission. For\n+ *    written permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\",\n+ *    \"Apache Turbine\", nor may \"Apache\" appear in their name, without\n+ *    prior written permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Unit tests \n+ * {@link org.apache.commons.collections.StaticBucketMap}.\n+ * \n+ * @author <a href=\"mailto:mas@apache.org\">Michael A. Smith</a>\n+ */\n+public class TestStaticBucketMap extends TestMap {\n+\n+    public TestStaticBucketMap(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TestStaticBucketMap.class);\n+    }\n+\n+    public static void main(String[] args[]) {\n+        String[] testCaseName = { TestStaticBucketMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new StaticBucketMap(30);\n+    }\n+   \n+    // The verification method must be overridden because the collection views\n+    // are not backed by the map.\n+        \n+    public void verifyEntrySet() {\n+        // update the entrySet view to the latest version, then proceed to\n+        // verify as usual.\n+        entrySet = map.entrySet();\n+        super.verifyEntrySet();\n+    }\n+    \n+    public void verifyKeySet() {\n+        // update the keySet view to the latest version, then proceed to verify\n+        // as usual.\n+        keySet = map.keySet();\n+        super.verifyKeySet();\n+    }\n+    \n+    public void verifyValues() {\n+        // update the values view to the latest version, then proceed to verify\n+        // as usual.  \n+        values = map.values();\n+        super.verifyValues();\n+    }\n+\n+}", "timestamp": 1024640265, "metainfo": ""}