{"sha": "80b08f8c3ad0c9386447ba54e277ef31041ebf86", "log": "Move cardinality method, rename frequency to countMatches.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/CollectionUtils.java\n      * @param coll the {@link Iterable} to search\n      * @param <O> the type of object that the {@link Iterable} may contain.\n      * @return the the number of occurrences of obj in coll\n-     */\n+     * @throws NullPointerException if coll is null\n+     * @deprecated since 4.1, use {@link IterableUtils#cardinality(Iterable, Object)} instead.\n+     *   Be aware that the order of parameters has changed.\n+     */\n+    @Deprecated\n     public static <O> int cardinality(final O obj, final Iterable<? super O> coll) {\n-        if (coll instanceof Set<?>) {\n-            return ((Set<? super O>) coll).contains(obj) ? 1 : 0;\n-        }\n-        if (coll instanceof Bag<?>) {\n-            return ((Bag<? super O>) coll).getCount(obj);\n-        }\n-        int count = 0;\n-        if (obj == null) {\n-            for (final Object element : coll) {\n-                if (element == null) {\n-                    count++;\n-                }\n-            }\n-        } else {\n-            for (final Object element : coll) {\n-                if (obj.equals(element)) {\n-                    count++;\n-                }\n-            }\n-        }\n-        return count;\n+        if (coll == null) {\n+            throw new NullPointerException(\"coll must not be null.\");\n+        }\n+        return IterableUtils.cardinality(coll, obj);\n     }\n \n     /**\n      * @param input  the {@link Iterable} to get the input from, may be null\n      * @param predicate  the predicate to use, may be null\n      * @return the number of matches for the predicate in the collection\n-     * @deprecated since 4.1, use {@link IterableUtils#frequency(Iterable, Predicate)} instead\n+     * @deprecated since 4.1, use {@link IterableUtils#countMatches(Iterable, Predicate)} instead\n      */\n     @Deprecated\n     public static <C> int countMatches(final Iterable<C> input, final Predicate<? super C> predicate) {\n-        return predicate == null ? 0 : (int) IterableUtils.frequency(input, predicate);\n+        return predicate == null ? 0 : (int) IterableUtils.countMatches(input, predicate);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/collections4/IterableUtils.java\n+++ b/src/main/java/org/apache/commons/collections4/IterableUtils.java\n import java.util.Comparator;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.commons.collections4.functors.EqualPredicate;\n import org.apache.commons.collections4.iterators.LazyIteratorChain;\n      *\n      * @param <E>  the element type\n      * @param iterable  the iterable to filter, may be null\n-     * @param predicate  the predicate used to filter elements, must not be null\n+     * @param predicate  the predicate used to filter elements, may not be null\n      * @return a filtered view on the specified iterable\n      * @throws NullPointerException if predicate is null\n      */\n     public static <E> Iterable<E> filteredIterable(final Iterable<E> iterable,\n                                                    final Predicate<? super E> predicate) {\n         if (predicate == null) {\n-            throw new NullPointerException(\"predicate must not be null.\");\n+            throw new NullPointerException(\"Predicate must not be null.\");\n         }\n \n         return new FluentIterable<E>() {\n      */\n     public static <E> Iterable<E> boundedIterable(final Iterable<E> iterable, final long maxSize) {\n         if (maxSize < 0) {\n-            throw new IllegalArgumentException(\"maxSize parameter must not be negative.\");\n+            throw new IllegalArgumentException(\"MaxSize parameter must not be negative.\");\n         }\n \n         return new FluentIterable<E>() {\n      */\n     public static <E> Iterable<E> skippingIterable(final Iterable<E> iterable, final long elementsToSkip) {\n         if (elementsToSkip < 0) {\n-            throw new IllegalArgumentException(\"elementsToSkip parameter must not be negative.\");\n+            throw new IllegalArgumentException(\"ElementsToSkip parameter must not be negative.\");\n         }\n \n         return new FluentIterable<E>() {\n     public static <I, O> Iterable<O> transformedIterable(final Iterable<I> iterable,\n                                                          final Transformer<? super I, ? extends O> transformer) {\n         if (transformer == null) {\n-            throw new NullPointerException(\"transformer must not be null.\");\n+            throw new NullPointerException(\"Transformer must not be null.\");\n         }\n \n         return new FluentIterable<O>() {\n \n     /**\n      * Returns an empty iterator if the argument is <code>null</code>,\n-     * or returns {@code iterable.iterator()} otherwise.\n+     * or {@code iterable.iterator()} otherwise.\n      *\n      * @param <E> the element type\n      * @param iterable  the iterable, possibly <code>null</code>\n-     * @return an empty collection if the argument is <code>null</code>\n-     */\n-    public static <E> Iterator<E> emptyIteratorIfNull(final Iterable<E> iterable) {\n+     * @return an empty iterator if the argument is <code>null</code>\n+     */\n+    private static <E> Iterator<E> emptyIteratorIfNull(final Iterable<E> iterable) {\n         return iterable != null ? iterable.iterator() : IteratorUtils.<E>emptyIterator();\n     }\n \n      * @return the number of matches for the predicate in the collection\n      * @throws NullPointerException if predicate is null\n      */\n-    public static <E> long frequency(final Iterable<E> input, final Predicate<? super E> predicate) {\n+    public static <E> long countMatches(final Iterable<E> input, final Predicate<? super E> predicate) {\n         if (predicate == null) {\n             throw new NullPointerException(\"Predicate must not be null.\");\n         }\n-        long count = 0;\n-        if (input != null) {\n-            for (final E o : input) {\n-                if (predicate.evaluate(o)) {\n-                    count++;\n-                }\n-            }\n-        }\n-        return count;\n+        return size(filteredIterable(input, predicate));\n     }\n \n     /**\n             throw new NullPointerException(\"Equator must not be null.\");\n         }\n         return matchesAny(iterable, EqualPredicate.equalPredicate(object, equator));\n+    }\n+\n+    /**\n+     * Returns the number of occurrences of the provided object in the iterable.\n+     *\n+     * @param <E>  the type of object that the {@link Iterable} may contain\n+     * @param iterable  the {@link Iterable} to search\n+     * @param obj  the object to find the cardinality of\n+     * @return the the number of occurrences of obj in iterable\n+     */\n+    public static <E, T extends E> int cardinality(final Iterable<E> iterable, final T obj) {\n+        if (iterable instanceof Set<?>) {\n+            return ((Set<E>) iterable).contains(obj) ? 1 : 0;\n+        }\n+        if (iterable instanceof Bag<?>) {\n+            return ((Bag<E>) iterable).getCount(obj);\n+        }\n+        return size(filteredIterable(iterable, EqualPredicate.<E>equalPredicate(obj)));\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/CollectionUtilsTest.java\n     }\n \n     @Test\n+    @Deprecated\n     public void cardinality() {\n         assertEquals(1, CollectionUtils.cardinality(1, iterableA));\n         assertEquals(2, CollectionUtils.cardinality(2, iterableA));\n     }\n \n     @Test\n+    @Deprecated\n     public void cardinalityOfNull() {\n         final List<String> list = new ArrayList<String>();\n         assertEquals(0, CollectionUtils.cardinality(null, list));\n     }\n \n     @Test\n+    @Deprecated\n     public void forAllButLastDoCollection() {\n         final Closure<List<? extends Number>> testClosure = ClosureUtils.invokerClosure(\"clear\");\n         final Collection<List<? extends Number>> col = new ArrayList<List<? extends Number>>();\n--- a/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n+++ b/src/test/java/org/apache/commons/collections4/IterableUtilsTest.java\n import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.HashSet;\n import java.util.LinkedList;\n import java.util.List;\n+import java.util.Set;\n \n import org.apache.commons.collections4.bag.HashBag;\n import org.junit.Assert;\n     }\n \n     @Test\n+    public void cardinality() {\n+        // null iterable test\n+        assertEquals(0, IterableUtils.cardinality(null, 1));\n+\n+        assertEquals(1, IterableUtils.cardinality(iterableA, 1));\n+        assertEquals(2, IterableUtils.cardinality(iterableA, 2));\n+        assertEquals(3, IterableUtils.cardinality(iterableA, 3));\n+        assertEquals(4, IterableUtils.cardinality(iterableA, 4));\n+        assertEquals(0, IterableUtils.cardinality(iterableA, 5));\n+\n+        assertEquals(0, IterableUtils.cardinality(iterableB, 1L));\n+        assertEquals(4, IterableUtils.cardinality(iterableB, 2L));\n+        assertEquals(3, IterableUtils.cardinality(iterableB, 3L));\n+        assertEquals(2, IterableUtils.cardinality(iterableB, 4L));\n+        assertEquals(1, IterableUtils.cardinality(iterableB, 5L));\n+\n+        // Ensure that generic bounds accept valid parameters, but return\n+        // expected results\n+        // e.g. no longs in the \"int\" Iterable<Number>, and vice versa.\n+        Iterable<Number> iterableIntAsNumber = Arrays.<Number>asList(1, 2, 3, 4, 5);\n+        Iterable<Number> iterableLongAsNumber = Arrays.<Number>asList(1L, 2L, 3L, 4L, 5L);\n+        assertEquals(0, IterableUtils.cardinality(iterableIntAsNumber, 2L));\n+        assertEquals(0, IterableUtils.cardinality(iterableLongAsNumber, 2));\n+\n+        final Set<String> set = new HashSet<String>();\n+        set.add(\"A\");\n+        set.add(\"C\");\n+        set.add(\"E\");\n+        set.add(\"E\");\n+        assertEquals(1, IterableUtils.cardinality(set, \"A\"));\n+        assertEquals(0, IterableUtils.cardinality(set, \"B\"));\n+        assertEquals(1, IterableUtils.cardinality(set, \"C\"));\n+        assertEquals(0, IterableUtils.cardinality(set, \"D\"));\n+        assertEquals(1, IterableUtils.cardinality(set, \"E\"));\n+\n+        final Bag<String> bag = new HashBag<String>();\n+        bag.add(\"A\", 3);\n+        bag.add(\"C\");\n+        bag.add(\"E\");\n+        bag.add(\"E\");\n+        assertEquals(3, IterableUtils.cardinality(bag, \"A\"));\n+        assertEquals(0, IterableUtils.cardinality(bag, \"B\"));\n+        assertEquals(1, IterableUtils.cardinality(bag, \"C\"));\n+        assertEquals(0, IterableUtils.cardinality(bag, \"D\"));\n+        assertEquals(2, IterableUtils.cardinality(bag, \"E\"));\n+    }\n+\n+    @Test\n+    public void cardinalityOfNull() {\n+        final List<String> list = new ArrayList<String>();\n+        assertEquals(0, IterableUtils.cardinality(list, null));\n+        list.add(\"A\");\n+        assertEquals(0, IterableUtils.cardinality(list, null));\n+        list.add(null);\n+        assertEquals(1, IterableUtils.cardinality(list, null));\n+        list.add(\"B\");\n+        assertEquals(1, IterableUtils.cardinality(list, null));\n+        list.add(null);\n+        assertEquals(2, IterableUtils.cardinality(list, null));\n+        list.add(\"B\");\n+        assertEquals(2, IterableUtils.cardinality(list, null));\n+        list.add(null);\n+        assertEquals(3, IterableUtils.cardinality(list, null));\n+    }\n+\n+    @Test\n     public void find() {\n         Predicate<Number> testPredicate = equalPredicate((Number) 4);\n         Integer test = IterableUtils.find(iterableA, testPredicate);\n     }\n \n     @Test\n-    public void frequency() {\n-        assertEquals(4, IterableUtils.frequency(iterableB, EQUALS_TWO));\n-        assertEquals(0, IterableUtils.frequency(null, EQUALS_TWO));\n-\n-        try {\n-            assertEquals(0, IterableUtils.frequency(iterableA, null));\n+    public void countMatches() {\n+        assertEquals(4, IterableUtils.countMatches(iterableB, EQUALS_TWO));\n+        assertEquals(0, IterableUtils.countMatches(null, EQUALS_TWO));\n+\n+        try {\n+            assertEquals(0, IterableUtils.countMatches(iterableA, null));\n             fail(\"predicate must not be null\");\n         } catch (NullPointerException ex) {\n             // expected\n         }\n \n         try {\n-            assertEquals(0, IterableUtils.frequency(null, null));\n+            assertEquals(0, IterableUtils.countMatches(null, null));\n             fail(\"predicate must not be null\");\n         } catch (NullPointerException ex) {\n             // expected", "timestamp": 1433600952, "metainfo": ""}