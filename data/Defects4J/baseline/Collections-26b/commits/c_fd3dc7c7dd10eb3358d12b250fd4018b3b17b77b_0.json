{"sha": "fd3dc7c7dd10eb3358d12b250fd4018b3b17b77b", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r471189 | scolebourne | 2006-11-04 05:57:57 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getMap(), getOrderedMap() and getSortedMap() - use decorated()     ------------------------------------------------------------------------     r468685 | scolebourne | 2006-10-28 05:30:27 -0700 (Sat, 28 Oct 2006) | 1 line          COLLECTIONS-228 - MultiValueMap put and putAll do not return the correct values     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/MultiValueMap.java\n+++ b/src/java/org/apache/commons/collections/map/MultiValueMap.java\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.collections.Factory;\n import org.apache.commons.collections.FunctorException;\n import org.apache.commons.collections.MultiMap;\n  * @version $Revision$ $Date$\n  * @since Commons Collections 3.2\n  */\n-public class MultiValueMap extends AbstractMapDecorator implements MultiMap, Serializable {\n+public class MultiValueMap<K, V> extends AbstractMapDecorator<K, Object> implements MultiMap<K, V>, Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = -2214159910087182007L;\n \n     /** The factory for creating value collections. */\n-    private final Factory collectionFactory;\n+    private final Factory<? extends Collection<V>> collectionFactory;\n     /** The cached values. */\n-    private transient Collection valuesView;\n+    private transient Collection<V> valuesView;\n \n     /**\n      * Creates a map which wraps the given map and\n      *\n      * @param map  the map to wrap\n      */\n-    public static MultiValueMap decorate(Map map) {\n-        return new MultiValueMap(map, new ReflectionFactory(ArrayList.class));\n+    @SuppressWarnings(\"unchecked\")\n+    public static <K, V> MultiValueMap<K, V> decorate(Map<K, ? super Collection<V>> map) {\n+        return MultiValueMap.<K, V, ArrayList>decorate((Map<K, ? super Collection>) map, ArrayList.class);\n     }\n \n     /**\n      * @param map  the map to wrap\n      * @param collectionClass  the type of the collection class\n      */\n-    public static MultiValueMap decorate(Map map, Class collectionClass) {\n-        return new MultiValueMap(map, new ReflectionFactory(collectionClass));\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> decorate(Map<K, ? super C> map, Class<C> collectionClass) {\n+        return new MultiValueMap<K, V>(map, new ReflectionFactory<C>(collectionClass));\n     }\n \n     /**\n      * @param map  the map to decorate\n      * @param collectionFactory  the collection factory (must return a Collection object).\n      */\n-    public static MultiValueMap decorate(Map map, Factory collectionFactory) {\n-        return new MultiValueMap(map, collectionFactory);\n+    public static <K, V, C extends Collection<V>> MultiValueMap<K, V> decorate(Map<K, ? super C> map, Factory<C> collectionFactory) {\n+        return new MultiValueMap<K, V>(map, collectionFactory);\n     }\n \n     //-----------------------------------------------------------------------\n      * Creates a MultiValueMap based on a <code>HashMap</code> and\n      * storing the multiple values in an <code>ArrayList</code>.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public MultiValueMap() {\n         this(new HashMap(), new ReflectionFactory(ArrayList.class));\n     }\n      * @param map  the map to decorate\n      * @param collectionFactory  the collection factory which must return a Collection instance\n      */\n-    protected MultiValueMap(Map map, Factory collectionFactory) {\n-        super(map);\n+    @SuppressWarnings(\"unchecked\")\n+    protected <C extends Collection<V>> MultiValueMap(Map<K, ? super C> map, Factory<C> collectionFactory) {\n+        super((Map<K, Object>) map);\n         if (collectionFactory == null) {\n             throw new IllegalArgumentException(\"The factory must not be null\");\n         }\n //            Collection coll = (Collection) keyValuePair.getValue();\n //            coll.clear();\n //        }\n-        getMap().clear();\n+        decorated().clear();\n     }\n \n     /**\n      * @param value the value to remove\n      * @return the value removed (which was passed in), null if nothing removed\n      */\n-    public Object remove(Object key, Object value) {\n-        Collection valuesForKey = getCollection(key);\n+    @SuppressWarnings(\"unchecked\")\n+    public V remove(Object key, Object value) {\n+        Collection<V> valuesForKey = getCollection(key);\n         if (valuesForKey == null) {\n             return null;\n         }\n         if (valuesForKey.isEmpty()) {\n             remove(key);\n         }\n-        return value;\n+        return (V) value;\n     }\n \n     /**\n      * @param value  the value to search for\n      * @return true if the map contains the value\n      */\n+    @SuppressWarnings(\"unchecked\")\n     public boolean containsValue(Object value) {\n-        Set pairs = getMap().entrySet();\n-        if (pairs == null) {\n-            return false;\n-        }\n-        Iterator pairsIterator = pairs.iterator();\n-        while (pairsIterator.hasNext()) {\n-            Map.Entry keyValuePair = (Map.Entry) pairsIterator.next();\n-            Collection coll = (Collection) keyValuePair.getValue();\n-            if (coll.contains(value)) {\n-                return true;\n+        Set<Map.Entry<K, Object>> pairs = decorated().entrySet();\n+        if (pairs != null) {\n+            for (Map.Entry<K, Object> entry : pairs) {\n+                if (((Collection<V>) entry.getValue()).contains(value)) {\n+                    return true;\n+                }\n             }\n         }\n         return false;\n      * @param value  the value to add to the collection at the key\n      * @return the value added if the map changed and null if the map did not change\n      */\n-    public Object put(Object key, Object value) {\n+    @SuppressWarnings(\"unchecked\")\n+    public Object put(K key, Object value) {\n         boolean result = false;\n-        Collection coll = getCollection(key);\n+        Collection<V> coll = getCollection(key);\n         if (coll == null) {\n             coll = createCollection(1);  // might produce a non-empty collection\n-            coll.add(value);\n+            coll.add((V) value);\n             if (coll.size() > 0) {\n                 // only add if non-zero size to maintain class state\n-                getMap().put(key, coll);\n+                decorated().put(key, coll);\n                 result = true;  // map definitely changed\n             }\n         } else {\n-            result = coll.add(value);\n+            result = coll.add((V) value);\n         }\n         return (result ? value : null);\n     }\n      *\n      * @param map  the map to copy (either a normal or multi map)\n      */\n-    public void putAll(Map map) {\n+    @SuppressWarnings(\"unchecked\")\n+    public void putAll(Map<? extends K, ?> map) {\n         if (map instanceof MultiMap) {\n-            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n-                Collection coll = (Collection) entry.getValue();\n-                putAll(entry.getKey(), coll);\n+            for (Map.Entry<? extends K, Object> entry : ((MultiMap<? extends K, V>) map).entrySet()) {\n+                putAll(entry.getKey(), (Collection<V>) entry.getValue());\n             }\n         } else {\n-            for (Iterator it = map.entrySet().iterator(); it.hasNext();) {\n-                Map.Entry entry = (Map.Entry) it.next();\n-                put(entry.getKey(), entry.getValue());\n+            for (Map.Entry<? extends K, ?> entry : map.entrySet()) {\n+                put(entry.getKey(), (V) entry.getValue());\n             }\n         }\n     }\n      *\n      * @return a collection view of the values contained in this map\n      */\n-    public Collection values() {\n-        if (valuesView == null) {\n-            valuesView = new Values();\n-        }\n-        return valuesView;\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<Object> values() {\n+        Collection<V> vs = valuesView;\n+        return (Collection<Object>) (vs != null ? vs : (valuesView = new Values()));\n     }\n \n     /**\n      * @return true if the map contains the value\n      */\n     public boolean containsValue(Object key, Object value) {\n-        Collection coll = getCollection(key);\n+        Collection<V> coll = getCollection(key);\n         if (coll == null) {\n             return false;\n         }\n      * @param key  the key to retrieve\n      * @return the collection mapped to the key, null if no mapping\n      */\n-    public Collection getCollection(Object key) {\n-        return (Collection) getMap().get(key);\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<V> getCollection(Object key) {\n+        return (Collection<V>) decorated().get(key);\n     }\n \n     /**\n      * @return the size of the collection at the key, zero if key not in map\n      */\n     public int size(Object key) {\n-        Collection coll = getCollection(key);\n+        Collection<V> coll = getCollection(key);\n         if (coll == null) {\n             return 0;\n         }\n      * @param values  the values to add to the collection at the key, null ignored\n      * @return true if this map changed\n      */\n-    public boolean putAll(Object key, Collection values) {\n+    public boolean putAll(K key, Collection<V> values) {\n         if (values == null || values.size() == 0) {\n             return false;\n         }\n         boolean result = false;\n-        Collection coll = getCollection(key);\n+        Collection<V> coll = getCollection(key);\n         if (coll == null) {\n             coll = createCollection(values.size());  // might produce a non-empty collection\n             coll.addAll(values);\n             if (coll.size() > 0) {\n                 // only add if non-zero size to maintain class state\n-                getMap().put(key, coll);\n+                decorated().put(key, coll);\n                 result = true;  // map definitely changed\n             }\n         } else {\n      * @param key  the key to get an iterator for\n      * @return the iterator of the collection at the key, empty iterator if key not in map\n      */\n-    public Iterator iterator(Object key) {\n+    public Iterator<V> iterator(Object key) {\n         if (!containsKey(key)) {\n-            return EmptyIterator.INSTANCE;\n-        } else {\n-            return new ValuesIterator(key);\n-        }\n+            return EmptyIterator.<V>getInstance();\n+        }\n+        return new ValuesIterator(key);\n     }\n \n     /**\n      */\n     public int totalSize() {\n         int total = 0;\n-        Collection values = getMap().values();\n-        for (Iterator it = values.iterator(); it.hasNext();) {\n-            Collection coll = (Collection) it.next();\n-            total += coll.size();\n+        for (Object v : decorated().values()) {\n+            total += CollectionUtils.size(v);\n         }\n         return total;\n     }\n      * @param size  the collection size that is about to be added\n      * @return the new collection\n      */\n-    protected Collection createCollection(int size) {\n-        return (Collection) collectionFactory.create();\n+    protected Collection<V> createCollection(int size) {\n+        return collectionFactory.create();\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * Inner class that provides the values view.\n      */\n-    private class Values extends AbstractCollection {\n-        public Iterator iterator() {\n-            final IteratorChain chain = new IteratorChain();\n-            for (Iterator it = keySet().iterator(); it.hasNext();) {\n+    private class Values extends AbstractCollection<V> {\n+        public Iterator<V> iterator() {\n+            final IteratorChain<V> chain = new IteratorChain<V>();\n+            for (Iterator<K> it = keySet().iterator(); it.hasNext();) {\n                 chain.addIterator(new ValuesIterator(it.next()));\n             }\n             return chain;\n     /**\n      * Inner class that provides the values iterator.\n      */\n-    private class ValuesIterator implements Iterator {\n+    private class ValuesIterator implements Iterator<V> {\n         private final Object key;\n-        private final Collection values;\n-        private final Iterator iterator;\n+        private final Collection<V> values;\n+        private final Iterator<V> iterator;\n \n         public ValuesIterator(Object key) {\n             this.key = key;\n             return iterator.hasNext();\n         }\n \n-        public Object next() {\n+        public V next() {\n             return iterator.next();\n         }\n     }\n     /**\n      * Inner class that provides a simple reflection factory.\n      */\n-    private static class ReflectionFactory implements Factory, Serializable {\n-        private final Class clazz;\n-\n-        public ReflectionFactory(Class clazz) {\n+    private static class ReflectionFactory<T extends Collection<?>> implements Factory<T>, Serializable {\n+\n+        /** Serialization version */\n+        private static final long serialVersionUID = 2986114157496788874L;\n+\n+        private final Class<T> clazz;\n+\n+        public ReflectionFactory(Class<T> clazz) {\n             this.clazz = clazz;\n         }\n \n-        public Object create() {\n+        public T create() {\n             try {\n                 return clazz.newInstance();\n             } catch (Exception ex) {", "timestamp": 1252994172, "metainfo": ""}