{"sha": "399fad2001612b85587dcd2e5639e4b299ff9acf", "log": "Refactor StaticBucketMap to map subpackage   ", "commit": "\n--- a/src/java/org/apache/commons/collections/StaticBucketMap.java\n+++ b/src/java/org/apache/commons/collections/StaticBucketMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/StaticBucketMap.java,v 1.12 2003/08/31 17:26:44 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/StaticBucketMap.java,v 1.13 2003/12/03 15:16:49 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * iterations, or if you can make your own guarantees about how bulk \n  * operations will affect the map.<p>\n  *\n+ * @deprecated Moved to map subpackage. Due to be removed in v4.0.\n  * @since Commons Collections 2.1\n- * @version $Revision: 1.12 $ $Date: 2003/08/31 17:26:44 $\n+ * @version $Revision: 1.13 $ $Date: 2003/12/03 15:16:49 $\n  * \n  * @author <a href=\"mailto:bloritsch@apache.org\">Berin Loritsch</a>\n  * @author <a href=\"mailto:g-froehlich@gmx.de\">Gerhard Froehlich</a>\n--- /dev/null\n+++ b/src/java/org/apache/commons/collections/map/StaticBucketMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/map/StaticBucketMap.java,v 1.1 2003/12/03 15:16:49 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2002-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.AbstractCollection;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * A StaticBucketMap is an efficient, thread-safe implementation of\n+ * <code>java.util.Map</code> that performs well in in a highly\n+ * thread-contentious environment.  The map supports very efficient\n+ * {@link #get(Object) get}, {@link #put(Object,Object) put}, \n+ * {@link #remove(Object) remove} and {@link #containsKey(Object) containsKey}\n+ * operations, assuming (approximate) uniform hashing and\n+ * that the number of entries does not exceed the number of buckets.  If the\n+ * number of entries exceeds the number of buckets or if the hashcodes of the\n+ * objects are not uniformly distributed, these operations have a worst case\n+ * scenario that is proportional to the number of elements in the map\n+ * (<i>O(n)</i>).<p>\n+ *\n+ * Each bucket in the hash table has its own monitor, so two threads can \n+ * safely operate on the map at the same time, often without incurring any \n+ * monitor contention.  This means that you don't have to wrap instances\n+ * of this class with {@link java.util.Collections#synchronizedMap(Map)};\n+ * instances are already thread-safe.  Unfortunately, however, this means \n+ * that this map implementation behaves in ways you may find disconcerting.  \n+ * Bulk operations, such as {@link #putAll(Map) putAll} or the\n+ * {@link Collection#retainAll(Collection) retainAll} operation in collection \n+ * views, are <i>not</i> atomic.  If two threads are simultaneously \n+ * executing \n+ *\n+ * <pre>\n+ *   staticBucketMapInstance.putAll(map);\n+ * </pre>\n+ *\n+ * and\n+ *\n+ * <pre>\n+ *   staticBucketMapInstance.entrySet().removeAll(map.entrySet());\n+ * </pre>\n+ *\n+ * then the results are generally random.  Those two statement could cancel\n+ * each other out, leaving <code>staticBucketMapInstance</code> essentially \n+ * unchanged, or they could leave some random subset of <code>map</code> in \n+ * <code>staticBucketMapInstance</code>.<p>\n+ *\n+ * Also, much like an encyclopedia, the results of {@link #size()} and \n+ * {@link #isEmpty()} are out-of-date as soon as they are produced.<p>\n+ *\n+ * The iterators returned by the collection views of this class are <i>not</i>\n+ * fail-fast.  They will <i>never</i> raise a \n+ * {@link java.util.ConcurrentModificationException}.  Keys and values \n+ * added to the map after the iterator is created do not necessarily appear\n+ * during iteration.  Similarly, the iterator does not necessarily fail to \n+ * return keys and values that were removed after the iterator was created.<p>\n+ *\n+ * Finally, unlike {@link java.util.HashMap}-style implementations, this\n+ * class <i>never</i> rehashes the map.  The number of buckets is fixed \n+ * at construction time and never altered.  Performance may degrade if \n+ * you do not allocate enough buckets upfront.<p>\n+ *\n+ * The {@link #atomic(Runnable)} method is provided to allow atomic iterations\n+ * and bulk operations; however, overuse of {@link #atomic(Runnable) atomic}\n+ * will basically result in a map that's slower than an ordinary synchronized\n+ * {@link java.util.HashMap}.\n+ *\n+ * Use this class if you do not require reliable bulk operations and \n+ * iterations, or if you can make your own guarantees about how bulk \n+ * operations will affect the map.<p>\n+ *\n+ * @since Commons Collections 3.0\n+ * @version $Revision: 1.1 $ $Date: 2003/12/03 15:16:49 $\n+ * \n+ * @author Berin Loritsch\n+ * @author Gerhard Froehlich\n+ * @author Michael A. Smith\n+ * @author Paul Jack\n+ * @author Leo Sutic\n+ * @author Janek Bogucki\n+ */\n+public final class StaticBucketMap implements Map {\n+\n+    private static final int DEFAULT_BUCKETS = 255;\n+    private Node[] m_buckets;\n+    private Lock[] m_locks;\n+\n+    /**\n+     * Initializes the map with the default number of buckets (255).\n+     */\n+    public StaticBucketMap() {\n+        this(DEFAULT_BUCKETS);\n+    }\n+\n+    /**\n+     * Initializes the map with a specified number of buckets.  The number\n+     * of buckets is never below 17, and is always an odd number (StaticBucketMap\n+     * ensures this). The number of buckets is inversely proportional to the\n+     * chances for thread contention.  The fewer buckets, the more chances for\n+     * thread contention.  The more buckets the fewer chances for thread\n+     * contention.\n+     *\n+     * @param numBuckets  the number of buckets for this map\n+     */\n+    public StaticBucketMap(int numBuckets) {\n+        int size = Math.max(17, numBuckets);\n+\n+        // Ensure that bucketSize is never a power of 2 (to ensure maximal distribution)\n+        if (size % 2 == 0) {\n+            size--;\n+        }\n+\n+        m_buckets = new Node[size];\n+        m_locks = new Lock[size];\n+\n+        for (int i = 0; i < size; i++) {\n+            m_locks[i] = new Lock();\n+        }\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Determine the exact hash entry for the key.  The hash algorithm\n+     * is rather simplistic, but it does the job:\n+     *\n+     * <pre>\n+     *   He = |Hk mod n|\n+     * </pre>\n+     *\n+     * <p>\n+     *   He is the entry's hashCode, Hk is the key's hashCode, and n is\n+     *   the number of buckets.\n+     * </p>\n+     */\n+    private final int getHash(Object key) {\n+        if (key == null) {\n+            return 0;\n+        }\n+        int hash = key.hashCode();\n+        hash += ~(hash << 15);\n+        hash ^= (hash >>> 10);\n+        hash += (hash << 3);\n+        hash ^= (hash >>> 6);\n+        hash += ~(hash << 11);\n+        hash ^= (hash >>> 16);\n+        hash %= m_buckets.length;\n+        return (hash < 0) ? hash * -1 : hash;\n+    }\n+\n+    /**\n+     * Gets the current size of the map.\n+     * The value is computed fresh each time the method is called.\n+     * \n+     * @return the current size\n+     */\n+    public int size() {\n+        int cnt = 0;\n+\n+        for (int i = 0; i < m_buckets.length; i++) {\n+            cnt += m_locks[i].size;\n+        }\n+        return cnt;\n+    }\n+\n+    /**\n+     * Checks if the size is currently zero.\n+     * \n+     * @return true if empty\n+     */\n+    public boolean isEmpty() {\n+        return (size() == 0);\n+    }\n+\n+    /**\n+     * Gets the value associated with the key.\n+     * \n+     * @param key  the key to retrieve\n+     * @return the associated value\n+     */\n+    public Object get(final Object key) {\n+        int hash = getHash(key);\n+\n+        synchronized (m_locks[hash]) {\n+            Node n = m_buckets[hash];\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    return n.value;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Checks if the map contains the specified key.\n+     * \n+     * @param key  the key to check\n+     * @return true if found\n+     */\n+    public boolean containsKey(final Object key) {\n+        int hash = getHash(key);\n+\n+        synchronized (m_locks[hash]) {\n+            Node n = m_buckets[hash];\n+\n+            while (n != null) {\n+                if (n.key == null || (n.key != null && n.key.equals(key))) {\n+                    return true;\n+                }\n+\n+                n = n.next;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks if the map contains the specified value.\n+     * \n+     * @param value  the value to check\n+     * @return true if found\n+     */\n+    public boolean containsValue(final Object value) {\n+        for (int i = 0; i < m_buckets.length; i++) {\n+            synchronized (m_locks[i]) {\n+                Node n = m_buckets[i];\n+\n+                while (n != null) {\n+                    if (n.value == value || (n.value != null && n.value.equals(value))) {\n+                        return true;\n+                    }\n+\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts a new key value mapping into the map.\n+     * \n+     * @param key  the key to use\n+     * @param value  the value to use\n+     * @return the previous mapping for the key\n+     */\n+    public Object put(final Object key, final Object value) {\n+        int hash = getHash(key);\n+\n+        synchronized (m_locks[hash]) {\n+            Node n = m_buckets[hash];\n+\n+            if (n == null) {\n+                n = new Node();\n+                n.key = key;\n+                n.value = value;\n+                m_buckets[hash] = n;\n+                m_locks[hash].size++;\n+                return null;\n+            }\n+\n+            // Set n to the last node in the linked list.  Check each key along the way\n+            //  If the key is found, then change the value of that node and return\n+            //  the old value.\n+            for (Node next = n; next != null; next = next.next) {\n+                n = next;\n+\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    Object returnVal = n.value;\n+                    n.value = value;\n+                    return returnVal;\n+                }\n+            }\n+\n+            // The key was not found in the current list of nodes, add it to the end\n+            //  in a new node.\n+            Node newNode = new Node();\n+            newNode.key = key;\n+            newNode.value = value;\n+            n.next = newNode;\n+            m_locks[hash].size++;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Removes the specified key from the map.\n+     * \n+     * @param key  the key to remove\n+     * @return the previous value at this key\n+     */\n+    public Object remove(Object key) {\n+        int hash = getHash(key);\n+\n+        synchronized (m_locks[hash]) {\n+            Node n = m_buckets[hash];\n+            Node prev = null;\n+\n+            while (n != null) {\n+                if (n.key == key || (n.key != null && n.key.equals(key))) {\n+                    // Remove this node from the linked list of nodes.\n+                    if (null == prev) {\n+                        // This node was the head, set the next node to be the new head.\n+                        m_buckets[hash] = n.next;\n+                    } else {\n+                        // Set the next node of the previous node to be the node after this one.\n+                        prev.next = n.next;\n+                    }\n+                    m_locks[hash].size--;\n+                    return n.value;\n+                }\n+\n+                prev = n;\n+                n = n.next;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the key set.\n+     * \n+     * @return the key set\n+     */\n+    public Set keySet() {\n+        return new KeySet();\n+    }\n+\n+    /**\n+     * Gets the values.\n+     * \n+     * @return the values\n+     */\n+    public Collection values() {\n+        return new Values();\n+    }\n+\n+    /**\n+     * Gets the entry set.\n+     * \n+     * @return the entry set\n+     */\n+    public Set entrySet() {\n+        return new EntrySet();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Puts all the entries from the specified map into this map.\n+     * This operation is <b>not atomic</b> and may have undesired effects.\n+     */\n+    public void putAll(Map other) {\n+        Iterator i = other.keySet().iterator();\n+\n+        while (i.hasNext()) {\n+            Object key = i.next();\n+            put(key, other.get(key));\n+        }\n+    }\n+\n+    /**\n+     * Clears the map of all entries.\n+     */\n+    public void clear() {\n+        for (int i = 0; i < m_buckets.length; i++) {\n+            Lock lock = m_locks[i];\n+            synchronized (lock) {\n+                m_buckets[i] = null;\n+                lock.size = 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compares this map to another, as per the Map specification.\n+     * \n+     * @param obj  the object to compare to\n+     * @return true if equal\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == this) {\n+            return true;\n+        }\n+        if (obj instanceof Map == false) {\n+            return false;\n+        }\n+        Map other = (Map) obj;\n+        return entrySet().equals(other.entrySet());\n+    }\n+\n+    /**\n+     * Gets the hashcode, as per the Map specification.\n+     * \n+     * @return the hashcode\n+     */\n+    public int hashCode() {\n+        int hashCode = 0;\n+\n+        for (int i = 0; i < m_buckets.length; i++) {\n+            synchronized (m_locks[i]) {\n+                Node n = m_buckets[i];\n+\n+                while (n != null) {\n+                    hashCode += n.hashCode();\n+                    n = n.next;\n+                }\n+            }\n+        }\n+        return hashCode;\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * The Map.Entry for the StaticBucketMap.\n+     */\n+    private static final class Node implements Map.Entry {\n+        protected Object key;\n+        protected Object value;\n+        protected Node next;\n+\n+        public Object getKey() {\n+            return key;\n+        }\n+\n+        public Object getValue() {\n+            return value;\n+        }\n+\n+        public int hashCode() {\n+            return ((key == null ? 0 : key.hashCode()) ^\n+                    (value == null ? 0 : value.hashCode()));\n+        }\n+\n+        public boolean equals(Object o) {\n+            if (o == this) {\n+                return true;\n+            }\n+            if (o instanceof Map.Entry == false) {\n+                return false;\n+            }\n+\n+            Map.Entry e2 = (Map.Entry) o;\n+            return (\n+                (key == null ? e2.getKey() == null : key.equals(e2.getKey())) &&\n+                (value == null ? e2.getValue() == null : value.equals(e2.getValue())));\n+        }\n+\n+        public Object setValue(Object val) {\n+            Object retVal = value;\n+            value = val;\n+            return retVal;\n+        }\n+    }\n+\n+\n+    /**\n+     * The lock object, which also includes a count of the nodes in this lock.\n+     */\n+    private final static class Lock {\n+        public int size;\n+    }\n+\n+\n+    //-----------------------------------------------------------------------\n+    private class EntryIterator implements Iterator {\n+\n+        private ArrayList current = new ArrayList();\n+        private int bucket;\n+        private Map.Entry last;\n+\n+\n+        public boolean hasNext() {\n+            if (current.size() > 0) return true;\n+            while (bucket < m_buckets.length) {\n+                synchronized (m_locks[bucket]) {\n+                    Node n = m_buckets[bucket];\n+                    while (n != null) {\n+                        current.add(n);\n+                        n = n.next;\n+                    }\n+                    bucket++;\n+                    if (current.size() > 0) return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        protected Map.Entry nextEntry() {\n+            if (!hasNext()) throw new NoSuchElementException();\n+            last = (Map.Entry)current.remove(current.size() - 1);\n+            return last;\n+        }\n+\n+        public Object next() {\n+            return nextEntry();\n+        }\n+\n+        public void remove() {\n+            if (last == null) throw new IllegalStateException();\n+            StaticBucketMap.this.remove(last.getKey());\n+            last = null;\n+        }\n+\n+    }\n+\n+    private class ValueIterator extends EntryIterator {\n+\n+        public Object next() {\n+            return nextEntry().getValue();\n+        }\n+\n+    }\n+\n+    private class KeyIterator extends EntryIterator {\n+\n+        public Object next() {\n+            return nextEntry().getKey();\n+        }\n+\n+    }\n+\n+    private class EntrySet extends AbstractSet {\n+\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new EntryIterator();\n+        }\n+\n+        public boolean contains(Object o) {\n+            Map.Entry entry = (Map.Entry)o;\n+            int hash = getHash(entry.getKey());\n+            synchronized (m_locks[hash]) {\n+                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public boolean remove(Object o) {\n+            Map.Entry entry = (Map.Entry)o;\n+            int hash = getHash(entry.getKey());\n+            synchronized (m_locks[hash]) {\n+                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+                    if (n.equals(entry)) {\n+                        StaticBucketMap.this.remove(n.getKey());\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    }\n+\n+\n+    private class KeySet extends AbstractSet {\n+\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new KeyIterator();\n+        }\n+\n+        public boolean contains(Object o) {\n+            return StaticBucketMap.this.containsKey(o);\n+        }\n+\n+        public boolean remove(Object o) {\n+            int hash = getHash(o);\n+            synchronized (m_locks[hash]) {\n+                for (Node n = m_buckets[hash]; n != null; n = n.next) {\n+                    Object k = n.getKey();\n+                    if ((k == o) || ((k != null) && k.equals(o))) {\n+                        StaticBucketMap.this.remove(k);\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+\n+        }\n+\n+    }\n+\n+\n+    private class Values extends AbstractCollection {\n+\n+        public int size() {\n+            return StaticBucketMap.this.size();\n+        }\n+\n+        public void clear() {\n+            StaticBucketMap.this.clear();\n+        }\n+\n+        public Iterator iterator() {\n+            return new ValueIterator();\n+        }\n+\n+    }\n+\n+\n+    /**\n+     *  Prevents any operations from occurring on this map while the\n+     *  given {@link Runnable} executes.  This method can be used, for\n+     *  instance, to execute a bulk operation atomically: \n+     *\n+     *  <pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            staticBucketMapInstance.putAll(map);\n+     *        }\n+     *    });\n+     *  </pre>\n+     *\n+     *  It can also be used if you need a reliable iterator:\n+     *\n+     *  <pre>\n+     *    staticBucketMapInstance.atomic(new Runnable() {\n+     *        public void run() {\n+     *            Iterator iterator = staticBucketMapInstance.iterator();\n+     *            while (iterator.hasNext()) {\n+     *                foo(iterator.next();\n+     *            }\n+     *        }\n+     *    });\n+     *  </pre>\n+     *\n+     *  <b>Implementation note:</b> This method requires a lot of time\n+     *  and a ton of stack space.  Essentially a recursive algorithm is used\n+     *  to enter each bucket's monitor.  If you have twenty thousand buckets\n+     *  in your map, then the recursive method will be invoked twenty thousand\n+     *  times.  You have been warned.\n+     *\n+     *  @param r  the code to execute atomically\n+     */\n+    public void atomic(Runnable r) {\n+        if (r == null) throw new NullPointerException();\n+        atomic(r, 0);\n+    }\n+\n+    private void atomic(Runnable r, int bucket) {\n+        if (bucket >= m_buckets.length) {\n+            r.run();\n+            return;\n+        }\n+        synchronized (m_locks[bucket]) {\n+            atomic(r, bucket + 1);\n+        }\n+    }\n+\n+\n+}\n--- a/src/test/org/apache/commons/collections/map/TestAll.java\n+++ b/src/test/org/apache/commons/collections/map/TestAll.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.6 2003/12/02 21:57:08 scolebourne Exp $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestAll.java,v 1.7 2003/12/03 15:16:49 scolebourne Exp $\n  * ====================================================================\n  *\n  * The Apache Software License, Version 1.1\n  * Entry point for tests.\n  * \n  * @since Commons Collections 3.0\n- * @version $Revision: 1.6 $ $Date: 2003/12/02 21:57:08 $\n+ * @version $Revision: 1.7 $ $Date: 2003/12/03 15:16:49 $\n  * \n  * @author Stephen Colebourne\n  */\n     public static Test suite() {\n         TestSuite suite = new TestSuite();\n         \n-        suite.addTest(TestFixedSizeMap.suite());\n-        suite.addTest(TestFixedSizeSortedMap.suite());\n         suite.addTest(TestFlat3Map.suite());\n         suite.addTest(TestHashedMap.suite());\n         suite.addTest(TestIdentityMap.suite());\n+        suite.addTest(TestStaticBucketMap.suite());\n+        \n+        suite.addTest(TestFixedSizeMap.suite());\n+        suite.addTest(TestFixedSizeSortedMap.suite());\n         suite.addTest(TestLazyMap.suite());\n         suite.addTest(TestLazySortedMap.suite());\n         suite.addTest(TestListOrderedMap.suite());\n--- /dev/null\n+++ b/src/test/org/apache/commons/collections/map/TestStaticBucketMap.java\n+/*\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/map/TestStaticBucketMap.java,v 1.1 2003/12/03 15:16:49 scolebourne Exp $\n+ * ====================================================================\n+ *\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2001-2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowledgement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowledgement may appear in the software itself,\n+ *    if and wherever such third-party acknowledgements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ *\n+ */\n+package org.apache.commons.collections.map;\n+\n+import java.util.Map;\n+\n+import junit.framework.Test;\n+\n+import org.apache.commons.collections.BulkTest;\n+\n+/**\n+ * Unit tests \n+ * {@link org.apache.commons.collections.StaticBucketMap}.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2003/12/03 15:16:49 $\n+ * \n+ * @author Michael A. Smith\n+ */\n+public class TestStaticBucketMap extends AbstractTestMap {\n+\n+    public TestStaticBucketMap(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        return BulkTest.makeSuite(TestStaticBucketMap.class);\n+    }\n+\n+    public static void main(String[] args[]) {\n+        String[] testCaseName = { TestStaticBucketMap.class.getName() };\n+        junit.textui.TestRunner.main(testCaseName);\n+    }\n+\n+    public Map makeEmptyMap() {\n+        return new StaticBucketMap(30);\n+    }\n+\n+    public String[] ignoredTests() {\n+        String pre = \"TestStaticBucketMap.bulkTestMap\";\n+        String post = \".testCollectionIteratorFailFast\";\n+        return new String[] {\n+            pre + \"EntrySet\" + post,\n+            pre + \"KeySet\" + post,\n+            pre + \"Values\" + post\n+        };\n+    }   \n+}", "timestamp": 1070464609, "metainfo": ""}