{"sha": "642cb02b2587fbbc25097d2114d7b9b93f421367", "log": "The collection views of FastArrayList, FastTreeMap and FastHashMap are now backed by the parent collection, even in fast mode, and those classes now pass all unit tests in fast mode.  The unit tests were altered so that they actually test the classes with setFast(true). PR:7924 Obtained from: Submitted by: Reviewed by:   ", "commit": "\n--- a/src/java/org/apache/commons/collections/FastArrayList.java\n+++ b/src/java/org/apache/commons/collections/FastArrayList.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastArrayList.java,v 1.6 2002/08/10 00:49:45 pjack Exp $\n- * $Revision: 1.6 $\n- * $Date: 2002/08/10 00:49:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastArrayList.java,v 1.7 2002/08/13 04:34:08 pjack Exp $\n+ * $Revision: 1.7 $\n+ * $Date: 2002/08/13 04:34:08 $\n  *\n  * ====================================================================\n  *\n import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n import java.util.List;\n import java.util.ListIterator;\n  *\n  * @since 1.0\n  * @author Craig R. McClanahan\n- * @version $Revision: 1.6 $ $Date: 2002/08/10 00:49:45 $\n+ * @version $Revision: 1.7 $ $Date: 2002/08/13 04:34:08 $\n  */\n \n public class FastArrayList extends ArrayList {\n      * failing due to concurrent modifications.\n      */\n     public Iterator iterator() {\n-\n-        if (fast) {\n-            return (list.iterator());\n-        } else {\n-            synchronized (list) {\n-                return (list.iterator());\n-            }\n-        }\n-\n+        if (fast) {\n+            return new ListIter(0);\n+        } else {\n+            return list.iterator();\n+        }\n     }\n \n \n      * See the implementation note on <code>iterator()</code>.\n      */\n     public ListIterator listIterator() {\n-\n-        if (fast) {\n-            return (list.listIterator());\n-        } else {\n-            synchronized (list) {\n-                return (list.listIterator());\n-            }\n-        }\n-\n+        if (fast) {\n+            return new ListIter(0);\n+        } else {\n+            return list.listIterator();\n+        }\n     }\n \n \n      * @exception IndexOutOfBoundsException if the index is out of range\n      */\n     public ListIterator listIterator(int index) {\n-\n-        if (fast) {\n-            return (list.listIterator(index));\n-        } else {\n-            synchronized (list) {\n-                return (list.listIterator(index));\n-            }\n-        }\n-\n+        if (fast) {\n+            return new ListIter(index);\n+        } else {\n+            return list.listIterator(index);\n+        }\n     }\n \n \n      * @exception IndexOutOfBoundsException if an index is out of range\n      */\n     public List subList(int fromIndex, int toIndex) {\n-\n-        if (fast) {\n-            return (list.subList(fromIndex, toIndex));\n-        } else {\n-            synchronized (list) {\n-                return (list.subList(fromIndex, toIndex));\n-            }\n-        }\n-\n+        if (fast) {\n+            return new SubList(fromIndex, toIndex);\n+        } else {\n+            return list.subList(fromIndex, toIndex);\n+        }\n     }\n \n \n     }\n \n \n+\n+    private class SubList implements List {\n+\n+        private int first;\n+        private int last;\n+        private List expected;\n+\n+\n+        public SubList(int first, int last) {\n+            this.first = first;\n+            this.last = last;\n+            this.expected = list;\n+        }\n+\n+        private List get(List l) {\n+            if (list != expected) {\n+                throw new ConcurrentModificationException();\n+            }\n+            return l.subList(first, last);\n+        }\n+\n+        public void clear() {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    get(temp).clear();\n+                    last = first;\n+                    list = temp;\n+                    expected = temp;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    get(expected).clear();\n+                }\n+            }\n+        }\n+\n+        public boolean remove(Object o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    boolean r = get(temp).remove(o);\n+                    if (r) last--;\n+                    list = temp;\n+                    expected = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).remove(o);\n+                }\n+            }\n+        }\n+\n+        public boolean removeAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    List sub = get(temp);\n+                    boolean r = sub.removeAll(o);\n+                    if (r) last = first + sub.size();\n+                    list = temp;\n+                    expected = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).removeAll(o);\n+                }\n+            }\n+        }\n+\n+        public boolean retainAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    List sub = get(temp);\n+                    boolean r = sub.retainAll(o);\n+                    if (r) last = first + sub.size();\n+                    list = temp;\n+                    expected = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).retainAll(o);\n+                }\n+            }\n+        }\n+\n+        public int size() {\n+            if (fast) {\n+                return get(expected).size();\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).size();\n+                }\n+            }\n+        }\n+\n+\n+        public boolean isEmpty() {\n+            if (fast) {\n+                return get(expected).isEmpty();\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).isEmpty();\n+                }\n+            }\n+        }\n+\n+        public boolean contains(Object o) {\n+            if (fast) {\n+                return get(expected).contains(o);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).contains(o);\n+                }\n+            }\n+        }\n+\n+        public boolean containsAll(Collection o) {\n+            if (fast) {\n+                return get(expected).containsAll(o);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).containsAll(o);\n+                }\n+            }\n+        }\n+\n+        public Object[] toArray(Object[] o) {\n+            if (fast) {\n+                return get(expected).toArray(o);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).toArray(o);\n+                }\n+            }\n+        }\n+\n+        public Object[] toArray() {\n+            if (fast) {\n+                return get(expected).toArray();\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).toArray();\n+                }\n+            }\n+        }\n+\n+\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (fast) {\n+                return get(expected).equals(o);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).equals(o);\n+                }\n+            }\n+        }\n+\n+        public int hashCode() {\n+            if (fast) {\n+                return get(expected).hashCode();\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).hashCode();\n+                }\n+            }\n+        }\n+\n+        public boolean add(Object o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    boolean r = get(temp).add(o);\n+                    if (r) last++;\n+                    list = temp;\n+                    expected = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).add(o);\n+                }\n+            }\n+        }\n+\n+        public boolean addAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    boolean r = get(temp).addAll(o);\n+                    if (r) last += o.size();\n+                    list = temp;\n+                    expected = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).addAll(o);\n+                }\n+            }\n+        }\n+\n+        public void add(int i, Object o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    get(temp).add(i, o);\n+                    last++;\n+                    list = temp;\n+                    expected = temp;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    get(expected).add(i, o);\n+                }\n+            }\n+        }\n+\n+        public boolean addAll(int i, Collection o) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    boolean r = get(temp).addAll(i, o);\n+                    list = temp;\n+                    if (r) last += o.size();\n+                    expected = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).addAll(i, o);\n+                }\n+            }\n+        }\n+\n+        public Object remove(int i) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    Object o = get(temp).remove(i);\n+                    last--;\n+                    list = temp;\n+                    expected = temp;\n+                    return o;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).remove(i);\n+                }\n+            }\n+        }\n+\n+        public Object set(int i, Object a) {\n+            if (fast) {\n+                synchronized (FastArrayList.this) {\n+                    ArrayList temp = (ArrayList) list.clone();\n+                    Object o = get(temp).set(i, a);\n+                    list = temp;\n+                    expected = temp;\n+                    return o;\n+                }\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).set(i, a);\n+                }\n+            }\n+        }\n+\n+\n+        public Iterator iterator() {\n+            return new SubListIter(0);\n+        }\n+\n+        public ListIterator listIterator() {\n+            return new SubListIter(0);\n+        }\n+\n+        public ListIterator listIterator(int i) {\n+            return new SubListIter(i);\n+        }\n+\n+\n+        public Object get(int i) {\n+            if (fast) {\n+                return get(expected).get(i);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).get(i);\n+                }\n+            }\n+        }\n+\n+        public int indexOf(Object o) {\n+            if (fast) {\n+                return get(expected).indexOf(o);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).indexOf(o);\n+                }\n+            }\n+        }\n+\n+\n+        public int lastIndexOf(Object o) {\n+            if (fast) {\n+                return get(expected).lastIndexOf(o);\n+            } else {\n+                synchronized (list) {\n+                    return get(expected).lastIndexOf(o);\n+                }\n+            }\n+        }\n+\n+\n+        public List subList(int f, int l) {\n+            if (list != expected) {\n+                throw new ConcurrentModificationException();\n+            }\n+            return new SubList(first + f, f + l);\n+        }\n+\n+\n+    private class SubListIter implements ListIterator {\n+\n+        private List expected;\n+        private ListIterator iter;\n+        private int lastReturnedIndex = -1;\n+\n+\n+        public SubListIter(int i) {\n+            this.expected = list;\n+            this.iter = SubList.this.get(expected).listIterator(i);\n+        }\n+\n+        private void checkMod() {\n+            if (list != expected) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        List get() {\n+            return SubList.this.get(expected);\n+        }\n+\n+        public boolean hasNext() {\n+            checkMod();\n+            return iter.hasNext();     \n+        }\n+\n+        public Object next() {\n+            checkMod();\n+            lastReturnedIndex = iter.nextIndex();\n+            return iter.next();\n+        }\n+\n+        public boolean hasPrevious() {\n+            checkMod();\n+            return iter.hasPrevious();\n+        }\n+\n+        public Object previous() {\n+            checkMod();\n+            lastReturnedIndex = iter.previousIndex();\n+            return iter.previous();\n+        }\n+\n+        public int previousIndex() {\n+            checkMod();\n+            return iter.previousIndex();\n+        }\n+\n+        public int nextIndex() {\n+            checkMod();\n+            return iter.nextIndex();\n+        }\n+\n+        public void remove() {\n+            checkMod();\n+            if (lastReturnedIndex < 0) {\n+                throw new IllegalStateException();\n+            }\n+            get().remove(lastReturnedIndex);\n+            last--;\n+            expected = list;\n+            iter = get().listIterator(previousIndex());\n+            lastReturnedIndex = -1;\n+        }\n+\n+        public void set(Object o) {\n+            checkMod();\n+            if (lastReturnedIndex < 0) {\n+                throw new IllegalStateException();\n+            }\n+            get().set(lastReturnedIndex, o);\n+            expected = list;\n+            iter = get().listIterator(previousIndex() + 1);\n+        } \n+\n+        public void add(Object o) {\n+            checkMod();\n+            int i = nextIndex();\n+            get().add(i, o);\n+            last++;\n+            iter = get().listIterator(i + 1);\n+            lastReturnedIndex = 1;\n+        }\n+\n+   }\n+\n+\n+    }\n+\n+\n+\n+    private class ListIter implements ListIterator {\n+\n+        private List expected;\n+        private ListIterator iter;\n+        private int lastReturnedIndex = -1;\n+\n+\n+        public ListIter(int i) {\n+            this.expected = list;\n+            this.iter = get().listIterator(i);\n+        }\n+\n+        private void checkMod() {\n+            if (list != expected) {\n+                throw new ConcurrentModificationException();\n+            }\n+        }\n+\n+        List get() {\n+            return expected;\n+        }\n+\n+        public boolean hasNext() {\n+            checkMod();\n+            return iter.hasNext();     \n+        }\n+\n+        public Object next() {\n+            checkMod();\n+            lastReturnedIndex = iter.nextIndex();\n+            return iter.next();\n+        }\n+\n+        public boolean hasPrevious() {\n+            checkMod();\n+            return iter.hasPrevious();\n+        }\n+\n+        public Object previous() {\n+            checkMod();\n+            lastReturnedIndex = iter.previousIndex();\n+            return iter.previous();\n+        }\n+\n+        public int previousIndex() {\n+            checkMod();\n+            return iter.previousIndex();\n+        }\n+\n+        public int nextIndex() {\n+            checkMod();\n+            return iter.nextIndex();\n+        }\n+\n+        public void remove() {\n+            checkMod();\n+            if (lastReturnedIndex < 0) {\n+                throw new IllegalStateException();\n+            }\n+            get().remove(lastReturnedIndex);\n+            expected = list;\n+            iter = get().listIterator(previousIndex());\n+            lastReturnedIndex = -1;\n+        }\n+\n+        public void set(Object o) {\n+            checkMod();\n+            if (lastReturnedIndex < 0) {\n+                throw new IllegalStateException();\n+            }\n+            get().set(lastReturnedIndex, o);\n+            expected = list;\n+            iter = get().listIterator(previousIndex() + 1);\n+        } \n+\n+        public void add(Object o) {\n+            checkMod();\n+            int i = nextIndex();\n+            get().add(i, o);\n+            iter = get().listIterator(i + 1);\n+            lastReturnedIndex = 1;\n+        }\n+\n+   }\n }\n--- a/src/java/org/apache/commons/collections/FastHashMap.java\n+++ b/src/java/org/apache/commons/collections/FastHashMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.7 2002/08/10 00:49:45 pjack Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/08/10 00:49:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastHashMap.java,v 1.8 2002/08/13 04:34:08 pjack Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/08/13 04:34:08 $\n  *\n  * ====================================================================\n  *\n \n import java.io.Serializable;\n import java.util.Collection;\n+import java.util.ConcurrentModificationException;\n import java.util.HashMap;\n import java.util.Iterator;\n import java.util.Map;\n  *\n  * @since 1.0\n  * @author Craig R. McClanahan\n- * @version $Revision: 1.7 $ $Date: 2002/08/10 00:49:45 $\n+ * @version $Revision: 1.8 $ $Date: 2002/08/13 04:34:08 $\n  */\n \n public class FastHashMap extends HashMap {\n      * element in the returned collection is a <code>Map.Entry</code>.\n      */\n     public Set entrySet() {\n-\n-        if (fast) {\n-            return (map.entrySet());\n-        } else {\n-            synchronized (map) {\n-                return (map.entrySet());\n-            }\n-        }\n-\n+        return new EntrySet();\n     }\n \n \n      * Return a set view of the keys contained in this map.\n      */\n     public Set keySet() {\n-\n-        if (fast) {\n-            return (map.keySet());\n-        } else {\n-            synchronized (map) {\n-                return (map.keySet());\n-            }\n-        }\n-\n+        return new KeySet();\n     }\n \n \n      * Return a collection view of the values contained in this map.\n      */\n     public Collection values() {\n-\n-        if (fast) {\n-            return (map.values());\n-        } else {\n-            synchronized (map) {\n-                return (map.values());\n-            }\n-        }\n-\n-    }\n-\n+        return new Values();\n+    }\n+\n+\n+    private abstract class CollectionView implements Collection {\n+\n+        public CollectionView() {\n+        }\n+\n+        protected abstract Collection get(Map map);\n+        protected abstract Object iteratorNext(Map.Entry entry);\n+\n+\n+        public void clear() {\n+            if (fast) {\n+                synchronized (FastHashMap.this) {\n+                    HashMap temp = (HashMap) map.clone();\n+                    get(temp).clear();\n+                    map = temp;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    get(map).clear();\n+                }\n+            }\n+        }\n+\n+        public boolean remove(Object o) {\n+            if (fast) {\n+                synchronized (FastHashMap.this) {\n+                    HashMap temp = (HashMap) map.clone();\n+                    boolean r = get(temp).remove(o);\n+                    map = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    return get(map).remove(o);\n+                }\n+            }\n+        }\n+\n+        public boolean removeAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastHashMap.this) {\n+                    HashMap temp = (HashMap) map.clone();\n+                    boolean r = get(temp).removeAll(o);\n+                    map = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    return get(map).removeAll(o);\n+                }\n+            }\n+        }\n+\n+        public boolean retainAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastHashMap.this) {\n+                    HashMap temp = (HashMap) map.clone();\n+                    boolean r = get(temp).retainAll(o);\n+                    map = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    return get(map).retainAll(o);\n+                }\n+            }\n+        }\n+\n+        public int size() {\n+            if (fast) {\n+                return get(map).size();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).size();\n+                }\n+            }\n+        }\n+\n+\n+        public boolean isEmpty() {\n+            if (fast) {\n+                return get(map).isEmpty();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).isEmpty();\n+                }\n+            }\n+        }\n+\n+        public boolean contains(Object o) {\n+            if (fast) {\n+                return get(map).contains(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).contains(o);\n+                }\n+            }\n+        }\n+\n+        public boolean containsAll(Collection o) {\n+            if (fast) {\n+                return get(map).containsAll(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).containsAll(o);\n+                }\n+            }\n+        }\n+\n+        public Object[] toArray(Object[] o) {\n+            if (fast) {\n+                return get(map).toArray(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).toArray(o);\n+                }\n+            }\n+        }\n+\n+        public Object[] toArray() {\n+            if (fast) {\n+                return get(map).toArray();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).toArray();\n+                }\n+            }\n+        }\n+\n+\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (fast) {\n+                return get(map).equals(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).equals(o);\n+                }\n+            }\n+        }\n+\n+        public int hashCode() {\n+            if (fast) {\n+                return get(map).hashCode();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).hashCode();\n+                }\n+            }\n+        }\n+\n+        public boolean add(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Iterator iterator() {\n+            return new CollectionViewIterator();\n+        }\n+\n+        private class CollectionViewIterator implements Iterator {\n+\n+            private Map expected;\n+            private Map.Entry lastReturned = null;\n+            private Iterator iterator;\n+\n+            public CollectionViewIterator() {\n+                this.expected = map;\n+                this.iterator = expected.entrySet().iterator();\n+            }\n+ \n+            public boolean hasNext() {\n+                if (expected != map) {\n+                    throw new ConcurrentModificationException();\n+                }\n+                return iterator.hasNext();\n+            }\n+\n+            public Object next() {\n+                if (expected != map) {\n+                    throw new ConcurrentModificationException();\n+                }\n+                lastReturned = (Map.Entry)iterator.next();\n+                return iteratorNext(lastReturned);\n+            }\n+\n+            public void remove() {\n+                if (lastReturned == null) {\n+                    throw new IllegalStateException();\n+                }\n+                if (fast) {\n+                    synchronized (FastHashMap.this) {\n+                        if (expected != map) {\n+                            throw new ConcurrentModificationException();\n+                        }\n+                        FastHashMap.this.remove(lastReturned.getKey());\n+                        lastReturned = null;\n+                        expected = map;\n+                    }\n+                } else {\n+                    iterator.remove();\n+                    lastReturned = null;\n+                }\n+            }\n+        }\n+   }\n+\n+\n+   private class KeySet extends CollectionView implements Set {\n+\n+       protected Collection get(Map map) {\n+           return map.keySet();\n+       }\n+\n+       protected Object iteratorNext(Map.Entry entry) {\n+           return entry.getKey();\n+       }       \n+\n+   }\n+\n+\n+   private class Values extends CollectionView {\n+\n+       protected Collection get(Map map) {\n+           return map.values();\n+       }\n+\n+       protected Object iteratorNext(Map.Entry entry) {\n+           return entry.getValue();\n+       }\n+   }\n+\n+\n+   private class EntrySet extends CollectionView implements Set {\n+\n+       protected Collection get(Map map) {\n+           return map.entrySet();\n+       }\n+\n+\n+       protected Object iteratorNext(Map.Entry entry) {\n+           return entry;\n+       }\n+\n+   }\n \n }\n--- a/src/java/org/apache/commons/collections/FastTreeMap.java\n+++ b/src/java/org/apache/commons/collections/FastTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.7 2002/08/10 00:49:45 pjack Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/08/10 00:49:45 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/java/org/apache/commons/collections/FastTreeMap.java,v 1.8 2002/08/13 04:34:08 pjack Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/08/13 04:34:08 $\n  *\n  * ====================================================================\n  *\n import java.io.Serializable;\n import java.util.Collection;\n import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n import java.util.Map;\n import java.util.Map.Entry;\n  *\n  * @since 1.0\n  * @author Craig R. McClanahan\n- * @version $Revision: 1.7 $ $Date: 2002/08/10 00:49:45 $\n+ * @version $Revision: 1.8 $ $Date: 2002/08/13 04:34:08 $\n  */\n \n public class FastTreeMap extends TreeMap {\n      * element in the returned collection is a <code>Map.Entry</code>.\n      */\n     public Set entrySet() {\n-\n-        if (fast) {\n-            return (map.entrySet());\n-        } else {\n-            synchronized (map) {\n-                return (map.entrySet());\n-            }\n-        }\n-\n+        return new EntrySet();\n     }\n \n \n      * Return a set view of the keys contained in this map.\n      */\n     public Set keySet() {\n-\n-        if (fast) {\n-            return (map.keySet());\n-        } else {\n-            synchronized (map) {\n-                return (map.keySet());\n-            }\n-        }\n-\n+        return new KeySet();\n     }\n \n \n      * Return a collection view of the values contained in this map.\n      */\n     public Collection values() {\n-\n-        if (fast) {\n-            return (map.values());\n-        } else {\n-            synchronized (map) {\n-                return (map.values());\n-            }\n-        }\n-\n-    }\n+        return new Values();\n+    }\n+\n+\n+\n+    private abstract class CollectionView implements Collection {\n+\n+        public CollectionView() {\n+        }\n+\n+        protected abstract Collection get(Map map);\n+        protected abstract Object iteratorNext(Map.Entry entry);\n+\n+\n+        public void clear() {\n+            if (fast) {\n+                synchronized (FastTreeMap.this) {\n+                    TreeMap temp = (TreeMap) map.clone();\n+                    get(temp).clear();\n+                    map = temp;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    get(map).clear();\n+                }\n+            }\n+        }\n+\n+        public boolean remove(Object o) {\n+            if (fast) {\n+                synchronized (FastTreeMap.this) {\n+                    TreeMap temp = (TreeMap) map.clone();\n+                    boolean r = get(temp).remove(o);\n+                    map = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    return get(map).remove(o);\n+                }\n+            }\n+        }\n+\n+        public boolean removeAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastTreeMap.this) {\n+                    TreeMap temp = (TreeMap) map.clone();\n+                    boolean r = get(temp).removeAll(o);\n+                    map = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    return get(map).removeAll(o);\n+                }\n+            }\n+        }\n+\n+        public boolean retainAll(Collection o) {\n+            if (fast) {\n+                synchronized (FastTreeMap.this) {\n+                    TreeMap temp = (TreeMap) map.clone();\n+                    boolean r = get(temp).retainAll(o);\n+                    map = temp;\n+                    return r;\n+                }\n+            } else {\n+                synchronized (map) {\n+                    return get(map).retainAll(o);\n+                }\n+            }\n+        }\n+\n+        public int size() {\n+            if (fast) {\n+                return get(map).size();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).size();\n+                }\n+            }\n+        }\n+\n+\n+        public boolean isEmpty() {\n+            if (fast) {\n+                return get(map).isEmpty();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).isEmpty();\n+                }\n+            }\n+        }\n+\n+        public boolean contains(Object o) {\n+            if (fast) {\n+                return get(map).contains(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).contains(o);\n+                }\n+            }\n+        }\n+\n+        public boolean containsAll(Collection o) {\n+            if (fast) {\n+                return get(map).containsAll(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).containsAll(o);\n+                }\n+            }\n+        }\n+\n+        public Object[] toArray(Object[] o) {\n+            if (fast) {\n+                return get(map).toArray(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).toArray(o);\n+                }\n+            }\n+        }\n+\n+        public Object[] toArray() {\n+            if (fast) {\n+                return get(map).toArray();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).toArray();\n+                }\n+            }\n+        }\n+\n+\n+        public boolean equals(Object o) {\n+            if (o == this) return true;\n+            if (fast) {\n+                return get(map).equals(o);\n+            } else {\n+                synchronized (map) {\n+                    return get(map).equals(o);\n+                }\n+            }\n+        }\n+\n+        public int hashCode() {\n+            if (fast) {\n+                return get(map).hashCode();\n+            } else {\n+                synchronized (map) {\n+                    return get(map).hashCode();\n+                }\n+            }\n+        }\n+\n+        public boolean add(Object o) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public boolean addAll(Collection c) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        public Iterator iterator() {\n+            return new CollectionViewIterator();\n+        }\n+\n+        private class CollectionViewIterator implements Iterator {\n+\n+            private Map expected;\n+            private Map.Entry lastReturned = null;\n+            private Iterator iterator;\n+\n+            public CollectionViewIterator() {\n+                this.expected = map;\n+                this.iterator = expected.entrySet().iterator();\n+            }\n+ \n+            public boolean hasNext() {\n+                if (expected != map) {\n+                    throw new ConcurrentModificationException();\n+                }\n+                return iterator.hasNext();\n+            }\n+\n+            public Object next() {\n+                if (expected != map) {\n+                    throw new ConcurrentModificationException();\n+                }\n+                lastReturned = (Map.Entry)iterator.next();\n+                return iteratorNext(lastReturned);\n+            }\n+\n+            public void remove() {\n+                if (lastReturned == null) {\n+                    throw new IllegalStateException();\n+                }\n+                if (fast) {\n+                    synchronized (FastTreeMap.this) {\n+                        if (expected != map) {\n+                            throw new ConcurrentModificationException();\n+                        }\n+                        FastTreeMap.this.remove(lastReturned.getKey());\n+                        lastReturned = null;\n+                        expected = map;\n+                    }\n+                } else {\n+                    iterator.remove();\n+                    lastReturned = null;\n+                }\n+            }\n+        }\n+   }\n+\n+\n+   private class KeySet extends CollectionView implements Set {\n+\n+       protected Collection get(Map map) {\n+           return map.keySet();\n+       }\n+\n+       protected Object iteratorNext(Map.Entry entry) {\n+           return entry.getKey();\n+       }       \n+\n+   }\n+\n+\n+   private class Values extends CollectionView {\n+\n+       protected Collection get(Map map) {\n+           return map.values();\n+       }\n+\n+       protected Object iteratorNext(Map.Entry entry) {\n+           return entry.getValue();\n+       }\n+   }\n+\n+\n+   private class EntrySet extends CollectionView implements Set {\n+\n+       protected Collection get(Map map) {\n+           return map.entrySet();\n+       }\n+\n+\n+       protected Object iteratorNext(Map.Entry entry) {\n+           return entry;\n+       }\n+\n+   }\n \n \n }\n--- a/src/test/org/apache/commons/collections/TestFastArrayList1.java\n+++ b/src/test/org/apache/commons/collections/TestFastArrayList1.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastArrayList1.java,v 1.2 2002/06/21 03:33:28 mas Exp $\n- * $Revision: 1.2 $\n- * $Date: 2002/06/21 03:33:28 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastArrayList1.java,v 1.3 2002/08/13 04:34:09 pjack Exp $\n+ * $Revision: 1.3 $\n+ * $Date: 2002/08/13 04:34:09 $\n  *\n  * ====================================================================\n  *\n  * Test FastArrayList implementation in <strong>fast</strong> mode.\n  *\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastArrayList1.java,v 1.2 2002/06/21 03:33:28 mas Exp $\n+ * @version $Id: TestFastArrayList1.java,v 1.3 2002/08/13 04:34:09 pjack Exp $\n  */\n public class TestFastArrayList1 extends TestFastArrayList\n {\n \n     public void setUp()\n     {\n-        list = (ArrayList) makeList();\n+        list = (ArrayList) makeEmptyList();\n     }\n \n-    public List makeList()\n+    public List makeEmptyList()\n     {\n         FastArrayList fal = new FastArrayList();\n         fal.setFast(true);\n         return (fal);\n     }\n \n+\n }\n--- a/src/test/org/apache/commons/collections/TestFastHashMap1.java\n+++ b/src/test/org/apache/commons/collections/TestFastHashMap1.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap1.java,v 1.3 2002/06/18 05:35:58 mas Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/06/18 05:35:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastHashMap1.java,v 1.4 2002/08/13 04:34:09 pjack Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/08/13 04:34:09 $\n  *\n  * ====================================================================\n  *\n  * Test FastHashMap in <strong>fast</strong> mode.\n  *\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastHashMap1.java,v 1.3 2002/06/18 05:35:58 mas Exp $\n+ * @version $Id: TestFastHashMap1.java,v 1.4 2002/08/13 04:34:09 pjack Exp $\n  */\n public class TestFastHashMap1 extends TestFastHashMap\n {\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeMap() {\n+    public Map makeEmptyMap() {\n         FastHashMap fhm = new FastHashMap();\n         fhm.setFast(true);\n         return (fhm);\n     }\n \n-    /**\n-     *  When the fast hash map is in fast mode, the underlying hash map is\n-     *  cloned on modification (i.e. on a put).  Because of that, any\n-     *  previously existing entry set will be representing the old (pre-clone)\n-     *  map and will not reflect changes made to the map after the clone.  So,\n-     *  we must override this test.\n-     **/\n-    public void testEntrySetChangesWithMapPut() {\n-    }\n-\n-    /**\n-     *  When the fast hash map is in fast mode, the underlying hash map is\n-     *  cloned on modification (i.e. on a remove).  Because of that, any\n-     *  previously existing entry set will be representing the old (pre-clone)\n-     *  map and will not reflect changes made to the map after the clone.  So,\n-     *  we must override this test.\n-     **/\n-    public void testEntrySetChangesWithMapRemove() {\n-    }\n-\n-    /**\n-     *  When the fast hash map is in fast mode, the underlying hash map is\n-     *  cloned on modification (i.e. on a put).  Because of that, any\n-     *  previously existing entry set will be representing the old (pre-clone)\n-     *  map, so changes to the set will not be seen in the map. So, we must\n-     *  override this test.\n-     **/\n-    public void testEntrySetRemoveCausesMapModification() {\n-    }\n-\n     public void setUp()\n     {\n-        map = (HashMap) makeMap();\n+        map = (HashMap) makeEmptyMap();\n     }\n \n }\n--- a/src/test/org/apache/commons/collections/TestFastTreeMap.java\n+++ b/src/test/org/apache/commons/collections/TestFastTreeMap.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap.java,v 1.7 2002/08/12 18:00:46 pjack Exp $\n- * $Revision: 1.7 $\n- * $Date: 2002/08/12 18:00:46 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap.java,v 1.8 2002/08/13 04:34:09 pjack Exp $\n+ * $Revision: 1.8 $\n+ * $Date: 2002/08/13 04:34:09 $\n  *\n  * ====================================================================\n  *\n \n /**\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastTreeMap.java,v 1.7 2002/08/12 18:00:46 pjack Exp $\n+ * @version $Id: TestFastTreeMap.java,v 1.8 2002/08/13 04:34:09 pjack Exp $\n  */\n public class TestFastTreeMap extends TestTreeMap\n {\n         ftm.setFast(false);\n         return (ftm);\n     }\n+\n+    public Map makeConfirmedEmptyMap() {\n+        return new TreeMap();\n+    }\n   \n     /**\n      *  The comparator for the fast tree map does not support null keys.\n--- a/src/test/org/apache/commons/collections/TestFastTreeMap1.java\n+++ b/src/test/org/apache/commons/collections/TestFastTreeMap1.java\n /*\n- * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap1.java,v 1.3 2002/06/18 05:35:58 mas Exp $\n- * $Revision: 1.3 $\n- * $Date: 2002/06/18 05:35:58 $\n+ * $Header: /home/jerenkrantz/tmp/commons/commons-convert/cvs/home/cvs/jakarta-commons//collections/src/test/org/apache/commons/collections/TestFastTreeMap1.java,v 1.4 2002/08/13 04:34:09 pjack Exp $\n+ * $Revision: 1.4 $\n+ * $Date: 2002/08/13 04:34:09 $\n  *\n  * ====================================================================\n  *\n  * Test FastTreeMap in <strong>fast</strong> mode.\n  *\n  * @author <a href=\"mailto:jvanzyl@apache.org\">Jason van Zyl</a>\n- * @version $Id: TestFastTreeMap1.java,v 1.3 2002/06/18 05:35:58 mas Exp $\n+ * @version $Id: TestFastTreeMap1.java,v 1.4 2002/08/13 04:34:09 pjack Exp $\n  */\n public class TestFastTreeMap1 extends TestFastTreeMap\n {\n         junit.textui.TestRunner.main(testCaseName);\n     }\n \n-    public Map makeMap() {\n+    public Map makeEmptyMap() {\n         FastTreeMap ftm = new FastTreeMap();\n         ftm.setFast(true);\n         return (ftm);\n \n     public void setUp()\n     {\n-        map = (TreeMap) makeMap();\n+        map = (TreeMap) makeEmptyMap();\n     }\n \n-    /**\n-     *  When the fast tree map is in fast mode, the underlying tree map is\n-     *  cloned on modification (i.e. on a put).  Because of that, any\n-     *  previously existing entry set will be representing the old (pre-clone)\n-     *  map and will not reflect changes made to the map after the clone.  So,\n-     *  we must override this test.\n-     **/\n-    public void testMapEntrySetChangesWithMapPut() {\n-    }\n-\n-    /**\n-     *  When the fast tree map is in fast mode, the underlying tree map is\n-     *  cloned on modification (i.e. on a put).  Because of that, any\n-     *  previously existing entry set will be representing the old (pre-clone)\n-     *  map and will not reflect changes made to the map after the clone.  So,\n-     *  we must override this test.\n-     **/\n-    public void testMapEntrySetChangesWithMapRemove() {\n-    }\n-\n-    /**\n-     *  When the fast tree map is in fast mode, the underlying tree map is\n-     *  cloned on modification (i.e. on a put).  Because of that, any\n-     *  previously existing entry set will be representing the old (pre-clone)\n-     *  map, so changes to the set will not be seen in the map. So, we must\n-     *  override this test.\n-     **/\n-    public void testMapEntrySetRemoveCausesMapModification() {\n-    }\n }", "timestamp": 1029213249, "metainfo": ""}