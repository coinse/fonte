{"sha": "4a1e68e1b8ceb367523a8492000d05f6772803b2", "log": "Merging from -r468106:814127 of collections_jdk5_branch - namely where this code was generified; mostly in r738956.  Also see the following revisions:      ------------------------------------------------------------------------     r751903 | mbenson | 2009-03-09 16:10:21 -0700 (Mon, 09 Mar 2009) | 1 line          comment     ------------------------------------------------------------------------     r751852 | mbenson | 2009-03-09 14:37:19 -0700 (Mon, 09 Mar 2009) | 1 line          comments     ------------------------------------------------------------------------     r740150 | mbenson | 2009-02-02 15:24:00 -0800 (Mon, 02 Feb 2009) | 1 line          make all [collections] maps implement IterableMap     ------------------------------------------------------------------------     r471189 | scolebourne | 2006-11-04 05:57:57 -0800 (Sat, 04 Nov 2006) | 1 line          Remove getMap(), getOrderedMap() and getSortedMap() - use decorated()     ------------------------------------------------------------------------   ", "commit": "\n--- a/src/java/org/apache/commons/collections/map/TransformedMap.java\n+++ b/src/java/org/apache/commons/collections/map/TransformedMap.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n import java.io.Serializable;\n-import java.util.Iterator;\n import java.util.Map;\n \n+import org.apache.commons.collections.IterableMap;\n import org.apache.commons.collections.Transformer;\n \n /**\n  * <strong>Note that TransformedMap is not synchronized and is not thread-safe.</strong>\n  * If you wish to use this map from multiple threads concurrently, you must use\n  * appropriate synchronization. The simplest approach is to wrap this map\n- * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw \n+ * using {@link java.util.Collections#synchronizedMap(Map)}. This class may throw\n  * exceptions when accessed by concurrent threads without synchronization.\n  * <p>\n  * This class is Serializable from Commons Collections 3.1.\n+ * <p>\n+ * @see org.apache.commons.collections.splitmap.TransformedMap\n  *\n  * @since Commons Collections 3.0\n  * @version $Revision$ $Date$\n  *\n  * @author Stephen Colebourne\n  */\n-public class TransformedMap\n-        extends AbstractInputCheckedMapDecorator\n+public class TransformedMap<K, V>\n+        extends AbstractInputCheckedMapDecorator<K, V>\n         implements Serializable {\n \n     /** Serialization version */\n     private static final long serialVersionUID = 7023152376788900464L;\n \n     /** The transformer to use for the key */\n-    protected final Transformer keyTransformer;\n+    protected final Transformer<? super K, ? extends K> keyTransformer;\n     /** The transformer to use for the value */\n-    protected final Transformer valueTransformer;\n+    protected final Transformer<? super V, ? extends V> valueTransformer;\n \n     /**\n      * Factory method to create a transforming map.\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * are NOT transformed.\n-     * Constrast this with {@link #decorateTransform}.\n-     * \n+     * Contrast this with {@link #decorateTransform}.\n+     *\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n      */\n-    public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n-        return new TransformedMap(map, keyTransformer, valueTransformer);\n+    public static <K, V> IterableMap<K, V> decorate(Map<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        return new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n     }\n \n     /**\n      * <p>\n      * If there are any elements already in the map being decorated, they\n      * will be transformed by this method.\n-     * Constrast this with {@link #decorate}.\n-     * \n+     * Contrast this with {@link #decorate}.\n+     *\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no transformation\n      * @param valueTransformer  the transformer to use for value conversion, null means no transformation\n      * @throws IllegalArgumentException if map is null\n      * @since Commons Collections 3.2\n      */\n-    public static Map decorateTransform(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n-        TransformedMap decorated = new TransformedMap(map, keyTransformer, valueTransformer);\n+    public static <K, V> Map<K, V> decorateTransform(Map<K, V> map,\n+            Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n+        TransformedMap<K, V> decorated = new TransformedMap<K, V>(map, keyTransformer, valueTransformer);\n         if (map.size() > 0) {\n-            Map transformed = decorated.transformMap(map);\n+            Map<K, V> transformed = decorated.transformMap(map);\n             decorated.clear();\n-            decorated.getMap().putAll(transformed);  // avoids double transformation\n+            decorated.decorated().putAll(transformed);  // avoids double transformation\n         }\n         return decorated;\n     }\n      * <p>\n      * If there are any elements already in the collection being decorated, they\n      * are NOT transformed.\n-     * \n+     *\n      * @param map  the map to decorate, must not be null\n      * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n      * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n      * @throws IllegalArgumentException if map is null\n      */\n-    protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {\n+    protected TransformedMap(Map<K, V> map, Transformer<? super K, ? extends K> keyTransformer,\n+            Transformer<? super V, ? extends V> valueTransformer) {\n         super(map);\n         this.keyTransformer = keyTransformer;\n         this.valueTransformer = valueTransformer;\n     //-----------------------------------------------------------------------\n     /**\n      * Write the map out using a custom routine.\n-     * \n+     *\n      * @param out  the output stream\n      * @throws IOException\n      * @since Commons Collections 3.1\n \n     /**\n      * Read the map in using a custom routine.\n-     * \n+     *\n      * @param in  the input stream\n      * @throws IOException\n      * @throws ClassNotFoundException\n      * @since Commons Collections 3.1\n      */\n+    @SuppressWarnings(\"unchecked\")\n     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n         in.defaultReadObject();\n         map = (Map) in.readObject();\n      * Transforms a key.\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n-     * \n+     *\n      * @param object  the object to transform\n      * @throws the transformed object\n      */\n-    protected Object transformKey(Object object) {\n+    protected K transformKey(K object) {\n         if (keyTransformer == null) {\n             return object;\n         }\n      * Transforms a value.\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n-     * \n+     *\n      * @param object  the object to transform\n      * @throws the transformed object\n      */\n-    protected Object transformValue(Object object) {\n+    protected V transformValue(V object) {\n         if (valueTransformer == null) {\n             return object;\n         }\n      * Transforms a map.\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n-     * \n+     *\n      * @param map  the map to transform\n      * @throws the transformed object\n      */\n-    protected Map transformMap(Map map) {\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<K, V> transformMap(Map<? extends K, ? extends V> map) {\n         if (map.isEmpty()) {\n-            return map;\n-        }\n-        Map result = new LinkedMap(map.size());\n-        for (Iterator it = map.entrySet().iterator(); it.hasNext(); ) {\n-            Map.Entry entry = (Map.Entry) it.next();\n-            result.put(transformKey(entry.getKey()), transformValue(entry.getValue()));\n+            return (Map<K, V>) map;\n+        }\n+        Map<K, V> result = new LinkedMap<K, V>(map.size());\n+\n+        for (Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n+            result.put((K) transformKey(entry.getKey()), transformValue(entry.getValue()));\n         }\n         return result;\n     }\n \n     /**\n      * Override to transform the value when using <code>setValue</code>.\n-     * \n+     *\n      * @param value  the value to transform\n      * @return the transformed value\n      * @since Commons Collections 3.1\n      */\n-    protected Object checkSetValue(Object value) {\n+    protected V checkSetValue(V value) {\n         return valueTransformer.transform(value);\n     }\n \n     /**\n      * Override to only return true when there is a value transformer.\n-     * \n+     *\n      * @return true if a value transformer is in use\n      * @since Commons Collections 3.1\n      */\n     }\n \n     //-----------------------------------------------------------------------\n-    public Object put(Object key, Object value) {\n+    public V put(K key, V value) {\n         key = transformKey(key);\n         value = transformValue(value);\n-        return getMap().put(key, value);\n-    }\n-\n-    public void putAll(Map mapToCopy) {\n+        return decorated().put(key, value);\n+    }\n+\n+    public void putAll(Map<? extends K, ? extends V> mapToCopy) {\n         mapToCopy = transformMap(mapToCopy);\n-        getMap().putAll(mapToCopy);\n+        decorated().putAll(mapToCopy);\n     }\n \n }", "timestamp": 1252994176, "metainfo": ""}