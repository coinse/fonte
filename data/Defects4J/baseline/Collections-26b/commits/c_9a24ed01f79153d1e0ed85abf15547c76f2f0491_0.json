{"sha": "9a24ed01f79153d1e0ed85abf15547c76f2f0491", "log": "address some testing TODOs  ", "commit": "\n--- a/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n+++ b/src/test/org/apache/commons/collections/map/AbstractTestMap.java\n \n import java.io.Serializable;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.Set;\n-import java.util.Map.Entry;\n \n import org.apache.commons.collections.AbstractTestObject;\n import org.apache.commons.collections.BulkTest;\n+import org.apache.commons.collections.CollectionUtils;\n import org.apache.commons.collections.collection.AbstractTestCollection;\n+import org.apache.commons.collections.keyvalue.DefaultMapEntry;\n import org.apache.commons.collections.set.AbstractTestSet;\n \n /**\n     }\n \n     /**\n+     * Tests values.removeAll.\n+     */\n+    public void testValuesRemoveAll() {\n+    \tresetFull();\n+    \tCollection<V> values = getMap().values();\n+    \tList<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+    \tif (!values.equals(sampleValuesAsList)) {\n+    \t\treturn;\n+    \t}\n+\t\ttry {\n+\t\t\tassertFalse(values.removeAll(Collections.<V> emptySet()));\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// if values.removeAll is unsupported, just skip this test\n+\t\t\treturn;\n+\t\t}\n+    \tassertEquals(sampleValuesAsList.size(), getMap().size());\n+    \ttry {\n+\t    \tassertTrue(values.removeAll(sampleValuesAsList));\n+\t    } catch (UnsupportedOperationException e) {\n+\t    \t// if values.removeAll is unsupported, just skip this test\n+\t    \treturn;\n+\t    }\n+\t    assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test values.retainAll.\n+     */\n+    public void testValuesRetainAll() {\n+    \tresetFull();\n+    \tCollection<V> values = getMap().values();\n+    \tList<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+    \tif (!values.equals(sampleValuesAsList)) {\n+    \t\treturn;\n+    \t}\n+    \ttry {\n+    \t\tassertFalse(values.retainAll(sampleValuesAsList));\n+    \t} catch (UnsupportedOperationException e) {\n+            // if values.retainAll is unsupported, just skip this test\n+    \t\treturn;\n+    \t}\n+    \tassertEquals(sampleValuesAsList.size(), getMap().size());\n+    \ttry {\n+\t\t\tassertTrue(values.retainAll(Collections.<V> emptySet()));\n+\t\t} catch (UnsupportedOperationException e) {\n+\t\t\t// if values.retainAll is unsupported, just skip this test\n+\t\t\treturn;\n+\t\t}\n+\t\tassertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verifies that values.iterator.remove changes the underlying map.\n+     */\n+    public void testValuesIteratorRemoveChangesMap() {\n+    \tresetFull();\n+    \tList<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n+    \tMap<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n+    \tCollection<V> values = getMap().values();\n+    \tfor (Iterator<V> iter = values.iterator(); iter.hasNext();) {\n+    \t\tV value = iter.next();\n+    \t\tInteger count = cardinality.get(value);\n+    \t\tif (count == null) {\n+    \t\t\treturn;\n+    \t\t}\n+    \t\ttry {\n+\t\t\t\titer.remove();\n+\t\t\t\tcardinality.put(value, --count);\n+    \t\t} catch (UnsupportedOperationException e) {\n+    \t\t\t// if values.iterator.remove is unsupported, just skip this test\n+    \t\t\treturn;\n+    \t\t}\n+    \t\tboolean expected = count > 0;\n+    \t\tStringBuilder msg = new StringBuilder(\"Value should \");\n+    \t\tmsg.append(expected ? \"yet \" : \"no longer \");\n+    \t\tmsg.append(\"be present in the underlying map\");\n+    \t\tassertEquals(msg.toString(), expected, getMap().containsValue(value));\n+    \t}\n+    \tassertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n      * Tests that the {@link Map#keySet} set is backed by\n      * the underlying map by removing from the keySet set\n      * and testing if the key was removed from the map.\n         }\n     }\n \n-    // TODO: Need:\n-    //    testValuesRemovedFromEntrySetAreRemovedFromMap\n-    //    same for EntrySet/KeySet/values's\n-    //      Iterator.remove, removeAll, retainAll\n-\n+    /**\n+     * Test keySet.removeAll.\n+     */\n+    public void testKeySetRemoveAll() {\n+        resetFull();\n+        Set<K> keys = getMap().keySet();\n+        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+        \treturn;\n+        }\n+        try {\n+        \tassertFalse(keys.removeAll(Collections.<K> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+        \treturn;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+        \tassertTrue(keys.removeAll(sampleKeysAsList));\n+        } catch (UnsupportedOperationException e) {\n+        \treturn;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test keySet.retainAll.\n+     */\n+    public void testKeySetRetainAll() {\n+        resetFull();\n+        Set<K> keys = getMap().keySet();\n+        List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n+        if (!keys.equals(sampleKeysAsList)) {\n+        \treturn;\n+        }\n+        try {\n+        \tassertFalse(keys.retainAll(sampleKeysAsList));\n+        } catch (UnsupportedOperationException e) {\n+        \treturn;\n+        }\n+        assertEquals(sampleKeysAsList, keys);\n+        try {\n+        \tassertTrue(keys.retainAll(Collections.<K> emptySet()));\n+        } catch (UnsupportedOperationException e) {\n+        \treturn;\n+        }\n+        assertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that keySet.iterator.remove changes the underlying map.\n+     */\n+    public void testKeySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n+        \tK key = iter.next();\n+        \ttry {\n+        \t\titer.remove();\n+        \t} catch (UnsupportedOperationException e) {\n+        \t\treturn;\n+        \t}\n+        \tassertFalse(getMap().containsKey(key));\n+        }\n+    }\n+\n+    /**\n+     * Tests that the {@link Map#entrySet} set is backed by\n+     * the underlying map by removing from the entrySet set\n+     * and testing if the entry was removed from the map.\n+     */\n+    public void testEntrySetRemoveChangesMap() {\n+    \tresetFull();\n+    \tK[] sampleKeys = getSampleKeys();\n+    \tV[] sampleValues = getSampleValues();\n+    \tSet<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+    \tfor (int i = 0; i < sampleKeys.length; i++) {\n+    \t\ttry {\n+    \t\t\tentrySet.remove(new DefaultMapEntry<K, V>(sampleKeys[i], sampleValues[i]));\n+    \t\t} catch (UnsupportedOperationException e) {\n+    \t\t\t// if entrySet removal is unsupported, just skip this test\n+    \t\t\treturn;\n+    \t\t}\n+    \t\tassertTrue(\n+    \t\t\t\t\"Entry should have been removed from the underlying map.\",\n+    \t\t\t\t!getMap().containsKey(sampleKeys[i]));\n+    \t}\n+    }\n+\n+    /**\n+     * Test entrySet.removeAll.\n+     */\n+    public void testEntrySetRemoveAll() {\n+    \tresetFull();\n+    \tK[] sampleKeys = getSampleKeys();\n+    \tV[] sampleValues = getSampleValues();\n+    \t//verify map looks as expected:\n+    \tfor (int i = 0; i < sampleKeys.length; i++) {\n+    \t\tif (!getMap().containsKey(sampleKeys[i])) {\n+    \t\t\treturn;\n+    \t\t}\n+    \t\tV value = sampleValues[i];\n+    \t\tV test = getMap().get(sampleKeys[i]);\n+    \t\tif (value == test || value != null && value.equals(test)) {\n+    \t\t\tcontinue;\n+    \t\t}\n+    \t\treturn;\n+    \t}\n+    \tSet<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+    \tHashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+    \ttry {\n+    \t\tassertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>> emptySet()));\n+    \t} catch (UnsupportedOperationException e) {\n+    \t\treturn;\n+    \t}\n+    \tassertEquals(sampleKeys.length, getMap().size());\n+    \ttry {\n+    \t\tassertTrue(entrySet.removeAll(comparisonSet));\n+    \t} catch (UnsupportedOperationException e) {\n+    \t\treturn;\n+    \t}\n+    \tassertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Test entrySet.retainAll.\n+     */\n+    public void testEntrySetRetainAll() {\n+    \tresetFull();\n+    \tK[] sampleKeys = getSampleKeys();\n+    \tV[] sampleValues = getSampleValues();\n+    \t//verify map looks as expected:\n+    \tfor (int i = 0; i < sampleKeys.length; i++) {\n+    \t\tif (!getMap().containsKey(sampleKeys[i])) {\n+    \t\t\treturn;\n+    \t\t}\n+    \t\tV value = sampleValues[i];\n+    \t\tV test = getMap().get(sampleKeys[i]);\n+    \t\tif (value == test || value != null && value.equals(test)) {\n+    \t\t\tcontinue;\n+    \t\t}\n+    \t\treturn;\n+    \t}\n+    \tSet<Map.Entry<K, V>> entrySet = getMap().entrySet();\n+    \tHashSet<Map.Entry<K, V>> comparisonSet = new HashSet<Map.Entry<K, V>>(entrySet);\n+    \ttry {\n+    \t\tassertFalse(entrySet.retainAll(comparisonSet));\n+    \t} catch (UnsupportedOperationException e) {\n+    \t\treturn;\n+    \t}\n+    \tassertEquals(sampleKeys.length, getMap().size());\n+    \ttry {\n+    \t\tassertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>> emptySet()));\n+    \t} catch (UnsupportedOperationException e) {\n+    \t\treturn;\n+    \t}\n+    \tassertTrue(getMap().isEmpty());\n+    }\n+\n+    /**\n+     * Verify that entrySet.iterator.remove changes the underlying map.\n+     */\n+    public void testEntrySetIteratorRemoveChangesMap() {\n+        resetFull();\n+        for (Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n+        \tK key = iter.next().getKey();\n+        \ttry {\n+        \t\titer.remove();\n+        \t} catch (UnsupportedOperationException e) {\n+        \t\treturn;\n+        \t}\n+        \tassertFalse(getMap().containsKey(key));\n+        }\n+    }\n \n     /**\n      * Utility methods to create an array of Map.Entry objects", "timestamp": 1297718515, "metainfo": ""}