{"sha": "4f5a854b287fc4cd24cbd316c704d15d6f3d4ac5", "log": "Continue review of MultiValuedMap interface and implementations: code style and formatting, use NullPointerException for null arguments, use MultiSet instead of Bag.  ", "commit": "\n--- a/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/ListValuedMap.java\n /**\n  * Defines a map that holds a list of values against each key.\n  * <p>\n- * A <code>ListValuedMap</code> is a Map with slightly different semantics:\n+ * A {@code ListValuedMap} is a Map with slightly different semantics:\n  * <ul>\n- *   <li>Putting a value into the map will add the value to a Collection at that key.</li>\n- *   <li>Getting a value will return a Collection, holding all the values put to that key.</li>\n+ *   <li>Putting a value into the map will add the value to a {@link List} at that key.</li>\n+ *   <li>Getting a value will return a {@link List}, holding all the values put to that key.</li>\n  * </ul>\n  *\n  * @since 4.1\n      * returned list will update the underlying {@code ListValuedMap} and\n      * vice-versa.\n      *\n-     * @param key the key to retrieve\n-     * @return the <code>List</code> of values, implementations should return an\n-     *         empty list for no mapping\n+     * @param key  the key to retrieve\n+     * @return the {@code List} of values, implementations should return an\n+     *   empty {@code List} for no mapping\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n+    @Override\n     List<V> get(Object key);\n \n     /**\n      * propagated to this list-valued map. In case no mapping was stored for the\n      * specified key, an empty, unmodifiable list will be returned.\n      *\n-     * @param key the key to remove values from\n-     * @return the <code>List</code> of values removed, implementations\n-     *         typically return an empty, unmodifiable List for no mapping found\n+     * @param key  the key to remove values from\n+     * @return the {@code List} of values removed, implementations\n+     *   typically return an empty, unmodifiable {@code List} for no mapping found\n      * @throws UnsupportedOperationException if the map is unmodifiable\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n+    @Override\n     List<V> remove(Object key);\n \n }\n--- a/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/MultiValuedMap.java\n /**\n  * Defines a map that holds a collection of values against each key.\n  * <p>\n- * A <code>MultiValuedMap</code> is a Map with slightly different semantics:\n+ * A {@code MultiValuedMap} is a Map with slightly different semantics:\n  * <ul>\n- *   <li>Putting a value into the map will add the value to a Collection at that key.</li>\n- *   <li>Getting a value will return a Collection, holding all the values put to that key.</li>\n+ *   <li>Putting a value into the map will add the value to a {@link Collection} at that key.</li>\n+ *   <li>Getting a value will return a {@link Collection}, holding all the values put to that key.</li>\n  * </ul>\n  * <p>\n  * For example:\n \n     /**\n      * Returns {@code true} if this map contains a mapping for the specified\n-     * key. More formally, returns {@code true} if and only if this map\n-     * contains a mapping for a key {@code k} such that\n-     * {@code (key==null ? k==null : key.equals(k))}. (There can be at most one\n-     * such mapping.)\n-     *\n-     * @param key key whose presence in this map is to be tested\n-     * @return {@code true} if this map contains a mapping for the specified key\n+     * key. More formally, returns {@code true} if and only if this map contains\n+     * a mapping for a key {@code k} such that {@code (key==null ? k==null : key.equals(k))}.\n+     * (There can be at most one such mapping.)\n+     *\n+     * @param key  key whose presence in this map is to be tested\n+     * @return true if this map contains a mapping for the specified key\n      * @throws ClassCastException if the key is of an inappropriate type for this map (optional)\n      * @throws NullPointerException if the specified key is null and this map\n-     *        does not permit null keys (optional)\n+     *   does not permit null keys (optional)\n      */\n     boolean containsKey(Object key);\n \n     /**\n      * Checks whether the map contains at least one mapping for the specified value.\n      *\n-     * @param value the value to search for\n+     * @param value  the value to search for\n      * @return true if the map contains the value\n      * @throws ClassCastException if the type of the specified value is not compatible\n-     *        with the used collection (optional)\n+     *   with the used collection (optional)\n      * @throws NullPointerException if the value is null and null values are not supported\n-     *        by the used collection types (optional)\n+     *   by the used collection types (optional)\n      */\n     boolean containsValue(Object value);\n \n     /**\n      * Checks whether the map contains a mapping for the specified key and value.\n      *\n-     * @param key the key to search for\n-     * @param value the value to search for\n+     * @param key  the key to search for\n+     * @param value  the value to search for\n      * @return true if the map contains the value\n      */\n     boolean containsMapping(Object key, Object value);\n \n     /**\n-     * Returns a view collection of the values associated with the specified\n-     * key.\n-     * <p>\n-     * This method will return an <b>empty</b> collection if\n-     * {@link #containsKey(Object)} returns {@code false}. Changes to the\n-     * returned collection will update the underlying {@code MultiValuedMap} and\n-     * vice-versa.\n-     *\n-     * @param key the key to retrieve\n-     * @return the <code>Collection</code> of values, implementations should\n-     *         return an empty collection for no mapping\n+     * Returns a view collection of the values associated with the specified key.\n+     * <p>\n+     * This method will return an <b>empty</b> collection if {@link #containsKey(Object)}\n+     * returns {@code false}. Changes to the returned collection will update the underlying\n+     * {@code MultiValuedMap} and vice-versa.\n+     *\n+     * @param key  the key to retrieve\n+     * @return the {@code Collection} of values, implementations should\n+     *   return an empty collection for no mapping\n      * @throws ClassCastException if the key is of an invalid type (optional)\n      * @throws NullPointerException if the key is null and null keys are invalid (optional)\n      */\n     /**\n      * Adds a key-value mapping to this multi-valued map.\n      * <p>\n-     * Unlike a normal <code>Map</code> the previous value is not replaced.\n+     * Unlike a normal {@code Map} the previous value is not replaced.\n      * Instead the new value is added to the collection stored against the key.\n      * Depending on the collection type used, duplicate key-value mappings may\n      * be allowed.\n      * The method will return {@code true} if the size of the multi-valued map\n      * has been increased because of this operation.\n      *\n-     * @param key the key to store against\n-     * @param value the value to add to the collection at the key\n-     * @return {@code true} if the map changed as a result of this put operation, or\n-     *        {@code false} if the map already contained the key-value mapping and the\n-     *        collection type does not allow duplicate values, e.g. when using a Set\n+     * @param key  the key to store against\n+     * @param value  the value to add to the collection at the key\n+     * @return true if the map changed as a result of this put operation, or false\n+     *   if the map already contained the key-value mapping and the collection\n+     *   type does not allow duplicate values, e.g. when using a Set\n      * @throws UnsupportedOperationException if the put operation is not supported by\n-     *        this multi-valued map, e.g. if it is unmodifiable\n+     *   this multi-valued map, e.g. if it is unmodifiable\n      * @throws ClassCastException if the key or value is of an invalid type (optional)\n      * @throws NullPointerException if the key or value is null and null is invalid (optional)\n      * @throws IllegalArgumentException if some aspect of the specified key or value prevents\n-     *        it from being stored in this multi-valued map\n+     *   it from being stored in this multi-valued map\n      */\n     boolean put(K key, V value);\n \n     /**\n      * Adds a mapping to the specified key for all values contained in the given Iterable.\n      *\n-     * @param key the key to store against\n-     * @param values the values to add to the collection at the key, null ignored\n-     * @return {@code true} if the map changed as a result of this operation\n+     * @param key  the key to store against\n+     * @param values  the values to add to the collection at the key, may not be null\n+     * @return true if the map changed as a result of this operation\n+     * @throws NullPointerException if the specified iterable is null, or if this map\n+     *   does not permit null keys or values, and the specified key or values contain\n+     *   null (optional)\n      */\n     boolean putAll(K key, Iterable<? extends V> values);\n \n     /**\n-     * Copies all mappings from the specified map to this multi-valued map (optional operation).\n+     * Copies all mappings from the specified map to this multi-valued map\n+     * (optional operation).\n      * <p>\n      * The effect of this call is equivalent to that of calling\n      * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n      * The behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n-     * @param m mappings to be stored in this map\n+     * @param map  mappings to be stored in this map, may not be null\n      * @throws UnsupportedOperationException if the {@code putAll} operation is\n-     *        not supported by this map\n+     *   not supported by this map\n      * @throws ClassCastException if the class of a key or value in the\n-     *        specified map prevents it from being stored in this map (optional)\n+     *   specified map prevents it from being stored in this map (optional)\n      * @throws NullPointerException if the specified map is null, or if this map\n-     *        does not permit null keys or values, and the specified map\n-     *        contains null keys or values (optional)\n+     *   does not permit null keys or values, and the specified map\n+     *   contains null keys or values (optional)\n      * @throws IllegalArgumentException if some property of a key or value in\n-     *        the specified map prevents it from being stored in this map\n-     */\n-    void putAll(Map<? extends K, ? extends V> m);\n-\n-    /**\n-     * Copies all mappings from the specified map to this multi-valued map (optional operation).\n-     * <p>\n-     * The effect of this call is equivalent to that of\n-     * calling {@link #put(Object,Object) put(k, v)} on this map once for each\n+     *   the specified map prevents it from being stored in this map\n+     */\n+    void putAll(Map<? extends K, ? extends V> map);\n+\n+    /**\n+     * Copies all mappings from the specified map to this multi-valued map\n+     * (optional operation).\n+     * <p>\n+     * The effect of this call is equivalent to that of calling\n+     * {@link #put(Object,Object) put(k, v)} on this map once for each\n      * mapping from key {@code k} to value {@code v} in the specified map.\n      * <p>\n      * The behavior of this operation is undefined if the specified map is modified\n      * while the operation is in progress.\n      *\n-     * @param m mappings to be stored in this map\n+     * @param map  mappings to be stored in this map, may not be null\n      * @throws UnsupportedOperationException if the {@code putAll} operation is\n-     *        not supported by this map\n+     *   not supported by this map\n      * @throws ClassCastException if the class of a key or value in the\n-     *        specified map prevents it from being stored in this map (optional)\n+     *   specified map prevents it from being stored in this map (optional)\n      * @throws NullPointerException if the specified map is null, or if this map\n-     *        does not permit null keys or values, and the specified map\n-     *        contains null keys or values (optional)\n+     *   does not permit null keys or values, and the specified map\n+     *   contains null keys or values (optional)\n      * @throws IllegalArgumentException if some property of a key or value in\n-     *        the specified map prevents it from being stored in this map\n-     */\n-    void putAll(MultiValuedMap<? extends K, ? extends V> m);\n+     *   the specified map prevents it from being stored in this map\n+     */\n+    void putAll(MultiValuedMap<? extends K, ? extends V> map);\n \n     /**\n      * Removes all values associated with the specified key.\n      * to this multi-valued map. In case no mapping was stored for the specified\n      * key, an empty, unmodifiable collection will be returned.\n      *\n-     * @param key the key to remove values from\n+     * @param key  the key to remove values from\n      * @return the values that were removed\n      * @throws UnsupportedOperationException if the map is unmodifiable\n      * @throws ClassCastException if the key is of an invalid type (optional)\n      * If the last value for a key is removed, implementations typically return\n      * an empty collection from a subsequent <code>get(Object)</code>.\n      *\n-     * @param key the key to remove from\n-     * @param item the item to remove\n-     * @return {@code true} if the mapping was removed, {@code false} otherwise\n+     * @param key  the key to remove from\n+     * @param item  the item to remove\n+     * @return true if the mapping was removed, false otherwise\n      * @throws UnsupportedOperationException if the map is unmodifiable\n      * @throws ClassCastException if the key or value is of an invalid type (optional)\n      * @throws NullPointerException if the key or value is null and null is invalid (optional)\n     Collection<Entry<K, V>> entries();\n \n     /**\n-     * Returns a {@link Bag} view of the keys contained in this multi-valued map.\n-     * <p>\n-     * The {@link Bag#getCount(Object)} method of the returned bag will give the\n-     * same result a calling {@code get(Object).size()} for the same key.\n-     * <p>\n-     * This bag is backed by the map, so any changes in the map are reflected in the bag.\n-     *\n-     * @return a bag view of the keys contained in this map\n-     */\n-    Bag<K> keys();\n+     * Returns a {@link MultiSet} view of the keys contained in this multi-valued map.\n+     * <p>\n+     * The {@link MultiSet#getCount(Object)} method of the returned multiset will give\n+     * the same result a calling {@code get(Object).size()} for the same key.\n+     * <p>\n+     * This multiset is backed by the map, so any changes in the map are reflected in\n+     * the multiset.\n+     *\n+     * @return a multiset view of the keys contained in this map\n+     */\n+    MultiSet<K> keys();\n \n     /**\n      * Returns a {@link Set} view of the keys contained in this multi-valued map.\n      * Implementations typically return a collection containing the combination\n      * of values from all keys.\n      *\n-     * @return a collection view of the values contained in this map\n+     * @return a collection view of the values contained in this multi-valued map\n      */\n     Collection<V> values();\n \n      * Returns a {@link Map} view of this MultiValuedMap with a Collection as\n      * its value. The Collection holds all the values mapped to that key.\n      *\n-     * @return a Map view of the mappings in this MultiValuedMap\n+     * @return a map view of the mappings in this multi-valued map\n      */\n     Map<K, Collection<V>> asMap();\n \n--- a/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/SetValuedMap.java\n /**\n  * Defines a map that holds a set of values against each key.\n  * <p>\n- * A <code>SetValuedMap</code> is a Map with slightly different semantics:\n+ * A {@code SetValuedMap} is a Map with slightly different semantics:\n  * <ul>\n- * <li>Putting a value into the map will add the value to a <code>Set</code> at\n- * that key.</li>\n- * <li>Getting a value will return a <code>Set</code>, holding all the values\n- * put to that key.</li>\n+ *   <li>Putting a value into the map will add the value to a {@link Set} at that key.</li>\n+ *   <li>Getting a value will return a {@link Set}, holding all the values put to that key.</li>\n  * </ul>\n  *\n  * @since 4.1\n     /**\n      * Gets the set of values associated with the specified key.\n      * <p>\n-     * Implementations typically return an empty <code>Set</code> if no values\n+     * Implementations typically return an empty {@code Set} if no values\n      * have been mapped to the key.\n      * <p>\n      *\n      * @param key the key to retrieve\n-     * @return the <code>Set</code> of values, implementations should return an\n-     *         empty Set for no mapping\n+     * @return the {@code Set} of values, implementations should return an\n+     *   empty {@code Set} for no mapping\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n+    @Override\n     Set<V> get(Object key);\n \n     /**\n      * specified key, an empty, unmodifiable set will be returned.\n      *\n      * @param key the key to remove values from\n-     * @return the <code>Set</code> of values removed, implementations should\n-     *         return <code>null</code> for no mapping found, but may return an\n-     *         empty collection\n+     * @return the {@code Set} of values removed, implementations should\n+     *   return null for no mapping found, but may return an empty collection\n      * @throws UnsupportedOperationException if the map is unmodifiable\n      * @throws ClassCastException if the key is of an invalid type\n      * @throws NullPointerException if the key is null and null keys are invalid\n      */\n+    @Override\n     Set<V> remove(Object key);\n }\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java\n import java.util.Map.Entry;\n import java.util.Set;\n \n-import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.Factory;\n import org.apache.commons.collections4.IteratorUtils;\n import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.MultiSet;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Transformer;\n-import org.apache.commons.collections4.bag.HashBag;\n import org.apache.commons.collections4.functors.InstantiateFactory;\n import org.apache.commons.collections4.iterators.EmptyMapIterator;\n import org.apache.commons.collections4.iterators.IteratorChain;\n     /** The EntryValues view */\n     private transient EntryValues entryValuesView;\n \n-    /** The KeyBag view */\n-    private transient KeysBag keysBagView;\n+    /** The KeyMultiSet view */\n+    private transient KeysMultiSet keysMultiSetView;\n \n     /** The map used to store the data */\n     private final Map<K, Collection<V>> map;\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public boolean containsKey(Object key) {\n         return getMap().containsKey(key);\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public boolean containsValue(final Object value) {\n         final Set<Map.Entry<K, Collection<V>>> pairs = getMap().entrySet();\n         if (pairs != null) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public boolean containsMapping(Object key, Object value) {\n         final Collection<V> col = getMap().get(key);\n         if (col == null) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Collection<Entry<K, V>> entries() {\n         return entryValuesView != null ? entryValuesView : (entryValuesView = new EntryValues());\n     }\n      *         <code>Collection</code> for no mapping\n      * @throws ClassCastException if the key is of an invalid type\n      */\n+    @Override\n     public Collection<V> get(Object key) {\n         return new WrappedCollection(key);\n     }\n      *         empty, unmodifiable collection for no mapping found.\n      * @throws ClassCastException if the key is of an invalid type\n      */\n+    @Override\n     public Collection<V> remove(Object key) {\n         return CollectionUtils.emptyIfNull(getMap().remove(key));\n     }\n      * @param item the item to remove\n      * @return {@code true} if the mapping was removed, {@code false} otherwise\n      */\n+    @Override\n     public boolean removeMapping(K key, V item) {\n         boolean result = false;\n         final Collection<V> col = getMap().get(key);\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public boolean isEmpty() {\n         return getMap().isEmpty();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Set<K> keySet() {\n         return getMap().keySet();\n     }\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public int size() {\n         int size = 0;\n         for (Collection<V> col : getMap().values()) {\n      *\n      * @return a collection view of the values contained in this map\n      */\n+    @Override\n     public Collection<V> values() {\n         final Collection<V> vs = valuesView;\n         return vs != null ? vs : (valuesView = new Values());\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public void clear() {\n         getMap().clear();\n     }\n      * @param value the value to add to the collection at the key\n      * @return the value added if the map changed and null if the map did not change\n      */\n+    @Override\n     public boolean put(K key, V value) {\n         boolean result = false;\n         Collection<V> coll = getMap().get(key);\n      *\n      * @param map mappings to be stored in this map\n      */\n+    @Override\n     public void putAll(final Map<? extends K, ? extends V> map) {\n         if (map != null) {\n             for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n-                put((K) entry.getKey(), (V) entry.getValue());\n+                put(entry.getKey(), entry.getValue());\n             }\n         }\n     }\n      *\n      * @param map mappings to be stored in this map\n      */\n-    @SuppressWarnings(\"unchecked\")\n+    @Override\n     public void putAll(MultiValuedMap<? extends K, ? extends V> map) {\n         if (map != null) {\n             for (final K key : map.keySet()) {\n-                putAll(key, (Collection<V>) map.get(key));\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Returns a {@link Bag} view of the key mapping contained in this map.\n+                putAll(key, map.get(key));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a {@link MultiSet} view of the key mapping contained in this map.\n      * <p>\n-     * Returns a Bag of keys with its values count as the count of the Bag. This\n-     * bag is backed by the map, so any changes in the map is reflected here.\n-     * Any method which modifies this bag like {@code add}, {@code remove},\n-     * {@code Iterator.remove} etc throws\n-     * <code>UnsupportedOperationException</code>\n+     * Returns a MultiSet of keys with its values count as the count of the MultiSet.\n+     * This multiset is backed by the map, so any changes in the map is reflected here.\n+     * Any method which modifies this multiset like {@code add}, {@code remove},\n+     * {@link Iterator#remove()} etc throws {@code UnsupportedOperationException}.\n      *\n      * @return a bag view of the key mapping contained in this map\n      */\n-    public Bag<K> keys() {\n-        return keysBagView != null ? keysBagView : (keysBagView = new KeysBag());\n+    @Override\n+    public MultiSet<K> keys() {\n+        return keysMultiSetView != null ? keysMultiSetView\n+                                        : (keysMultiSetView = new KeysMultiSet());\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public Map<K, Collection<V>> asMap() {\n         return getMap();\n     }\n      * Adds Iterable values to the collection associated with the specified key.\n      *\n      * @param key the key to store against\n-     * @param values the values to add to the collection at the key, null\n-     *        ignored\n+     * @param values the values to add to the collection at the key, may not be null\n      * @return true if this map changed\n-     */\n+     * @throws NullPointerException if values is null\n+     */\n+    @Override\n     public boolean putAll(final K key, final Iterable<? extends V> values) {\n-        if (values == null || values.iterator() == null || !values.iterator().hasNext()) {\n+        if (values == null) {\n+            throw new NullPointerException(\"Values must not be null.\");\n+        }\n+\n+        Iterator<? extends V> it = values.iterator();\n+        if (!it.hasNext()) {\n             return false;\n         }\n-        Iterator<? extends V> it = values.iterator();\n         boolean result = false;\n         Collection<V> coll = getMap().get(key);\n         if (coll == null) {\n     /**\n      * {@inheritDoc}\n      */\n+    @Override\n     public MapIterator<K, V> mapIterator() {\n         if (size() == 0) {\n             return EmptyMapIterator.<K, V>emptyMapIterator();\n             return getMap().get(key);\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public boolean add(V value) {\n             final Collection<V> col = getMapping();\n             return col.add(value);\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public boolean addAll(Collection<? extends V> c) {\n             final Collection<V> col = getMapping();\n             return col.addAll(c);\n         }\n \n+        @Override\n         public void clear() {\n             final Collection<V> col = getMapping();\n             if (col != null) {\n             }\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public Iterator<V> iterator() {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n-                return (Iterator<V>) IteratorUtils.EMPTY_ITERATOR;\n+                return IteratorUtils.EMPTY_ITERATOR;\n             }\n             return new ValuesIterator(key);\n         }\n \n+        @Override\n         public int size() {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return col.size();\n         }\n \n+        @Override\n         public boolean contains(Object o) {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return col.contains(o);\n         }\n \n+        @Override\n         public boolean containsAll(Collection<?> o) {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return col.containsAll(o);\n         }\n \n+        @Override\n         public boolean isEmpty() {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return col.isEmpty();\n         }\n \n+        @Override\n         public boolean remove(Object item) {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return result;\n         }\n \n+        @Override\n         public boolean removeAll(Collection<?> c) {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return result;\n         }\n \n+        @Override\n         public boolean retainAll(Collection<?> c) {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return result;\n         }\n \n+        @Override\n         public Object[] toArray() {\n             final Collection<V> col = getMapping();\n             if (col == null) {\n             return col.toArray();\n         }\n \n+        @Override\n         @SuppressWarnings(\"unchecked\")\n         public <T> T[] toArray(T[] a) {\n             final Collection<V> col = getMapping();\n     }\n \n     /**\n-     * Inner class that provides a Bag<K> keys view\n-     */\n-    private class KeysBag implements Bag<K> {\n-\n+     * Inner class that provides a MultiSet<K> keys view\n+     */\n+    private class KeysMultiSet implements MultiSet<K> {\n+\n+        @Override\n         public boolean addAll(Collection<? extends K> c) {\n             throw new UnsupportedOperationException();\n         }\n \n+        @Override\n         public void clear() {\n             throw new UnsupportedOperationException();\n         }\n \n+        @Override\n         public boolean contains(Object o) {\n             return getMap().containsKey(o);\n         }\n \n+        @Override\n         public boolean isEmpty() {\n             return getMap().isEmpty();\n         }\n \n+        @Override\n         public Object[] toArray() {\n             final Object[] result = new Object[size()];\n             int i = 0;\n             return result;\n         }\n \n+        @Override\n         public <T> T[] toArray(T[] array) {\n             final int size = size();\n             if (array.length < size) {\n             return array;\n         }\n \n+        @Override\n         public int getCount(Object object) {\n             int count = 0;\n             Collection<V> col = AbstractMultiValuedMap.this.getMap().get(object);\n             return count;\n         }\n \n+        @Override\n+        public int setCount(K object, int count) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n         public boolean add(K object) {\n             throw new UnsupportedOperationException();\n         }\n \n-        public boolean add(K object, int nCopies) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n+        @Override\n+        public int add(K object, int nCopies) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n         public boolean remove(Object object) {\n             throw new UnsupportedOperationException();\n         }\n \n-        public boolean remove(Object object, int nCopies) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n+        @Override\n+        public int remove(Object object, int nCopies) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n         public Set<K> uniqueSet() {\n             return UnmodifiableSet.<K>unmodifiableSet(keySet());\n         }\n \n+        @Override\n+        public Set<MultiSet.Entry<K>> entrySet() {\n+            // TODO: implement\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n         public int size() {\n             return AbstractMultiValuedMap.this.size();\n         }\n \n+        @Override\n         public boolean containsAll(Collection<?> coll) {\n-            if (coll instanceof Bag) {\n-                return containsAll((Bag<?>) coll);\n-            }\n-            return containsAll(new HashBag<Object>(coll));\n-        }\n-\n-        private boolean containsAll(final Bag<?> other) {\n-            final Iterator<?> it = other.uniqueSet().iterator();\n-            while (it.hasNext()) {\n-                final Object current = it.next();\n-                if (getCount(current) < other.getCount(current)) {\n+            final Iterator<?> e = coll.iterator();\n+            while (e.hasNext()) {\n+                if(!contains(e.next())) {\n                     return false;\n                 }\n             }\n             return true;\n         }\n \n+        @Override\n         public boolean removeAll(Collection<?> coll) {\n             throw new UnsupportedOperationException();\n         }\n \n+        @Override\n         public boolean retainAll(Collection<?> coll) {\n             throw new UnsupportedOperationException();\n         }\n \n+        @Override\n         public Iterator<K> iterator() {\n             return new LazyIteratorChain<K>() {\n \n                     final Iterator<V> colIterator = getMap().get(key).iterator();\n                     Iterator<K> nextIt = new Iterator<K>() {\n \n+                        @Override\n                         public boolean hasNext() {\n                             return colIterator.hasNext();\n                         }\n \n+                        @Override\n                         public K next() {\n                             colIterator.next();// Increment the iterator\n                             // The earlier statement would throw\n                             return key;\n                         }\n \n+                        @Override\n                         public void remove() {\n                             throw new UnsupportedOperationException();\n                         }\n                     final K key = keyIterator.next();\n                     final Transformer<V, Entry<K, V>> entryTransformer = new Transformer<V, Entry<K, V>>() {\n \n+                        @Override\n                         public Entry<K, V> transform(final V input) {\n                             return new MultiValuedMapEntry(key, input);\n                         }\n             this.it = AbstractMultiValuedMap.this.entries().iterator();\n         }\n \n+        @Override\n         public boolean hasNext() {\n             return it.hasNext();\n         }\n \n+        @Override\n         public K next() {\n             current = it.next();\n             return current.getKey();\n         }\n \n+        @Override\n         public K getKey() {\n             if (current == null) {\n                 throw new IllegalStateException();\n             return current.getKey();\n         }\n \n+        @Override\n         public V getValue() {\n             if (current == null) {\n                 throw new IllegalStateException();\n             return current.getValue();\n         }\n \n+        @Override\n         public void remove() {\n             it.remove();\n         }\n \n+        @Override\n         public V setValue(V value) {\n             if (current == null) {\n                 throw new IllegalStateException();\n             this.iterator = values.iterator();\n         }\n \n+        @Override\n         public void remove() {\n             iterator.remove();\n             if (values.isEmpty()) {\n             }\n         }\n \n+        @Override\n         public boolean hasNext() {\n             return iterator.hasNext();\n         }\n \n+        @Override\n         public V next() {\n             return iterator.next();\n         }\n--- a/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java\n import java.util.Map.Entry;\n import java.util.Set;\n \n-import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.MultiSet;\n import org.apache.commons.collections4.MultiValuedMap;\n \n /**\n         return map;\n     }\n \n+    @Override\n     public int size() {\n         return decorated().size();\n     }\n \n+    @Override\n     public boolean isEmpty() {\n         return decorated().isEmpty();\n     }\n \n+    @Override\n     public boolean containsKey(Object key) {\n         return decorated().containsKey(key);\n     }\n \n+    @Override\n     public boolean containsValue(Object value) {\n         return decorated().containsValue(value);\n     }\n \n+    @Override\n     public boolean containsMapping(Object key, Object value) {\n         return decorated().containsMapping(key, value);\n     }\n \n+    @Override\n     public Collection<V> get(Object key) {\n         return decorated().get(key);\n     }\n \n+    @Override\n     public Collection<V> remove(Object key) {\n         return decorated().remove(key);\n     }\n \n+    @Override\n     public boolean removeMapping(K key, V item) {\n         return decorated().removeMapping(key, item);\n     }\n \n+    @Override\n     public void clear() {\n         decorated().clear();\n     }\n \n+    @Override\n     public boolean put(K key, V value) {\n         return decorated().put(key, value);\n     }\n \n+    @Override\n     public Set<K> keySet() {\n         return decorated().keySet();\n     }\n \n+    @Override\n     public Collection<Entry<K, V>> entries() {\n         return decorated().entries();\n     }\n \n-    public Bag<K> keys() {\n+    @Override\n+    public MultiSet<K> keys() {\n         return decorated().keys();\n     }\n \n+    @Override\n     public Collection<V> values() {\n         return decorated().values();\n     }\n \n+    @Override\n     public Map<K, Collection<V>> asMap() {\n         return decorated().asMap();\n     }\n \n+    @Override\n     public boolean putAll(K key, Iterable<? extends V> values) {\n         return decorated().putAll(key, values);\n     }\n \n+    @Override\n     public void putAll(Map<? extends K, ? extends V> m) {\n         decorated().putAll(m);\n     }\n \n+    @Override\n     public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n         decorated().putAll(m);\n     }\n \n+    @Override\n     public MapIterator<K, V> mapIterator() {\n         return decorated().mapIterator();\n     }\n--- a/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/TransformedMultiValuedMap.java\n     /** Serialization Version */\n     private static final long serialVersionUID = -1254147899086470720L;\n \n+    /** The key transformer */\n     private final Transformer<? super K, ? extends K> keyTransformer;\n \n+    /** The value transformer */\n     private final Transformer<? super V, ? extends V> valueTransformer;\n \n     /**\n      * NOT transformed. Contrast this with\n      * {@link #transformedMap(MultiValuedMap, Transformer, Transformer)}.\n      *\n-     * @param <K> the key type\n-     * @param <V> the value type\n-     * @param map the MultiValuedMap to decorate, must not be null\n-     * @param keyTransformer the transformer to use for key conversion, null\n-     *        means no transformation\n-     * @param valueTransformer the transformer to use for value conversion, null\n-     *        means no transformation\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the MultiValuedMap to decorate, may not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n+     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n      * @return a new transformed MultiValuedMap\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     public static <K, V> TransformedMultiValuedMap<K, V> transformingMap(final MultiValuedMap<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n      * be transformed by this method. Contrast this with\n      * {@link #transformingMap(MultiValuedMap, Transformer, Transformer)}.\n      *\n-     * @param <K> the key type\n-     * @param <V> the value type\n-     * @param map the MultiValuedMap to decorate, must not be null\n-     * @param keyTransformer the transformer to use for key conversion, null\n-     *        means no transformation\n-     * @param valueTransformer the transformer to use for value conversion, null\n-     *        means no transformation\n+     * @param <K>  the key type\n+     * @param <V>  the value type\n+     * @param map  the MultiValuedMap to decorate, may not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n+     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n      * @return a new transformed MultiValuedMap\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     public static <K, V> TransformedMultiValuedMap<K, V> transformedMap(final MultiValuedMap<K, V> map,\n             final Transformer<? super K, ? extends K> keyTransformer,\n      * If there are any elements already in the collection being decorated, they\n      * are NOT transformed.\n      *\n-     * @param map the MultiValuedMap to decorate, must not be null\n-     * @param keyTransformer the transformer to use for key conversion, null\n-     *        means no conversion\n-     * @param valueTransformer the transformer to use for value conversion, null\n-     *        means no conversion\n-     * @throws IllegalArgumentException if map is null\n+     * @param map  the MultiValuedMap to decorate, may not be null\n+     * @param keyTransformer  the transformer to use for key conversion, null means no conversion\n+     * @param valueTransformer  the transformer to use for value conversion, null means no conversion\n+     * @throws NullPointerException if map is null\n      */\n     protected TransformedMultiValuedMap(MultiValuedMap<K, V> map,\n             Transformer<? super K, ? extends K> keyTransformer, Transformer<? super V, ? extends V> valueTransformer) {\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n      *\n-     * @param object the object to transform\n+     * @param object  the object to transform\n      * @return the transformed object\n      */\n     protected K transformKey(final K object) {\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n      *\n-     * @param object the object to transform\n+     * @param object  the object to transform\n      * @return the transformed object\n      */\n     protected V transformValue(final V object) {\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n      *\n-     * @param map the map to transform\n+     * @param map  the map to transform\n      * @return the transformed object\n      */\n     @SuppressWarnings(\"unchecked\")\n      * <p>\n      * The transformer itself may throw an exception if necessary.\n      *\n-     * @param map the MultiValuedMap to transform\n+     * @param map  the MultiValuedMap to transform\n      * @return the transformed object\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected MultiValuedMap<K, V> transformMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n+    protected MultiValuedMap<K, V> transformMultiValuedMap(\n+            final MultiValuedMap<? extends K, ? extends V> map) {\n         if (map.isEmpty()) {\n             return (MultiValuedMap<K, V>) map;\n         }\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public boolean putAll(K key, Iterable<? extends V> values) {\n-        if (values == null || values.iterator() == null || !values.iterator().hasNext()) {\n+        if (values == null) {\n+            throw new NullPointerException(\"Values must not be null.\");\n+        }\n+\n+        Iterator<V> it = (Iterator<V>) values.iterator();\n+        if (!it.hasNext()) {\n             return false;\n         }\n         K transformedKey = transformKey(key);\n         List<V> transformedValues = new LinkedList<V>();\n-        Iterator<V> it = (Iterator<V>) values.iterator();\n         while (it.hasNext()) {\n             transformedValues.add(transformValue(it.next()));\n         }\n \n     @Override\n     public void putAll(Map<? extends K, ? extends V> m) {\n-        if (m == null) {\n-            return;\n-        }\n         decorated().putAll(transformMap(m));\n     }\n \n     @Override\n     public void putAll(MultiValuedMap<? extends K, ? extends V> m) {\n-        if (m == null) {\n-            return;\n-        }\n         decorated().putAll(transformMultiValuedMap(m));\n     }\n \n--- a/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMap.java\n import java.util.Map.Entry;\n import java.util.Set;\n \n-import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.MultiSet;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Unmodifiable;\n-import org.apache.commons.collections4.bag.UnmodifiableBag;\n import org.apache.commons.collections4.collection.UnmodifiableCollection;\n import org.apache.commons.collections4.iterators.UnmodifiableMapIterator;\n import org.apache.commons.collections4.map.UnmodifiableMap;\n+import org.apache.commons.collections4.multiset.UnmodifiableMultiSet;\n import org.apache.commons.collections4.set.UnmodifiableSet;\n \n /**\n      * <p>\n      * If the map passed in is already unmodifiable, it is returned.\n      *\n-     * @param <K> the type of key elements\n-     * @param <V> the type of value elements\n-     * @param map the map to decorate, must not be null\n+     * @param <K>  the type of key elements\n+     * @param <V>  the type of value elements\n+     * @param map  the map to decorate, may not be null\n      * @return an unmodifiable MultiValuedMap\n-     * @throws IllegalArgumentException if map is null\n+     * @throws NullPointerException if map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     public static <K, V> UnmodifiableMultiValuedMap<K, V> unmodifiableMultiValuedMap(\n     /**\n      * Constructor that wraps (not copies).\n      *\n-     * @param map the MultiValuedMap to decorate, must not be null\n-     * @throws IllegalArgumentException if the map is null\n+     * @param map  the MultiValuedMap to decorate, may not be null\n+     * @throws NullPointerException if the map is null\n      */\n     @SuppressWarnings(\"unchecked\")\n     private UnmodifiableMultiValuedMap(final MultiValuedMap<? extends K, ? extends V> map) {\n \n     @Override\n     public Set<K> keySet() {\n-        return UnmodifiableSet.<K>unmodifiableSet(decorated().keySet());\n+        return UnmodifiableSet.unmodifiableSet(decorated().keySet());\n     }\n \n     @Override\n     public Collection<Entry<K, V>> entries() {\n-        return UnmodifiableCollection.<Entry<K, V>>unmodifiableCollection(decorated().entries());\n+        return UnmodifiableCollection.unmodifiableCollection(decorated().entries());\n     }\n \n     @Override\n-    public Bag<K> keys() {\n-        return UnmodifiableBag.<K>unmodifiableBag(decorated().keys());\n+    public MultiSet<K> keys() {\n+        return UnmodifiableMultiSet.unmodifiableMultiSet(decorated().keys());\n     }\n \n     @Override\n     public Collection<V> values() {\n-        return UnmodifiableCollection.<V>unmodifiableCollection(decorated().values());\n+        return UnmodifiableCollection.unmodifiableCollection(decorated().values());\n     }\n \n     @Override\n--- a/src/main/java/org/apache/commons/collections4/multimap/package-info.java\n+++ b/src/main/java/org/apache/commons/collections4/multimap/package-info.java\n  * The following implementations are provided in the package:\n  * <ul>\n  *   <li>MultiValuedHashMap - implementation that uses a HashMap to store the data\n+ *   <li>ListValuedHashMap  - implementation of a ListValuedMap using a HashMap as data store\n+ *   <li>SetValuedHashMap   - implementation of a SetValuedMap using a HashMap as data store\n  * </ul>\n  * <p>\n  * The following decorators are provided in the package:\n--- a/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java\n import org.apache.commons.collections4.BulkTest;\n import org.apache.commons.collections4.CollectionUtils;\n import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.MultiSet;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.bag.AbstractBagTest;\n-import org.apache.commons.collections4.bag.CollectionBag;\n import org.apache.commons.collections4.bag.HashBag;\n import org.apache.commons.collections4.collection.AbstractCollectionTest;\n import org.apache.commons.collections4.map.AbstractMapTest;\n+import org.apache.commons.collections4.multiset.AbstractMultiSetTest;\n import org.apache.commons.collections4.set.AbstractSetTest;\n \n /**\n     @SuppressWarnings(\"unchecked\")\n     public void testContainsValue_Key() {\n         final MultiValuedMap<K, V> map = makeFullMap();\n-        assertEquals(true, map.containsMapping(\"one\", (V) \"uno\"));\n-        assertEquals(false, map.containsMapping(\"two\", (V) \"2\"));\n+        assertEquals(true, map.containsMapping(\"one\", \"uno\"));\n+        assertEquals(false, map.containsMapping(\"two\", \"2\"));\n         if (!isAddSupported()) {\n             return;\n         }\n         map.put((K) \"A\", (V) \"AA\");\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"AA\"));\n-        assertEquals(false, map.containsMapping(\"A\", (V) \"AB\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"AA\"));\n+        assertEquals(false, map.containsMapping(\"A\", \"AB\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n \n         assertEquals(true, map.putAll((K) \"A\", coll));\n         assertEquals(3, map.get(\"A\").size());\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n-\n-        assertEquals(false, map.putAll((K) \"A\", null));\n+        assertEquals(true, map.containsMapping(\"A\", \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n+\n+        try {\n+            map.putAll((K) \"A\", null);\n+            fail(\"expecting NullPointerException\");\n+        } catch (NullPointerException npe) {\n+            // expected\n+        }\n+\n         assertEquals(3, map.get(\"A\").size());\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n \n         assertEquals(false, map.putAll((K) \"A\", new ArrayList<V>()));\n         assertEquals(3, map.get(\"A\").size());\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n \n         coll = (Collection<V>) Arrays.asList(\"M\");\n         assertEquals(true, map.putAll((K) \"A\", coll));\n         assertEquals(4, map.get(\"A\").size());\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"X\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Y\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"Z\"));\n-        assertEquals(true, map.containsMapping(\"A\", (V) \"M\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"X\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Y\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"Z\"));\n+        assertEquals(true, map.containsMapping(\"A\", \"M\"));\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         //assertEquals(new MultiValuedHashMap<K, V>(), map);\n     }\n \n-    public void testKeysBag() {\n+    public void testKeysMultiSet() {\n         MultiValuedMap<K, V> map = makeFullMap();\n-        Bag<K> keyBag = map.keys();\n-        assertEquals(2, keyBag.getCount(\"one\"));\n-        assertEquals(2, keyBag.getCount(\"two\"));\n-        assertEquals(2, keyBag.getCount(\"three\"));\n-        assertEquals(6, keyBag.size());\n+        MultiSet<K> keyMultiSet = map.keys();\n+        assertEquals(2, keyMultiSet.getCount(\"one\"));\n+        assertEquals(2, keyMultiSet.getCount(\"two\"));\n+        assertEquals(2, keyMultiSet.getCount(\"three\"));\n+        assertEquals(6, keyMultiSet.size());\n     }\n \n     public void testKeysBagIterator() {\n     @SuppressWarnings(\"unchecked\")\n     public void testKeysBagContainsAll() {\n         MultiValuedMap<K, V> map = makeFullMap();\n-        Bag<K> keyBag = map.keys();\n+        MultiSet<K> keyMultiSet = map.keys();\n         Collection<K> col = (Collection<K>) Arrays.asList(\"one\", \"two\", \"three\", \"one\", \"two\", \"three\");\n-        assertTrue(keyBag.containsAll(col));\n+        assertTrue(keyMultiSet.containsAll(col));\n     }\n \n     public void testAsMapGet() {\n     }\n \n     public void testFullMapCompatibility() throws Exception {\n-        final MultiValuedMap<?, ?> map = (MultiValuedMap<?, ?>) makeFullMap();\n+        final MultiValuedMap<?, ?> map = makeFullMap();\n         final MultiValuedMap<?, ?> map2 =\n                 (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n         assertEquals(\"Map is the right size\", map.size(), map2.size());\n         return new TestMultiValuedMapKeys();\n     }\n \n-    public class TestMultiValuedMapKeys extends AbstractBagTest<K> {\n+    public class TestMultiValuedMapKeys extends AbstractMultiSetTest<K> {\n \n         public TestMultiValuedMapKeys() {\n             super(\"\");\n         }\n \n         @Override\n-        public Bag<K> makeObject() {\n+        public MultiSet<K> makeObject() {\n             return AbstractMultiValuedMapTest.this.makeObject().keys();\n         }\n \n         @Override\n-        public Bag<K> makeFullCollection() {\n+        public MultiSet<K> makeFullCollection() {\n             return AbstractMultiValuedMapTest.this.makeFullMap().keys();\n         }\n \n         @Override\n         public void resetFull() {\n             AbstractMultiValuedMapTest.this.resetFull();\n-            // wrapping with CollectionBag as otherwise the Collection tests\n-            // would fail\n-            setCollection(CollectionBag.<K>collectionBag(AbstractMultiValuedMapTest.this.getMap().keys()));\n+            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n         }\n \n         @Override\n         public void resetEmpty() {\n             AbstractMultiValuedMapTest.this.resetEmpty();\n-            setCollection(CollectionBag.<K>collectionBag(AbstractMultiValuedMapTest.this.getMap().keys()));\n+            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n             TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n         }\n \n--- a/src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java\n+++ b/src/test/java/org/apache/commons/collections4/multimap/UnmodifiableMultiValuedMapTest.java\n \n import junit.framework.Test;\n \n-import org.apache.commons.collections4.Bag;\n import org.apache.commons.collections4.BulkTest;\n import org.apache.commons.collections4.MapIterator;\n+import org.apache.commons.collections4.MultiSet;\n import org.apache.commons.collections4.MultiValuedMap;\n import org.apache.commons.collections4.Unmodifiable;\n \n         return BulkTest.makeSuite(UnmodifiableMultiValuedMapTest.class);\n     }\n     \n+    @Override\n     public boolean isAddSupported() {\n         return false;\n     }\n \n+    @Override\n     public boolean isRemoveSupported() {\n         return false;\n     }\n         return UnmodifiableMultiValuedMap.<K, V> unmodifiableMultiValuedMap(new MultiValuedHashMap<K, V>());\n     }\n \n+    @Override\n     protected MultiValuedMap<K, V> makeFullMap() {\n         final MultiValuedMap<K, V> map = new MultiValuedHashMap<K, V>();\n         addSampleMappings(map);\n     @SuppressWarnings(\"unchecked\")\n     public void testUnmodifiableKeys() {\n         resetFull();\n-        Bag<K> keys = getMap().keys();\n+        MultiSet<K> keys = getMap().keys();\n         try {\n             keys.add((K) \"four\");\n             fail();", "timestamp": 1434060428, "metainfo": ""}