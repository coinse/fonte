{"sha": "cfee37042c553c0c2ba2b509bd66cfa4f9edb958", "log": "Moving rest of easily shareable deserialize methods to shared base class", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         }\n         return bean;\n     }\n-    \n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        // First things first: id Object Id is used, most likely that's it\n-        if (_objectIdReader != null) {\n-            return deserializeFromObjectId(jp, ctxt);\n-        }\n-        \n-        /* Bit complicated if we have delegating creator; may need to use it,\n-         * or might not...\n-         */\n-        if (_delegateDeserializer != null) {\n-            if (!_valueInstantiator.canCreateFromString()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                if (_injectables != null) {\n-                    injectValues(ctxt, bean);\n-                }\n-                return bean;\n-            }\n-        }\n-        return _valueInstantiator.createFromString(ctxt, jp.getText());\n-    }\n-\n-    /**\n-     * Method called to deserialize POJO value from a JSON floating-point\n-     * number.\n-     */\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        switch (jp.getNumberType()) {\n-        case FLOAT: // no separate methods for taking float...\n-        case DOUBLE:\n-            if (_delegateDeserializer != null) {\n-                if (!_valueInstantiator.canCreateFromDouble()) {\n-                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                    if (_injectables != null) {\n-                        injectValues(ctxt, bean);\n-                    }\n-                    return bean;\n-                }\n-            }\n-            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n-        }\n-        // actually, could also be BigDecimal, so:\n-        if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n-    }\n-\n-    /**\n-     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n-     */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_delegateDeserializer != null) {\n-            if (!_valueInstantiator.canCreateFromBoolean()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                if (_injectables != null) {\n-                    injectValues(ctxt, bean);\n-                }\n-                return bean;\n-            }\n-        }\n-        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n-        return _valueInstantiator.createFromBoolean(ctxt, value);\n-    }\n-\n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_delegateDeserializer != null) {\n-            try {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                if (_injectables != null) {\n-                    injectValues(ctxt, bean);\n-                }\n-                return bean;\n-            } catch (Exception e) {\n-                wrapInstantiationProblem(e, ctxt);\n-            }\n-        }\n-        throw ctxt.mappingException(getBeanClass());\n-    }\n+\n     /**\n      * Method called to deserialize bean using \"property-based creator\":\n      * this means that a non-default constructor or factory method is\n                         bean = null; // never gets here\n                     }\n                     //  polymorphic?\n-\t\t    if (bean.getClass() != _beanType.getRawClass()) {\n-\t\t\treturn handlePolymorphic(jp, ctxt, bean, unknown);\n-\t\t    }\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                    }\n                     if (unknown != null) { // nope, just extra unknown stuff...\n                         bean = handleUnknownProperties(ctxt, bean, unknown);\n-\t\t    }\n-\t\t    // or just clean?\n+                    }\n+                    // or just clean?\n                     return deserialize(jp, ctxt, bean);\n                 }\n                 continue;\n         }\n         return bean;\n     }\n-    \n-    /**\n-     * Method called in cases where we may have polymorphic deserialization\n-     * case: that is, type of Creator-constructed bean is not the type\n-     * of deserializer itself. It should be a sub-class or implementation\n-     * class; either way, we may have more specific deserializer to use\n-     * for handling it.\n-     *\n-     * @param jp (optional) If not null, parser that has more properties to handle\n-     *   (in addition to buffered properties); if null, all properties are passed\n-     *   in buffer\n-     */\n-    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          \n-            Object bean, TokenBuffer unknownTokens)\n-        throws IOException, JsonProcessingException\n-    {  \n-        // First things first: maybe there is a more specific deserializer available?\n-        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n-        if (subDeser != null) {\n-            if (unknownTokens != null) {\n-                // need to add END_OBJECT marker first\n-                unknownTokens.writeEndObject();\n-                JsonParser p2 = unknownTokens.asParser();\n-                p2.nextToken(); // to get to first data field\n-                bean = subDeser.deserialize(p2, ctxt, bean);\n-            }\n-            // Original parser may also have some leftovers\n-            if (jp != null) {\n-                bean = subDeser.deserialize(jp, ctxt, bean);\n-            }\n-            return bean;\n-        }\n-        // nope; need to use this deserializer. Unknowns we've seen so far?\n-        if (unknownTokens != null) {\n-            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n-        }\n-        // and/or things left to process via main parser?\n-        if (jp != null) {\n-            bean = deserialize(jp, ctxt, bean);\n-        }\n-        return bean;\n-    }\n-    \n+\n     /*\n     /**********************************************************\n     /* Deserializing when we have to consider an active View\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n         }\n         throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n     }\n+\n+    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // First things first: id Object Id is used, most likely that's it\n+        if (_objectIdReader != null) {\n+            return deserializeFromObjectId(jp, ctxt);\n+        }\n+        \n+        /* Bit complicated if we have delegating creator; may need to use it,\n+         * or might not...\n+         */\n+        if (_delegateDeserializer != null) {\n+            if (!_valueInstantiator.canCreateFromString()) {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            }\n+        }\n+        return _valueInstantiator.createFromString(ctxt, jp.getText());\n+    }\n+\n+    /**\n+     * Method called to deserialize POJO value from a JSON floating-point\n+     * number.\n+     */\n+    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getNumberType()) {\n+        case FLOAT: // no separate methods for taking float...\n+        case DOUBLE:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromDouble()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n+        }\n+        // actually, could also be BigDecimal, so:\n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+    }\n+\n+    /**\n+     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n+     */\n+    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            if (!_valueInstantiator.canCreateFromBoolean()) {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            }\n+        }\n+        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        return _valueInstantiator.createFromBoolean(ctxt, value);\n+    }\n+\n+    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            try {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+            }\n+        }\n+        throw ctxt.mappingException(getBeanClass());\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n             }\n         }\n         return bean;\n-    }\n-    \n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        // First things first: id Object Id is used, most likely that's it\n-        if (_objectIdReader != null) {\n-            return deserializeFromObjectId(jp, ctxt);\n-        }\n-        \n-        /* Bit complicated if we have delegating creator; may need to use it,\n-         * or might not...\n-         */\n-        if (_delegateDeserializer != null) {\n-            if (!_valueInstantiator.canCreateFromString()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                if (_injectables != null) {\n-                    injectValues(ctxt, bean);\n-                }\n-                return bean;\n-            }\n-        }\n-        return _valueInstantiator.createFromString(ctxt, jp.getText());\n-    }\n-\n-    /**\n-     * Method called to deserialize POJO value from a JSON floating-point\n-     * number.\n-     */\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        switch (jp.getNumberType()) {\n-        case FLOAT: // no separate methods for taking float...\n-        case DOUBLE:\n-            if (_delegateDeserializer != null) {\n-                if (!_valueInstantiator.canCreateFromDouble()) {\n-                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                    if (_injectables != null) {\n-                        injectValues(ctxt, bean);\n-                    }\n-                    return bean;\n-                }\n-            }\n-            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n-        }\n-        // actually, could also be BigDecimal, so:\n-        if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n-    }\n-\n-    /**\n-     * Method called to deserialize POJO value from a JSON boolean value (true, false)\n-     */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_delegateDeserializer != null) {\n-            if (!_valueInstantiator.canCreateFromBoolean()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                if (_injectables != null) {\n-                    injectValues(ctxt, bean);\n-                }\n-                return bean;\n-            }\n-        }\n-        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n-        return _valueInstantiator.createFromBoolean(ctxt, value);\n-    }\n-\n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_delegateDeserializer != null) {\n-            try {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-                if (_injectables != null) {\n-                    injectValues(ctxt, bean);\n-                }\n-                return bean;\n-            } catch (Exception e) {\n-                wrapInstantiationProblem(e, ctxt);\n-            }\n-        }\n-        throw ctxt.mappingException(getBeanClass());\n     }\n \n     /**", "timestamp": 1353179900, "metainfo": ""}