{"sha": "eea889f6c98cbf01187a13001529e381a177e452", "log": "Start work on auto-detect support via ObjectReader", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.DataFormatDetector;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n      */\n     protected final InjectableValues _injectableValues;\n \n+    /**\n+     * Optional detector used for auto-detecting data format that byte-based\n+     * input uses.\n+     *<p>\n+     * NOTE: If defined non-null, <code>readValue()</code> methods that take\n+     * {@link Reader} or {@link String} input <b>will fail with exception</b>,\n+     * because format-detection only works on byte-sources. Also, if format\n+     * can not be detect reliably (as per detector settings),\n+     * a {@link JsonParseException} will be thrown).\n+     * \n+     * @since 2.1\n+     */\n+    protected final DataFormatDetector _dataFormatDetector;\n+    \n     /*\n     /**********************************************************\n     /* Caching\n         _unwrapRoot = config.useRootWrapping();\n \n         _rootDeserializer = _prefetchRootDeserializer(config, valueType);\n+        _dataFormatDetector = null;        \n     }\n     \n     /**\n      */\n     protected ObjectReader(ObjectReader base, DeserializationConfig config,\n             JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n-            FormatSchema schema, InjectableValues injectableValues)\n+            FormatSchema schema, InjectableValues injectableValues,\n+            DataFormatDetector dataFormatDetector)\n     {\n         _config = config;\n         _context = base._context;\n         _schema = schema;\n         _injectableValues = injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n+        _dataFormatDetector = dataFormatDetector;\n     }\n \n     /**\n         _schema = base._schema;\n         _injectableValues = base._injectableValues;\n         _unwrapRoot = config.useRootWrapping();\n+        _dataFormatDetector = base._dataFormatDetector;\n     }\n \n     /**\n         }\n         return new ObjectReader(this, _config,\n                 _valueType, _rootDeserializer, _valueToUpdate,\n-                _schema, injectableValues);\n+                _schema, injectableValues, _dataFormatDetector);\n     }\n \n     /**\n         if (_schema == schema) {\n             return this;\n         }\n-        return new ObjectReader(this, _config,\n-                _valueType, _rootDeserializer, _valueToUpdate,\n-                schema, _injectableValues);\n+        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+                schema, _injectableValues, _dataFormatDetector);\n     }\n     \n     /**\n         if (valueType != null && valueType.equals(_valueType)) return this;\n         JsonDeserializer<Object> rootDeser = _prefetchRootDeserializer(_config, valueType);\n         // type is stored here, no need to make a copy of config\n-        return new ObjectReader(this, _config,\n-                valueType, rootDeser, _valueToUpdate,\n-                _schema, _injectableValues);\n+        return new ObjectReader(this, _config, valueType, rootDeser, _valueToUpdate,\n+                _schema, _injectableValues, _dataFormatDetector);\n     }    \n \n     /**\n             t = _valueType;\n         }\n         return new ObjectReader(this, _config, t, _rootDeserializer, value,\n-                _schema, _injectableValues);\n+                _schema, _injectableValues, _dataFormatDetector);\n     }\n \n     /**\n         return _with(_config.with(defaultBase64));\n     }\n \n-    protected ObjectReader _with(DeserializationConfig newConfig) {\n-        if (newConfig == _config) return this;\n-        return new ObjectReader(this, newConfig);\n+    /**\n+     * Fluent factory method for constructing a reader that will try to\n+     * auto-detect underlying data format, using specified list of\n+     * {@link JsonFactory} instances, and default {@link DataFormatDetector} settings\n+     * (for customized {@link DataFormatDetector}, you can construct instance yourself).\n+     * to construct appropriate {@link JsonParser} for actual parsing.\n+     *<p>\n+     * NOTE: since format detection only works with byte sources, it is possible to\n+     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n+     * (enough) detected as one of specified types, an exception will be thrown.\n+     * \n+     * @param factories Data formats accepted, in decreasing order of priority (that is,\n+     *   matches checked in listed order, first match wins)\n+     * \n+     * @return Newly configured writer instance\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectReader withFormatDetection(JsonFactory... factories)\n+    {\n+        return withFormatDetection(new DataFormatDetector(factories));\n+    }\n+\n+    /**\n+     * Fluent factory method for constructing a reader that will try to\n+     * auto-detect underlying data format, using specified\n+     * {@link DataFormatDetector}.\n+     *<p>\n+     * NOTE: since format detection only works with byte sources, it is possible to\n+     * get a failure from some 'readValue()' methods. Also, if input can not be reliably\n+     * (enough) detected as one of specified types, an exception will be thrown.\n+     * \n+     * @param detector DataFormatDetector to use for detecting underlying format.\n+     * \n+     * @return Newly configured writer instance\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectReader withFormatDetection(DataFormatDetector detector)\n+    {\n+        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+                _schema, _injectableValues, detector);\n     }\n     \n     /*\n      * configuration of this reader, including expected result type.\n      * Value return is either newly constructed, or root value that\n      * was specified with {@link #withValueToUpdate(Object)}.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonParser jp)\n      * is specified with the call (instead of currently configured root type).\n      * Value return is either newly constructed, or root value that\n      * was specified with {@link #withValueToUpdate(Object)}.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n      * is specified with the call (instead of currently configured root type).\n      * Value return is either newly constructed, or root value that\n      * was specified with {@link #withValueToUpdate(Object)}.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n      * is specified with the call (instead of currently configured root type).\n      * Value return is either newly constructed, or root value that\n      * was specified with {@link #withValueToUpdate(Object)}.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n \n     /**\n      * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n      *<p>\n      * Note: if an object was specified with {@link #withValueToUpdate}, it\n      * will be ignored.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n      *<pre>\n      *   withType(valueType).readValues(jp);\n      *</pre>\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @Override\n     public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n      *<pre>\n      *   withType(valueTypeRef).readValues(jp);\n      *</pre>\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @Override\n     public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n      *<pre>\n      *   withType(valueType).readValues(jp);\n      *</pre>\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     @Override\n     public <T> Iterator<T> readValues(JsonParser jp, ResolvedType valueType)\n      *<pre>\n      *   withType(valueType).readValues(jp);\n      *</pre>\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n      */\n     public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)\n         throws IOException, JsonProcessingException {\n     /* Deserialization methods; others similar to what ObjectMapper has\n     /**********************************************************\n      */\n-\n+    \n     /**\n      * Method that binds content read from given input source,\n      * using configuration of this reader.\n     public <T> T readValue(InputStream src)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            return (T) _bindAndClose(_detect(src));\n+        }\n         return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n     }\n \n     public <T> T readValue(Reader src)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(src);\n+        }\n         return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n     }\n-\n+    \n     /**\n      * Method that binds content read from given JSON string,\n      * using configuration of this reader.\n     public <T> T readValue(String src)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(src);\n+        }\n         return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n     }\n \n     public <T> T readValue(byte[] src)\n         throws IOException, JsonProcessingException\n     {\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+        JsonParser p = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src) : _detect(src, 0, src.length);\n+        return (T) _bindAndClose(p);\n     }\n \n     /**\n     public <T> T readValue(byte[] src, int offset, int length)\n         throws IOException, JsonProcessingException\n     {\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src, offset, length));\n+        JsonParser p = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src, offset, length) : _detect(src, offset, length);\n+        return (T) _bindAndClose(p);\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(File src)\n         throws IOException, JsonProcessingException\n     {\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+        JsonParser p = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src) : _detect(src);\n+        return (T) _bindAndClose(p);\n     }\n \n     /**\n     public <T> T readValue(URL src)\n         throws IOException, JsonProcessingException\n     {\n-        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+        JsonParser p = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src) : _detect(src);\n+        return (T) _bindAndClose(p);\n     }\n \n     /**\n     public <T> T readValue(JsonNode src)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(src);\n+        }\n         return (T) _bindAndClose(treeAsTokens(src));\n     }\n     \n     public JsonNode readTree(InputStream in)\n         throws IOException, JsonProcessingException\n     {\n-        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(in));\n+        JsonParser p = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(in) : _detect(in);\n+        return _bindAndCloseAsTree(p);\n     }\n     \n     /**\n     public JsonNode readTree(Reader r)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(r);\n+        }\n         return _bindAndCloseAsTree(_jsonFactory.createJsonParser(r));\n     }\n \n      * it will just be ignored; result is always a newly constructed\n      * {@link JsonNode} instance.\n      */\n-    public JsonNode readTree(String content)\n-        throws IOException, JsonProcessingException\n-    {\n-        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(content));\n+    public JsonNode readTree(String json)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(json);\n+        }\n+        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(json));\n     }\n \n     /*\n     public <T> MappingIterator<T> readValues(InputStream src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        JsonParser jp = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src) : _detect(src);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n     public <T> MappingIterator<T> readValues(Reader src)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(src);\n+        }\n         JsonParser jp = _jsonFactory.createJsonParser(src);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n     public <T> MappingIterator<T> readValues(String json)\n         throws IOException, JsonProcessingException\n     {\n+        if (_dataFormatDetector != null) {\n+            _reportUndetectableSource(json);\n+        }\n         JsonParser jp = _jsonFactory.createJsonParser(json);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n     public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = _jsonFactory.createJsonParser(src, offset, length);\n+        JsonParser jp = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src, offset, length) : _detect(src, offset, length);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n     public <T> MappingIterator<T> readValues(File src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        JsonParser jp = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src) : _detect(src);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n     public <T> MappingIterator<T> readValues(URL src)\n         throws IOException, JsonProcessingException\n     {\n-        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        JsonParser jp = (_dataFormatDetector == null) ?\n+                _jsonFactory.createJsonParser(src) : _detect(src);\n         if (_schema != null) {\n             jp.setSchema(_schema);\n         }\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n-    \n+\n     /*\n     /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Internal helper method called to create an instance of {@link DeserializationContext}\n-     * for deserializing a single root value.\n-     * Can be overridden if a custom context is needed.\n-     */\n-    protected final DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n-            DeserializationConfig cfg) {\n-        // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n-        return _context.createInstance(cfg, jp, _injectableValues);\n+    /* Implementation of rest of ObjectCodec methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode createArrayNode() {\n+        return _config.getNodeFactory().arrayNode();\n+    }\n+\n+    @Override\n+    public JsonNode createObjectNode() {\n+        return _config.getNodeFactory().objectNode();\n+    }\n+\n+    @Override\n+    public JsonParser treeAsTokens(TreeNode n) {\n+        return new TreeTraversingParser((JsonNode) n, this);\n+    }\n+\n+    @Override\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n+        throws JsonProcessingException\n+    {\n+        try {\n+            return readValue(treeAsTokens(n), valueType);\n+        } catch (JsonProcessingException e) {\n+            throw e;\n+        } catch (IOException e) { // should not occur, no real i/o...\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n+    {\n+        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n     }\n \n     /*\n     /**********************************************************\n-    /* Helper methods\n+    /* Helper methods, data-binding\n     /**********************************************************\n      */\n     \n         return t;\n     }\n \n-//static int col = 0;\n-\n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n             JavaType valueType)\n         throws JsonMappingException\n     {\n-        /*\n-if (++col > 76) { col = 0; System.out.println(); }\n-System.out.print((_rootDeserializer == null) ? '0' : '1');\n-*/\n-        \n         if (_rootDeserializer != null) {\n             return _rootDeserializer;\n         }\n         }\n         return result;\n     }\n-    \n+\n     /*\n     /**********************************************************\n-    /* Implementation of rest of ObjectCodec methods\n-    /**********************************************************\n-     */\n-    \n-    @Override\n-    public JsonNode createArrayNode() {\n-        return _config.getNodeFactory().arrayNode();\n-    }\n-\n-    @Override\n-    public JsonNode createObjectNode() {\n-        return _config.getNodeFactory().objectNode();\n-    }\n-\n-    @Override\n-    public JsonParser treeAsTokens(TreeNode n) {\n-        return new TreeTraversingParser((JsonNode) n, this);\n-    }\n-\n-    @Override\n-    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n-        throws JsonProcessingException\n-    {\n-        try {\n-            return readValue(treeAsTokens(n), valueType);\n-        } catch (JsonProcessingException e) {\n-            throw e;\n-        } catch (IOException e) { // should not occur, no real i/o...\n-            throw new IllegalArgumentException(e.getMessage(), e);\n-        }\n-    }\n-\n-    @Override\n-    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n-    {\n-        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n+    /* Internal methods, format auto-detection\n+    /**********************************************************\n+     */\n+    \n+    protected JsonParser _detect(InputStream in) throws IOException\n+    {\n+        // !!! TODO\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    protected JsonParser _detect(File src) throws IOException\n+    {\n+        // !!! TODO\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    protected JsonParser _detect(URL src) throws IOException\n+    {\n+        // !!! TODO\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    protected JsonParser _detect(byte[] src, int offset, int length) throws IOException\n+    {\n+        // !!! TODO\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Internal helper method called to create an instance of {@link DeserializationContext}\n+     * for deserializing a single root value.\n+     * Can be overridden if a custom context is needed.\n+     */\n+    protected final DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n+            DeserializationConfig cfg) {\n+        // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n+        return _context.createInstance(cfg, jp, _injectableValues);\n+    }\n+    \n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) return this;\n+        return new ObjectReader(this, newConfig);\n+    }\n+\n+    protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n+    {\n+        throw new JsonParseException(\"Can not use source of type \"\n+                +src.getClass().getName()+\" with format auto-detection: must be byte- not char-based\",\n+                JsonLocation.NA);\n     }\n }", "timestamp": 1345160031, "metainfo": ""}