{"sha": "ec6eafb55ade5bc45c8c56c63ef94d25ac2d462e", "log": "Add an alternative creator for collections", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n      * This method is called if {@link #getFromObjectArguments} returns\n      * null or empty List.\n      */\n-    public Object createUsingDefault(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException {\n+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\"; no default creator found\");\n     }\n      * This method is called if {@link #getFromObjectArguments} returns\n      * a non-empty List of arguments.\n      */\n-    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args)\n-        throws IOException, JsonProcessingException {\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" with arguments\");\n     }\n \n      * Method to called to create value instance from JSON Object using\n      * an intermediate \"delegate\" value to pass to createor method\n      */\n-    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate)\n-        throws IOException, JsonProcessingException {\n+    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()+\" using delegate\");\n     }\n     \n     /**********************************************************\n      */\n     \n-    public Object createFromString(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException {\n-        throw new JsonMappingException(\"Can not instantiate value of type \"\n-                +getValueTypeDesc()+\" from String value '\"+value+\"'\");\n-    }\n-    \n-    public Object createFromInt(DeserializationContext ctxt, int value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromString(DeserializationContext ctxt, String value) throws IOException {\n+        return _createFromStringFallbacks(ctxt, value);\n+    }\n+\n+    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Integer number (\"+value+\", int)\");\n     }\n \n-    public Object createFromLong(DeserializationContext ctxt, long value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Integer number (\"+value+\", long)\");\n     }\n \n-    public Object createFromDouble(DeserializationContext ctxt, double value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Floating-point number (\"+value+\", double)\");\n     }\n     \n-    public Object createFromBoolean(DeserializationContext ctxt, boolean value)\n-            throws IOException, JsonProcessingException {\n+    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException {\n         throw new JsonMappingException(\"Can not instantiate value of type \"\n                 +getValueTypeDesc()+\" from Boolean value (\"+value+\")\");\n     }\n      * this method may return null .\n      */\n     public AnnotatedWithParams getDefaultCreator() { return null; }\n-    \n+\n     /**\n      * Method that can be called to try to access member (constructor,\n      * static factory method) that is used as the \"delegate creator\".\n      * needs further annotation to help make the creator complete.\n      */\n     public AnnotatedParameter getIncompleteParameter() { return null; }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.4 (demoted from <code>StdValueInstantiator)\n+     */\n+    protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value)\n+            throws IOException, JsonProcessingException\n+    {\n+        /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy\n+         *   systems that expect conversions in some cases, let's just add a minimal\n+         *   patch (note: same could conceivably be used for numbers too).\n+         */\n+        if (canCreateFromBoolean()) {\n+            String str = value.trim();\n+            if (\"true\".equals(str)) {\n+                return createFromBoolean(ctxt, true);\n+            }\n+            if (\"false\".equals(str)) {\n+                return createFromBoolean(ctxt, false);\n+            }\n+        }\n+        // also, empty Strings might be accepted as null Object...\n+        if (value.length() == 0) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                return null;\n+            }\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from String value ('\"+value+\"'); no single-String constructor/factory method\");\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n+import java.io.IOException;\n import java.lang.reflect.Member;\n import java.util.*;\n \n-\n import com.fasterxml.jackson.databind.BeanDescription;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n \n     public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n     {\n-        StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType());\n-\n         JavaType delegateType;\n-\n-        if (_delegateCreator == null) {\n+        boolean maybeVanilla = _delegateCreator == null;\n+        \n+        if (maybeVanilla) {\n             delegateType = null;\n         } else {\n             // need to find type...\n             TypeBindings bindings = _beanDesc.bindingsForBeanType();\n             delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix));\n         }\n-        \n+\n+        final JavaType type = _beanDesc.getType();\n+\n+        // Any non-standard creator will prevent; with one exception: int-valued constructor\n+        // that standard containers container can be ignored\n+        maybeVanilla &= (_propertyBasedCreator == null)\n+                && (_delegateCreator == null)\n+                && (_stringCreator == null)\n+                && (_longCreator == null)\n+                && (_doubleCreator == null)\n+                && (_booleanCreator == null)\n+                ;\n+\n+        if (maybeVanilla) {\n+        /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n+         *   of \"well-known\" types, can create a non-reflection-based instantiator.\n+         */\n+            final Class<?> rawType = type.getRawClass();\n+            if (rawType == Collection.class || rawType == List.class || rawType == ArrayList.class) {\n+                return new Vanilla(Vanilla.TYPE_COLLECTION);\n+            }\n+            if (rawType == Map.class || rawType == LinkedHashMap.class) {\n+                return new Vanilla(Vanilla.TYPE_MAP);\n+            }\n+            if (rawType == HashMap.class) {\n+                return new Vanilla(Vanilla.TYPE_HASH_MAP);\n+            }\n+        }\n+        \n+        StdValueInstantiator inst = new StdValueInstantiator(config, type);\n         inst.configureFromObjectSettings(_defaultConstructor,\n                 _delegateCreator, delegateType, _delegateArgs,\n                 _propertyBasedCreator, _propertyBasedArgs);\n     public boolean hasDefaultCreator() {\n         return _defaultConstructor != null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper methods\n         }\n         return _fixAccess(newOne);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper class(es)\n+    /**********************************************************\n+     */\n+\n+    protected final static class Vanilla\n+        extends ValueInstantiator\n+        implements java.io.Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static int TYPE_COLLECTION = 1;\n+        public final static int TYPE_MAP = 2;\n+        public final static int TYPE_HASH_MAP = 3;\n+\n+        private final int _type;\n+        \n+        public Vanilla(int t) {\n+            _type = t;\n+        }\n+        \n+        \n+        @Override\n+        public String getValueTypeDesc() {\n+            switch (_type) {\n+            case TYPE_COLLECTION: return ArrayList.class.getName();\n+            case TYPE_MAP: return LinkedHashMap.class.getName();\n+            case TYPE_HASH_MAP: return HashMap.class.getName();\n+            }\n+            return Object.class.getName();\n+        }\n+\n+        @Override\n+        public boolean canInstantiate() { return true; }\n+\n+        @Override\n+        public boolean canCreateUsingDefault() {  return true; }\n+\n+        @Override\n+        public Object createUsingDefault(DeserializationContext ctxt) throws IOException {\n+            switch (_type) {\n+            case TYPE_COLLECTION: return new ArrayList<Object>();\n+            case TYPE_MAP: return new LinkedHashMap<String,Object>();\n+            case TYPE_HASH_MAP: return new HashMap<String,Object>();\n+            }\n+            throw new IllegalStateException(\"Unknown type \"+_type);\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n  * Creator methods that can be indicated by standard Jackson\n  * annotations.\n  */\n+@JacksonStdImpl\n public class StdValueInstantiator\n     extends ValueInstantiator\n     implements java.io.Serializable\n     /**********************************************************\n      */\n \n-    protected Object _createFromStringFallbacks(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException\n-    {\n-        /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy\n-         *   systems that expect conversions in some cases, let's just add a minimal\n-         *   patch (note: same could conceivably be used for numbers too).\n-         */\n-        if (_fromBooleanCreator != null) {\n-            String str = value.trim();\n-            if (\"true\".equals(str)) {\n-                return createFromBoolean(ctxt, true);\n-            }\n-            if (\"false\".equals(str)) {\n-                return createFromBoolean(ctxt, false);\n-            }\n-        }\n-        \n-        // and finally, empty Strings might be accepted as null Object...\n-        if (value.length() == 0) {\n-            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                return null;\n-            }\n-        }\n-        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n-                +\" from String value ('\"+value+\"'); no single-String constructor/factory method\");\n-    }\n-    \n     protected JsonMappingException wrapException(Throwable t)\n     {\n         while (t.getCause() != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         return new StringCollectionDeserializer(_collectionType,\n                 _valueInstantiator, delegateDeser, valueDeser);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Validation, post-processing", "timestamp": 1399774713, "metainfo": ""}