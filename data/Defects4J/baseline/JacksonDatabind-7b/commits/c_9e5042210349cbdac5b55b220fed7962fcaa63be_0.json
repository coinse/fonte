{"sha": "9e5042210349cbdac5b55b220fed7962fcaa63be", "log": "Deser refactoring, renaming", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n import com.fasterxml.jackson.databind.deser.DeserializerFactory;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n  * Object that contains baseline configuration for deserialization\n  * process. An instance is owned by {@link ObjectMapper}, which\n  * passes an immutable instance for serialization process to\n- * {@link DeserializerProvider} and {@link DeserializerFactory}\n+ * {@link DeserializerCache} and {@link DeserializerFactory}\n  * (either directly, or through {@link ObjectReader}.\n  *<p>\n  * Note that instances are considered immutable and as such no copies\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n      * Returns provider that can be used for dynamically locating\n      * other deserializers during runtime.\n      */\n-    public abstract DeserializerProvider getDeserializerProvider();\n+    public abstract DeserializerCache getDeserializerProvider();\n \n     public final AnnotationIntrospector getAnnotationIntrospector() {\n         return _config.getAnnotationIntrospector();\n \n     /*\n     /**********************************************************\n-    /* By-pass methods to DeserializerProvider\n+    /* By-pass methods to DeserializerCache\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     /**\n      * Object that manages access to deserializers used for deserializing\n-     * JSON content into Java objects, including possible caching\n+     * JSON content into Java objects, including caching\n      * of the deserializers. It contains a reference to\n      * {@link DeserializerFactory} to use for constructing acutal deserializers.\n      */\n-    protected DeserializerProvider _deserializerProvider;\n+    protected DeserializerCache _deserializerCache;\n \n     /*\n     /**********************************************************\n      * \n      * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n      * @param sp SerializerProvider to use: if null, a {@link StdSerializerProvider} will be constructed\n-     * @param dp DeserializerProvider to use: if null, a {@link StdDeserializerProvider} will be constructed\n+     * @param dp DeserializerCache to use: if null, a {@link StdDeserializerProvider} will be constructed\n      */\n     public ObjectMapper(JsonFactory jf,\n-            SerializerProvider sp, DeserializerProvider dp)\n+            SerializerProvider sp, DeserializerCache dp)\n     {\n         /* 02-Mar-2009, tatu: Important: we MUST default to using\n          *   the mapping factory, otherwise tree serialization will\n         _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n         _serializerProvider = (sp == null) ? new StdSerializerProvider.Impl() : sp;\n-        _deserializerProvider = (dp == null) ? new StdDeserializerProvider() : dp;\n+        _deserializerCache = (dp == null) ? new DeserializerCache(BeanDeserializerFactory.instance) : dp;\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n             \n             @Override\n             public void addDeserializers(Deserializers d) {\n-                mapper._deserializerProvider = mapper._deserializerProvider.withAdditionalDeserializers(d);\n+                mapper._deserializerCache = mapper._deserializerCache.withAdditionalDeserializers(d);\n             }\n \n             @Override\n             public void addKeyDeserializers(KeyDeserializers d) {\n-                mapper._deserializerProvider = mapper._deserializerProvider.withAdditionalKeyDeserializers(d);\n+                mapper._deserializerCache = mapper._deserializerCache.withAdditionalKeyDeserializers(d);\n             }\n             \n             @Override\n \n             @Override\n             public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n-                mapper._deserializerProvider = mapper._deserializerProvider.withDeserializerModifier(modifier);\n+                mapper._deserializerCache = mapper._deserializerCache.withDeserializerModifier(modifier);\n             }\n \n             // // // Methods for registering handlers: other\n             \n             @Override\n             public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n-                mapper._deserializerProvider = mapper._deserializerProvider.withAbstractTypeResolver(resolver);\n+                mapper._deserializerCache = mapper._deserializerCache.withAbstractTypeResolver(resolver);\n             }\n \n             @Override\n \n             @Override\n             public void addValueInstantiators(ValueInstantiators instantiators) {\n-                mapper._deserializerProvider = mapper._deserializerProvider.withValueInstantiators(instantiators);\n+                mapper._deserializerCache = mapper._deserializerCache.withValueInstantiators(instantiators);\n             }\n             \n             @Override\n     }\n     \n     /**\n-     * Method for setting specific {@link DeserializerProvider} to use\n+     * Method for setting specific {@link DeserializerCache} to use\n      * for handling caching of {@link JsonDeserializer} instances.\n      */\n-    public ObjectMapper setDeserializerProvider(DeserializerProvider p) {\n-        _deserializerProvider = p;\n-        return this;\n-    }\n-\n-    public DeserializerProvider getDeserializerProvider() {\n-        return _deserializerProvider;\n+    public ObjectMapper setDeserializerProvider(DeserializerCache p) {\n+        _deserializerCache = p;\n+        return this;\n+    }\n+\n+    public DeserializerCache getDeserializerProvider() {\n+        return _deserializerCache;\n     }\n     \n     /*\n      */\n     public boolean canDeserialize(JavaType type)\n     {\n-        return _deserializerProvider.hasValueDeserializerFor(getDeserializationConfig(), type);\n+        return _deserializerCache.hasValueDeserializerFor(getDeserializationConfig(), type);\n     }\n \n     /*\n \n     protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg)\n     {\n-        return new StdDeserializationContext(cfg, jp, _deserializerProvider,\n+        return new StdDeserializationContext(cfg, jp, _deserializerCache,\n                 _injectableValues);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.StdDeserializationContext;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.NullNode;\n      */\n     final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n    \n-    protected final DeserializerProvider _provider;\n+    protected final DeserializerCache _deserializerCache;\n \n     /**\n      * Factory used for constructing {@link JsonGenerator}s\n     {\n         _config = config;\n         _rootDeserializers = mapper._rootDeserializers;\n-        _provider = mapper._deserializerProvider;\n+        _deserializerCache = mapper._deserializerCache;\n         _jsonFactory = mapper._jsonFactory;\n         _rootNames = mapper._rootNames;\n         _valueType = valueType;\n         _config = config;\n \n         _rootDeserializers = base._rootDeserializers;\n-        _provider = base._provider;\n+        _deserializerCache = base._deserializerCache;\n         _jsonFactory = base._jsonFactory;\n         _rootNames = base._rootNames;\n \n         _config = config;\n \n         _rootDeserializers = base._rootDeserializers;\n-        _provider = base._provider;\n+        _deserializerCache = base._deserializerCache;\n         _jsonFactory = base._jsonFactory;\n         _rootNames = base._rootNames;\n \n         }\n \n         // Nope: need to ask provider to resolve it\n-        deser = _provider.findTypedValueDeserializer(cfg, valueType, null);\n+        deser = _deserializerCache.findTypedValueDeserializer(cfg, valueType, null);\n         if (deser == null) { // can this happen?\n             throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n         }\n     \n     protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n-        return new StdDeserializationContext(cfg, jp, _provider, _injectableValues);\n+        return new StdDeserializationContext(cfg, jp, _deserializerCache, _injectableValues);\n     }\n \n     protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             throws JsonMappingException;\n     \n     @Override\n-    public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerCache p,\n             ArrayType type, BeanProperty property)\n         throws JsonMappingException\n     {\n     }\n     \n     @Override\n-    public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config, DeserializerCache p,\n             CollectionType type, BeanProperty property)\n         throws JsonMappingException\n     {\n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n     public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, CollectionLikeType type, BeanProperty property)\n+            DeserializerCache p, CollectionLikeType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First: global defaulting:\n     }\n     \n     @Override\n-    public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config, DeserializerCache p,\n             MapType type, BeanProperty property)\n         throws JsonMappingException\n     {\n     // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n     @Override\n     public JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, MapLikeType type, BeanProperty property)\n+            DeserializerCache p, MapLikeType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First: global defaulting:\n      * Factory method for constructing serializers of {@link Enum} types.\n      */\n     @Override\n-    public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config, DeserializerCache p,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n     }\n \n     @Override\n-    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerCache p,\n             JavaType nodeType, BeanProperty property)\n         throws JsonMappingException\n     {\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> findStdBeanDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, JavaType type, BeanProperty property)\n+            DeserializerCache p, JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         Class<?> cls = type.getRawClass();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n      * This is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+    public void resolve(DeserializationConfig config, DeserializerCache provider)\n         throws JsonMappingException\n     {\n         // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n             return subDeser;\n         }\n         // If not, maybe we can locate one. First, need provider\n-        DeserializerProvider deserProv = ctxt.getDeserializerProvider();\n+        DeserializerCache deserProv = ctxt.getDeserializerProvider();\n         if (deserProv != null) {\n             JavaType type = ctxt.constructType(bean.getClass());\n             /* 09-Dec-2010, tatu: Would be nice to know which property pointed to this\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n  *<p>\n  * Since there is no caching, this factory is stateless and a globally\n  * shared singleton instance ({@link #instance}) can be  used by\n- * {@link DeserializerProvider}s).\n+ * {@link DeserializerCache}s).\n  */\n public class BeanDeserializerFactory\n     extends BasicDeserializerFactory\n     // Note: NOT overriding, superclass has no matching method\n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config,\n-            DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property)\n+            DeserializerCache provider, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         for (Deserializers d  : _factoryConfig.deserializers()) {\n     }\n \n     /**\n-     * Method that {@link DeserializerProvider}s call to create a new\n+     * Method that {@link DeserializerCache}s call to create a new\n      * deserializer for types other than Collections, Maps, arrays and\n      * enums.\n      */\n     @Override\n     public JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, JavaType type, BeanProperty property)\n+            DeserializerCache p, JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First things first: abstract types may use defaulting:\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n+import com.fasterxml.jackson.databind.type.CollectionLikeType;\n+import com.fasterxml.jackson.databind.type.CollectionType;\n+import com.fasterxml.jackson.databind.type.MapLikeType;\n+import com.fasterxml.jackson.databind.type.MapType;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Class that defines caching layer between callers (like\n+ * {@link ObjectMapper}, {@link com.fasterxml.jackson.map.deser.DeserializationContext})\n+ * and classes that construct deserializers ({@link com.fasterxml.jackson.map.deser.DeserializerFactory}).\n+ */\n+public final class DeserializerCache\n+{\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We will also cache some dynamically constructed deserializers;\n+     * specifically, ones that are expensive to construct.\n+     * This currently means bean and Enum deserializers; array, List and Map\n+     * deserializers will not be cached.\n+     *<p>\n+     * Given that we don't expect much concurrency for additions\n+     * (should very quickly converge to zero after startup), let's\n+     * explicitly define a low concurrency setting.\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+\n+    /**\n+     * During deserializer construction process we may need to keep track of partially\n+     * completed deserializers, to resolve cyclic dependencies. This is the\n+     * map used for storing deserializers before they are fully complete.\n+     */\n+    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n+        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory responsible for constructing actual deserializers, if not\n+     * one of pre-configured types.\n+     */\n+    protected final DeserializerFactory _factory;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public DeserializerCache(DeserializerFactory f) {\n+        _factory = f;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Fluent factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that sub-classes need to override, to ensure that fluent-factory\n+     * methods will produce proper sub-type.\n+     */\n+    public DeserializerCache withFactory(DeserializerFactory factory) {\n+        return new DeserializerCache(factory);\n+    }\n+    \n+    /**\n+     * Method that is to configure {@link DeserializerFactory} that provider has\n+     * to use specified deserializer provider, with highest precedence (that is,\n+     * additional providers have higher precedence than default one or previously\n+     * added ones)\n+     */\n+    public DeserializerCache withAdditionalDeserializers(Deserializers d) {\n+        return withFactory(_factory.withAdditionalDeserializers(d));\n+    }\n+\n+    public DeserializerCache withAdditionalKeyDeserializers(KeyDeserializers d) {\n+        return withFactory(_factory.withAdditionalKeyDeserializers(d));\n+    }\n+    \n+    public DeserializerCache withDeserializerModifier(BeanDeserializerModifier modifier) {\n+        return withFactory(_factory.withDeserializerModifier(modifier));\n+    }\n+\n+    public DeserializerCache withAbstractTypeResolver(AbstractTypeResolver resolver) {\n+        return withFactory(_factory.withAbstractTypeResolver(resolver));\n+    }\n+\n+    /**\n+     * Method that will construct a new instance with specified additional value instantiators\n+     * (i.e. does NOT replace existing ones)\n+     */\n+    public DeserializerCache withValueInstantiators(ValueInstantiators instantiators) {\n+        return withFactory(_factory.withValueInstantiators(instantiators));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Access to caching aspects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many deserializers this\n+     * provider is caching currently \n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of deserializers get cached;\n+     * default implementation caches only dynamically constructed deserializers,\n+     * but not eagerly constructed standard deserializers (which is different\n+     * from how serializer provider works).\n+     *<p>\n+     * The main use case for this method is to allow conditional flushing of\n+     * deserializer cache, if certain number of entries is reached.\n+     */\n+    public int cachedDeserializersCount() {\n+        return _cachedDeserializers.size();\n+    }\n+\n+    /**\n+     * Method that will drop all dynamically constructed deserializers (ones that\n+     * are counted as result value for {@link #cachedDeserializersCount}).\n+     * This can be used to remove memory usage (in case some deserializers are\n+     * only used once or so), or to force re-construction of deserializers after\n+     * configuration changes for mapper than owns the provider.\n+     */\n+    public void flushCachedDeserializers() {\n+        _cachedDeserializers.clear();       \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General deserializer locating method\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get hold of a deserializer for a value of given type;\n+     * or if no such deserializer can be found, a default handler (which\n+     * may do a best-effort generic serialization or just simply\n+     * throw an exception when invoked).\n+     *<p>\n+     * Note: this method is only called for value types; not for keys.\n+     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n+     *\n+     * @param config Deserialization configuration\n+     * @param propertyType Declared type of the value to deserializer (obtained using\n+     *   'setter' method signature and/or type annotations\n+     * @param property Object that represents accessor for property value; field,\n+     *    setter method or constructor parameter.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonDeserializer<Object> findValueDeserializer(DeserializationConfig config,\n+            JavaType propertyType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n+        if (deser != null) {\n+            // [JACKSON-385]: need to support contextualization:\n+            if (deser instanceof ContextualDeserializer<?>) {\n+                JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(config, property);\n+                deser = (JsonDeserializer<Object>) d;\n+            }\n+            return deser;\n+        }\n+        // If not, need to request factory to construct (or recycle)\n+        deser = _createAndCacheValueDeserializer(config, propertyType, property);\n+        if (deser == null) {\n+            /* Should we let caller handle it? Let's have a helper method\n+             * decide it; can throw an exception, or return a valid\n+             * deserializer\n+             */\n+            deser = _handleUnknownValueDeserializer(propertyType);\n+        }\n+        // [JACKSON-385]: need to support contextualization:\n+        if (deser instanceof ContextualDeserializer<?>) {\n+            JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(config, property);\n+            deser = (JsonDeserializer<Object>) d;\n+        }\n+        return deser;\n+    }\n+    \n+    /**\n+     * Method called to locate deserializer for given type, as well as matching\n+     * type deserializer (if one is needed); and if type deserializer is needed,\n+     * construct a \"wrapped\" deserializer that can extract and use type information\n+     * for calling actual deserializer.\n+     *<p>\n+     * Since this method is only called for root elements, no referral information\n+     * is taken.\n+     */\n+    public JsonDeserializer<Object> findTypedValueDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = findValueDeserializer(config, type, property);\n+        TypeDeserializer typeDeser = _factory.findTypeDeserializer(config, type, property);\n+        if (typeDeser != null) {\n+            return new WrappedDeserializer(typeDeser, deser);\n+        }\n+        return deser;\n+    }\n+\n+    /**\n+     * Method called to get hold of a deserializer to use for deserializing\n+     * keys for {@link java.util.Map}.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable key deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public KeyDeserializer findKeyDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        KeyDeserializer kd = _factory.createKeyDeserializer(config, type, property);\n+        // One more thing: contextuality\n+        if (kd instanceof ContextualKeyDeserializer) {\n+            kd = ((ContextualKeyDeserializer) kd).createContextual(config, property);\n+        }\n+        if (kd == null) { // if none found, need to use a placeholder that'll fail\n+            return _handleUnknownKeyDeserializer(type);\n+        }\n+        return kd;\n+    }\n+\n+    /**\n+     * Method called to find out whether provider would be able to find\n+     * a deserializer for given type, using a root reference (i.e. not\n+     * through fields or membership in an array or collection)\n+     */\n+    public boolean hasValueDeserializerFor(DeserializationConfig config, JavaType type)\n+    {\n+        /* Note: mostly copied from findValueDeserializer, except for\n+         * handling of unknown types\n+         */\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+        if (deser == null) {\n+            try {\n+                deser = _createAndCacheValueDeserializer(config, type, null);\n+            } catch (Exception e) {\n+                return false;\n+            }\n+        }\n+        return (deser != null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable helper methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return _cachedDeserializers.get(type);\n+    }\n+\n+    /**\n+     * Method that will try to create a deserializer for given type,\n+     * and resolve and cache it if necessary\n+     * \n+     * @param config Configuration\n+     * @param type Type of property to deserializer\n+     * @param property Property (field, setter, ctor arg) to use deserializer for\n+     */\n+    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        /* Only one thread to construct deserializers at any given point in time;\n+         * limitations necessary to ensure that only completely initialized ones\n+         * are visible and used.\n+         */\n+        synchronized (_incompleteDeserializers) {\n+            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n+            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+            if (deser != null) {\n+                return deser;\n+            }\n+            int count = _incompleteDeserializers.size();\n+            // Or perhaps being resolved right now?\n+            if (count > 0) {\n+                deser = _incompleteDeserializers.get(type);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+            // Nope: need to create and possibly cache\n+            try {\n+                return _createAndCache2(config, type, property);\n+            } finally {\n+                // also: any deserializers that have been created are complete by now\n+                if (count == 0 && _incompleteDeserializers.size() > 0) {\n+                    _incompleteDeserializers.clear();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that handles actual construction (via factory) and caching (both\n+     * intermediate and eventual)\n+     */\n+    protected JsonDeserializer<Object> _createAndCache2(DeserializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser;\n+        try {\n+            deser = _createDeserializer(config, type, property);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+        if (deser == null) {\n+            return null;\n+        }\n+        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n+         * (but can be re-defined for sub-classes by using @JsonCachable!)\n+         */\n+        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n+        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n+        boolean addToCache = deser.isCachable();\n+\n+        /* we will temporarily hold on to all created deserializers (to\n+         * handle cyclic references, and possibly reuse non-cached\n+         * deserializers (list, map))\n+         */\n+        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n+         *   resolution of a reference -- couple of ways to prevent this;\n+         *   either not add Lists or Maps, or clear references eagerly.\n+         *   Let's actually do both; since both seem reasonable.\n+         */\n+        /* Need to resolve? Mostly done for bean deserializers; required for\n+         * resolving cyclic references.\n+         */\n+        if (isResolvable) {\n+            _incompleteDeserializers.put(type, deser);\n+            _resolveDeserializer(config, (ResolvableDeserializer)deser);\n+            _incompleteDeserializers.remove(type);\n+        }\n+        if (addToCache) {\n+            _cachedDeserializers.put(type, deser);\n+        }\n+        return deser;\n+    }\n+\n+    /* Refactored so we can isolate the casts that require suppression\n+     * of type-safety warnings.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _createDeserializer(DeserializationConfig config, \n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (type.isEnumType()) {\n+            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, this, type, property);\n+        }\n+        if (type.isContainerType()) {\n+            if (type.isArrayType()) {\n+                return (JsonDeserializer<Object>)_factory.createArrayDeserializer(config, this,\n+                        (ArrayType) type, property);\n+            }\n+            if (type.isMapLikeType()) {\n+                MapLikeType mlt = (MapLikeType) type;\n+                if (mlt.isTrueMapType()) {\n+                    return (JsonDeserializer<Object>)_factory.createMapDeserializer(config, this,\n+                            (MapType) mlt, property);\n+                }\n+                return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(config, this,\n+                        mlt, property);\n+            }\n+            if (type.isCollectionLikeType()) {\n+                CollectionLikeType clt = (CollectionLikeType) type;\n+                if (clt.isTrueCollectionType()) {\n+                    return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(config, this,\n+                            (CollectionType) clt, property);\n+                }\n+                return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(config, this,\n+                        clt, property);\n+            }\n+        }\n+\n+        // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n+        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n+            return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, this, type, property);\n+        }\n+        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, this, type, property);\n+    }\n+\n+    protected void _resolveDeserializer(DeserializationConfig config, ResolvableDeserializer ser)\n+        throws JsonMappingException\n+    {\n+        ser.resolve(config, this);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable error reporting methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Let's try to figure out the reason, to give better error\n+         * messages\n+         */\n+        Class<?> rawClass = type.getRawClass();\n+        if (!ClassUtil.isConcrete(rawClass)) {\n+            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n+        }\n+        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n+    }\n+\n+    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /*  Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple deserializer that will call configured type deserializer, passing\n+     * in configured data deserializer, and exposing it all as a simple\n+     * deserializer.\n+     */\n+    protected final static class WrappedDeserializer\n+        extends JsonDeserializer<Object>\n+    {\n+        final TypeDeserializer _typeDeserializer;\n+        final JsonDeserializer<Object> _deserializer;\n+\n+        public WrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+        {\n+            super();\n+            _typeDeserializer = typeDeser;\n+            _deserializer = deser;\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+                throws IOException, JsonProcessingException\n+        {\n+            // should never happen? (if it can, could call on that object)\n+            throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n import com.fasterxml.jackson.databind.type.*;\n \n /**\n- * Abstract class that defines API used by {@link DeserializerProvider}\n+ * Abstract class that defines API used by {@link DeserializerCache}\n  * to obtain actual\n  * {@link JsonDeserializer} instances from multiple distinct factories.\n  *<p>\n  * <li>For JSON \"Array\" type, we need 2 methods: one to deal with expected\n  *   Java arrays ({@link #createArrayDeserializer})\n  *   and the other for other Java containers like {@link java.util.List}s\n- *   and {@link java.util.Set}s ({@link #createCollectionDeserializer(DeserializationConfig, DeserializerProvider, CollectionType, BeanProperty)})\n+ *   and {@link java.util.Set}s ({@link #createCollectionDeserializer(DeserializationConfig, DeserializerCache, CollectionType, BeanProperty)})\n  *  </li>\n  * <li>For JSON \"Object\" type, we need 2 methods: one to deal with\n  *   expected Java {@link java.util.Map}s\n  *   ({@link #createMapDeserializer}), and another for POJOs\n- *   ({@link #createBeanDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}.\n+ *   ({@link #createBeanDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}.\n  *  </li>\n  * <li>For Tree Model ({@link com.fasterxml.jackson.core.JsonNode}) properties there is\n- *    {@link #createTreeDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n+ *    {@link #createTreeDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}\n  * <li>For enumerated types ({@link java.lang.Enum}) there is\n- *    {@link #createEnumDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n+ *    {@link #createEnumDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}\n  *  </li>\n- * <li>For all other types, {@link #createBeanDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n+ * <li>For all other types, {@link #createBeanDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}\n  *   is used.\n  * </ul>\n  *<p>\n      * @param p Provider that can be called to create deserializers for\n      *   contained member types\n      */\n-    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config, DeserializerCache p,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n      * @param p Provider that can be called to create deserializers for\n      *   contained member types\n      */\n-    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerCache p,\n             ArrayType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, CollectionType type, BeanProperty property)\n+            DeserializerCache p, CollectionType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, CollectionLikeType type, BeanProperty property)\n+            DeserializerCache p, CollectionLikeType type, BeanProperty property)\n         throws JsonMappingException;\n     \n     public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, JavaType type, BeanProperty property)\n+            DeserializerCache p, JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, MapType type, BeanProperty property)\n+            DeserializerCache p, MapType type, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n-            DeserializerProvider p, MapLikeType type, BeanProperty property)\n+            DeserializerCache p, MapLikeType type, BeanProperty property)\n         throws JsonMappingException;\n \n     /**\n      * Method called to create and return a deserializer that can construct\n      * JsonNode(s) from JSON content.\n      */\n-    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerProvider p,\n+    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerCache p,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n      *<p>\n      * Similarly, a {@link KeyDeserializer} may be passed, but this is only done if there is\n      * a specific configuration override (annotations) to indicate instance to use. Otherwise\n-     * null is passed, and key deserializer needs to be obtained using {@link DeserializerProvider}\n+     * null is passed, and key deserializer needs to be obtained using {@link DeserializerCache}\n      * \n      * @param type Type of {@link java.util.Map} instances to deserialize\n      * @param config Configuration in effect\n      *<p>\n      * Similarly, a {@link KeyDeserializer} may be passed, but this is only done if there is\n      * a specific configuration override (annotations) to indicate instance to use. Otherwise\n-     * null is passed, and key deserializer needs to be obtained using {@link DeserializerProvider}\n+     * null is passed, and key deserializer needs to be obtained using {@link DeserializerCache}\n      * \n      * @param type Type of {@link java.util.Map} instances to deserialize\n      * @param config Configuration in effect\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n \n /**\n  * Interface used to indicate deserializers that want to do post-processing\n- * after construction and being added to {@link DeserializerProvider},\n+ * after construction and being added to {@link DeserializerCache},\n  * but before being used. This is typically used to resolve references\n  * to other contained types; for example, bean deserializers use this\n  * to eagerly find deserializers for contained field types.\n public interface ResolvableDeserializer\n {\n     /**\n-     * Method called after {@link DeserializerProvider} has registered\n+     * Method called after {@link DeserializerCache} has registered\n      * the deserializer, but before it has returned it to the caller.\n      * Called object can then resolve its dependencies to other types,\n      * including self-references (direct or indirect).\n      * @param provider Provider that has constructed deserializer this method\n      *   is called on.\n      */\n-    public abstract void resolve(DeserializationConfig config, DeserializerProvider provider)\n+    public abstract void resolve(DeserializationConfig config, DeserializerCache provider)\n         throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n      */\n     protected JsonParser _parser;\n \n-    protected final DeserializerProvider _deserProvider;\n+    protected final DeserializerCache _deserProvider;\n \n     protected final InjectableValues _injectableValues;\n     \n      */\n \n     public StdDeserializationContext(DeserializationConfig config, JsonParser jp,\n-            DeserializerProvider prov, InjectableValues injectableValues)\n+            DeserializerCache prov, InjectableValues injectableValues)\n     {\n     \tsuper(config);\n         _parser = jp;\n      */\n \n     @Override\n-    public DeserializerProvider getDeserializerProvider() {\n+    public DeserializerCache getDeserializerProvider() {\n         return _deserProvider;\n     }\n \n \n     /*\n     /**********************************************************\n-    /* Public API, pass-through to DeserializerProvider\n+    /* Public API, pass-through to DeserializerCache\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n      * is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+    public void resolve(DeserializationConfig config, DeserializerCache provider)\n         throws JsonMappingException\n     {\n         // May need to resolve types for delegate-based creators:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n         }\n         \n         @Override\n-        public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        public void resolve(DeserializationConfig config, DeserializerCache provider)\n             throws JsonMappingException\n         {\n             if (_valueDeserializer == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n      * is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+    public void resolve(DeserializationConfig config, DeserializerCache provider)\n         throws JsonMappingException\n     {\n         // May need to resolve types for delegate- and/or property-based creators:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n      *     for passing deserialized values; provided so deserializer can be contextualized if necessary (since 1.7)\n      */\n     protected JsonDeserializer<Object> findDeserializer(DeserializationConfig config,\n-            DeserializerProvider provider,\n+            DeserializerCache provider,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n      * is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+    public void resolve(DeserializationConfig config, DeserializerCache provider)\n         throws JsonMappingException\n     {\n         // May need to resolve types for delegate-based creators:\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.deser.DeserializerProvider;\n+import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.util.Provider;\n \n         return null;\n     }\n \n-    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, DeserializerProvider p)\n+    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, DeserializerCache p)\n     {\n         Class<?> rawType = type.getRawClass();\n         String className = rawType.getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.deser.StdDeserializerProvider;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n         }\n \n         @Override\n-        public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        public void resolve(DeserializationConfig config, DeserializerCache provider)\n             throws JsonMappingException\n         {\n             try {", "timestamp": 1327433039, "metainfo": ""}