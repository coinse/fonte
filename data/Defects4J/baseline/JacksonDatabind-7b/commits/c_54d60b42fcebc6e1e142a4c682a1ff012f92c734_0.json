{"sha": "54d60b42fcebc6e1e142a4c682a1ff012f92c734", "log": "Fixed #390; trying to trim forward-ref implementation slightly to remove non-static inner classes", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedId.java\n  * @author pgelinas\n  */\n public class UnresolvedId {\n-    private Object _id;\n-    private JsonLocation _location;\n-    private Class<?> _type;\n+    private final Object _id;\n+    private final JsonLocation _location;\n+    private final Class<?> _type;\n \n-    public UnresolvedId(Object id, Class<?> type, JsonLocation where)\n-    {\n+    public UnresolvedId(Object id, Class<?> type, JsonLocation where) {\n         _id = id;\n         _type = type;\n         _location = where;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n     {\n         /* 04-Feb-2014, tatu: As per [#390], it may be necessary to switch the\n          *   ordering of forward/backward references, and start with back ref.\n-         *   But before doing that, need a unit test.\n-         */\n-        \n-        // Start with forward property\n-        Object result = _managedProperty.setAndReturn(instance, value);\n-        /* And then back reference, if (and only if!) we actually have a non-null\n-         * reference\n          */\n         if (value != null) {\n             if (_isContainer) { // ok, this gets ugly... but has to do for now\n                 _backProperty.set(value, instance);\n             }\n         }\n-        return result;\n+        // and then the forward reference itself\n+        return _managedProperty.setAndReturn(instance, value);\n \t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n         CollectionReferringAccumulator referringAccumulator =\n-            (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(result);\n+            (valueDes.getObjectIdReader() == null) ? null :\n+                new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n \n         JsonToken t;\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n         return result;\n     }\n \n-    public final class CollectionReferringAccumulator {\n-        private Collection<Object> _result;\n+    public final static class CollectionReferringAccumulator {\n+        private final Class<?> _elementType;\n+        private final Collection<Object> _result;\n+\n         /**\n          * A list of {@link UnresolvedId} to maintain ordering.\n          */\n         private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n \n-        public CollectionReferringAccumulator(Collection<Object> result)\n-        {\n+        public CollectionReferringAccumulator(Class<?> elementType, Collection<Object> result) {\n+            _elementType = elementType;\n             _result = result;\n         }\n \n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference)\n         {\n-            UnresolvedId id = new UnresolvedId(reference.getUnresolvedId(), reference.getLocation());\n+            UnresolvedId id = new UnresolvedId(this, reference, _elementType);\n             _accumulator.add(id);\n             return id;\n         }\n             throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                     + \"] that wasn't previously seen as unresolved.\");\n         }\n-\n-        /**\n-         * Helper class to maintain processing order of value. The resolved\n-         * object associated with {@link #_id} comes before the values in\n-         * {@link _next}.\n-         */\n-        private final class UnresolvedId extends Referring {\n-            private final Object _id;\n-            private final List<Object> _next = new ArrayList<Object>();\n-\n-            private UnresolvedId(Object id, JsonLocation location)\n-            {\n-                super(location, _collectionType.getContentType().getRawClass());\n-                _id = id;\n-            }\n-\n-            @Override\n-            public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n-                resolveForwardReference(id, value);\n-            }\n+    }\n+\n+    /**\n+     * Helper class to maintain processing order of value. The resolved\n+     * object associated with {@link #_id} comes before the values in\n+     * {@link _next}.\n+     */\n+    private final static class UnresolvedId extends Referring {\n+        private final CollectionReferringAccumulator _parent;\n+        private final Object _id;\n+        private final List<Object> _next = new ArrayList<Object>();\n+        \n+        private UnresolvedId(CollectionReferringAccumulator parent, UnresolvedForwardReference reference,\n+                Class<?> contentType)\n+        {\n+            super(reference.getLocation(), contentType);\n+            _parent = parent;\n+            _id = reference.getUnresolvedId();\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n+            _parent.resolveForwardReference(id, value);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n public abstract class ContainerDeserializerBase<T>\n     extends StdDeserializer<T>\n {\n-    protected ContainerDeserializerBase(JavaType selfType)\n-    {\n+    protected ContainerDeserializerBase(JavaType selfType) {\n         super(selfType);\n     }\n \n      * @deprecated Since 2.3 use one that takes {@link JavaType}\n      */\n     @Deprecated\n-    protected ContainerDeserializerBase(Class<?> selfType)\n-    {\n+    protected ContainerDeserializerBase(Class<?> selfType) {\n         super(selfType);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n             HashSet<String> ignorable)\n     {\n         \n-        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser)\n-                && (_ignorableProperties == ignorable)) {\n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n+                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n             return this;\n         }\n         return new MapDeserializer(this,\n                 && isDefaultKeyDeserializer(keyDeser));\n     }\n     \n-    public void setIgnorableProperties(String[] ignorable)\n-    {\n+    public void setIgnorableProperties(String[] ignorable) {\n         _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n             null : ArrayBuilders.arrayToSet(ignorable);\n     }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        MapReferringAccumuator referringAccumulator = null;\n+        MapReferringAccumulator referringAccumulator = null;\n         boolean useObjectId = valueDes.getObjectIdReader() != null;\n         if (useObjectId) {\n-            referringAccumulator = new MapReferringAccumuator(result);\n+            referringAccumulator = new MapReferringAccumulator(result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n         }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        MapReferringAccumuator referringAccumulator = null;\n+        MapReferringAccumulator referringAccumulator = null;\n         boolean useObjectId = valueDes.getObjectIdReader() != null;\n         if (useObjectId) {\n-            referringAccumulator = new MapReferringAccumuator(result);\n+            referringAccumulator = new MapReferringAccumulator(result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n         throw JsonMappingException.wrapWithPath(t, ref, null);\n     }\n \n-    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumuator accumulator, Object key,\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n             UnresolvedForwardReference reference)\n         throws JsonMappingException\n     {\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final class MapReferringAccumuator  {\n+    private final class MapReferringAccumulator  {\n         private Map<Object,Object> _result;\n         /**\n          * A list of {@link UnresolvedId} to maintain ordering.\n          */\n         private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n \n-        public MapReferringAccumuator(Map<Object, Object> result)\n-        {\n+        public MapReferringAccumulator(Map<Object, Object> result) {\n             _result = result;\n         }\n \n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n         {\n-            UnresolvedId id = new UnresolvedId(key, reference.getUnresolvedId(), reference.getLocation());\n+            UnresolvedId id = new UnresolvedId(key, reference.getUnresolvedId(), reference.getLocation(),\n+                    _mapType.getContentType().getRawClass());\n             _accumulator.add(id);\n             return id;\n         }\n             private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n             private final Object _key;\n \n-            private UnresolvedId(Object key, Object id, JsonLocation location)\n+            private UnresolvedId(Object key, Object id, JsonLocation location,\n+                    Class<?> valueType)\n             {\n-                super(location, _mapType.getContentType().getRawClass());\n+                super(location, valueType);\n                 _key = key;\n                 _id = id;\n             }\n \n             @Override\n-            public void handleResolvedForwardReference(Object id, Object value)\n-                throws IOException\n+            public void handleResolvedForwardReference(Object id, Object value) throws IOException\n             {\n                 resolveForwardReference(id, value);\n             }", "timestamp": 1394847394, "metainfo": ""}