{"sha": "b672a9dea707816e91985b423a901bdbe4cbe25b", "log": "cleaning up manual micro-benchmarks", "commit": "\n--- a/src/test/java/perf/ManualReadPerfUntyped.java\n+++ b/src/test/java/perf/ManualReadPerfUntyped.java\n         Object input1 = m.readValue(data, Object.class);\n         JsonNode input2 = m.readTree(data);\n \n-        new ManualReadPerfUntyped().test(\n-                m, \"JSON-as-Object\", input1, Object.class,\n-                m, \"JSON-as-Node\", input2, JsonNode.class);\n+        new ManualReadPerfUntyped()\n+//            .testFromBytes(\n+            .testFromString(\n+                m, \"JSON-as-Object\", input1, Object.class\n+                ,m, \"JSON-as-Object2\", input2, Object.class\n+//               ,m, \"JSON-as-Node\", input2, JsonNode.class\n+                );\n     }\n \n }\n--- a/src/test/java/perf/ManualReadPerfWithMedia.java\n+++ b/src/test/java/perf/ManualReadPerfWithMedia.java\n \n public class ManualReadPerfWithMedia extends ObjectReaderBase\n {\n- \n     public static void main(String[] args) throws Exception\n     {\n         if (args.length != 0) {\n         ObjectMapper m1 = new ObjectMapper();\n         m1.setAnnotationIntrospector(new NoFormatIntrospector());\n         ObjectMapper m2 = new ObjectMapper();\n-        new ManualReadPerfWithRecord().test(m1, \"JSON-as-Object\", input, MediaItem.class,\n+        new ManualReadPerfWithRecord().testFromBytes(m1, \"JSON-as-Object\", input, MediaItem.class,\n                 m2, \"JSON-as-Array\", input, MediaItem.class);\n     }\n \n--- a/src/test/java/perf/ManualReadPerfWithRecord.java\n+++ b/src/test/java/perf/ManualReadPerfWithRecord.java\n         Record input = new Record(44, \"BillyBob\", \"Bumbler\", 'm', true);\n         RecordAsArray input2 = new RecordAsArray(44, \"BillyBob\", \"Bumbler\", 'm', true);\n         ObjectMapper m = new ObjectMapper();\n-        new ManualReadPerfWithRecord().test(m, \"JSON-as-Object\", input, Record.class,\n+        new ManualReadPerfWithRecord().testFromBytes(m, \"JSON-as-Object\", input, Record.class,\n                 m, \"JSON-as-Array\", input2, RecordAsArray.class);\n     }\n }\n--- a/src/test/java/perf/ManualReadPerfWithUUID.java\n+++ b/src/test/java/perf/ManualReadPerfWithUUID.java\n \n         ObjectMapper m = new ObjectMapper();\n \n-        new ManualReadPerfWithRecord().test(\n+        new ManualReadPerfWithRecord().testFromBytes(\n                 m, \"JSON-as-Object\", input1, UUIDNative.class,\n                 m, \"JSON-as-Array\", input2, UUIDWithJdk.class);\n     }\n--- a/src/test/java/perf/ObjectReaderBase.java\n+++ b/src/test/java/perf/ObjectReaderBase.java\n \n abstract class ObjectReaderBase\n {\n+    protected final static int WARMUP_ROUNDS = 5;\n+\n     protected int hash;\n \n-    protected <T1, T2> void test(ObjectMapper mapper1, String desc1,\n+    protected int roundsDone = 0;\n+\n+    protected int REPS;\n+    \n+    protected <T1, T2> void testFromBytes(ObjectMapper mapper1, String desc1,\n             T1 inputValue1, Class<T1> inputClass1,\n             ObjectMapper mapper2, String desc2,\n             T2 inputValue2, Class<T2> inputClass2)\n     {\n         final byte[] byteInput1 = mapper1.writeValueAsBytes(inputValue1);\n         final byte[] byteInput2 = mapper2.writeValueAsBytes(inputValue2);\n-\n+        // Let's try to guestimate suitable size... to get to N megs to process\n+        REPS = (int) ((double) (8 * 1000 * 1000) / (double) byteInput1.length);\n+\n+        // sanity check:\n+        /*T1 back1 =*/ mapper1.readValue(byteInput1, inputClass1);\n+        /*T2 back2 =*/ mapper2.readValue(byteInput2, inputClass2);\n+        System.out.println(\"Input successfully round-tripped for both styles...\");\n+        \n+        doTest(mapper1, desc1, byteInput1, inputClass1, mapper2, desc2, byteInput2, inputClass2);\n+    }\n+    \n+    protected <T1, T2> void testFromString(ObjectMapper mapper1, String desc1,\n+            T1 inputValue1, Class<T1> inputClass1,\n+            ObjectMapper mapper2, String desc2,\n+            T2 inputValue2, Class<T2> inputClass2)\n+        throws Exception\n+    {\n+        final String input1 = mapper1.writeValueAsString(inputValue1);\n+        final String input2 = mapper2.writeValueAsString(inputValue2);\n+        // Let's try to guestimate suitable size... to get to N megs to process\n+        REPS = (int) ((double) (8 * 1000 * 1000) / (double) input1.length());\n+\n+        // sanity check:\n+        /*T1 back1 =*/ mapper1.readValue(input1, inputClass1);\n+        /*T2 back2 =*/ mapper2.readValue(input2, inputClass2);\n+        System.out.println(\"Input successfully round-tripped for both styles...\");\n+        \n+        doTest(mapper1, desc1, input1, inputClass1, mapper2, desc2, input2, inputClass2);\n+    }\n+    \n+    protected void doTest(ObjectMapper mapper1, String desc1,\n+            byte[] byteInput1, Class<?> inputClass1,\n+            ObjectMapper mapper2, String desc2,\n+            byte[] byteInput2, Class<?> inputClass2)\n+        throws Exception\n+    {\n         desc1 = String.format(\"%s (%d bytes)\", desc1, byteInput1.length);\n         desc2 = String.format(\"%s (%d bytes)\", desc2, byteInput2.length);\n \n-        // sanity check:\n-        {\n-            /*T1 back1 =*/ mapper1.readValue(byteInput1, inputClass1);\n-            /*T2 back2 =*/ mapper2.readValue(byteInput2, inputClass2);\n-            System.out.println(\"Input successfully round-tripped for both styles...\");\n-        }\n-\n-        // Let's try to guestimate suitable size... to get to N megs to process\n-        final int REPS = (int) ((double) (8 * 1000 * 1000) / (double) byteInput1.length);\n-\n         System.out.printf(\"Read %d bytes to bind (%d as array); will do %d repetitions\\n\",\n                 byteInput1.length, byteInput2.length, REPS);\n \n                 .withType(inputClass2);\n         \n         int i = 0;\n-        int roundsDone = 0;\n         final int TYPES = 2;\n-        final int WARMUP_ROUNDS = 5;\n \n         final long[] times = new long[TYPES];\n-        \n         while (true) {\n-            try {  Thread.sleep(100L); } catch (InterruptedException ie) { }\n-            int round = (i++ % TYPES);\n+            Thread.sleep(100L);\n+            int type = (i++ % TYPES);\n \n             String msg;\n-            boolean lf = (round == 0);\n-\n             long msecs;\n             \n-            switch (round) {\n+            switch (type) {\n             case 0:\n                 msg = desc1;\n                 msecs = testDeser(REPS, byteInput1, jsonReader);\n             default:\n                 throw new Error();\n             }\n-\n-            // skip first 5 rounds to let results stabilize\n-            if (roundsDone >= WARMUP_ROUNDS) {\n-                times[round] += msecs;\n+            updateStats(type, (i % 17) == 0, msg, msecs, times);\n+        }\n+    }\n+\n+    protected void doTest(ObjectMapper mapper1, String desc1,\n+            String input1, Class<?> inputClass1,\n+            ObjectMapper mapper2, String desc2,\n+            String input2, Class<?> inputClass2)\n+        throws Exception\n+    {\n+        desc1 = String.format(\"%s (%d bytes)\", desc1, input1.length());\n+        desc2 = String.format(\"%s (%d bytes)\", desc2, input2.length());\n+\n+        System.out.printf(\"Read %d bytes to bind (%d as array); will do %d repetitions\\n\",\n+                input1.length(), input2.length(), REPS);\n+\n+        final ObjectReader jsonReader = mapper1.reader()\n+                .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n+                .withType(inputClass1);\n+        final ObjectReader arrayReader = mapper2.reader()\n+                .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n+                .withType(inputClass2);\n+        \n+        int i = 0;\n+        final int TYPES = 2;\n+\n+        final long[] times = new long[TYPES];\n+        while (true) {\n+            Thread.sleep(100L);\n+            int type = (i++ % TYPES);\n+\n+            String msg;\n+            long msecs;\n+            \n+            switch (type) {\n+            case 0:\n+                msg = desc1;\n+                msecs = testDeser(REPS, input1, jsonReader);\n+                break;\n+            case 1:\n+                msg = desc2;\n+                msecs = testDeser(REPS, input2, arrayReader);\n+                break;\n+            default:\n+                throw new Error();\n             }\n-            \n-            System.out.printf(\"Test '%s' [hash: 0x%s] -> %d msecs\\n\", msg, this.hash, msecs);\n-            if (lf) {\n-                ++roundsDone;\n-                if ((roundsDone % 3) == 0 && roundsDone > WARMUP_ROUNDS) {\n-                    double den = (double) (roundsDone - WARMUP_ROUNDS);\n-                    System.out.printf(\"Averages after %d rounds (Object / Array): %.1f / %.1f msecs\\n\",\n-                            (int) den,\n-                            times[0] / den, times[1] / den);\n-                            \n-                }\n-                System.out.println();\n+            updateStats(type, (i % 17) == 0, msg, msecs, times);\n+        }\n+    }\n+    \n+    private void updateStats(int type, boolean doGc, String msg, long msecs, long[] times)\n+        throws Exception\n+    {\n+        // skip first N rounds to let results stabilize\n+        if (roundsDone >= WARMUP_ROUNDS) {\n+            times[type] += msecs;\n+        }\n+        System.out.printf(\"Test '%s' [hash: 0x%s] -> %d msecs\\n\", msg, this.hash, msecs);\n+        if (type == 0) {\n+            ++roundsDone;\n+            if ((roundsDone % 3) == 0 && roundsDone > WARMUP_ROUNDS) {\n+                double den = (double) (roundsDone - WARMUP_ROUNDS);\n+                System.out.printf(\"Averages after %d rounds (Object / Array): %.1f / %.1f msecs\\n\",\n+                        (int) den,\n+                        times[0] / den, times[1] / den);\n+                        \n             }\n-            if ((i % 17) == 0) {\n-                System.out.println(\"[GC]\");\n-                Thread.sleep(100L);\n-                System.gc();\n-                Thread.sleep(100L);\n-            }\n-        }\n-    }\n-\n-    private final long testDeser(int REPS, byte[] input, ObjectReader reader) throws Exception\n+            System.out.println();\n+        }\n+        if (doGc) {\n+            System.out.println(\"[GC]\");\n+            Thread.sleep(100L);\n+            System.gc();\n+            Thread.sleep(100L);\n+        }\n+    }\n+    \n+    private final long testDeser(int reps, byte[] input, ObjectReader reader) throws Exception\n     {\n         long start = System.currentTimeMillis();\n         Object result = null;\n-        while (--REPS >= 0) {\n+        while (--reps >= 0) {\n             result = reader.readValue(input);\n         }\n         hash = result.hashCode();\n         return System.currentTimeMillis() - start;\n     }\n \n+    private final long testDeser(int reps, String input, ObjectReader reader) throws Exception\n+    {\n+        long start = System.currentTimeMillis();\n+        Object result = null;\n+        while (--reps >= 0) {\n+            result = reader.readValue(input);\n+        }\n+        hash = result.hashCode();\n+        return System.currentTimeMillis() - start;\n+    }\n+    \n     public static byte[] readAll(String filename) throws IOException\n     {\n         File f = new File(filename);", "timestamp": 1398029411, "metainfo": ""}