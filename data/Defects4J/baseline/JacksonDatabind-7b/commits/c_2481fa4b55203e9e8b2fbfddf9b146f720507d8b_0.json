{"sha": "2481fa4b55203e9e8b2fbfddf9b146f720507d8b", "log": "Fixed [JACKSON-811]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n {\n     protected final JavaType _baseType;\n \n+    protected final ObjectIdReader _objectIdReader;\n+    \n     // support for \"native\" types, which require special care:\n     \n     protected final boolean _acceptString;\n     protected final boolean _acceptInt;\n     protected final boolean _acceptDouble;\n     \n-    public AbstractDeserializer(JavaType bt)\n+    public AbstractDeserializer(JavaType bt, ObjectIdReader oir)\n     {\n         _baseType = bt;\n+        _objectIdReader = oir;\n         Class<?> cls = bt.getRawClass();\n         _acceptString = cls.isAssignableFrom(String.class);\n         _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class);\n         _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Public accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isCachable() { return true; }\n+    \n+    /**\n+     * Overridden to return true for those instances that are\n+     * handling value for which Object Identity handling is enabled\n+     * (either via value type or referring property).\n+     */\n+    @Override\n+    public ObjectIdReader getObjectIdReader() {\n+        return _objectIdReader;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserializer implementation\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n+        // Hmmh. One tricky question; for scalar, is it an Object Id, or \"Natural\" type?\n+\n+        // for now, prefer Object Id:\n+        if (_objectIdReader != null) {\n+            JsonToken t = jp.getCurrentToken();\n+            // should be good enough check; we only care about Strings, integral numbers:\n+            if (t != null && t.isScalarValue()) {\n+                return _deserializeFromObjectId(jp, ctxt);\n+            }\n+        }\n+        \n         // First: support \"natural\" values (which are always serialized without type info!)\n         Object result = _deserializeIfNatural(jp, ctxt);\n         if (result != null) {\n                 \"abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information\");\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n     protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n         }\n         return null;\n     }\n+\n+    /**\n+     * Method called in cases where it looks like we got an Object Id\n+     * to parse and use as a reference.\n+     */\n+    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        Object id = _objectIdReader.deserializer.deserialize(jp, ctxt);\n+        ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator);\n+        // do we have it resolved?\n+        Object pojo = roid.item;\n+        if (pojo == null) { // not yet; should wait...\n+            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n+        }\n+        return pojo;\n+    }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n         // do we have it resolved?\n         Object pojo = roid.item;\n         if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- illegal forward-reference?\");\n+            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n         }\n         return pojo;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n                 anyViews);\n     }\n \n+    /**\n+     * Alternate build method used when we must be using some form of\n+     * abstract resolution, usually by using addition Type Id\n+     * (\"polymorphic deserialization\")\n+     * \n+     * @since 2.0\n+     */\n+    public AbstractDeserializer buildAbstract()\n+    {\n+        return new AbstractDeserializer(_beanDesc.getType(), _objectIdReader);\n+    }\n+    \n     /**\n      * Method for constructing a specialized deserializer that uses\n      * additional external Builder object during data binding.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n     {\n         // First: check what creators we can use, if any\n         ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n-        // ... since often we have nothing to go on, if we have abstract type:\n-        if (type.isAbstract()) {\n-            if (!valueInstantiator.canInstantiate()) {\n-                // and if so, need placeholder deserializer\n-                return new AbstractDeserializer(type);\n-            }\n-        }\n         BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(ctxt, beanDesc);\n         builder.setValueInstantiator(valueInstantiator);\n          // And then setters for deserializing from JSON Object\n         // managed/back reference fields/setters need special handling... first part\n         addReferenceProperties(ctxt, beanDesc, builder);\n         addInjectables(ctxt, beanDesc, builder);\n-\n+        \n         final DeserializationConfig config = ctxt.getConfig();\n         // [JACKSON-440]: update builder now that all information is in?\n         if (_factoryConfig.hasDeserializerModifiers()) {\n                 builder = mod.updateBuilder(config, beanDesc, builder);\n             }\n         }\n-        JsonDeserializer<?> deserializer = builder.build();\n+        JsonDeserializer<?> deserializer;\n+\n+        /* 19-Mar-2012, tatu: This check used to be done earlier; but we have to defer\n+         *   it a bit to collect information on ObjectIdReader, for example.\n+         */\n+        if (type.isAbstract() && !valueInstantiator.canInstantiate()) {\n+            deserializer = builder.buildAbstract();\n+        } else {\n+            deserializer = builder.build();\n+        }\n \n         // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n         if (_factoryConfig.hasDeserializerModifiers()) {\n         }\n         return (JsonDeserializer<Object>) deserializer;\n     }\n-\n+    \n     /**\n      * Method for constructing a bean deserializer that uses specified\n      * intermediate Builder for binding data, and construction of the", "timestamp": 1332205740, "metainfo": ""}