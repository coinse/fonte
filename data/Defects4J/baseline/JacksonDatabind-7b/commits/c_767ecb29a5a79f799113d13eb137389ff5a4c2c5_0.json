{"sha": "767ecb29a5a79f799113d13eb137389ff5a4c2c5", "log": "Try to add support for retaining type ids via TokenBuffer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         throws IllegalArgumentException\n     {\n         if (fromValue == null) return null;\n-        TokenBuffer buf = new TokenBuffer(this);\n+        TokenBuffer buf = new TokenBuffer(this, false);\n         JsonNode result;\n         try {\n             writeValue(buf, fromValue);\n         /* Then use TokenBuffer, which is a JsonGenerator:\n          * (see [JACKSON-175])\n          */\n-        TokenBuffer buf = new TokenBuffer(this);\n+        TokenBuffer buf = new TokenBuffer(this, false);\n         try {\n             // inlined 'writeValue' with minor changes:\n             // first: disable wrapping when writing\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.util.*;\n import java.util.concurrent.*;\n \n+import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Abstract factory base class that can provide deserializers for standard\n             BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        return JacksonDeserializers.findValueInstantiator(config, beanDesc);\n+        if (beanDesc.getBeanClass() == JsonLocation.class) {\n+            return JsonLocationInstantiator.instance;\n+        }\n+        return null;\n     }\n \n     /**\n         }\n         if (clsName.startsWith(\"com.fasterxml.\")) {\n             // and a few Jackson types as well:\n-            return JacksonDeserializers.find(rawType);\n+            if (rawType == TokenBuffer.class) {\n+                return TokenBufferDeserializer.instance;\n+            }\n+            if (JavaType.class.isAssignableFrom(rawType)) {\n+                return JavaTypeDeserializer.instance;\n+            }\n         }\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp.getCodec());\n+                unknown = new TokenBuffer(jp);\n             }\n             unknown.writeFieldName(propName);\n             unknown.copyCurrentStructure(jp);\n         if (_propertyBasedCreator != null) {\n             return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n         }\n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n         if (t == JsonToken.START_OBJECT) {\n             t = jp.nextToken();\n         }\n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n         PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n \n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n \n         JsonToken t = jp.getCurrentToken();\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n         PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n \n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n \n         JsonToken t = jp.getCurrentToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n             return deserializeFromObject(jp, ctxt);\n         }\n         // otherwise need to reorder things\n-        TokenBuffer tmpBuffer = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tmpBuffer = new TokenBuffer(jp);\n         TokenBuffer mergedBuffer = null;\n         for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             // when we match the id property, can start merging\n             if (mergedBuffer == null) {\n                 if (idPropName.equals(propName)) {\n-                    mergedBuffer = new TokenBuffer(jp.getCodec());\n+                    mergedBuffer = new TokenBuffer(jp);\n                     mergedBuffer.writeFieldName(propName);\n                     jp.nextToken();\n                     mergedBuffer.copyCurrentStructure(jp);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp.getCodec());\n+                unknown = new TokenBuffer(jp);\n             }\n             unknown.writeFieldName(propName);\n             unknown.copyCurrentStructure(jp);\n         if (_propertyBasedCreator != null) {\n             return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n         }\n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n         Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n         if (t == JsonToken.START_OBJECT) {\n             t = jp.nextToken();\n         }\n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n         PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n \n-        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        TokenBuffer tokens = new TokenBuffer(jp);\n         tokens.writeStartObject();\n \n         JsonToken t = jp.getCurrentToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n             canDeserialize = (bean != null) && (_tokens[index] != null);\n         } else {\n             @SuppressWarnings(\"resource\")\n-            TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+            TokenBuffer tokens = new TokenBuffer(jp);\n             tokens.copyCurrentStructure(jp);\n             _tokens[index] = tokens;\n             canDeserialize = (bean != null) && (_typeIds[index] != null);\n             int index, String typeId)\n         throws IOException, JsonProcessingException\n     {\n-        TokenBuffer merged = new TokenBuffer(jp.getCodec());\n+        TokenBuffer merged = new TokenBuffer(jp);\n         merged.writeStartArray();\n         merged.writeString(typeId);\n         JsonParser p2 = _tokens[index].asParser(jp);\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n          * style to ensure we can handle all kinds of JSON constructs.\n          */\n-        TokenBuffer merged = new TokenBuffer(jp.getCodec());\n+        TokenBuffer merged = new TokenBuffer(jp);\n         merged.writeStartArray();\n         merged.writeString(typeId);\n         JsonParser p2 = _tokens[index].asParser(jp);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JavaTypeDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+/**\n+ * Deserializer for {@link JavaType} values.\n+ */\n+public class JavaTypeDeserializer\n+    extends StdScalarDeserializer<JavaType>\n+{\n+    public final static JavaTypeDeserializer instance = new JavaTypeDeserializer();\n+    \n+    public JavaTypeDeserializer() { super(JavaType.class); }\n+    \n+    @Override\n+    public JavaType deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken curr = jp.getCurrentToken();\n+        // Usually should just get string value:\n+        if (curr == JsonToken.VALUE_STRING) {\n+            String str = jp.getText().trim();\n+            if (str.length() == 0) {\n+                return getEmptyValue();\n+            }\n+            return ctxt.getTypeFactory().constructFromCanonical(str);\n+        }\n+        // or occasionally just embedded object maybe\n+        if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            return (JavaType) jp.getEmbeddedObject();\n+        }\n+        throw ctxt.mappingException(_valueClass);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonLocationInstantiator.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.PropertyMetadata;\n+import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.deser.CreatorProperty;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+\n+/**\n+ * For {@link JsonLocation}, we should be able to just implement\n+ * {@link ValueInstantiator} (not that explicit one would be very\n+ * hard but...)\n+ */\n+public class JsonLocationInstantiator extends ValueInstantiator\n+{\n+    public final static JsonLocationInstantiator instance = new JsonLocationInstantiator();\n+    \n+    @Override\n+    public String getValueTypeDesc() {\n+        return JsonLocation.class.getName();\n+    }\n+    \n+    @Override\n+    public boolean canCreateFromObjectWith() { return true; }\n+    \n+    @Override\n+    public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n+        JavaType intType = config.constructType(Integer.TYPE);\n+        JavaType longType = config.constructType(Long.TYPE);\n+        return  new CreatorProperty[] {\n+                creatorProp(\"sourceRef\", config.constructType(Object.class), 0),\n+                creatorProp(\"byteOffset\", longType, 1),\n+                creatorProp(\"charOffset\", longType, 2),\n+                creatorProp(\"lineNr\", intType, 3),\n+                creatorProp(\"columnNr\", intType, 4)\n+        };\n+    }\n+\n+    private static CreatorProperty creatorProp(String name, JavaType type, int index) {\n+        return new CreatorProperty(new PropertyName(name), type, null,\n+                null, null, null, index, null, PropertyMetadata.STD_REQUIRED);\n+    }\n+    \n+    @Override\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) {\n+        return new JsonLocation(args[0], _long(args[1]), _long(args[2]),\n+                _int(args[3]), _int(args[4]));\n+    }\n+\n+    private final static long _long(Object o) {\n+        return (o == null) ? 0L : ((Number) o).longValue();\n+    }\n+    private final static int _int(Object o) {\n+        return (o == null) ? 0 : ((Number) o).intValue();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * We also want to directly support deserialization of {@link TokenBuffer}.\n+ *<p>\n+ * Note that we use scalar deserializer base just because we claim\n+ * to be of scalar for type information inclusion purposes; actual\n+ * underlying content can be of any (Object, Array, scalar) type.\n+ *<p>\n+ * Since 2.3, another important thing is that possible native ids\n+ * (type id, object id) should be properly copied even when converting\n+ * with {@link TokenBuffer}. Such ids are supported if (and only if!)\n+ * source {@link JsonParser} supports them.\n+ */\n+@JacksonStdImpl\n+public class TokenBufferDeserializer\n+    extends StdScalarDeserializer<TokenBuffer>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    public final static TokenBufferDeserializer instance = new TokenBufferDeserializer();\n+    \n+    public TokenBufferDeserializer() { super(TokenBuffer.class); }\n+\n+    @Override\n+    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        TokenBuffer tb = new TokenBuffer(jp);\n+        // quite simple, given that TokenBuffer is a JsonGenerator:\n+        tb.copyCurrentStructure(jp);\n+        return tb;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n         // Minor complication: we may need to merge type id in?\n         if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n-            TokenBuffer tb = new TokenBuffer(null);\n+            TokenBuffer tb = new TokenBuffer(null, false);\n             tb.writeStartObject(); // recreate START_OBJECT\n             tb.writeFieldName(_typePropertyName);\n             tb.writeString(typeId);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n                 return _deserializeTypedForId(jp, ctxt, tb);\n             }\n             if (tb == null) {\n-                tb = new TokenBuffer(null);\n+                tb = new TokenBuffer(null, false);\n             }\n             tb.writeFieldName(name);\n             tb.copyCurrentStructure(jp);\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         if (_typeIdVisible) { // need to merge id back in JSON input?\n             if (tb == null) {\n-                tb = new TokenBuffer(null);\n+                tb = new TokenBuffer(null, false);\n             }\n             tb.writeFieldName(jp.getCurrentName());\n             tb.writeString(typeId);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n         // Minor complication: we may need to merge type id in?\n         if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n-            TokenBuffer tb = new TokenBuffer(null);\n+            TokenBuffer tb = new TokenBuffer(null, false);\n             tb.writeStartObject(); // recreate START_OBJECT\n             tb.writeFieldName(_typePropertyName);\n             tb.writeString(typeId);\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n  * accessing contents of JSON tree in alternate form (stream of tokens).\n  * Useful when a streaming source is expected by code, such as data binding\n  * functionality.\n- * \n- * @author tatu\n  */\n public class TreeTraversingParser extends ParserMinimalBase\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n  */\n     extends JsonGenerator\n {\n-    protected final static int DEFAULT_PARSER_FEATURES = JsonParser.Feature.collectDefaults();\n+    protected final static int DEFAULT_GENERATOR_FEATURES = JsonGenerator.Feature.collectDefaults();\n \n     /*\n     /**********************************************************\n     protected int _generatorFeatures;\n \n     protected boolean _closed;\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected final boolean _hasNativeTypeIds;\n     \n     /*\n     /**********************************************************\n      * @param codec Object codec to use for stream-based object\n      *   conversion through parser/generator interfaces. If null,\n      *   such methods can not be used.\n-     */\n-    public TokenBuffer(ObjectCodec codec)\n+     *   \n+     * @deprecated since 2.3 preferred variant is one that takes {@link JsonParser} or additional boolean parameter.\n+     */\n+    @Deprecated\n+    public TokenBuffer(ObjectCodec codec) {\n+        this(codec, false);\n+    }\n+\n+    /**\n+     * @param codec Object codec to use for stream-based object\n+     *   conversion through parser/generator interfaces. If null,\n+     *   such methods can not be used.\n+     * @param nativeTypeIds Whether resulting {@link JsonParser} (if created)\n+     *   is considered to support native type ids\n+     */\n+    public TokenBuffer(ObjectCodec codec, boolean nativeTypeIds)\n     {\n         _objectCodec = codec;\n-        _generatorFeatures = DEFAULT_PARSER_FEATURES;\n+        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n         _writeContext = JsonWriteContext.createRootContext();\n         // at first we have just one segment\n         _first = _last = new Segment();\n         _appendOffset = 0;\n-    }\n-\n+        _hasNativeTypeIds = nativeTypeIds;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public TokenBuffer(JsonParser jp)\n+    {\n+        _objectCodec = jp.getCodec();\n+        _generatorFeatures = DEFAULT_GENERATOR_FEATURES;\n+        _writeContext = JsonWriteContext.createRootContext();\n+        // at first we have just one segment\n+        _first = _last = new Segment();\n+        _appendOffset = 0;\n+        _hasNativeTypeIds = jp.canReadTypeId();\n+    }\n+    \n     @Override\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     @Override\n     public void copyCurrentEvent(JsonParser jp) throws IOException, JsonProcessingException\n     {\n+        if (_hasNativeTypeIds) {\n+            _copyTypeId(jp);\n+        }\n         switch (jp.getCurrentToken()) {\n         case START_OBJECT:\n             writeStartObject();\n             writeNull();\n             break;\n         case VALUE_EMBEDDED_OBJECT:\n+            if (_hasNativeTypeIds) {\n+                _copyTypeId(jp);\n+            }\n             writeObject(jp.getEmbeddedObject());\n             break;\n         default:\n         }\n     }\n \n+    protected void _copyTypeId(JsonParser jp) throws IOException, JsonProcessingException\n+    {\n+        String typeId = jp.getTypeId();\n+        if (typeId != null) {\n+            writeTypeId(typeId);\n+        }\n+    }\n+    \n     @Override\n     public void copyCurrentStructure(JsonParser jp) throws IOException, JsonProcessingException {\n         JsonToken t = jp.getCurrentToken();\n \n         switch (t) {\n         case START_ARRAY:\n+            if (_hasNativeTypeIds) {\n+                _copyTypeId(jp);\n+            }\n             writeStartArray();\n             while (jp.nextToken() != JsonToken.END_ARRAY) {\n                 copyCurrentStructure(jp);\n             writeEndArray();\n             break;\n         case START_OBJECT:\n+            if (_hasNativeTypeIds) {\n+                _copyTypeId(jp);\n+            }\n             writeStartObject();\n             while (jp.nextToken() != JsonToken.END_OBJECT) {\n                 copyCurrentStructure(jp);\n     protected final static class Parser\n         extends ParserMinimalBase\n     {\n+        /*\n+        /**********************************************************\n+        /* Configuration\n+        /**********************************************************\n+         */\n+\n         protected ObjectCodec _codec;\n \n+        /**\n+         * @since 2.3\n+         */\n+        protected final boolean _hasNativeTypeIds;\n+        \n         /*\n         /**********************************************************\n         /* Parsing state\n         /* Construction, init\n         /**********************************************************\n          */\n-        \n-        public Parser(Segment firstSeg, ObjectCodec codec)\n+\n+        @Deprecated // since 2.3\n+        public Parser(Segment firstSeg, ObjectCodec codec) {\n+            this(firstSeg, codec, false);\n+        }\n+\n+        /**\n+         * @since 2.3\n+         */\n+        public Parser(Segment firstSeg, ObjectCodec codec, boolean hasNativeTypeIds)\n         {\n             super(0);\n             _segment = firstSeg;\n             _segmentPtr = -1; // not yet read\n             _codec = codec;\n             _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+            _hasNativeTypeIds = hasNativeTypeIds;\n         }\n \n         public void setLocation(JsonLocation l) {\n             throw new IllegalStateException(\"Internal error: entry should be a Number, but is of type \"\n                     +value.getClass().getName());\n         }\n-        \n+\n         /*\n         /**********************************************************\n         /* Public API, access to token information, other\n         }\n \n         @Override\n-        public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException, JsonParseException\n+        public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n+            throws IOException, JsonParseException\n         {\n             byte[] data = getBinaryValue(b64variant);\n             if (data != null) {\n                 return data.length;\n             }\n             return 0;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Public API, native ids\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public boolean canReadTypeId() {\n+            return _hasNativeTypeIds;\n+        }\n+\n+        @Override\n+        public String getTypeId() throws IOException, JsonParseException\n+        {\n+            if (!_hasNativeTypeIds) {\n+                return super.getTypeId();\n+            }\n+            // !! TODO\n+            return null;\n         }\n         \n         /*\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n         // [JACKSON-393] fix:\n \n         // first, null should come as null\n-        TokenBuffer buf = new TokenBuffer(null);\n+        TokenBuffer buf = new TokenBuffer(null, false);\n         buf.writeObject(null);\n         assertNull(MAPPER.readValue(buf.asParser(), UUID.class));\n         buf.close();\n \n         // then, UUID itself come as is:\n-        buf = new TokenBuffer(null);\n+        buf = new TokenBuffer(null, false);\n         buf.writeObject(value);\n         assertSame(value, MAPPER.readValue(buf.asParser(), UUID.class));\n \n         assertEquals(value, MAPPER.readValue(\"\\\"\"+value.toString()+\"\\\"\", URL.class));\n \n         // trivial case; null to null, embedded URL to URL\n-        TokenBuffer buf = new TokenBuffer(null);\n+        TokenBuffer buf = new TokenBuffer(null, false);\n         buf.writeObject(null);\n         assertNull(MAPPER.readValue(buf.asParser(), URL.class));\n         buf.close();\n \n         // then, UUID itself come as is:\n-        buf = new TokenBuffer(null);\n+        buf = new TokenBuffer(null, false);\n         buf.writeObject(value);\n         assertSame(value, MAPPER.readValue(buf.asParser(), URL.class));\n         buf.close();\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n \n         // Ok, first test JSON Object containing buffer:\n-        TokenBuffer buf = new TokenBuffer(mapper);\n+        TokenBuffer buf = new TokenBuffer(mapper, false);\n         buf.writeStartObject();\n         buf.writeNumberField(\"num\", 42);\n         buf.writeEndObject();\n         buf.close();\n \n         // then as an array:\n-        buf = new TokenBuffer(mapper);\n+        buf = new TokenBuffer(mapper, false);\n         buf.writeStartArray();\n         buf.writeBoolean(true);\n         buf.writeEndArray();\n         buf.close();\n \n         // and finally as scalar\n-        buf = new TokenBuffer(mapper);\n+        buf = new TokenBuffer(mapper, false);\n         buf.writeNumber(321);\n         json = mapper.writeValueAsString(new ObjectHolder(buf));\n         holder = mapper.readValue(json, ObjectHolder.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n \n     public void testEmbeddedObject() throws Exception\n     {\n-        TokenBuffer buf = new TokenBuffer(MAPPER);\n+        TokenBuffer buf = new TokenBuffer(MAPPER, false);\n         buf.writeObject(new byte[3]);\n         JsonNode node = MAPPER.readTree(buf.asParser());\n         buf.close();\n \n     public void testEmbeddedObjectInArray() throws Exception\n     {\n-        TokenBuffer buf = new TokenBuffer(MAPPER);\n+        TokenBuffer buf = new TokenBuffer(MAPPER, false);\n         buf.writeStartArray();\n         buf.writeObject(MARKER);\n         buf.writeEndArray();\n \n     public void testEmbeddedObjectInObject() throws Exception\n     {\n-        TokenBuffer buf = new TokenBuffer(MAPPER);\n+        TokenBuffer buf = new TokenBuffer(MAPPER, false);\n         buf.writeStartObject();\n         buf.writeFieldName(\"pojo\");\n         buf.writeObject(MARKER);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJacksonTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJacksonTypes.java\n     {\n         // First, copy events from known good source (StringReader)\n         JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC);\n-        TokenBuffer tb = new TokenBuffer(null);\n+        TokenBuffer tb = new TokenBuffer(null, false);\n         while (jp.nextToken() != null) {\n             tb.copyCurrentEvent(jp);\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n      */\n     public void testSimpleWrites() throws IOException\n     {\n-        TokenBuffer buf = new TokenBuffer(null); // no ObjectCodec\n+        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec\n \n         // First, with empty buffer\n         JsonParser jp = buf.asParser();\n \n     public void testSimpleArray() throws IOException\n     {\n-        TokenBuffer buf = new TokenBuffer(null); // no ObjectCodec\n+        TokenBuffer buf = new TokenBuffer(null, false); // no ObjectCodec\n \n         // First, empty array\n         assertTrue(buf.getOutputContext().inRoot());\n         buf.close();\n \n         // Then one with simple contents\n-        buf = new TokenBuffer(null);\n+        buf = new TokenBuffer(null, false);\n         buf.writeStartArray();\n         buf.writeBoolean(true);\n         buf.writeNull();\n         buf.close();\n \n         // And finally, with array-in-array\n-        buf = new TokenBuffer(null);\n+        buf = new TokenBuffer(null, false);\n         buf.writeStartArray();\n         buf.writeStartArray();\n         buf.writeBinary(new byte[3]);\n \n     public void testSimpleObject() throws IOException\n     {\n-        TokenBuffer buf = new TokenBuffer(null);\n+        TokenBuffer buf = new TokenBuffer(null, false);\n \n         // First, empty JSON Object\n         assertTrue(buf.getOutputContext().inRoot());\n         buf.close();\n \n         // Then one with simple contents\n-        buf = new TokenBuffer(null);\n+        buf = new TokenBuffer(null, false);\n         buf.writeStartObject();\n         buf.writeNumberField(\"num\", 1.25);\n         buf.writeEndObject();\n     {\n         // First, copy events from known good source (StringReader)\n         JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC);\n-        TokenBuffer tb = new TokenBuffer(null);\n+        TokenBuffer tb = new TokenBuffer(null, false);\n         while (jp.nextToken() != null) {\n             tb.copyCurrentEvent(jp);\n         }\n \n     public void testAppend() throws IOException\n     {\n-        TokenBuffer buf1 = new TokenBuffer(null);\n+        TokenBuffer buf1 = new TokenBuffer(null, false);\n         buf1.writeStartObject();\n         buf1.writeFieldName(\"a\");\n         buf1.writeBoolean(true);\n         \n-        TokenBuffer buf2 = new TokenBuffer(null);\n+        TokenBuffer buf2 = new TokenBuffer(null, false);\n         buf2.writeFieldName(\"b\");\n         buf2.writeNumber(13);\n         buf2.writeEndObject();\n     public void testWithJsonParserSequenceSimple() throws IOException\n     {\n         // Let's join a TokenBuffer with JsonParser first\n-        TokenBuffer buf = new TokenBuffer(null);\n+        TokenBuffer buf = new TokenBuffer(null, false);\n         buf.writeStartArray();\n         buf.writeString(\"test\");\n         JsonParser jp = createParserUsingReader(\"[ true, null ]\");\n     @SuppressWarnings(\"resource\")\n     public void testWithMultipleJsonParserSequences() throws IOException\n     {\n-        TokenBuffer buf1 = new TokenBuffer(null);\n+        TokenBuffer buf1 = new TokenBuffer(null, false);\n         buf1.writeStartArray();\n-        TokenBuffer buf2 = new TokenBuffer(null);\n+        TokenBuffer buf2 = new TokenBuffer(null, false);\n         buf2.writeString(\"a\");\n-        TokenBuffer buf3 = new TokenBuffer(null);\n+        TokenBuffer buf3 = new TokenBuffer(null, false);\n         buf3.writeNumber(13);\n-        TokenBuffer buf4 = new TokenBuffer(null);\n+        TokenBuffer buf4 = new TokenBuffer(null, false);\n         buf4.writeEndArray();\n \n         JsonParserSequence seq1 = JsonParserSequence.createFlattened(buf1.asParser(), buf2.asParser());", "timestamp": 1375661840, "metainfo": ""}