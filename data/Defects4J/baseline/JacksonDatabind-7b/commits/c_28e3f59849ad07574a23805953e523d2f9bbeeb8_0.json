{"sha": "28e3f59849ad07574a23805953e523d2f9bbeeb8", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.IndexedStringListSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.StringArraySerializer;\n+import com.fasterxml.jackson.databind.ser.impl.StringCollectionSerializer;\n import com.fasterxml.jackson.databind.ser.std.*;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n         // Important: do NOT use standard serializers if non-standard element value serializer specified\n         if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n             if (String[].class == raw) {\n-                return new StdArraySerializers.StringArraySerializer(property);\n+                return new StringArraySerializer(property);\n             } else {\n                 // other standard types?\n                 JsonSerializer<?> ser = _arraySerializers.get(raw.getName());\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StaticListSerializerBase;\n+\n+/**\n+ * Efficient implement for serializing {@link List}s that contains Strings and are random-accessible.\n+ * The only complexity is due to possibility that serializer for {@link String}\n+ * may be overridde; because of this, logic is needed to ensure that the default\n+ * serializer is in use to use fastest mode, or if not, to defer to custom\n+ * String serializer.\n+ */\n+@JacksonStdImpl\n+public final class IndexedStringListSerializer\n+    extends StaticListSerializerBase<List<String>>\n+    implements ContextualSerializer\n+{\n+    protected final JsonSerializer<String> _serializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public IndexedStringListSerializer() {\n+        this(null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public IndexedStringListSerializer(JsonSerializer<?> ser) {\n+        super(List.class, null);\n+        _serializer = (JsonSerializer<String>) ser;\n+        \n+    }\n+\n+    @Override protected JsonNode contentSchema() {\n+        return createSchemaNode(\"string\", true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Post-processing\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = _serializer;\n+        if (ser == null) {\n+            ser = provider.findValueSerializer(String.class, _property);\n+        } else if (ser instanceof ContextualSerializer) {\n+            ser = ((ContextualSerializer) ser).createContextual(provider, property);\n+        }\n+        // Optimization: default serializer just writes String, so we can avoid a call:\n+        if (isDefaultSerializer(ser)) {\n+            ser = null;\n+        }\n+        // note: will never have TypeSerializer, because Strings are \"natural\" type\n+        if (ser == _serializer) {\n+            return this;\n+        }\n+        return new IndexedStringListSerializer(ser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartArray();\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n+    public void serializeWithType(List<String> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForArray(value, jgen);\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForArray(value, jgen);\n+    }\n+    \n+    private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        int i = 0;\n+        try {\n+            final int len = value.size();\n+            for (; i < len; ++i) {\n+                String str = value.get(i);\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    jgen.writeString(str);\n+                }\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(provider, e, value, i);\n+        }\n+    }\n+\n+    private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        int i = 0;\n+        try {\n+            final int len = value.size();\n+            final JsonSerializer<String> ser = _serializer;\n+            for (i = 0; i < len; ++i) {\n+                String str = value.get(i);\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    ser.serialize(str, jgen, provider);\n+                }\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(provider, e, value, i);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n+import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.ser.std.ArraySerializerBase;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Standard serializer used for <code>String[]</code> values.\n+ */\n+@JacksonStdImpl\n+public class StringArraySerializer\n+    extends ArraySerializerBase<String[]>\n+    implements ResolvableSerializer\n+{\n+    /* Note: not clean in general, but we are betting against\n+     * anyone re-defining properties of String.class here...\n+     */\n+    private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(String.class);\n+        \n+    /**\n+     * Value serializer to use, if it's not the standard one\n+     * (if it is we can optimize serialization a lot)\n+     */\n+    protected JsonSerializer<Object> _elementSerializer;\n+\n+    public StringArraySerializer(BeanProperty prop) {\n+        super(String[].class, null, prop);\n+    }\n+\n+    /**\n+     * Strings never add type info; hence, even if type serializer is suggested,\n+     * we'll ignore it...\n+     */\n+    @Override\n+    public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        return this;\n+    }\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return VALUE_TYPE;\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> getContentSerializer() {\n+        return _elementSerializer;\n+    }\n+    \n+    @Override\n+    public boolean isEmpty(String[] value) {\n+        return (value == null) || (value.length == 0);\n+    }\n+    \n+    @Override\n+    public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int len = value.length;\n+        if (len == 0) {\n+            return;\n+        }\n+        if (_elementSerializer != null) {\n+            serializeContentsSlow(value, jgen, provider, _elementSerializer);\n+            return;\n+        }\n+        /* 08-Dec-2008, tatus: If we want this to be fully overridable\n+         *  (for example, to support String cleanup during writing\n+         *  or something), we should find serializer  by provider.\n+         *  But for now, that seems like an overkill: and caller can\n+         *  add custom serializer if that is needed as well.\n+         * (ditto for null values)\n+         */\n+        //JsonSerializer<String> ser = (JsonSerializer<String>)provider.findValueSerializer(String.class);\n+        for (int i = 0; i < len; ++i) {\n+            String str = value[i];\n+            if (str == null) {\n+                jgen.writeNull();\n+            } else {\n+                //ser.serialize(value[i], jgen, provider);\n+                jgen.writeString(value[i]);\n+            }\n+        }\n+    }\n+\n+    private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        for (int i = 0, len = value.length; i < len; ++i) {\n+            String str = value[i];\n+            if (str == null) {\n+                provider.defaultSerializeNull(jgen);\n+            } else {\n+                ser.serialize(value[i], jgen, provider);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Need to get callback to resolve value serializer, which may\n+     * be overridden by custom serializer\n+     */\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> ser = provider.findValueSerializer(String.class, _property);\n+        // Retain if not the standard implementation\n+        if (ser != null && ser.getClass().getAnnotation(JacksonStdImpl.class) == null) {\n+            _elementSerializer = ser;\n+        }\n+    }        \n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        o.put(\"items\", createSchemaNode(\"string\"));\n+        return o;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StaticListSerializerBase;\n+\n+/**\n+ * Efficient implement for serializing {@link Collection}s that contain Strings.\n+ * The only complexity is due to possibility that serializer for {@link String}\n+ * may be overridde; because of this, logic is needed to ensure that the default\n+ * serializer is in use to use fastest mode, or if not, to defer to custom\n+ * String serializer.\n+ */\n+@JacksonStdImpl\n+public class StringCollectionSerializer\n+    extends StaticListSerializerBase<Collection<String>>\n+    implements ContextualSerializer\n+{\n+    protected final JsonSerializer<String> _serializer;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public StringCollectionSerializer() {\n+        this(null);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected StringCollectionSerializer(JsonSerializer<?> ser)\n+    {\n+        super(Collection.class, null);\n+        _serializer = (JsonSerializer<String>) ser;\n+    }        \n+    \n+    @Override protected JsonNode contentSchema() {\n+        return createSchemaNode(\"string\", true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Post-processing\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = _serializer;\n+        if (ser == null) {\n+            ser = provider.findValueSerializer(String.class, _property);\n+        } else if (ser instanceof ContextualSerializer) {\n+            ser = ((ContextualSerializer) ser).createContextual(provider, property);\n+        }\n+        // Optimization: default serializer just writes String, so we can avoid a call:\n+        if (isDefaultSerializer(ser)) {\n+            ser = null;\n+        }\n+        // note: will never have TypeSerializer, because Strings are \"natural\" type\n+        if (ser == _serializer) {\n+            return this;\n+        }\n+        return new StringCollectionSerializer(ser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartArray();\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n+    public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForArray(value, jgen);\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForArray(value, jgen);\n+    }\n+    \n+    private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_serializer != null) {\n+            serializeUsingCustom(value, jgen, provider);\n+            return;\n+        }\n+        int i = 0;\n+        for (String str : value) {\n+            try {\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    jgen.writeString(str);\n+                }\n+                ++i;\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, i);\n+            }\n+        }\n+    }\n+\n+    private void serializeUsingCustom(Collection<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<String> ser = _serializer;\n+        int i = 0;\n+        for (String str : value) {\n+            try {\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    ser.serialize(str, jgen, provider);\n+                }\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, i);\n+            }\n+       }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n-import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n     protected StdArraySerializers() { }\n \n     /*\n-    /**********************************************************\n-    /* Base classes\n-    /**********************************************************\n-     */\n-\n-    /*\n      ****************************************************************\n     /* Concrete serializers, arrays\n      ****************************************************************\n      */\n \n-    /**\n-     * Standard serializer used for <code>String[]</code> values.\n-     */\n-    @JacksonStdImpl\n-    public final static class StringArraySerializer\n-        extends ArraySerializerBase<String[]>\n-        implements ResolvableSerializer\n-    {\n-        /* Note: not clean in general, but we are betting against\n-         * anyone re-defining properties of String.class here...\n-         */\n-        private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(String.class);\n-            \n-        /**\n-         * Value serializer to use, if it's not the standard one\n-         * (if it is we can optimize serialization a lot)\n-         */\n-        protected JsonSerializer<Object> _elementSerializer;\n-\n-        public StringArraySerializer(BeanProperty prop) {\n-            super(String[].class, null, prop);\n-        }\n-\n-        /**\n-         * Strings never add type info; hence, even if type serializer is suggested,\n-         * we'll ignore it...\n-         */\n-        @Override\n-        public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n-            return this;\n-        }\n-\n-        @Override\n-        public JavaType getContentType() {\n-            return VALUE_TYPE;\n-        }\n-\n-        @Override\n-        public JsonSerializer<?> getContentSerializer() {\n-            return _elementSerializer;\n-        }\n-        \n-        @Override\n-        public boolean isEmpty(String[] value) {\n-            return (value == null) || (value.length == 0);\n-        }\n-        \n-        @Override\n-        public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n-            final int len = value.length;\n-            if (len == 0) {\n-                return;\n-            }\n-            if (_elementSerializer != null) {\n-                serializeContentsSlow(value, jgen, provider, _elementSerializer);\n-                return;\n-            }\n-            /* 08-Dec-2008, tatus: If we want this to be fully overridable\n-             *  (for example, to support String cleanup during writing\n-             *  or something), we should find serializer  by provider.\n-             *  But for now, that seems like an overkill: and caller can\n-             *  add custom serializer if that is needed as well.\n-             * (ditto for null values)\n-             */\n-            //JsonSerializer<String> ser = (JsonSerializer<String>)provider.findValueSerializer(String.class);\n-            for (int i = 0; i < len; ++i) {\n-                String str = value[i];\n-                if (str == null) {\n-                    jgen.writeNull();\n-                } else {\n-                    //ser.serialize(value[i], jgen, provider);\n-                    jgen.writeString(value[i]);\n-                }\n-            }\n-        }\n-\n-        private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider,\n-                JsonSerializer<Object> ser)\n-            throws IOException, JsonGenerationException\n-        {\n-            for (int i = 0, len = value.length; i < len; ++i) {\n-                String str = value[i];\n-                if (str == null) {\n-                    provider.defaultSerializeNull(jgen);\n-                } else {\n-                    ser.serialize(value[i], jgen, provider);\n-                }\n-            }\n-        }\n-\n-        /**\n-         * Need to get callback to resolve value serializer, which may\n-         * be overridden by custom serializer\n-         */\n-        @Override\n-        public void resolve(SerializerProvider provider)\n-            throws JsonMappingException\n-        {\n-            JsonSerializer<Object> ser = provider.findValueSerializer(String.class, _property);\n-            // Retain if not the standard implementation\n-            if (ser != null && ser.getClass().getAnnotation(JacksonStdImpl.class) == null) {\n-                _elementSerializer = ser;\n-            }\n-        }        \n-        \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"string\"));\n-            return o;\n-        }\n-    }\n \n     @JacksonStdImpl\n     public final static class BooleanArraySerializer", "timestamp": 1328061148, "metainfo": ""}