{"sha": "b37ff33bbc7885f21a208bee4f42126468f55d41", "log": "Yet more refactoring, trying to be able to pass DeserializationContext to ContextualDeserializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n-import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n-import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.NopAnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.LinkedNode;\n \n /**\n     public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n         return (T) getClassIntrospector().forCreation(this, type, this);\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Extended API: handler instantiation\n-    /**********************************************************\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n-            Class<?> deserClass)\n-    {\n-        HandlerInstantiator hi = getHandlerInstantiator();\n-        if (hi != null) {\n-            JsonDeserializer<?> deser = hi.deserializerInstance(this, annotated,\n-                    (Class<JsonDeserializer<?>>)deserClass);\n-            if (deser != null) {\n-                return (JsonDeserializer<Object>) deser;\n-            }\n-        }\n-        return (JsonDeserializer<Object>) ClassUtil.createInstance(deserClass, canOverrideAccessModifiers());\n-    }\n-\n-    public KeyDeserializer keyDeserializerInstance(Annotated annotated,\n-            Class<?> keyDeserClass)\n-    {\n-        HandlerInstantiator hi = getHandlerInstantiator();\n-        if (hi != null) {\n-            @SuppressWarnings(\"unchecked\")\n-            KeyDeserializer keyDeser = hi.keyDeserializerInstance(this, annotated,\n-                    (Class<KeyDeserializer>)keyDeserClass);\n-            if (keyDeser != null) {\n-                return (KeyDeserializer) keyDeser;\n-            }\n-        }\n-        return (KeyDeserializer) ClassUtil.createInstance(keyDeserClass, canOverrideAccessModifiers());\n-    }\n-\n-    public ValueInstantiator valueInstantiatorInstance(Annotated annotated,\n-            Class<?> instClass)\n-    {\n-        HandlerInstantiator hi = getHandlerInstantiator();\n-        if (hi != null) {\n-            @SuppressWarnings(\"unchecked\")\n-            ValueInstantiator inst = hi.valueInstantiatorInstance(this, annotated,\n-                    (Class<ValueInstantiator>)instClass);\n-            if (inst != null) {\n-                return (ValueInstantiator) inst;\n-            }\n-        }\n-        return (ValueInstantiator) ClassUtil.createInstance(instClass, canOverrideAccessModifiers());\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n      */\n     public DeserializationConfig getConfig() { return _config; }\n \n-    /**\n-     * Returns provider that can be used for dynamically locating\n-     * other deserializers during runtime.\n-     */\n-    public abstract DeserializerCache getDeserializerProvider();\n-\n     public final AnnotationIntrospector getAnnotationIntrospector() {\n         return _config.getAnnotationIntrospector();\n     }\n         return (_featureFlags & feat.getMask()) != 0;\n     }\n \n+    public final boolean isEnabled(MapperConfig.Feature feat) {\n+        return _config.isEnabled(feat);\n+    }\n+    \n+    public final boolean canOverrideAccessModifiers() {\n+        return _config.canOverrideAccessModifiers();\n+    }\n+\n     /**\n      * Convenience method for accessing the default Base64 encoding\n      * used for decoding base64 encoded binary content.\n      */\n     public abstract KeyDeserializer findKeyDeserializer(JavaType keyType,\n             BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API: handler instantiation\n+    /**********************************************************\n+     */\n+\n+    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n+            BeanProperty property, Object deserDef)\n+        throws JsonMappingException;\n+\n+    public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated,\n+            BeanProperty property, Object keyDeserClass)\n         throws JsonMappingException;\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n      * @return Deserializer instance to use\n      */\n     public abstract JsonDeserializer<?> deserializerInstance(DeserializationConfig config,\n-            Annotated annotated, Class<? extends JsonDeserializer<?>> deserClass);\n+            Annotated annotated, Class<?> deserClass);\n \n     /**\n      * Method called to get an instance of key deserializer of specified type.\n      * @return Key deserializer instance to use\n      */\n     public abstract KeyDeserializer keyDeserializerInstance(DeserializationConfig config,\n-            Annotated annotated, Class<? extends KeyDeserializer> keyDeserClass);\n+            Annotated annotated, Class<?> keyDeserClass);\n     \n     /**\n      * Method called to get an instance of serializer of specified type.\n      * @return TypeResolverBuilder instance to use\n      */\n     public abstract TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config,\n-            Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass);\n+            Annotated annotated, Class<?> builderClass);\n \n     /**\n      * Method called to get an instance of TypeIdResolver of specified type.\n      * @return TypeResolverBuilder instance to use\n      */\n     public abstract TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,\n-            Annotated annotated, Class<? extends TypeIdResolver> resolverClass);\n+            Annotated annotated, Class<?> resolverClass);\n \n     /**\n      * Method called to construct an instance of ValueInstantiator of specified type.\n      */\n     public ValueInstantiator valueInstantiatorInstance(MapperConfig<?> config,\n-            Annotated annotated, Class<? extends ValueInstantiator> resolverClass) {\n+            Annotated annotated, Class<?> resolverClass) {\n         return null;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n      */\n \n     @Override\n-    public abstract ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+    public abstract ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n             BeanDescription beanDesc)\n         throws JsonMappingException;\n \n             throws JsonMappingException;\n     \n     @Override\n-    public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n             ArrayType type, final BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n                  *   deserializers for all types (including primitive arrays) is useful\n                  *   so let's allow this\n                  */\n-                JsonDeserializer<?> custom = _findCustomArrayDeserializer(type, config, property, null, null);\n+                JsonDeserializer<?> custom = _findCustomArrayDeserializer(type,\n+                        ctxt.getConfig(), property, null, null);\n                 if (custom != null) {\n                     return custom;\n                 }\n         TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (elemTypeDeser == null) {\n-            elemTypeDeser = findTypeDeserializer(config, elemType, property);\n+            elemTypeDeser = findTypeDeserializer(ctxt.getConfig(), elemType, property);\n         }\n         // 23-Nov-2010, tatu: Custom array deserializer?\n-        JsonDeserializer<?> custom = _findCustomArrayDeserializer(type, config, property, elemTypeDeser, contentDeser);\n+        JsonDeserializer<?> custom = _findCustomArrayDeserializer(type,\n+                ctxt.getConfig(), property, elemTypeDeser, contentDeser);\n         if (custom != null) {\n             return custom;\n         }\n     }\n     \n     @Override\n-    public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n             CollectionType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (contentTypeDeser == null) {\n-            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n+            contentTypeDeser = findTypeDeserializer(ctxt.getConfig(), contentType, property);\n         }\n \n         // 23-Nov-2010, tatu: Custom deserializer?\n-        JsonDeserializer<?> custom = _findCustomCollectionDeserializer(type, config, beanDesc, property,\n+        JsonDeserializer<?> custom = _findCustomCollectionDeserializer(type,\n+                ctxt.getConfig(), beanDesc, property,\n                 contentTypeDeser, contentDeser);\n         if (custom != null) {\n             return custom;\n                 throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n             }\n             collectionClass = fallback;\n-            type = (CollectionType) config.constructSpecializedType(type, collectionClass);\n+            type = (CollectionType) ctxt.getConfig().constructSpecializedType(type, collectionClass);\n             // But if so, also need to re-check creators...\n-            beanDesc = config.introspectForCreation(type);\n-        }\n-        ValueInstantiator inst = findValueInstantiator(config, beanDesc);\n+            beanDesc = ctxt.getConfig().introspectForCreation(type);\n+        }\n+        ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n         // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n         if (contentType.getRawClass() == String.class) {\n             // no value type deserializer because Strings are one of natural/native types:\n \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n-    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n             CollectionLikeType type, final BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (contentTypeDeser == null) {\n-            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n-        }\n-        return _findCustomCollectionLikeDeserializer(type, config, beanDesc, property,\n+            contentTypeDeser = findTypeDeserializer(ctxt.getConfig(), contentType, property);\n+        }\n+        return _findCustomCollectionLikeDeserializer(type, ctxt.getConfig(), beanDesc, property,\n                 contentTypeDeser, contentDeser);\n     }\n     \n     @Override\n-    public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n             MapType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n         JavaType keyType = type.getKeyType();\n         JavaType contentType = type.getContentType();\n         \n             // But if so, also need to re-check creators...\n             beanDesc = config.introspectForCreation(type);\n         }\n-        ValueInstantiator inst = findValueInstantiator(config, beanDesc);\n+        ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n         MapDeserializer md = new MapDeserializer(type, property, inst, keyDes, contentDeser, contentTypeDeser);\n         md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n         return md;\n \n     // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n     @Override\n-    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n             MapLikeType type, final BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (contentTypeDeser == null) {\n-            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n-        }\n-        return _findCustomMapLikeDeserializer(type, config, beanDesc, property,\n-                keyDes, contentTypeDeser, contentDeser);\n+            contentTypeDeser = findTypeDeserializer(ctxt.getConfig(), contentType, property);\n+        }\n+        return _findCustomMapLikeDeserializer(type, ctxt.getConfig(),\n+                beanDesc, property, keyDes, contentTypeDeser, contentDeser);\n     }\n \n     /**\n      * Factory method for constructing serializers of {@link Enum} types.\n      */\n     @Override\n-    public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         Class<?> enumClass = type.getRawClass();\n         // 23-Nov-2010, tatu: Custom deserializer?\n-        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc, property);\n+        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass,\n+                ctxt.getConfig(), beanDesc, property);\n         if (custom != null) {\n             return custom;\n         }\n \n         // [JACKSON-193] May have @JsonCreator for static factory method:\n         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n-            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n+            if (ctxt.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n                 int argCount = factory.getParameterCount();\n                 if (argCount == 1) {\n                     Class<?> returnType = factory.getRawType();\n                     // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n                     if (returnType.isAssignableFrom(enumClass)) {\n-                        return EnumDeserializer.deserializerForCreator(config, enumClass, factory);\n+                        return EnumDeserializer.deserializerForCreator(ctxt.getConfig(), enumClass, factory);\n                     }\n                 }\n                 throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n             }\n         }\n         // [JACKSON-749] Also, need to consider @JsonValue, if one found\n-        return new EnumDeserializer(constructEnumResolver(enumClass, config, beanDesc.findJsonValueMethod()));\n+        return new EnumDeserializer(constructEnumResolver(enumClass, ctxt.getConfig(), beanDesc.findJsonValueMethod()));\n     }\n \n     @Override\n     }\n \n     @Override\n-    public KeyDeserializer createKeyDeserializer(DeserializationConfig config, JavaType type,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n+    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        final DeserializationConfig config = ctxt.getConfig();\n         if (_factoryConfig.hasKeyDeserializers()) {\n             BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n             for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n             }\n         }\n         // and if none found, standard ones:\n-        // No serializer needed if it's plain old String, or Object/untyped\n         Class<?> raw = type.getRawClass();\n         if (raw == String.class || raw == Object.class) {\n             return StdKeyDeserializers.constructStringKeyDeserializer(config, type);\n         }\n-        // Most other keys are of limited number of static types\n+        // Most other keys are for limited number of static types\n         KeyDeserializer kdes = _keyDeserializers.get(type);\n         if (kdes != null) {\n             return kdes;\n         }\n         // And then other one-offs; first, Enum:\n         if (type.isEnumType()) {\n-            return _createEnumKeyDeserializer(config, type, property);\n+            return _createEnumKeyDeserializer(ctxt, type, property);\n         }\n         // One more thing: can we find ctor(String) or valueOf(String)?\n         kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         return kdes;\n     }\n \n-    private KeyDeserializer _createEnumKeyDeserializer(DeserializationConfig config,\n+    private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n         BeanDescription beanDesc = config.introspect(type);\n-        JsonDeserializer<?> des = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo(), property);\n         if (des != null) {\n             return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n         }\n      * has annotation that tells which class to use for deserialization.\n      * Returns null if no such annotation found.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationConfig config,\n+    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n             Annotated ann, BeanProperty property)\n         throws JsonMappingException\n     {\n-        Object deserDef = config.getAnnotationIntrospector().findDeserializer(ann);\n+        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n         if (deserDef == null) {\n             return null;\n         }\n-        if (deserDef instanceof JsonDeserializer) {\n-            JsonDeserializer<Object> deser = (JsonDeserializer<Object>) deserDef;\n-            // related to [JACKSON-569], need contextualization:\n-            if (deser instanceof ContextualDeserializer<?>) {\n-                deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(config, property);\n-            }\n-            return deser;\n-        }\n-        /* Alas, there's no way to force return type of \"either class\n-         * X or Y\" -- need to throw an exception after the fact\n-         */\n-        if (!(deserDef instanceof Class)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n-        }\n-        Class<? extends JsonDeserializer<?>> deserClass = (Class<? extends JsonDeserializer<?>>) deserDef;\n-        if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n-        }\n-        JsonDeserializer<Object> deser = config.deserializerInstance(ann, deserClass);\n-        // related to [JACKSON-569], need contextualization:\n-        if (deser instanceof ContextualDeserializer<?>) {\n-            deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(config, property);\n-        }\n-        return deser;\n+        return ctxt.deserializerInstance(ann, property, deserDef);\n     }\n \n     /**\n      * using generic type passed as type reference), which is\n      * needed in some cases.\n      */\n-    protected JavaType resolveType(DeserializationConfig config,\n+    protected JavaType resolveType(DeserializationContext ctxt,\n             BeanDescription beanDesc, JavaType type, AnnotatedMember member,\n             BeanProperty property)                    \n         throws JsonMappingException\n     {\n         // [JACKSON-154]: Also need to handle keyUsing, contentUsing\n         if (type.isContainerType()) {\n-            AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+            AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n             JavaType keyType = type.getKeyType();\n             if (keyType != null) {\n                 Object kdDef = intr.findKeyDeserializer(member);\n-                if (kdDef != null) {\n-                    KeyDeserializer kd = null;\n-                    if (kdDef instanceof KeyDeserializer) {\n-                        kd = (KeyDeserializer) kdDef;\n-                    } else {\n-                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                        if (kdClass != null) {\n-                            kd = config.keyDeserializerInstance(member, kdClass);\n-                        }\n-                    }\n-                    if (kd != null) {\n-                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n-                        keyType = type.getKeyType(); // just in case it's used below\n-                    }\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(member, property, kdDef);\n+                if (kd != null) {\n+                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                    keyType = type.getKeyType(); // just in case it's used below\n                 }\n             }\n             // and all container types have content types...\n             Object cdDef = intr.findContentDeserializer(member);\n-            if (cdDef != null) {\n-                JsonDeserializer<?> cd = null;\n-                if (cdDef instanceof JsonDeserializer<?>) {\n-                    cd = (JsonDeserializer<?>) cdDef;\n-                } else {\n-                    Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n-                    if (cdClass != null) {\n-                        cd = config.deserializerInstance(member, cdClass);\n-                    }\n-                }\n-                if (cd != null) {\n-                    type = type.withContentValueHandler(cd);\n-                }\n+            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, property, cdDef);\n+            if (cd != null) {\n+                type = type.withContentValueHandler(cd);\n             }\n             /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n              *    information to use for polymorphic members; and specifically types for\n              *    ... but only applies to members (fields, methods), not classes\n              */\n             if (member instanceof AnnotatedMember) {\n-            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(config, type,\n-            \t       (AnnotatedMember) member, property);            \t\n+            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(\n+            \t        ctxt.getConfig(), type, (AnnotatedMember) member, property);            \t\n             \tif (contentTypeDeser != null) {\n             \t    type = type.withContentTypeHandler(contentTypeDeser);\n             \t}\n     \tTypeDeserializer valueTypeDeser;\n \n         if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n-            valueTypeDeser = findPropertyTypeDeserializer(config, type, (AnnotatedMember) member, property);\n+            valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n+                    type, (AnnotatedMember) member, property);\n         } else { // classes just have Jackson annotations\n             // probably only occurs if 'property' is null anyway\n-            valueTypeDeser = findTypeDeserializer(config, type, null);\n+            valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type, null);\n         }\n     \tif (valueTypeDeser != null) {\n             type = type.withTypeHandler(valueTypeDeser);\n     \treturn type;\n     }\n     \n+    public ValueInstantiator valueInstantiatorInstance(DeserializationConfig config,\n+            Annotated annotated, Object instDef)\n+        throws JsonMappingException\n+    {\n+        if (instDef == null) {\n+            return null;\n+        }\n+\n+        ValueInstantiator inst;\n+        \n+        if (instDef instanceof ValueInstantiator) {\n+            inst = (ValueInstantiator) instDef;\n+        } else {\n+            if (!(instDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n+                        +instDef.getClass().getName()\n+                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n+            }\n+            Class<?> instClass = (Class<?>)instDef;\n+            if (instClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!ValueInstantiator.class.isAssignableFrom(instClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+instClass.getName()\n+                        +\"; expected Class<ValueInstantiator>\");\n+            }\n+            HandlerInstantiator hi = config.getHandlerInstantiator();\n+            if (hi != null) {\n+                inst = hi.valueInstantiatorInstance(config, annotated, instClass);\n+            } else {\n+                inst = (ValueInstantiator) ClassUtil.createInstance(instClass,\n+                        config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // not resolvable or contextual, just return:\n+        return inst;\n+    }\n+    \n     protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config,\n             AnnotatedMethod jsonValueMethod)\n     {\n         BeanDescription beanDesc = config.introspect(enumType);\n         return beanDesc.findJsonValueMethod();\n     }\n-\n-    protected Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n-    {\n-        if (src == null) {\n-            return null;\n-        }\n-        if (!(src instanceof Class)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n-        }\n-        Class<?> cls = (Class<?>) src;\n-        if (cls == noneClass || cls == NoClass.class) {\n-            return null;\n-        }\n-        return cls;\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             return subDeser;\n         }\n         // If not, maybe we can locate one. First, need provider\n-        DeserializerCache deserProv = ctxt.getDeserializerProvider();\n-        if (deserProv != null) {\n-            JavaType type = ctxt.constructType(bean.getClass());\n-            /* 09-Dec-2010, tatu: Would be nice to know which property pointed to this\n-             *    bean... but, alas, no such information is retained, so:\n-             */\n-            subDeser = ctxt.findValueDeserializer(type, _property);\n-            // Also, need to cache it\n-            if (subDeser != null) {\n-                synchronized (this) {\n-                    if (_subDeserializers == null) {\n-                        _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n-                    }\n-                    _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n-                }            \n-            }\n+        JavaType type = ctxt.constructType(bean.getClass());\n+        /* 09-Dec-2010, tatu: Would be nice to know which property pointed to this\n+         *    bean... but, alas, no such information is retained, so:\n+         */\n+        subDeser = ctxt.findValueDeserializer(type, _property);\n+        // Also, need to cache it\n+        if (subDeser != null) {\n+            synchronized (this) {\n+                if (_subDeserializers == null) {\n+                    _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n+                }\n+                _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n+            }            \n         }\n         return subDeser;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n      * module interface).\n      */\n     @Override\n-    public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+    public ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n             BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        ValueInstantiator instantiator;\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        ValueInstantiator instantiator = null;\n         // [JACKSON-633] Check @JsonValueInstantiator before anything else\n         AnnotatedClass ac = beanDesc.getClassInfo();\n-        Object instDef = config.getAnnotationIntrospector().findValueInstantiator(ac);\n+        Object instDef = ctxt.getAnnotationIntrospector().findValueInstantiator(ac);\n         if (instDef != null) {\n-            if (instDef instanceof ValueInstantiator) {\n-                instantiator = (ValueInstantiator) instDef;\n-            } else {\n-                if (!(instDef instanceof Class<?>)) { // sanity check\n-                    throw new IllegalStateException(\"Invalid value instantiator returned for type \"+beanDesc+\": neither a Class nor ValueInstantiator\");\n-                }\n-                Class<?> cls = (Class<?>) instDef;\n-                if (!ValueInstantiator.class.isAssignableFrom(cls)) {\n-                    throw new IllegalStateException(\"Invalid instantiator Class<?> returned for type \"+beanDesc+\": \"\n-                            +cls.getName()+\" not a ValueInstantiator\");\n-                }\n-                @SuppressWarnings(\"unchecked\")\n-                Class<? extends ValueInstantiator> instClass = (Class<? extends ValueInstantiator>) cls;\n-                instantiator = config.valueInstantiatorInstance(ac, (Class<? extends ValueInstantiator>)instClass);\n-            }\n-        } else {\n+            instantiator = valueInstantiatorInstance(config, ac, instDef);\n+        }\n+        if (instantiator == null) {\n             /* Second: see if some of standard Jackson/JDK types might provide value\n              * instantiators.\n              */\n             instantiator = findStdValueInstantiator(config, beanDesc);\n             if (instantiator == null) {\n-                instantiator = constructDefaultValueInstantiator(config, beanDesc);\n+                instantiator = constructDefaultValueInstantiator(ctxt, beanDesc);\n             }\n         }\n         \n      * enums.\n      */\n     @Override\n-    public JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n         // We may also have custom overrides:\n         JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc, property);\n         if (custom != null) {\n          * different handling.\n          */\n         if (type.isThrowable()) {\n-            return buildThrowableDeserializer(config, type, beanDesc, property);\n+            return buildThrowableDeserializer(ctxt, type, beanDesc, property);\n         }\n         /* Or, for abstract types, may have alternate means for resolution\n          * (defaulting, materialization)\n                  * interface doesn't have constructors, for one)\n                  */\n                 beanDesc = config.introspect(concreteType);\n-                return buildBeanDeserializer(config, concreteType, beanDesc, property);\n+                return buildBeanDeserializer(ctxt, concreteType, beanDesc, property);\n             }\n         }\n \n             return null;\n         }\n         // Use generic bean introspection to build deserializer\n-        return buildBeanDeserializer(config, type, beanDesc, property);\n+        return buildBeanDeserializer(ctxt, type, beanDesc, property);\n     }\n \n     /**\n      * deserializers.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First: check what creators we can use, if any\n-        ValueInstantiator valueInstantiator = findValueInstantiator(config, beanDesc);\n+        ValueInstantiator valueInstantiator = findValueInstantiator(ctxt, beanDesc);\n+        final DeserializationConfig config = ctxt.getConfig();\n         // ... since often we have nothing to go on, if we have abstract type:\n         if (type.isAbstract()) {\n             if (!valueInstantiator.canInstantiate()) {\n         BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(beanDesc);\n         builder.setValueInstantiator(valueInstantiator);\n          // And then setters for deserializing from JSON Object\n-        addBeanProps(config, beanDesc, builder);\n+        addBeanProps(ctxt, beanDesc, builder);\n         // managed/back reference fields/setters need special handling... first part\n-        addReferenceProperties(config, beanDesc, builder);\n-        addInjectables(config, beanDesc, builder);\n+        addReferenceProperties(ctxt, beanDesc, builder);\n+        addInjectables(ctxt, beanDesc, builder);\n \n         // [JACKSON-440]: update builder now that all information is in?\n         if (_factoryConfig.hasDeserializerModifiers()) {\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n         // first: construct like a regular bean deserializer...\n         BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(beanDesc);\n-        builder.setValueInstantiator(findValueInstantiator(config, beanDesc));\n-\n-        addBeanProps(config, beanDesc, builder);\n+        builder.setValueInstantiator(findValueInstantiator(ctxt, beanDesc));\n+\n+        addBeanProps(ctxt, beanDesc, builder);\n         // (and assume there won't be any back references)\n \n         // But then let's decorate things a bit\n          */\n         AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n         if (am != null) { // should never be null\n-            SettableBeanProperty prop = constructSettableProperty(config, beanDesc, \"cause\", am);\n+            SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, \"cause\", am);\n             if (prop != null) {\n                 /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n                  *   to set (with new 1.9 code)... but let's replace it just in case,\n      * Method that will construct standard default {@link ValueInstantiator}\n      * using annotations (like @JsonCreator) and visibility rules\n      */\n-    protected ValueInstantiator constructDefaultValueInstantiator(DeserializationConfig config,\n+    protected ValueInstantiator constructDefaultValueInstantiator(DeserializationContext ctxt,\n             BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        boolean fixAccess = config.canOverrideAccessModifiers();\n+        boolean fixAccess = ctxt.canOverrideAccessModifiers();\n         CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         \n         // First, let's figure out constructor/factory-based instantiation\n         // 23-Jan-2010, tatus: but only for concrete types\n         }\n \n         // need to construct suitable visibility checker:\n+        final DeserializationConfig config = ctxt.getConfig();\n         VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n         vchecker = config.getAnnotationIntrospector().findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n \n         /* Important: first add factory methods; then constructors, so\n          * latter can override former!\n          */\n-        _addDeserializerFactoryMethods(config, beanDesc, vchecker, intr, creators);\n-        _addDeserializerConstructors(config, beanDesc, vchecker, intr, creators);\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators);\n+        _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators);\n \n         return creators.constructValueInstantiator(config);\n     }\n \n     protected void _addDeserializerConstructors\n-        (DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n          AnnotationIntrospector intr, CreatorCollector creators)\n         throws JsonMappingException\n     {\n             boolean isVisible =  vchecker.isCreatorVisible(ctor);\n             // some single-arg constructors (String, number) are auto-detected\n             if (argCount == 1) {\n-                _handleSingleArgumentConstructor(config, beanDesc, vchecker, intr, creators,\n+                _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                         ctor, isCreator, isVisible);\n                 continue;\n             }\n                 Object injectId = intr.findInjectableValueId(param);\n                 if (name != null && name.length() > 0) {\n                     ++namedCount;\n-                    properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectId);\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                 } else if (injectId != null) {\n                     ++injectCount;\n-                    properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectId);\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                 } else if (nonAnnotatedParam == null) {\n                     nonAnnotatedParam = param;\n                 }\n         }\n     }\n \n-    protected boolean _handleSingleArgumentConstructor(DeserializationConfig config,\n+    protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n             AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n         if ((injectId != null) || (name != null && name.length() > 0)) { // property-based\n             // We know there's a name and it's only 1 parameter.\n             CreatorProperty[] properties = new CreatorProperty[1];\n-            properties[0] = constructCreatorProperty(config, beanDesc, name, 0, param, injectId);\n+            properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId);\n             creators.addPropertyCreator(ctor, properties);\n             return true;\n         }\n     }\n     \n     protected void _addDeserializerFactoryMethods\n-        (DeserializationConfig config, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n          AnnotationIntrospector intr, CreatorCollector creators)\n         throws JsonMappingException\n     {\n-\n+        final DeserializationConfig config = ctxt.getConfig();\n         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n             int argCount = factory.getParameterCount();\n             if (argCount < 1) {\n                 Object injectId = intr.findInjectableValueId(param);\n                 if (name != null && name.length() > 0) {\n                     ++namedCount;\n-                    properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectId);\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                 } else if (injectId != null) {\n                     ++injectCount;\n-                    properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectId);\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n                 } else if (nonAnnotatedParam == null) {\n                     nonAnnotatedParam = param;\n                 }\n      * a logical property passed via Creator (constructor or static\n      * factory method)\n      */\n-    protected CreatorProperty constructCreatorProperty(DeserializationConfig config,\n+    protected CreatorProperty constructCreatorProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, String name, int index,\n             AnnotatedParameter param,\n             Object injectableValueId)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n         JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n         BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), param);\n-        JavaType type = resolveType(config, beanDesc, t0, param, property);\n+        JavaType type = resolveType(ctxt, beanDesc, t0, param, property);\n         if (type != t0) {\n             property = property.withType(type);\n         }\n         // Is there an annotation that specifies exact deserializer?\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, param, property);\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param, property);\n         // If yes, we are mostly done:\n-        type = modifyTypeByAnnotation(config, param, type, name);\n+        type = modifyTypeByAnnotation(ctxt, param, type, property);\n \n         // Type deserializer: either comes from property (and already resolved)\n         TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n      * Note: designed to be overridable, and effort is made to keep interface\n      * similar between versions.\n      */\n-    protected void addBeanProps(DeserializationConfig config,\n+    protected void addBeanProps(DeserializationContext ctxt,\n             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n         throws JsonMappingException\n     {\n         List<BeanPropertyDefinition> props = beanDesc.findProperties();\n         // Things specified as \"ok to ignore\"? [JACKSON-77]\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         boolean ignoreAny = false;\n         {\n             Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n         // Also, do we have a fallback \"any\" setter?\n         AnnotatedMethod anySetter = beanDesc.findAnySetter();\n         if (anySetter != null) {\n-            builder.setAnySetter(constructAnySetter(config, beanDesc, anySetter));\n+            builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n         }\n         // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n         // Implicit ones via @JsonIgnore and equivalent?\n                 AnnotatedMethod setter = property.getSetter();\n                 // [JACKSON-429] Some types are declared as ignorable as well\n                 Class<?> type = setter.getParameterClass(0);\n-                if (isIgnorableType(config, beanDesc, type, ignoredTypes)) {\n+                if (isIgnorableType(ctxt.getConfig(), beanDesc, type, ignoredTypes)) {\n                     // important: make ignorable, to avoid errors if value is actually seen\n                     builder.addIgnorable(name);\n                     continue;\n                 }\n-                SettableBeanProperty prop = constructSettableProperty(config, beanDesc, name, setter);\n+                SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, name, setter);\n                 if (prop != null) {\n                     builder.addProperty(prop);\n                 }\n                 AnnotatedField field = property.getField();\n                 // [JACKSON-429] Some types are declared as ignorable as well\n                 Class<?> type = field.getRawType();\n-                if (isIgnorableType(config, beanDesc, type, ignoredTypes)) {\n+                if (isIgnorableType(ctxt.getConfig(), beanDesc, type, ignoredTypes)) {\n                     // important: make ignorable, to avoid errors if value is actually seen\n                     builder.addIgnorable(name);\n                     continue;\n                 }\n-                SettableBeanProperty prop = constructSettableProperty(config, beanDesc, name, field);\n+                SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, name, field);\n                 if (prop != null) {\n                     builder.addProperty(prop);\n                 }\n         /* also, as per [JACKSON-328], should not override fields (or actual setters),\n          * thus these are added AFTER adding fields\n          */\n-        if (config.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n+        if (ctxt.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n             /* Hmmh. We have to assume that 'use getters as setters' also\n              * implies 'yes, do auto-detect these getters'? (if not, we'd\n              * need to add AUTO_DETECT_GETTERS to deser config too, not\n                     Class<?> rt = getter.getRawType();\n                     if (Collection.class.isAssignableFrom(rt) || Map.class.isAssignableFrom(rt)) {\n                         if (!ignored.contains(name) && !builder.hasProperty(name)) {\n-                            builder.addProperty(constructSetterlessProperty(config, beanDesc, name, getter));\n+                            builder.addProperty(constructSetterlessProperty(ctxt, beanDesc, name, getter));\n                         }\n                     }\n                 }\n      * Method that will find if bean has any managed- or back-reference properties,\n      * and if so add them to bean, to be linked during resolution phase.\n      */\n-    protected void addReferenceProperties(DeserializationConfig config,\n+    protected void addReferenceProperties(DeserializationContext ctxt,\n             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n         throws JsonMappingException\n     {\n                 AnnotatedMember m = en.getValue();\n                 if (m instanceof AnnotatedMethod) {\n                     builder.addBackReferenceProperty(name, constructSettableProperty(\n-                            config, beanDesc, m.getName(), (AnnotatedMethod) m));\n+                            ctxt, beanDesc, m.getName(), (AnnotatedMethod) m));\n                 } else {\n                     builder.addBackReferenceProperty(name, constructSettableProperty(\n-                            config, beanDesc, m.getName(), (AnnotatedField) m));\n+                            ctxt, beanDesc, m.getName(), (AnnotatedField) m));\n                 }\n             }\n         }\n      * Method called locate all members used for value injection (if any),\n      * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n      */\n-    protected void addInjectables(DeserializationConfig config,\n+    protected void addInjectables(DeserializationContext ctxt,\n             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n         throws JsonMappingException\n     {\n         Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n         if (raw != null) {\n-            boolean fixAccess = config.canOverrideAccessModifiers();\n+            boolean fixAccess = ctxt.canOverrideAccessModifiers();\n             for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n                 AnnotatedMember m = entry.getValue();\n                 if (fixAccess) {\n      * for handling unknown bean properties, given a method that\n      * has been designated as such setter.\n      */\n-    protected SettableAnyProperty constructAnySetter(DeserializationConfig config,\n+    protected SettableAnyProperty constructAnySetter(DeserializationContext ctxt,\n             BeanDescription beanDesc, AnnotatedMethod setter)\n         throws JsonMappingException\n     {\n-        if (config.canOverrideAccessModifiers()) {\n+        if (ctxt.canOverrideAccessModifiers()) {\n             setter.fixAccess(); // to ensure we can call it\n         }\n         // we know it's a 2-arg method, second arg is the value\n         JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getParameterType(1));\n         BeanProperty.Std property = new BeanProperty.Std(setter.getName(), type, beanDesc.getClassAnnotations(), setter);\n-        type = resolveType(config, beanDesc, type, setter, property);\n+        type = resolveType(ctxt, beanDesc, type, setter, property);\n \n         /* AnySetter can be annotated with @JsonClass (etc) just like a\n          * regular setter... so let's see if those are used.\n          * Returns null if no annotations, in which case binding will\n          * be done at a later point.\n          */\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, setter, property);\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter, property);\n         if (deser != null) {\n             return new SettableAnyProperty(property, setter, type, deser);\n         }\n         /* Otherwise, method may specify more specific (sub-)class for\n          * value (no need to check if explicit deser was specified):\n          */\n-        type = modifyTypeByAnnotation(config, setter, type, property.getName());\n+        type = modifyTypeByAnnotation(ctxt, setter, type, property);\n         return new SettableAnyProperty(property, setter, type, null);\n     }\n \n      * @return Property constructed, if any; or null to indicate that\n      *   there should be no property based on given definitions.\n      */\n-    protected SettableBeanProperty constructSettableProperty(DeserializationConfig config,\n+    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, String name,\n             AnnotatedMethod setter)\n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n-        if (config.canOverrideAccessModifiers()) {\n+        if (ctxt.canOverrideAccessModifiers()) {\n             setter.fixAccess();\n         }\n \n         // note: this works since we know there's exactly one argument for methods\n         JavaType t0 = beanDesc.bindingsForBeanType().resolveType(setter.getParameterType(0));\n         BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), setter);\n-        JavaType type = resolveType(config, beanDesc, t0, setter, property);\n+        JavaType type = resolveType(ctxt, beanDesc, t0, setter, property);\n         // did type change?\n         if (type != t0) {\n             property = property.withType(type);\n         /* First: does the Method specify the deserializer to use?\n          * If so, let's use it.\n          */\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(config, setter, property);\n-        type = modifyTypeByAnnotation(config, setter, type, name);\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, setter, property);\n+        type = modifyTypeByAnnotation(ctxt, setter, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop = new SettableBeanProperty.MethodProperty(name, type, typeDeser,\n                 beanDesc.getClassAnnotations(), setter);\n             prop = prop.withValueDeserializer(propDeser);\n         }\n         // [JACKSON-235]: need to retain name of managed forward references:\n-        AnnotationIntrospector.ReferenceProperty ref = config.getAnnotationIntrospector().findReferenceType(setter);\n+        AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(setter);\n         if (ref != null && ref.isManagedReference()) {\n             prop.setManagedReferenceName(ref.getName());\n         }\n         return prop;\n     }\n \n-    protected SettableBeanProperty constructSettableProperty(DeserializationConfig config,\n+    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, String name, AnnotatedField field)\n         throws JsonMappingException\n     {\n         // need to ensure method is callable (for non-public)\n-        if (config.canOverrideAccessModifiers()) {\n+        if (ctxt.canOverrideAccessModifiers()) {\n             field.fixAccess();\n         }\n         JavaType t0 = beanDesc.bindingsForBeanType().resolveType(field.getGenericType());\n         BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), field);\n-        JavaType type = resolveType(config, beanDesc, t0, field, property);\n+        JavaType type = resolveType(ctxt, beanDesc, t0, field, property);\n         // did type change?\n         if (type != t0) {\n             property = property.withType(type);\n         /* First: does the Method specify the deserializer to use?\n          * If so, let's use it.\n          */\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(config, field, property);\n-        type = modifyTypeByAnnotation(config, field, type, name);\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, field, property);\n+        type = modifyTypeByAnnotation(ctxt, field, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop = new SettableBeanProperty.FieldProperty(name, type, typeDeser,\n                 beanDesc.getClassAnnotations(), field);\n             prop = prop.withValueDeserializer(propDeser);\n         }\n         // [JACKSON-235]: need to retain name of managed forward references:\n-        AnnotationIntrospector.ReferenceProperty ref = config.getAnnotationIntrospector().findReferenceType(field);\n+        AnnotationIntrospector.ReferenceProperty ref = ctxt.getAnnotationIntrospector().findReferenceType(field);\n         if (ref != null && ref.isManagedReference()) {\n             prop.setManagedReferenceName(ref.getName());\n         }\n      * @param getter Method to use to get property value to modify, null if\n      *    none. Non-null for \"setterless\" properties.\n      */\n-    protected SettableBeanProperty constructSetterlessProperty(DeserializationConfig config,\n+    protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, String name, AnnotatedMethod getter)\n         throws JsonMappingException\n     {\n         // need to ensure it is callable now:\n-        if (config.canOverrideAccessModifiers()) {\n+        if (ctxt.canOverrideAccessModifiers()) {\n             getter.fixAccess();\n         }\n \n          */\n         BeanProperty.Std property = new BeanProperty.Std(name, type, beanDesc.getClassAnnotations(), getter);\n         // @TODO: create BeanProperty to pass?\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(config, getter, property);\n-        type = modifyTypeByAnnotation(config, getter, type, name);\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter, property);\n+        type = modifyTypeByAnnotation(ctxt, getter, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop = new SettableBeanProperty.SetterlessProperty(name, type, typeDeser,\n                 beanDesc.getClassAnnotations(), getter);\n      *\n      * @param a Method or field that the type is associated with\n      * @param type Type derived from the setter argument\n-     * @param propName Name of property that refers to type, if any; null\n+     * @param prop property that refers to type, if any; null\n      *   if no property information available (when modify type declaration\n      *   of a class, for example)\n      *\n      * @throws JsonMappingException if invalid annotation is found\n      */\n     @SuppressWarnings({ \"unchecked\" })\n-    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationConfig config,\n-            Annotated a, T type, String propName)\n+    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationContext ctxt,\n+            Annotated a, T type, BeanProperty prop)\n         throws JsonMappingException\n     {\n         // first: let's check class for the instance itself:\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Class<?> subclass = intr.findDeserializationType(a, type, propName);\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type,\n+                (prop == null) ? null : prop.getName());\n         if (subclass != null) {\n             try {\n                 type = (T) type.narrowBy(subclass);\n \n         // then key class\n         if (type.isContainerType()) {\n-            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(),\n+                    (prop == null) ? null : prop.getName());\n             if (keyClass != null) {\n                 // illegal to use on non-Maps\n                 if (!(type instanceof MapLikeType)) {\n              */\n             if (keyType != null && keyType.getValueHandler() == null) {\n                 Object kdDef = intr.findKeyDeserializer(a);\n-                if (kdDef != null) {\n-                    KeyDeserializer kd = null;\n-                    if (kdDef instanceof KeyDeserializer) {\n-                        kd = (KeyDeserializer) kdDef;\n-                    } else {\n-                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                        if (kdClass != null) {\n-                            kd = config.keyDeserializerInstance(a, kdClass);\n-                        }\n-                    }\n-                    if (kd != null) {\n-                        type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                        keyType = type.getKeyType(); // just in case it's used below\n-                    }\n+                KeyDeserializer kd = ctxt.keyDeserializerInstance(a, prop, kdDef);\n+                if (kd != null) {\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    keyType = type.getKeyType(); // just in case it's used below\n                 }\n             }            \n            \n            // and finally content class; only applicable to structured types\n-           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(), propName);\n+           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(),\n+                   (prop == null) ? null : prop.getName());\n            if (cc != null) {\n                try {\n                    type = (T) type.narrowContentsBy(cc);\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n-                if (cdDef != null) {\n-                    JsonDeserializer<?> cd = null;\n-                    if (cdDef instanceof JsonDeserializer<?>) {\n-                        cdDef = (JsonDeserializer<?>) cdDef;\n-                    } else {\n-                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n-                        if (cdClass != null) {\n-                            cd = config.deserializerInstance(a, cdClass);\n-                        }\n-                    }\n-                    if (cd != null) {\n-                        type = (T) type.withContentValueHandler(cd);\n-                    }\n+                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, prop, cdDef);\n+                if (cd != null) {\n+                    type = (T) type.withContentValueHandler(cd);\n                 }\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n      *   accessing suitable key deserializer; including that of not\n      *   finding any serializer\n      */\n-    public KeyDeserializer findKeyDeserializer(DeserializationConfig config,\n+    public KeyDeserializer findKeyDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n-        KeyDeserializer kd = _factory.createKeyDeserializer(config, type, property);\n-        // One more thing: contextuality\n-        if (kd instanceof ContextualKeyDeserializer) {\n-            kd = ((ContextualKeyDeserializer) kd).createContextual(config, property);\n-        }\n+        KeyDeserializer kd = _factory.createKeyDeserializer(ctxt, type, property);\n         if (kd == null) { // if none found, need to use a placeholder that'll fail\n             return _handleUnknownKeyDeserializer(type);\n+        }\n+        // First: need to resolve?\n+        if (kd instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) kd).resolve(ctxt);\n+        }\n+        // Second: contextualize?\n+        if (kd instanceof ContextualKeyDeserializer) {\n+            kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt.getConfig(), property);\n         }\n         return kd;\n     }\n         }\n \n         // If not, may have further type-modification annotations to check:\n-        JavaType newType = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, property);\n+        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type, property);\n         if (newType != type) {\n             type = newType;\n             beanDesc = config.introspect(newType);\n \n         // If not, let's see which factory method to use:\n         if (type.isEnumType()) {\n-            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, type,\n+            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(ctxt, type,\n                     beanDesc, property);\n         }\n         if (type.isContainerType()) {\n             if (type.isArrayType()) {\n-                return (JsonDeserializer<Object>)_factory.createArrayDeserializer(config,\n+                return (JsonDeserializer<Object>)_factory.createArrayDeserializer(ctxt,\n                         (ArrayType) type, beanDesc, property);\n             }\n             if (type.isMapLikeType()) {\n                 MapLikeType mlt = (MapLikeType) type;\n                 if (mlt.isTrueMapType()) {\n-                    return (JsonDeserializer<Object>)_factory.createMapDeserializer(config,\n+                    return (JsonDeserializer<Object>)_factory.createMapDeserializer(ctxt,\n                             (MapType) mlt, beanDesc, property);\n                 }\n-                return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(config,\n+                return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(ctxt,\n                         mlt, beanDesc, property);\n             }\n             if (type.isCollectionLikeType()) {\n                 CollectionLikeType clt = (CollectionLikeType) type;\n                 if (clt.isTrueCollectionType()) {\n-                    return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(config,\n+                    return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(ctxt,\n                             (CollectionType) clt, beanDesc, property);\n                 }\n-                return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(config,\n+                return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(ctxt,\n                         clt, beanDesc, property);\n             }\n         }\n         if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n             return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, type, beanDesc, property);\n         }\n-        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, type, beanDesc, property);\n+        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(ctxt, type, beanDesc, property);\n     }\n \n     /**\n      * has annotation that tells which class to use for deserialization.\n      * Returns null if no such annotation found.\n      */\n-    @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n             Annotated ann, BeanProperty property)\n         throws JsonMappingException\n         if (deserDef == null) {\n             return null;\n         }\n-        if (deserDef instanceof JsonDeserializer) {\n-            JsonDeserializer<Object> deser = (JsonDeserializer<Object>) deserDef;\n-            // related to [JACKSON-569], need contextualization:\n-            if (deser instanceof ContextualDeserializer<?>) {\n-                deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(ctxt.getConfig(), property);\n-            }\n-            return deser;\n-        }\n-        /* Alas, there's no way to force return type of \"either class\n-         * X or Y\" -- need to throw an exception after the fact\n-         */\n-        if (!(deserDef instanceof Class)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n-        }\n-        Class<? extends JsonDeserializer<?>> deserClass = (Class<? extends JsonDeserializer<?>>) deserDef;\n-        if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n-            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n-        }\n-        JsonDeserializer<Object> deser = ctxt.getConfig().deserializerInstance(ann, deserClass);\n-        // related to [JACKSON-569], need contextualization:\n-        if (deser instanceof ContextualDeserializer<?>) {\n-            deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(ctxt.getConfig(), property);\n-        }\n-        return deser;\n-    }\n-    \n-    private JavaType modifyTypeByAnnotation(DeserializationConfig config,\n-            Annotated a, JavaType type, BeanProperty prop)\n-        throws JsonMappingException\n-    {\n-        return modifyTypeByAnnotation(config, a, type,\n-                (prop == null)  ? null : prop.getName());\n+        return ctxt.deserializerInstance(ann, property, deserDef);\n     }\n \n     /**\n      *\n      * @param a Method or field that the type is associated with\n      * @param type Type derived from the setter argument\n-     * @param propName Name of property that refers to type, if any; null\n-     *   if no property information available (when modify type declaration\n-     *   of a class, for example)\n+     * @param prop Property that lead to this annotation, if any.\n      *\n      * @return Original type if no annotations are present; or a more\n      *   specific type derived from it if type annotation(s) was found\n      *\n      * @throws JsonMappingException if invalid annotation is found\n      */\n-    private JavaType modifyTypeByAnnotation(DeserializationConfig config,\n-            Annotated a, JavaType type, String propName)\n+    private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n+            Annotated a, JavaType type, BeanProperty prop)\n         throws JsonMappingException\n     {\n         // first: let's check class for the instance itself:\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Class<?> subclass = intr.findDeserializationType(a, type, propName);\n+        AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type,\n+                (prop == null)? null : prop.getName());\n         if (subclass != null) {\n             try {\n                 type = type.narrowBy(subclass);\n \n         // then key class\n         if (type.isContainerType()) {\n-            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(),\n+                    (prop == null)? null : prop.getName());\n             if (keyClass != null) {\n                 // illegal to use on non-Maps\n                 if (!(type instanceof MapLikeType)) {\n             if (keyType != null && keyType.getValueHandler() == null) {\n                 Object kdDef = intr.findKeyDeserializer(a);\n                 if (kdDef != null) {\n-                    KeyDeserializer kd = null;\n-                    if (kdDef instanceof KeyDeserializer) {\n-                        kd = (KeyDeserializer) kdDef;\n-                    } else {\n-                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                        if (kdClass != null) {\n-                            kd = config.keyDeserializerInstance(a, kdClass);\n-                        }\n-                    }\n+                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, prop, kdDef);\n                     if (kd != null) {\n                         type = ((MapLikeType) type).withKeyValueHandler(kd);\n                         keyType = type.getKeyType(); // just in case it's used below\n             }            \n             \n             // and finally content class; only applicable to structured types\n-            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(), propName);\n+            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(),\n+                    (prop == null) ? null : prop.getName());\n             if (cc != null) {\n                 try {\n                     type = type.narrowContentsBy(cc);\n                     } else {\n                         Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                         if (cdClass != null) {\n-                            cd = config.deserializerInstance(a, cdClass);\n+                            cd = ctxt.deserializerInstance(a, prop, cdClass);\n                         }\n                     }\n                     if (cd != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n      * Method that is to find all creators (constructors, factory methods)\n      * for the bean type to deserialize.\n      */\n-    public abstract ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+    public abstract ValueInstantiator findValueInstantiator(DeserializationContext ctxt,\n             BeanDescription beanDesc)\n         throws JsonMappingException;\n     \n      *\n      * @param type Type to be deserialized\n      */\n-    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n      *\n      * @param type Type to be deserialized\n      */\n-    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationContext ctxt,\n             ArrayType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n-    public abstract JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n             CollectionType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n-    public abstract JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationContext ctxt,\n             CollectionLikeType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n     \n-    public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n-    public abstract JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n             MapType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n-    public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n+    public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationContext ctxt,\n             MapLikeType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n      * @return Key deserializer to use for specified type, if one found; null if not\n      *   (and default key deserializer should be used)\n      */\n-    public abstract KeyDeserializer createKeyDeserializer(DeserializationConfig config,\n+    public abstract KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.LinkedNode;\n      */\n     protected JsonParser _parser;\n \n-    protected final DeserializerCache _deserProvider;\n+    protected final DeserializerCache _deserCache;\n \n     protected final InjectableValues _injectableValues;\n     \n      */\n \n     public StdDeserializationContext(DeserializationConfig config, JsonParser jp,\n-            DeserializerCache prov, InjectableValues injectableValues)\n+            DeserializerCache cache, InjectableValues injectableValues)\n     {\n     \tsuper(config);\n         _parser = jp;\n-        _deserProvider = prov;\n+        _deserCache = cache;\n         _injectableValues = injectableValues;\n     }\n \n     /**********************************************************\n      */\n \n-    @Override\n-    public DeserializerCache getDeserializerProvider() {\n-        return _deserProvider;\n+    public DeserializerCache getDeserializerCache() {\n+        return _deserCache;\n     }\n \n     /**\n     @Override\n     public JsonDeserializer<Object> findValueDeserializer(JavaType type,\n             BeanProperty property) throws JsonMappingException {\n-        return _deserProvider.findValueDeserializer(this, type, property);\n+        return _deserCache.findValueDeserializer(this, type, property);\n     }\n     \n     @Override\n     public JsonDeserializer<Object> findTypedValueDeserializer(JavaType type,\n             BeanProperty property) throws JsonMappingException {\n-        return _deserProvider.findTypedValueDeserializer(this, type, property);\n+        return _deserCache.findTypedValueDeserializer(this, type, property);\n     }\n \n     @Override\n     public KeyDeserializer findKeyDeserializer(JavaType keyType,\n             BeanProperty property) throws JsonMappingException {\n-        return _deserProvider.findKeyDeserializer(_config, keyType, property);\n-    }\n-    \n+        return _deserCache.findKeyDeserializer(this, keyType, property);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n+            BeanProperty property, Object deserDef)\n+        throws JsonMappingException\n+    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        JsonDeserializer<?> deser;\n+        \n+        if (deserDef instanceof JsonDeserializer) {\n+            deser = (JsonDeserializer<?>) deserDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(deserDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n+            }\n+            Class<?> deserClass = (Class<?>)deserDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                deser = hi.deserializerInstance(_config, annotated, deserClass);\n+            } else {\n+                deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // First: need to resolve\n+        if (deser instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) deser).resolve(this);\n+        }\n+        // Second: contextualize:\n+        if (deser instanceof ContextualDeserializer<?>) {\n+            deser = ((ContextualDeserializer<?>) deser).createContextual(_config, property);\n+        }\n+        return (JsonDeserializer<Object>) deser;\n+    }\n+\n+    @Override\n+    public KeyDeserializer keyDeserializerInstance(Annotated annotated,\n+            BeanProperty property, Object deserDef)\n+        throws JsonMappingException\n+    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n+\n+        KeyDeserializer deser;\n+        \n+        if (deserDef instanceof KeyDeserializer) {\n+            deser = (KeyDeserializer) deserDef;\n+        } else {\n+            if (!(deserDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n+                        +deserDef.getClass().getName()\n+                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n+            }\n+            Class<?> deserClass = (Class<?>)deserDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!KeyDeserializer.class.isAssignableFrom(deserClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()\n+                        +\"; expected Class<KeyDeserializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                deser = hi.keyDeserializerInstance(_config, annotated, deserClass);\n+            } else {\n+                deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // First: need to resolve\n+        if (deser instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) deser).resolve(this);\n+        }\n+        // Second: contextualize:\n+        if (deser instanceof ContextualKeyDeserializer) {\n+            deser = ((ContextualKeyDeserializer) deser).createContextual(_config, property);\n+        }\n+        return deser;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, helper object recycling\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n         }\n         \n         @Override\n-        public JsonDeserializer<?> deserializerInstance(DeserializationConfig config, Annotated annotated,\n-                Class<? extends JsonDeserializer<?>> deserClass)\n+        public JsonDeserializer<?> deserializerInstance(DeserializationConfig config,\n+                Annotated annotated,\n+                Class<?> deserClass)\n         {\n             if (deserClass == MyBeanDeserializer.class) {\n                 return new MyBeanDeserializer(_prefix);\n \n         @Override\n         public KeyDeserializer keyDeserializerInstance(DeserializationConfig config,\n-                Annotated annotated, Class<? extends KeyDeserializer> keyDeserClass)\n+                Annotated annotated, Class<?> keyDeserClass)\n         {\n             if (keyDeserClass == MyKeyDeserializer.class) {\n                 return new MyKeyDeserializer();\n \n         @Override\n         public TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,\n-                Annotated annotated, Class<? extends TypeIdResolver> resolverClass)\n+                Annotated annotated, Class<?> resolverClass)\n         {\n             if (resolverClass == CustomIdResolver.class) {\n                 return new CustomIdResolver(\"!!!\");\n \n         @Override\n         public TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config, Annotated annotated,\n-                Class<? extends TypeResolverBuilder<?>> builderClass)\n+                Class<?> builderClass)\n         {\n             return null;\n         }", "timestamp": 1327450776, "metainfo": ""}