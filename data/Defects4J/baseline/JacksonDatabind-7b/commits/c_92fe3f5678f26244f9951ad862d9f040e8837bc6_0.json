{"sha": "92fe3f5678f26244f9951ad862d9f040e8837bc6", "log": "Merge pull request #482 from sanbeg/master  Make date parsing error behavior consistent with Java", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java\n \n     @Override\n     public Date parse(String source, ParsePosition pos) {\n-        // index must be set to other than 0, I would swear this requirement is not there in\n-        // some version of jdk 6.\n-        /* 03-Nov-2013, tatu: I can't see this having any direct effect\n-         *   here... I am guessing it marks things as consumed but why?\n-         */\n-        pos.setIndex(source.length());\n-        return ISO8601Utils.parse(source);\n+        try {\n+            return ISO8601Utils.parse(source, pos);\n+        }\n+        catch (ParseException e) {\n+            return null;\n+        }\n+    }\n+\n+    //supply our own parse(String) since pos isn't updated during parsing,\n+    //but the exception should have the right error offset.\n+    @Override\n+    public Date parse(String source) throws ParseException {\n+        return ISO8601Utils.parse(source, new ParsePosition(0));\n     }\n \n     @Override\n \n     @Override\n     public String toString() { return getClass().getName(); }\n-}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n package com.fasterxml.jackson.databind.util;\n \n import java.util.*;\n+import java.text.ParsePosition;\n+import java.text.ParseException;\n \n /**\n  * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than\n      * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n      *\n      * @param date ISO string to parse in the appropriate format.\n+     * @param pos The position to start parsing from, updated to where parsing stopped.\n      * @return the parsed date\n-     * @throws IllegalArgumentException if the date is not in the appropriate format\n-     */\n-    public static Date parse(String date)\n+     * @throws ParseException if the date is not in the appropriate format\n+     */\n+    public static Date parse(String date, ParsePosition pos) throws ParseException\n     {\n         Exception fail = null;\n         try {\n-            int offset = 0;\n+            int offset = pos.getIndex();\n \n             // extract year\n             int year = parseInt(date, offset, offset += 4);\n             String timezoneId;\n             char timezoneIndicator = date.charAt(offset);\n             if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n-                timezoneId = GMT_ID + date.substring(offset);\n+                String timezoneOffset = date.substring(offset);\n+                timezoneId = GMT_ID + timezoneOffset;\n+                offset += timezoneOffset.length();\n             } else if (timezoneIndicator == 'Z') {\n                 timezoneId = GMT_ID;\n+                offset += 1;\n             } else {\n                 throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneIndicator);\n             }\n+\n             TimeZone timezone = TimeZone.getTimeZone(timezoneId);\n             if (!timezone.getID().equals(timezoneId)) {\n                 throw new IndexOutOfBoundsException();\n             calendar.set(Calendar.SECOND, seconds);\n             calendar.set(Calendar.MILLISECOND, milliseconds);\n \n+            pos.setIndex(offset);\n             return calendar.getTime();\n+            //If we get a ParseException it'll already have the right message/offset.\n+            //Other exception types can convert here.\n         } catch (IndexOutOfBoundsException e) {\n             fail = e;\n         } catch (NumberFormatException e) {\n             fail = e;\n         }\n         String input = (date == null) ? null : ('\"'+date+\"'\");\n-        throw new IllegalArgumentException(\"Failed to parse date [\"+input\n-                +\"]: \"+fail.getMessage(), fail);\n+        throw new ParseException(\"Failed to parse date [\"+input\n+            +\"]: \"+fail.getMessage(), pos.getIndex());\n     }\n \n     /**\n      * @param expected the expected character\n      * @throws IndexOutOfBoundsException if the expected character is not found\n      */\n-    private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException {\n+    private static void checkOffset(String value, int offset, char expected) throws ParseException {\n         char found = value.charAt(offset);\n         if (found != expected) {\n-            throw new IndexOutOfBoundsException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\");\n+            throw new ParseException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\", offset);\n         }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/util/ISO8601DateFormatTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601DateFormatTest.java\n         assertEquals(date, result);\n     }\n \n+    public void testPartialParse() throws Exception {\n+        java.text.ParsePosition pos = new java.text.ParsePosition(0);\n+        String timestamp = \"2007-08-13T19:51:23Z\";\n+        Date result = df.parse(timestamp + \"hello\", pos);\n+        \n+        assertEquals(date, result);\n+        assertEquals(timestamp.length(), pos.getIndex());\n+    }\n+\n     public void testCloneObject() throws Exception {\n         DateFormat clone = (DateFormat)df.clone();\n         assertSame(df, clone);\n--- a/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n package com.fasterxml.jackson.databind.util;\n \n import java.util.*;\n-\n+import java.text.ParsePosition;\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.util.ISO8601Utils;\n         assertEquals(\"2007-08-13T19:51:23.789Z\", result);\n     }\n \n-    public void testParse() {\n-        Date d = ISO8601Utils.parse(\"2007-08-13T19:51:23.789Z\");\n+    public void testParse() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T19:51:23.789Z\", new ParsePosition(0));\n         assertEquals(date, d);\n \n-        d = ISO8601Utils.parse(\"2007-08-13T19:51:23Z\");\n+        d = ISO8601Utils.parse(\"2007-08-13T19:51:23Z\", new ParsePosition(0));\n         assertEquals(dateZeroMillis, d);\n \n-        d = ISO8601Utils.parse(\"2007-08-13T21:51:23.789+02:00\");\n+        d = ISO8601Utils.parse(\"2007-08-13T21:51:23.789+02:00\", new ParsePosition(0));\n         assertEquals(date, d);\n     }\n ", "timestamp": 1402357924, "metainfo": ""}