{"sha": "75e7f262bf7982bd0afd1fee9a5d489fc566b1d5", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     /* Life-cycle, factory methods from MapperConfig\n     /**********************************************************\n      */\n-\n+    \n     @Override\n     public DeserializationConfig with(MapperFeature... features)\n     {\n         return (newMapperFlags == _mapperFeatures) ? this :\n             new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n     }\n-    \n+\n+    @Override\n+    public DeserializationConfig with(MapperFeature feature, boolean state)\n+    {\n+        int newMapperFlags;\n+        if (state) {\n+            newMapperFlags = _mapperFeatures | feature.getMask();\n+        } else {\n+            newMapperFlags = _mapperFeatures & ~feature.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this :\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+    }\n+\n     @Override\n     public DeserializationConfig with(ClassIntrospector ci) {\n         return _withBase(_base.withClassIntrospector(ci));\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         _rootNames = new RootNameLookup();\n         // and default type factory is shared one\n         _typeFactory = TypeFactory.defaultInstance();\n+        \n         _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n         _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n+\n+        // Some overrides we may need\n+        final boolean needOrder = _jsonFactory.requiresPropertyOrdering();\n+        if (needOrder ^ _serializationConfig.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY)) {\n+            configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, needOrder);\n+        }\n+        \n         _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n         _deserializationContext = (dc == null) ?\n                 new DefaultDeserializationContext.Impl(BeanDeserializerFactory.instance) : dc;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n \n     protected ObjectReader(ObjectReader base, JsonFactory f)\n     {\n-        _config = base._config;\n+        // may need to override ordering, based on data format capabilities\n+        _config = base._config\n+            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n         _context = base._context;\n \n         _rootDeserializers = base._rootDeserializers;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n         _rootSerializer = base._rootSerializer;\n         _prettyPrinter = base._prettyPrinter;\n     }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected ObjectWriter(ObjectWriter base, JsonFactory f)\n+    {\n+        // may need to override ordering, based on data format capabilities\n+        _config = base._config\n+            .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n+        _cfgBigDecimalAsPlain = base._cfgBigDecimalAsPlain;\n+\n+        _serializerProvider = base._serializerProvider;\n+        _serializerFactory = base._serializerFactory;\n+        _generatorFactory = base._generatorFactory;\n+        _schema = base._schema;\n+        _characterEscapes = base._characterEscapes;\n+\n+        _rootType = base._rootType;\n+        _rootSerializer = base._rootSerializer;\n+        _prettyPrinter = base._prettyPrinter;\n+    }\n     \n     /**\n      * Method that will return version information stored in and read from jar\n         return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n                 _prettyPrinter, _schema, escapes);\n     }\n-    \n+\n+    /**\n+     * @since 2.3\n+     */\n+    public ObjectWriter with(JsonFactory f) {\n+        if (f == _generatorFactory) {\n+            return this;\n+        }\n+        return new ObjectWriter(this, f);\n+    }    \n     /*\n     /**********************************************************\n     /* Simple accessors\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n     }\n \n     @Override\n+    public SerializationConfig with(MapperFeature feature, boolean state)\n+    {\n+        int newMapperFlags;\n+        if (state) {\n+            newMapperFlags = _mapperFeatures | feature.getMask();\n+        } else {\n+            newMapperFlags = _mapperFeatures & ~feature.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this :\n+            new SerializationConfig(this, newMapperFlags, _serFeatures);\n+    }\n+    \n+    @Override\n     public SerializationConfig with(AnnotationIntrospector ai) {\n         return _withBase(_base.withAnnotationIntrospector(ai));\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n      * mapper features disabled.\n      */\n     public abstract T without(MapperFeature... features);\n+\n+    /**\n+     * @since 2.3\n+     */\n+    public abstract T with(MapperFeature feature, boolean state);\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     protected final ObjectIdReader _objectIdReader;\n \n     protected final Map<String, SettableBeanProperty> _backRefProperties;\n-    \n+\n     // support for \"native\" types, which require special care:\n     \n     protected final boolean _acceptString;\n         _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);\n     }\n \n+    protected AbstractDeserializer(BeanDescription beanDesc)\n+    {\n+        _baseType = beanDesc.getType();\n+        _objectIdReader = null;\n+        _backRefProperties = null;\n+        Class<?> cls = _baseType.getRawClass();\n+        _acceptString = cls.isAssignableFrom(String.class);\n+        _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class);\n+        _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class);\n+        _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);\n+    }\n+    \n+    /**\n+     * Factory method used when constructing instances for non-POJO types, like\n+     * {@link java.util.Map}s.\n+     * \n+     * @since 2.3\n+     */\n+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)\n+    {\n+        return new AbstractDeserializer(beanDesc);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public accessors\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             if (type.isInterface() || type.isAbstract()) {\n                 CollectionType implType = _mapAbstractCollectionType(type, config);\n                 if (implType == null) {\n-                    throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n-                }\n-                type = implType;\n-                // But if so, also need to re-check creators...\n-                beanDesc = config.introspectForCreation(type);\n-            }\n-            ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n-            if (!inst.canCreateUsingDefault()) {\n-                // [Issue#161]: No default constructor for ArrayBlockingQueue...\n-                if (type.getRawClass() == ArrayBlockingQueue.class) {\n-                    return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n-                }\n-            }\n-            // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n-            if (contentType.getRawClass() == String.class) {\n-                // no value type deserializer because Strings are one of natural/native types:\n-                deser = new StringCollectionDeserializer(type, contentDeser, inst);\n-            } else {\n-                deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n+                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n+                    if (type.getTypeHandler() == null) {\n+                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n+                    }\n+                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n+                } else {\n+                    type = implType;\n+                    // But if so, also need to re-check creators...\n+                    beanDesc = config.introspectForCreation(type);\n+                }\n+            }\n+            if (deser == null) {\n+                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n+                if (!inst.canCreateUsingDefault()) {\n+                    // [Issue#161]: No default constructor for ArrayBlockingQueue...\n+                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n+                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n+                    }\n+                }\n+                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n+                if (contentType.getRawClass() == String.class) {\n+                    // no value type deserializer because Strings are one of natural/native types:\n+                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n+                } else {\n+                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n+                }\n             }\n         }\n         // and then new with 2.2: ability to post-process it too (Issue#120)\n         if (contentTypeDeser == null) {\n             contentTypeDeser = findTypeDeserializer(config, contentType);\n         }\n-\n+        \n         // 23-Nov-2010, tatu: Custom deserializer?\n         JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                 keyDes, contentTypeDeser, contentDeser);\n                 if (type.isInterface() || type.isAbstract()) {\n                     @SuppressWarnings(\"rawtypes\")\n                     Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n-                    if (fallback == null) {\n-                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n+                    if (fallback != null) {\n+                        mapClass = fallback;\n+                        type = (MapType) config.constructSpecializedType(type, mapClass);\n+                        // But if so, also need to re-check creators...\n+                        beanDesc = config.introspectForCreation(type);\n+                    } else {\n+                        // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n+                        if (type.getTypeHandler() == null) {\n+                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n+                        }\n+                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                     }\n-                    mapClass = fallback;\n-                    type = (MapType) config.constructSpecializedType(type, mapClass);\n-                    // But if so, also need to re-check creators...\n-                    beanDesc = config.introspectForCreation(type);\n-                }\n-                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n-                MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n-                md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n-                deser = md;\n+                }\n+                if (deser == null) {\n+                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n+                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n+                    md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n+                    deser = md;\n+                }\n             }\n         }\n         // and then new with 2.2: ability to post-process it too (Issue#120)\n             // probably only occurs if 'property' is null anyway\n             valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n         }\n-    \tif (valueTypeDeser != null) {\n+        if (valueTypeDeser != null) {\n             type = type.withTypeHandler(valueTypeDeser);\n-    \t}\n-    \treturn type;\n+        }\n+        return type;\n     }\n     \n     protected EnumResolver<?> constructEnumResolver(Class<?> enumClass,\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * For [Issue#292]\n+ */\n+@SuppressWarnings(\"serial\")\n+public class TestAbstractContainers extends BaseMapTest\n+{\n+    // Polymorphic abstract Map type, wrapper\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = MapWrapper.class, name = \"wrapper\"),\n+    })\n+    static class MapWrapper {\n+        public  IDataValueMap map = new DataValueMap();     // This does NOT work\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"_type_\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = DataValueMap.class,  name = \"DataValueMap\")\n+    })\n+    public interface IDataValueMap extends Map<String, String> { }\n+\n+    static class DataValueMap extends HashMap<String, String> implements IDataValueMap { }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = ListWrapper.class, name = \"wrapper\"),\n+    })\n+    static class ListWrapper {\n+        public IDataValueList list = new DataValueList();     // This does NOT work\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = DataValueList.class,  name = \"list\")\n+    })\n+    public interface IDataValueList extends List<String> { }\n+\n+    static class DataValueList extends LinkedList<String> implements IDataValueList { }\n+   \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testAbstractLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ListWrapper w = new ListWrapper();\n+        w.list.add(\"x\");\n+\n+        String json = mapper.writeValueAsString(w);\n+        Object o = mapper.readValue(json, ListWrapper.class);\n+        assertEquals(ListWrapper.class, o.getClass());\n+        ListWrapper out = (ListWrapper) o;\n+        assertEquals(1, out.list.size());\n+        assertEquals(\"x\", out.list.get(0));\n+   }\n+    \n+    public void testAbstractMaps() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MapWrapper w = new MapWrapper();\n+        w.map.put(\"key1\", \"name1\");\n+\n+        String json = mapper.writeValueAsString(w);\n+        Object o = mapper.readValue(json, MapWrapper.class);\n+        assertEquals(MapWrapper.class, o.getClass());\n+        MapWrapper out = (MapWrapper) o;\n+        assertEquals(1, out.map.size());\n+   }\n+}", "timestamp": 1377744153, "metainfo": ""}