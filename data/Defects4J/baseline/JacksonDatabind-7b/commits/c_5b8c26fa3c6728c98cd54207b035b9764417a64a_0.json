{"sha": "5b8c26fa3c6728c98cd54207b035b9764417a64a", "log": "Merge pull request #146 from christophercurrie/rename-creator-properties  Rename creator properties in _renameProperties()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n                 } else {\n                     old.addAll(prop);\n                 }\n+\n+                // replace the creatorProperty too, if there is one\n+                if (_creatorProperties != null) {\n+                    for (int i = 0; i < _creatorProperties.size(); ++i) {\n+                        if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) {\n+                            _creatorProperties.set(i, prop);\n+                            break;\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-//  @Override\n+    @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.deser.DataFormatReaders;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-//  @Override\n+    @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.Instantiatable;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-//  @Override\n+    @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/PackageVersion.java.in\n+package @package@;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.Versioned;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Automatically generated from PackageVersion.java.in during\n+ * packageVersion-generate execution of maven-replacer-plugin in\n+ * pom.xml.\n+ */\n+public final class PackageVersion implements Versioned {\n+    public final static Version VERSION = VersionUtil.parseVersion(\n+        \"@projectversion@\", \"@projectgroupid@\", \"@projectartifactid@\");\n+\n+    @Override\n+    public Version version() {\n+        return VERSION;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n                 if (kt == null || !kt.isEnum()) {\n                     throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n                 }\n-                deser = new EnumMapDeserializer(type, null, contentDeser);\n+                deser = new EnumMapDeserializer(type, null, contentDeser, contentTypeDeser);\n             }\n \n             // Otherwise, generic handler works ok.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n         if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {\n             String name = jp.getText();\n             Enum<?> result = _resolver.findEnum(name);\n-            if (result == null  && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                throw ctxt.weirdStringException(name, _resolver.getEnumClass(),\n-                        \"value not one of declared Enum instance names\");\n+            if (result == null) {\n+                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                    if (name.length() == 0 || name.trim().length() == 0) {\n+                        return null;\n+                    }\n+                }\n+                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+                    throw ctxt.weirdStringException(name, _resolver.getEnumClass(),\n+                            \"value not one of declared Enum instance names\");\n+                }\n             }\n             return result;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     extends StdDeserializer<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 1916979386940205321L;\n+    private static final long serialVersionUID = 1518773374647478964L;\n \n     protected final JavaType _mapType;\n     \n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n+\n+    /**\n+     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n+     */\n+    @Deprecated\n+    public EnumMapDeserializer(JavaType mapType,\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser) {\n+        this(mapType, keyDeserializer, valueDeser, null);\n+    }\n     \n     public EnumMapDeserializer(JavaType mapType,\n-            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser)\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n     {\n         super(EnumMap.class);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n         _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n     }\n \n+    /**\n+     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n+     */\n+    @Deprecated\n     public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n             JsonDeserializer<?> valueDeserializer)\n     {\n-        if ((keyDeserializer == _keyDeserializer) && valueDeserializer == _valueDeserializer) {\n+        return withResolved(keyDeserializer, valueDeserializer, null);\n+    } \n+    \n+    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n+            JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    {\n+        if ((keyDeserializer == _keyDeserializer)\n+                && (valueDeserializer == _valueDeserializer)\n+                && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         }\n         return new EnumMapDeserializer(_mapType,\n-                keyDeserializer, valueDeserializer);\n+                keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n     }\n     \n     /**\n                 vd = ((ContextualDeserializer) vd).createContextual(ctxt, property);\n             }\n         }\n-\n-        return withResolved(kd, vd);\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vd, vtd);\n     }\n     \n     /**\n             throw ctxt.mappingException(EnumMap.class);\n         }\n         EnumMap result = constructMap();\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n         while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n             Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n             /* note: MUST check for nulls separately: deserializers will\n              * not handle them (and maybe fail or return bogus data)\n              */\n-            Object value = (t == JsonToken.VALUE_NULL) ?\n-                null :  _valueDeserializer.deserialize(jp, ctxt);\n+            Object value;\n+            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value =  valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n             result.put(key, value);\n         }\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n             t = jp.nextToken();\n         }\n         final KeyDeserializer keyDes = _keyDeserializer;\n-        \n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.core.Version;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.core.Version;\n+\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n \n         @Override\n         public Version version() {\n-            return DatabindVersion.instance.version();\n-        }\n+            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n+       }\n     };\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n     public <T extends JsonNode> T deepCopy() { return (T) this; }\n     \n     public static MissingNode getInstance() { return instance; }\n+\n+    @Override\n+    public boolean isValueNode()\n+    {\n+        return false;\n+    }\n \n     @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n import com.fasterxml.jackson.core.base.ParserMinimalBase;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n                 // this will convert it to base64\n                 return n.asText();\n             }\n-        }\n-\n-        return (_currToken == null) ? null : _currToken.asString();\n+        default:\n+        \treturn (_currToken == null) ? null : _currToken.asString();\n+        }\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n         JsonSerializer<Object> prevSerializer = null;\n         Class<?> prevClass = null;\n         EnumValues keyEnums = _keyEnums;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n \n         for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            final Object valueElem = entry.getValue();\n+            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?\n+                continue;\n+            }\n             // First, serialize key\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             jgen.writeFieldName(keyEnums.serializedValueFor(key));\n-            // And then value\n-            Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n+                continue;\n+            }\n+            Class<?> cc = valueElem.getClass();\n+            JsonSerializer<Object> currSerializer;\n+            if (cc == prevClass) {\n+                currSerializer = prevSerializer;\n             } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevClass) {\n-                    currSerializer = prevSerializer;\n+                currSerializer = provider.findValueSerializer(cc, _property);\n+                prevSerializer = currSerializer;\n+                prevClass = cc;\n+            }\n+            try {\n+                if (vts == null) {\n+                    currSerializer.serialize(valueElem, jgen, provider);\n                 } else {\n-                    currSerializer = provider.findValueSerializer(cc, _property);\n-                    prevSerializer = currSerializer;\n-                    prevClass = cc;\n+                    currSerializer.serializeWithType(valueElem, jgen, provider, vts);\n                 }\n-                try {\n-                    currSerializer.serialize(valueElem, jgen, provider);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    wrapAndThrow(provider, e, value, entry.getKey().name());\n-                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                wrapAndThrow(provider, e, value, entry.getKey().name());\n             }\n         }\n     }\n         throws IOException, JsonGenerationException\n     {\n         EnumValues keyEnums = _keyEnums;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n+        \n         for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            final Object valueElem = entry.getValue();\n+            if (skipNulls && valueElem == null) { // [JACKSON-314] skip entries with null values?\n+                continue;\n+            }\n             Enum<?> key = entry.getKey();\n             if (keyEnums == null) {\n                 // clumsy, but has to do for now:\n                 keyEnums = ((EnumSerializer) ser).getEnumValues();\n             }\n             jgen.writeFieldName(keyEnums.serializedValueFor(key));\n-            Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n-            } else {\n-                try {\n+                continue;\n+            }\n+            try {\n+                if (vts == null) {\n                     valueSer.serialize(valueElem, jgen, provider);\n-                } catch (Exception e) {\n-                    wrapAndThrow(provider, e, value, entry.getKey().name());\n+                } else {\n+                    valueSer.serializeWithType(valueElem, jgen, provider, vts);\n                 }\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, entry.getKey().name());\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n package com.fasterxml.jackson.databind.util;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.io.*;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n-\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Utility class used for efficient storage of {@link JsonToken}\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n \n     /**\n \n         @Override\n         public Version version() {\n-            return DatabindVersion.instance.version();\n-        }\n-        \n+            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n+        }\n+\n         /*\n         /**********************************************************\n         /* Extended API beyond JsonParser\n             case VALUE_NUMBER_FLOAT:\n                 Object ob = _currentObject();\n                 return (ob == null) ? null : ob.toString();\n-            }\n-            return _currToken.asString();\n+            default:\n+            \treturn _currToken.asString();\n+            }\n         }\n \n         @Override\n             if (n instanceof BigInteger) {\n                 return (BigInteger) n;\n             }\n-            switch (getNumberType()) {\n-            case BIG_DECIMAL:\n+            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                 return ((BigDecimal) n).toBigInteger();\n             }\n             // int/long is simple, but let's also just truncate float/double:\n                 return BigDecimal.valueOf(n.longValue());\n             case BIG_INTEGER:\n                 return new BigDecimal((BigInteger) n);\n+            default:\n             }\n             // float or double\n             return BigDecimal.valueOf(n.doubleValue());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.cfg.PackageVersion;\n \n /**\n  * Tests to ensure that we get proper Version information via\n  */\n public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n {\n-    // Not a good to do this, but has to do, for now...\n-    private final static int MAJOR_VERSION = 2;\n-    private final static int MINOR_VERSION = 2;\n-\n-    private final static String GROUP_ID = \"com.fasterxml.jackson.core\";\n-    private final static String ARTIFACT_ID = \"jackson-databind\";\n-\n     public void testMapperVersions()\n     {\n         ObjectMapper mapper = new ObjectMapper();\n     {\n         Version v = vers.version();\n         assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n-        assertEquals(MAJOR_VERSION, v.getMajorVersion());\n-        assertEquals(MINOR_VERSION, v.getMinorVersion());\n-        // Check patch level initially, comment out for maint versions\n-//        assertEquals(0, v.getPatchLevel());\n-        assertEquals(GROUP_ID, v.getGroupId());\n-        assertEquals(ARTIFACT_ID, v.getArtifactId());\n+        Version exp = PackageVersion.VERSION;\n+        assertEquals(exp.toFullString(), v.toFullString());\n+        assertEquals(exp, v);\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n             y = y0;\n         }\n     }\n+\n+    // [JACKSON-882]\n+    public static class CustomKey {\n+        private final int id;\n+\n+        public CustomKey(int id) {this.id = id;}\n+\n+        public int getId() { return id; }\n+    }\n+    \n+    public static class Model\n+    {\n+        protected final Map<CustomKey, String> map;\n+\n+        @JsonCreator\n+        public Model(@JsonProperty(\"map\") @JsonDeserialize(keyUsing = CustomKeyDeserializer.class) Map<CustomKey, String> map)\n+        {\n+            this.map = new HashMap<CustomKey, String>(map);\n+        }\n+\n+        @JsonProperty\n+        @JsonSerialize(keyUsing = CustomKeySerializer.class)\n+        public Map<CustomKey, String> getMap() {\n+            return map;\n+        }\n+    }\n+     \n+    static class CustomKeySerializer extends JsonSerializer<CustomKey> {\n+        @Override\n+        public void serialize(CustomKey value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeFieldName(String.valueOf(value.getId()));\n+        }\n+    }\n+\n+    static class CustomKeyDeserializer extends KeyDeserializer {\n+        @Override\n+        public CustomKey deserializeKey(String key, DeserializationContext ctxt) throws IOException {\n+            return new CustomKey(Integer.valueOf(key));\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n+    final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testCustomBeanDeserializer() throws Exception\n     {\n-\n-        final ObjectMapper map = new ObjectMapper();\n         String json = \"{\\\"beans\\\":[{\\\"c\\\":{\\\"a\\\":10,\\\"b\\\":20},\\\"d\\\":\\\"hello, tatu\\\"}]}\";\n-        TestBeans beans = map.readValue(json, TestBeans.class);\n+        TestBeans beans = MAPPER.readValue(json, TestBeans.class);\n \n         assertNotNull(beans);\n         List<TestBean> results = beans.beans;\n \n         json = \"{\\\"beans\\\":[{\\\"c\\\":{\\\"b\\\":3,\\\"a\\\":-4},\\\"d\\\":\\\"\\\"},\"\n             +\"{\\\"d\\\":\\\"abc\\\", \\\"c\\\":{\\\"b\\\":15}}]}\";\n-        beans = map.readValue(json, TestBeans.class);\n+        beans = MAPPER.readValue(json, TestBeans.class);\n \n         assertNotNull(beans);\n         results = beans.beans;\n         assertEquals(3, imm.x);\n         assertEquals(7, imm.y);\n     }\n+\n+    public void testIssue882() throws Exception\n+    {\n+        Model original = new Model(Collections.singletonMap(new CustomKey(123), \"test\"));\n+        String json = MAPPER.writeValueAsString(original);\n+        Model deserialized = MAPPER.readValue(json, Model.class);\n+        assertNotNull(deserialized);\n+        assertNotNull(deserialized.map);\n+        assertEquals(1, deserialized.map.size());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n         TestEnumFor834 res = mapper.readValue(\"1 \", TestEnumFor834.class);\n         assertSame(TestEnumFor834.ENUM_A, res);\n     }\n+\n+    // [Issue#141]: allow mapping of empty String into null\n+    public void testEnumsWithEmpty() throws Exception\n+    {\n+       final ObjectMapper m = new ObjectMapper();\n+       m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+       TestEnum result = m.readValue(\"\\\"\\\"\", TestEnum.class);\n+       assertNull(result);\n+    }\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n             return new KeyType(v, true);\n         }\n     }\n+\n+    // Issue #142\n+    public static class EnumMapContainer {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+        public EnumMap<KeyEnum,ITestType> testTypes;\n+    }\n+\n+    public static class ListContainer {\n+        public List<ITestType> testTypes;\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+    public static interface ITestType { }\n+\n+    public static enum KeyEnum {\n+        A, B\n+    }\n+    public static enum ConcreteType implements ITestType {\n+        ONE, TWO;\n+    }\n+\n+    \n     \n     /*\n     /**********************************************************\n         assertNull(result.get(Key.WHATEVER));\n         assertNull(result.get(Key.KEY1));\n     }\n-    \n+\n+    public void testEnumPolymorphicSerializationTest() throws Exception \n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        List<ITestType> testTypesList = new ArrayList<ITestType>();\n+        testTypesList.add(ConcreteType.ONE);\n+        testTypesList.add(ConcreteType.TWO);\n+        ListContainer listContainer = new ListContainer();\n+        listContainer.testTypes = testTypesList;\n+        String json = mapper.writeValueAsString(listContainer);\n+        listContainer = mapper.readValue(json, ListContainer.class);\n+        EnumMapContainer enumMapContainer = new EnumMapContainer();\n+        EnumMap<KeyEnum,ITestType> testTypesMap = new EnumMap<KeyEnum,ITestType>(KeyEnum.class);\n+        testTypesMap.put(KeyEnum.A, ConcreteType.ONE);\n+        testTypesMap.put(KeyEnum.B, ConcreteType.TWO);\n+        enumMapContainer.testTypes = testTypesMap;\n+        \n+        json = mapper.writeValueAsString(enumMapContainer);\n+        enumMapContainer = mapper.readValue(json, EnumMapContainer.class);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods, maps with Date\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdSerialization.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonIdentityReference;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+/**\n+ * Tests for github ussues #138\n+ * https://github.com/FasterXML/jackson-databind/issues/138\n+ */\n+public class TestObjectIdSerialization extends BaseMapTest {\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    static protected class Obj {\n+\n+        public int id;\n+        @JsonIdentityReference(alwaysAsId = true)\n+        public SetContainer objGroup;\n+\n+        public Obj(int id) {\n+            this.id = id;\n+        }\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    static protected class SetContainer {\n+\n+        public int id;\n+        @JsonIdentityReference(alwaysAsId = true)\n+//        @JsonSerialize(contentAs = Obj.class)\n+        public Set<Obj> objs = new LinkedHashSet<Obj>();\n+\n+        public SetContainer(int id) {\n+            this.id = id;\n+        }\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    static protected class ArrContainer {\n+\n+        public int id;\n+        @JsonIdentityReference(alwaysAsId = true)\n+        public Obj[] objs;\n+\n+        public ArrContainer(int id) {\n+            this.id = id;\n+        }\n+    }\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    private final static String EXP_ARR_SET = \"{\\\"id\\\":4,\\\"objs\\\":[1,7]}\";\n+\n+    public void testArraySerialization() throws Exception {\n+        Obj o = new Obj(1);\n+        Obj o2 = new Obj(7);\n+        ArrContainer oa = new ArrContainer(4);\n+        oa.objs = new Obj[]{o, o2};\n+        String json = MAPPER.writeValueAsString(oa);\n+        assertEquals(EXP_ARR_SET, json);\n+    }\n+\n+    public void testCollectionSerialization() throws Exception {\n+        Obj o = new Obj(1);\n+        Obj o2 = new Obj(7);\n+        SetContainer os = new SetContainer(4);\n+        os.objs.add(o);\n+        os.objs.add(o2);\n+        String json = MAPPER.writeValueAsString(os);\n+        assertEquals(EXP_ARR_SET, json);\n+    }\n+}", "timestamp": 1358018926, "metainfo": ""}