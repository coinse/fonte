{"sha": "f2a2d4d24b6b1176117940f5e4c75eae550d742b", "log": "Fix handling of String[] deserializer, to allow customization as expected.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n      */\n     public static class Base implements ValueInstantiators\n     {\n-//      @Override\n+        @Override\n         public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n                 BeanDescription beanDesc, ValueInstantiator defaultInstantiator) {\n             return defaultInstantiator;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n-import com.fasterxml.jackson.databind.util.ObjectBuffer;\n \n \n /**\n         add(float.class, new FloatDeser());\n         add(double.class, new DoubleDeser());\n \n-        add(String.class, new StringDeser());\n+        add(String.class, new StringArrayDeserializer());\n         /* also: char[] is most likely only used with Strings; doesn't\n          * seem to make sense to transfer as numbers\n          */\n     /********************************************************\n     */\n \n-    @JacksonStdImpl\n-    final static class StringDeser\n-        extends Base<String[]>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        public StringDeser() { super(String[].class); }\n-\n-        @Override\n-        public String[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            // Ok: must point to START_ARRAY (or equivalent)\n-            if (!jp.isExpectedStartArrayToken()) {\n-                return handleNonArray(jp, ctxt);\n-            }\n-            final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n-            Object[] chunk = buffer.resetAndStart();\n-            int ix = 0;\n-            JsonToken t;\n-            \n-            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-                // Ok: no need to convert Strings, but must recognize nulls\n-                String value = (t == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt);\n-                if (ix >= chunk.length) {\n-                    chunk = buffer.appendCompletedChunk(chunk);\n-                    ix = 0;\n-                }\n-                chunk[ix++] = value;\n-            }\n-            String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n-            ctxt.returnObjectBuffer(buffer);\n-            return result;\n-        }\n-    \n-        private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            // [JACKSON-526]: implicit arrays from single values?\n-            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n-                // [JACKSON-620] Empty String can become null...\n-                if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                        && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                    String str = jp.getText();\n-                    if (str.length() == 0) {\n-                        return null;\n-                    }\n-                }\n-                throw ctxt.mappingException(_valueClass);\n-            }\n-            return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n-        }\n-    }\n-    \n     @JacksonStdImpl\n     final static class CharDeser\n         extends Base<char[]>\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+\n+/**\n+ * Separate implementation for serializing String arrays (instead of\n+ * using {@link ObjectArraySerializer}. Used if (and only if) no custom\n+ * value deserializers are used.\n+ */\n+@JacksonStdImpl\n+final class StringArrayDeserializer\n+    extends StdDeserializer<String[]>\n+    implements ContextualDeserializer\n+{\n+    private static final long serialVersionUID = -4286917407100819199L;\n+\n+    /**\n+     * Value serializer to use, if not the standard one (which is inlined)\n+     */\n+    protected JsonDeserializer<String> _elementDeserializer;\n+\n+    public StringArrayDeserializer() {\n+        super(String[].class);\n+        _elementDeserializer = null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected StringArrayDeserializer(JsonDeserializer<?> deser) {\n+        super(String[].class);\n+        _elementDeserializer = (JsonDeserializer<String>) deser;\n+    }\n+   \n+    @Override\n+    public String[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_ARRAY (or equivalent)\n+        if (!jp.isExpectedStartArrayToken()) {\n+            return handleNonArray(jp, ctxt);\n+        }\n+        if (_elementDeserializer != null) {\n+            return _deserializeCustom(jp, ctxt);\n+        }\n+\n+        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+        Object[] chunk = buffer.resetAndStart();\n+        \n+        int ix = 0;\n+        JsonToken t;\n+        \n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            // Ok: no need to convert Strings, but must recognize nulls\n+            String value;\n+            if (t == JsonToken.VALUE_STRING) {\n+                value = jp.getText();\n+            } else if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else {\n+                value = _parseString(jp, ctxt);\n+            }\n+            if (ix >= chunk.length) {\n+                chunk = buffer.appendCompletedChunk(chunk);\n+                ix = 0;\n+            }\n+            chunk[ix++] = value;\n+        }\n+        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n+        ctxt.returnObjectBuffer(buffer);\n+        return result;\n+    }\n+\n+    /**\n+     * Offlined version used when we do not use the default deserialization method.\n+     */\n+    protected final String[] _deserializeCustom(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+        Object[] chunk = buffer.resetAndStart();\n+        final JsonDeserializer<String> deser = _elementDeserializer;\n+        \n+        int ix = 0;\n+        JsonToken t;\n+        \n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            // Ok: no need to convert Strings, but must recognize nulls\n+            String value = (t == JsonToken.VALUE_NULL) ? null : deser.deserialize(jp, ctxt);\n+            if (ix >= chunk.length) {\n+                chunk = buffer.appendCompletedChunk(chunk);\n+                ix = 0;\n+            }\n+            chunk[ix++] = value;\n+        }\n+        String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n+        ctxt.returnObjectBuffer(buffer);\n+        return result;\n+    }\n+    \n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+        TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+    }\n+\n+    private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-526]: implicit arrays from single values?\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                String str = jp.getText();\n+                if (str.length() == 0) {\n+                    return null;\n+                }\n+            }\n+            throw ctxt.mappingException(_valueClass);\n+        }\n+        return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : _parseString(jp, ctxt) };\n+    }\n+\n+    /**\n+     * Contextualization is needed to see whether we can \"inline\" deserialization\n+     * of String values, or if we have to use separate value deserializer.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonDeserializer<?> deser = _elementDeserializer;\n+        // #125: May have a content converter\n+        deser = findConvertingContentDeserializer(ctxt, property, deser);\n+        if (deser == null) {\n+            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n+        } else { // if directly assigned, probably not yet contextual, so:\n+            if (deser instanceof ContextualDeserializer) {\n+                deser = ((ContextualDeserializer) deser).createContextual(ctxt, property);\n+            }\n+        }\n+        // Ok ok: if all we got is the default String deserializer, can just forget about it\n+        if (deser != null && this.isDefaultDeserializer(deser)) {\n+            deser = null;\n+        }\n+        if (_elementDeserializer != deser) {\n+            return new StringArrayDeserializer(deser);\n+        }\n+        return this;\n+    }\n+}\n+    \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n     /* Life-cycle\n     /**********************************************************\n      */\n-    \n+\n     public CollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts,\n             BeanProperty property, JsonSerializer<Object> valueSerializer)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n     /**********************************************************\n      */\n \n-//  @Override\n+    @Override\n     public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException, JsonProcessingException\n         typeSer.writeTypeSuffixForScalar(this, jgen);\n     }\n \n-//  @Override\n+    @Override\n     public void serialize(JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonProcessingException\n     {", "timestamp": 1362278476, "metainfo": ""}