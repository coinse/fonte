{"sha": "5639f3459976aa04e02da9f72af97a92adc6b7a9", "log": "Completed [JACKSON-608] (Json Views for deserialization), with tests", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n  * Builder object that can be used for per-serialization configuration of\n  * deserialization parameters, such as root type to use or object\n  * to update (instead of constructing new instance).\n- * Uses \"fluid\" (aka builder) pattern so that instances are immutable\n+ *<p>\n+ * Uses \"fluent\" (aka builder) pattern so that instances are immutable\n  * (and thus fully thread-safe with no external synchronization);\n  * new instances are constructed for different configurations.\n  * Instances are initially constructed by {@link ObjectMapper} and can be\n- * reused.\n+ * reused, shared, cached; both because of thread-safety and because\n+ * instances are relatively light-weight.\n  */\n public class ObjectReader\n     extends ObjectCodec\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withType(TypeReference<?> valueTypeRef)\n-    {\n+    public ObjectReader withType(TypeReference<?> valueTypeRef) {\n         return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n     }    \n \n         JavaType t = (_valueType == null) ? _config.constructType(value.getClass()) : _valueType;\n         return new ObjectReader(this, _config, t, value,\n                 _schema, _injectableValues);\n-    }    \n+    }\n+\n+    /**\n+     * Method for constructing a new instance with configuration that\n+     * uses specified View for filtering.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withView(Class<?> activeView) {\n+        DeserializationConfig newConfig = _config.withView(activeView);\n+        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n             // Skip field name:\n             jp.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n-            \n-            if (prop != null) { // normal case\n+            if (prop != null) {\n+                if (!prop.visibleInView(activeView)) {\n+                    jp.skipChildren();\n+                    continue;\n+                }\n                 try {\n                     prop.deserializeAndSet(jp, ctxt, bean);\n                 } catch (Exception e) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n      */\n     private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n \n+    private final static Class<?>[] NO_VIEWS = new Class<?>[0];\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n                 }\n             }\n             if (prop != null) {\n+                Class<?>[] views = propDef.findViews();\n+                if (views == null) {\n+                    // one more twist: if default inclusion disabled, need to force empty set of views\n+                    if (!ctxt.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION)) {\n+                        views = NO_VIEWS;\n+                    }\n+                }\n                 // one more thing before adding to builder: copy any metadata\n-                prop.setViews(propDef.findViews());\n+                prop.setViews(views);\n                 builder.addProperty(prop);\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.Annotations;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.ViewMatcher;\n \n /**\n  * Base class for settable properties of a bean: contains\n     protected String _managedReferenceName;\n \n     /**\n-     * If property has associated view information (list of\n-     * Views in which property is to be included), this contains\n-     * those views; if not, will be null.\n-     */\n-    protected Class<?>[] _views;\n+     * Helper object used for checking whether this property is to\n+     * be included in the active view, if property is view-specific;\n+     * null otherwise.\n+     */\n+    protected ViewMatcher _viewMatcher;\n     \n     /**\n      * Index of property (within all property of a bean); assigned\n         _type = type;\n         _contextAnnotations = contextAnnotations;\n         _valueTypeDeserializer = typeDeser;\n+        _viewMatcher = null;\n     }\n \n     /**\n         _nullProvider = src._nullProvider;\n         _managedReferenceName = src._managedReferenceName;\n         _propertyIndex = src._propertyIndex;\n+        _viewMatcher = src._viewMatcher;\n     }\n \n     /**\n             Object nvl = deser.getNullValue();\n             _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl);\n         }\n+        _viewMatcher = src._viewMatcher;\n     }\n \n     /**\n         _nullProvider = src._nullProvider;\n         _managedReferenceName = src._managedReferenceName;\n         _propertyIndex = src._propertyIndex;\n+        _viewMatcher = src._viewMatcher;\n     }\n     \n     public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<Object> deser);\n     }\n     \n     public void setViews(Class<?>[] views) {\n-        _views = views;\n+        if (views == null) {\n+            _viewMatcher = null;\n+        } else {\n+            _viewMatcher = ViewMatcher.construct(views);\n+        }\n     }\n     \n     /**\n \n     public TypeDeserializer getValueTypeDeserializer() { return _valueTypeDeserializer; }\n \n-    public Class<?>[] getViews() { return _views; }\n-\n-    public boolean hasViews() { return _views != null; }\n+    public boolean visibleInView(Class<?> activeView) {\n+        return (_viewMatcher == null) || _viewMatcher.isVisibleForView(activeView);\n+    }\n+    \n+    public boolean hasViews() { return _viewMatcher != null; }\n     \n     /**\n      * Method for accessing unique index of this property; indexes are\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ViewMatcher.java\n+package com.fasterxml.jackson.databind.util;\n+\n+/**\n+ * Helper class used for checking whether a property is visible\n+ * in the active view\n+ */\n+public abstract class ViewMatcher\n+{\n+    public abstract boolean isVisibleForView(Class<?> activeView);\n+\n+    public static ViewMatcher construct(Class<?>[] views)\n+    {\n+        if (views == null) {\n+            return Empty.instance;\n+        }\n+        switch (views.length) {\n+        case 0:\n+            return Empty.instance;\n+        case 1:\n+            return new Single(views[0]);\n+        }\n+        return new Multi(views);\n+    } \n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete sub-classes\n+    /**********************************************************\n+     */\n+\n+    private final static class Empty extends ViewMatcher {\n+        final static Empty instance = new Empty();\n+        public boolean isVisibleForView(Class<?> activeView) {\n+            return false;\n+        }\n+    }\n+\n+    private final static class Single extends ViewMatcher {\n+        private final Class<?> _view;\n+        public Single(Class<?> v) { _view = v; }\n+        public boolean isVisibleForView(Class<?> activeView) {\n+            return (activeView == _view) || _view.isAssignableFrom(activeView);\n+        }\n+    }\n+\n+    private final static class Multi extends ViewMatcher {\n+        private final Class<?>[] _views;\n+\n+        public Multi(Class<?>[] v) { _views = v; }\n+\n+        public boolean isVisibleForView(Class<?> activeView)\n+        {\n+            for (int i = 0, len = _views.length; i < len; ++i) {\n+                Class<?> view = _views[i];\n+                if ((activeView == view) || view.isAssignableFrom(activeView)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n import com.fasterxml.jackson.annotation.JsonView;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestViewDeserialization extends BaseMapTest\n {\n         public void setB(int value) { b = value; }\n     }\n \n+    static class DefaultsBean\n+    {\n+        public int a;\n+\n+        @JsonView(ViewA.class)\n+        public int b;\n+    }\n+\n     /*\n     /************************************************************************ \n     /* Tests\n     \n     public void testSimple() throws Exception\n     {\n-        Bean bean = mapper.readerWithView(ViewAA.class)\n+        // by default, should have it all...\n+        Bean bean = mapper\n+                .readValue(\"{\\\"a\\\":3, \\\"aa\\\":\\\"foo\\\", \\\"b\\\": 9 }\", Bean.class);\n+        assertEquals(3, bean.a);\n+        assertEquals(\"foo\", bean.aa);\n+        assertEquals(9, bean.b);\n+        \n+        // but with different views, different contents\n+        bean = mapper.readerWithView(ViewAA.class)\n                 .withType(Bean.class)\n                 .readValue(\"{\\\"a\\\":3, \\\"aa\\\":\\\"foo\\\", \\\"b\\\": 9 }\");\n         // should include 'a' and 'aa' (as per view)\n         assertEquals(\"foo\", bean.aa);\n         // but not 'b'\n         assertEquals(0, bean.b);\n+\n+        bean = mapper.readerWithView(ViewA.class)\n+                .withType(Bean.class)\n+                .readValue(\"{\\\"a\\\":1, \\\"aa\\\":\\\"x\\\", \\\"b\\\": 3 }\");\n+        assertEquals(1, bean.a);\n+        assertNull(bean.aa);\n+        assertEquals(0, bean.b);\n+        \n+        bean = mapper.reader(Bean.class)\n+                .withView(ViewB.class)\n+                .readValue(\"{\\\"a\\\":-3, \\\"aa\\\":\\\"y\\\", \\\"b\\\": 2 }\");\n+        assertEquals(0, bean.a);\n+        assertEquals(\"y\", bean.aa);\n+        assertEquals(2, bean.b);\n+    }\n+\n+    public void testWithoutDefaultInclusion() throws Exception\n+    {\n+        // without active view, all included still:\n+        DefaultsBean bean = mapper\n+                .readValue(\"{\\\"a\\\":3, \\\"b\\\": 9 }\", DefaultsBean.class);\n+        assertEquals(3, bean.a);\n+        assertEquals(9, bean.b);\n+\n+        ObjectMapper myMapper = new ObjectMapper();\n+        myMapper.disable(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+\n+        // but with, say, AA, will not get 'b'\n+        bean = myMapper.readerWithView(ViewAA.class)\n+                .withType(DefaultsBean.class)\n+                .readValue(\"{\\\"a\\\":1, \\\"b\\\": 2 }\");\n+        // 'a' not there any more\n+        assertEquals(0, bean.a);\n+        assertEquals(2, bean.b);\n     }\n }", "timestamp": 1327732433, "metainfo": ""}