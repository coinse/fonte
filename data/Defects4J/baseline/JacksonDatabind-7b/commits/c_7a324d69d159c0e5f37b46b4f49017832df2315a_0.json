{"sha": "7a324d69d159c0e5f37b46b4f49017832df2315a", "log": "Trying to straighten out type handling, related to schema generation", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n \n public interface JsonArrayFormatVisitor extends JsonFormatVisitorWithSerializerProvider\n {\n-\tvoid itemsFormat(JavaType contentType) throws JsonMappingException;\n-\tvoid itemsFormat(JsonFormatTypes format) throws JsonMappingException;\n+    /**\n+     * Visit method called for structured types, as well as possibly\n+     * for leaf types (especially if handled by custom serializers).\n+     * \n+     * @param handler Serializer used, to allow for further callbacks\n+     * @param elementType Type of elements in JSON array value\n+     */\n+    void itemsFormat(JsonFormatVisitable handler, JavaType elementType);\n+    \n+    /**\n+     * Visit method that is called if the content type is a simple\n+     * scalar type like {@link JsonFormatTypes#STRING} (but not\n+     * for structured types like {@link JsonFormatTypes#OBJECT} since\n+     * they would be missing type information).\n+     */\n+    void itemsFormat(JsonFormatTypes format) throws JsonMappingException;\n+\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for serializers that will output contents as JSON\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n     {\n-        /* 15-Jan-2010, tatu: This should probably be rewritten, given that\n-         *    more information about content type is actually being explicitly\n-         *    passed. So there should be less need to try to re-process that\n-         *    information.\n-         */\n-        //ObjectNode o = createSchemaNode(\"array\", true);\n         JsonArrayFormatVisitor arrayVisitor = visitor.expectArrayFormat(typeHint);\n-        JavaType contentType = null;\n-        if (typeHint != null) {\n-            contentType = typeHint.getContentType();\n-            if (contentType == null) { // could still be parameterized (Iterators)\n-                // 30-Sep-2012, tatu: This is wrong, should use TypeFactory... but it is alas\n-                //    not being passed (oversight)\n-                if (typeHint instanceof ParameterizedType) {\n-                    Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n-                    if (typeArgs.length == 1) {\n-                        contentType = visitor.getProvider().constructType(typeArgs[0]);\n-                    }\n-                }\n-            }\n-        }\n-        if (contentType == null && _elementType != null) {\n-            contentType = _elementType;\n-        }\n-        if (contentType != null) {\n-//            JsonNode schemaNode = null;\n-            arrayVisitor.itemsFormat(contentType);\n-        }\n+        if (arrayVisitor == null) { // not sure if this is legal but...\n+            return; \n+        }\n+        TypeFactory tf = visitor.getProvider().getTypeFactory();\n+        JavaType contentType = tf.moreSpecificType(_elementType, typeHint.getContentType());\n+        if (contentType == null) {\n+            throw new JsonMappingException(\"Could not resolve type\");\n+        }\n+        JsonSerializer<?> valueSer = _elementSerializer;\n+        if (valueSer == null) {\n+            valueSer = visitor.getProvider().findValueSerializer(contentType, _property);\n+        }\n+        arrayVisitor.itemsFormat(valueSer, contentType);\n     }\n \n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.ArrayType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Generic serializer for Object arrays (<code>Object[]</code>).\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n     {\n-        visitor.expectArrayFormat(typeHint).itemsFormat(_elementType);\n+        JsonArrayFormatVisitor arrayVisitor = visitor.expectArrayFormat(typeHint);\n+        if (arrayVisitor == null) { // not sure if this is legal but...\n+            return; \n+        }\n+        TypeFactory tf = visitor.getProvider().getTypeFactory();\n+        JavaType contentType = tf.moreSpecificType(_elementType, typeHint.getContentType());\n+        if (contentType == null) {\n+            throw new JsonMappingException(\"Could not resolve type\");\n+        }\n+        JsonSerializer<?> valueSer = _elementSerializer;\n+        if (valueSer == null) {\n+            valueSer = visitor.getProvider().findValueSerializer(contentType, _property);\n+        }\n+        arrayVisitor.itemsFormat(valueSer, contentType);\n     }\n \n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n \n     /*\n     /**********************************************************\n-    /* Overrides for supporting Serializable\n-    /**********************************************************\n-     */\n-    \n-    /*\n-    /**********************************************************\n     /* Static methods for non-instance-specific functionality\n     /**********************************************************\n      */\n     }\n     \n     /*\n+    /**********************************************************\n     /* Type conversion, parameterization resolution methods\n     /**********************************************************\n      */\n         }\n         return bindings.typesAsArray();\n     }\n+\n+    /**\n+     * Method that can be called to figure out more specific of two\n+     * types (if they are related; that is, one implements or extends the\n+     * other); or if not related, return the primary type.\n+     * \n+     * @param type1 Primary type to consider\n+     * @param type2 Secondary type to consider\n+     * \n+     * @since 2.2\n+     */\n+    public JavaType moreSpecificType(JavaType type1, JavaType type2)\n+    {\n+        if (type1 == null) {\n+            return type2;\n+        }\n+        if (type2 == null) {\n+            return type1;\n+        }\n+        Class<?> raw1 = type1.getRawClass();\n+        Class<?> raw2 = type2.getRawClass();\n+        if (raw1 == raw2) {\n+            return type1;\n+        }\n+        // TODO: maybe try sub-classing, to retain generic types?\n+        if (raw1.isAssignableFrom(raw2)) {\n+            return type2;\n+        }\n+        return type1;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n         assertEquals(TypeFactory.unknownType(), type.getKeyType());\n         assertEquals(TypeFactory.unknownType(), type.getContentType());\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: other\n+    /**********************************************************\n+     */\n+    \n+    public void testMoreSpecificType()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+\n+        JavaType t1 = tf.constructCollectionType(Collection.class, Object.class);\n+        JavaType t2 = tf.constructCollectionType(List.class, Object.class);\n+        assertSame(t2, tf.moreSpecificType(t1, t2));\n+        assertSame(t2, tf.moreSpecificType(t2, t1));\n+\n+        t1 = tf.constructType(Double.class);\n+        t2 = tf.constructType(Number.class);\n+        assertSame(t1, tf.moreSpecificType(t1, t2));\n+        assertSame(t1, tf.moreSpecificType(t2, t1));\n+\n+        // and then unrelated, return first\n+        t1 = tf.constructType(Double.class);\n+        t2 = tf.constructType(String.class);\n+        assertSame(t1, tf.moreSpecificType(t1, t2));\n+        assertSame(t2, tf.moreSpecificType(t2, t1));\n+    }\n }\n-\n+        ", "timestamp": 1353385571, "metainfo": ""}