{"sha": "f293cc4700fdd812456fc1f18a14c0e6ad065cce", "log": "Implemented [JACKSON-810]; add 'DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      */\n \n     /**\n-     * SerializationFeature that determines whether JSON floating point numbers\n+     * Feature that determines whether JSON floating point numbers\n      * are to be deserialized into {@link java.math.BigDecimal}s\n      * if only generic type description (either {@link Object} or\n      * {@link Number}, or within untyped {@link java.util.Map}\n      * If enabled such values will be deserialized as {@link java.math.BigDecimal}s;\n      * if disabled, will be deserialized as {@link Double}s.\n      * <p>\n-     * SerializationFeature is disabled by default, meaning that \"untyped\" floating\n+     * Feature is disabled by default, meaning that \"untyped\" floating\n      * point numbers will by default be deserialized as {@link Double}s\n      * (choice is for performance reason -- BigDecimals are slower than\n      * Doubles).\n     USE_BIG_DECIMAL_FOR_FLOATS(false),\n \n     /**\n-     * SerializationFeature that determines whether JSON integral (non-floating-point)\n+     * Feature that determines whether JSON integral (non-floating-point)\n      * numbers are to be deserialized into {@link java.math.BigInteger}s\n      * if only generic type description (either {@link Object} or\n      * {@link Number}, or within untyped {@link java.util.Map}\n      * which is either {@link Integer}, {@link Long} or\n      * {@link java.math.BigInteger}, depending on number of digits.\n      * <p>\n-     * SerializationFeature is disabled by default, meaning that \"untyped\" floating\n+     * Feature is disabled by default, meaning that \"untyped\" floating\n      * point numbers will by default be deserialized using whatever\n      * is the most compact integral type, to optimize efficiency.\n      */\n \n     // [JACKSON-652]\n     /**\n-     * SerializationFeature that determines whether JSON Array is mapped to\n+     * Feature that determines whether JSON Array is mapped to\n      * <code>Object[]</code> or <code>List&lt;Object></code> when binding\n      * \"untyped\" objects (ones with nominal type of <code>java.lang.Object</code>).\n      * If true, binds as <code>Object[]</code>; if false, as <code>List&lt;Object></code>.\n      *<p>\n-     * SerializationFeature is disabled by default, meaning that JSON arrays are bound as\n+     * Feature is disabled by default, meaning that JSON arrays are bound as\n      * {@link java.util.List}s.\n      */\n     USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n     \n     /**\n-     * SerializationFeature that determines standard deserialization mechanism used for\n+     * Feature that determines standard deserialization mechanism used for\n      * Enum values: if enabled, Enums are assumed to have been serialized  using\n      * return value of <code>Enum.toString()</code>;\n      * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n      * Note: this feature should usually have same value\n      * as {@link SerializationFeature#WRITE_ENUMS_USING_TO_STRING}.\n      *<p>\n-     * SerializationFeature is disabled by default.\n+     * Feature is disabled by default.\n      */\n     READ_ENUMS_USING_TO_STRING(false),\n     \n      */\n \n     /**\n-     * SerializationFeature that determines whether encountering of unknown\n+     * Feature that determines whether encountering of unknown\n      * properties (ones that do not map to a property, and there is\n      * no \"any setter\" or handler that can handle it)\n      * should result in a failure (by throwing a\n      * methods for unknown properties have been tried, and\n      * property remains unhandled.\n      *<p>\n-     * SerializationFeature is enabled by default (meaning that a\n+     * Feature is enabled by default (meaning that a\n      * {@link JsonMappingException} will be thrown if an unknown property\n      * is encountered).\n      */\n     FAIL_ON_UNKNOWN_PROPERTIES(true),\n \n     /**\n-     * SerializationFeature that determines whether encountering of JSON null\n+     * Feature that determines whether encountering of JSON null\n      * is an error when deserializing into Java primitive types\n      * (like 'int' or 'double'). If it is, a JsonProcessingException\n      * is thrown to indicate this; if not, default value is used\n      * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n      *<p>\n-     * SerializationFeature is disabled by default.\n+     * Feature is disabled by default.\n      */\n     FAIL_ON_NULL_FOR_PRIMITIVES(false),\n \n     /**\n-     * SerializationFeature that determines whether JSON integer numbers are valid\n+     * Feature that determines whether JSON integer numbers are valid\n      * values to be used for deserializing Java enum values.\n      * If set to 'false' numbers are acceptable and are used to map to\n      * ordinal() of matching enumeration value; if 'true', numbers are\n      * mapping from integer values to enums might happen (and when enums\n      * are always serialized as JSON Strings)\n      *<p>\n-     * SerializationFeature is disabled by default.\n+     * Feature is disabled by default.\n      */\n     FAIL_ON_NUMBERS_FOR_ENUMS(false),\n \n     /**\n-     * SerializationFeature that determines whether Jackson code should catch\n+     * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n      * to add additional information about\n      * location (within input) of problem or not. If enabled,\n      * However, sometimes calling application may just want \"raw\"\n      * unchecked exceptions passed as is.\n      *<p>\n-     * SerializationFeature is enabled by default.\n+     * Feature is enabled by default.\n      */\n     WRAP_EXCEPTIONS(true),\n     \n      */\n \n     /**\n-     * SerializationFeature that determines whether it is acceptable to coerce non-array\n+     * Feature that determines whether it is acceptable to coerce non-array\n      * (in JSON) values to work with Java collection (arrays, java.util.Collection)\n      * types. If enabled, collection deserializers will try to handle non-array\n      * values as if they had \"implicit\" surrounding JSON array.\n      * to work with packages (such as XML-to-JSON converters) that leave out JSON\n      * array in cases where there is just a single element in array.\n      *<p>\n-     * SerializationFeature is disabled by default.\n+     * Feature is disabled by default.\n      */\n     ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n     \n     /**\n-     * SerializationFeature to allow \"unwrapping\" root-level JSON value, to match setting of\n+     * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n      * {@link SerializationFeature#WRAP_ROOT_VALUE} used for serialization.\n      * Will verify that the root JSON value is a JSON Object, and that it has\n      * a single property with expected root name. If not, a\n      * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n      * will be deserialized as if it was the root value.\n      *<p>\n-     * SerializationFeature is disabled by default.\n+     * Feature is disabled by default.\n      */\n     UNWRAP_ROOT_VALUE(false),\n \n      */\n     \n     /**\n-     * SerializationFeature that can be enabled to allow JSON empty String\n+     * Feature that can be enabled to allow JSON empty String\n      * value (\"\") to be bound to POJOs as null.\n      * If disabled, standard POJOs can only be bound from JSON null or\n      * JSON Object (standard meaning that no custom deserializers or\n      * kinds of JSON values); if enable, empty JSON String can be taken\n      * to be equivalent of JSON null.\n      *<p>\n-     * SerializationFeature is enabled by default.\n-     */\n-    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n-    \n+     * Feature is enabled by default.\n+     */\n+    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false),\n+    \n+    /**\n+     * Feature that allows unknown Enum values to be parsed as null values. \n+     * If disabled, unknown Enum values will throw exceptions.\n+     *<p>\n+     * Note that in some cases this will basically ignore unknown Enum values;\n+     * this is the keys for keys of {@link java.util.EnumMap} and values\n+     * of {@link java.util.EnumSet} (because nulls are not accepted in these\n+     * cases).\n+     *<p>\n+     * Feature is disabled by default.\n+     * \n+     * @since 2.0\n+     */\n+    READ_UNKNOWN_ENUM_VALUES_AS_NULL(false)\n     ;\n \n     private final boolean _defaultState;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n         if (curr == JsonToken.VALUE_STRING || curr == JsonToken.FIELD_NAME) {\n             String name = jp.getText();\n             Enum<?> result = _resolver.findEnum(name);\n-            if (result == null) {\n+            if (result == null  && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                 throw ctxt.weirdStringException(_resolver.getEnumClass(), \"value not one of declared Enum instance names\");\n             }\n             return result;\n             \n             int index = jp.getIntValue();\n             Enum<?> result = _resolver.getEnum(index);\n-            if (result == null) {\n+            if (result == null && !ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                 throw ctxt.weirdNumberException(_resolver.getEnumClass(), \"index value outside legal index range [0..\"+_resolver.lastValidIndex()+\"]\");\n             }\n             return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n         while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n             Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n             if (key == null) {\n-                throw ctxt.weirdStringException(_enumClass, \"value not one of declared Enum instance names\");\n+                if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+                    throw ctxt.weirdStringException(_enumClass, \"value not one of declared Enum instance names\");\n+                }\n+                /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n+                 *  just skip the entry then. But we must skip the value then.\n+                 */\n+                jp.nextToken();\n+                jp.skipChildren();\n+                continue;\n             }\n             // And then the value...\n             JsonToken t = jp.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n                 throw ctxt.mappingException(_enumClass);\n             }\n             Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);\n-            result.add(value);\n+            /* 24-Mar-2012, tatu: As per [JACKSON-810], may actually get nulls;\n+             *    but EnumSets don't allow nulls so need to skip.\n+             */\n+            if (value != null) { \n+                result.add(value);\n+            }\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n             }\n         } catch (Exception re) {\n             throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation: \"+re.getMessage());\n+        }\n+        if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n+        \treturn null;\n         }\n         throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n     }\n                 }\n             }\n             Enum<?> e = _resolver.findEnum(key);\n-            if (e == null) {\n+            if (e == null && !ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n                 throw ctxt.weirdKeyException(_keyClass, key, \"not one of values for Enum class\");\n             }\n             return e;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n \n import java.util.EnumMap;\n import java.util.EnumSet;\n+import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import com.fasterxml.jackson.annotation.*;\n         public String toString() { return name; }\n     }\n     \n+    // [JACKSON-810]\n+    static class ClassWithEnumMapKey {\n+    \t@JsonProperty Map<TestEnum, String> map;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Tests\n     /**********************************************************\n      */\n \n-    protected final ObjectMapper mapper = new ObjectMapper();\n+    protected final ObjectMapper MAPPER = new ObjectMapper();\n \n     public void testSimple() throws Exception\n     {\n         // First \"good\" case with Strings\n         String JSON = \"\\\"OK\\\" \\\"RULES\\\"  null\";\n         // multiple main-level mappings, need explicit parser:\n-        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n-\n-        assertEquals(TestEnum.OK, mapper.readValue(jp, TestEnum.class));\n-        assertEquals(TestEnum.RULES, mapper.readValue(jp, TestEnum.class));\n+        JsonParser jp = MAPPER.getJsonFactory().createJsonParser(JSON);\n+\n+        assertEquals(TestEnum.OK, MAPPER.readValue(jp, TestEnum.class));\n+        assertEquals(TestEnum.RULES, MAPPER.readValue(jp, TestEnum.class));\n \n         /* should be ok; nulls are typeless; handled by mapper, not by\n          * deserializer\n          */\n-        assertNull(mapper.readValue(jp, TestEnum.class));\n+        assertNull(MAPPER.readValue(jp, TestEnum.class));\n \n         // and no more content beyond that...\n         assertFalse(jp.hasCurrentToken());\n \n         /* Then alternative with index (0 means first entry)\n          */\n-        assertEquals(TestEnum.JACKSON, mapper.readValue(\" 0 \", TestEnum.class));\n+        assertEquals(TestEnum.JACKSON, MAPPER.readValue(\" 0 \", TestEnum.class));\n \n         /* Then error case: unrecognized value\n          */\n         try {\n-            /*Object result =*/ mapper.readValue(\"\\\"NO-SUCH-VALUE\\\"\", TestEnum.class);\n+            /*Object result =*/ MAPPER.readValue(\"\\\"NO-SUCH-VALUE\\\"\", TestEnum.class);\n             fail(\"Expected an exception for bogus enum value...\");\n         } catch (JsonMappingException jex) {\n             verifyException(jex, \"value not one of declared\");\n      */\n     public void testComplexEnum() throws Exception\n     {\n-        String json = mapper.writeValueAsString(TimeUnit.HOURS);\n+        String json = MAPPER.writeValueAsString(TimeUnit.HOURS);\n         assertEquals(quote(\"HOURS\"), json);\n-        TimeUnit result = mapper.readValue(json, TimeUnit.class);\n+        TimeUnit result = MAPPER.readValue(json, TimeUnit.class);\n         assertSame(TimeUnit.HOURS, result);\n     }\n     \n      */\n     public void testAnnotated() throws Exception\n     {\n-        AnnotatedTestEnum e = mapper.readValue(\"\\\"JACKSON\\\"\", AnnotatedTestEnum.class);\n+        AnnotatedTestEnum e = MAPPER.readValue(\"\\\"JACKSON\\\"\", AnnotatedTestEnum.class);\n         /* dummy deser always returns value OK, independent of input;\n          * only works if annotation is used\n          */\n \n     public void testEnumMaps() throws Exception\n     {\n-        EnumMap<TestEnum,String> value = mapper.readValue(\"{\\\"OK\\\":\\\"value\\\"}\",\n+        EnumMap<TestEnum,String> value = MAPPER.readValue(\"{\\\"OK\\\":\\\"value\\\"}\",\n                 new TypeReference<EnumMap<TestEnum,String>>() { });\n         assertEquals(\"value\", value.get(TestEnum.OK));\n     }\n     // Test [JACKSON-214]\n     public void testSubclassedEnums() throws Exception\n     {\n-        EnumWithSubClass value = mapper.readValue(\"\\\"A\\\"\", EnumWithSubClass.class);\n+        EnumWithSubClass value = MAPPER.readValue(\"\\\"A\\\"\", EnumWithSubClass.class);\n         assertEquals(EnumWithSubClass.A, value);\n     }\n \n     // [JACKSON-193]\n     public void testCreatorEnums() throws Exception\n     {\n-        EnumWithCreator value = mapper.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n+        EnumWithCreator value = MAPPER.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n         assertEquals(EnumWithCreator.A, value);\n     }\n     \n     public void testNumbersToEnums() throws Exception\n     {\n         // by default numbers are fine:\n-        assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS));\n-        TestEnum value = mapper.readValue(\"1\", TestEnum.class);\n+        assertFalse(MAPPER.getDeserializationConfig().isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS));\n+        TestEnum value = MAPPER.readValue(\"1\", TestEnum.class);\n         assertSame(TestEnum.RULES, value);\n \n         // but can also be changed to errors:\n     public void testEnumsWithJsonValue() throws Exception\n     {\n         // first, enum as is\n-        EnumWithJsonValue e = mapper.readValue(quote(\"foo\"), EnumWithJsonValue.class);\n+        EnumWithJsonValue e = MAPPER.readValue(quote(\"foo\"), EnumWithJsonValue.class);\n         assertSame(EnumWithJsonValue.A, e);\n-        e = mapper.readValue(quote(\"bar\"), EnumWithJsonValue.class);\n+        e = MAPPER.readValue(quote(\"bar\"), EnumWithJsonValue.class);\n         assertSame(EnumWithJsonValue.B, e);\n \n         // then in EnumSet\n-        EnumSet<EnumWithJsonValue> set = mapper.readValue(\"[\\\"bar\\\"]\",\n+        EnumSet<EnumWithJsonValue> set = MAPPER.readValue(\"[\\\"bar\\\"]\",\n                 new TypeReference<EnumSet<EnumWithJsonValue>>() { });\n         assertNotNull(set);\n         assertEquals(1, set.size());\n         assertFalse(set.contains(EnumWithJsonValue.A));\n \n         // and finally EnumMap\n-        EnumMap<EnumWithJsonValue,Integer> map = mapper.readValue(\"{\\\"foo\\\":13}\",\n+        EnumMap<EnumWithJsonValue,Integer> map = MAPPER.readValue(\"{\\\"foo\\\":13}\",\n                 new TypeReference<EnumMap<EnumWithJsonValue, Integer>>() { });\n         assertNotNull(map);\n         assertEquals(1, map.size());\n     // [JACKSON-756], next three tests\n \n     public void testEnumWithCreatorEnumMaps() throws Exception {\n-          EnumMap<EnumWithCreator,String> value = mapper.readValue(\"{\\\"enumA\\\":\\\"value\\\"}\",\n+          EnumMap<EnumWithCreator,String> value = MAPPER.readValue(\"{\\\"enumA\\\":\\\"value\\\"}\",\n                   new TypeReference<EnumMap<EnumWithCreator,String>>() {});\n           assertEquals(\"value\", value.get(EnumWithCreator.A));\n     }\n \n     public void testEnumWithCreatorMaps() throws Exception {\n-          java.util.HashMap<EnumWithCreator,String> value = mapper.readValue(\"{\\\"enumA\\\":\\\"value\\\"}\",\n+          java.util.HashMap<EnumWithCreator,String> value = MAPPER.readValue(\"{\\\"enumA\\\":\\\"value\\\"}\",\n                   new TypeReference<java.util.HashMap<EnumWithCreator,String>>() {});\n           assertEquals(\"value\", value.get(EnumWithCreator.A));\n     }\n \n     public void testEnumWithCreatorEnumSets() throws Exception {\n-          EnumSet<EnumWithCreator> value = mapper.readValue(\"[\\\"enumA\\\"]\",\n+          EnumSet<EnumWithCreator> value = MAPPER.readValue(\"[\\\"enumA\\\"]\",\n                   new TypeReference<EnumSet<EnumWithCreator>>() {});\n           assertTrue(value.contains(EnumWithCreator.A));\n     }\n+\n+    // [JACKSON-810], ability to ignore unknown Enum values:\n+\n+    public void testAllowUnknownEnumValuesReadAsNull() throws Exception\n+    {\n+        // can not use shared mapper when changing configs...\n+        ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n+        assertNull(reader.withType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n+        assertNull(reader.withType(TestEnum.class).readValue(\" 4343 \"));\n+    }\n+\n+    public void testAllowUnknownEnumValuesForEnumSets() throws Exception\n+    {\n+        ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n+        EnumSet<TestEnum> result = reader.withType(new TypeReference<EnumSet<TestEnum>>() { })\n+                .readValue(\"[\\\"NO-SUCH-VALUE\\\"]\");\n+        assertEquals(0, result.size());\n+    }\n+    \n+    public void testAllowUnknownEnumValuesAsMapKeysReadAsNull() throws Exception\n+    {\n+        ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n+        ClassWithEnumMapKey result = reader.withType(ClassWithEnumMapKey.class)\n+                .readValue(\"{\\\"map\\\":{\\\"NO-SUCH-VALUE\\\":\\\"val\\\"}}\");\n+        assertTrue(result.map.containsKey(null));\n+    }\n+    \n+    public void testDoNotAllowUnknownEnumValuesAsMapKeysWhenReadAsNullDisabled() throws Exception\n+    {\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL));\n+         try {\n+             MAPPER.readValue(\"{\\\"map\\\":{\\\"NO-SUCH-VALUE\\\":\\\"val\\\"}}\", ClassWithEnumMapKey.class);\n+             fail(\"Expected an exception for bogus enum value...\");\n+         } catch (JsonMappingException jex) {\n+             verifyException(jex, \"Can not construct Map key\");\n+         }\n+    }\n+\n }", "timestamp": 1332648618, "metainfo": ""}