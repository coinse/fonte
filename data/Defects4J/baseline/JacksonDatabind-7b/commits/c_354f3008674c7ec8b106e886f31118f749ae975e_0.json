{"sha": "354f3008674c7ec8b106e886f31118f749ae975e", "log": "Merge branch 'master' of https://github.com/FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n      * for which no explicit is defined should be alphabetically (lexicograpically)\n      * ordered\n      */\n+    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n+        return null;\n+    }\n+\n+    @Deprecated // since 2.4\n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n      * Constructor used for creating actual per-call instances.\n      */\n     protected DeserializationContext(DeserializationContext src,\n-            DeserializationConfig config, JsonParser jp,\n+            DeserializationConfig config, JsonParser p,\n             InjectableValues injectableValues)\n     {\n         _cache = src._cache;\n         _config = config;\n         _featureFlags = config.getDeserializationFeatures();\n         _view = config.getActiveView();\n-        _parser = jp;\n+        _parser = p;\n         _injectableValues = injectableValues;\n         _attributes = config.getAttributes();\n     }\n     public TimeZone getTimeZone() {\n         return _config.getTimeZone();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Public API, pass-through to DeserializerCache\n      */\n     @SuppressWarnings(\"unchecked\")\n     public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type,\n-            BeanProperty property) throws JsonMappingException\n-    {\n-        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this,\n-                _factory, type);\n+            BeanProperty prop) throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n         if (deser != null) {\n-            deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, property);\n+            deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, prop);\n         }\n         return deser;\n     }\n-    \n+\n     /**\n      * Method for finding a deserializer for root-level value.\n      */\n     /**\n      * Convenience method, functionally same as:\n      *<pre>\n-     *  getDeserializerProvider().findKeyDeserializer(getConfig(), propertyType, property);\n+     *  getDeserializerProvider().findKeyDeserializer(getConfig(), prop.getType(), prop);\n      *</pre>\n      */\n     public final KeyDeserializer findKeyDeserializer(JavaType keyType,\n-            BeanProperty property) throws JsonMappingException {\n+            BeanProperty prop) throws JsonMappingException {\n         KeyDeserializer kd = _cache.findKeyDeserializer(this,\n                 _factory, keyType);\n         // Second: contextualize?\n         if (kd instanceof ContextualKeyDeserializer) {\n-            kd = ((ContextualKeyDeserializer) kd).createContextual(this, property);\n+            kd = ((ContextualKeyDeserializer) kd).createContextual(this, prop);\n         }\n         return kd;\n     }\n      */\n     public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolver);\n \n-    @Deprecated\n+    @Deprecated // since 2.4\n     public abstract ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator);\n \n     /**\n      * to handle details of resolving\n      * {@link ContextualDeserializer} with given property context.\n      * \n-     * @param property Property for which the given primary deserializer is used; never null.\n+     * @param prop Property for which the given primary deserializer is used; never null.\n      * \n      * @since 2.3\n      */\n     public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser,\n-            BeanProperty property)\n+            BeanProperty prop)\n         throws JsonMappingException\n     {\n         if (deser != null) {\n             if (deser instanceof ContextualDeserializer) {\n-                deser = ((ContextualDeserializer) deser).createContextual(this, property);\n+                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n             }\n         }\n         return deser;\n      * (or, in case of root value property, to any property), annotations\n      * accessible may or may not be relevant.\n      * \n-     * @param property Property for which deserializer is used, if any; null\n+     * @param prop Property for which deserializer is used, if any; null\n      *    when deserializing root values\n      * \n      * @since 2.3\n      */\n     public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        if (deser != null) {\n-            if (deser instanceof ContextualDeserializer) {\n-                deser = ((ContextualDeserializer) deser).createContextual(this, property);\n-            }\n+            BeanProperty prop)\n+        throws JsonMappingException {\n+        if (deser != null && (deser instanceof ContextualDeserializer)) {\n+            deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n     }\n      * date format is cloned, and cloned instance will be retained\n      * for use during this deserialization round.\n      */\n-    public Date parseDate(String dateStr)\n-        throws IllegalArgumentException\n+    public Date parseDate(String dateStr) throws IllegalArgumentException\n     {\n         try {\n             DateFormat df = getDateFormat();\n      * Convenience method for constructing Calendar instance set\n      * to specified time, to be modified and used by caller.\n      */\n-    public Calendar constructCalendar(Date d)\n-    {\n-        /* 08-Jan-2008, tatu: not optimal, but should work for the\n-         *   most part; let's revise as needed.\n-         */\n+    public Calendar constructCalendar(Date d) {\n+        // 08-Jan-2008, tatu: not optimal, but should work for the most part; let's revise as needed.\n         Calendar c = Calendar.getInstance(getTimeZone());\n         c.setTime(d);\n         return c;\n \n     /*\n     /**********************************************************\n+    /* Convenience methods for reading parsed values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Convenience method that may be used by composite or container deserializers,\n+     * for reading one-off values contained (for sequences, it is more efficient\n+     * to actually fetch deserializer once for the whole collection).\n+     *<p>\n+     * NOTE: when deserializing values of properties contained in composite types,\n+     * rather use {@link #readPropertyValue(JsonParser, BeanProperty, Class)};\n+     * this method does not allow use of contextual annotations.\n+     * \n+     * @since 2.4\n+     */\n+    public <T> T readValue(JsonParser p, Class<T> type) throws IOException {\n+        return readValue(p, getTypeFactory().constructType(type));\n+    }\n+\n+    /**\n+     * @since 2.4\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser p, JavaType type) throws IOException {\n+        JsonDeserializer<Object> deser = findRootValueDeserializer(type);\n+        if (deser == null) {\n+        }\n+        return (T) deser.deserialize(p, this);\n+    }\n+\n+    /**\n+     * Convenience method that may be used by composite or container deserializers,\n+     * for reading one-off values for the composite type, taking into account\n+     * annotations that the property (passed to this method -- usually property that\n+     * has custom serializer that called this method) has.\n+     * \n+     * @since 2.4\n+     */\n+    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, Class<T> type) throws IOException {\n+        return readPropertyValue(p, prop, getTypeFactory().constructType(type));\n+    }\n+\n+    /**\n+     * @since 2.4\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readPropertyValue(JsonParser p, BeanProperty prop, JavaType type) throws IOException {\n+        JsonDeserializer<Object> deser = findContextualValueDeserializer(type, prop);\n+        if (deser == null) {\n+            \n+        }\n+        return (T) deser.deserialize(p, this);\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Methods for problem handling, reporting\n     /**********************************************************\n      */\n      * Method deserializers can call to inform configured {@link DeserializationProblemHandler}s\n      * of an unrecognized property.\n      */\n-    public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser,\n+    public boolean handleUnknownProperty(JsonParser p, JsonDeserializer<?> deser,\n             Object instanceOrClass, String propName)\n         throws IOException, JsonProcessingException\n     {\n         if (h != null) {\n             while (h != null) {\n                 // Can bail out if it's handled\n-                if (h.value().handleUnknownProperty(this, jp, deser, instanceOrClass, propName)) {\n+                if (h.value().handleUnknownProperty(this, p, deser, instanceOrClass, propName)) {\n                     return true;\n                 }\n                 h = h.next();\n      * Helper method for indicating that the current token was expected to be another\n      * token.\n      */\n-    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg) {\n-        return JsonMappingException.from(jp, \"Unexpected token (\"+jp.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n+    public JsonMappingException wrongTokenException(JsonParser p, JsonToken expToken, String msg) {\n+        return JsonMappingException.from(p, \"Unexpected token (\"+p.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n             TimeZone.getTimeZone(\"GMT\"),\n             Base64Variants.getDefaultVariant() // 2.1\n     );\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration settings, shared\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             // Skip field name:\n             jp.nextToken();\n                 return deserializeWithView(jp, ctxt, bean, view);\n             }\n         }\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             // Skip field name:\n             jp.nextToken();\n     {\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             jp.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n      */\n \n     @Override\n-    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator, ObjectIdResolver resolverType)\n-    {\n-        final ObjectIdGenerator.IdKey key = generator.key(id);\n+    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n+    {\n+        final ObjectIdGenerator.IdKey key = gen.key(id);\n         if (_objectIds == null) {\n             _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n         } else {\n         return entry;\n     }\n     \n-    @Override\n-    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> generator)\n-    {\n-        return findObjectId(id, generator, new SimpleObjectIdResolver());\n-    }\n-\n-    @Override\n-    public void checkUnresolvedObjectId()\n-        throws UnresolvedForwardReference\n+    @Deprecated // since 2.4\n+    @Override\n+    public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen) {\n+        return findObjectId(id, gen, new SimpleObjectIdResolver());\n+    }\n+\n+    @Override\n+    public void checkUnresolvedObjectId() throws UnresolvedForwardReference\n     {\n         if (_objectIds == null) {\n             return;\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n-            Object deserDef)\n+    public JsonDeserializer<Object> deserializerInstance(Annotated ann, Object deserDef)\n         throws JsonMappingException\n     {\n         if (deserDef == null) {\n                 throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n             }\n             HandlerInstantiator hi = _config.getHandlerInstantiator();\n-            deser = (hi == null) ? null : hi.deserializerInstance(_config, annotated, deserClass);\n+            deser = (hi == null) ? null : hi.deserializerInstance(_config, ann, deserClass);\n             if (deser == null) {\n                 deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n                         _config.canOverrideAccessModifiers());\n     }\n \n     @Override\n-    public final KeyDeserializer keyDeserializerInstance(Annotated annotated,\n-            Object deserDef)\n+    public final KeyDeserializer keyDeserializerInstance(Annotated ann, Object deserDef)\n         throws JsonMappingException\n     {\n         if (deserDef == null) {\n                         +\"; expected Class<KeyDeserializer>\");\n             }\n             HandlerInstantiator hi = _config.getHandlerInstantiator();\n-            deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, annotated, deserClass);\n+            deser = (hi == null) ? null : hi.keyDeserializerInstance(_config, ann, deserClass);\n             if (deser == null) {\n                 deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n                         _config.canOverrideAccessModifiers());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n      * Method used for setting \"any\" properties, along with annotation\n      * information. Retained to allow contextualization of any properties.\n      */\n-    final protected BeanProperty _property;\n+    protected final BeanProperty _property;\n     \n     /**\n      * Physical JDK object used for assigning properties.\n     \n     /*\n     /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    // TODO (2.3): handle restoring of reference to any-setter method\n+    \n+/*\n+    Object readResolve() {\n+        return new SettableAnyProperty(this, _annotated.getAnnotated());\n+    }\n+    */\n+    \n+    /*\n+    /**********************************************************\n     /* Public API, accessors\n     /**********************************************************\n      */\n      * context), and set it using appropriate method (a setter method).\n      */\n     public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-                                        Object instance, String propName)\n-        throws IOException, JsonProcessingException\n+            Object instance, String propName)\n+        throws IOException\n     {\n         try {\n             set(instance, propName, deserialize(jp, ctxt));\n             if (!(_valueDeserializer.getObjectIdReader() != null)) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n-            AnySetterReferring referring = new AnySetterReferring(instance, propName, reference.getUnresolvedId(),\n-                    reference.getLocation());\n+            AnySetterReferring referring = new AnySetterReferring(this, reference,\n+                    _type.getRawClass(), instance, propName);\n             reference.getRoid().appendReferring(referring);\n         }\n     }\n \n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == JsonToken.VALUE_NULL) {\n         return _valueDeserializer.deserialize(jp, ctxt);\n     }\n \n-    public void set(Object instance, String propName, Object value)\n-        throws IOException\n+    public void set(Object instance, String propName, Object value) throws IOException\n     {\n         try {\n             _setter.invoke(instance, propName, value);\n \n     @Override public String toString() { return \"[any property on class \"+getClassName()+\"]\"; }\n \n-    private class AnySetterReferring extends Referring {\n-        private Object _pojo;\n-        private String _propName;\n-        private Object _unresolvedId;\n-\n-        public AnySetterReferring(Object instance, String propName, Object id, JsonLocation location)\n+    private static class AnySetterReferring extends Referring {\n+        private final SettableAnyProperty _parent;\n+        private final Object _pojo;\n+        private final String _propName;\n+\n+        public AnySetterReferring(SettableAnyProperty parent,\n+                UnresolvedForwardReference reference, Class<?> type, Object instance, String propName)\n         {\n-            super(location, _type.getRawClass());\n+            super(reference, type);\n+            _parent = parent;\n             _pojo = instance;\n             _propName = propName;\n-            _unresolvedId = id;\n         }\n \n         @Override\n         public void handleResolvedForwardReference(Object id, Object value)\n             throws IOException\n         {\n-            if (!id.equals(_unresolvedId)) {\n+            if (!hasId(id)) {\n                 throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id.toString()\n                         + \"] that wasn't previously registered.\");\n             }\n-            set(_pojo, _propName, value);\n-        }\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* JDK serialization handling\n-    /**********************************************************\n-     */\n-\n-    // TODO (2.3): handle restoring of reference to any-setter method\n-    \n-/*\n-    Object readResolve() {\n-        return new SettableAnyProperty(this, _annotated.getAnnotated());\n-    }\n-    */\n+            _parent.set(_pojo, _propName, value);\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/UnresolvedId.java\n  * @author pgelinas\n  */\n public class UnresolvedId {\n-    private Object _id;\n-    private JsonLocation _location;\n-    private Class<?> _type;\n+    private final Object _id;\n+    private final JsonLocation _location;\n+    private final Class<?> _type;\n \n-    public UnresolvedId(Object id, Class<?> type, JsonLocation where)\n-    {\n+    public UnresolvedId(Object id, Class<?> type, JsonLocation where) {\n         _id = id;\n         _type = type;\n         _location = where;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ManagedReferenceProperty.java\n     {\n         /* 04-Feb-2014, tatu: As per [#390], it may be necessary to switch the\n          *   ordering of forward/backward references, and start with back ref.\n-         *   But before doing that, need a unit test.\n-         */\n-        \n-        // Start with forward property\n-        Object result = _managedProperty.setAndReturn(instance, value);\n-        /* And then back reference, if (and only if!) we actually have a non-null\n-         * reference\n          */\n         if (value != null) {\n             if (_isContainer) { // ok, this gets ugly... but has to do for now\n                 _backProperty.set(value, instance);\n             }\n         }\n-        return result;\n+        // and then the forward reference itself\n+        return _managedProperty.setAndReturn(instance, value);\n \t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n import java.io.IOException;\n import java.lang.annotation.Annotation;\n \n-import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationContext;\n     }\n \n     @Override\n-    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser)\n-    {\n+    public SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser) {\n         return new ObjectIdReferenceProperty(this, deser);\n     }\n \n     @Override\n-    public SettableBeanProperty withName(PropertyName newName)\n-    {\n+    public SettableBeanProperty withName(PropertyName newName) {\n         return new ObjectIdReferenceProperty(this, newName);\n     }\n \n     @Override\n-    public <A extends Annotation> A getAnnotation(Class<A> acls)\n-    {\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return _forward.getAnnotation(acls);\n     }\n \n     @Override\n-    public AnnotatedMember getMember()\n-    {\n+    public AnnotatedMember getMember() {\n         return _forward.getMember();\n     }\n \n             if (!usingIdentityInfo) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n-            reference.getRoid().appendReferring(\n-                    new PropertyReferring(instance, reference.getUnresolvedId(), reference.getLocation()));\n+            reference.getRoid().appendReferring(new PropertyReferring(this, reference, _type.getRawClass(), instance));\n             return null;\n         }\n     }\n \n     @Override\n-    public void set(Object instance, Object value)\n-        throws IOException\n-    {\n+    public void set(Object instance, Object value) throws IOException {\n         _forward.set(instance, value);\n     }\n \n     @Override\n-    public Object setAndReturn(Object instance, Object value)\n-        throws IOException\n-    {\n+    public Object setAndReturn(Object instance, Object value) throws IOException {\n         return _forward.setAndReturn(instance, value);\n     }\n \n-    public final class PropertyReferring extends Referring {\n+    public final static class PropertyReferring extends Referring {\n+        private final ObjectIdReferenceProperty _parent;\n         public final Object _pojo;\n-        private Object _unresolvedId;\n \n-        public PropertyReferring(Object ob, Object id, JsonLocation location)\n+        public PropertyReferring(ObjectIdReferenceProperty parent,\n+                UnresolvedForwardReference ref, Class<?> type, Object ob)\n         {\n-            super(location, _type.getRawClass());\n+            super(ref, type);\n+            _parent = parent;\n             _pojo = ob;\n-            _unresolvedId = id;\n         }\n \n         @Override\n-        public void handleResolvedForwardReference(Object id, Object value)\n-            throws IOException\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException\n         {\n-            if (!id.equals(_unresolvedId)) {\n+            if (!hasId(id)) {\n                 throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                         + \"] that wasn't previously seen as unresolved.\");\n             }\n-            set(_pojo, value);\n+            _parent.set(_pojo, value);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ReadableObjectId.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n \n /**\n  * Simple value container for containing information about single Object Id\n     private ObjectIdResolver _resolver;\n \n     @Deprecated\n-    public ReadableObjectId(Object id)\n-    {\n+    public ReadableObjectId(Object id) {\n         this.id = id;\n         _key = null;\n     }\n \n-    public ReadableObjectId(IdKey key)\n-    {\n+    public ReadableObjectId(IdKey key) {\n         _key = key;\n         id = key.key;\n     }\n \n-    public void setResolver(ObjectIdResolver resolver)\n-    {\n+    public void setResolver(ObjectIdResolver resolver) {\n         _resolver = resolver;\n     }\n \n-    public IdKey getKey()\n-    {\n+    public IdKey getKey() {\n         return _key;\n     }\n \n      */\n \n     public static abstract class Referring {\n-        private final JsonLocation _location;\n+        private final UnresolvedForwardReference _reference;\n         private final Class<?> _beanType;\n \n-        public Referring(JsonLocation location, Class<?> beanType)\n-        {\n-            _location = location;\n+        public Referring(UnresolvedForwardReference ref, Class<?> beanType) {\n+            _reference = ref;\n             _beanType = beanType;\n         }\n \n-        public JsonLocation getLocation() { return _location; }\n+        public JsonLocation getLocation() { return _reference.getLocation(); }\n         public Class<?> getBeanType() { return _beanType; }\n \n-        public abstract void handleResolvedForwardReference(Object id, Object value)\n-            throws IOException;\n+        public abstract void handleResolvedForwardReference(Object id, Object value) throws IOException;\n+        public boolean hasId(Object id) {\n+            return id.equals(_reference.getUnresolvedId());\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n         CollectionReferringAccumulator referringAccumulator =\n-            (valueDes.getObjectIdReader() == null) ? null : new CollectionReferringAccumulator(result);\n+            (valueDes.getObjectIdReader() == null) ? null :\n+                new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n \n         JsonToken t;\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n         return result;\n     }\n \n-    public final class CollectionReferringAccumulator {\n-        private Collection<Object> _result;\n+    public final static class CollectionReferringAccumulator {\n+        private final Class<?> _elementType;\n+        private final Collection<Object> _result;\n+\n         /**\n-         * A list of {@link UnresolvedId} to maintain ordering.\n+         * A list of {@link CollectionReferring} to maintain ordering.\n          */\n-        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n-\n-        public CollectionReferringAccumulator(Collection<Object> result)\n-        {\n+        private List<CollectionReferring> _accumulator = new ArrayList<CollectionReferring>();\n+\n+        public CollectionReferringAccumulator(Class<?> elementType, Collection<Object> result) {\n+            _elementType = elementType;\n             _result = result;\n         }\n \n             if (_accumulator.isEmpty()) {\n                 _result.add(value);\n             } else {\n-                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n-                unresolvedId._next.add(value);\n+                CollectionReferring ref = _accumulator.get(_accumulator.size() - 1);\n+                ref.next.add(value);\n             }\n         }\n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference)\n         {\n-            UnresolvedId id = new UnresolvedId(reference.getUnresolvedId(), reference.getLocation());\n+            CollectionReferring id = new CollectionReferring(this, reference, _elementType);\n             _accumulator.add(id);\n             return id;\n         }\n \n         public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n-            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n+            Iterator<CollectionReferring> iterator = _accumulator.iterator();\n             // Resolve ordering after resolution of an id. This mean either:\n             // 1- adding to the result collection in case of the first unresolved id.\n             // 2- merge the content of the resolved id with its previous unresolved id.\n             Collection<Object> previous = _result;\n             while (iterator.hasNext()) {\n-                UnresolvedId unresolvedId = iterator.next();\n-                if (unresolvedId._id.equals(id)) {\n+                CollectionReferring ref = iterator.next();\n+                if (ref.hasId(id)) {\n                     iterator.remove();\n                     previous.add(value);\n-                    previous.addAll(unresolvedId._next);\n+                    previous.addAll(ref.next);\n                     return;\n                 }\n-                previous = unresolvedId._next;\n+                previous = ref.next;\n             }\n \n             throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                     + \"] that wasn't previously seen as unresolved.\");\n         }\n-\n-        /**\n-         * Helper class to maintain processing order of value. The resolved\n-         * object associated with {@link #_id} comes before the values in\n-         * {@link _next}.\n-         */\n-        private final class UnresolvedId extends Referring {\n-            private final Object _id;\n-            private final List<Object> _next = new ArrayList<Object>();\n-\n-            private UnresolvedId(Object id, JsonLocation location)\n-            {\n-                super(location, _collectionType.getContentType().getRawClass());\n-                _id = id;\n-            }\n-\n-            @Override\n-            public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n-                resolveForwardReference(id, value);\n-            }\n+    }\n+\n+    /**\n+     * Helper class to maintain processing order of value. The resolved\n+     * object associated with {@link #_id} comes before the values in\n+     * {@link #next}.\n+     */\n+    private final static class CollectionReferring extends Referring {\n+        private final CollectionReferringAccumulator _parent;\n+        public final List<Object> next = new ArrayList<Object>();\n+        \n+        private CollectionReferring(CollectionReferringAccumulator parent,\n+                UnresolvedForwardReference reference, Class<?> contentType)\n+        {\n+            super(reference, contentType);\n+            _parent = parent;\n+        }\n+        \n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n+            _parent.resolveForwardReference(id, value);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n public abstract class ContainerDeserializerBase<T>\n     extends StdDeserializer<T>\n {\n-    protected ContainerDeserializerBase(JavaType selfType)\n-    {\n+    protected ContainerDeserializerBase(JavaType selfType) {\n         super(selfType);\n     }\n \n      * @deprecated Since 2.3 use one that takes {@link JavaType}\n      */\n     @Deprecated\n-    protected ContainerDeserializerBase(Class<?> selfType)\n-    {\n+    protected ContainerDeserializerBase(Class<?> selfType) {\n         super(selfType);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n             String name = jp.getText();\n             Enum<?> result = _resolver.findEnum(name);\n             if (result == null) {\n-                if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                    if (name.length() == 0 || name.trim().length() == 0) {\n+                name = name.trim();\n+                if (name.length() == 0) {\n+                    if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                         return null;\n+                    }\n+                } else {\n+                    // [#149]: Allow use of 'String' indexes as well\n+                    char c = name.charAt(0);\n+                    if (c >= '0' && c <= '9') {\n+                        try {\n+                            int ix = Integer.parseInt(name);\n+                            result = _resolver.getEnum(ix);\n+                            if (result != null) {\n+                                return result;\n+                            }\n+                        } catch (NumberFormatException e) {\n+                            // fine, ignore, was not an integer\n+                        }\n                     }\n                 }\n                 if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n             HashSet<String> ignorable)\n     {\n         \n-        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser) && (_valueTypeDeserializer == valueTypeDeser)\n-                && (_ignorableProperties == ignorable)) {\n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n+                && (_valueTypeDeserializer == valueTypeDeser) && (_ignorableProperties == ignorable)) {\n             return this;\n         }\n         return new MapDeserializer(this,\n                 && isDefaultKeyDeserializer(keyDeser));\n     }\n     \n-    public void setIgnorableProperties(String[] ignorable)\n-    {\n+    public void setIgnorableProperties(String[] ignorable) {\n         _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n             null : ArrayBuilders.arrayToSet(ignorable);\n     }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        MapReferringAccumuator referringAccumulator = null;\n+        MapReferringAccumulator referringAccumulator = null;\n         boolean useObjectId = valueDes.getObjectIdReader() != null;\n         if (useObjectId) {\n-            referringAccumulator = new MapReferringAccumuator(result);\n+            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n         }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        MapReferringAccumuator referringAccumulator = null;\n+        MapReferringAccumulator referringAccumulator = null;\n         boolean useObjectId = valueDes.getObjectIdReader() != null;\n         if (useObjectId) {\n-            referringAccumulator = new MapReferringAccumuator(result);\n+            referringAccumulator = new MapReferringAccumulator(_mapType.getContentType().getRawClass(), result);\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n         }\n     }\n \n-    // note: copied form BeanDeserializer; should try to share somehow...\n+    // note: copied from BeanDeserializer; should try to share somehow...\n     protected void wrapAndThrow(Throwable t, Object ref)\n         throws IOException\n     {\n         throw JsonMappingException.wrapWithPath(t, ref, null);\n     }\n \n-    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumuator accumulator, Object key,\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n             UnresolvedForwardReference reference)\n         throws JsonMappingException\n     {\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final class MapReferringAccumuator  {\n+    private final static class MapReferringAccumulator  {\n+        private final Class<?> _valueType;\n         private Map<Object,Object> _result;\n         /**\n-         * A list of {@link UnresolvedId} to maintain ordering.\n+         * A list of {@link MapReferring} to maintain ordering.\n          */\n-        private List<UnresolvedId> _accumulator = new ArrayList<UnresolvedId>();\n-\n-        public MapReferringAccumuator(Map<Object, Object> result)\n-        {\n+        private List<MapReferring> _accumulator = new ArrayList<MapReferring>();\n+\n+        public MapReferringAccumulator(Class<?> valueType, Map<Object, Object> result) {\n+            _valueType = valueType;\n             _result = result;\n         }\n \n             if (_accumulator.isEmpty()) {\n                 _result.put(key, value);\n             } else {\n-                UnresolvedId unresolvedId = _accumulator.get(_accumulator.size() - 1);\n-                unresolvedId._next.put(key, value);\n+                MapReferring ref = _accumulator.get(_accumulator.size() - 1);\n+                ref.next.put(key, value);\n             }\n         }\n \n         public Referring handleUnresolvedReference(UnresolvedForwardReference reference, Object key)\n         {\n-            UnresolvedId id = new UnresolvedId(key, reference.getUnresolvedId(), reference.getLocation());\n+            MapReferring id = new MapReferring(this, reference, _valueType, key);\n             _accumulator.add(id);\n             return id;\n         }\n \n-        public void resolveForwardReference(Object id, Object value)\n-            throws IOException\n+        public void resolveForwardReference(Object id, Object value) throws IOException\n         {\n-            Iterator<UnresolvedId> iterator = _accumulator.iterator();\n-            // Resolve ordering after resolution of an id. This mean either:\n+            Iterator<MapReferring> iterator = _accumulator.iterator();\n+            // Resolve ordering after resolution of an id. This means either:\n             // 1- adding to the result map in case of the first unresolved id.\n             // 2- merge the content of the resolved id with its previous unresolved id.\n             Map<Object,Object> previous = _result;\n             while (iterator.hasNext()) {\n-                UnresolvedId unresolvedId = iterator.next();\n-                if (unresolvedId._id.equals(id)) {\n+                MapReferring ref = iterator.next();\n+                if (ref.hasId(id)) {\n                     iterator.remove();\n-                    previous.put(unresolvedId._key, value);\n-                    previous.putAll(unresolvedId._next);\n+                    previous.put(ref.key, value);\n+                    previous.putAll(ref.next);\n                     return;\n                 }\n-                previous = unresolvedId._next;\n+                previous = ref.next;\n             }\n \n             throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n                     + \"] that wasn't previously seen as unresolved.\");\n         }\n-\n-        /**\n-         * Helper class to maintain processing order of value. The resolved\n-         * object associated with {@link #_id} comes before the values in\n-         * {@link _next}.\n-         */\n-        private final class UnresolvedId extends Referring {\n-            private final Object _id;\n-            private final Map<Object, Object> _next = new LinkedHashMap<Object, Object>();\n-            private final Object _key;\n-\n-            private UnresolvedId(Object key, Object id, JsonLocation location)\n-            {\n-                super(location, _mapType.getContentType().getRawClass());\n-                _key = key;\n-                _id = id;\n-            }\n-\n-            @Override\n-            public void handleResolvedForwardReference(Object id, Object value)\n-                throws IOException\n-            {\n-                resolveForwardReference(id, value);\n-            }\n+    }\n+\n+    /**\n+     * Helper class to maintain processing order of value. The resolved\n+     * object associated with {@link #_id} comes before the values in\n+     * {@link _next}.\n+     */\n+    private final static class MapReferring extends Referring {\n+        private final MapReferringAccumulator _parent;\n+\n+        public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n+        public final Object key;\n+        \n+        private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+                Class<?> valueType, Object key)\n+        {\n+            super(ref, valueType);\n+            _parent = parent;\n+            this.key = key;\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value) throws IOException {\n+            _parent.resolveForwardReference(id, value);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         // And finally, let's allow Strings to be converted too\n         if (t == JsonToken.VALUE_STRING) {\n             String text = jp.getText().trim();\n-            if (\"true\".equals(text)) {\n+            // [#422]: Allow aliases\n+            if (\"true\".equals(text) || \"True\".equals(text)) {\n                 return true;\n             }\n-            if (\"false\".equals(text) || text.length() == 0) {\n+            if (\"false\".equals(text) || \"False\".equals(text) || text.length() == 0) {\n                 return false;\n             }\n             if (_hasTextualNull(text)) {\n         // And finally, let's allow Strings to be converted too\n         if (t == JsonToken.VALUE_STRING) {\n             String text = jp.getText().trim();\n-            if (\"true\".equals(text)) {\n+            // [#422]: Allow aliases\n+            if (\"true\".equals(text) || \"True\".equals(text)) {\n                 return Boolean.TRUE;\n             }\n-            if (\"false\".equals(text)) {\n+            if (\"false\".equals(text) || \"False\".equals(text)) {\n                 return Boolean.FALSE;\n             }\n             if (text.length() == 0) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n      * ordered\n      */\n     @Override\n+    @Deprecated\n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         Boolean result = _primary.findSerializationSortAlphabetically(ac);\n         if (result == null) {\n         return result;            \n     }\n \n+    @Override\n+    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n+        Boolean result = _primary.findSerializationSortAlphabetically(ann);\n+        if (result == null) {\n+            result = _secondary.findSerializationSortAlphabetically(ann);\n+        }\n+        return result;            \n+    }\n+    \n     // // // Serialization: property annotations\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     }\n \n     @Override\n+    public Boolean findSerializationSortAlphabetically(Annotated ann) {\n+        return _findSortAlpha(ann);\n+    }\n+\n+    @Override\n+    @Deprecated\n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n-        JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class);\n+        return _findSortAlpha(ac);\n+    }\n+\n+    private final Boolean _findSortAlpha(Annotated ann) {\n+        JsonPropertyOrder order = ann.getAnnotation(JsonPropertyOrder.class);\n         return (order == null) ? null : order.alphabetic();\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Serialization: property annotations\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n         // Then how about explicit ordering?\n         AnnotationIntrospector intr = _annotationIntrospector;\n         boolean sort;\n-        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically(_classDef);\n+        Boolean alpha = (intr == null) ? null : intr.findSerializationSortAlphabetically((Annotated) _classDef);\n         \n         if (alpha == null) {\n             sort = _config.shouldSortPropertiesAlphabetically();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n                 continue;\n             }\n             // different from default name?\n-            if (explName.equals(_name)) { // nope, skip\n+            /* 14-Mar-2014, tatu: As per [#369], Must match local name... but,\n+             *   shouldn't really exclude namespace. Not sure what's the best\n+             *   fix but for now, let's not worry about that.\n+             * \n+             */\n+            if (explName.equals(_name.getSimpleName())) { // nope, skip\n                 continue;\n             }\n             if (renamed == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n         } else if (_customFormat != null) {\n             // 21-Feb-2011, tatu: not optimal, but better than alternatives:\n             synchronized (_customFormat) {\n-                jgen.writeString(_customFormat.format(value));\n+                // _customformat cannot parse Calendar, so Date should be passed\n+                jgen.writeString(_customFormat.format(value.getTime()));\n             }\n         } else {\n             provider.defaultSerializeDateValue(value.getTime(), jgen);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n      */\n     protected final Object _filterId;\n \n+    /**\n+     * Flag set if output is forced to be sorted by keys (usually due\n+     * to annotation).\n+     * \n+     * @since 2.4\n+     */\n+    protected final boolean _sortKeys;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle\n         _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n         _property = null;\n         _filterId = null;\n+        _sortKeys = false;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = property;\n         _filterId = src._filterId;\n+        _sortKeys = src._sortKeys;\n     }\n \n     protected MapSerializer(MapSerializer src, TypeSerializer vts)\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = src._property;\n         _filterId = src._filterId;\n-    }\n-\n-    protected MapSerializer(MapSerializer src, Object filterId)\n+        _sortKeys = src._sortKeys;\n+    }\n+\n+    protected MapSerializer(MapSerializer src, Object filterId, boolean sortKeys)\n     {\n         super(Map.class, false);\n         _ignoredEntries = src._ignoredEntries;\n         _dynamicValueSerializers = src._dynamicValueSerializers;\n         _property = src._property;\n         _filterId = filterId;\n-    }\n-    \n-    @Override\n-    public MapSerializer _withValueTypeSerializer(TypeSerializer vts)\n-    {\n+        _sortKeys = sortKeys;\n+    }\n+    \n+    @Override\n+    public MapSerializer _withValueTypeSerializer(TypeSerializer vts) {\n         return new MapSerializer(this, vts);\n     }\n \n+    @Deprecated // since 2.3\n+    public MapSerializer withResolved(BeanProperty property,\n+            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) {\n+        return withResolved(property, keySerializer, valueSerializer, ignored, _sortKeys);\n+    }\n+\n+    /**\n+     * @since 2.4\n+     */\n     public MapSerializer withResolved(BeanProperty property,\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n-            HashSet<String> ignored)\n-    {\n-        return new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n-    }\n-\n+            HashSet<String> ignored, boolean sortKeys)\n+    {\n+        MapSerializer ser = new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n+        if (sortKeys != ser._sortKeys) {\n+            ser = new MapSerializer(ser, _filterId, sortKeys);\n+        }\n+        return ser;\n+    }\n+    \n     /**\n      * @since 2.3\n      */\n     public MapSerializer withFilterId(Object filterId) {\n-        return (_filterId == filterId) ? this : new MapSerializer(this, filterId);\n+        return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n     }\n \n     /**\n          */\n         JsonSerializer<?> ser = null;\n         JsonSerializer<?> keySer = null;\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n \n         // First: if we have a property, may have property-annotation overrides\n-        if (property != null) {\n-            AnnotatedMember m = property.getMember();\n-            if (m != null) {\n-                Object serDef;\n-                final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-                serDef = intr.findKeySerializer(m);\n-                if (serDef != null) {\n-                    keySer = provider.serializerInstance(m, serDef);\n-                }\n-                serDef = intr.findContentSerializer(m);\n-                if (serDef != null) {\n-                    ser = provider.serializerInstance(m, serDef);\n-                }\n+        if (propertyAcc != null && intr != null) {\n+            Object serDef = intr.findKeySerializer(propertyAcc);\n+            if (serDef != null) {\n+                keySer = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            serDef = intr.findContentSerializer(propertyAcc);\n+            if (serDef != null) {\n+                ser = provider.serializerInstance(propertyAcc, serDef);\n             }\n         }\n         if (ser == null) {\n         } else {\n             keySer = provider.handleSecondaryContextualization(keySer, property);\n         }\n-        HashSet<String> ignored = this._ignoredEntries;\n-        AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-        if (intr != null && property != null) {\n-            String[] moreToIgnore = intr.findPropertiesToIgnore(property.getMember());\n+        HashSet<String> ignored = _ignoredEntries;\n+        boolean sortKeys = false;\n+        if (intr != null && propertyAcc != null) {\n+            String[] moreToIgnore = intr.findPropertiesToIgnore(propertyAcc);\n             if (moreToIgnore != null) {\n                 ignored = (ignored == null) ? new HashSet<String>() : new HashSet<String>(ignored);\n                 for (String str : moreToIgnore) {\n                     ignored.add(str);\n                 }\n             }\n-        }\n-        MapSerializer mser =  withResolved(property, keySer, ser, ignored);\n+            Boolean b = intr.findSerializationSortAlphabetically(propertyAcc);\n+            sortKeys = (b != null) && b.booleanValue();\n+        }\n+        MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);\n \n         // [Issue#307]: allow filtering\n         if (property != null) {\n                         findPropertyFilter(provider, _filterId, value));\n                 return;\n             }\n-            if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n+            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n             if (_valueSerializer != null) {\n     {\n         typeSer.writeTypePrefixForObject(value, jgen);\n         if (!value.isEmpty()) {\n-            if (provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n+            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n             if (_valueSerializer != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n         if (cls == String.class) {\n             return DEFAULT_STRING_SERIALIZER;\n         }\n-        if (cls == Object.class) {\n+        if (cls == Object.class || cls.isPrimitive() || Number.class.isAssignableFrom(cls)) {\n             return DEFAULT_KEY_SERIALIZER;\n         }\n-        // [JACKSON-606] special handling for dates...\n         if (Date.class.isAssignableFrom(cls)) {\n             return (JsonSerializer<Object>) DateKeySerializer.instance;\n         }\n         if (Calendar.class.isAssignableFrom(cls)) {\n             return (JsonSerializer<Object>) CalendarKeySerializer.instance;\n         }\n+        /* 14-Mar-2014, tatu: Should support @JsonValue, as per #47; but that\n+         *   requires extensive introspection, and passing in more information\n+         *   to this method.\n+         */\n         // If no match, just use default one:\n         return DEFAULT_KEY_SERIALIZER;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.*;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n             return new CustomKey(Integer.valueOf(key));\n         }\n     }\n+\n+    // [#375]\n+\n+    @Target({ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface Negative { }\n+\n+    static class Bean375Wrapper {\n+        @Negative\n+        public Bean375Outer value;\n+    }\n+    \n+    static class Bean375Outer {\n+        protected Bean375Inner inner;\n+\n+        public Bean375Outer(Bean375Inner v) { inner = v; }\n+    }\n+\n+    static class Bean375Inner {\n+        protected int x;\n+\n+        public Bean375Inner(int x) { this.x = x; }\n+    }\n+\n+    static class Bean375OuterDeserializer extends StdDeserializer<Bean375Outer>\n+        implements ContextualDeserializer\n+    {\n+        protected BeanProperty prop;\n+        \n+        protected Bean375OuterDeserializer() { this(null); }\n+        protected Bean375OuterDeserializer(BeanProperty p) {\n+            super(Bean375Outer.class);\n+            prop = p;\n+        }\n+\n+        @Override\n+        public Bean375Outer deserialize(JsonParser p, DeserializationContext ctxt) throws IOException,\n+                JsonProcessingException {\n+            Object ob = ctxt.readPropertyValue(p, prop, Bean375Inner.class);\n+            return new Bean375Outer((Bean375Inner) ob);\n+        }\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n+                throws JsonMappingException {\n+            return new Bean375OuterDeserializer(property);\n+        }\n+    }\n+\n+    static class Bean375InnerDeserializer extends StdDeserializer<Bean375Inner>\n+        implements ContextualDeserializer\n+    {\n+        protected boolean negative;\n+        \n+        protected Bean375InnerDeserializer() { this(false); }\n+        protected Bean375InnerDeserializer(boolean n) {\n+            super(Bean375Inner.class);\n+            negative = n;\n+        }\n+\n+        @Override\n+        public Bean375Inner deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException {\n+            int x = jp.getIntValue();\n+            if (negative) {\n+                x = -x;\n+            } else {\n+                x += x;\n+            }\n+            return new Bean375Inner(x);\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n+                throws JsonMappingException {\n+            if (property != null) {\n+                Negative n = property.getAnnotation(Negative.class);\n+                if (n != null) {\n+                    return new Bean375InnerDeserializer(true);\n+                }\n+            }\n+            return this;\n+        }\n+        \n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    final ObjectMapper MAPPER = new ObjectMapper();\n+    final ObjectMapper MAPPER = objectMapper();\n     \n     public void testCustomBeanDeserializer() throws Exception\n     {\n         assertNotNull(deserialized.map);\n         assertEquals(1, deserialized.map.size());\n     }\n+\n+    // [#337]: convenience methods for custom deserializers to use\n+    public void testContextReadValue() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(Bean375Outer.class, new Bean375OuterDeserializer());\n+        module.addDeserializer(Bean375Inner.class, new Bean375InnerDeserializer());\n+        mapper.registerModule(module);\n+\n+        // First, without property; doubles up value:\n+        Bean375Outer outer = mapper.readValue(\"13\", Bean375Outer.class);\n+        assertEquals(26, outer.inner.x);\n+\n+        // then with property; should find annotation, turn negative\n+        Bean375Wrapper w = mapper.readValue(\"{\\\"value\\\":13}\", Bean375Wrapper.class);\n+        assertNotNull(w.value);\n+        assertNotNull(w.value.inner);\n+        assertEquals(-13, w.value.inner.x);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n public class TestEnumDeserialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes, enums\n-    /**********************************************************\n-     */\n-\n     enum TestEnum { JACKSON, RULES, OK; }\n \n     /**\n             //exception as thrown correctly\n         }\n     }\n+\n+    // [Issue#149]: 'stringified' indexes for enums\n+    public void testIndexAsString() throws Exception\n+    {\n+        // first, regular index ought to work fine\n+        TestEnum en = MAPPER.readValue(\"2\", TestEnum.class);\n+        assertSame(TestEnum.values()[2], en);\n+\n+        // but also with quoted Strings\n+        en = MAPPER.readValue(quote(\"1\"), TestEnum.class);\n+        assertSame(TestEnum.values()[1], en);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n     /* Unit tests\n     /**********************************************************\n      */\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n     \n     public void testSimpleRefs() throws Exception\n     {\n         SimpleTreeNode root = new SimpleTreeNode(\"root\");\n         SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n-        ObjectMapper mapper = new ObjectMapper();\n         root.child = child;\n         child.parent = root;\n         \n-        String json = mapper.writeValueAsString(root);\n-        \n-        SimpleTreeNode resultNode = mapper.readValue(json, SimpleTreeNode.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = MAPPER.readValue(json, SimpleTreeNode.class);\n         assertEquals(\"root\", resultNode.name);\n         SimpleTreeNode resultChild = resultNode.child;\n         assertNotNull(resultChild);\n     {\n         SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n         SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n-        ObjectMapper mapper = new ObjectMapper();\n         root.child = child;\n         child.parent = root;\n         \n-        String json = mapper.writeValueAsString(root);\n-        \n-        SimpleTreeNode2 resultNode = mapper.readValue(json, SimpleTreeNode2.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = MAPPER.readValue(json, SimpleTreeNode2.class);\n         assertEquals(\"root\", resultNode.name);\n         SimpleTreeNode2 resultChild = resultNode.child;\n         assertNotNull(resultChild);\n         FullTreeNode root = new FullTreeNode(\"root\");\n         FullTreeNode child1 = new FullTreeNode(\"kid1\");\n         FullTreeNode child2 = new FullTreeNode(\"kid2\");\n-        ObjectMapper mapper = new ObjectMapper();\n         root.firstChild = child1;\n         child1.parent = root;\n         child1.next = child2;\n         child2.prev = child1;\n         \n-        String json = mapper.writeValueAsString(root);\n-        \n-        FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = MAPPER.readValue(json, FullTreeNode.class);\n         assertEquals(\"root\", resultNode.name);\n         FullTreeNode resultChild = resultNode.firstChild;\n         assertNotNull(resultChild);\n         ArrayNode node1 = new ArrayNode(\"a\");\n         ArrayNode node2 = new ArrayNode(\"b\");\n         root.nodes = new ArrayNode[] { node1, node2 };\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(root);\n-        \n-        NodeArray result = mapper.readValue(json, NodeArray.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeArray result = MAPPER.readValue(json, NodeArray.class);\n         ArrayNode[] kids = result.nodes;\n         assertNotNull(kids);\n         assertEquals(2, kids.length);\n         NodeForList node1 = new NodeForList(\"a\");\n         NodeForList node2 = new NodeForList(\"b\");\n         root.nodes = Arrays.asList(node1, node2);\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(root);\n-        \n-        NodeList result = mapper.readValue(json, NodeList.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeList result = MAPPER.readValue(json, NodeList.class);\n         List<NodeForList> kids = result.nodes;\n         assertNotNull(kids);\n         assertEquals(2, kids.size());\n         nodes.put(\"a1\", node1);\n         nodes.put(\"b2\", node2);\n         root.nodes = nodes;\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(root);\n-        \n-        NodeMap result = mapper.readValue(json, NodeMap.class);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeMap result = MAPPER.readValue(json, NodeMap.class);\n         Map<String,NodeForMap> kids = result.nodes;\n         assertNotNull(kids);\n         assertEquals(2, kids.size());\n         child.prev = parent;\n \n         // serialization ought to be ok\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(parent);\n-\n-        AbstractNode root = mapper.readValue(json, AbstractNode.class);\n+        String json = MAPPER.writeValueAsString(parent);\n+\n+        AbstractNode root = MAPPER.readValue(json, AbstractNode.class);\n \n         assertEquals(ConcreteNode.class, root.getClass());\n         assertEquals(\"p\", root.id);\n         Parent parent = new Parent();\n         parent.addChild(new Child(\"foo\"));\n         parent.addChild(new Child(\"bar\"));\n-        ObjectMapper mapper = new ObjectMapper();\n-        byte[] bytes = mapper.writeValueAsBytes(parent);\n-        Parent value = mapper.readValue(bytes, Parent.class); \n+        byte[] bytes = MAPPER.writeValueAsBytes(parent);\n+        Parent value = MAPPER.readValue(bytes, Parent.class); \n         for (Child child : value.children) {\n             assertEquals(value, child.getParent());\n         }\n \n     public void testIssue708() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        Advertisement708 ad = mapper.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        Advertisement708 ad = MAPPER.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n         assertNotNull(ad);\n     }   \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonPointer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonPointer.java\n         assertTrue(SAMPLE_ROOT.at(\"/Image/Depth\").isMissingNode());\n         assertTrue(SAMPLE_ROOT.at(\"/Image/1\").isMissingNode());\n     }\n+\n+    // To help verify [Core#133]; should be fine with \"big numbers\" as property keys\n+    public void testLongNumbers() throws Exception\n+    {\n+        \n+        // First, with small int key\n+        JsonNode root = objectMapper().readTree(\"{\\\"123\\\" : 456}\");\n+        JsonNode jn2 = root.at(\"/123\"); \n+        assertEquals(456, jn2.asInt());\n+\n+        // and then with above int-32:\n+        root = objectMapper().readTree(\"{\\\"35361706045\\\" : 1234}\");\n+        jn2 = root.at(\"/35361706045\"); \n+        assertEquals(1234, jn2.asInt());\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeWithType.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+public class TestTreeWithType extends BaseMapTest\n+{\n+    public static class Foo {\n+        public String bar;\n+\n+        public Foo() { }\n+\n+        public Foo(String bar) {\n+            this.bar = bar;\n+        }\n+    }\n+\n+    // [Issue#353]\n+    public class SavedCookie {\n+        public String name, value;\n+\n+        public SavedCookie() { }\n+        public SavedCookie(String n, String v) {\n+            name = n;\n+            value = v;\n+        }\n+    }\n+\n+    public class SavedCookieDeserializer extends JsonDeserializer<SavedCookie> {\n+        @Override\n+        public SavedCookie deserialize(JsonParser jsonParser, DeserializationContext ctxt)\n+                throws IOException {\n+           ObjectCodec oc = jsonParser.getCodec();\n+           JsonNode node = oc.readTree(jsonParser);\n+           return new SavedCookie(node.path(\"name\").textValue(),\n+                   node.path(\"value\").textValue());\n+        }\n+\n+        @Override\n+        public SavedCookie deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return (SavedCookie) typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+        }\n+    }    \n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testValueAsStringWithoutDefaultTyping() throws Exception {\n+\n+        Foo foo = new Foo(\"baz\");\n+        String json = MAPPER.writeValueAsString(foo);\n+\n+        JsonNode jsonNode = MAPPER.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testValueAsStringWithDefaultTyping() throws Exception {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+\n+        Foo foo = new Foo(\"baz\");\n+        String json = mapper.writeValueAsString(foo);\n+\n+        JsonNode jsonNode = mapper.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testReadTreeWithDefaultTyping() throws Exception\n+    {\n+        final String CLASS = Foo.class.getName();\n+\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL,\n+                JsonTypeInfo.As.PROPERTY);\n+        String json = \"{\\\"@class\\\":\\\"\"+CLASS+\"\\\",\\\"bar\\\":\\\"baz\\\"}\";\n+        JsonNode jsonNode = mapper.readTree(json);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), \"baz\");\n+    }\n+\n+    public void testValueToTreeWithoutDefaultTyping() throws Exception {\n+\n+        Foo foo = new Foo(\"baz\");\n+        JsonNode jsonNode = MAPPER.valueToTree(foo);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testValueToTreeWithDefaultTyping() throws Exception {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);\n+\n+        Foo foo = new Foo(\"baz\");\n+        JsonNode jsonNode = mapper.valueToTree(foo);\n+        assertEquals(jsonNode.get(\"bar\").textValue(), foo.bar);\n+    }\n+\n+    public void testIssue353() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        mapper.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL, \"@class\");\n+\n+         SimpleModule testModule = new SimpleModule(\"MyModule\", new Version(1, 0, 0, null, \"TEST\", \"TEST\"));\n+         testModule.addDeserializer(SavedCookie.class, new SavedCookieDeserializer());\n+         mapper.registerModule(testModule);\n+\n+         SavedCookie savedCookie = new SavedCookie(\"key\", \"v\");\n+         String json = mapper.writeValueAsString(savedCookie);\n+         SavedCookie out = mapper.reader(SavedCookie.class).readValue(json);\n+\n+         assertEquals(\"key\", out.name);\n+         assertEquals(\"v\", out.value);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd,HH:00\", timezone=\"CET\")\n         public Date date;\n         public DateInCETBean(long l) { date = new java.util.Date(l); }\n+    }\n+\n+    static class CalendarAsStringBean {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd\")\n+        public Calendar value;\n+        public CalendarAsStringBean(long l) {\n+            value = new GregorianCalendar();\n+            value.setTimeInMillis(l);\n+        }\n     }\n     \n     /*\n         // and with different DateFormat; CET is one hour ahead of GMT\n         json = mapper.writeValueAsString(new DateInCETBean(0L));\n         assertEquals(\"{\\\"date\\\":\\\"1970-01-01,01:00\\\"}\", json);\n+        \n+        // and for [Issue#423] as well:\n+        json = mapper.writer().with(getUTCTimeZone()).writeValueAsString(new CalendarAsStringBean(0L));\n+        assertEquals(\"{\\\"value\\\":\\\"1970-01-01\\\"}\", json);\n     }\n \n     /**\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n         }\n     }\n     \n+    // [#335]\n+    static class MapOrderingBean {\n+        @JsonPropertyOrder(alphabetic=true)\n+        public LinkedHashMap<String,Integer> map;\n+        \n+        public MapOrderingBean(String... keys) {\n+            map = new LinkedHashMap<String,Integer>();\n+            int ix = 1;\n+            for (String key : keys) {\n+                map.put(key, ix++);\n+            }\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n \n-    final ObjectMapper MAPPER = new ObjectMapper();\n+    final ObjectMapper MAPPER = objectMapper();\n     \n     // Test [JACKSON-220]\n     public void testMapSerializer() throws IOException\n         // but can be changed\n         assertEquals(\"{\\\"a\\\":6,\\\"b\\\":3}\", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map));\n     }\n+\n+    // [#335[\n+    public void testOrderByKeyViaProperty() throws IOException\n+    {\n+        MapOrderingBean input = new MapOrderingBean(\"c\", \"b\", \"a\");\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'map':{'a':3,'b':2,'c':1}}\"), json);\n+    }        \n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357And359.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.util.StdConverter;\n+\n+public class TestConvertingSerializer357And359\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    // [Issue#357]\n+    static class A { }\n+\n+    static class B {\n+        @JsonSerialize(contentConverter = AToStringConverter.class)\n+        public List<A> list = Arrays.asList(new A());\n+    }\n+\n+    static class AToStringConverter extends StdConverter<A, List<String>> {\n+        @Override\n+        public List<String> convert(A value) {\n+            return Arrays.asList(\"Hello world!\");\n+        }\n+    }\n+\n+    // [Issue#359]\n+\n+    static class Bean359 {\n+        @JsonSerialize(as = List.class, contentAs = Source.class)\n+        public List<Source> stuff = Arrays.asList(new Source());\n+    }\n+\n+    @JsonSerialize(using = TargetSerializer.class)\n+    static class Target {\n+        public String unexpected = \"Bye.\";\n+    }\n+\n+    @JsonSerialize(converter = SourceToTargetConverter.class)\n+    static class Source { }\n+\n+    static class SourceToTargetConverter extends StdConverter<Source, Target> {\n+        @Override\n+        public Target convert(Source value) {\n+            return new Target();\n+        }\n+    }\n+\n+    static class TargetSerializer extends JsonSerializer<TargetSerializer>\n+    {\n+        @Override\n+        public void serialize(TargetSerializer a, JsonGenerator jsonGenerator, SerializerProvider provider)\n+                throws IOException {\n+            jsonGenerator.writeString(\"Target\");\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#357]\n+    public void testConverterForList357() throws Exception {\n+        String json = objectWriter().writeValueAsString(new B());\n+        assertEquals(\"{\\\"list\\\":[[\\\"Hello world!\\\"]]}\", json);\n+    }\n+\n+    // [Issue#359]\n+    public void testIssue359() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new Bean359());\n+        assertNotNull(json);\n+        assertEquals(\"{\\\"stuff\\\":[\\\"Target\\\"]}\", json);\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n-import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.test.BaseTest;\n \n-public class TestMapJsonValueKey extends BaseTest\n+// [Issue#47]\n+public class TestMapJsonValueKey extends BaseMapTest\n {\n     public static class Wat\n     {\n         private final String wat;\n \n         @JsonCreator\n-        Wat(String wat)\n-        {\n+        Wat(String wat) {\n             this.wat = wat;\n         }\n \n         @JsonValue\n-        public String getWat()\n-        {\n+        public String getWat() {\n             return wat;\n         }\n \n         @Override\n-        public String toString()\n-        {\n-            return \"[Wat: \" + wat + \"]\";\n+        public String toString() {\n+            return \"(String)[Wat: \" + wat + \"]\";\n         }\n     }\n \n     public void testMapJsonValueKey()\n     throws Exception\n     {\n-        Map<Wat, Boolean> map = new HashMap<Wat, Boolean>();\n-        map.put(new Wat(\"3\"), true);\n-        map.put(new Wat(\"x\"), false);\n-\n-        TypeReference<Map<Wat, Boolean>> type = new TypeReference<Map<Wat, Boolean>>(){};\n+        Map<Wat, Boolean> input = new HashMap<Wat, Boolean>();\n+        input.put(new Wat(\"3\"), true);\n \n         ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(map, mapper.readValue(mapper.writeValueAsBytes(map), type));\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'3':'true'}\"), json);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestNameConflicts193And327.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestNameConflicts193And327 extends BaseMapTest\n+{\n+    static class Bean193\n+    {\n+        @JsonProperty(\"val1\")\n+        private int x;\n+        @JsonIgnore\n+        private int value2;\n+        \n+        public Bean193(@JsonProperty(\"val1\")int value1,\n+                    @JsonProperty(\"val2\")int value2)\n+        {\n+            this.x = value1;\n+            this.value2 = value2;\n+        }\n+        \n+        @JsonProperty(\"val2\")\n+        int x()\n+        {\n+            return value2;\n+        }\n+    }\n+\n+    // [Issue#323]\n+    static class Bean323 { \n+        private int a;\n+\n+        public Bean323 (@JsonProperty(\"a\") final int a ) {\n+            this.a = a;\n+        }\n+\n+        @JsonProperty(\"b\")\n+        private int getA () {\n+            return a;\n+        }\n+    }    \n+\n+    /* We should only report an exception for cases where there is\n+     * real ambiguity as to how to rename things; but not when everything\n+     * has been explicitly defined\n+     */\n+    // [Issue#327]\n+    @JsonPropertyOrder({ \"prop1\", \"prop2\" })\n+    static class BogusConflictBean\n+    {\n+        @JsonProperty(\"prop1\")\n+        public int a = 2;\n+\n+        @JsonProperty(\"prop2\")\n+        public int getA() {\n+            return 1;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#193]\n+    public void testIssue193() throws Exception\n+    {\n+        String json = objectWriter().writeValueAsString(new Bean193(1, 2));\n+        assertNotNull(json);\n+    }\n+\n+    // [Issue#323]\n+    public void testCreatorPropRename() throws Exception\n+    {\n+        Bean323 input = new Bean323(7);\n+        assertEquals(\"{\\\"b\\\":7}\", objectWriter().writeValueAsString(input));\n+    }\n+\n+    // [Issue#327]\n+    public void testNonConflict() throws Exception\n+    {\n+        String json = objectMapper().writeValueAsString(new BogusConflictBean());\n+        assertEquals(aposToQuotes(\"{'prop1':2,'prop2':1}\"), json);\n+    }    \n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdDeserialization.java\n import com.fasterxml.jackson.failing.TestObjectIdDeserialization.EnumMapCompany.FooEnum;\n \n /**\n- * Unit test to verify handling of Object Id deserialization\n+ * Unit test to verify handling of Object Id deserialization.\n+ *<p>\n+ * NOTE: only tests that still fail, even with initial forward-ref-handling\n+ * code (2.4), are included here. Other cases moved to successfully\n+ * passing tests.\n  */\n public class TestObjectIdDeserialization extends BaseMapTest\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n {\n     /**\n      * Flag that indicates that serialization must be done as the\n-     * Java timetamp, regardless of other settings.\n+     * Java timestamp, regardless of other settings.\n      */\n     protected final boolean _useTimestamp;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n             } else {\n                 serializeFields(value, jgen, provider);\n             }\n-        }        \n+        }\n         jgen.writeEndObject();\n     }\n ", "timestamp": 1395092889, "metainfo": ""}