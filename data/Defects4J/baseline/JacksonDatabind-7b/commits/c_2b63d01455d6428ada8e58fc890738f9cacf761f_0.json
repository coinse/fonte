{"sha": "2b63d01455d6428ada8e58fc890738f9cacf761f", "log": "Minor test cleanup", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericsBounded.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericsBounded.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n \n         public T wrapped;\n     }\n \n+    // Types for [JACKSON-778]\n+    \n+    static class Document {}\n+    static class Row {}\n+    static class RowWithDoc<D extends Document> extends Row {\n+        @JsonProperty(\"d\") D d;\n+    }\n+    static class ResultSet<R extends Row> {\n+        @JsonProperty(\"rows\") List<R> rows;\n+    }\n+    static class ResultSetWithDoc<D extends Document> extends ResultSet<RowWithDoc<D>> {}\n+\n+    static class MyDoc extends Document {}    \n     /*\n     /*******************************************************\n     /* Unit tests\n         assertEquals(-0.5, out.start);\n         assertEquals(0.5, out.end);\n     }\n+\n+    public void testIssue778() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        String json = \"{\\\"rows\\\":[{\\\"d\\\":{}}]}\";\n+\n+        final TypeReference<?> type = new TypeReference<ResultSetWithDoc<MyDoc>>() {};\n+        \n+        // type passed is correct, but somehow it gets mangled when passed...\n+        ResultSetWithDoc<MyDoc> rs = mapper.readValue(json, type);\n+        Document d = rs.rows.iterator().next().d;\n+    \n+        assertEquals(MyDoc.class, d.getClass()); //expected MyDoc but was Document\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n import com.fasterxml.jackson.databind.*;\n \n         public void setParent(Parent parent) { this.parent = parent; }\n     }    \n \n+    // [JACKSON-368]\n+\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})\n+    static abstract class AbstractNode\n+    {\n+        public String id;\n+        \n+        @JsonManagedReference public AbstractNode next;\n+        @JsonBackReference public AbstractNode prev;\n+    }\n+\n+    @JsonTypeName(\"concrete\")\n+    static class ConcreteNode extends AbstractNode {\n+        public ConcreteNode() { }\n+        public ConcreteNode(String id) { this.id = id; }\n+    }\n+    \n     // [JACKSON-708]\n     static class Model708 { }\n     \n         assertSame(result, kids.get(\"b2\").parent);\n     }\n \n+    // for [JACKSON-368]\n+    public void testAbstract368() throws Exception\n+    {\n+        AbstractNode parent = new ConcreteNode(\"p\");\n+        AbstractNode child = new ConcreteNode(\"c\");\n+        parent.next = child;\n+        child.prev = parent;\n+\n+        // serialization ought to be ok\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(parent);\n+\n+        AbstractNode root = mapper.readValue(json, AbstractNode.class);\n+\n+        assertEquals(ConcreteNode.class, root.getClass());\n+        assertEquals(\"p\", root.id);\n+        assertNull(root.prev);\n+        AbstractNode leaf = root.next;\n+        assertNotNull(leaf);\n+        assertEquals(\"c\", leaf.id);\n+        assertSame(root, leaf.prev);\n+    }\n+    \n     public void testIssue693() throws Exception\n     {\n         Parent parent = new Parent();", "timestamp": 1332219367, "metainfo": ""}