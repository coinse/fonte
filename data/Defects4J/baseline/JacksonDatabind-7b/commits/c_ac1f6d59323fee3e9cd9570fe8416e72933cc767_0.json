{"sha": "ac1f6d59323fee3e9cd9570fe8416e72933cc767", "log": "First part of #308, improved deserialization speed by 4x as per test", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.regex.Pattern;\n \n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n \n /**\n     /**********************************************************\n      */\n \n-    public static class UUIDDeserializer\n-        extends FromStringDeserializer<UUID>\n-    {\n-        public final static UUIDDeserializer instance = new UUIDDeserializer();\n-        \n-        public UUIDDeserializer() { super(UUID.class); }\n-\n-        @Override\n-        protected UUID _deserialize(String id, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            // Adapter from java-uuid-generator (https://github.com/cowtowncoder/java-uuid-generator)\n-            // which is 5x faster than UUID.fromString(value), as oper \"ManualReadPerfWithUUID\"\n-            if (id.length() != 36) {\n-                _badFormat(id);\n-            }\n-\n-            long lo, hi;\n-            lo = hi = 0;\n-            \n-            for (int i = 0, j = 0; i < 36; ++j) {\n-              \n-                // Need to bypass hyphens:\n-                switch (i) {\n-                case 8:\n-                case 13:\n-                case 18:\n-                case 23:\n-                    if (id.charAt(i) != '-') {\n-                        _badFormat(id);\n-                    }\n-                    ++i;\n-                }\n-                int curr;\n-                char c = id.charAt(i);\n-\n-                if (c >= '0' && c <= '9') {\n-                    curr = (c - '0');\n-                } else if (c >= 'a' && c <= 'f') {\n-                    curr = (c - 'a' + 10);\n-                } else if (c >= 'A' && c <= 'F') {\n-                    curr = (c - 'A' + 10);\n-                } else {\n-                    curr = _badChar(id, i, c);\n-                }\n-                curr = (curr << 4);\n-\n-                c = id.charAt(++i);\n-\n-                if (c >= '0' && c <= '9') {\n-                    curr |= (c - '0');\n-                } else if (c >= 'a' && c <= 'f') {\n-                    curr |= (c - 'a' + 10);\n-                } else if (c >= 'A' && c <= 'F') {\n-                    curr |= (c - 'A' + 10);\n-                } else {\n-                    curr = _badChar(id, i, c);\n-                }\n-                if (j < 8) {\n-                   hi = (hi << 8) | curr;\n-                } else {\n-                   lo = (lo << 8) | curr;\n-                }\n-                ++i;\n-            }      \n-            return new UUID(hi, lo);\n-        }\n-\n-        private int _badChar(String uuidStr, int index, char c) {\n-            throw new NumberFormatException(\"Non-hex character at #\"+index+\": '\"+c\n-                    +\"' (value 0x\"+Integer.toHexString(c)+\") for UUID String '\"+uuidStr+\"'\");\n-        }\n-\n-        private void _badFormat(String uuidStr) {\n-            throw new NumberFormatException(\"UUID has to be represented by the standard 36-char representation\");\n-        }\n-        \n-        @Override\n-        protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            if (ob instanceof byte[]) {\n-                byte[] bytes = (byte[]) ob;\n-                if (bytes.length != 16) {\n-                    ctxt.mappingException(\"Can only construct UUIDs from 16 byte arrays; got \"+bytes.length+\" bytes\");\n-                }\n-                // clumsy, but should work for now...\n-                DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n-                long l1 = in.readLong();\n-                long l2 = in.readLong();\n-                return new UUID(l1, l2);\n-            }\n-            super._deserializeEmbedded(ob, ctxt);\n-            return null; // never gets here\n-        }\n-    }\n-\n     public static class URLDeserializer\n         extends FromStringDeserializer<URL>\n     {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UUIDDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.UUID;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+public class UUIDDeserializer\n+    extends FromStringDeserializer<UUID>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    final static int[] HEX_DIGITS = new int[127];\n+    static {\n+        Arrays.fill(HEX_DIGITS, -1);\n+        for (int i = 0; i < 10; ++i) {\n+            HEX_DIGITS['0' + i] = i;\n+        }\n+        for (int i = 0; i < 6; ++i) {\n+            HEX_DIGITS['a' + i] = 10 + i;\n+            HEX_DIGITS['A' + i] = 10 + i;\n+        }\n+    }\n+\n+    public final static UUIDDeserializer instance = new UUIDDeserializer();\n+    \n+    public UUIDDeserializer() { super(UUID.class); }\n+\n+    @Override\n+    protected UUID _deserialize(String id, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Adapted from java-uuid-generator (https://github.com/cowtowncoder/java-uuid-generator)\n+        // which is 5x faster than UUID.fromString(value), as oper \"ManualReadPerfWithUUID\"\n+        if (id.length() != 36) {\n+            _badFormat(id);\n+        }\n+\n+        // verify hyphens first:\n+        if ((id.charAt(8) != '-') || (id.charAt(13) != '-')\n+                || (id.charAt(18) != '-') || (id.charAt(23) != '-')) {\n+            _badFormat(id);\n+        }\n+        long l1 = intFromChars(id, 0);\n+        l1 <<= 32;\n+        long l2 = ((long) shortFromChars(id, 9)) << 16;\n+        l2 |= shortFromChars(id, 14);\n+        long hi = l1 + l2;\n+\n+        int i1 = (shortFromChars(id, 19) << 16) | shortFromChars(id, 24);\n+        l1 = i1;\n+        l1 <<= 32;\n+        l2 = intFromChars(id, 28);\n+        l2 = (l2 << 32) >>> 32; // sign removal, Java-style. Ugh.\n+        long lo = l1 | l2;\n+\n+        return new UUID(hi, lo);\n+    }\n+\n+    static int intFromChars(String str, int index) {\n+        return (byteFromChars(str, index) << 24)\n+                +(byteFromChars(str, index+2) << 16)\n+                +(byteFromChars(str, index+4) << 8)\n+                + byteFromChars(str, index+6);\n+    }\n+    \n+    static int shortFromChars(String str, int index) {\n+        return (byteFromChars(str, index) << 8) + byteFromChars(str, index+2);\n+    }\n+    \n+    static int byteFromChars(String str, int index)\n+    {\n+        final char c1 = str.charAt(index);\n+        final char c2 = str.charAt(index+1);\n+\n+        if (c1 <= 127 && c2 <= 127) {\n+            int hex = (HEX_DIGITS[c1] << 4) | HEX_DIGITS[c2];\n+            if (hex >= 0) {\n+                return hex;\n+            }\n+        }\n+        if (c1 > 127 || HEX_DIGITS[c1] < 0) {\n+            return _badChar(str, index, c1);\n+        }\n+        return _badChar(str, index+1, c2);\n+    }\n+\n+    static int _badChar(String uuidStr, int index, char c) {\n+        throw new NumberFormatException(\"Non-hex character '\"+c+\"', not valid character for a UUID String\"\n+                +\"' (value 0x\"+Integer.toHexString(c)+\") for UUID String \\\"\"+uuidStr+\"\\\"\");\n+    }\n+\n+    private void _badFormat(String uuidStr) {\n+        throw new NumberFormatException(\"UUID has to be represented by the standard 36-char representation\");\n+    }\n+    \n+    @Override\n+    protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (ob instanceof byte[]) {\n+            byte[] bytes = (byte[]) ob;\n+            if (bytes.length != 16) {\n+                ctxt.mappingException(\"Can only construct UUIDs from 16 byte arrays; got \"+bytes.length+\" bytes\");\n+            }\n+            // clumsy, but should work for now...\n+            DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n+            long l1 = in.readLong();\n+            long l2 = in.readLong();\n+            return new UUID(l1, l2);\n+        }\n+        super._deserializeEmbedded(ob, ctxt);\n+        return null; // never gets here\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n \n     public void testUUID() throws Exception\n     {\n-        UUID value = UUID.fromString(\"76e6d183-5f68-4afa-b94a-922c1fdb83f8\");\n-        assertEquals(value, MAPPER.readValue(\"\\\"\"+value.toString()+\"\\\"\", UUID.class));\n-\n+        // first, couple of generated UUIDs:\n+        for (String value : new String[] {\n+                \"76e6d183-5f68-4afa-b94a-922c1fdb83f8\",\n+                \"00000007-0000-0000-0000-000000000000\"\n+        }) {\n+            assertEquals(UUID.fromString(value),\n+                    MAPPER.readValue(quote(value), UUID.class));\n+        }\n+        // then use templating; note that these are not exactly valid UUIDs\n+        // wrt spec (type bits etc), but JDK UUID should deal ok\n+        final String TEMPL = \"00000000-0000-0000-0000-000000000000\";\n+        final String chars = \"123456789abcdefABCDEF\";\n+\n+        for (int i = 0; i < chars.length(); ++i) {\n+            String value = TEMPL.replace('0', chars.charAt(i));\n+            assertEquals(UUID.fromString(value).toString(),\n+                    MAPPER.readValue(quote(value), UUID.class).toString());\n+        }\n+    }\n+\n+    public void testUUIDAux() throws Exception\n+    {\n         // [JACKSON-393] fix:\n+        final UUID value = UUID.fromString(\"76e6d183-5f68-4afa-b94a-922c1fdb83f8\");\n \n         // first, null should come as null\n         TokenBuffer buf = new TokenBuffer(null, false);", "timestamp": 1379136600, "metainfo": ""}