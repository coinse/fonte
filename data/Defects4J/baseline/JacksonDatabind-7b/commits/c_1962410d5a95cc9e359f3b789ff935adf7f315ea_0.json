{"sha": "1962410d5a95cc9e359f3b789ff935adf7f315ea", "log": "Refactoring of property name conflict resolution: fixes issues #193 and #327", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n  * can not return meaningful values since parameters do not have stand-alone\n  * JDK objects associated; so access should mostly be limited to checking\n  * annotation values which are properly aggregated and included.\n- *<p>\n- * Note: as of version 1.7, this type extends {@link AnnotatedMember}, since\n- * it behaves like a member for the most part, but earlier it just extended\n- * {@link Annotated}\n  */\n public final class AnnotatedParameter\n     extends AnnotatedMember\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n      */\n     protected void _addCreators()\n     {\n-        final AnnotationIntrospector ai = _annotationIntrospector;\n         // can be null if annotation processing is disabled...\n-        if (ai == null) {\n-            return;\n-        }\n-        for (AnnotatedConstructor ctor : _classDef.getConstructors()) {\n-            if (_creatorProperties == null) {\n-                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n-            }\n-            for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) {\n-                AnnotatedParameter param = ctor.getParameter(i);\n-                PropertyName pn = ai.findNameForDeserialization(param);\n-                // is it legal not to have name?\n-                if (pn != null && !pn.isEmpty()) {\n-                    // shouldn't need to worry about @JsonIgnore (no real point, so)\n-                    POJOPropertyBuilder prop = _property(pn);\n-                    // 28-Mar-2014, tatu: for now, all creator names considered explicit;\n-                    //    may need to change for JDK 8 where implicit names exist\n-                    prop.addCtor(param, pn, true, true, false);\n-                    _creatorProperties.add(prop);\n-                }\n-            }\n-        }\n-        for (AnnotatedMethod factory : _classDef.getStaticMethods()) {\n-            if (_creatorProperties == null) {\n-                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n-            }\n-            for (int i = 0, len = factory.getParameterCount(); i < len; ++i) {\n-                AnnotatedParameter param = factory.getParameter(i);\n-                PropertyName pn = ai.findNameForDeserialization(param);\n-                // is it legal not to have name?\n-                if (pn != null && !pn.isEmpty()) {\n-                    // shouldn't need to worry about @JsonIgnore (no real point, so)\n-                    POJOPropertyBuilder prop = _property(pn);\n-                    // 28-Mar-2014, tatu: for now, all names considered explicit\n-                    prop.addCtor(param, pn, true, true, false);\n-                    _creatorProperties.add(prop);\n-                }\n-            }\n-        }\n-    }\n-\n+        if (_annotationIntrospector != null) {\n+            for (AnnotatedConstructor ctor : _classDef.getConstructors()) {\n+                if (_creatorProperties == null) {\n+                    _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n+                }\n+                for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) {\n+                    _addCreatorParam(ctor.getParameter(i));\n+                }\n+            }\n+            for (AnnotatedMethod factory : _classDef.getStaticMethods()) {\n+                if (_creatorProperties == null) {\n+                    _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n+                }\n+                for (int i = 0, len = factory.getParameterCount(); i < len; ++i) {\n+                    _addCreatorParam(factory.getParameter(i));\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void _addCreatorParam(AnnotatedParameter param)\n+    {\n+        // JDK 8, paranamer can give implicit name\n+        String impl = _annotationIntrospector.findParameterSourceName(param);\n+        if (impl == null) {\n+            impl = \"\";\n+        }\n+        PropertyName pn = _annotationIntrospector.findNameForDeserialization(param);\n+        boolean expl = (pn != null && !pn.isEmpty());\n+        if (!expl) {\n+            if (impl.isEmpty()) {\n+                /* Important: if neither implicit nor explicit name, can not make use\n+                 * of this creator paramter -- may or may not be a problem, verified\n+                 * at a later point.\n+                 */\n+                return;\n+            }\n+            pn = new PropertyName(impl);\n+        }\n+\n+        // shouldn't need to worry about @JsonIgnore, since creators only added\n+        // if so annotated\n+\n+        POJOPropertyBuilder prop = expl ?  _property(pn) : _property(impl);\n+        prop.addCtor(param, pn, expl, true, false);\n+\n+        _creatorProperties.add(prop);\n+    }\n+    \n     /**\n      * Method for collecting basic information on all fields found\n      */\n         while (it.hasNext()) {\n             Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n             POJOPropertyBuilder prop = entry.getValue();\n+\n+            Collection<PropertyName> l = prop.findExplicitNames();\n+            // no explicit names? Implicit one is fine as is\n+            if (l.isEmpty()) {\n+                continue;\n+            }\n+            it.remove(); // need to replace with one or more renamed\n+            if (renamed == null) {\n+                renamed = new LinkedList<POJOPropertyBuilder>();\n+            }\n+            // simple renaming? Just do it\n+            if (l.size() == 1) {\n+                PropertyName n = l.iterator().next();\n+                renamed.add(prop.withName(n));\n+                continue;\n+            }\n+            // but this may be problematic...\n+            renamed.addAll(prop.explode(l));\n+\n+            /*\n             String newName = prop.findNewName();\n             if (newName != null) {\n                 if (renamed == null) {\n                 renamed.add(prop);\n                 it.remove();\n             }\n+            */\n         }\n         \n         // and if any were renamed, merge back in...\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import java.util.Map;\n+import java.util.*;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n \n     protected Linked<AnnotatedMethod> _setters;\n \n-    public POJOPropertyBuilder(PropertyName internalName,\n+    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai, boolean forSerialization) {\n+        this(internalName, internalName, ai, forSerialization);\n+    }\n+\n+    protected POJOPropertyBuilder(PropertyName internalName, PropertyName name,\n             AnnotationIntrospector annotationIntrospector, boolean forSerialization)\n     {\n         _internalName = internalName;\n-        _name = internalName;\n+        _name = name;\n         _annotationIntrospector = annotationIntrospector;\n         _forSerialization = forSerialization;\n     }\n-\n+    \n     @Deprecated // since 2.3\n     public POJOPropertyBuilder(String simpleInternalName,\n             AnnotationIntrospector annotationIntrospector, boolean forSerialization)\n     {\n         this(new PropertyName(simpleInternalName), annotationIntrospector, forSerialization);\n     }\n-    \n+\n     public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)\n     {\n         _internalName = src._internalName;\n     }\n \n     /**\n-     * @since 2.4 Use {@link #findNewNames} instead\n-     */\n-    /*\n+     * @since 2.4 Use {@link #findExplicitNames} instead\n+     */\n     @Deprecated\n     public String findNewName()\n     {\n-        Map<String,POJOPropertyBuilder> r = findRenamed();\n-        if (r == null) {\n+        Collection<PropertyName> l = findExplicitNames();\n+        if (l == null) {\n             return null;\n         }\n-        return r.entrySet().iterator().next().getKey();\n-    }\n-    */\n-    \n-    /**\n-     * Method called to check whether property represented by this collector\n-     * should be renamed from the implicit name; and also verify that there\n-     * are no conflicting rename definitions.\n-     */\n-//    public Map<String,POJOPropertyBuilder> findRenamed()\n-    public String findNewName()\n-    {\n-//        Map<String,POJOPropertyBuilder> renamed = null;\n-        Linked<? extends AnnotatedMember> renamed = null;\n-        renamed = findRenamed(_fields, renamed);\n-        renamed = findRenamed(_getters, renamed);\n-        renamed = findRenamed(_setters, renamed);\n-        renamed = findRenamed(_ctorParameters, renamed);\n-        return (renamed == null) ? null : renamed.name.getSimpleName();\n-    }\n-\n-    private Linked<? extends AnnotatedMember> findRenamed(Linked<? extends AnnotatedMember> node,\n-            Linked<? extends AnnotatedMember> renamed)\n+        \n+        // 13-Apr-2014, tatu: Start with code similar to existing conflict checks\n+        if (l.size() > 1) {\n+            throw new IllegalStateException(\"Conflicting/ambiguous property name definitions (implicit name '\"\n+                    +_name+\"'): found more than one explicit name: \"\n+                    +l);\n+        }\n+        PropertyName first = l.iterator().next();\n+        if (first.equals(_name)) {\n+            return null;\n+        }\n+        return first.getSimpleName();\n+    }\n+    \n+    /**\n+     * Method called to find out set of explicit names for accessors\n+     * bound together due to implicit name.\n+     * \n+     * @since 2.4\n+     */\n+    public Set<PropertyName> findExplicitNames()\n+    {\n+        Set<PropertyName> renamed = null;\n+        renamed = _findExplicitNames(_fields, renamed);\n+        renamed = _findExplicitNames(_getters, renamed);\n+        renamed = _findExplicitNames(_setters, renamed);\n+        renamed = _findExplicitNames(_ctorParameters, renamed);\n+        if (renamed == null) {\n+            return Collections.emptySet();\n+        }\n+        return renamed;\n+    }\n+\n+    /**\n+     * Method called when a previous call to {@link #findExplicitNames} found\n+     * multiple distinct explicit names, and the property this builder represents\n+     * basically needs to be broken apart and replaced by a set of more than\n+     * one properties.\n+     * \n+     * @since 2.4\n+     */\n+    public Collection<POJOPropertyBuilder> explode(Collection<PropertyName> newNames)\n+    {\n+        HashMap<PropertyName,POJOPropertyBuilder> props = new HashMap<PropertyName,POJOPropertyBuilder>();\n+        _explode(newNames, props, _fields);\n+        _explode(newNames, props, _getters);\n+        _explode(newNames, props, _setters);\n+        _explode(newNames, props, _ctorParameters);\n+        return props.values();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void _explode(Collection<PropertyName> newNames,\n+            Map<PropertyName,POJOPropertyBuilder> props,\n+            Linked<?> accessors)\n+    {\n+        final Linked<?> firstAcc = accessors; // clumsy, part 1\n+        for (Linked<?> node = accessors; node != null; node = node.next) {\n+            PropertyName name = node.name;\n+            if (!node.isNameExplicit || name == null) { // no explicit name -- problem!\n+                throw new IllegalStateException(\"Conflicting/ambiguous property name definitions (implicit name '\"\n+                        +_name+\"'): found multiple explicit names: \"\n+                        +newNames+\", but also implicit accessor: \"+node);\n+            }\n+            POJOPropertyBuilder prop = props.get(name);\n+            if (prop == null) {\n+                prop = new POJOPropertyBuilder(_internalName, name, _annotationIntrospector, _forSerialization);\n+                props.put(name, prop);\n+            }\n+            // ultra-clumsy, part 2 -- lambdas would be nice here\n+            if (firstAcc == _fields) {\n+                Linked<AnnotatedField> n2 = (Linked<AnnotatedField>) node;\n+                prop._fields = n2.withNext(prop._fields);\n+            } else if (firstAcc == _getters) {\n+                Linked<AnnotatedMethod> n2 = (Linked<AnnotatedMethod>) node;\n+                prop._getters = n2.withNext(prop._getters);\n+            } else if (firstAcc == _setters) {\n+                Linked<AnnotatedMethod> n2 = (Linked<AnnotatedMethod>) node;\n+                prop._setters = n2.withNext(prop._setters);\n+            } else if (firstAcc == _ctorParameters) {\n+                Linked<AnnotatedParameter> n2 = (Linked<AnnotatedParameter>) node;\n+                prop._ctorParameters = n2.withNext(prop._ctorParameters);\n+            } else {\n+                throw new IllegalStateException(\"Internal error: mismatched accessors, property: \"+this);\n+            }\n+        }\n+    }\n+    \n+    private Set<PropertyName> _findExplicitNames(Linked<? extends AnnotatedMember> node,\n+            Set<PropertyName> renamed)\n     {\n         for (; node != null; node = node.next) {\n-            /* 30-Mar-2014, tatu: Second change should not be needed, but seems like\n+            /* 30-Mar-2014, tatu: Second check should not be needed, but seems like\n              *   removing it can cause nasty exceptions with certain version\n              *   combinations (2.4 databind, an older module).\n              *   So leaving it in for now until this is resolved\n             if (!node.isNameExplicit || node.name == null) {\n                 continue;\n             }\n-            PropertyName name = node.name;\n-            // different from default name?\n-            if (name.equals(_name)) { // nope, skip\n-                continue;\n-            }\n             if (renamed == null) {\n-                renamed = node;\n-            } else {\n-                // different from an earlier renaming? problem\n-                if (!name.equals(renamed.name)) {\n-                    throw new IllegalStateException(\"Conflicting property name definitions: '\"\n-                            +renamed.name+\"' (for \"+renamed.value+\") vs '\"\n-                            +node.name+\"' (for \"+node.value+\")\");\n-                }\n-            }\n+                renamed = new HashSet<PropertyName>();\n+            }\n+            renamed.add(node.name);\n         }\n         return renamed;\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts193And327.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts193And327.java\n-package com.fasterxml.jackson.failing;\n+package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.databind.*;\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n         public int getValue() { return value+1; }\n     }\n \n-    // [Issue#323] (fixed in 2.4)\n+    // [Issue#323]\n     static class Bean323 { \n         private int a;\n ", "timestamp": 1397531251, "metainfo": ""}