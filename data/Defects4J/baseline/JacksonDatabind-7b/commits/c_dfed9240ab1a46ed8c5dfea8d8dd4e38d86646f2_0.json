{"sha": "dfed9240ab1a46ed8c5dfea8d8dd4e38d86646f2", "log": "Completed major rewrite of handling of on/off features for ObjectMapper/SerConfig/DeserConfig", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n import com.fasterxml.jackson.databind.deser.DeserializerFactory;\n \n /**\n  * Object that contains baseline configuration for deserialization\n- * process. An instance is owned by {@link ObjectMapper}, which makes\n- * a copy that is passed during serialization process to\n- * {@link DeserializerProvider} and {@link DeserializerFactory}.\n+ * process. An instance is owned by {@link ObjectMapper}, which\n+ * passes an immutable instance for serialization process to\n+ * {@link DeserializerProvider} and {@link DeserializerFactory}\n+ * (either directly, or through {@link ObjectReader}.\n  *<p>\n- * Note: although configuration settings can be changed at any time\n- * (for factories and instances), they are not guaranteed to have\n- * effect if called after constructing relevant mapper or deserializer\n- * instance. This because some objects may be configured, constructed and\n- * cached first time they are needed.\n- *<p>\n- * Note: as of 2.0, goal is still to make config instances fully immutable.\n+ * Note that instances are considered immutable and as such no copies\n+ * should need to be created (there are some implementation details\n+ * with respect to mix-in annotations; where this is guaranteed as\n+ * long as caller follow \"copy-then-use\" pattern)\n  */\n public class DeserializationConfig\n     extends MapperConfigBase<DeserializationConfig.Feature, DeserializationConfig>\n {\n     /**\n-     * Enumeration that defines togglable features that guide\n-     * the serialization feature.\n-     * \n-     * Note that some features can only be set for\n-     * {@link ObjectMapper} (as default for all deserializations),\n-     * while others can be changed on per-call basis using {@link ObjectReader}.\n-     * Ones that can be used on per-call basis will return <code>true</code>\n-     * from {@link #canUseForInstance}.\n-     * Trying enable/disable ObjectMapper-only feature will result in\n-     * an {@link IllegalArgumentException}.\n+     * Enumeration that defines simple on/off features that affect\n+     * the way Java objects are deserialized from JSON\n+     *<p>\n+     * Note that features can be set both through\n+     * {@link ObjectMapper} (as sort of defaults) and through\n+     * {@link ObjectReader}.\n+     * In first case these defaults must follow \"config-then-use\" patterns\n+     * (i.e. defined once, not changed afterwards); all per-call\n+     * changes must be done using {@link ObjectReader}.\n      */\n     public enum Feature implements ConfigFeature\n     {\n         /*\n         /******************************************************\n-         *  Introspection features\n-        /******************************************************\n-         */\n-\n-        /**\n-         * Feature that determines whether annotation introspection\n-         * is used for configuration; if enabled, configured\n-         * {@link AnnotationIntrospector} will be used: if disabled,\n-         * no annotations are considered.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        USE_ANNOTATIONS(true, false),\n-\n-        /**\n-         * Feature that determines whether \"setter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public one-argument methods that\n-         * start with prefix \"set\"\n-         * are considered setters. If disabled, only methods explicitly\n-         * annotated are considered setters.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_SETTERS(true, false),\n-\n-        /**\n-         * Feature that determines whether \"creator\" methods are\n-         * automatically detected by consider public constructors,\n-         * and static single argument methods with name \"valueOf\".\n-         * If disabled, only methods explicitly annotated are considered\n-         * creator methods (except for the no-arg default constructor which\n-         * is always considered a factory method).\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_CREATORS(true, false),\n-\n-        /**\n-         * Feature that determines whether non-static fields are recognized as\n-         * properties.\n-         * If yes, then all public member fields\n-         * are considered as properties. If disabled, only fields explicitly\n-         * annotated are considered property fields.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_FIELDS(true, false),\n-\n-        /**\n-         * Feature that determines whether otherwise regular \"getter\"\n-         * methods (but only ones that handle Collections and Maps,\n-         * not getters of other type)\n-         * can be used for purpose of getting a reference to a Collection\n-         * and Map to modify the property, without requiring a setter\n-         * method.\n-         * This is similar to how JAXB framework sets Collections and\n-         * Maps: no setter is involved, just setter.\n-         *<p>\n-         * Note that such getters-as-setters methods have lower\n-         * precedence than setters, so they are only used if no\n-         * setter is found for the Map/Collection property.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        USE_GETTERS_AS_SETTERS(true, false),\n-\n-        /**\n-         * Feature that determines whether method and field access\n-         * modifier settings can be overridden when accessing\n-         * properties. If enabled, method\n-         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n-         * may be called to enable access to otherwise unaccessible\n-         * objects.\n-         */\n-        CAN_OVERRIDE_ACCESS_MODIFIERS(true, false),\n-\n-        /*\n-        /******************************************************\n         /* Type conversion features\n         /******************************************************\n          */\n \n         /**\n-         * Feature that determines whether Json floating point numbers\n+         * Feature that determines whether JSON floating point numbers\n          * are to be deserialized into {@link java.math.BigDecimal}s\n          * if only generic type description (either {@link Object} or\n          * {@link Number}, or within untyped {@link java.util.Map}\n          * point numbers will by default be deserialized as {@link Double}s\n          * (choice is for performance reason -- BigDecimals are slower than\n          * Doubles).\n-         * Feature <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        USE_BIG_DECIMAL_FOR_FLOATS(false, true),\n-\n-        /**\n-         * Feature that determines whether Json integral (non-floating-point)\n+         */\n+        USE_BIG_DECIMAL_FOR_FLOATS(false),\n+\n+        /**\n+         * Feature that determines whether JSON integral (non-floating-point)\n          * numbers are to be deserialized into {@link java.math.BigInteger}s\n          * if only generic type description (either {@link Object} or\n          * {@link Number}, or within untyped {@link java.util.Map}\n          * Feature is disabled by default, meaning that \"untyped\" floating\n          * point numbers will by default be deserialized using whatever\n          * is the most compact integral type, to optimize efficiency.\n-         * Feature <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        USE_BIG_INTEGER_FOR_INTS(false, true),\n+         */\n+        USE_BIG_INTEGER_FOR_INTS(false),\n \n         // [JACKSON-652]\n         /**\n          * If true, binds as <code>Object[]</code>; if false, as <code>List&lt;Object></code>.\n          *<p>\n          * Feature is disabled by default, meaning that JSON arrays are bound as\n-         * {@link java.util.List}s. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        USE_JAVA_ARRAY_FOR_JSON_ARRAY(false, true),\n+         * {@link java.util.List}s.\n+         */\n+        USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n         \n         /**\n          * Feature that determines standard deserialization mechanism used for\n          * Enum values: if enabled, Enums are assumed to have been serialized  using\n          * return value of <code>Enum.toString()</code>;\n          * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n-         * Since pre-1.6 method was to use Enum name, this is the default.\n          *<p>\n          * Note: this feature should usually have same value\n          * as {@link SerializationConfig.Feature#WRITE_ENUMS_USING_TO_STRING}.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        READ_ENUMS_USING_TO_STRING(false, true),\n+         * Feature is disabled by default.\n+         */\n+        READ_ENUMS_USING_TO_STRING(false),\n         \n         /*\n         /******************************************************\n          *<p>\n          * Feature is enabled by default (meaning that a\n          * {@link JsonMappingException} will be thrown if an unknown property\n-         * is encountered). It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        FAIL_ON_UNKNOWN_PROPERTIES(true, true),\n+         * is encountered).\n+         */\n+        FAIL_ON_UNKNOWN_PROPERTIES(true),\n \n         /**\n          * Feature that determines whether encountering of JSON null\n          * is thrown to indicate this; if not, default value is used\n          * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        FAIL_ON_NULL_FOR_PRIMITIVES(false, true),\n+         * Feature is disabled by default.\n+         */\n+        FAIL_ON_NULL_FOR_PRIMITIVES(false),\n \n         /**\n          * Feature that determines whether JSON integer numbers are valid\n          * mapping from integer values to enums might happen (and when enums\n          * are always serialized as JSON Strings)\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        FAIL_ON_NUMBERS_FOR_ENUMS(false, true),\n+         * Feature is disabled by default.\n+         */\n+        FAIL_ON_NUMBERS_FOR_ENUMS(false),\n \n         /**\n          * Feature that determines whether Jackson code should catch\n          * However, sometimes calling application may just want \"raw\"\n          * unchecked exceptions passed as is.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRAP_EXCEPTIONS(true, true),\n+         * Feature is enabled by default.\n+         */\n+        WRAP_EXCEPTIONS(true),\n         \n         /*\n         /******************************************************\n          * to work with packages (such as XML-to-JSON converters) that leave out JSON\n          * array in cases where there is just a single element in array.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        ACCEPT_SINGLE_VALUE_AS_ARRAY(false, true),\n+         * Feature is disabled by default.\n+         */\n+        ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n         \n         /**\n          * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n          * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n          * will be deserialized as if it was the root value.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        UNWRAP_ROOT_VALUE(false, true),\n+         * Feature is disabled by default.\n+         */\n+        UNWRAP_ROOT_VALUE(false),\n \n         /*\n         /******************************************************\n-         *  Value conversion features\n+        /* Value conversion features\n         /******************************************************\n          */\n         \n          * kinds of JSON values); if enable, empty JSON String can be taken\n          * to be equivalent of JSON null.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false, true)\n+         * Feature is enabled by default.\n+         */\n+        ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n         \n         ;\n \n         private final boolean _defaultState;\n-\n-        /**\n-         * Whether feature can be used and changed on per-call basis (true),\n-         * or just for <code>ObjectMapper</code> (false).\n-         */\n-        private final boolean _canUseForInstance;\n         \n-        private Feature(boolean defaultState, boolean canUseForInstance) {\n+        private Feature(boolean defaultState) {\n             _defaultState = defaultState;\n-            _canUseForInstance = canUseForInstance;\n         }\n \n         @Override\n         public boolean enabledByDefault() { return _defaultState; }\n-\n-        @Override\n-        public boolean canUseForInstance() { return _canUseForInstance; }\n     \n         @Override\n         public int getMask() { return (1 << ordinal()); }\n     /**********************************************************\n      */\n \n+    /**\n+     * Set of features enabled; actual type (kind of features)\n+     * depends on sub-classes.\n+     */\n+    protected final int _featureFlags;\n+    \n     /**\n      * Linked list that contains all registered problem handlers.\n      * Implementation as front-added linked list allows for sharing\n      * of the list (tail) without copying the list.\n      */\n-    protected LinkedNode<DeserializationProblemHandler> _problemHandlers;\n+    protected final LinkedNode<DeserializationProblemHandler> _problemHandlers;\n     \n     /**\n      * Factory used for constructing {@link com.fasterxml.jackson.core.JsonNode} instances.\n      */\n     protected final JsonNodeFactory _nodeFactory;\n-\n-    /**\n-     * Feature flag from {@link SerializationConfig} which is needed to\n-     * know if serializer will by default sort properties in\n-     * alphabetic order.\n-     *<p>\n-     * Note that although this property is not marked as final,\n-     * it is handled like it was, except for the fact that it is\n-     * assigned with a call to {@link #passSerializationFeatures}\n-     * instead of constructor.\n-     */\n-    protected boolean _sortPropertiesAlphabetically;\n     \n     /*\n     /**********************************************************\n      * Constructor used by ObjectMapper to create default configuration object instance.\n      */\n     public DeserializationConfig(BaseSettings base,\n-            int defaultFeatures, SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n-    {\n-        super(base, defaultFeatures, str, mixins);\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(base, str, mixins);\n+        _featureFlags = collectFeatureDefaults(DeserializationConfig.Feature.class);\n         _nodeFactory = JsonNodeFactory.instance;\n+        _problemHandlers = null;\n     }\n \n     /**\n     private DeserializationConfig(DeserializationConfig src, SubtypeResolver str)\n     {\n         super(src, str);\n+        _featureFlags = src._featureFlags;\n+        _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            int mapperFeatures, int deserFeatures)\n+    {\n+        super(src, mapperFeatures);\n+        _featureFlags = deserFeatures;\n         _nodeFactory = src._nodeFactory;\n-        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n-    }\n-\n-    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str,\n-            int features)\n-    {\n-        super(src, src._base, str, features);\n-\n         _problemHandlers = src._problemHandlers;\n+    }\n+    \n+    private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n+    {\n+        super(src, base);\n+        _featureFlags = src._featureFlags;\n         _nodeFactory = src._nodeFactory;\n-        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n-    }\n-    \n-    private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n-    {\n-        super(src, base, src._subtypeResolver, src._featureFlags);\n         _problemHandlers = src._problemHandlers;\n-        _nodeFactory = src._nodeFactory;\n-        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n     {\n         super(src);\n+        _featureFlags = src._featureFlags;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = f;\n-        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n-    }\n-\n-    private DeserializationConfig(DeserializationConfig src, int featureFlags)\n-    {\n-        super(src, featureFlags);\n-        _problemHandlers = src._problemHandlers;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            LinkedNode<DeserializationProblemHandler> problemHandlers)\n+    {\n+        super(src);\n+        _featureFlags = src._featureFlags;\n+        _problemHandlers = problemHandlers;\n         _nodeFactory = src._nodeFactory;\n-        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n-    }\n-    \n-    /**\n-     * Helper method to be called right after creating a non-shared\n-     * instance, needed to pass state of feature(s) shared with\n-     * SerializationConfig.\n-     */\n-    protected DeserializationConfig passSerializationFeatures(int serializationFeatureFlags)\n-    {\n-        _sortPropertiesAlphabetically = (serializationFeatureFlags\n-                & SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY.getMask()) != 0;\n-        return this;\n-    }\n-    \n+    }\n+       \n     /*\n     /**********************************************************\n     /* Life-cycle, factory methods from MapperConfig\n      * specified {@link JsonNodeFactory}\n      */\n     public DeserializationConfig withNodeFactory(JsonNodeFactory f) {\n+        if (_nodeFactory == f) {\n+            return this;\n+        }\n         return new DeserializationConfig(this, f);\n     }\n \n+    /**\n+     * Method that can be used to add a handler that can (try to)\n+     * resolve non-fatal deserialization problems.\n+     */\n+    public DeserializationConfig withHandler(DeserializationProblemHandler h)\n+    {\n+        // Sanity check: let's prevent adding same handler multiple times\n+        if (LinkedNode.contains(_problemHandlers, h)) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this,\n+                new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers));\n+    }\n+\n+    /**\n+     * Method for removing all configured problem handlers; usually done to replace\n+     * existing handler(s) with different one(s)\n+     */\n+    public DeserializationConfig withNoProblemHandlers() {\n+        if (_problemHandlers == null) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this,\n+                (LinkedNode<DeserializationProblemHandler>) null);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    @Override\n+    public DeserializationConfig with(MapperConfig.Feature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperConfig.Feature f : features) {\n+            newMapperFlags |= f.getMask();\n+        }\n+        return new DeserializationConfig(this, newMapperFlags, _featureFlags);\n+    }\n+    \n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features enabled.\n         for (Feature f : features) {\n             flags |= f.getMask();\n         }\n-        return new DeserializationConfig(this, flags);\n-    }\n-\n+        return new DeserializationConfig(this, _mapperFeatures, flags);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    @Override\n+    public DeserializationConfig without(MapperConfig.Feature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperConfig.Feature f : features) {\n+             newMapperFlags &= ~f.getMask();\n+        }\n+        return new DeserializationConfig(this, newMapperFlags, _featureFlags);\n+    }\n+    \n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features disabled.\n         for (Feature f : features) {\n             flags &= ~f.getMask();\n         }\n-        return new DeserializationConfig(this, flags);\n+        return new DeserializationConfig(this, _mapperFeatures, flags);\n     }\n     \n     /*\n     /* MapperConfig implementation\n     /**********************************************************\n      */\n-    \n-    /**\n-     * Method that is called to create a non-shared copy of the configuration\n-     * to be used for a deserialization operation.\n-     * Note that if sub-classing\n-     * and sub-class has additional instance methods,\n-     * this method <b>must</b> be overridden to produce proper sub-class\n-     * instance.\n-     */\n-    @Override\n-    public DeserializationConfig createUnshared() {\n-        return this;\n-    }\n-\n-\n-    @Override\n-    public DeserializationConfig createUnshared(int features) {\n-        return new DeserializationConfig(this, features);\n+\n+    @Override\n+    public final int getFeatureFlags() {\n+        return _featureFlags;\n     }\n     \n     /**\n         /* 29-Jul-2009, tatu: it's now possible to disable use of\n          *   annotations; can be done using \"no-op\" introspector\n          */\n-        if (isEnabled(Feature.USE_ANNOTATIONS)) {\n+        if (isEnabled(MapperConfig.Feature.USE_ANNOTATIONS)) {\n             return super.getAnnotationIntrospector();\n         }\n         return NopAnnotationIntrospector.instance;\n     public <T extends BeanDescription> T introspectDirectClassAnnotations(JavaType type) {\n         return (T) getClassIntrospector().forDirectClassAnnotations(this, type, this);\n     }\n-    \n-    @Override\n-    public boolean isAnnotationProcessingEnabled() {\n-        return isEnabled(Feature.USE_ANNOTATIONS);\n-    }\n-\n-    @Override\n-    public boolean canOverrideAccessModifiers() {\n-        return isEnabled(Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n-    }\n-\n-    @Override\n-    public boolean shouldSortPropertiesAlphabetically() {\n-        return _sortPropertiesAlphabetically;\n-    }\n \n     @Override\n     public VisibilityChecker<?> getDefaultVisibilityChecker()\n     {\n         VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n-        if (!isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS)) {\n+        if (!isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS)) {\n             vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n         }\n-        if (!isEnabled(DeserializationConfig.Feature.AUTO_DETECT_CREATORS)) {\n+        if (!isEnabled(MapperConfig.Feature.AUTO_DETECT_CREATORS)) {\n             vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n         }\n-        if (!isEnabled(DeserializationConfig.Feature.AUTO_DETECT_FIELDS)) {\n+        if (!isEnabled(MapperConfig.Feature.AUTO_DETECT_FIELDS)) {\n             vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n         }\n         return vchecker;\n     public boolean isEnabled(DeserializationConfig.Feature f) {\n         return (_featureFlags & f.getMask()) != 0;\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Problem handlers\n+\n+    /*\n+    /**********************************************************\n+    /* Other configuration\n     /**********************************************************\n      */\n \n      * Method for getting head of the problem handler chain. May be null,\n      * if no handlers have been added.\n      */\n-    public LinkedNode<DeserializationProblemHandler> getProblemHandlers()\n-    {\n+    public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n         return _problemHandlers;\n     }\n     \n-    /**\n-     * Method that can be used to add a handler that can (try to)\n-     * resolve non-fatal deserialization problems.\n-     */\n-    public void addHandler(DeserializationProblemHandler h)\n-    {\n-        /* Sanity check: let's prevent adding same handler multiple\n-         * times\n-         */\n-        if (!LinkedNode.contains(_problemHandlers, h)) {\n-            _problemHandlers = new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers);\n-        }\n-    }\n-\n-    /**\n-     * Method for removing all configured problem handlers; usually done to replace\n-     * existing handler(s) with different one(s)\n-     */\n-    public void clearHandlers()\n-    {\n-        _problemHandlers = null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Other configuration\n-    /**********************************************************\n-     */\n-\n     /**\n      * Method called during deserialization if Base64 encoded content\n      * needs to be decoded. Default version just returns default Jackson\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializerProvider.java\n     /**\n      * Method that sub-classes need to override, to ensure that fluent-factory\n      * methods will produce proper sub-type.\n-     * \n-     * @since 1.9\n      */\n     public abstract DeserializerProvider withFactory(DeserializerFactory factory);\n     \n      * to use specified deserializer provider, with highest precedence (that is,\n      * additional providers have higher precedence than default one or previously\n      * added ones)\n-     * \n-     * @since 1.7\n      */\n     public abstract DeserializerProvider withAdditionalDeserializers(Deserializers d);\n \n-    /**\n-     * @since 1.8\n-     */\n     public abstract DeserializerProvider withAdditionalKeyDeserializers(KeyDeserializers d);\n     \n-    /**\n-     * @since 1.7\n-     */\n     public abstract DeserializerProvider withDeserializerModifier(BeanDeserializerModifier modifier);\n \n-    /**\n-     * @since 1.8\n-     */\n     public abstract DeserializerProvider withAbstractTypeResolver(AbstractTypeResolver resolver);\n \n     /**\n      * Method that will construct a new instance with specified additional value instantiators\n      * (i.e. does NOT replace existing ones)\n-     * \n-     * @since 1.9\n      */\n     public abstract DeserializerProvider withValueInstantiators(ValueInstantiators instantiators);\n     \n      *<p>\n      * Since this method is only called for root elements, no referral information\n      * is taken.\n-     *    \n-     * @since 1.5\n      */\n     public abstract JsonDeserializer<Object> findTypedValueDeserializer(DeserializationConfig config,\n             JavaType type, BeanProperty property)\n      * (interface, abstract class) into a concrete type, or at least\n      * something \"more concrete\" (abstract class instead of interface).\n      * Will either return passed type, or a more specific type.\n-     * \n-     * @since 1.9\n      */\n     public abstract JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n         throws JsonMappingException;\n      *<p>\n      * The main use case for this method is to allow conditional flushing of\n      * deserializer cache, if certain number of entries is reached.\n-     * \n-     * @since 1.4\n      */\n     public abstract int cachedDeserializersCount();\n \n      * This can be used to remove memory usage (in case some deserializers are\n      * only used once or so), or to force re-construction of deserializers after\n      * configuration changes for mapper than owns the provider.\n-     * \n-     * @since 1.4\n      */\n     public abstract void flushCachedDeserializers();\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.lang.reflect.Type;\n import java.net.URL;\n import java.text.DateFormat;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n-import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n         // and default type factory is shared one\n         _typeFactory = TypeFactory.defaultInstance();\n         _serializationConfig = (sconfig != null) ? sconfig :\n-            new SerializationConfig(DEFAULT_BASE, collectFeatureDefaults(SerializationConfig.Feature.class),\n+            new SerializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n         _deserializationConfig = (dconfig != null) ? dconfig :\n-            new DeserializationConfig(DEFAULT_BASE, collectFeatureDefaults(DeserializationConfig.Feature.class),\n+            new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n         _serializerProvider = (sp == null) ? new StdSerializerProvider.Impl() : sp;\n         _deserializerProvider = (dp == null) ? new StdDeserializerProvider() : dp;\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n-    }\n-\n-    /**\n-     * Method that calculates bit set (flags) of all features that\n-     * are enabled by default.\n-     */\n-    protected static <F extends Enum<F> & ConfigFeature> int collectFeatureDefaults(Class<F> enumClass)\n-    {\n-        int flags = 0;\n-        for (F value : enumClass.getEnumConstants()) {\n-            if (value.enabledByDefault()) {\n-                flags |= value.getMask();\n-            }\n-        }\n-        return flags;\n     }\n     \n     /*\n     public SerializationConfig getSerializationConfig() {\n         return _serializationConfig;\n     }\n-\n-    /**\n-     * Method that creates a copy of\n-     * the shared default {@link SerializationConfig} object\n-     * that defines configuration settings for serialization.\n-     * Since it is a copy, any changes made to the configuration\n-     * object will NOT directly affect serialization done using\n-     * basic serialization methods that use the shared object (that is,\n-     * ones that do not take separate {@link SerializationConfig}\n-     * argument.\n-     *<p>\n-     * The use case is that of changing object settings of the configuration\n-     * (like date format being used, see {@link SerializationConfig#withDateFormat}).\n-     */\n-    public SerializationConfig copySerializationConfig() {\n-        return _serializationConfig.createUnshared();\n-    }\n-\n-    public SerializationConfig copySerializationConfig(int features) {\n-        return _serializationConfig.createUnshared(features);\n-    }\n     \n     /**\n      * Method for replacing the shared default serialization configuration\n      */\n     public DeserializationConfig getDeserializationConfig() {\n         return _deserializationConfig;\n-    }\n-\n-    /**\n-     * Method that creates a copy of\n-     * the shared default {@link DeserializationConfig} object\n-     * that defines configuration settings for deserialization.\n-     * Since it is a copy, any changes made to the configuration\n-     * object will NOT directly affect deserialization done using\n-     * basic deserialization methods that use the shared object (that is,\n-     * ones that do not take separate {@link DeserializationConfig}\n-     * argument.\n-     *<p>\n-     * The use case is that of changing object settings of the configuration\n-     * (like deserialization problem handler,\n-     * see {@link DeserializationConfig#addHandler})\n-     */\n-    public DeserializationConfig copyDeserializationConfig() {\n-        return _deserializationConfig.createUnshared()\n-                .passSerializationFeatures(_serializationConfig.getFeatureFlags());\n     }\n \n     /**\n         return this;\n     }\n \n+    /**\n+     * Method for adding specified {@link DeserializationProblemHandler}\n+     * to be used for handling specific problems during deserialization.\n+     */\n+    public ObjectMapper addHandler(DeserializationProblemHandler h) {\n+        _deserializationConfig = _deserializationConfig.withHandler(h);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for removing all registered {@link DeserializationProblemHandler}s\n+     * instances from this mapper.\n+     */\n+    public ObjectMapper clearProblemHandlers() {\n+        _deserializationConfig = _deserializationConfig.withNoProblemHandlers();\n+        return this;\n+    }\n+    \n+    \n     /*\n     /**********************************************************\n     /* Configuration, serialization\n      */\n \n     /**\n+     * Method for changing state of an on/off mapper feature for\n+     * this mapper instance.\n+     */\n+    public ObjectMapper configure(MapperConfig.Feature f, boolean state) {\n+        _serializationConfig = state ?\n+                _serializationConfig.with(f) : _serializationConfig.without(f);\n+        _deserializationConfig = state ?\n+                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n+        return this;\n+    }\n+    \n+    /**\n      * Method for changing state of an on/off serialization feature for\n      * this object mapper.\n      */\n     }\n \n     /**\n+     * Method for enabling specified {@link MapperConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(MapperConfig.Feature... f) {\n+        _deserializationConfig = _deserializationConfig.with(f);\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n+    public ObjectMapper disable(MapperConfig.Feature... f) {\n+        _deserializationConfig = _deserializationConfig.without(f);\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n     public ObjectMapper enable(DeserializationConfig.Feature... f) {\n         _deserializationConfig = _deserializationConfig.with(f);\n         return this;\n     }\n     \n     /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getSerializationConfig().isEnabled(f);\n-     *</pre>\n+     * Method for checking whether given Mapper\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(MapperConfig.Feature f) {\n+        // ok to use either one, should be kept in sync\n+        return _serializationConfig.isEnabled(f);\n+    }\n+\n+    /**\n+     * Method for checking whether given serialization-specific\n+     * feature is enabled.\n      */\n     public boolean isEnabled(SerializationConfig.Feature f) {\n         return _serializationConfig.isEnabled(f);\n     }\n-\n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getDeserializationConfig().isEnabled(f);\n-     *</pre>\n+    \n+    /**\n+     * Method for checking whether given deserialization-specific\n+     * feature is enabled.\n      */\n     public boolean isEnabled(DeserializationConfig.Feature f) {\n         return _deserializationConfig.isEnabled(f);\n     public <T> T readValue(JsonParser jp, Class<T> valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return (T) _readValue(copyDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n+        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n     } \n \n     /**\n     public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return (T) _readValue(copyDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n+        return (T) _readValue(getDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n     }\n \n     /**\n     public final <T> T readValue(JsonParser jp, ResolvedType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return (T) _readValue(copyDeserializationConfig(), jp, (JavaType) valueType);\n+        return (T) _readValue(getDeserializationConfig(), jp, (JavaType) valueType);\n     }\n \n     /**\n     public <T> T readValue(JsonParser jp, JavaType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return (T) _readValue(copyDeserializationConfig(), jp, valueType);\n+        return (T) _readValue(getDeserializationConfig(), jp, valueType);\n     }\n     \n     /**\n         /* 05-Aug-2011, tatu: Also, must check for EOF here before\n          *   calling readValue(), since that'll choke on it otherwise\n          */\n-        DeserializationConfig cfg = copyDeserializationConfig();\n+        DeserializationConfig cfg = getDeserializationConfig();\n         JsonToken t = jp.getCurrentToken();\n         if (t == null) {\n             t = jp.nextToken();\n     public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n             throws IOException, JsonProcessingException\n     {\n-        DeserializationConfig config = copyDeserializationConfig();\n+        DeserializationConfig config = getDeserializationConfig();\n         DeserializationContext ctxt = _createDeserializationContext(jp, config);\n         JsonDeserializer<?> deser = _findRootDeserializer(config, valueType);\n         // false -> do NOT close JsonParser (since caller passed it)\n     public void writeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        SerializationConfig config = copySerializationConfig();\n+        SerializationConfig config = getSerializationConfig();\n         if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, config);\n         } else {\n     public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n         throws IOException, JsonProcessingException\n     {\n-        SerializationConfig config = copySerializationConfig();\n+        SerializationConfig config = getSerializationConfig();\n         _serializerProvider.serializeValue(config, jgen, rootNode, _serializerFactory);\n         if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n             jgen.flush();\n      */\n     public boolean canSerialize(Class<?> type)\n     {\n-        return _serializerProvider.hasSerializerFor(copySerializationConfig(),\n+        return _serializerProvider.hasSerializerFor(getSerializationConfig(),\n                 type, _serializerFactory);\n     }\n \n      */\n     public boolean canDeserialize(JavaType type)\n     {\n-        return _deserializerProvider.hasValueDeserializerFor(copyDeserializationConfig(), type);\n+        return _deserializerProvider.hasValueDeserializerFor(getDeserializationConfig(), type);\n     }\n \n     /*\n     {\n      // !!! TODO\n //    \t_setupClassLoaderForDeserialization(valueType);\n-        return (T) _readValue(copyDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueType));\n+        return (T) _readValue(getDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueType));\n     } \n \n     /**\n     public <T> T readValue(JsonNode root, TypeReference valueTypeRef)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return (T) _readValue(copyDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueTypeRef));\n+        return (T) _readValue(getDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueTypeRef));\n     } \n     \n     /**\n     public <T> T readValue(JsonNode root, JavaType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-        return (T) _readValue(copyDeserializationConfig(), treeAsTokens(root), valueType);\n+        return (T) _readValue(getDeserializationConfig(), treeAsTokens(root), valueType);\n     } \n     \n     /*\n      * with default settings.\n      */\n     public ObjectWriter writer() {\n-        return new ObjectWriter(this, copySerializationConfig());\n+        return new ObjectWriter(this, getSerializationConfig());\n     }\n \n     /**\n      */\n     public ObjectWriter writer(DateFormat df) {\n         return new ObjectWriter(this,\n-                copySerializationConfig().withDateFormat(df));\n+                getSerializationConfig().withDateFormat(df));\n     }\n     \n     /**\n      * serialize objects using specified JSON View (filter).\n      */\n     public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return new ObjectWriter(this, copySerializationConfig().withView(serializationView));\n+        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      */\n     public ObjectWriter writerWithType(Class<?> rootType) {\n         JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n-        return new ObjectWriter(this, copySerializationConfig(), t, /*PrettyPrinter*/null);\n+        return new ObjectWriter(this, getSerializationConfig(), t, /*PrettyPrinter*/null);\n     }\n \n     /**\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n     public ObjectWriter writerWithType(JavaType rootType) {\n-        return new ObjectWriter(this, copySerializationConfig(), rootType, /*PrettyPrinter*/null);\n+        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n \n     /**\n      */\n     public ObjectWriter writerWithType(TypeReference<?> rootType) {\n         JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n-        return new ObjectWriter(this, copySerializationConfig(), t, /*PrettyPrinter*/null);\n+        return new ObjectWriter(this, getSerializationConfig(), t, /*PrettyPrinter*/null);\n     }\n     \n     /**\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, copySerializationConfig(), /*root type*/ null, pp);\n+        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * serialize objects using the default pretty printer for indentation\n      */\n     public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return new ObjectWriter(this, copySerializationConfig(),\n+        return new ObjectWriter(this, getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      */\n     public ObjectWriter writer(FilterProvider filterProvider) {\n         return new ObjectWriter(this,\n-                copySerializationConfig().withFilters(filterProvider));\n+                getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      * @param schema Schema to pass to generator\n      */\n     public ObjectWriter writer(FormatSchema schema) {\n-        return new ObjectWriter(this, copySerializationConfig(), schema);\n+        return new ObjectWriter(this, getSerializationConfig(), schema);\n     }\n     \n     /*\n      * without defining expected value type.\n      */\n     public ObjectReader reader() {\n-        return new ObjectReader(this, copyDeserializationConfig())\n+        return new ObjectReader(this, getDeserializationConfig())\n             .withInjectableValues(_injectableValues);\n     }\n     \n     public ObjectReader readerForUpdating(Object valueToUpdate)\n     {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return new ObjectReader(this, copyDeserializationConfig(), t, valueToUpdate,\n+        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      */\n     public ObjectReader reader(JavaType type)\n     {\n-        return new ObjectReader(this, copyDeserializationConfig(), type, null,\n+        return new ObjectReader(this, getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      */\n     public ObjectReader reader(JsonNodeFactory f)\n     {\n-        return new ObjectReader(this, copyDeserializationConfig()).withNodeFactory(f);\n+        return new ObjectReader(this, getDeserializationConfig()).withNodeFactory(f);\n     }\n \n     /**\n      * @param schema Schema to pass to parser\n      */\n     public ObjectReader reader(FormatSchema schema) {\n-        return new ObjectReader(this, copyDeserializationConfig(), null, null,\n+        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * @param injectableValues Injectable values to use\n      */\n     public ObjectReader reader(InjectableValues injectableValues) {\n-        return new ObjectReader(this, copyDeserializationConfig(), null, null,\n+        return new ObjectReader(this, getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n     \n         try {\n             // inlined 'writeValue' with minor changes:\n             // first: disable wrapping when writing\n-            int serFeatures = _serializationConfig.getFeatureFlags()\n-                    & ~(SerializationConfig.Feature.WRAP_ROOT_VALUE.getMask());\n+            SerializationConfig config = getSerializationConfig().without(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n             // no need to check for closing of TokenBuffer\n-            _serializerProvider.serializeValue(copySerializationConfig(serFeatures),\n-                    buf, fromValue, _serializerFactory);\n+            _serializerProvider.serializeValue(config, buf, fromValue, _serializerFactory);\n \n             // then matching read, inlined 'readValue' with minor mods:\n             final JsonParser jp = buf.asParser();\n             Object result;\n             // ok to pass in existing feature flags; unwrapping handled by mapper\n-            final DeserializationConfig deserConfig = copyDeserializationConfig();\n+            final DeserializationConfig deserConfig = getDeserializationConfig();\n             JsonToken t = _initForReading(jp);\n             if (t == JsonToken.VALUE_NULL) {\n                 result = _findRootDeserializer(deserConfig, toValueType).getNullValue();\n     public JsonSchema generateJsonSchema(Class<?> t)\n             throws JsonMappingException\n     {\n-        return generateJsonSchema(t, copySerializationConfig());\n+        return generateJsonSchema(t, getSerializationConfig());\n     }\n \n     /**\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        SerializationConfig cfg = copySerializationConfig();\n+        SerializationConfig cfg = getSerializationConfig();\n         // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n         if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        SerializationConfig cfg = copySerializationConfig().withView(viewClass);\n+        SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n         if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n             JsonToken t = _initForReading(jp);\n             if (t == JsonToken.VALUE_NULL) {\n                 // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n-                // (note: probably no need to make a copy of config for just this access)\n-                result = _findRootDeserializer(this._deserializationConfig, valueType).getNullValue();\n+                result = _findRootDeserializer(getDeserializationConfig(), valueType).getNullValue();\n             } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n                 result = null;\n             } else {\n-                DeserializationConfig cfg = copyDeserializationConfig();\n+                DeserializationConfig cfg = getDeserializationConfig();\n                 DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n                 JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n                 if (cfg.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n \n /**\n  * Object that contains baseline configuration for serialization\n- * process. An instance is owned by {@link ObjectMapper}, which makes\n- * a copy that is passed during serialization process to\n- * {@link SerializerProvider} and {@link SerializerFactory}.\n+ * process. An instance is owned by {@link ObjectMapper}, which\n+ * passes an immutable instance for serialization process to\n+ * {@link SerializerProvider} and {@link SerializerFactory}\n+ * (either directly, or through {@link ObjectWriter}.\n  *<p>\n- * Note: although configuration settings can be changed at any time\n- * (for factories and instances), they are not guaranteed to have\n- * effect if called after constructing relevant mapper or serializer\n- * instance. This because some objects may be configured, constructed and\n- * cached first time they are needed.\n- *<p>\n- * Note: as of 2.0, goal is still to make config instances fully immutable.\n+ * Note that instances are considered immutable and as such no copies\n+ * should need to be created (there are some implementation details\n+ * with respect to mix-in annotations; where this is guaranteed as\n+ * long as caller follow \"copy-then-use\" pattern)\n  */\n public class SerializationConfig\n     extends MapperConfigBase<SerializationConfig.Feature, SerializationConfig>\n {\n     /**\n-     * Enumeration that defines togglable features that guide\n-     * the serialization feature.\n-     * \n-     * Note that some features can only be set for\n-     * {@link ObjectMapper} (as default for all serializations),\n-     * while others can be changed on per-call basis using {@link ObjectWriter}.\n-     * Ones that can be used on per-call basis will return <code>true</code>\n-     * from {@link #canUseForInstance}.\n-     * Trying enable/disable ObjectMapper-only feature will result in\n-     * an {@link IllegalArgumentException}.\n+     * Enumeration that defines simple on/off features that affect\n+     * the way Java objects are serialized.\n+     *<p>\n+     * Note that features can be set both through\n+     * {@link ObjectMapper} (as sort of defaults) and through\n+     * {@link ObjectWriter}.\n+     * In first case these defaults must follow \"config-then-use\" patterns\n+     * (i.e. defined once, not changed afterwards); all per-call\n+     * changes must be done using {@link ObjectWriter}.\n      */\n     public enum Feature implements ConfigFeature\n     {\n         /*\n         /******************************************************\n-        /*  Introspection features\n-        /******************************************************\n-         */\n-        \n-        /**\n-         * Feature that determines whether annotation introspection\n-         * is used for configuration; if enabled, configured\n-         * {@link AnnotationIntrospector} will be used: if disabled,\n-         * no annotations are considered.\n-         *<p>\n-         * Feature is enabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        USE_ANNOTATIONS(true, false),\n-\n-        /**\n-         * Feature that determines whether regualr \"getter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public zero-argument methods that\n-         * start with prefix \"get\" \n-         * are considered as getters.\n-         * If disabled, only methods explicitly  annotated are considered getters.\n-         *<p>\n-         * Note that since version 1.3, this does <b>NOT</b> include\n-         * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        AUTO_DETECT_GETTERS(true, false),\n-\n-        /**\n-         * Feature that determines whether \"is getter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public zero-argument methods that\n-         * start with prefix \"is\", and whose return type is boolean\n-         * are considered as \"is getters\".\n-         * If disabled, only methods explicitly annotated are considered getters.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        AUTO_DETECT_IS_GETTERS(true, false),\n-\n-        /**\n-         * Feature that determines whether non-static fields are recognized as\n-         * properties.\n-         * If yes, then all public member fields\n-         * are considered as properties. If disabled, only fields explicitly\n-         * annotated are considered property fields.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-         AUTO_DETECT_FIELDS(true, false),\n-\n-        /**\n-         * Feature that determines whether method and field access\n-         * modifier settings can be overridden when accessing\n-         * properties. If enabled, method\n-         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n-         * may be called to enable access to otherwise unaccessible\n-         * objects.\n-         *<p>\n-         * Feature is enabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        CAN_OVERRIDE_ACCESS_MODIFIERS(true, false),\n-\n-        /**\n-         * Feature that determines whether getters (getter methods)\n-         * can be auto-detected if there is no matching mutator (setter,\n-         * constructor parameter or field) or not: if set to true,\n-         * only getters that match a mutator are auto-discovered; if\n-         * false, all auto-detectable getters can be discovered.\n-         *<p>\n-         * Feature is disabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        REQUIRE_SETTERS_FOR_GETTERS(false, false),\n-        \n-        /*\n-        /******************************************************\n         /* Generic output features\n         /******************************************************\n          */\n-\n-        /**\n-         * Feature that determines whether the type detection for\n-         * serialization should be using actual dynamic runtime type,\n-         * or declared static type.\n-         * Default value is false, to use dynamic runtime type.\n-         *<p>\n-         * This global default value can be overridden at class, method\n-         * or field level by using {@link JsonSerialize#typing} annotation\n-         * property\n-         *<p>\n-         * Feature is disabled by default. It can <b>not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        USE_STATIC_TYPING(false, false),\n-\n-        /**\n-         * Feature that determines whether properties that have no view\n-         * annotations are included in JSON serialization views (see\n-         * {@link com.fasterxml.jackson.annotation.JsonView} for more\n-         * details on JSON Views).\n-         * If enabled, non-annotated properties will be included;\n-         * when disabled, they will be excluded. So this feature\n-         * changes between \"opt-in\" (feature disabled) and\n-         * \"opt-out\" (feature enabled) modes.\n-         *<p>\n-         * Default value is enabled, meaning that non-annotated\n-         * properties are included in all views if there is no\n-         * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n-         *<p>\n-         * Feature is enabled by default. It <b>can not</b> changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        DEFAULT_VIEW_INCLUSION(true, false),\n         \n         /**\n          * Feature that can be enabled to make root value (usually JSON\n          * class name).\n          * Feature is mostly intended for JAXB compatibility.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRAP_ROOT_VALUE(false, true),\n+         * Feature is enabled by default.\n+         */\n+        WRAP_ROOT_VALUE(false),\n \n         /**\n          * Feature that allows enabling (or disabling) indentation\n          * method to use any <code>PrettyPrinter</code> instance.\n          * This feature will only allow using the default implementation.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        INDENT_OUTPUT(false, true),\n-\n-        /**\n-         * Feature that defines default property serialization order used\n-         * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n-         * serialization!):\n-         * if enabled, default ordering is alphabetic (similar to\n-         * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n-         * works); if disabled, order is unspecified (based on what JDK gives\n-         * us, which may be declaration order, but not guaranteed).\n-         *<p>\n-         * Note that this is just the default behavior, and can be overridden by\n-         * explicit overrides in classes.\n-         *<p>\n-         * Feature is disabled by default. It <b>can not</b> be changed\n-         * after first call to serialization; that is, it is not changeable\n-         * via {@link ObjectWriter}\n-         */\n-        SORT_PROPERTIES_ALPHABETICALLY(false, false),\n+         * Feature is enabled by default.\n+         */\n+        INDENT_OUTPUT(false),\n         \n         /*\n         /******************************************************\n          * (like <code>@JsonSerialize</code>): ones that do have annotations\n          * do not result in an exception being thrown.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        FAIL_ON_EMPTY_BEANS(true, true),\n+         * Feature is enabled by default.\n+         */\n+        FAIL_ON_EMPTY_BEANS(true),\n \n         /**\n          * Feature that determines whether Jackson code should catch\n          * unchecked exceptions passed as is.\n          *<p>\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRAP_EXCEPTIONS(true, true),\n+         * Feature is enabled by default.\n+         */\n+        WRAP_EXCEPTIONS(true),\n \n         /*\n         /******************************************************\n           * objects reachable from the root object. Put another way, only one\n           * call will be made for each 'writeValue' call.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n+         * Feature is disabled by default.\n           */\n-        CLOSE_CLOSEABLE(false, true),\n+        CLOSE_CLOSEABLE(false),\n \n         /**\n          * Feature that determines whether <code>JsonGenerator.flush()</code> is\n          * compressing and flush() causes compression state to be flushed\n          * (which occurs with some compression codecs).\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        FLUSH_AFTER_WRITE_VALUE(true, true),\n+         * Feature is enabled by default.\n+         */\n+        FLUSH_AFTER_WRITE_VALUE(true),\n          \n         /*\n         /******************************************************\n          * Note: whether {@link java.util.Map} keys are serialized as Strings\n          * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_DATES_AS_TIMESTAMPS(true, true),\n+         * Feature is enabled by default.\n+         */\n+        WRITE_DATES_AS_TIMESTAMPS(true),\n \n         /**\n          * Feature that determines whether {@link java.util.Date}s\n          * Default value is 'false', meaning that Date-valued Map keys are serialized\n          * as textual (ISO-8601) values.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_DATE_KEYS_AS_TIMESTAMPS(false, true),\n+         * Feature is disabled by default.\n+         */\n+        WRITE_DATE_KEYS_AS_TIMESTAMPS(false),\n \n         /**\n          * Feature that determines how type <code>char[]</code> is serialized:\n          * single-character Strings as values); when disabled, defaults to\n          * serializing them as Strings (which is more compact).\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false, true),\n+         * Feature is disabled by default.\n+         */\n+        WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false),\n \n         /**\n          * Feature that determines standard serialization mechanism used for\n          * Note: this feature should usually have same value\n          * as {@link DeserializationConfig.Feature#READ_ENUMS_USING_TO_STRING}.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_ENUMS_USING_TO_STRING(false, true),\n+         * Feature is disabled by default.\n+         */\n+        WRITE_ENUMS_USING_TO_STRING(false),\n \n         /**\n          * Feature that determines whethere Java Enum values are serialized\n          * Note that this feature has precedence over {@link #WRITE_ENUMS_USING_TO_STRING},\n          * which is only considered if this feature is set to false.\n          *<p>\n-         * Feature is disabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_ENUMS_USING_INDEX(false, true),\n+         * Feature is disabled by default.\n+         */\n+        WRITE_ENUMS_USING_INDEX(false),\n         \n         /**\n          * Feature that determines whether Map entries with null values are\n          *<p>\n          * For further details, check out [JACKSON-314]\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_NULL_MAP_VALUES(true, true),\n+         * Feature is enabled by default.\n+         */\n+        WRITE_NULL_MAP_VALUES(true),\n \n         /**\n          * Feature that determines whether Container properties (POJO properties\n          * Note that this does not change behavior of {@link java.util.Map}s, or\n          * \"Collection-like\" types.\n          *<p>\n-         * Feature is enabled by default. It <b>can</b> be changed\n-         * after first call to serialization; that is, it is changeable\n-         * via {@link ObjectWriter}\n-         */\n-        WRITE_EMPTY_JSON_ARRAYS(true, true)\n+         * Feature is enabled by default.\n+         */\n+        WRITE_EMPTY_JSON_ARRAYS(true)\n         \n             ;\n \n         private final boolean _defaultState;\n-\n-        /**\n-         * Whether feature can be used and changed on per-call basis (true),\n-         * or just for <code>ObjectMapper</code> (false).\n-         */\n-        private final boolean _canUseForInstance;\n-        \n-        private Feature(boolean defaultState, boolean canUseForInstance) {\n+        \n+        private Feature(boolean defaultState) {\n             _defaultState = defaultState;\n-            _canUseForInstance = canUseForInstance;\n         }\n         \n         @Override\n         public boolean enabledByDefault() { return _defaultState; }\n \n         @Override\n-        public boolean canUseForInstance() { return _canUseForInstance; }\n-\n-        @Override\n         public int getMask() { return (1 << ordinal()); }\n     }\n \n     /*\n     /**********************************************************\n-    /* Configuration settings\n-    /**********************************************************\n-     */\n+    /* Serialization settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Set of features enabled; actual type (kind of features)\n+     * depends on sub-classes.\n+     */\n+    protected final int _featureFlags;\n     \n     /**\n      * Which Bean/Map properties are to be included in serialization?\n      * Constructor used by ObjectMapper to create default configuration object instance.\n      */\n     public SerializationConfig(BaseSettings base,\n-            int defaultFeatures, SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n-    {\n-        super(base, defaultFeatures, str, mixins);\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(base, str, mixins);\n+        _featureFlags = collectFeatureDefaults(SerializationConfig.Feature.class);\n         _filterProvider = null;\n     }\n     \n-    private SerializationConfig(SerializationConfig src, SubtypeResolver str) {\n+    private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n+    {\n         super(src, str);\n+        _featureFlags = src._featureFlags;\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     }\n \n-    private SerializationConfig(SerializationConfig src, int features) {\n-        super(src, features);\n+    private SerializationConfig(SerializationConfig src,\n+            int mapperFeatures, int serFeatures)\n+    {\n+        super(src, mapperFeatures);\n+        _featureFlags = serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     \n     private SerializationConfig(SerializationConfig src, BaseSettings base)\n     {\n-        super(src, base, src._subtypeResolver);\n+        super(src, base);\n+        _featureFlags = src._featureFlags;\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     private SerializationConfig(SerializationConfig src, FilterProvider filters)\n     {\n         super(src);\n+        _featureFlags = src._featureFlags;\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = filters;\n     private SerializationConfig(SerializationConfig src, Class<?> view)\n     {\n         super(src);\n+        _featureFlags = src._featureFlags;\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = view;\n         _filterProvider = src._filterProvider;\n     private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n     {\n         super(src);\n+        _featureFlags = src._featureFlags;\n         _serializationInclusion = incl;\n-        _serializationView = src._serializationView;\n-        _filterProvider = src._filterProvider;\n-    }\n-\n-    private SerializationConfig(SerializationConfig src, SubtypeResolver str,\n-            int features)\n-    {\n-        super(src, str, features);\n-        _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     }\n      * object instance with specified features enabled.\n      */\n     @Override\n+    public SerializationConfig with(MapperConfig.Feature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperConfig.Feature f : features) {\n+            newMapperFlags |= f.getMask();\n+        }\n+        return new SerializationConfig(this, newMapperFlags, _featureFlags);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    @Override\n     public SerializationConfig with(Feature... features)\n     {\n         int flags = _featureFlags;\n         for (Feature f : features) {\n             flags |= f.getMask();\n         }\n-        return new SerializationConfig(this, flags);\n-    }\n-\n+        return new SerializationConfig(this, _mapperFeatures, flags);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    @Override\n+    public SerializationConfig without(MapperConfig.Feature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperConfig.Feature f : features) {\n+             newMapperFlags &= ~f.getMask();\n+        }\n+        return new SerializationConfig(this, newMapperFlags, _featureFlags);\n+    }\n+    \n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features disabled.\n         for (Feature f : features) {\n             flags &= ~f.getMask();\n         }\n-        return new SerializationConfig(this, flags);\n+        return new SerializationConfig(this, _mapperFeatures, flags);\n     }\n     \n     /*\n     /* MapperConfig implementation/overrides\n     /**********************************************************\n      */\n-    \n-    @Override\n-    public SerializationConfig createUnshared() {\n-        return this;\n-    }\n-\n-    @Override\n-    public SerializationConfig createUnshared(int features) {\n-        return new SerializationConfig(this, features);\n+\n+    @Override\n+    public final int getFeatureFlags() {\n+        return _featureFlags;\n     }\n     \n     @Override\n         /* 29-Jul-2009, tatu: it's now possible to disable use of\n          *   annotations; can be done using \"no-op\" introspector\n          */\n-        if (isEnabled(Feature.USE_ANNOTATIONS)) {\n+        if (isEnabled(MapperConfig.Feature.USE_ANNOTATIONS)) {\n             return super.getAnnotationIntrospector();\n         }\n         return AnnotationIntrospector.nopInstance();\n     public <T extends BeanDescription> T introspectDirectClassAnnotations(JavaType type) {\n         return (T) getClassIntrospector().forDirectClassAnnotations(this, type, this);\n     }\n-\n-    @Override\n-    public boolean isAnnotationProcessingEnabled() {\n-        return isEnabled(SerializationConfig.Feature.USE_ANNOTATIONS);\n-    }\n-    \n-    @Override\n-    public boolean canOverrideAccessModifiers() {\n-        return isEnabled(Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n-    }\n-\n-    @Override\n-    public boolean shouldSortPropertiesAlphabetically() {\n-        return isEnabled(Feature.SORT_PROPERTIES_ALPHABETICALLY);\n-    }\n     \n     @Override\n     public VisibilityChecker<?> getDefaultVisibilityChecker()\n     {\n         VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n-        if (!isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS)) {\n+        if (!isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS)) {\n             vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n         }\n         // then global overrides (disabling)\n-        if (!isEnabled(SerializationConfig.Feature.AUTO_DETECT_IS_GETTERS)) {\n+        if (!isEnabled(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS)) {\n             vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n         }\n-        if (!isEnabled(SerializationConfig.Feature.AUTO_DETECT_FIELDS)) {\n+        if (!isEnabled(MapperConfig.Feature.AUTO_DETECT_FIELDS)) {\n             vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n         }\n         return vchecker;\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import java.util.Date;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n      *  getConfig().isEnabled(feature);\n      *</pre>\n      */\n+    public final boolean isEnabled(MapperConfig.Feature feature) {\n+        return _config.isEnabled(feature);\n+    }\n+\n+    /**\n+     * Convenience method for checking whether specified serialization\n+     * feature is enabled or not.\n+     * Shortcut for:\n+     *<pre>\n+     *  getConfig().isEnabled(feature);\n+     *</pre>\n+     */\n     public final boolean isEnabled(SerializationConfig.Feature feature) {\n         return _config.isEnabled(feature);\n     }\n-\n+    \n     /**\n      * Convenience method for accessing serialization view in use (if any); equivalent to:\n      *<pre>\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/ConfigFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/ConfigFeature.java\n      * Accessor for checking whether this feature is enabled by default.\n      */\n     public boolean enabledByDefault();\n-\n-    /**\n-     * Accessor for checking whether feature can be used on per-call basis\n-     * (true), or not (false): in latter case it can only be configured once\n-     * before any serialization or deserialization.\n-     */\n-    public boolean canUseForInstance();\n     \n     /**\n      * Returns bit mask for this feature instance\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n  * serialization and deserialization configuration objects;\n  * accessors to mode-independent configuration settings\n  * and such.\n+ * In addition, shared features are defined\n+ * in {@link MapperConfig.Feature}\n  *<p>\n  * Small part of implementation is included here by aggregating\n  * {@link BaseSettings} instance that contains configuration\n public abstract class MapperConfig<T extends MapperConfig<T>>\n     implements ClassIntrospector.MixInResolver\n {\n+    /**\n+     * Enumeration that defines simple on/off features to set\n+     * for {@link ObjectMapper}, and accessible (but NOT mutable!)\n+     * via {@link SerializationConfig} and {@link DeserializationConfig}.\n+     * Note that in addition to being only mutable via {@link ObjectMapper},\n+     * changes only take effect when done <b>before any serialization or\n+     * deserialization</b> calls -- that is, caller must follow\n+     * \"configure-then-use\" pattern.\n+     */\n+    public enum Feature implements ConfigFeature\n+    {\n+        /*\n+        /******************************************************\n+        /*  Introspection features\n+        /******************************************************\n+         */\n+        \n+        /**\n+         * Feature that determines whether annotation introspection\n+         * is used for configuration; if enabled, configured\n+         * {@link AnnotationIntrospector} will be used: if disabled,\n+         * no annotations are considered.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        USE_ANNOTATIONS(true),\n+\n+        /**\n+         * Feature that determines whether \"creator\" methods are\n+         * automatically detected by consider public constructors,\n+         * and static single argument methods with name \"valueOf\".\n+         * If disabled, only methods explicitly annotated are considered\n+         * creator methods (except for the no-arg default constructor which\n+         * is always considered a factory method).\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<P>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_CREATORS(true),\n+        \n+        /**\n+         * Feature that determines whether non-static fields are recognized as\n+         * properties.\n+         * If yes, then all public member fields\n+         * are considered as properties. If disabled, only fields explicitly\n+         * annotated are considered property fields.\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+         AUTO_DETECT_FIELDS(true),\n+        \n+        /**\n+         * Feature that determines whether regualr \"getter\" methods are\n+         * automatically detected based on standard Bean naming convention\n+         * or not. If yes, then all public zero-argument methods that\n+         * start with prefix \"get\" \n+         * are considered as getters.\n+         * If disabled, only methods explicitly  annotated are considered getters.\n+         *<p>\n+         * Note that since version 1.3, this does <b>NOT</b> include\n+         * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_GETTERS(true),\n+\n+        /**\n+         * Feature that determines whether \"is getter\" methods are\n+         * automatically detected based on standard Bean naming convention\n+         * or not. If yes, then all public zero-argument methods that\n+         * start with prefix \"is\", and whose return type is boolean\n+         * are considered as \"is getters\".\n+         * If disabled, only methods explicitly annotated are considered getters.\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_IS_GETTERS(true),\n+\n+         /**\n+          * Feature that determines whether \"setter\" methods are\n+          * automatically detected based on standard Bean naming convention\n+          * or not. If yes, then all public one-argument methods that\n+          * start with prefix \"set\"\n+          * are considered setters. If disabled, only methods explicitly\n+          * annotated are considered setters.\n+          *<p>\n+          * Note that this feature has lower precedence than per-class\n+          * annotations, and is only used if there isn't more granular\n+          * configuration available.\n+          *<P>\n+          * Feature is enabled by default.\n+          */\n+         AUTO_DETECT_SETTERS(true),\n+         \n+         /**\n+          * Feature that determines whether getters (getter methods)\n+          * can be auto-detected if there is no matching mutator (setter,\n+          * constructor parameter or field) or not: if set to true,\n+          * only getters that match a mutator are auto-discovered; if\n+          * false, all auto-detectable getters can be discovered.\n+          *<p>\n+          * Feature is disabled by default.\n+          */\n+         REQUIRE_SETTERS_FOR_GETTERS(false),\n+\n+         /**\n+          * Feature that determines whether otherwise regular \"getter\"\n+          * methods (but only ones that handle Collections and Maps,\n+          * not getters of other type)\n+          * can be used for purpose of getting a reference to a Collection\n+          * and Map to modify the property, without requiring a setter\n+          * method.\n+          * This is similar to how JAXB framework sets Collections and\n+          * Maps: no setter is involved, just setter.\n+          *<p>\n+          * Note that such getters-as-setters methods have lower\n+          * precedence than setters, so they are only used if no\n+          * setter is found for the Map/Collection property.\n+          *<p>\n+          * Feature is enabled by default.\n+          */\n+         USE_GETTERS_AS_SETTERS(true),\n+\n+         /**\n+         * Feature that determines whether method and field access\n+         * modifier settings can be overridden when accessing\n+         * properties. If enabled, method\n+         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n+         * may be called to enable access to otherwise unaccessible\n+         * objects.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+\n+        /*\n+        /******************************************************\n+        /* Type-handling features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines whether the type detection for\n+         * serialization should be using actual dynamic runtime type,\n+         * or declared static type.\n+         * Note that deserialization always uses declared static types\n+         * since no runtime types are available (as we are creating\n+         * instances after using type information).\n+         *<p>\n+         * This global default value can be overridden at class, method\n+         * or field level by using {@link JsonSerialize#typing} annotation\n+         * property.\n+         *<p>\n+         * Feature is disabled by default which means that dynamic runtime types\n+         * are used (instead of declared static types) for serialization.\n+         */\n+        USE_STATIC_TYPING(false),\n+\n+        /*\n+        /******************************************************\n+        /* View-related features\n+        /******************************************************\n+         */\n+        \n+        /**\n+         * Feature that determines whether properties that have no view\n+         * annotations are included in JSON serialization views (see\n+         * {@link com.fasterxml.jackson.annotation.JsonView} for more\n+         * details on JSON Views).\n+         * If enabled, non-annotated properties will be included;\n+         * when disabled, they will be excluded. So this feature\n+         * changes between \"opt-in\" (feature disabled) and\n+         * \"opt-out\" (feature enabled) modes.\n+         *<p>\n+         * Default value is enabled, meaning that non-annotated\n+         * properties are included in all views if there is no\n+         * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        DEFAULT_VIEW_INCLUSION(true),\n+        \n+        /*\n+        /******************************************************\n+        /* Generic output features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that defines default property serialization order used\n+         * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n+         * serialization!):\n+         * if enabled, default ordering is alphabetic (similar to\n+         * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n+         * works); if disabled, order is unspecified (based on what JDK gives\n+         * us, which may be declaration order, but is not guaranteed).\n+         *<p>\n+         * Note that this is just the default behavior, and can be overridden by\n+         * explicit overrides in classes.\n+         *<p>\n+         * Feature is disabled by default.\n+         */\n+        SORT_PROPERTIES_ALPHABETICALLY(false)\n+\n+        ;\n+\n+        private final boolean _defaultState;\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+        }\n+        \n+        @Override\n+        public boolean enabledByDefault() { return _defaultState; }\n+\n+        @Override\n+        public int getMask() { return (1 << ordinal()); }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Simple immutable basic settings\n      */\n \n     /**\n+     * Set of shared mapper features enabled.\n+     */\n+    protected final int _mapperFeatures;\n+    \n+    /**\n      * Immutable container object for simple configuration settings.\n      */\n     protected final BaseSettings _base;\n     /**********************************************************\n      */\n \n-    protected MapperConfig(BaseSettings base)\n+    protected MapperConfig(BaseSettings base, int mapperFeatures)\n     {\n         _base = base;\n+        _mapperFeatures = mapperFeatures;\n+    }\n+\n+    protected MapperConfig(MapperConfig<T> src)\n+    {\n+        _base = src._base;\n+        _mapperFeatures = src._mapperFeatures;\n+    }\n+    \n+    /**\n+     * Method that calculates bit set (flags) of all features that\n+     * are enabled by default.\n+     */\n+    public static <F extends Enum<F> & ConfigFeature> int collectFeatureDefaults(Class<F> enumClass)\n+    {\n+        int flags = 0;\n+        for (F value : enumClass.getEnumConstants()) {\n+            if (value.enabledByDefault()) {\n+                flags |= value.getMask();\n+            }\n+        }\n+        return flags;\n     }\n     \n     /*\n     /* Life-cycle: factory methods\n     /**********************************************************\n      */\n-    \n-    /**\n-     * Method to use for constructing an instance that is not shared\n-     * between multiple operations but only used for a single one\n-     * (which may be this instance, if it is immutable; if not, a copy\n-     * is constructed with same settings)\n-     */\n-    public abstract T createUnshared();\n-\n-    /**\n-     * Method to use for constructing an instance that is not shared\n-     * between multiple operations but only used for a single one\n-     * (which may be this instance, if it is immutable; if not, a copy\n-     * is constructed with same settings)\n-     */\n-    public abstract T createUnshared(int features);\n-\n+\n+    /**\n+     * Method for constructing and returning a new instance with specified\n+     * mapper features enabled.\n+     */\n+    public abstract T with(MapperConfig.Feature... features);\n+\n+    /**\n+     * Method for constructing and returning a new instance with specified\n+     * mapper features disabled.\n+     */\n+    public abstract T without(MapperConfig.Feature... features);\n+    \n     /**\n      * Method for constructing and returning a new instance with different\n      * {@link ClassIntrospector}\n     /* Configuration: simple features\n     /**********************************************************\n      */\n+\n+    /**\n+     * Accessor for simple mapper features (which are shared for\n+     * serialization, deserialization)\n+     */\n+    public final boolean isEnabled(MapperConfig.Feature f) {\n+        return (_mapperFeatures & f.getMask()) != 0;\n+    }\n     \n     /**\n      * Method for determining whether annotation processing is enabled or not\n      * \n      * @return True if annotation processing is enabled; false if not\n      */\n-    public abstract boolean isAnnotationProcessingEnabled();\n+    public final boolean isAnnotationProcessingEnabled() {\n+        return isEnabled(MapperConfig.Feature.USE_ANNOTATIONS);\n+    }\n \n     /**\n      * Accessor for determining whether it is ok to try to force override of access\n      *   any Field, Method, Constructor or Class); false to prevent any attempts\n      *   to override.\n      */\n-    public abstract boolean canOverrideAccessModifiers();\n+    public final boolean canOverrideAccessModifiers() {\n+        return isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+    }\n \n     /**\n      * Accessor for checking whether default settings for property handling\n      * indicate that properties should be alphabetically ordered or not.\n      */\n-    public abstract boolean shouldSortPropertiesAlphabetically();\n+    public final boolean shouldSortPropertiesAlphabetically() {\n+        return isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n     T extends MapperConfigBase<CFG,T>>\n     extends MapperConfig<T>\n {\n+    private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperConfig.Feature.class);\n+\n     /*\n     /**********************************************************\n     /* Immutable config\n     /**********************************************************\n      */\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n-     */\n-    protected int _featureFlags;\n \n     /**\n      * Mix-in annotation mappings to use, if any: immutable,\n     /**********************************************************\n      */\n \n+    /**\n+     * Constructor used when creating a new instance (compared to\n+     * that of creating fluent copies)\n+     */\n     protected MapperConfigBase(BaseSettings base,\n-            int defaultFeatures, SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n     {\n-        super(base);\n-        _featureFlags = defaultFeatures;\n+        super(base, DEFAULT_MAPPER_FEATURES);\n         _mixInAnnotations = mixins;\n         _subtypeResolver = str;\n     }\n     \n+    /**\n+     * Pass-through constructor used when no changes are needed to the\n+     * base class.\n+     */\n     protected MapperConfigBase(MapperConfigBase<CFG,T> src) {\n-        super(src._base);\n-        _featureFlags = src._featureFlags;\n+        super(src);\n         _mixInAnnotations = src._mixInAnnotations;\n         _subtypeResolver = src._subtypeResolver;\n     }\n     \n-    protected MapperConfigBase(MapperConfigBase<CFG,T> src, int features) {\n-        super(src._base);\n-        _featureFlags = features;\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, int mapperFeatures)\n+    {\n+        super(src._base, mapperFeatures);\n         _mixInAnnotations = src._mixInAnnotations;\n         _subtypeResolver = src._subtypeResolver;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, SubtypeResolver str) {\n-        super(src._base);\n-        _featureFlags = src._featureFlags;\n+        super(src);\n         _mixInAnnotations = src._mixInAnnotations;\n         _subtypeResolver = str;\n     }\n-    \n-    protected MapperConfigBase(MapperConfigBase<CFG,T> src, SubtypeResolver str,\n-            int features)\n+\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base)\n     {\n-        super(src._base);\n-        _featureFlags = features;\n+        super(base, src._mapperFeatures);\n         _mixInAnnotations = src._mixInAnnotations;\n-        _subtypeResolver = str;\n-    }\n-    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base, SubtypeResolver str)\n-    {\n-        super(base);\n-        _featureFlags = src._featureFlags;\n-        _mixInAnnotations = src._mixInAnnotations;\n-        _subtypeResolver = str;\n-    }\n-    \n-    protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base, SubtypeResolver str,\n-            int features)\n-    {\n-        super(base);\n-        _featureFlags = features;\n-        _mixInAnnotations = src._mixInAnnotations;\n-        _subtypeResolver = str;\n+        _subtypeResolver = src._subtypeResolver;\n     }\n     \n     /*\n     /**********************************************************\n      */\n \n-    public final int getFeatureFlags() {\n-        return _featureFlags;\n-    }\n+    public abstract int getFeatureFlags();\n \n     /**\n      * Accessor for object used for finding out all reachable subtypes\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import com.fasterxml.jackson.core.JsonNode;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.JacksonDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n         /* also, as per [JACKSON-328], should not override fields (or actual setters),\n          * thus these are added AFTER adding fields\n          */\n-        if (config.isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n+        if (config.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n             /* Hmmh. We have to assume that 'use getters as setters' also\n              * implies 'yes, do auto-detect these getters'? (if not, we'd\n              * need to add AUTO_DETECT_GETTERS to deser config too, not\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n                 return true;\n             }\n         } else {\n-            if (config.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING)) {\n+            if (config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)) {\n                 return true;\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n             }\n             JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n             // copied from BasicSerializerFactory.buildMapSerializer():\n-            boolean staticTyping = config.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING);\n+            boolean staticTyping = config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING);\n             JavaType valueType = type.getContentType();\n             TypeSerializer typeSer = createTypeSerializer(config, valueType, property);\n             // last 2 nulls; don't know key, value serializers (yet)\n         removeIgnorableTypes(config, beanDesc, properties);\n         \n         // and possibly remove ones without matching mutator...\n-        if (config.isEnabled(SerializationConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS)) {\n+        if (config.isEnabled(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS)) {\n             removeSetterlessGetters(config, beanDesc, properties);\n         }\n         \n      * if they want to provide custom view handling. As such it is not\n      * considered an internal implementation detail, and will be supported\n      * as part of API going forward.\n-     *<p>\n-     * NOTE: signature of this method changed in 1.7, due to other significant\n-     * changes (esp. use of builder for serializer construction).\n      */\n     protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n     {\n         // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n         List<BeanPropertyWriter> props = builder.getProperties();\n-        boolean includeByDefault = config.isEnabled(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        boolean includeByDefault = config.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n         final int propCount = props.size();\n         int viewsFound = 0;\n         BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n              * the actual type until we get the instance.\n              */\n             // 10-Mar-2010, tatu: Except if static typing is to be used\n-            if (provider.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING)\n+            if (provider.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)\n                     || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) {\n                 JavaType t = provider.constructType(_accessorMethod.getGenericReturnType());\n                 // false -> no need to cache\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n         ObjectMapper m = new ObjectMapper();\n         \n         // sort-alphabetically is disabled by default:\n-        assertFalse(m.isEnabled(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n-        SerializationConfig sc = m.copySerializationConfig();\n-        assertFalse(sc.isEnabled(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertFalse(m.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        SerializationConfig sc = m.getSerializationConfig();\n+        assertFalse(sc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertFalse(sc.shouldSortPropertiesAlphabetically());\n-        DeserializationConfig dc = m.copyDeserializationConfig();\n+        DeserializationConfig dc = m.getDeserializationConfig();\n         assertFalse(dc.shouldSortPropertiesAlphabetically());\n \n         // but when enabled, should be visible:\n-        m.enable(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n-        sc = m.copySerializationConfig();\n-        assertTrue(sc.isEnabled(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        m.enable(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+        sc = m.getSerializationConfig();\n+        assertTrue(sc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertTrue(sc.shouldSortPropertiesAlphabetically());\n-        dc = m.copyDeserializationConfig();\n+        dc = m.getDeserializationConfig();\n         // and not just via SerializationConfig, but also via DeserializationConfig\n+        assertTrue(dc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertTrue(dc.shouldSortPropertiesAlphabetically());\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for checking handling of DeserializationConfig.\n         DeserializationConfig cfg = m.getDeserializationConfig();\n \n         // Expected defaults:\n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.USE_ANNOTATIONS));\n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.AUTO_DETECT_CREATORS));\n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS));\n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_CREATORS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n \n \n         assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS));\n     {\n         // first: verify that annotation introspection is enabled by default\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(m.getDeserializationConfig().isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n         // with annotations, property is renamed\n         AnnoBean bean = m.readValue(\"{ \\\"y\\\" : 0 }\", AnnoBean.class);\n         assertEquals(0, bean.value);\n \n         m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.USE_ANNOTATIONS, false);\n+        m.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n         // without annotations, should default to default bean-based name...\n         bean = m.readValue(\"{ \\\"x\\\" : 0 }\", AnnoBean.class);\n         assertEquals(0, bean.value);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that feature requested\n     {\n         ObjectMapper m = new ObjectMapper();\n         // by default, it should be enabled\n-        assertTrue(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS));\n-        m.configure(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n-        assertFalse(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(m.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n+        assertFalse(m.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n \n         // and now this should fail\n         try {\n         throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n+        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n         // so this should fail now without a setter\n         try {\n             m.readValue\n     public void testSetterlessPrecedence() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS, true);\n+        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, true);\n         Dual value = m.readValue(\"{\\\"list\\\":[1,2,3]}, valueType)\", Dual.class);\n         assertNotNull(value);\n         assertEquals(3, value.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n         throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.getDeserializationConfig().clearHandlers();\n-        mapper.getDeserializationConfig().addHandler(new MyHandler());\n+        mapper.clearProblemHandlers();\n+        mapper.addHandler(new MyHandler());\n         TestBean result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n         assertNotNull(result);\n         assertEquals(1, result._a);\n     /**\n      * Test for checking that it is also possible to simply suppress\n      * error reporting for unknown properties.\n-     *\n-     * @since 1.2\n      */\n     public void testUnknownHandlingIgnoreWithFeature()\n         throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import java.math.BigDecimal;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-\n-/**\n- * @since 1.9\n- */\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+\n public class TestPOJOPropertiesCollector\n     extends BaseMapTest\n {\n     public void testGlobalVisibilityForGetters()\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n         POJOPropertiesCollector coll = collector(m, SimpleGetterVisibility.class, true);\n         // should be 1, expect that we disabled getter auto-detection, so\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n     public void testJackson703() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.USE_ANNOTATIONS, false);\n+        mapper.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n         BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class));\n         assertNotNull(beanDesc);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n \n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestGenericListSerialization\n         embedded.add(new Child1());\n         embedded.add(new Child2());\n         input.setResult(embedded);\n-        mapper.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        mapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n         byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that types that serialize as JSON Arrays\n  * get properly serialized with types (esp. for contents, and\n  * gracefully handling Lists themselves too)\n- * \n- * @author tatus\n- * @since 1.5\n  */\n public class TestTypedArraySerialization\n     extends BaseMapTest\n \n         // then with static typing enabled:\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n         assertEquals(EXP, m.writeValueAsString(input));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestMixinSerWithViews\n     extends BaseMapTest\n         A a = new A(\"myname\", 29, \"mysurname\");\n \n         // Property SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION set to false\n-        mapper.configure(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n+        mapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n         mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n     private ObjectMapper createObjectMapper( )\n     {\n       ObjectMapper objectMapper = new ObjectMapper( );\n-      objectMapper.configure( SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+      objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-      objectMapper.configure( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n+      objectMapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n \n       Map<Class<?>, Class<?>> sourceMixins = new HashMap<Class<?>, Class<?>>( );\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * This unit test suite tests use of @JsonClass Annotation\n     public void testStaticTypingWithMap() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n         ValueMap map = new ValueMap();\n         map.put(\"a\", new ValueClass());\n         assertEquals(\"{\\\"a\\\":{\\\"x\\\":3}}\", serializeAsString(m, map));\n     public void testStaticTypingWithArrayList() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n         ValueList list = new ValueList();\n         list.add(new ValueClass());\n         assertEquals(\"[{\\\"x\\\":3}]\", m.writeValueAsString(list));\n     public void testStaticTypingWithLinkedList() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n         ValueLinkedList list = new ValueLinkedList();\n         list.add(new ValueClass());\n         assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, list));\n     public void testStaticTypingWithArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n         ValueInterface[] array = new ValueInterface[] { new ValueClass() };\n         assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, array));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n \n /**\n     /*********************************************************\n      */\n \n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n     public void testSimpleJsonValue() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        String result = serializeAsString(m, new ValueClass<String>(\"abc\"));\n+        String result = mapper.writeValueAsString(new ValueClass<String>(\"abc\"));\n         assertEquals(\"\\\"abc\\\"\", result);\n     }\n \n     public void testJsonValueWithUseSerializer() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        String result = serializeAsString(m, new ToStringValueClass<Integer>(Integer.valueOf(123)));\n+        String result = serializeAsString(mapper, new ToStringValueClass<Integer>(Integer.valueOf(123)));\n         assertEquals(\"\\\"123\\\"\", result);\n     }\n \n      */\n     public void testMixedJsonValue() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        String result = serializeAsString(m, new ToStringValueClass2(\"xyz\"));\n+        String result = serializeAsString(mapper, new ToStringValueClass2(\"xyz\"));\n         assertEquals(\"\\\"xyz\\\"\", result);\n     }\n \n     public void testValueWithStaticType() throws Exception\n     {\n         // Ok; first, with dynamic type:\n-        ObjectMapper m = new ObjectMapper();\n-        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", serializeAsString(m, new ValueWrapper()));\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(new ValueWrapper()));\n \n         // then static\n-        m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n-        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", serializeAsString(m, new ValueWrapper()));\n+        ObjectMapper staticMapper = new ObjectMapper();\n+        staticMapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", staticMapper.writeValueAsString(new ValueWrapper()));\n     }\n \n     public void testMapWithJsonValue() throws Exception\n     {\n-        assertEquals(\"{\\\"a\\\":\\\"1\\\"}\", new ObjectMapper().writeValueAsString(new MapBean()));\n+        assertEquals(\"{\\\"a\\\":\\\"1\\\"}\", mapper.writeValueAsString(new MapBean()));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n package com.fasterxml.jackson.databind.ser;\n-\n \n import java.io.*;\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * This unit test suite tests use of Annotations for\n     {\n         ObjectMapper m = new ObjectMapper();\n         GettersWithoutSetters bean = new GettersWithoutSetters(123);\n-        assertFalse(m.isEnabled(SerializationConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS));\n+        assertFalse(m.isEnabled(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS));\n     \n         // by default, all 4 found:\n         assertEquals(\"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n \n         // but 3 if we require mutator:\n         m = new ObjectMapper();\n-        m.enable(SerializationConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS);\n+        m.enable(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS);\n         assertEquals(\"{\\\"a\\\":3,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n \n import java.util.*;\n \n-\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n /**\n         SerializationConfig cfg = m.getSerializationConfig();\n \n         // First, defaults:\n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.USE_ANNOTATIONS));\n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS));\n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n \n         assertTrue(cfg.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n \n         assertFalse(cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT));\n-        assertFalse(cfg.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING));\n+        assertFalse(cfg.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING));\n \n         // since 1.3:\n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.AUTO_DETECT_IS_GETTERS));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS));\n         // since 1.4\n         \n         assertTrue(cfg.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n         // since 1.5\n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION));\n+        assertTrue(cfg.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION));\n \n     }\n \n     {\n         // first: verify that annotation introspection is enabled by default\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(m.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n         Map<String,Object> result = writeAndMap(m, new AnnoBean());\n         assertEquals(2, result.size());\n \n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.USE_ANNOTATIONS, false);\n+        m.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n         result = writeAndMap(m, new AnnoBean());\n         assertEquals(1, result.size());\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for checking whether JsonSerializerFactory.Feature\n         // Then auto-detection disabled. But note: we MUST create a new\n         // mapper, since old version of serializer may be cached by now\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n         result = writeAndMap(m, new GetterClass());\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"x\"));\n         assertTrue(result.containsKey(\"x\"));\n \n         // And then class-level auto-detection enabling, should override defaults\n-        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n         result = writeAndMap(m, new EnabledGetterClass());\n         assertEquals(2, result.size());\n         assertTrue(result.containsKey(\"x\"));\n     {\n         ObjectMapper m = new ObjectMapper();\n         // class level should override\n-        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, true);\n-        m.configure(SerializationConfig.Feature.AUTO_DETECT_IS_GETTERS, false);\n+        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, true);\n+        m.configure(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS, false);\n          Map<String,Object> result = writeAndMap(m, new EnabledIsGetterClass());\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"ok\"));\n     public void testConfigChainability()\n     {\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS));\n-        m.configure(DeserializationConfig.Feature.AUTO_DETECT_SETTERS, false).configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n-        assertFalse(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertFalse(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS));\n+        assertTrue(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n+        assertTrue(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+        m.configure(MapperConfig.Feature.AUTO_DETECT_SETTERS, false)\n+            .configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        assertFalse(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n+        assertFalse(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n     }\n \n     // Test for [JACKSON-282]\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         // must force static typing, otherwise won't matter a lot\n-        mapper.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        mapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n         String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.annotation.*;\n+\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that constraints on ordering of serialized\n     public void testOrderWithFeature() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY, true);\n+        m.configure(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY, true);\n         assertEquals(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"d\\\":4}\", serializeAsString(m, new BeanFor459()));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestViews.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying JSON view functionality: ability to declaratively\n \n         // but can also change (but not necessarily on the fly...)\n         mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, false);\n+        mapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false);\n         // with this setting, only explicit inclusions count:\n         String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean);\n         map = mapper.readValue(json, Map.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestViews2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestViews2.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestViews2 extends BaseMapTest\n {\n     ObjectMapper objectMapper = new ObjectMapper( );\n     objectMapper.configure( SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n     objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-    objectMapper.configure( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n+    objectMapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n //    objectMapper.getSerializationConfig( ).disable( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION );\n //    objectMapper.getSerializationConfig( ).setSerializationView( viewClass );\n     return objectMapper;", "timestamp": 1327005104, "metainfo": ""}