{"sha": "ee67deeffb3149c7a0798fca8988f3c0cc2c54f3", "log": "Add #305 implementation; also, add numeric test for -0.0", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n  * {@link com.fasterxml.jackson.databind.jsontype.TypeDeserializer}) for converting\n  * between type and matching id; id is stored in JSON and needed for\n  * creating instances of proper subtypes when deserializing values.\n+ *<p>\n+ * NOTE: it is <b>strongly</b> recommended that developers always extend\n+ * abstract base class {@link com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase}\n+ * instead of directly implementing this interface; this helps prevent\n+ * breakage in case new methds need to be added in this interface (something\n+ * we try to avoid doing; but which may be necessary in some cases).\n  */\n public interface TypeIdResolver\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-\n+import com.fasterxml.jackson.databind.DatabindContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n     }\n \n     @Override\n-    public JavaType typeFromId(String id)\n+    public JavaType typeFromId(String id) {\n+        return _typeFromId(id, _typeFactory);\n+    }\n+\n+    @Override\n+    public JavaType typeFromId(DatabindContext context, String id) {\n+        return _typeFromId(id, context.getTypeFactory());\n+    }\n+\n+    protected JavaType _typeFromId(String id, TypeFactory typeFactory)\n     {\n         /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n          *    check if any generics info is added; and only then ask factory\n          *    to do translation when necessary\n          */\n         if (id.indexOf('<') > 0) {\n-            JavaType t = _typeFactory.constructFromCanonical(id);\n+            JavaType t = typeFactory.constructFromCanonical(id);\n             // note: may want to try combining with specialization (esp for EnumMap)?\n             return t;\n         }\n         try {\n             Class<?> cls =  ClassUtil.findClass(id);\n-            return _typeFactory.constructSpecializedType(_baseType, cls);\n+            return typeFactory.constructSpecializedType(_baseType, cls);\n         } catch (ClassNotFoundException e) {\n             throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): no such class found\");\n         } catch (Exception e) {\n             throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n         }\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/MinimalClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/MinimalClassNameIdResolver.java\n package com.fasterxml.jackson.databind.jsontype.impl;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n     }\n \n     @Override\n-    public JavaType typeFromId(String id)\n+    protected JavaType _typeFromId(String id, TypeFactory typeFactory)\n     {\n         if (id.startsWith(\".\")) {\n             StringBuilder sb = new StringBuilder(id.length() + _basePackageName.length());\n             }\n             id = sb.toString();\n         }\n-        return super.typeFromId(id);\n+        return super._typeFromId(id, typeFactory);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n         synchronized (_deserializers) {\n             deser = _deserializers.get(typeId);\n             if (deser == null) {\n-                JavaType type = _idResolver.typeFromId(typeId);\n+                /* As per [Issue#305], need to provide contextual info. But for\n+                 * backwards compatibility, let's start by only supporting this\n+                 * for base class, not via interface. Later on we can add this\n+                 * to the interface, assuming deprecation at base class helps.\n+                 */\n+                JavaType type;\n+                if (_idResolver instanceof TypeIdResolverBase) {\n+                    type = ((TypeIdResolverBase) _idResolver).typeFromId(ctxt, typeId);\n+                } else {\n+                    type = _idResolver.typeFromId(typeId);\n+                }\n                 if (type == null) {\n                     // As per [JACKSON-614], use the default impl if no type id available:\n                     if (_defaultImpl == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n package com.fasterxml.jackson.databind.jsontype.impl;\n \n+import com.fasterxml.jackson.databind.DatabindContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n+/**\n+ * Partial base implementation of {@link TypeIdResolver}: all custom implementations\n+ * are <b>strongly</b> recommended to extend this class, instead of directly\n+ * implementing {@link TypeIdResolver}.\n+ *<p>\n+ * Note that instances created to be constructed from annotations\n+ * ({@link com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver})\n+ * are always created using no-arguments constructor; protected constructor\n+ * is only used sub-classes.\n+ */\n public abstract class TypeIdResolverBase\n     implements TypeIdResolver\n {\n      */\n     protected final JavaType _baseType;\n \n+    protected TypeIdResolverBase() {\n+        this(null, null);\n+    }\n+    \n     protected TypeIdResolverBase(JavaType baseType, TypeFactory typeFactory)\n     {\n         _baseType = baseType;\n          */\n         return idFromValueAndType(null, _baseType.getRawClass());\n     }\n+\n+    /**\n+     * @deprecated Since 2.3, override {@link #typeFromId(DatabindContext, String)} instead\n+     *    to get access to contextual information\n+     */\n+    @Deprecated\n+    @Override\n+    public abstract JavaType typeFromId(String id);\n+\n+    /**\n+     * New method, replacement for {@link #typeFromId(String)}, which is given\n+     * context for accessing information, including configuration and\n+     * {@link TypeFactory}.\n+     * \n+     * @return Type for given id\n+     * \n+     * @since 2.3\n+     */\n+    public JavaType typeFromId(DatabindContext context, String id) {\n+        return typeFromId(id);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-\n import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.DatabindContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n     }\n     \n     @Override\n-    public JavaType typeFromId(String id)\n-        throws IllegalArgumentException\n+    public JavaType typeFromId(String id) {\n+        return _idToType.get(id);\n+    }    \n+\n+    @Override\n+    public JavaType typeFromId(DatabindContext context, String id) {\n+        return _typeFromId(id);\n+    }\n+    \n+    protected JavaType _typeFromId(String id)\n     {\n-        JavaType t = _idToType.get(id);\n         /* Now: if no type is found, should we try to locate it by\n          * some other means? (specifically, if in same package as base type,\n          * could just try Class.forName)\n          * For now let's not add any such workarounds; can add if need be\n          */\n-        return t;\n+        return _idToType.get(id);\n     }    \n-\n+    \n     @Override\n     public String toString()\n     {\n-    \tStringBuilder sb = new StringBuilder();\n-    \tsb.append('[').append(getClass().getName());\n-    \tsb.append(\"; id-to-type=\").append(_idToType);\n-    \tsb.append(']');\n-    \treturn sb.toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[').append(getClass().getName());\n+        sb.append(\"; id-to-type=\").append(_idToType);\n+        sb.append(']');\n+        return sb.toString();\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n         assertTrue(LongNode.valueOf(Long.MIN_VALUE).canConvertToLong());\n     }\n \n-    public void testDouble()\n+    public void testDouble() throws Exception\n     {\n         DoubleNode n = DoubleNode.valueOf(0.25);\n         assertStandardEquals(n);\n         assertTrue(DoubleNode.valueOf(0L).canConvertToLong());\n         assertTrue(DoubleNode.valueOf(Long.MAX_VALUE).canConvertToLong());\n         assertTrue(DoubleNode.valueOf(Long.MIN_VALUE).canConvertToLong());\n+\n+        JsonNode num = objectMapper().readTree(\" -0.0\");\n+        assertTrue(num.isDouble());\n+        n = (DoubleNode) num;\n+        assertEquals(-0.0, n.doubleValue());\n+        assertEquals(\"-0.0\", String.valueOf(n.doubleValue()));\n     }\n \n     // @since 2.2", "timestamp": 1380413506, "metainfo": ""}