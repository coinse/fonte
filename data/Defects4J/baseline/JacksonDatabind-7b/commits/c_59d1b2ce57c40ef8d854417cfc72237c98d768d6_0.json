{"sha": "59d1b2ce57c40ef8d854417cfc72237c98d768d6", "log": "Remove calls deprecated JsonNode methods", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     extends StdDeserializer<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 1518773374647478964L;\n+    private static final long serialVersionUID = 4564890642370311174L;\n \n     protected final JavaType _mapType;\n     \n     /**********************************************************\n      */\n \n-    /**\n-     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n-     */\n-    @Deprecated\n-    public EnumMapDeserializer(JavaType mapType,\n-            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser) {\n-        this(mapType, keyDeserializer, valueDeser, null);\n-    }\n-    \n-    public EnumMapDeserializer(JavaType mapType,\n-            JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser,\n-            TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n     {\n         super(EnumMap.class);\n         _mapType = mapType;\n         _valueTypeDeserializer = valueTypeDeser;\n     }\n \n-    /**\n-     * @deprecated Since 2.1.3 -- use variant that takes one more argument.\n-     */\n-    @Deprecated\n-    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n-            JsonDeserializer<?> valueDeserializer)\n+    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n     {\n-        return withResolved(keyDeserializer, valueDeserializer, null);\n-    } \n-    \n-    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer,\n-            JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n-    {\n-        if ((keyDeserializer == _keyDeserializer)\n-                && (valueDeserializer == _valueDeserializer)\n-                && (valueTypeDeser == _valueTypeDeserializer)) {\n+        if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         }\n-        return new EnumMapDeserializer(_mapType,\n-                keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n+        return new EnumMapDeserializer(_mapType, keyDeserializer, valueDeserializer, _valueTypeDeserializer);\n     }\n     \n     /**\n      * when it is known for which property deserializer is needed for.\n      */\n     @Override\n-    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n-            BeanProperty property) throws JsonMappingException\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) throws JsonMappingException\n     {\n         // note: instead of finding key deserializer, with enums we actually\n         // work with regular deserializers (less code duplication; but not\n      */\n \n     @Override\n-    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException\n     {\n         // Ok: must point to START_OBJECT\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n     }\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n+   public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n         // In future could check current token... for now this should be enough:\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n      * @param value to set field to; if null, will be converted\n      *   to a {@link NullNode} first  (to remove field entry, call\n      *   {@link #remove} instead)\n-     *<p>\n-     * NOTE: this method will be <b>deprecated</b> in 2.2; and should\n-     * be replace with either\n-     * {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},\n-     * depending on which return value is desired for possible chaining.\n      *   \n      * @return Old value of the field, if any; null if there was no\n      *   old value.\n-     */\n+     *   \n+     * @deprecated Since 2.4 use either {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},\n+     */\n+    @Deprecated\n     public JsonNode put(String fieldName, JsonNode value)\n     {\n         if (value == null) { // let's not store 'raw' nulls but nodes\n      * \n      * @return Value of specified field, if it existed; null if not\n      */\n-    public JsonNode remove(String fieldName)\n-    {\n+    public JsonNode remove(String fieldName) {\n         return _children.remove(fieldName);\n     }\n \n     /**\n      * Method for adding given properties to this object node, overriding\n      * any existing values for those properties.\n-     *<p>\n-     * NOTE: this method will be <b>deprecated</b> in 2.2; and should\n-     * be replace with {@link #setAll(Map)}.\n      * \n      * @param properties Properties to add\n      * \n      * @return This node after adding/replacing property values (to allow chaining)\n-     */\n+     * \n+     * @deprecated Since 2.4 use {@link #setAll(Map)},\n+     */\n+    @Deprecated\n     public JsonNode putAll(Map<String,JsonNode> properties) {\n         return setAll(properties);\n     }\n     /**\n      * Method for adding all properties of the given Object, overriding\n      * any existing values for those properties.\n-     *<p>\n-     * NOTE: this method will be <b>deprecated</b> in 2.2; and should\n-     * be replace with {@link #setAll(ObjectNode)}.\n      * \n      * @param other Object of which properties to add to this object\n      * \n      * @return This node (to allow chaining)\n-     */\n+     * \n+     * @deprecated Since 2.4 use {@link #setAll(ObjectNode)},\n+     */\n+    @Deprecated\n     public JsonNode putAll(ObjectNode other) {\n         return setAll(other);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n      */\n \n     /**\n-     * Deprecated method; final to help identify problems with sub-classes,\n-     * as this method will NOT be called any more in 2.1\n-     * \n-     * @deprecated Since 2.1 (removed 'property' argument)\n-     */\n-    @Deprecated\n-    protected final JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n-            JavaType type, BeanDescription beanDesc, BeanProperty property, boolean staticTyping)\n-        throws JsonMappingException\n-    {\n-        return  buildContainerSerializer(prov, type, beanDesc, staticTyping);\n-    }\n-    \n-    /**\n      * @since 2.1\n      */\n     protected JsonSerializer<?> buildContainerSerializer(SerializerProvider prov,\n         return null;\n     }\n \n-    /**\n-     * Deprecated method; final to help identify problems with sub-classes,\n-     * as this method will NOT be called any more in 2.1\n-     * \n-     * @deprecated Since 2.1\n-     */\n-    @Deprecated\n-    protected final JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n-            CollectionType type,\n-            BeanDescription beanDesc, BeanProperty property,\n-            boolean staticTyping,\n-            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n-        throws JsonMappingException\n-    {\n-        return buildCollectionSerializer(config, type, beanDesc,\n-                staticTyping, elementTypeSerializer, elementValueSerializer);\n-    }\n-    \n     /**\n      * Helper method that handles configuration details when constructing serializers for\n      * {@link java.util.List} types that support efficient by-index access\n      * Method called to find filter that is configured to be used with bean\n      * serializer being built, if any.\n      */\n-    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc)\n-    {\n+    protected Object findFilterId(SerializationConfig config, BeanDescription beanDesc) {\n         return config.getAnnotationIntrospector().findFilterId((Annotated)beanDesc.getClassInfo());\n     }\n-    \n-    /**\n-     * @deprecated Since 2.1: use method without 'property'\n-     */\n-    @Deprecated\n-    protected final  boolean usesStaticTyping(SerializationConfig config,\n-            BeanDescription beanDesc, TypeSerializer typeSer, BeanProperty property)\n-    {\n-        return usesStaticTyping(config, beanDesc, typeSer);\n-    }\n-    \n+\n     /**\n      * Helper method to check whether global settings and/or class\n      * annotations for the bean class indicate that static typing\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     // @since 2.3 -- needed so it can be overridden by unwrapping writer\n     protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode)\n     {\n-        propertiesNode.put(getName(), schemaNode);\n+        propertiesNode.set(getName(), schemaNode);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n      */\n \n     /**\n-     * @deprecated Since 2.1: need to use the new variant without 'property'\n-     *    argument (since one won't be passed)\n-     */\n-    @Deprecated\n-    public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n-            JavaType baseType, BeanProperty property)\n-        throws JsonMappingException {\n-        return createSerializer(prov, baseType);\n-    }\n-    \n-    /**\n       * Method called to create (or, for immutable serializers, reuse) a serializer for given type. \n       * \n       * @param prov Provider that needs to be used to resolve annotation-provided\n     public abstract JsonSerializer<Object> createKeySerializer(SerializationConfig config,\n             JavaType baseType, JsonSerializer<Object> defaultImpl)\n         throws JsonMappingException;\n-\n-    /**\n-     * @deprecated Since 2.2, use one that takes additional <code>defaultImpl</code> parameter\n-     */\n-    @Deprecated\n-    public JsonSerializer<Object> createKeySerializer(SerializationConfig config,\n-            JavaType baseType)\n-        throws JsonMappingException {\n-        return createKeySerializer(config, baseType, null);\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatTypes;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.std.ArraySerializerBase;\n         }\n     }\n \n-    private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider,\n-            JsonSerializer<Object> ser)\n+    private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider, JsonSerializer<Object> ser)\n         throws IOException, JsonGenerationException\n     {\n         for (int i = 0, len = value.length; i < len; ++i) {\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n-        ObjectNode o = createSchemaNode(\"array\", true);\n-        o.put(\"items\", createSchemaNode(\"string\"));\n-        return o;\n-    }\n-    \n-    @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+        return createSchemaNode(\"array\", true).set(\"items\", createSchemaNode(\"string\"));\n+    }\n+    \n+    @Override\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n         if (visitor != null) {\n             JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n                 if (_nameTransformer != null) {\n                     name = _nameTransformer.transform(name);\n                 }\n-                propertiesNode.put(name, entry.getValue());\n+                propertiesNode.set(name, entry.getValue());\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Intermediate base class for Lists, Collections and Arrays\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n-        ObjectNode o = createSchemaNode(\"array\", true);\n-        o.put(\"items\", contentSchema());\n-        return o;\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+        return createSchemaNode(\"array\", true).set(\"items\", contentSchema());\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-        throws JsonMappingException\n-    {\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n         acceptContentVisitor(visitor.expectArrayFormat(typeHint));\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n      * Accessor for checking to see if there is a standard serializer for\n      * given primitive value type.\n      */\n-    public static JsonSerializer<?> findStandardImpl(Class<?> cls)\n-    {\n+    public static JsonSerializer<?> findStandardImpl(Class<?> cls) {\n         return _arraySerializers.get(cls.getName());\n     }\n     \n      * Intermediate base class used for cases where we may add\n      * type information (excludes boolean/int/double arrays).\n      */\n-    protected abstract static class TypedPrimitiveArraySerializer<T>\n-        extends ArraySerializerBase<T>\n+    protected abstract static class TypedPrimitiveArraySerializer<T> extends ArraySerializerBase<T>\n     {\n         /**\n          * Type serializer to use for values, if any.\n      */\n \n     @JacksonStdImpl\n-    public final static class BooleanArraySerializer\n-        extends ArraySerializerBase<boolean[]>\n+    public final static class BooleanArraySerializer extends ArraySerializerBase<boolean[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Boolean.class);\n         public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         {\n             ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"boolean\"));\n+            o.set(\"items\", createSchemaNode(\"boolean\"));\n             return o;\n         }\n \n      * NOTE: since it is NOT serialized as an array, can not use AsArraySerializer as base\n      */\n     @JacksonStdImpl\n-    public final static class ByteArraySerializer\n-        extends StdSerializer<byte[]>\n+    public final static class ByteArraySerializer extends StdSerializer<byte[]>\n     {\n         public ByteArraySerializer() {\n             super(byte[].class);\n         {\n             ObjectNode o = createSchemaNode(\"array\", true);\n             ObjectNode itemSchema = createSchemaNode(\"string\"); //binary values written as strings?\n-            o.put(\"items\", itemSchema);\n-            return o;\n+            return o.set(\"items\", itemSchema);\n         }\n         \n         @Override\n     }\n \n     @JacksonStdImpl\n-    public final static class ShortArraySerializer\n-        extends TypedPrimitiveArraySerializer<short[]>\n+    public final static class ShortArraySerializer extends TypedPrimitiveArraySerializer<short[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Short.TYPE);\n         {\n             //no \"short\" type defined by json\n             ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"integer\"));\n-            return o;\n+            return o.set(\"items\", createSchemaNode(\"integer\"));\n         }\n         \n         @Override\n      * NOTE: since it is NOT serialized as an array, can not use AsArraySerializer as base\n      */\n     @JacksonStdImpl\n-    public final static class CharArraySerializer\n-        extends StdSerializer<char[]>\n+    public final static class CharArraySerializer extends StdSerializer<char[]>\n     {\n         public CharArraySerializer() { super(char[].class); }\n         \n             ObjectNode o = createSchemaNode(\"array\", true);\n             ObjectNode itemSchema = createSchemaNode(\"string\");\n             itemSchema.put(\"type\", \"string\");\n-            o.put(\"items\", itemSchema);\n-            return o;\n+            return o.set(\"items\", itemSchema);\n         }\n         \n         @Override\n     }\n \n     @JacksonStdImpl\n-    public final static class IntArraySerializer\n-        extends ArraySerializerBase<int[]>\n+    public final static class IntArraySerializer extends ArraySerializerBase<int[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Integer.TYPE);\n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"integer\"));\n-            return o;\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+            return createSchemaNode(\"array\", true).set(\"items\", createSchemaNode(\"integer\"));\n+        }\n+        \n+        @Override\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n             if (visitor != null) {\n                 JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);\n     }\n \n     @JacksonStdImpl\n-    public final static class LongArraySerializer\n-        extends TypedPrimitiveArraySerializer<long[]>\n+    public final static class LongArraySerializer extends TypedPrimitiveArraySerializer<long[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Long.TYPE);\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"number\", true));\n-            return o;\n+            return createSchemaNode(\"array\", true)\n+                .set(\"items\", createSchemaNode(\"number\", true));\n         }\n \n         @Override\n     }\n \n     @JacksonStdImpl\n-    public final static class FloatArraySerializer\n-        extends TypedPrimitiveArraySerializer<float[]>\n+    public final static class FloatArraySerializer extends TypedPrimitiveArraySerializer<float[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Float.TYPE);\n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"number\"));\n-            return o;\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+            return createSchemaNode(\"array\", true).set(\"items\", createSchemaNode(\"number\"));\n+        }\n+        \n+        @Override\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n             if (visitor != null) {\n                 JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);\n     }\n \n     @JacksonStdImpl\n-    public final static class DoubleArraySerializer\n-        extends ArraySerializerBase<double[]>\n+    public final static class DoubleArraySerializer extends ArraySerializerBase<double[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Double.TYPE);\n         }\n \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            ObjectNode o = createSchemaNode(\"array\", true);\n-            o.put(\"items\", createSchemaNode(\"number\"));\n-            return o;\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+            return createSchemaNode(\"array\", true).set(\"items\", createSchemaNode(\"number\"));\n         }\n         \n         @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n \tstatic class MyTypeImpl implements MyType {\n \t\tprivate String data;\n \n+\t\t@Override\n \t\tpublic String getData() {\n-\t\t\treturn data;\n+\t\t    return data;\n \t\t}\n \n+\t\t@Override\n \t\tpublic void setData(String data) {\n-\t\t\tthis.data = data;\n+\t\t    this.data = data;\n \t\t}\n \t}\n ", "timestamp": 1388461947, "metainfo": ""}