{"sha": "2f26e6a6fdce400cf910a47c4903561c62200c0c", "log": "Start work on adding context(-accessible) attributes; general-purpose key/value context", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DatabindContext.java\n     \n     /*\n     /**********************************************************\n+    /* Generic attributes (2.3+)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing attributes available in this context.\n+     * Per-call attributes have highest precedence; attributes set\n+     * via {@link ObjectReader} or {@link ObjectWriter} have lower\n+     * precedence.\n+     * \n+     * @param key Key of the attribute to get\n+     * @return Value of the attribute, if any; null otherwise\n+     * \n+     * @since 2.3\n+     */\n+    public abstract Object getAttribute(Object key);\n+\n+    /**\n+     * Method for setting per-call value of given attribute.\n+     * This will override any previously defined value for the\n+     * attribute within this context.\n+     * \n+     * @param key Key of the attribute to set\n+     * @param value Value to set attribute to\n+     * \n+     * @return This context object, to allow chaining\n+     * \n+     * @since 2.3\n+     */\n+    public abstract DatabindContext setAttribute(Object key, Object value);\n+\n+    /*\n+    /**********************************************************\n     /* Type instantiation/resolution\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, ContextAttributes attrs)\n+    {\n+        super(src, attrs);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n     \n     // for unit tests only:\n     protected BaseSettings getBaseSettings() { return _base; }\n     public DeserializationConfig with(Base64Variant base64) {\n         return _withBase(_base.with(base64));\n     }\n+\n+    @Override\n+    public DeserializationConfig with(ContextAttributes attrs) {\n+        return (attrs == _attributes) ? this : new DeserializationConfig(this, attrs);\n+    }\n     \n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n     protected transient ObjectBuffer _objectBuffer;\n \n     protected transient DateFormat _dateFormat;\n+\n+    /**\n+     * Lazily-constructed holder for per-call attributes.\n+     * \n+     * @since 2.3\n+     */\n+    protected transient ContextAttributes _attributes;\n     \n     /*\n     /**********************************************************\n         _config = null;\n         _injectableValues = null;\n         _view = null;\n+        _attributes = null;\n     }\n \n     protected DeserializationContext(DeserializationContext src,\n         _view = src._view;\n         _parser = src._parser;\n         _injectableValues = src._injectableValues;\n-    }\n-    \n+        _attributes = src._attributes;\n+    }\n+\n+    /**\n+     * Constructor used for creating actual per-call instances.\n+     */\n     protected DeserializationContext(DeserializationContext src,\n             DeserializationConfig config, JsonParser jp,\n             InjectableValues injectableValues)\n         _view = config.getActiveView();\n         _parser = jp;\n         _injectableValues = injectableValues;\n+        _attributes = config.getAttributes();\n     }\n \n     /*\n     @Override\n     public final TypeFactory getTypeFactory() {\n         return _config.getTypeFactory();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Generic attributes (2.3+)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getAttribute(Object key) {\n+        return _attributes.getAttribute(key);\n+    }\n+\n+    @Override\n+    public DeserializationContext setAttribute(Object key, Object value)\n+    {\n+        _attributes = _attributes.withPerCallAttribute(key, value);\n+        return this;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected SerializationConfig(SerializationConfig src, ContextAttributes attrs)\n+    {\n+        super(src, attrs);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n     \n     /*\n     /**********************************************************\n     public SerializationConfig with(Base64Variant base64) {\n         return _withBase(_base.with(base64));\n     }\n+\n+    @Override\n+    public SerializationConfig with(ContextAttributes attrs) {\n+        return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n+    }\n     \n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n     /*\n     /**********************************************************\n-    /* Helper objects for caching\n+    /* Helper objects for caching, reuse\n     /**********************************************************\n      */\n     \n      * Helper object for keeping track of introspected root names\n      */\n     final protected RootNameLookup _rootNames;\n+    \n+    /**\n+     * Lazily-constructed holder for per-call attributes.\n+     * \n+     * @since 2.3\n+     */\n+    protected transient ContextAttributes _attributes;\n     \n     /*\n     /**********************************************************\n         _rootNames = new RootNameLookup();\n \n         _serializationView = null;\n+        _attributes = null;\n \n         // not relevant for blueprint instance, could set either way:\n         _stdNullValueSerializer = true;\n         _knownSerializers = _serializerCache.getReadOnlyLookupMap();\n \n         _serializationView = config.getActiveView();\n+        _attributes = config.getAttributes();\n     }\n     \n     /*\n      */\n     @Deprecated\n     public final Class<?> getSerializationView() { return _serializationView; }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Generic attributes (2.3+)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object getAttribute(Object key) {\n+        return _attributes.getAttribute(key);\n+    }\n+\n+    @Override\n+    public SerializerProvider setAttribute(Object key, Object value)\n+    {\n+        _attributes = _attributes.withPerCallAttribute(key, value);\n+        return this;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Access to general configuration\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/ContextAttributes.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.util.*;\n+\n+/**\n+ * Helper class used for storing and accessing per-call attributes.\n+ * Storage is two-layered: at higher precedence, we have actual per-call\n+ * attributes; and at lower precedence, default attributes that may be\n+ * defined for Object readers and writers.\n+ *<p>\n+ * Note that the way mutability is implemented differs between kinds\n+ * of attributes, to account for thread-safety: per-call attributes\n+ * are handled assuming that instances are never shared, whereas\n+ * changes to per-reader/per-writer attributes are made assuming\n+ * sharing, by creating new copies instead of modifying state.\n+ * This allows sharing of default values without per-call copying, but\n+ * requires two-level lookup on access.\n+ * \n+ * @since 2.3\n+ */\n+public abstract class ContextAttributes\n+{\n+    public static ContextAttributes getEmpty() {\n+        return Impl.getEmpty();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Per-reader/writer access\n+    /**********************************************************\n+     */\n+\n+    public abstract ContextAttributes withSharedAttribute(Object key, Object value);\n+\n+    public abstract ContextAttributes withSharedAttributes(Map<Object,Object> attributes);\n+    \n+    public abstract ContextAttributes withoutSharedAttribute(Object key);\n+    \n+    /*\n+    /**********************************************************\n+    /* Per-operation (serialize/deserialize) access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for value of specified attribute\n+     */\n+    public abstract Object getAttribute(Object key);\n+\n+    /**\n+     * Mutator used during call (via context) to set value of \"non-shared\"\n+     * part of attribute set.\n+     */\n+    public abstract ContextAttributes withPerCallAttribute(Object key, Object value);\n+\n+    /*\n+    /**********************************************************\n+    /* Default implementation\n+    /**********************************************************\n+     */\n+\n+    public static class Impl extends ContextAttributes\n+        implements java.io.Serializable // just so ObjectReader/ObjectWriter can retain configs\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        protected final static Impl EMPTY = new Impl(Collections.emptyMap());\n+\n+        protected final static Object NULL_SURROGATE = new Object();\n+        \n+        /**\n+         * Shared attributes that we can not modify in-place.\n+         */\n+        protected final Map<Object,Object> _shared;\n+\n+        /**\n+         * Per-call attributes that we can directly modify, since they are not\n+         * shared between threads.\n+         */\n+        protected transient Map<Object,Object> _nonShared;\n+        \n+        /*\n+        /**********************************************************\n+        /* Construction, factory methods\n+        /**********************************************************\n+         */\n+        \n+        protected Impl(Map<Object,Object> shared) {\n+            _shared = shared;\n+            _nonShared = null;\n+        }\n+\n+        protected Impl(Map<Object,Object> shared, Map<Object,Object> nonShared) {\n+            _shared = shared;\n+            _nonShared = nonShared;\n+        }\n+        \n+        public static ContextAttributes getEmpty() {\n+            return EMPTY;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Per-reader/writer mutant factories\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public ContextAttributes withSharedAttribute(Object key, Object value)\n+        {\n+            Map<Object,Object> m;\n+            // need to cover one special case, since EMPTY uses Immutable map:\n+            if (this == EMPTY) {\n+                m = new HashMap<Object,Object>(8);\n+            } else {\n+                m = _copy(_shared);\n+            }\n+            m.put(key, value);\n+            return new Impl(m);\n+        }\n+\n+        @Override\n+        public ContextAttributes withSharedAttributes(Map<Object, Object> shared) {\n+            return new Impl(shared);\n+        }\n+\n+        @Override\n+        public ContextAttributes withoutSharedAttribute(Object key)\n+        {\n+            // first couple of trivial optimizations\n+            if (_shared.isEmpty()) {\n+                return this;\n+            }\n+            if (_shared.containsKey(key)) {\n+                if (_shared.size() == 1) {\n+                    return EMPTY;\n+                }\n+            } else { // if we didn't have it anyway, return as-is\n+                return this;\n+            }\n+            // otherwise make copy, modify\n+            Map<Object,Object> m = _copy(_shared);\n+            m.remove(key);\n+            return new Impl(m);\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Per-call access\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public Object getAttribute(Object key)\n+        {\n+            if (_nonShared != null) {\n+                Object ob = _nonShared.get(key);\n+                if (ob != null) {\n+                    if (ob == NULL_SURROGATE) {\n+                        return null;\n+                    }\n+                    return ob;\n+                }\n+            }\n+            return _shared.get(key);\n+        }\n+        \n+        @Override\n+        public ContextAttributes withPerCallAttribute(Object key, Object value)\n+        {\n+            // First: null value may need masking\n+            if (value == null) {\n+                // need to mask nulls to ensure default values won't be showing\n+                if (_shared.containsKey(key)) {\n+                    value = NULL_SURROGATE;\n+                } else {\n+                    // except if non-mutable shared list has no entry, we don't care\n+                    return this;\n+                }\n+            }\n+\n+            // a special case: create non-shared instance if need be\n+            if (_nonShared == null) {\n+                return nonSharedInstance(key, value);\n+            }\n+            _nonShared.put(key, value);\n+            return this;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Internal methods\n+        /**********************************************************\n+         */\n+\n+        /**\n+         * Overridable method that creates initial non-shared instance,\n+         * with the first explicit set value.\n+         */\n+        protected ContextAttributes nonSharedInstance(Object key, Object value)\n+        {\n+            Map<Object,Object> m = new HashMap<Object,Object>();\n+            if (value == null) {\n+                value = NULL_SURROGATE;\n+            }\n+            m.put(key, value);\n+            return new Impl(_shared, m);\n+        }\n+        \n+        private Map<Object,Object> _copy(Map<Object,Object> src)\n+        {\n+            return new HashMap<Object,Object>(src);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n     public Base64Variant getBase64Variant() {\n         return _base.getBase64Variant();\n     }\n-    \n+\n+    /**\n+     * Method for accessing per-instance shared (baseline/default)\n+     * attribute values; these are used as the basis for per-call\n+     * attributes.\n+     * \n+     * @since 2.3\n+     */\n+    public abstract ContextAttributes getAttributes();\n+\n     /*\n     /**********************************************************\n     /* Methods for instantiating handlers\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n     extends MapperConfig<T>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -8378230381628000111L;\n+    private static final long serialVersionUID = 6062961959359172474L;\n \n     private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperFeature.class);\n \n      * is defined), meaning that all properties are to be included.\n      */\n     protected final Class<?> _view;\n-    \n+\n+    /**\n+     * Contextual attributes accessible (get and set) during processing,\n+     * on per-call basis.\n+     * \n+     * @since 2.3\n+     */\n+    protected final ContextAttributes _attributes;\n+\n     /*\n     /**********************************************************\n     /* Construction\n         _subtypeResolver = str;\n         _rootName = null;\n         _view = null;\n+        // default to \"no attributes\"\n+        _attributes = ContextAttributes.getEmpty();\n     }\n     \n     /**\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base)\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n     \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, int mapperFeatures)\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, SubtypeResolver str) {\n         _subtypeResolver = str;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, String rootName) {\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n     }\n \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, Class<?> view)\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = view;\n+        _attributes = src._attributes;\n     }\n \n     /**\n         _subtypeResolver = src._subtypeResolver;\n         _rootName = src._rootName;\n         _view = src._view;\n+        _attributes = src._attributes;\n+    }\n+\n+    /**\n+     * @since 2.3\n+     */\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, ContextAttributes attr)\n+    {\n+        super(src);\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n+        _view = src._view;\n+        _attributes = attr;\n     }\n     \n     /*\n      * default {@link Base64Variant} to use with base64-encoded binary values.\n      */\n     public abstract T with(Base64Variant base64);\n+\n+    /**\n+     * Method for constructing an instance that has specified\n+     * contextual attributes.\n+     * \n+     * @since 2.3\n+     */\n+    public abstract T with(ContextAttributes attrs);\n+\n+    /**\n+     * Method for constructing an instance that has only specified\n+     * attributes, removing any attributes that exist before the call.\n+     * \n+     * @since 2.3\n+     */\n+    public T withAttributes(Map<Object,Object> attributes) {\n+        return with(getAttributes().withSharedAttributes(attributes));\n+    }\n+    \n+    /**\n+     * Method for constructing an instance that has specified\n+     * value for attribute for given key.\n+     * \n+     * @since 2.3\n+     */\n+    public T withAttribute(Object key, Object value) {\n+        return with(getAttributes().withSharedAttribute(key, value));\n+    }\n+\n+    /**\n+     * Method for constructing an instance that has no\n+     * value for attribute for given key.\n+     * \n+     * @since 2.3\n+     */\n+    public T withoutAttribute(Object key) {\n+        return with(getAttributes().withoutSharedAttribute(key));\n+    }\n     \n     /*\n     /**********************************************************\n     public final Class<?> getActiveView() {\n         return _view;\n     }\n+\n+    @Override\n+    public final ContextAttributes getAttributes() {\n+        return _attributes;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n         public int getY() { return y; }\n         public void setY(int y) { this.y = y; }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Tests for individual objects", "timestamp": 1381122332, "metainfo": ""}