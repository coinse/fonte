{"sha": "76793f149d8ac935247eab3b1297536429d58ad1", "log": "Trying to refactor things to make it possible to filter non-Bean types (maps; any setters)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n  * synchronization issues.\n  */\n public class BeanPropertyWriter\n+    extends PropertyWriter\n     implements BeanProperty\n {\n     /**\n     /* BeanProperty impl\n     /**********************************************************\n      */\n-    \n+\n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public String getName() {\n         return _name.getValue();\n     }\n \n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public PropertyName getFullName() {\n         // !!! TODO: impl properly\n         return _member;\n     }\n \n+    // @since 2.3 -- needed so it can be overridden by unwrapping writer\n+    protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode)\n+    {\n+        propertiesNode.put(getName(), schemaNode);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Managing and accessing of opaque internal settings\n+    /* (used by extensions)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing value of specified internal setting.\n+     * \n+     * @return Value of the setting, if any; null if none.\n+     */\n+    public Object getInternalSetting(Object key)\n+    {\n+        if (_internalSettings == null) {\n+            return null;\n+        }\n+        return _internalSettings.get(key);\n+    }\n+    \n+    /**\n+     * Method for setting specific internal setting to given value\n+     * \n+     * @return Old value of the setting, if any (null if none)\n+     */\n+    public Object setInternalSetting(Object key, Object value)\n+    {\n+        if (_internalSettings == null) {\n+            _internalSettings = new HashMap<Object,Object>();\n+        }\n+        return _internalSettings.put(key, value);\n+    }\n+\n+    /**\n+     * Method for removing entry for specified internal setting.\n+     * \n+     * @return Existing value of the setting, if any (null if none)\n+     */\n+    public Object removeInternalSetting(Object key)\n+    {\n+        Object removed = null;\n+        if (_internalSettings != null) {\n+            removed = _internalSettings.remove(key);\n+            // to reduce memory usage, let's also drop the Map itself, if empty\n+            if (_internalSettings.size() == 0) {\n+                _internalSettings = null;\n+            }\n+        }\n+        return removed;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    public SerializedString getSerializedName() { return _name; }\n+    \n+    public boolean hasSerializer() { return _serializer != null; }\n+    public boolean hasNullSerializer() { return _nullSerializer != null; }\n+\n+    /**\n+     * Accessor that will return true if this bean property has to support\n+     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n+     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n+     *<p>\n+     * Default implementation simply returns false.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean isUnwrapping() {\n+        return false;\n+    }\n+    \n+    public boolean willSuppressNulls() { return _suppressNulls; }\n+    \n+    // Needed by BeanSerializer#getSchema\n+    public JsonSerializer<Object> getSerializer() {\n+        return _serializer;\n+    }\n+\n+    public JavaType getSerializationType() {\n+        return _cfgSerializationType;\n+    }\n+\n+    public Class<?> getRawSerializationType() {\n+        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n+    }\n+    \n+    public Class<?> getPropertyType() \n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.getReturnType();\n+        }\n+        return _field.getType();\n+    }\n+\n+    /**\n+     * Get the generic property type of this property writer.\n+     *\n+     * @return The property type, or null if not found.\n+     */\n+    public Type getGenericPropertyType()\n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.getGenericReturnType();\n+        }\n+        return _field.getGenericType();\n+    }\n+\n+    public Class<?>[] getViews() { return _includeInViews; }\n+\n+    /**\n+     *<p>\n+     * NOTE: due to introspection, this is a <b>slow</b> method to call\n+     * and should never be called during actual serialization or filtering\n+     * of the property. Rather it is needed for traversal needed for things\n+     * like constructing JSON Schema instances.\n+     * \n+     * @since 2.1\n+     * \n+     * @deprecated since 2.2, use {@link #isRequired()} instead.\n+     */\n+    @Deprecated\n+    protected boolean isRequired(AnnotationIntrospector intr) {\n+        return _metadata.isRequired();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* PropertyWriter methods (serialization)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to access property that this bean stands for, from\n+     * within given bean, and to serialize it as a JSON Object field\n+     * using appropriate serializer.\n+     */\n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        // Null handling is bit different, check that first\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                jgen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, jgen, prov);\n+            }\n+            return;\n+        }\n+        // then find serializer to use\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        // and then see if we must suppress certain values (default, empty)\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        // For non-nulls: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n+        }\n+        jgen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    /**\n+     * Method called to indicate that serialization of a field was omitted\n+     * due to filtering, in cases where backend data format does not allow\n+     * basic omission.\n+     * \n+     * @since 2.3\n+     */\n+    @Override\n+    public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        if (!jgen.canOmitFields()) {\n+            jgen.writeOmittedField(_name.getValue());\n+        }\n+    }\n+    \n+    /**\n+     * Alternative to {@link #serializeAsField} that is used when a POJO\n+     * is serialized as JSON Array; the difference is that no field names\n+     * are written.\n+     * \n+     * @since 2.1\n+     */\n+    @Override\n+    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        if (value == null) { // nulls need specialized handling\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, jgen, prov);\n+            } else { // can NOT suppress entries in tabular output\n+                jgen.writeNull();\n+            }\n+            return;\n+        }\n+        // otherwise find serializer to use\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        // and then see if we must suppress certain values (default, empty)\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n+                    serializeAsPlaceholder(bean, jgen, prov);\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n+                serializeAsPlaceholder(bean, jgen, prov);\n+                return;\n+            }\n+        }\n+        // For non-nulls: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    /**\n+     * Method called to serialize a placeholder used in tabular output when\n+     * real value is not to be included (is filtered out), but when we need\n+     * an entry so that field indexes will not be off. Typically this should\n+     * output null or empty String, depending on datatype.\n+     * \n+     * @since 2.1\n+     */\n+    @Override\n+    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        if (_nullSerializer != null) {\n+            _nullSerializer.serialize(null, jgen, prov);\n+        } else {\n+            jgen.writeNull();\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* PropertyWriter methods (schema generation)\n+    /**********************************************************\n+     */\n+\n+    // Also part of BeanProperty implementation\n     @Override\n     public void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n         throws JsonMappingException\n         }\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Legacy support for JsonFormatVisitable\n-    /**********************************************************\n-     */\n+    // // // Legacy support for JsonFormatVisitable\n \n     /**\n      * Attempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n      * @param propertiesNode Node which the given property would exist within\n      * @param provider Provider that can be used for accessing dynamic aspects of serialization\n      *  processing\n-     *  \n-     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n      * \n      * @since 2.1\n      */\n     @SuppressWarnings(\"deprecation\")\n+    @Override\n     public void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n         throws JsonMappingException\n     {\n         }\n         _depositSchemaProperty(propertiesNode, schemaNode);\n     }\n-\n-    // @since 2.3 -- needed so it can be overridden by unwrapping writer\n-    protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode)\n-    {\n-        propertiesNode.put(getName(), schemaNode);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Managing and accessing of opaque internal settings\n-    /* (used by extensions)\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Method for accessing value of specified internal setting.\n-     * \n-     * @return Value of the setting, if any; null if none.\n-     */\n-    public Object getInternalSetting(Object key)\n-    {\n-        if (_internalSettings == null) {\n-            return null;\n-        }\n-        return _internalSettings.get(key);\n-    }\n-    \n-    /**\n-     * Method for setting specific internal setting to given value\n-     * \n-     * @return Old value of the setting, if any (null if none)\n-     */\n-    public Object setInternalSetting(Object key, Object value)\n-    {\n-        if (_internalSettings == null) {\n-            _internalSettings = new HashMap<Object,Object>();\n-        }\n-        return _internalSettings.put(key, value);\n-    }\n-\n-    /**\n-     * Method for removing entry for specified internal setting.\n-     * \n-     * @return Existing value of the setting, if any (null if none)\n-     */\n-    public Object removeInternalSetting(Object key)\n-    {\n-        Object removed = null;\n-        if (_internalSettings != null) {\n-            removed = _internalSettings.remove(key);\n-            // to reduce memory usage, let's also drop the Map itself, if empty\n-            if (_internalSettings.size() == 0) {\n-                _internalSettings = null;\n-            }\n-        }\n-        return removed;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Accessors\n-    /**********************************************************\n-     */\n-\n-    public SerializedString getSerializedName() { return _name; }\n-    \n-    public boolean hasSerializer() { return _serializer != null; }\n-    public boolean hasNullSerializer() { return _nullSerializer != null; }\n-\n-    /**\n-     * Accessor that will return true if this bean property has to support\n-     * \"unwrapping\"; ability to replace POJO structural wrapping with optional\n-     * name prefix and/or suffix (or in some cases, just removal of wrapper name).\n-     *<p>\n-     * Default implementation simply returns false.\n-     * \n-     * @since 2.3\n-     */\n-    public boolean isUnwrapping() {\n-        return false;\n-    }\n-    \n-    public boolean willSuppressNulls() { return _suppressNulls; }\n-    \n-    // Needed by BeanSerializer#getSchema\n-    public JsonSerializer<Object> getSerializer() {\n-        return _serializer;\n-    }\n-\n-    public JavaType getSerializationType() {\n-        return _cfgSerializationType;\n-    }\n-\n-    public Class<?> getRawSerializationType() {\n-        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n-    }\n-    \n-    public Class<?> getPropertyType() \n-    {\n-        if (_accessorMethod != null) {\n-            return _accessorMethod.getReturnType();\n-        }\n-        return _field.getType();\n-    }\n-\n-    /**\n-     * Get the generic property type of this property writer.\n-     *\n-     * @return The property type, or null if not found.\n-     */\n-    public Type getGenericPropertyType()\n-    {\n-        if (_accessorMethod != null) {\n-            return _accessorMethod.getGenericReturnType();\n-        }\n-        return _field.getGenericType();\n-    }\n-\n-    public Class<?>[] getViews() { return _includeInViews; }\n-\n-    /**\n-     *<p>\n-     * NOTE: due to introspection, this is a <b>slow</b> method to call\n-     * and should never be called during actual serialization or filtering\n-     * of the property. Rather it is needed for traversal needed for things\n-     * like constructing JSON Schema instances.\n-     * \n-     * @since 2.1\n-     * \n-     * @deprecated since 2.2, use {@link #isRequired()} instead.\n-     */\n-    @Deprecated\n-    protected boolean isRequired(AnnotationIntrospector intr) {\n-        return _metadata.isRequired();\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Serialization functionality\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method called to access property that this bean stands for, from\n-     * within given bean, and to serialize it as a JSON Object field\n-     * using appropriate serializer.\n-     */\n-    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n-        throws Exception\n-    {\n-        Object value = get(bean);\n-        // Null handling is bit different, check that first\n-        if (value == null) {\n-            if (_nullSerializer != null) {\n-                jgen.writeFieldName(_name);\n-                _nullSerializer.serialize(null, jgen, prov);\n-            }\n-            return;\n-        }\n-        // then find serializer to use\n-        JsonSerializer<Object> ser = _serializer;\n-        if (ser == null) {\n-            Class<?> cls = value.getClass();\n-            PropertySerializerMap map = _dynamicSerializers;\n-            ser = map.serializerFor(cls);\n-            if (ser == null) {\n-                ser = _findAndAddDynamic(map, cls, prov);\n-            }\n-        }\n-        // and then see if we must suppress certain values (default, empty)\n-        if (_suppressableValue != null) {\n-            if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n-                    return;\n-                }\n-            } else if (_suppressableValue.equals(value)) {\n-                return;\n-            }\n-        }\n-        // For non-nulls: simple check for direct cycles\n-        if (value == bean) {\n-            _handleSelfReference(bean, ser);\n-        }\n-        jgen.writeFieldName(_name);\n-        if (_typeSerializer == null) {\n-            ser.serialize(value, jgen, prov);\n-        } else {\n-            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n-        }\n-    }\n-\n-    /**\n-     * Method called to indicate that serialization of a field was omitted\n-     * due to filtering, in cases where backend data format does not allow\n-     * basic omission.\n-     * \n-     * @since 2.3\n-     */\n-    public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n-        throws Exception\n-    {\n-        if (!jgen.canOmitFields()) {\n-            jgen.writeOmittedField(_name.getValue());\n-        }\n-    }\n-    \n-    /**\n-     * Alternative to {@link #serializeAsField} that is used when a POJO\n-     * is serialized as JSON Array; the difference is that no field names\n-     * are written.\n-     * \n-     * @since 2.1\n-     */\n-    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n-        throws Exception\n-    {\n-        Object value = get(bean);\n-        if (value == null) { // nulls need specialized handling\n-            if (_nullSerializer != null) {\n-                _nullSerializer.serialize(null, jgen, prov);\n-            } else { // can NOT suppress entries in tabular output\n-                jgen.writeNull();\n-            }\n-            return;\n-        }\n-        // otherwise find serializer to use\n-        JsonSerializer<Object> ser = _serializer;\n-        if (ser == null) {\n-            Class<?> cls = value.getClass();\n-            PropertySerializerMap map = _dynamicSerializers;\n-            ser = map.serializerFor(cls);\n-            if (ser == null) {\n-                ser = _findAndAddDynamic(map, cls, prov);\n-            }\n-        }\n-        // and then see if we must suppress certain values (default, empty)\n-        if (_suppressableValue != null) {\n-            if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n-                    serializeAsPlaceholder(bean, jgen, prov);\n-                    return;\n-                }\n-            } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n-                serializeAsPlaceholder(bean, jgen, prov);\n-                return;\n-            }\n-        }\n-        // For non-nulls: simple check for direct cycles\n-        if (value == bean) {\n-            _handleSelfReference(bean, ser);\n-        }\n-        if (_typeSerializer == null) {\n-            ser.serialize(value, jgen, prov);\n-        } else {\n-            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n-        }\n-    }\n-\n-    /**\n-     * Method called to serialize a placeholder used in tabular output when\n-     * real value is not to be included (is filtered out), but when we need\n-     * an entry so that field indexes will not be off. Typically this should\n-     * output null or empty String, depending on datatype.\n-     * \n-     * @since 2.1\n-     */\n-    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n-        throws Exception\n-    {\n-        if (_nullSerializer != null) {\n-            _nullSerializer.serialize(null, jgen, prov);\n-        } else {\n-            jgen.writeNull();\n-        }\n-    }\n     \n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Base class for writers used to output property values (name-value pairs)\n+ * as key/value pairs via streaming API. This is the most generic abstraction\n+ * implemented by both POJO and {@link java.util.Map} serializers, and invoked\n+ * by filtering functionality.\n+ * \n+ * @since 2.3\n+ */\n+public abstract class PropertyWriter\n+{\n+    /*\n+    /**********************************************************\n+    /* Metadata access\n+    /**********************************************************\n+     */\n+\n+    public abstract String getName();\n+\n+    public abstract PropertyName getFullName();\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization methods, regular output\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * The main serialization method called by filter when property is to be written normally.\n+     */\n+    public abstract void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception;\n+\n+    /**\n+     * Serialization method that filter needs to call in cases where property is to be\n+     * filtered, but the underlying data format requires a placeholder of some kind.\n+     * This is usually the case for tabular (positional) data formats such as CSV.\n+     */\n+    public abstract void serializeAsOmittedField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception;\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization methods, explicit positional/tabular formats\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Serialization method called when output is to be done in tabular format, omitting\n+     * property names. Note that this mode of operation is independent of underlying\n+     * data format; so it is typically NOT called for fully tabular formats such as CSV.\n+     */\n+    public abstract void serializeAsColumn(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception;\n+\n+    /**\n+     * Serialization method called when doing tabular (positional) output from databind,\n+     * but then value is to be omitted. This requires output of a placeholder value\n+     * of some sort; often similar to {@link #serializeAsOmittedField}.\n+     */\n+    public abstract void serializeAsPlaceholder(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception;\n+\n+    /*\n+    /**********************************************************\n+    /* Schema-related\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Traversal method used for things like JSON Schema generation, or\n+     * POJO introspection.\n+     */\n+    public abstract void depositSchemaProperty(JsonObjectFormatVisitor objectVisitor)\n+        throws JsonMappingException;\n+\n+\n+    /**\n+     * Legacy method called for JSON Schema generation; should not be called by new code\n+     * \n+     * @deprecated Since 2.2\n+     */\n+    @Deprecated\n+    public abstract void depositSchemaProperty(ObjectNode propertiesNode, SerializerProvider provider)\n+        throws JsonMappingException;\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n     /* Field serialization methods\n     /**********************************************************\n      */\n+\n     private boolean hasSingleElement(SerializerProvider provider) {\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n-import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n-import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.*;\n \n /**\n  * Simple {@link BeanPropertyFilter} implementation that only uses property name\n             writer.depositSchemaProperty(objectVisitor);\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Sub-classes", "timestamp": 1381898176, "metainfo": ""}