{"sha": "ee3c526bcd0080f17b57796c1272d9ee767e6072", "log": "complete test to verify that Jackson can do Externalizable", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestExternalizable.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestExternalizable.java\n      * Helper class we need to adapt {@link ObjectOutput} as\n      * {@link OutputStream}\n      */\n+    final static class ExternalizableInput extends InputStream\n+    {\n+        private final ObjectInput in;\n+\n+        public ExternalizableInput(ObjectInput in) {\n+            this.in = in;\n+        }\n+\n+        @Override\n+        public int available() throws IOException {\n+            return in.available();\n+        }\n+        \n+        @Override\n+        public void close() throws IOException {\n+            in.close();\n+        }\n+        \n+        @Override\n+        public boolean  markSupported() {\n+            return false;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            return in.read();\n+        }\n+\n+        @Override\n+        public int read(byte[] buffer) throws IOException {\n+            return in.read(buffer);\n+        }\n+\n+        @Override\n+        public int read(byte[] buffer, int offset, int len) throws IOException {\n+            return in.read(buffer, offset, len);\n+        }\n+        \n+        @Override\n+        public long skip(long n) throws IOException {\n+            return in.skip(n);\n+        }\n+    }        \n+\n+    /**\n+     * Helper class we need to adapt {@link ObjectOutput} as\n+     * {@link OutputStream}\n+     */\n     final static class ExternalizableOutput extends OutputStream\n     {\n         private final ObjectOutput out;\n         }\n     }\n     \n+//    @com.fasterxml.jackson.annotation.JsonFormat(shape=com.fasterxml.jackson.annotation.JsonFormat.Shape.ARRAY)\n     static class MyPojo implements Externalizable\n     {\n         public int id;\n         public String name;\n         public int[] values;\n \n-        protected MyPojo() { } // for deserialization\n+        public MyPojo() { } // for deserialization\n         public MyPojo(int id, String name, int[] values)\n         {\n             this.id = id;\n \n         public void readExternal(ObjectInput in) throws IOException\n         {\n+//            MapperHolder.mapper().readValue(\n+            MapperHolder.mapper().readerForUpdating(this).readValue(new ExternalizableInput(in));\n+        }\n+\n+        public void writeExternal(ObjectOutput oo) throws IOException\n+        {\n+            MapperHolder.mapper().writeValue(new ExternalizableOutput(oo), this);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null) return false;\n+            if (o.getClass() != getClass()) return false;\n             \n-        }\n-\n-        public void writeExternal(ObjectOutput oo) throws IOException\n-        {\n-            MapperHolder.mapper().writeValue(new ExternalizableOutput(oo), this);\n+            MyPojo other = (MyPojo) o;\n+            \n+            if (other.id != id) return false;\n+            if (!other.name.equals(name)) return false;\n+            \n+            if (other.values.length != values.length) return false;\n+            for (int i = 0, end = values.length; i < end; ++i) {\n+                if (values[i] != other.values[i]) return false;\n+            }\n+            return true;\n         }\n     }\n \n     /* Actual tests\n     /**********************************************************\n      */\n+\n+    // Comparison, using JDK native\n+    static class MyPojoNative implements Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public int id;\n+        public String name;\n+        public int[] values;\n+\n+        public MyPojoNative(int id, String name, int[] values)\n+        {\n+            this.id = id;\n+            this.name = name;\n+            this.values = values;\n+        }\n+    }\n     \n+    @SuppressWarnings(\"unused\")\n     public void testSerializeAsExternalizable() throws Exception\n     {\n         ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n         final MyPojo input = new MyPojo(13, \"Foobar\", new int[] { 1, 2, 3 } );\n         obs.writeObject(input);\n         obs.close();\n-        byte[] b = bytes.toByteArray();\n-\n-        // Ok: just verify it contains stuff \n+        byte[] ser = bytes.toByteArray();\n+\n+        // Ok: just verify it contains stuff it should\n         byte[] json = MapperHolder.mapper().writeValueAsBytes(input);\n-        \n-        System.out.println(\"Length: \"+b.length+\" vs \"+json.length);\n-        System.out.println();\n-        System.out.println(\"Raw: [\"+bytes.toString(\"ISO-8859-1\")+\"]\");\n+\n+        int ix = indexOf(ser, json);\n+        if (ix < 0) {\n+            fail(\"Serialization (\"+ser.length+\") does NOT contain JSON (of \"+json.length+\")\");\n+        }\n+        \n+        // Sanity check:\n+        if (false) {\n+            bytes = new ByteArrayOutputStream();\n+            obs = new ObjectOutputStream(bytes);\n+            MyPojoNative p = new MyPojoNative(13, \"Foobar\", new int[] { 1, 2, 3 } );\n+            obs.writeObject(p);\n+            obs.close();\n+            System.out.println(\"Native size: \"+bytes.size()+\", vs JSON: \"+ser.length);\n+        }\n+        \n+        // then read back!\n+        ObjectInputStream ins = new ObjectInputStream(new ByteArrayInputStream(ser));\n+        MyPojo output = (MyPojo) ins.readObject();\n+        assertNotNull(output);\n+        \n+        assertEquals(input, output);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private int indexOf(byte[] full, byte[] fragment)\n+    {\n+        final byte first = fragment[0];\n+        for (int i = 0, end = full.length-fragment.length; i < end; ++i) {\n+            if (full[i] != first) continue;\n+            if (matches(full, i, fragment)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    private boolean matches(byte[] full, int index, byte[] fragment)\n+    {\n+        for (int i = 1, end = fragment.length; i < end; ++i) {\n+            if (fragment[i] != full[index+i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n }", "timestamp": 1345252771, "metainfo": ""}