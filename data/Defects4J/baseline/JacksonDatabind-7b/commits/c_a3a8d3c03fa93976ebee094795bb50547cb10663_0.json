{"sha": "a3a8d3c03fa93976ebee094795bb50547cb10663", "log": "Fix issue #292", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     protected final ObjectIdReader _objectIdReader;\n \n     protected final Map<String, SettableBeanProperty> _backRefProperties;\n-    \n+\n     // support for \"native\" types, which require special care:\n     \n     protected final boolean _acceptString;\n         _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);\n     }\n \n+    protected AbstractDeserializer(BeanDescription beanDesc)\n+    {\n+        _baseType = beanDesc.getType();\n+        _objectIdReader = null;\n+        _backRefProperties = null;\n+        Class<?> cls = _baseType.getRawClass();\n+        _acceptString = cls.isAssignableFrom(String.class);\n+        _acceptBoolean = (cls == Boolean.TYPE) || cls.isAssignableFrom(Boolean.class);\n+        _acceptInt = (cls == Integer.TYPE) || cls.isAssignableFrom(Integer.class);\n+        _acceptDouble = (cls == Double.TYPE) || cls.isAssignableFrom(Double.class);\n+    }\n+    \n+    /**\n+     * Factory method used when constructing instances for non-POJO types, like\n+     * {@link java.util.Map}s.\n+     * \n+     * @since 2.3\n+     */\n+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)\n+    {\n+        return new AbstractDeserializer(beanDesc);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public accessors\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             if (type.isInterface() || type.isAbstract()) {\n                 CollectionType implType = _mapAbstractCollectionType(type, config);\n                 if (implType == null) {\n-                    throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n-                }\n-                type = implType;\n-                // But if so, also need to re-check creators...\n-                beanDesc = config.introspectForCreation(type);\n-            }\n-            ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n-            if (!inst.canCreateUsingDefault()) {\n-                // [Issue#161]: No default constructor for ArrayBlockingQueue...\n-                if (type.getRawClass() == ArrayBlockingQueue.class) {\n-                    return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n-                }\n-            }\n-            // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n-            if (contentType.getRawClass() == String.class) {\n-                // no value type deserializer because Strings are one of natural/native types:\n-                deser = new StringCollectionDeserializer(type, contentDeser, inst);\n-            } else {\n-                deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n+                    // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n+                    if (type.getTypeHandler() == null) {\n+                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n+                    }\n+                    deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n+                } else {\n+                    type = implType;\n+                    // But if so, also need to re-check creators...\n+                    beanDesc = config.introspectForCreation(type);\n+                }\n+            }\n+            if (deser == null) {\n+                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n+                if (!inst.canCreateUsingDefault()) {\n+                    // [Issue#161]: No default constructor for ArrayBlockingQueue...\n+                    if (type.getRawClass() == ArrayBlockingQueue.class) {\n+                        return new ArrayBlockingQueueDeserializer(type, contentDeser, contentTypeDeser, inst, null);\n+                    }\n+                }\n+                // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n+                if (contentType.getRawClass() == String.class) {\n+                    // no value type deserializer because Strings are one of natural/native types:\n+                    deser = new StringCollectionDeserializer(type, contentDeser, inst);\n+                } else {\n+                    deser = new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n+                }\n             }\n         }\n         // and then new with 2.2: ability to post-process it too (Issue#120)\n         if (contentTypeDeser == null) {\n             contentTypeDeser = findTypeDeserializer(config, contentType);\n         }\n-\n+        \n         // 23-Nov-2010, tatu: Custom deserializer?\n         JsonDeserializer<?> deser = _findCustomMapDeserializer(type, config, beanDesc,\n                 keyDes, contentTypeDeser, contentDeser);\n                 if (type.isInterface() || type.isAbstract()) {\n                     @SuppressWarnings(\"rawtypes\")\n                     Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n-                    if (fallback == null) {\n-                        throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n+                    if (fallback != null) {\n+                        mapClass = fallback;\n+                        type = (MapType) config.constructSpecializedType(type, mapClass);\n+                        // But if so, also need to re-check creators...\n+                        beanDesc = config.introspectForCreation(type);\n+                    } else {\n+                        // [Issue#292]: Actually, may be fine, but only if polymorphich deser enabled\n+                        if (type.getTypeHandler() == null) {\n+                            throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n+                        }\n+                        deser = AbstractDeserializer.constructForNonPOJO(beanDesc);\n                     }\n-                    mapClass = fallback;\n-                    type = (MapType) config.constructSpecializedType(type, mapClass);\n-                    // But if so, also need to re-check creators...\n-                    beanDesc = config.introspectForCreation(type);\n-                }\n-                ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n-                MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n-                md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n-                deser = md;\n+                }\n+                if (deser == null) {\n+                    ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n+                    MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n+                    md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n+                    deser = md;\n+                }\n             }\n         }\n         // and then new with 2.2: ability to post-process it too (Issue#120)\n             // probably only occurs if 'property' is null anyway\n             valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), type);\n         }\n-    \tif (valueTypeDeser != null) {\n+        if (valueTypeDeser != null) {\n             type = type.withTypeHandler(valueTypeDeser);\n-    \t}\n-    \treturn type;\n+        }\n+        return type;\n     }\n     \n     protected EnumResolver<?> constructEnumResolver(Class<?> enumClass,\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * For [Issue#292]\n+ */\n+@SuppressWarnings(\"serial\")\n+public class TestAbstractContainers extends BaseMapTest\n+{\n+    // Polymorphic abstract Map type, wrapper\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = MapWrapper.class, name = \"wrapper\"),\n+    })\n+    static class MapWrapper {\n+        public  IDataValueMap map = new DataValueMap();     // This does NOT work\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"_type_\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = DataValueMap.class,  name = \"DataValueMap\")\n+    })\n+    public interface IDataValueMap extends Map<String, String> { }\n+\n+    static class DataValueMap extends HashMap<String, String> implements IDataValueMap { }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = ListWrapper.class, name = \"wrapper\"),\n+    })\n+    static class ListWrapper {\n+        public IDataValueList list = new DataValueList();     // This does NOT work\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ \n+        @JsonSubTypes.Type(value = DataValueList.class,  name = \"list\")\n+    })\n+    public interface IDataValueList extends List<String> { }\n+\n+    static class DataValueList extends LinkedList<String> implements IDataValueList { }\n+   \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testAbstractLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ListWrapper w = new ListWrapper();\n+        w.list.add(\"x\");\n+\n+        String json = mapper.writeValueAsString(w);\n+        Object o = mapper.readValue(json, ListWrapper.class);\n+        assertEquals(ListWrapper.class, o.getClass());\n+        ListWrapper out = (ListWrapper) o;\n+        assertEquals(1, out.list.size());\n+        assertEquals(\"x\", out.list.get(0));\n+   }\n+    \n+    public void testAbstractMaps() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MapWrapper w = new MapWrapper();\n+        w.map.put(\"key1\", \"name1\");\n+\n+        String json = mapper.writeValueAsString(w);\n+        Object o = mapper.readValue(json, MapWrapper.class);\n+        assertEquals(MapWrapper.class, o.getClass());\n+        MapWrapper out = (MapWrapper) o;\n+        assertEquals(1, out.map.size());\n+   }\n+}", "timestamp": 1377564364, "metainfo": ""}