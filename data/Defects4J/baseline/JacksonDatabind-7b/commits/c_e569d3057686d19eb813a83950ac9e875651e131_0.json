{"sha": "e569d3057686d19eb813a83950ac9e875651e131", "log": "Convert MapDeserializer to be ContextualDeserializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             beanDesc = config.introspectForCreation(type);\n         }\n         ValueInstantiator inst = findValueInstantiator(ctxt, beanDesc);\n-        MapDeserializer md = new MapDeserializer(type, property, inst, keyDes, contentDeser, contentTypeDeser);\n+        MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n         md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n         return md;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n-import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n-import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\n import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n @JacksonStdImpl\n public class MapDeserializer\n     extends ContainerDeserializerBase<Map<Object,Object>>\n-    implements ResolvableDeserializer\n+    implements ContextualDeserializer, ResolvableDeserializer\n {\n     // // Configuration: typing, deserializers\n \n     protected final JavaType _mapType;\n-\n-    protected final BeanProperty _property;\n     \n     /**\n      * Key deserializer to use; either passed via constructor\n      * (when indicated by annotations), or resolved when\n      * {@link #resolve} is called;\n      */\n-    protected KeyDeserializer _keyDeserializer;\n+    protected final KeyDeserializer _keyDeserializer;\n \n     /**\n      * Flag set to indicate that the key type is\n     /**\n      * Value deserializer.\n      */\n-    protected JsonDeserializer<Object> _valueDeserializer;\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n \n     /**\n      * If value instances have polymorphic type information, this\n     protected final ValueInstantiator _valueInstantiator;\n \n     protected final boolean _hasDefaultCreator;\n+\n+    /**\n+     * Deserializer that is used iff delegate-based creator is\n+     * to be used for deserializing from JSON Object.\n+     */\n+    protected JsonDeserializer<Object> _delegateDeserializer;\n     \n     /**\n      * If the Map is to be instantiated using non-default constructor\n      */\n     protected PropertyBasedCreator _propertyBasedCreator;    \n     \n-    /**\n-     * Deserializer that is used iff delegate-based creator is\n-     * to be used for deserializing from JSON Object.\n-     */\n-    protected JsonDeserializer<Object> _delegateDeserializer;\n-    \n     // // Any properties to ignore if seen?\n     \n     protected HashSet<String> _ignorableProperties;\n     /**********************************************************\n      */\n \n-    public MapDeserializer(JavaType mapType, BeanProperty prop,\n-            ValueInstantiator valueInstantiator,\n+    public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator,\n             KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n             TypeDeserializer valueTypeDeser)\n     {\n         super(Map.class);\n         _mapType = mapType;\n-        _property = prop;\n         _keyDeserializer = keyDeser;\n         _valueDeserializer = valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n         _valueInstantiator = valueInstantiator;\n         _hasDefaultCreator = valueInstantiator.canCreateUsingDefault();\n+        _delegateDeserializer = null;\n+        _propertyBasedCreator = null;\n+        _standardStringKey = _isStdKeyDeser(mapType, keyDeser);\n     }\n \n     /**\n     {\n         super(src._valueClass);\n         _mapType = src._mapType;\n-        _property = src._property;\n         _keyDeserializer = src._keyDeserializer;\n         _valueDeserializer = src._valueDeserializer;\n         _valueTypeDeserializer = src._valueTypeDeserializer;\n         _hasDefaultCreator = src._hasDefaultCreator;\n         // should we make a copy here?\n         _ignorableProperties = src._ignorableProperties;\n-    }\n-\n+\n+        _standardStringKey = src._standardStringKey;\n+    }\n+\n+    protected MapDeserializer(MapDeserializer src,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser)\n+    {\n+        super(src._valueClass);\n+        _mapType = src._mapType;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+        _valueInstantiator = src._valueInstantiator;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _hasDefaultCreator = src._hasDefaultCreator;\n+        // should we make a copy here?\n+        _ignorableProperties = src._ignorableProperties;\n+\n+        _standardStringKey = _isStdKeyDeser(_mapType, keyDeser);\n+    }\n+\n+    /**\n+     * Fluent factory method used to create a copy with slightly\n+     * different settings. When sub-classing, MUST be overridden.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapDeserializer withResolved(//JsonDeserializer<Object> delegateDeser, PropertyBasedCreator propBasedCreator,\n+            KeyDeserializer keyDeser, JsonDeserializer<?> valueDeser)\n+    {\n+        return new MapDeserializer(this, // delegateDeser, propBasedCreator,\n+                keyDeser, (JsonDeserializer<Object>) valueDeser);\n+    }\n+    \n+    /**\n+     * Helper method used to check whether we can just use the default key\n+     * deserialization, where JSON String becomes Java String.\n+     */\n+    protected final boolean _isStdKeyDeser(JavaType mapType, KeyDeserializer keyDeser)\n+    {\n+        if (keyDeser == null) {\n+            return true;\n+        }\n+        JavaType keyType = mapType.getKeyType();\n+        if (keyType == null) { // assumed to be Object\n+            return true;\n+        }\n+        Class<?> rawKeyType = keyType.getRawClass();\n+        return ((rawKeyType == String.class || rawKeyType == Object.class)\n+                && isDefaultKeyDeserializer(keyDeser));\n+    }\n+    \n     public void setIgnorableProperties(String[] ignorable)\n     {\n         _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n     /**********************************************************\n      */\n \n-    /**\n-     * Method called to finalize setup of this deserializer,\n-     * after deserializer itself has been registered. This\n-     * is needed to handle recursive and transitive dependencies.\n-     */\n-    @Override\n-    public void resolve(DeserializationContext ctxt)\n-        throws JsonMappingException\n+\n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         // May need to resolve types for delegate- and/or property-based creators:\n         if (_valueInstantiator.canCreateUsingDelegate()) {\n                         +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n                         +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n             }\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n-            // Need to create a temporary property to allow contextual deserializers:\n-            // Note: unlike BeanDeserializer, we don't have an AnnotatedClass around; hence no annotations passed\n-            BeanProperty.Std property = new BeanProperty.Std(null,\n-                    delegateType, null, delegateCreator);\n-            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n+            /* Theoretically should be able to get CreatorProperty for delegate\n+             * parameter to pass; but things get tricky because DelegateCreator\n+             * may contain injectable values. So, for now, let's pass nothing.\n+             */\n+            _delegateDeserializer = findDeserializer(ctxt, delegateType, null);\n         }\n         if (_valueInstantiator.canCreateFromObjectWith()) {\n             SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n                 }\n             }\n         }\n-        if (_keyDeserializer == null) {\n-            _keyDeserializer = ctxt.findKeyDeserializer(_mapType.getKeyType(), _property);\n-        }\n-        Class<?> raw = _mapType.getKeyType().getRawClass();\n-        _standardStringKey =  (raw == String.class || raw == Object.class)\n-            && isDefaultKeyDeserializer(_keyDeserializer);\n-        if (_valueDeserializer == null) {\n-            _valueDeserializer = ctxt.findValueDeserializer(_mapType.getContentType(), _property);\n-        }\n+        _standardStringKey = _isStdKeyDeser(_mapType, _keyDeserializer);\n+    }\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * when it is known for which property deserializer is needed for.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        KeyDeserializer kd = _keyDeserializer;\n+        if (kd == null) {\n+            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n+        }\n+        JsonDeserializer<Object> vd = _valueDeserializer;\n+        if (vd == null) {\n+            vd = ctxt.findValueDeserializer(_mapType.getContentType(), property);\n+        }\n+        return withResolved(kd, vd);\n     }\n     \n     /*\n         }\n         throw JsonMappingException.wrapWithPath(t, ref, null);\n     }\n-\n }", "timestamp": 1327970368, "metainfo": ""}