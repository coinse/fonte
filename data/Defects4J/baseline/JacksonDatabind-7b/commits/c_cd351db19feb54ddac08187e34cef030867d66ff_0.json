{"sha": "cd351db19feb54ddac08187e34cef030867d66ff", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n         _reportUnsupportedOperation();\n     }\n \n-    @Override\n     public void writeRaw(SerializableString text) throws IOException, JsonGenerationException {\n         _reportUnsupportedOperation();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         \n         if (type.isMapLikeType()) { // implements java.util.Map\n             MapLikeType mlt = (MapLikeType) type;\n-            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo(), property);\n+            /* 29-Sep-2012, tatu: This is actually too early to (try to) find\n+             *  key serializer from property annotations, and can lead to caching\n+             *  issues (see [Issue#75]). Instead, must be done from 'createContextual()' call.\n+             *  But we do need to check class annotations.\n+             */\n+            JsonSerializer<Object> keySerializer = _findKeySerializer(prov, beanDesc.getClassInfo());\n             if (mlt.isTrueMapType()) {\n                 return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n                         keySerializer, elementTypeSerializer, elementValueSerializer);\n     }\n \n     /**\n-     * Helper method called to try to find whether there is an annotation that\n-     * specifies key serializer to use: either attached to property (higher priority)\n-     * or class of key type (lower priority).\n+     * Helper method called to try to find whether there is an annotation in the\n+     * class that indicates key serializer to use.\n      * If so, will try to instantiate key serializer and return it; otherwise returns null.\n      */\n     protected JsonSerializer<Object> _findKeySerializer(SerializerProvider prov,\n-            Annotated a, BeanProperty property)\n+            Annotated a)\n         throws JsonMappingException\n     {\n         AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n-\n-        // Start with property (more specific); if not found, then find from type\n-        if (property != null) {\n-            AnnotatedMember m = property.getMember();\n-            if (m != null) {\n-                Object serDef = intr.findKeySerializer(m);\n-                if (serDef != null) {\n-                    return prov.serializerInstance(m, serDef);\n-                }\n-            }\n-        }\n         Object serDef = intr.findKeySerializer(a);\n         if (serDef != null) {\n             return prov.serializerInstance(a, serDef);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n         } else if (ser instanceof ContextualSerializer) {\n             ser = ((ContextualSerializer) ser).createContextual(provider, property);\n         }\n-        /* 10-Dec-2010, tatu: Let's also fetch key serializer; and always assume we'll\n-         *   do that just by using static type information\n+        /* 29-Sep-2012, tatu: Actually, we need to do much more contextual\n+         *    checking here since we finally know for sure the property,\n+         *    and it may have overrides\n          */\n-        /* 25-Feb-2011, tatu: May need to reconsider this static checking (since it\n-         *   differs from value handling)... but for now, it's ok to ensure contextual\n-         *   aspects are handled; this is done by provider.\n-         */\n-        JsonSerializer<?> keySer = _keySerializer;\n+        JsonSerializer<?> keySer = null;\n+        // Start with property (more specific); if not found, then find from type\n+        if (property != null) {\n+            AnnotatedMember m = property.getMember();\n+            if (m != null) {\n+                Object serDef = provider.getAnnotationIntrospector().findKeySerializer(m);\n+                if (serDef != null) {\n+                    keySer = provider.serializerInstance(m, serDef);\n+                }\n+            }\n+        }\n+        if (keySer == null) {\n+            keySer = _keySerializer;\n+        }\n         if (keySer == null) {\n             keySer = provider.findKeySerializer(_keyType, property);\n         } else if (keySer instanceof ContextualSerializer) {\n         }\n         return withResolved(property, keySer, ser, ignored);\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Accessors\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestKeySerializers extends BaseMapTest\n+{\n+    public static class KarlSerializer extends JsonSerializer<String>\n+    {\n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeFieldName(\"Karl\");\n+        }\n+    }\n+\n+    public static class NotKarlBean\n+    {\n+        public Map<String,Integer> map = new HashMap<String,Integer>();\n+        {\n+            map.put(\"Not Karl\", 1);\n+        }\n+    }\n+\n+    public static class KarlBean\n+    {\n+        @JsonSerialize(keyUsing = KarlSerializer.class)\n+        public Map<String,Integer> map = new HashMap<String,Integer>();\n+        {\n+            map.put(\"Not Karl\", 1);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testNotKarl() throws IOException {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        final String serialized = mapper.writeValueAsString(new NotKarlBean());\n+        assertEquals(\"{\\\"map\\\":{\\\"Not Karl\\\":1}}\", serialized);\n+    }\n+\n+    public void testKarl() throws IOException {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        final String serialized = mapper.writeValueAsString(new KarlBean());\n+        assertEquals(\"{\\\"map\\\":{\\\"Karl\\\":1}}\", serialized);\n+    }\n+\n+    // [Issue#75]: caching of KeySerializers\n+    public void testBoth() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        final String value1 = mapper.writeValueAsString(new NotKarlBean());\n+        assertEquals(\"{\\\"map\\\":{\\\"Not Karl\\\":1}}\", value1);\n+        final String value2 = mapper.writeValueAsString(new KarlBean());\n+        assertEquals(\"{\\\"map\\\":{\\\"Karl\\\":1}}\", value2);\n+    }\n+}", "timestamp": 1348990995, "metainfo": ""}