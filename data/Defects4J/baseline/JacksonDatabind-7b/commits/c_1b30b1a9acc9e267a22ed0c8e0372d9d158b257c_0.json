{"sha": "1b30b1a9acc9e267a22ed0c8e0372d9d158b257c", "log": "Fixed [Issue-14]: parent types of mix-in annotations were not resolved for fields, methods", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n         if (_mixInResolver != null) {\n             Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n             if (mixin != null) {\n-                _addMethodMixIns(_memberMethods, mixin, mixins);\n+                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n             }\n         }\n \n         _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n \n         /* And then from its supertypes, if any. But note that we will\n-         *  only consider super-types up until reaching the masked\n+         * only consider super-types up until reaching the masked\n          * class (if found); this because often mix-in class\n          * is a sub-class (for convenience reasons). And if so, we\n          * absolutely must NOT include super types of masked class,\n     {\n         // first, mixIns, since they have higher priority then class methods\n         if (mixInCls != null) {\n-            _addMethodMixIns(methods, mixInCls, mixIns);\n+            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n         }        \n         if (cls == null) { // just so caller need not check when passing super-class\n             return;\n         }\n     }\n \n-    protected void _addMethodMixIns(AnnotatedMethodMap methods,\n+    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n     {\n-        for (Method m : mixInCls.getDeclaredMethods()) {\n-            if (!_isIncludableMemberMethod(m)) {\n-                continue;\n-            }\n-            AnnotatedMethod am = methods.find(m);\n-            /* Do we already have a method to augment (from sub-class\n-             * that will mask this mixIn)? If so, add if visible\n-             * without masking (no such annotation)\n-             */\n-            if (am != null) {\n-                _addMixUnders(m, am);\n-                /* Otherwise will have precedence, but must wait\n-                 * until we find the real method (mixIn methods are\n-                 * just placeholder, can't be called)\n+        List<Class<?>> parents = new ArrayList<Class<?>>();\n+        parents.add(mixInCls);\n+        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n+        for (Class<?> mixin : parents) {\n+            for (Method m : mixin.getDeclaredMethods()) {\n+                if (!_isIncludableMemberMethod(m)) {\n+                    continue;\n+                }\n+                AnnotatedMethod am = methods.find(m);\n+                /* Do we already have a method to augment (from sub-class\n+                 * that will mask this mixIn)? If so, add if visible\n+                 * without masking (no such annotation)\n                  */\n-            } else {\n-                mixIns.add(_constructMethod(m));\n+                if (am != null) {\n+                    _addMixUnders(m, am);\n+                    /* Otherwise will have precedence, but must wait\n+                     * until we find the real method (mixIn methods are\n+                     * just placeholder, can't be called)\n+                     */\n+                } else {\n+                    mixIns.add(_constructMethod(m));\n+                }\n             }\n         }\n     }\n             if (_mixInResolver != null) {\n                 Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                 if (mixin != null) {\n-                    _addFieldMixIns(mixin, fields);\n+                    _addFieldMixIns(parent, mixin, fields);\n                 }\n             }\n         }\n      * into already collected actual fields (from introspected classes and their\n      * super-classes)\n      */\n-    protected void _addFieldMixIns(Class<?> mixin, Map<String,AnnotatedField> fields)\n-    {\n-        for (Field mixinField : mixin.getDeclaredFields()) {\n-            /* there are some dummy things (static, synthetic); better\n-             * ignore\n-             */\n-            if (!_isIncludableField(mixinField)) {\n-                continue;\n-            }\n-            String name = mixinField.getName();\n-            // anything to mask? (if not, quietly ignore)\n-            AnnotatedField maskedField = fields.get(name);\n-            if (maskedField != null) {\n-                _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n+    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n+            Map<String,AnnotatedField> fields)\n+    {\n+        List<Class<?>> parents = new ArrayList<Class<?>>();\n+        parents.add(mixInCls);\n+        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n+        for (Class<?> mixin : parents) {\n+            for (Field mixinField : mixin.getDeclaredFields()) {\n+                // there are some dummy things (static, synthetic); better ignore\n+                if (!_isIncludableField(mixinField)) {\n+                    continue;\n+                }\n+                String name = mixinField.getName();\n+                // anything to mask? (if not, quietly ignore)\n+                AnnotatedField maskedField = fields.get(name);\n+                if (maskedField != null) {\n+                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n+                }\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n     {\n         return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8));\n     }\n-\n+    \n     public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result)\n     {\n         _addSuperTypes(cls, endBefore, result, false);\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n         public int ido;\n     }\n \n-    public void testMixinInheritance() throws IOException\n+    static class Beano2 {\n+        public int getIdo() { return 13; }\n+        public String getNameo() { return \"Bill\"; }\n+    }\n+\n+    static abstract class BeanoMixinSuper2 extends Beano2 {\n+        @Override\n+        @JsonProperty(\"name\")\n+        public abstract String getNameo();\n+    }\n+\n+    static abstract class BeanoMixinSub2 extends BeanoMixinSuper2 {\n+        @Override\n+        @JsonProperty(\"id\")\n+        public abstract int getIdo();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testMixinFieldInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.addMixInAnnotations(Beano.class, BeanoMixinSub.class);\n         assertTrue(result.containsKey(\"id\"));\n         assertTrue(result.containsKey(\"name\"));\n     }\n+\n+    public void testMixinMethodInheritance() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class);\n+        Map<String,Object> result;\n+        result = writeAndMap(mapper, new Beano2());\n+        assertEquals(2, result.size());\n+        assertTrue(result.containsKey(\"id\"));\n+        assertTrue(result.containsKey(\"name\"));\n+    }\n }", "timestamp": 1335599014, "metainfo": ""}