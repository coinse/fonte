{"sha": "d1e678e660f50c66113da7d03e4ffb52fef45fc0", "log": "Last pieces of the first round of refactoring: again compiles, may work", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n import com.fasterxml.jackson.core.type.JavaType;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.NopAnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n     }\n \n     @Override\n-    public DeserializationConfig withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility) {\n+    public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n         return new DeserializationConfig(this, _base.withVisibility(forMethod, visibility));\n     }\n     \n     /**********************************************************\n      */\n     \n-    /**\n-     * Method that checks class annotations that the argument Object has,\n-     * and modifies settings of this configuration object accordingly,\n-     * similar to how those annotations would affect actual value classes\n-     * annotated with them, but with global scope. Note that not all\n-     * annotations have global significance, and thus only subset of\n-     * Jackson annotations will have any effect.\n-     *<p>\n-     * Ones that are known to have effect are:\n-     *<ul>\n-     * <li>{@link JsonAutoDetect}</li>\n-     *</ul>\n-     * \n-     * @param cls Class of which class annotations to use\n-     *   for changing configuration settings\n-     *   \n-     * @deprecated Since 1.9, it is preferably to explicitly configure\n-     *   instances; this method also modifies existing instance which is\n-     *   against immutable design goals of this class.\n-     */\n-    @Deprecated\n-    @Override\n-    public void fromAnnotations(Class<?> cls)\n-    {\n-    \t/* no class annotation for:\n-         *\n-         * - CAN_OVERRIDE_ACCESS_MODIFIERS\n-         * - USE_BIG_DECIMAL_FOR_FLOATS\n-         * - USE_BIG_INTEGER_FOR_INTS\n-         * - USE_GETTERS_AS_SETTERS\n-         */\n-\n-        /* 10-Jul-2009, tatu: Should be able to just pass null as\n-         *    'MixInResolver'; no mix-ins set at this point\n-         */\n-        AnnotationIntrospector ai = getAnnotationIntrospector();\n-        AnnotatedClass ac = AnnotatedClass.construct(cls, ai, null);\n-        // visibility checks handled via separate checker object...\n-        VisibilityChecker<?> prevVc = getDefaultVisibilityChecker();\n-        _base = _base.withVisibilityChecker(ai.findAutoDetectVisibility(ac, prevVc));\n-    }\n-\n     /**\n      * Method that is called to create a non-shared copy of the configuration\n      * to be used for a deserialization operation.\n     public boolean isEnabled(DeserializationConfig.Feature f) {\n         return (_featureFlags & f.getMask()) != 0;\n     }\n-\n-    /**\n-     * @deprecated Since 1.9, it is preferable to use {@link #with} instead;\n-     *    this method is deprecated as it modifies current instance instead of\n-     *    creating a new one (as the goal is to make this class immutable)\n-     */\n-    @Deprecated\n-    @Override\n-    public void enable(DeserializationConfig.Feature f) {\n-        super.enable(f);\n-    }\n-\n-    /** \n-     * @deprecated Since 1.9, it is preferable to use {@link #without} instead;\n-     *    this method is deprecated as it modifies current instance instead of\n-     *    creating a new one (as the goal is to make this class immutable)\n-     */\n-    @Deprecated\n-    @Override\n-    public void disable(DeserializationConfig.Feature f) {\n-        super.disable(f);\n-    }\n-\n-    /** \n-     * @deprecated Since 1.9, it is preferable to use {@link #without} and {@link #with} instead;\n-     *    this method is deprecated as it modifies current instance instead of\n-     *    creating a new one (as the goal is to make this class immutable)\n-     */\n-    @Deprecated\n-    @Override\n-    public void set(DeserializationConfig.Feature f, boolean state) {\n-        super.set(f, state);\n-    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n import java.text.DateFormat;\n import java.util.HashMap;\n import java.util.Map;\n+\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.type.JavaType;\n  * One major remaining issue is that of handling mix-in annotations, which\n  * still represent a bit of mutable state; may need to implement a\n  * functional-style immutable map for storing those.\n- *\n- * @since 1.2 -- major change in 1.8, changed from interface to\n- *   abstract class\n  */\n public abstract class MapperConfig<T extends MapperConfig<T>>\n     implements ClassIntrospector.MixInResolver\n      * same field or method. They can be further masked by sub-classes:\n      * you can think of it as injecting annotations between the target\n      * class and its sub-classes (or interfaces)\n-     *\n-     * @since 1.2\n      */\n     protected HashMap<ClassKey,Class<?>> _mixInAnnotations;\n \n      * Flag used to detect when a copy if mix-in annotations is\n      * needed: set when current copy is shared, cleared when a\n      * fresh copy is made\n-     *\n-     * @since 1.2\n      */\n     protected boolean _mixInAnnotationsShared;\n \n      *<p>\n      * Note: this is the only property left as non-final, to allow\n      * lazy construction of the instance as necessary.\n-     * \n-     * @since 1.6\n      */\n     protected SubtypeResolver _subtypeResolver;\n     \n \n     /**\n      * Simple copy constructor\n-     * \n-     * @since 1.8\n      */\n     protected MapperConfig(MapperConfig<T> src) {\n         this(src, src._base, src._subtypeResolver);\n     }\n \n     /**\n-     * @since 1.8\n+     * Fluent-copy constructor that creates a new slightly modified version, using\n+     * given config object as base for settings not provided.\n      */\n     protected MapperConfig(MapperConfig<T> src, MapperConfig.Base base, SubtypeResolver str)\n     {\n      */\n     \n     /**\n-     * Method that checks class annotations that the argument Object has,\n-     * and modifies settings of this configuration object accordingly,\n-     * similar to how those annotations would affect actual value classes\n-     * annotated with them, but with global scope. Note that not all\n-     * annotations have global significance, and thus only subset of\n-     * Jackson annotations will have any effect.\n-     * \n-     * @deprecated Since 1.9, it is preferably to explicitly configure\n-     *   instances; this method also modifies existing instance which is\n-     *   against immutable design goals of this class.\n-     */\n-    @Deprecated\n-    public abstract void fromAnnotations(Class<?> cls);\n-\n-    /**\n      * Method to use for constructing an instance that is not shared\n      * between multiple operations but only used for a single one\n      * (which may be this instance, if it is immutable; if not, a copy\n      * is constructed with same settings)\n-     * \n-     * @since 1.8\n      */\n     public abstract T createUnshared(SubtypeResolver subtypeResolver);\n \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci);\n \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withAnnotationIntrospector(AnnotationIntrospector ai);\n     \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withVisibilityChecker(VisibilityChecker<?> vc);\n \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.9\n-     */\n-    public abstract T withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility);\n+     */\n+    public abstract T withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility);\n     \n     /**\n      * Method for constructing and returning a new instance with different\n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withTypeResolverBuilder(TypeResolverBuilder<?> trb);\n     \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withSubtypeResolver(SubtypeResolver str);\n     \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withPropertyNamingStrategy(PropertyNamingStrategy strategy);\n     \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withTypeFactory(TypeFactory typeFactory);\n     \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withDateFormat(DateFormat df);\n \n      *<p>\n      * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n      * if directly calling this method.\n-     * \n-     * @since 1.8\n      */\n     public abstract T withHandlerInstantiator(HandlerInstantiator hi);\n \n     /**\n      * Method for constructing and returning a new instance with additional\n      * {@link AnnotationIntrospector} inserted (as the highest priority one)\n-     * \n-     * @since 1.9\n      */\n     public abstract T withInsertedAnnotationIntrospector(AnnotationIntrospector introspector);\n \n     /**\n      * Method for constructing and returning a new instance with additional\n      * {@link AnnotationIntrospector} appended (as the lowest priority one)\n-     * \n-     * @since 1.9\n      */\n     public abstract T withAppendedAnnotationIntrospector(AnnotationIntrospector introspector);\n     \n     /* Configuration: simple features\n     /**********************************************************\n      */\n-\n-    /**\n-     * Method for checking whether given feature is enabled or not\n-     */\n-    public abstract boolean isEnabled(ConfigFeature f);\n     \n     /**\n      * Method for determining whether annotation processing is enabled or not\n      * (default settings are typically that it is enabled; must explicitly disable).\n      * \n      * @return True if annotation processing is enabled; false if not\n-     * \n-     * @since 1.8\n      */\n     public abstract boolean isAnnotationProcessingEnabled();\n \n      * @return True if access modifier overriding is allowed (and may be done for\n      *   any Field, Method, Constructor or Class); false to prevent any attempts\n      *   to override.\n-     * \n-     * @since 1.8\n      */\n     public abstract boolean canOverrideAccessModifiers();\n \n     /**\n      * Accessor for checking whether default settings for property handling\n      * indicate that properties should be alphabetically ordered or not.\n-     * \n-     * @since 1.9\n      */\n     public abstract boolean shouldSortPropertiesAlphabetically();\n     \n      */\n     public AnnotationIntrospector getAnnotationIntrospector() {\n         return _base.getAnnotationIntrospector();\n-    }\n-\n-    /**\n-     * Method for registering specified {@link AnnotationIntrospector} as the highest\n-     * priority introspector (will be chained with existing introspector(s) which\n-     * will be used as fallbacks for cases this introspector does not handle)\n-     * \n-     * @param introspector Annotation introspector to register.\n-     * \n-     * @since 1.7\n-     * \n-     * @deprecated Since 1.9 use {@link #withInsertedAnnotationIntrospector(AnnotationIntrospector)} instead;\n-     *   this method is deprecated as it changes state, preventing immutability of instances\n-     */\n-    @Deprecated\n-    public final void insertAnnotationIntrospector(AnnotationIntrospector introspector) {\n-        _base = _base.withAnnotationIntrospector(AnnotationIntrospector.Pair.create(introspector,\n-                getAnnotationIntrospector()));\n-    }\n-\n-    /**\n-     * Method for registering specified {@link AnnotationIntrospector} as the lowest\n-     * priority introspector, chained with existing introspector(s) and called\n-     * as fallback for cases not otherwise handled.\n-     * \n-     * @param introspector Annotation introspector to register.\n-     * \n-     * @since 1.7\n-     * \n-     * @deprecated Since 1.9 use {@link #withAppendedAnnotationIntrospector(AnnotationIntrospector)} instead;\n-     *   this method is deprecated as it changes state, preventing immutability of instances\n-     */\n-    @Deprecated\n-    public final void appendAnnotationIntrospector(AnnotationIntrospector introspector) {\n-        _base = _base.withAnnotationIntrospector(AnnotationIntrospector.Pair.create(getAnnotationIntrospector(),\n-                introspector));\n     }\n \n     /**\n      * that this is the global handler; individual types (classes)\n      * can further override active checker used (using\n      * {@link JsonAutoDetect} annotation)\n-     * \n-     * @since 1.5\n      */\n     public VisibilityChecker<?> getDefaultVisibilityChecker() {\n         return _base.getVisibilityChecker();\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     public final PropertyNamingStrategy getPropertyNamingStrategy() {\n         return _base.getPropertyNamingStrategy();\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public final HandlerInstantiator getHandlerInstantiator() {\n         return _base.getHandlerInstantiator();\n     }\n      * Annotations from source classes (and their supertypes)\n      * will <b>override</b>\n      * annotations that target classes (and their super-types) have.\n-     *\n-     * @since 1.2\n      */\n     public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n     {\n      * <code>mixinSource</code> are taken to override annotations\n      * that <code>target</code> (or its supertypes) has.\n      *\n-     * @since 1.2\n-     *\n      * @param target Class (or interface) whose annotations to effectively override\n      * @param mixinSource Class (or interface) whose annotations are to\n      *   be \"added\" to target's annotations, overriding as necessary\n     /**\n      * Method that will check if there are \"mix-in\" classes (with mix-in\n      * annotations) for given class\n-     * \n-     * @since 1.2\n      */\n     @Override\n     public final Class<?> findMixInClassFor(Class<?> cls) {\n         return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n     }\n \n-    /**\n-     * @since 1.8.1\n-     */\n     public final int mixInCount() {\n         return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n     }\n      * one explicitly declared via annotations (or other configuration).\n      * If such default handler is configured, it is returned; otherwise\n      * null is returned.\n-     * \n-     * @since 1.5\n      */\n     public final TypeResolverBuilder<?> getDefaultTyper(JavaType baseType) {\n         return _base.getTypeResolverBuilder();\n         }\n         return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers());\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Deprecated methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method for replacing existing annotation introspector(s) with specified\n-     * introspector.\n-     * Since this method modifies state of configuration object directly, its use\n-     * is not recommended.\n-     * \n-     * @deprecated Since 1.8, use either\n-     *  {@link #withAnnotationIntrospector(AnnotationIntrospector)} or\n-     *  Module API instead\n-     */\n-    @Deprecated\n-    public final void setAnnotationIntrospector(AnnotationIntrospector ai) {\n-        _base = _base.withAnnotationIntrospector(ai);\n-    }\n-    \n-    /**\n-     * Method that will define specific date format to use for reading/writing\n-     * Date and Calendar values.\n-     * If null is passed, will use {@link StdDateFormat}.\n-     * Instance is used as is, without creating a clone.\n-     * Format object in use can be accessed using {@link #getDateFormat}.\n-     * \n-     * @param df Date format to use, if not null; if null, the default format\n-     *   will be used\n-     * \n-     * @deprecated As of version 1.8, it is preferable to call method in\n-     *   {@link ObjectMapper} instead; or construct new instance with\n-     *   {@link #withDateFormat(DateFormat)}\n-     */\n-    @Deprecated\n-    public void setDateFormat(DateFormat df) {\n-        if (df == null) {\n-            df = DEFAULT_DATE_FORMAT;\n-        }\n-        _base = _base.withDateFormat(df);\n-    }\n \n     /*\n     /**********************************************************\n      * {@link MapperConfig} implementations must implement.\n      * Necessary since enums can not be extended using normal\n      * inheritance, but can implement interfaces\n-     * \n-     * @since 1.9\n      */\n     public interface ConfigFeature\n     {\n                     _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n         }\n \n-        public Base withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility) {\n+        public Base withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n             return new Base(_classIntrospector, _annotationIntrospector,\n                     _visibilityChecker.withVisibility(forMethod, visibility),\n                     _propertyNamingStrategy, _typeFactory,\n          */\n         public abstract T without(CFG... features);\n         \n-        /*\n-        /**********************************************************\n-        /* Configuration: simple features\n-        /**********************************************************\n-         */\n-        \n-        /* NOTE: this method was added in 1.9, but should be\n-         * removed from 2.0 -- overloads do not work nicely with\n-         * enums, so we better not try \n-         *<p>\n-         * Also note that we can NOT use type variable CFG here, because\n-         * non-generic base class had to use base type.\n-         * \n-         * @Deprecated \n-         */\n-        @Override\n-        public boolean isEnabled(MapperConfig.ConfigFeature f) {\n-            return (_featureFlags & f.getMask()) != 0;\n-        }\n-        \n-        /*\n-        /**********************************************************\n-        /* Configuration: deprecated methods\n-        /**********************************************************\n-         */\n-        \n-        /**\n-         * Method for enabling specified feature.\n-         * \n-         * @deprecated Since 1.9, it is preferable to use {@link #with} instead;\n-         *    this method is deprecated as it modifies current instance instead of\n-         *    creating a new one (as the goal is to make this class immutable)\n-         */\n-        @Deprecated\n-        public void enable(CFG f) {\n-            _featureFlags |= f.getMask();\n-        }\n-\n-        /**\n-         * Method for disabling specified feature.\n-         * \n-         * @deprecated Since 1.9, it is preferable to use {@link #without} instead;\n-         *    this method is deprecated as it modifies current instance instead of\n-         *    creating a new one (as the goal is to make this class immutable)\n-         */\n-        @Deprecated\n-        public void disable(CFG f) {\n-            _featureFlags &= ~f.getMask();\n-        }\n-\n-        /**\n-         * Method for enabling or disabling specified feature.\n-         * \n-         * @deprecated Since 1.9, it is preferable to use {@link #with} and\n-         * {@link #without} methods instead;\n-         *    this method is deprecated as it modifies current instance instead of\n-         *    creating a new one (as the goal is to make this class immutable)\n-         */\n-        @SuppressWarnings(\"deprecation\")\n-        @Deprecated\n-        public void set(CFG f, boolean state)\n-        {\n-            if (state) {\n-                enable(f);\n-            } else {\n-                disable(f);\n-            }\n-        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n-import org.codehaus.jackson.*;\n import org.codehaus.jackson.node.*;\n-import org.codehaus.jackson.schema.JsonSchema;\n \n /**\n  * This mapper (or, data binder, or codec) provides functionality for\n      * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n      * to specify what kind of types (classes) default typing should\n      * be used for. It will only be used if no explicit type information\n-     * is found, but this enumeration further limits subset of those\n-     * types.\n-     * \n-     * @since 1.5\n+     * is found, but this enumeration further limits subset of those types.\n      */\n     public enum DefaultTyping {\n         /**\n         this(jf, null, null);\n     }\n \n-    /**\n-     * Construct mapper that uses specified {@link SerializerFactory}\n-     * for constructing necessary serializers.\n-     *\n-     * @deprecated Use other constructors instead; note that\n-     *   you can just set serializer factory with {@link #setSerializerFactory}\n-     */\n-    @Deprecated\n-    public ObjectMapper(SerializerFactory sf)\n-    {\n-        this(null, null, null);\n-        setSerializerFactory(sf);\n-    }\n-\n     public ObjectMapper(JsonFactory jf,\n-                        SerializerProvider sp, DeserializerProvider dp)\n+            SerializerProvider sp, DeserializerProvider dp)\n     {\n     \tthis(jf, sp, dp, null, null);\n     }\n      * custom serializers and deserializers.\n      * \n      * @param module Module to register\n-     * \n-     * @since 1.7\n-     */\n-    public void registerModule(Module module)\n+     */\n+    public ObjectMapper registerModule(Module module)\n     {\n         /* Let's ensure we have access to name and version information, \n          * even if we do not have immediate use for either. This way we know\n                 mapper._serializationConfig.addMixInAnnotations(target, mixinSource);\n             }\n         });\n-    }\n-\n-    /**\n-     * Fluent-style alternative to {@link #registerModule}; functionally equivalent to:\n-     *<pre>\n-     *  mapper.registerModule(module);\n-     *  return mapper;\n-     *</pre>\n-     * NOTE: name is unfortunately misleading in suggesting that a new instance\n-     * might be created (as is the case with most other 'withXxx()' methods\n-     * for Jackson core objects) -- this is not the case; rather, this is just\n-     * a variant of {@link #registerModule} but one that returns 'this'\n-     * (like it should return, but does not for historical reasons).\n-     * \n-     * @since 1.8\n-     */\n-    public ObjectMapper withModule(Module module)\n-    {\n-        registerModule(module);\n         return this;\n     }\n \n      * \n      * @since 1.9\n      */\n-    public ObjectMapper setVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility)\n+    public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n     {\n         _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n         _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n      * {@link SerializationConfig#set} on the shared {@link SerializationConfig}\n      * object with given arguments.\n      */\n-    @SuppressWarnings(\"deprecation\")\n     public ObjectMapper configure(SerializationConfig.Feature f, boolean state) {\n-        _serializationConfig.set(f, state);\n+        _serializationConfig = state ?\n+                _serializationConfig.with(f) : _serializationConfig.without(f);\n         return this;\n     }\n \n      * {@link DeserializationConfig#set} on the shared {@link DeserializationConfig}\n      * object with given arguments.\n      */\n-    @SuppressWarnings(\"deprecation\")\n     public ObjectMapper configure(DeserializationConfig.Feature f, boolean state) {\n-        _deserializationConfig.set(f, state);\n+        _deserializationConfig = state ?\n+                _deserializationConfig.with(f) : _deserializationConfig.without(f);\n         return this;\n     }\n \n     /**\n      * Convenience method for constructing {@link ObjectWriter}\n      * with default settings.\n-     * \n-     * @since 1.6\n      */\n     public ObjectWriter writer() {\n         return new ObjectWriter(this, copySerializationConfig());\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified {@link DateFormat}; or, if\n      * null passed, using timestamp (64-bit number.\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writer(DateFormat df) {\n         return new ObjectWriter(this,\n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified JSON View (filter).\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writerWithView(Class<?> serializationView) {\n         return new ObjectWriter(this, copySerializationConfig().withView(serializationView));\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime\n      * type.\n-     *\n-     * @since 1.9\n      */\n     public ObjectWriter writerWithType(Class<?> rootType) {\n         JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime type.\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writerWithType(JavaType rootType) {\n         return new ObjectWriter(this, copySerializationConfig(), rootType, /*PrettyPrinter*/null);\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified root type, instead of actual\n      * runtime type of value. Type must be a super-type of runtime type.\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writerWithType(TypeReference<?> rootType) {\n         JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified pretty printer for indentation\n      * (or if null, no pretty printer)\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writer(PrettyPrinter pp) {\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using the default pretty printer for indentation\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writerWithDefaultPrettyPrinter() {\n         return new ObjectWriter(this, copySerializationConfig(),\n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified filter provider.\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writer(FilterProvider filterProvider) {\n         return new ObjectWriter(this,\n      * writing content.\n      * \n      * @param schema Schema to pass to generator\n-     * \n-     * @since 1.9\n      */\n     public ObjectWriter writer(FormatSchema schema) {\n         return new ObjectWriter(this, copySerializationConfig(), schema);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Deprecated ObjectWriter creator methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * @deprecated Since 1.9, use {@link #writerWithType(Class)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter typedWriter(Class<?> rootType) {\n-        return writerWithType(rootType);\n-    }\n-\n-    /**\n-     * @deprecated Since 1.9, use {@link #writerWithType(JavaType)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter typedWriter(JavaType rootType) {\n-        return writerWithType(rootType);\n-    }\n-\n-    /**\n-     * @deprecated Since 1.9, use {@link #writerWithType(TypeReference)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter typedWriter(TypeReference<?> rootType) {\n-        return writerWithType(rootType);\n-    }\n-    \n-    /**\n-     * @deprecated Since 1.9, use {@link #writerWithView(Class)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter viewWriter(Class<?> serializationView) {\n-        return writerWithView(serializationView);\n-    }\n-    \n-    /**\n-     * @deprecated Since 1.9, use {@link #writer(FilterProvider)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter prettyPrintingWriter(PrettyPrinter pp) {\n-        return writer(pp);\n-    }\n-\n-    /**\n-     * @deprecated Since 1.9, use {@link #writerWithDefaultPrettyPrinter} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter defaultPrettyPrintingWriter() {\n-        return writerWithDefaultPrettyPrinter();\n-    }\n-    \n-    /**\n-     * @deprecated Since 1.9, use {@link #writer(FilterProvider)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter filteredWriter(FilterProvider filterProvider) {\n-        return writer(filterProvider);\n-    }\n-    \n-    /**\n-     * @deprecated Since 1.9, use {@link #writer(FilterProvider)} instead.\n-     */\n-    @Deprecated\n-    public ObjectWriter schemaBasedWriter(FormatSchema schema) {\n-        return writer(schema);\n     }\n     \n     /*\n      * Factory method for constructing {@link ObjectReader} with\n      * default settings. Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n-     * \n-     * @since 1.6\n      */\n     public ObjectReader reader() {\n         return new ObjectReader(this, copyDeserializationConfig())\n      * as root.\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n-     * \n-     * @since 1.9\n      */\n     public ObjectReader readerForUpdating(Object valueToUpdate)\n     {\n      * use specified injectable values.\n      * \n      * @param injectableValues Injectable values to use\n-     * \n-     * @since 1.9\n      */\n     public ObjectReader reader(InjectableValues injectableValues) {\n         return new ObjectReader(this, copyDeserializationConfig(), null, null,\n                 null, injectableValues);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Deprecated ObjectReader creator methods\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * @deprecated Since 1.9, use {@link #readerForUpdating} instead.\n-     */\n-    @Deprecated\n-    public ObjectReader updatingReader(Object valueToUpdate) {\n-        return readerForUpdating(valueToUpdate);\n-    }\n-    \n-    /**\n-     * @deprecated Since 1.9, use {@link #reader(FormatSchema)} instead.\n-     */\n-    @Deprecated\n-    public ObjectReader schemaBasedReader(FormatSchema schema) {\n-        return reader(schema);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import java.text.DateFormat;\n import java.util.*;\n+\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n import com.fasterxml.jackson.databind.annotate.JsonSerialize.Inclusion;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n-\n \n /**\n  * Object that contains baseline configuration for serialization\n          * no annotations are considered.\n          *<P>\n          * Feature is enabled by default.\n-         *\n-         * @since 1.2\n          */\n         USE_ANNOTATIONS(true),\n \n          * configuration available.\n          *<p>\n          * Feature is enabled by default.\n-         *\n-         * @since 1.1\n          */\n          AUTO_DETECT_FIELDS(true),\n \n          *<p>\n          * Feature is disabled by default for backwards compatibility\n          * reasons.\n-         * \n-         * @since 1.9\n          */\n         REQUIRE_SETTERS_FOR_GETTERS(false),\n         \n         /* Generic output features\n         /******************************************************\n          */\n-\n-        /**\n-         * Feature that determines the default settings of whether Bean\n-         * properties with null values are to be written out.\n-         *<p>\n-         * Feature is enabled by default (null properties written).\n-         *<p>\n-         * Note too that there is annotation\n-         * {@link org.codehaus.jackson.annotate.JsonWriteNullProperties}\n-         * that can be used for more granular control (annotates bean\n-         * classes or individual property access methods).\n-         *\n-         * @deprecated As of 1.1, use {@link SerializationConfig#setSerializationInclusion}\n-         *    instead\n-         */\n-        @Deprecated\n-        WRITE_NULL_PROPERTIES(true),\n \n         /**\n          * Feature that determines whether the type detection for\n          * Default value is enabled, meaning that non-annotated\n          * properties are included in all views if there is no\n          * {@link org.codehaus.jackson.map.annotate.JsonView} annotation.\n-         * \n-         * @since 1.5\n          */\n         DEFAULT_VIEW_INCLUSION(true),\n         \n          * Feature is mostly intended for JAXB compatibility.\n          *<p>\n          * Default setting is false, meaning root value is not wrapped.\n-         *\n-         * @since 1.7\n          */\n         WRAP_ROOT_VALUE(false),\n \n          *<p>\n          * Note that this is just the default behavior, and can be overridden by\n          * explicit overrides in classes.\n-         *\n-         * @since 1.8\n          */\n         SORT_PROPERTIES_ALPHABETICALLY(false),\n         \n          * those \"empty\" beans that do not have any recognized annotations\n          * (like <code>@JsonSerialize</code>): ones that do have annotations\n          * do not result in an exception being thrown.\n-         *\n-         * @since 1.4\n          */\n         FAIL_ON_EMPTY_BEANS(true),\n \n          * However, sometimes calling application may just want \"raw\"\n          * unchecked exceptions passed as is.\n          *<p>\n-         * Feature is enabled by default, and is similar in behavior\n-         * to default prior to 1.7.\n-         * \n-         * @since 1.7\n+         * Feature is enabled by default.\n          */\n         WRAP_EXCEPTIONS(true),\n \n           * NOTE: only affects behavior with <b>root</b> objects, and not other\n           * objects reachable from the root object. Put another way, only one\n           * call will be made for each 'writeValue' call.\n-          * \n-          * @since 1.6 (see [JACKSON-282 for details])\n           */\n         CLOSE_CLOSEABLE(false),\n \n          * should not be forced: for example when underlying stream is\n          * compressing and flush() causes compression state to be flushed\n          * (which occurs with some compression codecs).\n-          * \n-          * @since 1.6 (see [JACKSON-401 for details])\n          */\n         FLUSH_AFTER_WRITE_VALUE(true),\n          \n          *<p>\n          * Default value is 'false', meaning that Date-valued Map keys are serialized\n          * as textual (ISO-8601) values.\n-         * \n-         * @since 1.9\n          */\n         WRITE_DATE_KEYS_AS_TIMESTAMPS(false),\n \n          * when enabled, will be serialized as an explict JSON array (with\n          * single-character Strings as values); when disabled, defaults to\n          * serializing them as Strings (which is more compact).\n-         * \n-         * @since 1.6 (see [JACKSON-289 for details])\n          */\n         WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false),\n \n          *<p>\n          * Note: this feature should usually have same value\n          * as {@link DeserializationConfig.Feature#READ_ENUMS_USING_TO_STRING}.\n-         *<p>\n-         * For further details, check out [JACKSON-212]\n          * \n          * @since 1.6\n          */\n          *<p>\n          * Note that this feature has precedence over {@link #WRITE_ENUMS_USING_TO_STRING},\n          * which is only considered if this feature is set to false.\n-         * \n-         * @since 1.9\n          */\n         WRITE_ENUMS_USING_INDEX(false),\n         \n          * to be serialized (true) or not (false).\n          *<p>\n          * For further details, check out [JACKSON-314]\n-         * \n-         * @since 1.6\n          */\n         WRITE_NULL_MAP_VALUES(true),\n \n          *<p>\n          * Note that this does not change behavior of {@link java.util.Map}s, or\n          * \"Collection-like\" types.\n-         * \n-         * @since 1.9\n          */\n         WRITE_EMPTY_JSON_ARRAYS(true)\n         \n         _filterProvider = null;\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     protected SerializationConfig(SerializationConfig src) {\n         this(src, src._base);\n     }\n \n     /**\n      * Constructor used to make a private copy of specific mix-in definitions.\n-     * \n-     * @since 1.8\n      */\n     protected SerializationConfig(SerializationConfig src,\n             HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str)\n         _subtypeResolver = str;\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     protected SerializationConfig(SerializationConfig src, MapperConfig.Base base)\n     {\n         super(src, base, src._subtypeResolver);\n         _filterProvider = src._filterProvider;\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     protected SerializationConfig(SerializationConfig src, FilterProvider filters)\n     {\n         super(src);\n         _filterProvider = filters;\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     protected SerializationConfig(SerializationConfig src, Class<?> view)\n     {\n         super(src);\n         _filterProvider = src._filterProvider;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     protected SerializationConfig(SerializationConfig src, JsonSerialize.Inclusion incl)\n     {\n         super(src);\n         _serializationInclusion = incl;\n-        // And for some level of backwards compatibility, also...\n-        if (incl == JsonSerialize.Inclusion.NON_NULL) {\n-            _featureFlags &= ~Feature.WRITE_NULL_PROPERTIES.getMask();\n-        } else {\n-            _featureFlags |= Feature.WRITE_NULL_PROPERTIES.getMask();\n-        }\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     protected SerializationConfig(SerializationConfig src, int features)\n     {\n         super(src, features);\n     }\n \n     @Override\n-    public SerializationConfig withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility) {\n+    public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n         return new SerializationConfig(this, _base.withVisibility(forMethod, visibility));\n     }\n     \n     /**********************************************************\n      */\n     \n-    /**\n-     * @since 1.7\n-     */\n     public SerializationConfig withFilters(FilterProvider filterProvider) {\n         return new SerializationConfig(this, filterProvider);\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public SerializationConfig withView(Class<?> view) {\n         return new SerializationConfig(this, view);\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public SerializationConfig withSerializationInclusion(JsonSerialize.Inclusion incl) {\n         return new SerializationConfig(this, incl);\n     }\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features enabled.\n-     * \n-     * @since 1.9\n      */\n     @Override\n     public SerializationConfig with(Feature... features)\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features disabled.\n-     * \n-     * @since 1.9\n      */\n     @Override\n     public SerializationConfig without(Feature... features)\n     /**********************************************************\n      */\n     \n-    /**\n-     * Method that checks class annotations that the argument Object has,\n-     * and modifies settings of this configuration object accordingly,\n-     * similar to how those annotations would affect actual value classes\n-     * annotated with them, but with global scope. Note that not all\n-     * annotations have global significance, and thus only subset of\n-     * Jackson annotations will have any effect.\n-     *<p>\n-     * Serialization annotations that are known to have effect are:\n-     *<ul>\n-     * <li>{@link JsonWriteNullProperties}</li>\n-     * <li>{@link JsonAutoDetect}</li>\n-     * <li>{@link JsonSerialize#typing}</li>\n-     *</ul>\n-     * \n-     * @param cls Class of which class annotations to use\n-     *   for changing configuration settings\n-     *   \n-     * @deprecated Since 1.9, it is preferably to explicitly configure\n-     *   instances; this method also modifies existing instance which is\n-     *   against immutable design goals of this class.\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    @Deprecated\n-    @Override\n-    public void fromAnnotations(Class<?> cls)\n-    {\n-        /* 10-Jul-2009, tatu: Should be able to just pass null as\n-         *    'MixInResolver'; no mix-ins set at this point\n-         * 29-Jul-2009, tatu: Also, we do NOT ignore annotations here, even\n-         *    if Feature.USE_ANNOTATIONS was disabled, since caller\n-         *    specifically requested annotations to be added with this call\n-         */\n-        AnnotationIntrospector ai = getAnnotationIntrospector();\n-        AnnotatedClass ac = AnnotatedClass.construct(cls, ai, null);\n-        _base = _base.withVisibilityChecker(ai.findAutoDetectVisibility(ac,\n-                getDefaultVisibilityChecker()));\n-\n-        // How about writing null property values?\n-        JsonSerialize.Inclusion incl = ai.findSerializationInclusion(ac, null);\n-        if (incl != _serializationInclusion) {\n-            setSerializationInclusion(incl);\n-    \t}\n-\n-        JsonSerialize.Typing typing = ai.findSerializationTyping(ac);\n-        if (typing != null) {\n-            set(Feature.USE_STATIC_TYPING, (typing == JsonSerialize.Typing.STATIC));\n-        }\n-    }\n-\n     @Override\n     public SerializationConfig createUnshared(SubtypeResolver subtypeResolver)\n     {\n         return (_featureFlags & f.getMask()) != 0;\n     }\n     \n-    /**\n-     * @deprecated Since 1.9, it is preferable to use {@link #with} instead;\n-     *    this method is deprecated as it modifies current instance instead of\n-     *    creating a new one (as the goal is to make this class immutable)\n-     */\n-    @Deprecated\n-    @Override\n-    public void enable(SerializationConfig.Feature f) {\n-        super.enable(f);\n-    }\n-\n-    /** \n-     * @deprecated Since 1.9, it is preferable to use {@link #without} instead;\n-     *    this method is deprecated as it modifies current instance instead of\n-     *    creating a new one (as the goal is to make this class immutable)\n-     */\n-    @Deprecated\n-    @Override\n-    public void disable(SerializationConfig.Feature f) {\n-        super.disable(f);\n-    }\n-\n-    /** \n-     * @deprecated Since 1.9, it is preferable to use {@link #without} and {@link #with} instead;\n-     *    this method is deprecated as it modifies current instance instead of\n-     *    creating a new one (as the goal is to make this class immutable)\n-     */\n-    @Deprecated\n-    @Override\n-    public void set(SerializationConfig.Feature f, boolean state) {\n-        super.set(f, state);\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Configuration: other\n     /**\n      * Method for checking which serialization view is being used,\n      * if any; null if none.\n-     *\n-     * @since 1.4\n      */\n     public Class<?> getSerializationView() { return _serializationView; }\n \n         if (_serializationInclusion != null) {\n             return _serializationInclusion;\n         }\n-        return isEnabled(Feature.WRITE_NULL_PROPERTIES) ?\n-            JsonSerialize.Inclusion.ALWAYS : JsonSerialize.Inclusion.NON_NULL;\n-    }\n-    \n-    /**\n-     * Method that will define global setting of which\n-     * bean/map properties are to be included in serialization.\n-     * Can be overridden by class annotations (overriding\n-     * settings to use for instances of that class) and\n-     * method/field annotations (overriding settings for the value\n-     * bean for that getter method or field)\n-     * \n-     * @deprecated since 1.9 should either use {@link #withSerializationInclusion}\n-     *    to construct new instance, or configure through {@link ObjectMapper}\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    @Deprecated\n-    public void setSerializationInclusion(JsonSerialize.Inclusion props)\n-    {\n-        _serializationInclusion = props;\n-        // And for some level of backwards compatibility, also...\n-        if (props == JsonSerialize.Inclusion.NON_NULL) {\n-            disable(Feature.WRITE_NULL_PROPERTIES);\n-        } else {\n-            enable(Feature.WRITE_NULL_PROPERTIES);\n-        }\n+        return JsonSerialize.Inclusion.ALWAYS;\n     }\n     \n     /**\n      * id (which is usually provided with filter annotations).\n      * Will be null if no provided was set for {@link ObjectWriter}\n      * (or if serialization directly called from {@link ObjectMapper})\n-     * \n-     * @since 1.7\n      */\n     public FilterProvider getFilterProvider() {\n         return _filterProvider;\n     \n     /*\n     /**********************************************************\n-    /* Deprecated methods\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * One thing to note is that this will set {@link Feature#WRITE_DATES_AS_TIMESTAMPS}\n-     * to false (if null format set), or true (if non-null format)\n-     * \n-     * @deprecated Since 1.8, use {@link #withDateFormat} instead.\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    @Deprecated\n-    public final void setDateFormat(DateFormat df) {\n-        super.setDateFormat(df);\n-        set(Feature.WRITE_DATES_AS_TIMESTAMPS, (df == null));\n-    }\n-    \n-    /**\n-     * Method for checking which serialization view is being used,\n-     * if any; null if none.\n-     *\n-     * @since 1.4\n-     * \n-     * @deprecated Since 1.8, use {@link #withView} instead\n-     */\n-    @Deprecated\n-    public void setSerializationView(Class<?> view)\n-    {\n-        _serializationView = view;\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* Debug support\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n-import org.codehaus.jackson.schema.JsonSchema;\n \n /**\n  * Abstract class that defines API used by {@link ObjectMapper} and\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n      *\n      * @throws JsonMappingException if invalid annotation is found\n      */\n-    @SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+    @SuppressWarnings({ \"unchecked\" })\n     protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationConfig config,\n             Annotated a, T type, String propName)\n         throws JsonMappingException\n                 Class<? extends KeyDeserializer> kdClass = intr.findKeyDeserializer(a);\n                 if (kdClass != null && kdClass != KeyDeserializer.None.class) {\n                     KeyDeserializer kd = config.keyDeserializerInstance(a, kdClass);\n-                    // !!! TODO: For 2.0, change to use this instead:\n-                    /*\n                     type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType = type.getKeyType(); // just in case it's used below\n-                    */\n-                    keyType.setValueHandler(kd);\n                 }\n             }            \n             \n                 Class<? extends JsonDeserializer<?>> cdClass = intr.findContentDeserializer(a);\n                 if (cdClass != null && cdClass != JsonDeserializer.None.class) {\n                     JsonDeserializer<Object> cd = config.deserializerInstance(a, cdClass);\n-                    // !!! TODO: For 2.0, change to use this instead:\n-                    /*\n                     type = (T) type.withContentValueHandler(cd);\n-                    */\n-                    type.getContentType().setValueHandler(cd);\n                 }\n             }\n         }\n      * Starting with version 1.3, this method will also resolve instances\n      * of key and content deserializers if defined by annotations.\n      */\n-    @SuppressWarnings(\"deprecation\")\n     protected JavaType resolveType(DeserializationConfig config,\n             BasicBeanDescription beanDesc, JavaType type, AnnotatedMember member,\n             BeanProperty property)                    \n                 Class<? extends KeyDeserializer> kdClass = intr.findKeyDeserializer(member);\n                 if (kdClass != null && kdClass != KeyDeserializer.None.class) {\n                     KeyDeserializer kd = config.keyDeserializerInstance(member, kdClass);\n-                    // !!! TODO: For 2.0, change to use this instead:\n-                    /*\n                     type = ((MapLikeType) type).withKeyValueHandler(kd);\n                     keyType = type.getKeyType(); // just in case it's used below\n-                    */\n-                    keyType.setValueHandler(kd);\n                 }\n             }\n             // and all container types have content types...\n             Class<? extends JsonDeserializer<?>> cdClass = intr.findContentDeserializer(member);\n             if (cdClass != null && cdClass != JsonDeserializer.None.class) {\n                 JsonDeserializer<Object> cd = config.deserializerInstance(member, cdClass);\n-                // !!! TODO: For 2.0, change to use this instead:\n-                /*\n                 type = type.withContentValueHandler(cd);\n-                */\n-                type.getContentType().setValueHandler(cd);\n             }\n             /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n              *    information to use for polymorphic members; and specifically types for\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n import java.lang.reflect.Member;\n import java.lang.reflect.Method;\n \n+\n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n \n /**\n      *\n      * @since 1.9\n      */\n-    public T withVisibility(JsonMethod method, Visibility v);\n+    public T withVisibility(PropertyAccessor method, Visibility v);\n     \n     /**\n      * Builder method that will return a checker instance that has\n          */\n \tpublic Std(JsonAutoDetect ann)\n \t{\n-\t    JsonMethod[] incl = ann.value();\n \t    // let's combine checks for enabled/disabled, with minimimum level checks:\n-\t    _getterMinLevel = hasMethod(incl, JsonMethod.GETTER) ? ann.getterVisibility() : Visibility.NONE;\n-            _isGetterMinLevel = hasMethod(incl, JsonMethod.IS_GETTER) ? ann.isGetterVisibility() : Visibility.NONE;\n-            _setterMinLevel = hasMethod(incl, JsonMethod.SETTER) ? ann.setterVisibility() : Visibility.NONE;\n-            _creatorMinLevel = hasMethod(incl, JsonMethod.CREATOR) ? ann.creatorVisibility() : Visibility.NONE;\n-            _fieldMinLevel = hasMethod(incl, JsonMethod.FIELD) ? ann.fieldVisibility() : Visibility.NONE;\n+\t    _getterMinLevel = ann.getterVisibility();\n+            _isGetterMinLevel = ann.isGetterVisibility();\n+            _setterMinLevel = ann.setterVisibility();\n+            _creatorMinLevel = ann.creatorVisibility();\n+            _fieldMinLevel = ann.fieldVisibility();\n \t}\n \n \t/**\n         @Override\n \tpublic Std with(JsonAutoDetect ann)\n \t{\n-\t    if (ann == null) return this;\n-\t    Std curr = this;\n-\n-\t    JsonMethod[] incl = ann.value();\n-\t    Visibility v;\n-\n-\t    v = hasMethod(incl, JsonMethod.GETTER) ? ann.getterVisibility() : Visibility.NONE;\n-\t    curr = curr.withGetterVisibility(v);\n-\t    v = hasMethod(incl, JsonMethod.IS_GETTER) ? ann.isGetterVisibility() : Visibility.NONE;\n-\t    curr = curr.withIsGetterVisibility(v);\n-\t    v = hasMethod(incl, JsonMethod.SETTER) ? ann.setterVisibility() : Visibility.NONE;\n-            curr  = curr.withSetterVisibility(v);\n-            v = hasMethod(incl, JsonMethod.CREATOR) ? ann.creatorVisibility() : Visibility.NONE;\n-            curr = curr.withCreatorVisibility(v);\n-            v = hasMethod(incl, JsonMethod.FIELD) ? ann.fieldVisibility() : Visibility.NONE;\n-            curr = curr.withFieldVisibility(v);\n+            Std curr = this;\n+\t    if (ann != null) {\n+    \t    curr = curr.withGetterVisibility(ann.getterVisibility());\n+    \t    curr = curr.withIsGetterVisibility(ann.isGetterVisibility());\n+                curr  = curr.withSetterVisibility(ann.setterVisibility());\n+                curr = curr.withCreatorVisibility(ann.creatorVisibility());\n+                curr = curr.withFieldVisibility(ann.fieldVisibility());\n+\t    }\n \t    return curr;\n \t}\n \n \t}\n \n         @Override\n-\tpublic Std withVisibility(JsonMethod method, Visibility v)\n+\tpublic Std withVisibility(PropertyAccessor method, Visibility v)\n \t{\n \t    switch (method) {\n \t    case GETTER:\n \n         /*\n         /********************************************************\n-        /* Helper methods\n-        /********************************************************\n-         */\n-    \n-        private static boolean hasMethod(JsonMethod[] methods, JsonMethod method)\n-        {\n-            for (JsonMethod curr : methods) {\n-                if (curr == method || curr == JsonMethod.ALL) return true;\n-            }\n-            return false;\n-        }\n-\n-        /*\n-        /********************************************************\n         /* Standard methods\n         /********************************************************\n          */\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+\n+/**\n+ * A {@link org.codehaus.jackson.JsonNode} that represents a JSON-Schema instance.\n+ *\n+ * @author Ryan Heaton\n+ * @see <a href=\"http://json-schema.org/\">JSON Schema</a>\n+ */\n+public class JsonSchema\n+{\n+    private final ObjectNode schema;\n+\n+    /**\n+     * Main constructor for schema instances.\n+     *<p>\n+     * This is the creator constructor used by Jackson itself when\n+     * deserializing instances. It is so-called delegating creator, \n+     * meaning that its argument will be bound by Jackson before\n+     * constructor gets called.\n+     */\n+    @JsonCreator\n+    public JsonSchema(ObjectNode schema)\n+    {\n+        this.schema = schema;\n+    }\n+\n+    /**\n+     * Method for accessing root JSON object of the contained schema.\n+     *<p>\n+     * Note: this method is specified with {@link JsonValue} annotation\n+     * to represent serialization to use; same as if explicitly\n+     * serializing returned object.\n+     *\n+     * @return Root node of the schema tree\n+     */\n+    @JsonValue\n+    public ObjectNode getSchemaNode()\n+    {\n+        return schema;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return this.schema.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (!(o instanceof JsonSchema)) return false;\n+\n+        JsonSchema other = (JsonSchema) o;\n+        if (schema == null) {\n+            return other.schema == null;\n+        }\n+        return schema.equals(other.schema);\n+    }\n+\n+    /**\n+     * Get the default schema node.\n+     *\n+     * @return The default schema node.\n+     */\n+    public static JsonNode getDefaultSchemaNode()\n+    {\n+        ObjectNode objectNode = JsonNodeFactory.instance.objectNode();\n+        objectNode.put(\"type\", \"any\");\n+        // \"required\" is false by default, no need to include\n+        //objectNode.put(\"required\", false);\n+        return objectNode;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSerializableSchema.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Annotation that can be used to define JSON Schema definition for\n+ * the annotated class.\n+ *<p>\n+ * Note that annotation is often not needed: for example, regular\n+ * Jackson beans that Jackson can introspect can be used without\n+ * annotations, to produce JSON schema definition.\n+ * \n+ * @author Ryan Heaton\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonSerializableSchema\n+{\n+    /**\n+     * The schema type for this JsonSerializable instance.\n+     * Possible values: \"string\", \"number\", \"boolean\", \"object\", \"array\", \"null\", \"any\"\n+     *\n+     * @return The schema type for this JsonSerializable instance.\n+     */\n+    String schemaType() default \"any\";\n+\n+    /**\n+     * If the schema type is \"object\", the node that defines the properties of the object.\n+     *\n+     * @return The node representing the schema properties, or \"##irrelevant\" if irrelevant.\n+     */\n+    String schemaObjectPropertiesDefinition() default \"##irrelevant\";\n+\n+    /**\n+     * If the schema type if \"array\", the node that defines the schema for the items in the array.\n+     *\n+     * @return The schema for the items in the array, or \"##irrelevant\" if irrelevant.\n+     */\n+    String schemaItemDefinition() default \"##irrelevant\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Marker interface for schema-aware serializers.\n+ *\n+ * @author Ryan Heaton\n+ */\n+public interface SchemaAware\n+{\n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+            throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/package-info.java\n+/**\n+ * Classes needed for JSON schema support (currently just ability\n+ * to generate schemas using serialization part of data mapping)\n+ */\n+package com.fasterxml.jackson.databind.jsonschema;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.JavaType;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.ser.impl.FailingSerializer;\n import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\n import com.fasterxml.jackson.databind.ser.impl.SerializerCache;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSchema;\n-import org.codehaus.jackson.schema.SchemaAware;\n \n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n import com.fasterxml.jackson.core.type.JavaType;\n \n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSchema;\n-import org.codehaus.jackson.schema.SchemaAware;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import com.fasterxml.jackson.core.type.JavaType;\n \n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSchema;\n-import org.codehaus.jackson.schema.SchemaAware;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.ser.*;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n \n import org.codehaus.jackson.node.JsonNodeFactory;\n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSchema;\n-import org.codehaus.jackson.schema.SchemaAware;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.JavaType;\n \n-import org.codehaus.jackson.schema.SchemaAware;\n-import org.codehaus.jackson.schema.JsonSchema;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n import com.fasterxml.jackson.core.type.JavaType;\n \n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSchema;\n-import org.codehaus.jackson.schema.SchemaAware;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.TypeSerializer;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.ArrayType;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSerializableSchema;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.TypeSerializer;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n         String objectProperties = null;\n         String itemDefinition = null;\n         if (typeHint != null) {\n-            Class<?> rawClass = TypeFactory.type(typeHint).getRawClass();\n+            Class<?> rawClass = TypeFactory.rawClass(typeHint);\n             if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) {\n                 JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class);\n                 schemaType = schemaInfo.schemaType();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableWithTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableWithTypeSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.JsonSerializableSchema;\n \n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializableWithType;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.TypeSerializer;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n import com.fasterxml.jackson.core.type.JavaType;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n \n import org.codehaus.jackson.node.JsonNodeFactory;\n import org.codehaus.jackson.node.ObjectNode;\n-import org.codehaus.jackson.schema.SchemaAware;\n \n /**\n  * Base class used by all standard serializers. Provides some convenience", "timestamp": 1324690720, "metainfo": ""}