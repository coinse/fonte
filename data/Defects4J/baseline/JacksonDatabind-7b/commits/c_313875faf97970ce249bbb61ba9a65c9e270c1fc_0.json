{"sha": "313875faf97970ce249bbb61ba9a65c9e270c1fc", "log": "Deferring construction of key deserializers, trying to reduce startup overhead", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n \n import com.fasterxml.jackson.databind.AbstractTypeResolver;\n import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n /**\n     private static final long serialVersionUID = 3683541151102256824L;\n \n     protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n-    protected final static KeyDeserializers[] NO_KEY_DESERIALIZERS = new KeyDeserializers[0];\n     protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n     protected final static AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS = new AbstractTypeResolver[0];\n     protected final static ValueInstantiators[] NO_VALUE_INSTANTIATORS = new ValueInstantiators[0];\n+\n+    /**\n+     * By default we plug default key deserializers using as \"just another\" set of\n+     * of key deserializers.\n+     * \n+     * @since 2.2\n+     */\n+    protected final static KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS = new KeyDeserializers[] {\n+        new StdKeyDeserializers()\n+    };\n     \n     /**\n      * List of providers for additional deserializers, checked before considering default\n         _additionalDeserializers = (allAdditionalDeserializers == null) ?\n                 NO_DESERIALIZERS : allAdditionalDeserializers;\n         _additionalKeyDeserializers = (allAdditionalKeyDeserializers == null) ?\n-                NO_KEY_DESERIALIZERS : allAdditionalKeyDeserializers;\n+                DEFAULT_KEY_DESERIALIZERS : allAdditionalKeyDeserializers;\n         _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers;\n         _abstractTypeResolvers = (atr == null) ? NO_ABSTRACT_TYPE_RESOLVERS : atr;\n         _valueInstantiators = (vi == null) ? NO_VALUE_INSTANTIATORS : vi;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n      */\n     final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers\n         = PrimitiveArrayDeserializers.getAll();\n-\n-    /**\n-     * Set of available key deserializers is currently limited\n-     * to standard types; and all known instances are stored in this map.\n-     */\n-    final protected static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n     \n     /* We do some defaulting for abstract Map classes and\n      * interfaces, to avoid having to use exact types or annotations in\n          */\n         _mapFallbacks.put(\"java.util.NavigableMap\", TreeMap.class);\n         try {\n-            Class<?> key = Class.forName(\"java.util.concurrent.ConcurrentNavigableMap\");\n-            Class<?> value = Class.forName(\"java.util.concurrent.ConcurrentSkipListMap\");\n+            Class<?> key = java.util.concurrent.ConcurrentNavigableMap.class;\n+            Class<?> value = java.util.concurrent.ConcurrentSkipListMap.class;\n             @SuppressWarnings(\"unchecked\")\n                 Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n             _mapFallbacks.put(key.getName(), mapValue);\n-        } catch (ClassNotFoundException cnfe) { // occurs on 1.5\n-        } catch (SecurityException se) { // might occur in applets, see stackoverflow.com/questions/12345068\n+        } catch (Exception e) { // is this possible?\n+            System.err.println(\"Problems with (optional) types: \"+e);\n         }\n     }\n \n     protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n         _factoryConfig = config;\n     }\n-\n+    \n     /**\n      * Method for getting current {@link DeserializerFactoryConfig}.\n       *<p>\n                 }\n             }\n         }\n+        // the only non-standard thing is this:\n         if (deser == null) {\n-            // and if none found, standard ones:\n-            Class<?> raw = type.getRawClass();\n-            if (raw == String.class || raw == Object.class) {\n-                deser = StdKeyDeserializers.constructStringKeyDeserializer(config, type);\n-            } else {\n-                // Most other keys are for limited number of static types\n-                deser = _keyDeserializers.get(type);\n-                if (deser == null) {\n-                    // And then other one-offs; first, Enum:\n-                    if (type.isEnumType()) {\n-                        deser = _createEnumKeyDeserializer(ctxt, type);\n-                    } else {\n-                        // One more thing: can we find ctor(String) or valueOf(String)?\n-                        deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n-                    }\n-                }\n-            }\n-        }\n+            if (type.isEnumType()) {\n+                return _createEnumKeyDeserializer(ctxt, type);\n+            }\n+            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+        }\n+        \n         // and then new with 2.2: ability to post-process it too (Issue#120)\n-        if (_factoryConfig.hasDeserializerModifiers()) {\n-            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-                deser = mod.modifyKeyDeserializer(config, type, deser);\n+        if (deser != null) {\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyKeyDeserializer(config, type, deser);\n+                }\n             }\n         }\n         return deser;\n             \t}\n             }\n         }\n-    \tTypeDeserializer valueTypeDeser;\n+        TypeDeserializer valueTypeDeser;\n \n         if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n             valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n             throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation: \"+re.getMessage());\n         }\n         if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        \treturn null;\n+            return null;\n         }\n         throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n-import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n  *</ul>\n  */\n public class StdKeyDeserializers\n+    implements KeyDeserializers, java.io.Serializable\n {\n-    protected final HashMap<JavaType, KeyDeserializer> _keyDeserializers = new HashMap<JavaType, KeyDeserializer>();\n+    private static final long serialVersionUID = 923268084968181479L;\n \n-    protected StdKeyDeserializers()\n-    {\n-        add(new StdKeyDeserializer.BoolKD());\n-        add(new StdKeyDeserializer.ByteKD());\n-        add(new StdKeyDeserializer.CharKD());\n-        add(new StdKeyDeserializer.ShortKD());\n-        add(new StdKeyDeserializer.IntKD());\n-        add(new StdKeyDeserializer.LongKD());\n-        add(new StdKeyDeserializer.FloatKD());\n-        add(new StdKeyDeserializer.DoubleKD());\n-        add(new StdKeyDeserializer.DateKD());\n-        add(new StdKeyDeserializer.CalendarKD());\n-        add(new StdKeyDeserializer.UuidKD());\n-        add(new StdKeyDeserializer.LocaleKD());\n-    }\n-\n-    private void add(StdKeyDeserializer kdeser)\n-    {\n-        Class<?> keyClass = kdeser.getKeyClass();\n-        /* As with other cases involving primitive types, we can use\n-         * default TypeFactory ok, even if it's not our first choice:\n-         */\n-        _keyDeserializers.put(TypeFactory.defaultInstance().constructType(keyClass), kdeser);\n-    }\n-\n-    public static HashMap<JavaType, KeyDeserializer> constructAll()\n-    {\n-        return new StdKeyDeserializers()._keyDeserializers;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Dynamic factory methods\n-    /**********************************************************\n+    /**\n+     * @deprecated Since 2.2, just call {@link StdKeyDeserializer.StringKD} directly\n      */\n-\n-    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config, JavaType type) {\n+    @Deprecated\n+    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config,\n+            JavaType type) {\n         return StdKeyDeserializer.StringKD.forType(type.getRawClass());\n     }\n     \n         return new StdKeyDeserializer.DelegatingKD(type.getRawClass(), deser);\n     }\n     \n-    public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type)\n+    public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config,\n+            JavaType type)\n     {\n         /* We don't need full deserialization information, just need to\n          * know creators.\n         // nope, no such luck...\n         return null;\n     }\n+    \n+    /*\n+    /**********************************************************\n+    /* KeyDeserializers implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public KeyDeserializer findKeyDeserializer(JavaType type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        Class<?> raw = type.getRawClass();\n+        // First, common types; String/Object/UUID, Int/Long, Dates\n+        if (raw == String.class || raw == Object.class) {\n+            return StdKeyDeserializer.StringKD.forType(raw);\n+        }\n+        if (raw == UUID.class) {\n+            return new StdKeyDeserializer.UuidKD();\n+        }\n+        if (raw == Integer.class) {\n+            return new StdKeyDeserializer.IntKD();\n+        }\n+        if (raw == Long.class) {\n+            return new StdKeyDeserializer.LongKD();\n+        }\n+        if (raw == Date.class) {\n+            return new StdKeyDeserializer.DateKD();\n+        }\n+        if (raw == Calendar.class) {\n+            return new StdKeyDeserializer.CalendarKD();\n+        }\n+        \n+        // then less common ones...\n+        if (raw == Boolean.class) {\n+            return new StdKeyDeserializer.BoolKD();\n+        }\n+        if (raw == Byte.class) {\n+            return new StdKeyDeserializer.ByteKD();\n+        }\n+        if (raw == Character.class) {\n+            return new StdKeyDeserializer.CharKD();\n+        }\n+        if (raw == Short.class) {\n+            return new StdKeyDeserializer.ShortKD();\n+        }\n+        if (raw == Float.class) {\n+            return new StdKeyDeserializer.FloatKD();\n+        }\n+        if (raw == Double.class) {\n+            return new StdKeyDeserializer.DoubleKD();\n+        }\n+        if (raw == Locale.class) {\n+            return new StdKeyDeserializer.LocaleKD();\n+        }\n+        return null;\n+    }\n }", "timestamp": 1366071605, "metainfo": ""}