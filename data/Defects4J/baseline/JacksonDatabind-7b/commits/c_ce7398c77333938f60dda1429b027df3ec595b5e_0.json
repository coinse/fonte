{"sha": "ce7398c77333938f60dda1429b027df3ec595b5e", "log": "Fix [JACKSON-839], issue-9", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n             if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue();\n             }\n-            return jp.getIntValue();\n+            /* and as per [JACKSON-839], allow \"upgrade\" to bigger types: out-of-range\n+             * entries can not be produced without type, so this should \"just work\",\n+             * even if it is bit unclean\n+             */\n+            return jp.getNumberValue();\n \n         case VALUE_NUMBER_FLOAT:\n             // For [JACKSON-72], see above\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n+\n+/**\n+ * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * one that only uses core JDK types; wrappers, Maps and Lists.\n+ */\n+public class TestUntypedDeserialization\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSampleDoc()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* To get \"untyped\" Mapping (to Maps, Lists, instead of beans etc),\n+         * we'll specify plain old Object.class as the target.\n+         */\n+        Object root = new ObjectMapper().readValue(jf.createJsonParser(new StringReader(JSON)), Object.class);\n+\n+        assertType(root, Map.class);\n+        Map<?,?> rootMap = (Map<?,?>) root;\n+        assertEquals(1, rootMap.size());\n+        Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();\n+        assertEquals(\"Image\", rootEntry.getKey());\n+        Object image = rootEntry.getValue();\n+        assertType(image, Map.class);\n+        Map<?,?> imageMap = (Map<?,?>) image;\n+        assertEquals(5, imageMap.size());\n+\n+        Object value = imageMap.get(\"Width\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);\n+\n+        value = imageMap.get(\"Height\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);\n+\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get(\"Title\"));\n+\n+        // Another Object, \"thumbnail\"\n+        value = imageMap.get(\"Thumbnail\");\n+        assertType(value, Map.class);\n+        Map<?,?> tnMap = (Map<?,?>) value;\n+        assertEquals(3, tnMap.size());\n+\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get(\"Height\"));\n+        // for some reason, width is textual, not numeric...\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get(\"Width\"));\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get(\"Url\"));\n+\n+        // And then number list, \"IDs\"\n+        value = imageMap.get(\"IDs\");\n+        assertType(value, List.class);\n+        List<Object> ids = (List<Object>) value;\n+        assertEquals(4, ids.size());\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));\n+\n+        // and that's all folks!\n+    }\n+\n+    // [JACKSON-839]: allow 'upgrade' of big integers into Long, BigInteger\n+    public void testObjectSerializeWithLong() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT, As.PROPERTY);\n+        final long VALUE = 1337800584532L;\n+\n+        String serialized = \"{\\\"timestamp\\\":\"+VALUE+\"}\";\n+        // works fine as node\n+        JsonNode deserialized = mapper.readTree(serialized);\n+        assertEquals(VALUE, deserialized.get(\"timestamp\").asLong());\n+        // and actually should work in Maps too\n+        Map<?,?> deserMap = mapper.readValue(serialized, Map.class);\n+        Number n = (Number) deserMap.get(\"timestamp\");\n+        assertNotNull(n);\n+        assertSame(Long.class, n.getClass());\n+        assertEquals(Long.valueOf(VALUE), n);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestUntypedSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * This unit test suite tries verify simplest aspects of\n+ * \"Native\" java type mapper; basically that is can properly serialize\n+ * core JDK objects to JSON.\n+ */\n+public class TestUntypedSerialization\n+    extends BaseMapTest\n+{\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ArrayList<Object> doc = new ArrayList<Object>();\n+        doc.add(\"Elem1\");\n+        doc.add(Integer.valueOf(3));\n+        Map<String,Object> struct = new LinkedHashMap<String, Object>();\n+        struct.put(\"first\", Boolean.TRUE);\n+        struct.put(\"Second\", new ArrayList<Object>());\n+        doc.add(struct);\n+        doc.add(Boolean.FALSE);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonFactory f =  new JsonFactory();\n+\n+        // loop more than once, just to ensure caching works ok (during second round)\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            \n+            JsonParser jp = f.createJsonParser(str);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"Elem1\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(3, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"first\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"Second\", getAndVerifyText(jp));\n+            \n+            if (jp.nextToken() != JsonToken.START_ARRAY) {\n+                fail(\"Expected START_ARRAY: JSON == '\"+str+\"'\");\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+            \n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        LinkedHashMap<String,Object> doc = new LinkedHashMap<String,Object>();\n+        JsonFactory f =  new JsonFactory();\n+\n+        doc.put(\"a1\", \"\\\"text\\\"\");\n+        doc.put(\"int\", Integer.valueOf(137));\n+        doc.put(\"foo bar\", Long.valueOf(1234567890L));\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            JsonParser jp = f.createJsonParser(str);\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"a1\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"\\\"text\\\"\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"int\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(137, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"foo bar\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1234567890L, jp.getLongValue());\n+            \n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+}", "timestamp": 1338435903, "metainfo": ""}