{"sha": "e3ae58e5bd6af6f68e70ad12561efef5a14807cd", "log": "Work on [JACKSON-707], [JACKSON-770]; simplifying JsonNode", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n \n     /**\n      * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig withFeatures(DeserializationConfig.Feature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (Feature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n      * object instance with specified feature disabled.\n      */\n     public DeserializationConfig without(DeserializationConfig.Feature feature)\n         return (newDeserFeatures == _deserFeatures) ? this :\n             new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n     }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig withoutFeatures(DeserializationConfig.Feature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (Feature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n     \n     /*\n     /**********************************************************\n     /* MapperConfig implementation\n     /**********************************************************\n      */\n-\n-    @Override\n-    public final int getFeatureFlags() {\n-        return _deserFeatures;\n-    }\n     \n     /**\n      * Method for getting {@link AnnotationIntrospector} configured\n     /**********************************************************\n      */\n \n+    public final int getDeserializationFeatures() {\n+        return _deserFeatures;\n+    }\n+    \n     /**\n      * Method for getting head of the problem handler chain. May be null,\n      * if no handlers have been added.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     protected DeserializationContext(DeserializationConfig config)\n     {\n         _config = config;\n-        _featureFlags = config.getFeatureFlags();\n+        _featureFlags = config.getDeserializationFeatures();\n         _view = config.getActiveView();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n import com.fasterxml.jackson.databind.ser.Serializers;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n \n /**\n          */\n         public <C extends ObjectCodec> C getOwner();\n \n+        /**\n+         * Accessor for finding {@link TypeFactory} that is currently configured\n+         * by the context.\n+         *<p>\n+         * NOTE: since it is possible that other modules might change or replace\n+         * TypeFactory, use of this method adds order-dependency for registrations.\n+         * \n+         * @since 2.0\n+         */\n+        public TypeFactory getTypeFactory();\n+        \n         public boolean isEnabled(MapperConfig.Feature f);\n         \n         public boolean isEnabled(DeserializationConfig.Feature f);\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n                 // why do we need the cast here?!?\n                 return (C) mapper;\n             }\n+\n+            @Override\n+            public TypeFactory getTypeFactory() {\n+                return _typeFactory;\n+            }\n             \n             @Override\n             public boolean isEnabled(MapperConfig.Feature f) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.StdDeserializationContext;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.NullNode;\n import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n /**\n \n     /**\n      * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader withFeatures(DeserializationConfig.Feature... features)\n+    {\n+        DeserializationConfig newConfig = _config.withFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    }    \n+    \n+    /**\n+     * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n     public ObjectReader without(DeserializationConfig.Feature feature) \n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n     }    \n \n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader withoutFeatures(DeserializationConfig.Feature... features)\n+    {\n+        DeserializationConfig newConfig = _config.withoutFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    }    \n+    \n     /**\n      * Method for constructing a new instance with configuration that uses\n      * passed {@link InjectableValues} to provide injectable values.\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withType(java.lang.reflect.Type valueType)\n-    {\n+    public ObjectReader withType(java.lang.reflect.Type valueType) {\n         return withType(_config.getTypeFactory().constructType(valueType));\n     }    \n \n     public ObjectReader withView(Class<?> activeView) {\n         DeserializationConfig newConfig = _config.withView(activeView);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Simple accessors\n+    /**********************************************************\n+     */\n+    \n+    public boolean isEnabled(DeserializationConfig.Feature f) {\n+        return _config.isEnabled(f);\n+    }\n+\n+    public boolean isEnabled(MapperConfig.Feature f) {\n+        return _config.isEnabled(f);\n+    }\n+\n+    public boolean isEnabled(JsonParser.Feature f) {\n+        return _jsonFactory.isEnabled(f);\n+    }\n+\n+    @Override\n+    public JsonFactory getJsonFactory() {\n+        return _jsonFactory;\n+    }\n+\n+    public TypeFactory getTypeFactory() {\n+        return _config.getTypeFactory();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Builder object that can be used for per-serialization configuration of\n     {\n         SerializationConfig newConfig = _config.with(feature);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n-    }    \n+    }\n \n     /**\n      * Method for constructing a new instance that is configured\n \n     /**\n      * Method for constructing a new instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectWriter withFeatures(SerializationConfig.Feature... features)\n+    {\n+        SerializationConfig newConfig = _config.withFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }    \n+    \n+    /**\n+     * Method for constructing a new instance that is configured\n      * with specified feature enabled.\n      */\n     public ObjectWriter without(SerializationConfig.Feature feature) \n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n     }    \n \n+    /**\n+     * Method for constructing a new instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectWriter withoutFeatures(SerializationConfig.Feature... features)\n+    {\n+        SerializationConfig newConfig = _config.withoutFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }    \n+    \n     /**\n      * Fluent factory method that will construct a new writer instance that will\n      * use specified date format for serializing dates; or if null passed, one\n         SerializationConfig newConfig = _config.withView(view);\n         return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n     }    \n+\n+    /*\n+    /**********************************************************\n+    /* Simple accessors\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(SerializationConfig.Feature f) {\n+        return _config.isEnabled(f);\n+    }\n+\n+    public boolean isEnabled(MapperConfig.Feature f) {\n+        return _config.isEnabled(f);\n+    }\n+\n+    public boolean isEnabled(JsonParser.Feature f) {\n+        return _jsonFactory.isEnabled(f);\n+    }\n+\n+    public JsonFactory getJsonFactory() {\n+        return _jsonFactory;\n+    }\n+    \n+    public TypeFactory getTypeFactory() {\n+        return _config.getTypeFactory();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n     \n     /**\n      * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public SerializationConfig withFeatures(Feature... features)\n+    {\n+        int newSerFeatures = _serFeatures;\n+        for (Feature f : features) {\n+            newSerFeatures |= f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n      * object instance with specified feature disabled.\n      */\n     public SerializationConfig without(Feature feature)\n                 : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n     }\n \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public SerializationConfig withoutFeatures(Feature... features)\n+    {\n+        int newSerFeatures = _serFeatures;\n+        for (Feature f : features) {\n+            newSerFeatures &= ~f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+    \n     public SerializationConfig withFilters(FilterProvider filterProvider) {\n         return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n     }\n     /* MapperConfig implementation/overrides\n     /**********************************************************\n      */\n-\n-    @Override\n-    public final int getFeatureFlags() {\n-        return _serFeatures;\n-    }\n     \n     @Override\n     public boolean useRootWrapping()\n         }\n         return vchecker;\n     }\n-\n-    public boolean isEnabled(SerializationConfig.Feature f) {\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: other\n+    /**********************************************************\n+     */\n+\n+    public final boolean isEnabled(SerializationConfig.Feature f) {\n         return (_serFeatures & f.getMask()) != 0;\n     }\n     \n-    /*\n-    /**********************************************************\n-    /* Configuration: other\n-    /**********************************************************\n-     */\n-\n+    public final int getSerializationFeatures() {\n+        return _serFeatures;\n+    }\n+    \n     public JsonInclude.Include getSerializationInclusion()\n     {\n         if (_serializationInclusion != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n     /* Simple accessors\n     /**********************************************************\n      */\n-\n-    public abstract int getFeatureFlags();\n-\n+    \n     /**\n      * Accessor for object used for finding out all reachable subtypes\n      * for supertypes; needed when a logical type name is used instead\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n \n     public ArrayNode(JsonNodeFactory nc) { super(nc); }\n \n+    protected ArrayNode(JsonNodeFactory nc,\n+            ArrayList<JsonNode> children) {\n+        super(nc);\n+        _children = children;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends JsonNode> T deepCopy() {\n+        if (_children == null) {\n+            return (T) new ArrayNode(_nodeFactory);\n+        }\n+        final int len = _children.size();\n+        ArrayList<JsonNode> newKids = new ArrayList<JsonNode>(Math.max(4, len));\n+        for (int i = 0; i < len; ++i) {\n+            newKids.add(_children.get(i).deepCopy());\n+        }\n+        return (T) new ArrayNode(_nodeFactory, newKids);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Implementation of core JsonNode API\n     }\n \n     @Override\n-    public Iterator<JsonNode> getElements()\n+    public Iterator<JsonNode> elements()\n     {\n         return (_children == null) ? NoNodesIterator.instance() : _children.iterator();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n      * value, if (and only if) node is a number node.\n      */\n     @Override\n-    public JsonParser.NumberType getNumberType() {\n+    public JsonParser.NumberType numberType() {\n         // most types non-numeric, so:\n         return null; \n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n     public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n \n     @Override\n-    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.BIG_INTEGER; }\n+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.BIG_INTEGER; }\n \n     @Override\n     public boolean isIntegralNumber() { return true; }\n     }\n     \n     @Override\n-    public Number getNumberValue() {\n+    public Number numberValue() {\n         return _value;\n     }\n \n     @Override\n-    public int getIntValue() { return _value.intValue(); }\n+    public int intValue() { return _value.intValue(); }\n \n     @Override\n-    public long getLongValue() { return _value.longValue(); }\n+    public long longValue() { return _value.longValue(); }\n \n     @Override\n-    public BigInteger getBigIntegerValue() { return _value; }\n+    public BigInteger bigIntegerValue() { return _value; }\n \n     @Override\n-    public double getDoubleValue() { return _value.doubleValue(); }\n+    public double doubleValue() { return _value.doubleValue(); }\n \n     @Override\n-    public BigDecimal getDecimalValue() { return new BigDecimal(_value); }\n+    public BigDecimal decimalValue() { return new BigDecimal(_value); }\n \n     /* \n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n      * it is not a copy but reference to the underlying byte array.\n      */\n     @Override\n-    public byte[] getBinaryValue() { return _data; }\n+    public byte[] binaryValue() { return _data; }\n \n     /**\n      * Hmmh. This is not quite as efficient as using {@link #serialize},\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java\n     public boolean isBoolean() { return true; }\n \n     @Override\n-    public boolean getBooleanValue() {\n+    public boolean booleanValue() {\n         return (this == TRUE);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n         _nodeFactory = nc;\n     }\n \n+    // all containers are mutable: can't define:\n+//    @Override public abstract <T extends JsonNode> T deepCopy();\n+    \n     @Override\n     public boolean isContainerNode() { return true; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n     @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }\n \n     @Override\n-    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.BIG_DECIMAL; }\n+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.BIG_DECIMAL; }\n \n     /* \n     /**********************************************************\n     }\n     \n     @Override\n-    public Number getNumberValue() { return _value; }\n+    public Number numberValue() { return _value; }\n \n     @Override\n-    public int getIntValue() { return _value.intValue(); }\n+    public int intValue() { return _value.intValue(); }\n \n     @Override\n-    public long getLongValue() { return _value.longValue(); }\n+    public long longValue() { return _value.longValue(); }\n \n \n     @Override\n-    public BigInteger getBigIntegerValue() { return _value.toBigInteger(); }\n+    public BigInteger bigIntegerValue() { return _value.toBigInteger(); }\n \n     @Override\n-    public double getDoubleValue() { return _value.doubleValue(); }\n+    public double doubleValue() { return _value.doubleValue(); }\n \n     @Override\n-    public BigDecimal getDecimalValue() { return _value; }\n+    public BigDecimal decimalValue() { return _value; }\n \n     @Override\n     public String asText() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n     @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }\n \n     @Override\n-    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.DOUBLE; }\n+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.DOUBLE; }\n \n     /* \n     /**********************************************************\n     }\n     \n     @Override\n-    public Number getNumberValue() {\n+    public Number numberValue() {\n         return Double.valueOf(_value);\n     }\n \n     @Override\n-        public int getIntValue() { return (int) _value; }\n+        public int intValue() { return (int) _value; }\n \n     @Override\n-        public long getLongValue() { return (long) _value; }\n+        public long longValue() { return (long) _value; }\n \n     @Override\n-        public double getDoubleValue() { return _value; }\n+        public double doubleValue() { return _value; }\n \n     @Override\n-        public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+        public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }\n \n     @Override\n-    public BigInteger getBigIntegerValue() {\n-        return getDecimalValue().toBigInteger();\n+    public BigInteger bigIntegerValue() {\n+        return decimalValue().toBigInteger();\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n     @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n \n     @Override\n-    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.INT; }\n+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.INT; }\n \n     /* \n     /**********************************************************\n     @Override public boolean canConvertToLong() { return true; }\n     \n     @Override\n-    public Number getNumberValue() {\n+    public Number numberValue() {\n         return Integer.valueOf(_value);\n     }\n \n     @Override\n-    public int getIntValue() { return _value; }\n+    public int intValue() { return _value; }\n \n     @Override\n-    public long getLongValue() { return (long) _value; }\n+    public long longValue() { return (long) _value; }\n \n     @Override\n-    public double getDoubleValue() { return (double) _value; }\n+    public double doubleValue() { return (double) _value; }\n \n     @Override\n-    public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+    public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }\n \n     @Override\n-    public BigInteger getBigIntegerValue() { return BigInteger.valueOf(_value); }\n+    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }\n \n     @Override\n     public String asText() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n     @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n \n     @Override\n-    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.LONG; }\n+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.LONG; }\n \n \n     @Override\n     @Override public boolean canConvertToLong() { return true; }\n     \n     @Override\n-    public Number getNumberValue() {\n+    public Number numberValue() {\n         return Long.valueOf(_value);\n     }\n \n     @Override\n-    public int getIntValue() { return (int) _value; }\n+    public int intValue() { return (int) _value; }\n \n     @Override\n-    public long getLongValue() { return _value; }\n+    public long longValue() { return _value; }\n \n     @Override\n-    public double getDoubleValue() { return (double) _value; }\n+    public double doubleValue() { return (double) _value; }\n \n     @Override\n-    public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+    public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }\n \n     @Override\n-    public BigInteger getBigIntegerValue() { return BigInteger.valueOf(_value); }\n+    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }\n \n     @Override\n     public String asText() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-\n \n /**\n  * This singleton node class is generated to denote \"missing nodes\"\n \n     private MissingNode() { }\n \n+    // Immutable: no need to copy\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends JsonNode> T deepCopy() { return (T) this; }\n+    \n     public static MissingNode getInstance() { return instance; }\n \n     @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n \n         public Array(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ARRAY, p);\n-            _contents = n.getElements();\n+            _contents = n.elements();\n         }\n \n         @Override\n         public Object(JsonNode n, NodeCursor p)\n         {\n             super(JsonStreamContext.TYPE_OBJECT, p);\n-            _contents = ((ObjectNode) n).getFields();\n+            _contents = ((ObjectNode) n).fields();\n             _needEntry = true;\n         }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n     // // // Let's re-abstract so sub-classes handle them\n \n     @Override\n-    public abstract JsonParser.NumberType getNumberType();\n+    public abstract JsonParser.NumberType numberType();\n \n-    @Override\n-    public abstract Number getNumberValue();\n-    @Override\n-    public abstract int getIntValue();\n-    @Override\n-    public abstract long getLongValue();\n-    @Override\n-    public abstract double getDoubleValue();\n-    @Override\n-    public abstract BigDecimal getDecimalValue();\n-    @Override\n-    public abstract BigInteger getBigIntegerValue();\n+    @Override public abstract Number numberValue();\n+    @Override public abstract int intValue();\n+    @Override public abstract long longValue();\n+    @Override public abstract double doubleValue();\n+    @Override public abstract BigDecimal decimalValue();\n+    @Override public abstract BigInteger bigIntegerValue();\n \n     @Override public abstract boolean canConvertToInt();\n     @Override public abstract boolean canConvertToLong();\n \n     @Override\n     public int asInt() {\n-        return getIntValue();\n+        return intValue();\n     }\n     @Override\n     public int asInt(int defaultValue) {\n-        return getIntValue();\n+        return intValue();\n     }\n \n     @Override\n     public long asLong() {\n-        return getLongValue();\n+        return longValue();\n     }\n     @Override\n     public long asLong(long defaultValue) {\n-        return getLongValue();\n+        return longValue();\n     }\n     \n     @Override\n     public double asDouble() {\n-        return getDoubleValue();\n+        return doubleValue();\n     }\n     @Override\n     public double asDouble(double defaultValue) {\n-        return getDoubleValue();\n+        return doubleValue();\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n     protected LinkedHashMap<String, JsonNode> _children = null;\n \n     public ObjectNode(JsonNodeFactory nc) { super(nc); }\n+\n+    protected ObjectNode(JsonNodeFactory nc, LinkedHashMap<String, JsonNode> children) {\n+        super(nc);\n+        _children = children;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends JsonNode> T deepCopy()\n+    {\n+        if (_children == null) {\n+            return (T) new ObjectNode(_nodeFactory);\n+        }\n+        final int len = _children.size();\n+        LinkedHashMap<String, JsonNode> newKids = new LinkedHashMap<String, JsonNode>(Math.max(4, len));\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            newKids.put(entry.getKey(), entry.getValue().deepCopy());\n+        }\n+        return (T) new ObjectNode(_nodeFactory, newKids);\n+    }\n     \n     /*\n     /**********************************************************\n     }\n \n     @Override\n-    public Iterator<JsonNode> getElements()\n+    public Iterator<JsonNode> elements()\n     {\n         return (_children == null) ? NoNodesIterator.instance() : _children.values().iterator();\n     }\n     }\n \n     @Override\n-    public Iterator<String> getFieldNames()\n-    {\n+    public Iterator<String> fieldNames() {\n         return (_children == null) ? NoStringsIterator.instance() : _children.keySet().iterator();\n     }\n \n      * and values) of this JSON Object.\n      */\n     @Override\n-    public Iterator<Map.Entry<String, JsonNode>> getFields()\n+    public Iterator<Map.Entry<String, JsonNode>> fields()\n     {\n         if (_children == null) {\n             return NoFieldsIterator.instance;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n     public boolean isTextual() { return true; }\n \n     @Override\n-    public String getTextValue() {\n+    public String textValue() {\n         return _value;\n     }\n \n     }\n \n     @Override\n-    public byte[] getBinaryValue() throws IOException\n+    public byte[] binaryValue() throws IOException\n     {\n         return getBinaryValue(Base64Variants.getDefaultVariant());\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n         case FIELD_NAME:\n             return _nodeCursor.getCurrentName();\n         case VALUE_STRING:\n-            return currentNode().getTextValue();\n+            return currentNode().textValue();\n         case VALUE_NUMBER_INT:\n         case VALUE_NUMBER_FLOAT:\n-            return String.valueOf(currentNode().getNumberValue());\n+            return String.valueOf(currentNode().numberValue());\n         case VALUE_EMBEDDED_OBJECT:\n             JsonNode n = currentNode();\n             if (n != null && n.isBinary()) {\n     @Override\n     public NumberType getNumberType() throws IOException, JsonParseException {\n         JsonNode n = currentNumericNode();\n-        return (n == null) ? null : n.getNumberType();\n+        return (n == null) ? null : n.numberType();\n     }\n \n     @Override\n     public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n     {\n-        return currentNumericNode().getBigIntegerValue();\n+        return currentNumericNode().bigIntegerValue();\n     }\n \n     @Override\n     public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n-        return currentNumericNode().getDecimalValue();\n+        return currentNumericNode().decimalValue();\n     }\n \n     @Override\n     public double getDoubleValue() throws IOException, JsonParseException {\n-        return currentNumericNode().getDoubleValue();\n+        return currentNumericNode().doubleValue();\n     }\n \n     @Override\n     public float getFloatValue() throws IOException, JsonParseException {\n-        return (float) currentNumericNode().getDoubleValue();\n+        return (float) currentNumericNode().doubleValue();\n     }\n \n     @Override\n     public long getLongValue() throws IOException, JsonParseException {\n-        return currentNumericNode().getLongValue();\n+        return currentNumericNode().longValue();\n     }\n \n     @Override\n     public int getIntValue() throws IOException, JsonParseException {\n-        return currentNumericNode().getIntValue();\n+        return currentNumericNode().intValue();\n     }\n \n     @Override\n     public Number getNumberValue() throws IOException, JsonParseException {\n-        return currentNumericNode().getNumberValue();\n+        return currentNumericNode().numberValue();\n     }\n \n     @Override\n                     return ((POJONode) n).getPojo();\n                 }\n                 if (n.isBinary()) {\n-                    return ((BinaryNode) n).getBinaryValue();\n+                    return ((BinaryNode) n).binaryValue();\n                 }\n             }\n         }\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) { // binary node?\n-            byte[] data = n.getBinaryValue();\n+            byte[] data = n.binaryValue();\n             // (or TextNode, which can also convert automatically!)\n             if (data != null) {\n                 return data;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n {\n     protected ValueNode() { }\n \n-    @Override\n-    public boolean isValueNode() { return true; }\n+    /**\n+     * All current value nodes are immutable, so we can just return\n+     * them as is.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends JsonNode> T deepCopy() { return (T) this; }\n+    \n+    @Override public boolean isValueNode() { return true; }\n \n-    @Override\n-    public abstract JsonToken asToken();\n+    @Override public abstract JsonToken asToken();\n \n     @Override\n     public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n--- a/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n         this(prefix, suffix, value, (JavaType) null);\n     }\n \n+    /**\n+     * Constructor that should be used when specific serialization type to use\n+     * is important, and needs to be passed instead of just using runtime\n+     * (type-erased) type of the value.\n+     */\n     public JSONWrappedObject(String prefix, String suffix, Object value, JavaType asType)\n     {\n         _prefix = prefix;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n             jp.close();\n             assertTrue(root.isArray());\n             assertEquals(3, root.size());\n-            assertEquals(1, root.get(0).getIntValue());\n-            assertEquals(2, root.get(1).getIntValue());\n-            assertFalse(root.get(2).getBooleanValue());\n+            assertEquals(1, root.get(0).intValue());\n+            assertEquals(2, root.get(1).intValue());\n+            assertFalse(root.get(2).booleanValue());\n         }\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n \n \tObjectNode root = jsonSchema.getSchemaNode();\n         assertEquals(\"object\", root.get(\"type\").asText());\n-        assertEquals(false, root.path(\"required\").getBooleanValue());\n+        assertEquals(false, root.path(\"required\").booleanValue());\n         JsonNode propertiesSchema = root.get(\"properties\");\n         assertNotNull(propertiesSchema);\n         JsonNode property1Schema = propertiesSchema.get(\"property1\");\n         assertNotNull(property1Schema);\n         assertEquals(\"integer\", property1Schema.get(\"type\").asText());\n-        assertEquals(false, property1Schema.path(\"required\").getBooleanValue());\n+        assertEquals(false, property1Schema.path(\"required\").booleanValue());\n         JsonNode property2Schema = propertiesSchema.get(\"property2\");\n         assertNotNull(property2Schema);\n         assertEquals(\"string\", property2Schema.get(\"type\").asText());\n-        assertEquals(false, property2Schema.path(\"required\").getBooleanValue());\n+        assertEquals(false, property2Schema.path(\"required\").booleanValue());\n         JsonNode property3Schema = propertiesSchema.get(\"property3\");\n         assertNotNull(property3Schema);\n         assertEquals(\"array\", property3Schema.get(\"type\").asText());\n-        assertEquals(false, property3Schema.path(\"required\").getBooleanValue());\n+        assertEquals(false, property3Schema.path(\"required\").booleanValue());\n         assertEquals(\"string\", property3Schema.get(\"items\").get(\"type\").asText());\n         JsonNode property4Schema = propertiesSchema.get(\"property4\");\n         assertNotNull(property4Schema);\n         assertEquals(\"array\", property4Schema.get(\"type\").asText());\n-        assertEquals(false, property4Schema.path(\"required\").getBooleanValue());\n+        assertEquals(false, property4Schema.path(\"required\").booleanValue());\n         assertEquals(\"number\", property4Schema.get(\"items\").get(\"type\").asText());\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestArrayNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestArrayNode.java\n     {\n         ArrayNode n = new ArrayNode(JsonNodeFactory.instance);\n         assertStandardEquals(n);\n-        assertFalse(n.getElements().hasNext());\n-        assertFalse(n.getFieldNames().hasNext());\n+        assertFalse(n.elements().hasNext());\n+        assertFalse(n.fieldNames().hasNext());\n         TextNode text = TextNode.valueOf(\"x\");\n         n.add(text);\n         assertEquals(1, n.size());\n         assertFalse(0 == n.hashCode());\n-        assertTrue(n.getElements().hasNext());\n+        assertTrue(n.elements().hasNext());\n         // no field names for arrays\n-        assertFalse(n.getFieldNames().hasNext());\n+        assertFalse(n.fieldNames().hasNext());\n         assertNull(n.get(\"x\")); // not used with arrays\n         assertTrue(n.path(\"x\").isMissingNode());\n         assertSame(text, n.get(0));\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n         {\n             JsonNode tree = jp.readValueAsTree();\n             Leaf leaf = new Leaf();\n-            leaf.value = tree.get(\"value\").getIntValue();\n+            leaf.value = tree.get(\"value\").intValue();\n             return leaf;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestFindMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestFindMethods.java\n \n         JsonNode node = root.findValue(\"b\");\n         assertNotNull(node);\n-        assertEquals(3, node.getIntValue());\n+        assertEquals(3, node.intValue());\n         node = root.findParent(\"b\");\n         assertNotNull(node);\n         assertTrue(node.isObject());\n         assertEquals(1, ((ObjectNode) node).size());\n-        assertEquals(3, node.path(\"b\").getIntValue());\n+        assertEquals(3, node.path(\"b\").intValue());\n     }\n \n     public void testMatchingMultiple() throws Exception\n         List<JsonNode> nodes = root.findValues(\"value\");\n         assertEquals(2, nodes.size());\n         // here we count on nodes being returned in order; true with Jackson:\n-        assertEquals(3, nodes.get(0).getIntValue());\n-        assertEquals(42, nodes.get(1).getIntValue());\n+        assertEquals(3, nodes.get(0).intValue());\n+        assertEquals(42, nodes.get(1).intValue());\n \n         nodes = root.findParents(\"value\");\n         assertEquals(2, nodes.size());\n         // should only return JSON Object nodes:\n         assertTrue(nodes.get(0).isObject());\n         assertTrue(nodes.get(1).isObject());\n-        assertEquals(3, nodes.get(0).path(\"value\").getIntValue());\n-        assertEquals(42, nodes.get(1).path(\"value\").getIntValue());\n+        assertEquals(3, nodes.get(0).path(\"value\").intValue());\n+        assertEquals(42, nodes.get(1).path(\"value\").intValue());\n \n         // and finally, convenience conversion method\n         List<String> values = root.findValuesAsText(\"value\");\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n         assertFalse(n.isMissingNode());\n \n         // fallback accessors\n-        assertFalse(n.getBooleanValue());\n-        assertNull(n.getNumberValue());\n-        assertEquals(0, n.getIntValue());\n-        assertEquals(0L, n.getLongValue());\n-        assertEquals(BigDecimal.ZERO, n.getDecimalValue());\n-        assertEquals(BigInteger.ZERO, n.getBigIntegerValue());\n+        assertFalse(n.booleanValue());\n+        assertNull(n.numberValue());\n+        assertEquals(0, n.intValue());\n+        assertEquals(0L, n.longValue());\n+        assertEquals(BigDecimal.ZERO, n.decimalValue());\n+        assertEquals(BigInteger.ZERO, n.bigIntegerValue());\n \n         assertEquals(0, n.size());\n-        assertFalse(n.getElements().hasNext());\n-        assertFalse(n.getFieldNames().hasNext());\n+        assertFalse(n.elements().hasNext());\n+        assertFalse(n.fieldNames().hasNext());\n         // path is never null; but does point to missing node\n         assertNotNull(n.path(\"xyz\"));\n         assertTrue(n.path(\"xyz\").isMissingNode());\n         assertTrue(f.isBoolean());\n         assertSame(f, BooleanNode.valueOf(false));\n         assertStandardEquals(f);\n-        assertFalse(f.getBooleanValue());\n+        assertFalse(f.booleanValue());\n         assertEquals(\"false\", f.asText());\n         assertEquals(JsonToken.VALUE_FALSE, f.asToken());\n \n         assertTrue(t.isBoolean());\n         assertSame(t, BooleanNode.valueOf(true));\n         assertStandardEquals(t);\n-        assertTrue(t.getBooleanValue());\n+        assertTrue(t.booleanValue());\n         assertEquals(\"true\", t.asText());\n         assertEquals(JsonToken.VALUE_TRUE, t.asToken());\n \n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n         assertStandardEquals(n);\n         assertTrue(0 != n.hashCode());\n         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n-        assertEquals(JsonParser.NumberType.INT, n.getNumberType());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n-        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(JsonParser.NumberType.INT, n.numberType());\n+        assertEquals(1, n.intValue());\n+        assertEquals(1L, n.longValue());\n+        assertEquals(BigDecimal.ONE, n.decimalValue());\n+        assertEquals(BigInteger.ONE, n.bigIntegerValue());\n         assertEquals(\"1\", n.asText());\n \n         assertNodeNumbers(n, 1, 1.0);\n         assertStandardEquals(n);\n         assertTrue(0 != n.hashCode());\n         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n-        assertEquals(JsonParser.NumberType.LONG, n.getNumberType());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n-        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(JsonParser.NumberType.LONG, n.numberType());\n+        assertEquals(1, n.intValue());\n+        assertEquals(1L, n.longValue());\n+        assertEquals(BigDecimal.ONE, n.decimalValue());\n+        assertEquals(BigInteger.ONE, n.bigIntegerValue());\n         assertEquals(\"1\", n.asText());\n \n         assertNodeNumbers(n, 1, 1.0);\n         assertStandardEquals(n);\n         assertTrue(0 != n.hashCode());\n         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n-        assertEquals(JsonParser.NumberType.DOUBLE, n.getNumberType());\n-        assertEquals(0, n.getIntValue());\n-        assertEquals(0.25, n.getDoubleValue());\n-        assertNotNull(n.getDecimalValue());\n-        assertEquals(BigInteger.ZERO, n.getBigIntegerValue());\n+        assertEquals(JsonParser.NumberType.DOUBLE, n.numberType());\n+        assertEquals(0, n.intValue());\n+        assertEquals(0.25, n.doubleValue());\n+        assertNotNull(n.decimalValue());\n+        assertEquals(BigInteger.ZERO, n.bigIntegerValue());\n         assertEquals(\"0.25\", n.asText());\n \n         // 1.6:\n         assertStandardEquals(n);\n         assertTrue(n.equals(new DecimalNode(BigDecimal.ONE)));\n         assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n-        assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.getNumberType());\n+        assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.numberType());\n         assertTrue(n.isNumber());\n         assertFalse(n.isIntegralNumber());\n         assertTrue(n.isBigDecimal());\n-        assertEquals(BigDecimal.ONE, n.getNumberValue());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(BigDecimal.ONE, n.numberValue());\n+        assertEquals(1, n.intValue());\n+        assertEquals(1L, n.longValue());\n+        assertEquals(BigDecimal.ONE, n.decimalValue());\n         assertEquals(\"1\", n.asText());\n \n         // 1.6:\n         assertStandardEquals(n);\n         assertTrue(n.equals(new BigIntegerNode(BigInteger.ONE)));\n         assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n-        assertEquals(JsonParser.NumberType.BIG_INTEGER, n.getNumberType());\n+        assertEquals(JsonParser.NumberType.BIG_INTEGER, n.numberType());\n         assertTrue(n.isNumber());\n         assertTrue(n.isIntegralNumber());\n         assertTrue(n.isBigInteger());\n-        assertEquals(BigInteger.ONE, n.getNumberValue());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(BigInteger.ONE, n.numberValue());\n+        assertEquals(1, n.intValue());\n+        assertEquals(1L, n.longValue());\n+        assertEquals(BigInteger.ONE, n.bigIntegerValue());\n         assertEquals(\"1\", n.asText());\n         \n         // 1.6:\n         BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);\n         \n         n = BigIntegerNode.valueOf(maxLong);\n-        assertEquals(Long.MAX_VALUE, n.getLongValue());\n+        assertEquals(Long.MAX_VALUE, n.longValue());\n \n         ObjectMapper mapper = new ObjectMapper();\n         JsonNode n2 = mapper.readTree(maxLong.toString());\n-        assertEquals(Long.MAX_VALUE, n2.getLongValue());\n+        assertEquals(Long.MAX_VALUE, n2.longValue());\n \n         // then over long limit:\n         BigInteger beyondLong = maxLong.shiftLeft(2); // 4x max long\n         n2 = mapper.readTree(beyondLong.toString());\n-        assertEquals(beyondLong, n2.getBigIntegerValue());\n+        assertEquals(beyondLong, n2.bigIntegerValue());\n \n         assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToInt());\n         assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MAX_VALUE)).canConvertToInt());\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n         ObjectNode n = new ObjectNode(JsonNodeFactory.instance);\n         assertStandardEquals(n);\n \n-        assertFalse(n.getElements().hasNext());\n-        assertFalse(n.getFields().hasNext());\n-        assertFalse(n.getFieldNames().hasNext());\n+        assertFalse(n.elements().hasNext());\n+        assertFalse(n.fields().hasNext());\n+        assertFalse(n.fieldNames().hasNext());\n         assertNull(n.get(\"a\"));\n         assertTrue(n.path(\"a\").isMissingNode());\n \n         TextNode text = TextNode.valueOf(\"x\");\n         n.put(\"a\", text);\n         assertEquals(1, n.size());\n-        assertTrue(n.getElements().hasNext());\n-        assertTrue(n.getFields().hasNext());\n-        assertTrue(n.getFieldNames().hasNext());\n+        assertTrue(n.elements().hasNext());\n+        assertTrue(n.fields().hasNext());\n+        assertTrue(n.fieldNames().hasNext());\n         assertSame(text, n.get(\"a\"));\n         assertSame(text, n.path(\"a\"));\n         assertNull(n.get(\"b\"));\n         assertEquals(3, ob.size());\n         assertSame(ob, ob.remove(Arrays.asList(\"a\", \"c\")));\n         assertEquals(1, ob.size());\n-        assertEquals(\"b\", ob.get(\"b\").getTextValue());\n+        assertEquals(\"b\", ob.get(\"b\").textValue());\n     }\n \n     public void testRetain()\n         assertEquals(3, ob.size());\n         assertSame(ob, ob.retain(\"a\", \"c\"));\n         assertEquals(2, ob.size());\n-        assertEquals(\"a\", ob.get(\"a\").getTextValue());\n+        assertEquals(\"a\", ob.get(\"a\").textValue());\n         assertNull(ob.get(\"b\"));\n-        assertEquals(\"c\", ob.get(\"c\").getTextValue());\n+        assertEquals(\"c\", ob.get(\"c\").textValue());\n     }\n \n     // @since 1.8\n--- a/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeDeserialization.java\n         assertNotNull(n);\n         assertEquals(1, n.size());\n         ObjectNode on = (ObjectNode) n;\n-        assertEquals(3, on.get(\"a\").getIntValue());\n+        assertEquals(3, on.get(\"a\").intValue());\n     }\n \n     /// Verifying [JACKSON-143]\n--- a/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperDeserializer.java\n             assertTrue(result.isObject());\n             \n             ObjectNode main = (ObjectNode) result;\n-            assertEquals(\"Image\", main.getFieldNames().next());\n-            JsonNode ob = main.getElements().next();\n+            assertEquals(\"Image\", main.fieldNames().next());\n+            JsonNode ob = main.elements().next();\n             assertType(ob, ObjectNode.class);\n             ObjectNode imageMap = (ObjectNode) ob;\n             \n             ob = imageMap.get(\"Width\");\n             assertTrue(ob.isIntegralNumber());\n             assertFalse(ob.isFloatingPointNumber());\n-            assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.getIntValue());\n+            assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.intValue());\n             ob = imageMap.get(\"Height\");\n             assertTrue(ob.isIntegralNumber());\n-            assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.getIntValue());\n+            assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.intValue());\n             \n             ob = imageMap.get(\"Title\");\n             assertTrue(ob.isTextual());\n-            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.getTextValue());\n+            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.textValue());\n             \n             ob = imageMap.get(\"Thumbnail\");\n             assertType(ob, ObjectNode.class);\n             ObjectNode tn = (ObjectNode) ob;\n             ob = tn.get(\"Url\");\n             assertTrue(ob.isTextual());\n-            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.getTextValue());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.textValue());\n             ob = tn.get(\"Height\");\n             assertTrue(ob.isIntegralNumber());\n-            assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.getIntValue());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.intValue());\n             ob = tn.get(\"Width\");\n             assertTrue(ob.isTextual());\n-            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.getTextValue());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.textValue());\n             \n             ob = imageMap.get(\"IDs\");\n             assertTrue(ob.isArray());\n             ArrayNode idList = (ArrayNode) ob;\n             assertEquals(4, idList.size());\n-            assertEquals(4, calcLength(idList.getElements()));\n+            assertEquals(4, calcLength(idList.elements()));\n             assertEquals(4, calcLength(idList.iterator()));\n             {\n                 int[] values = new int[] {\n                     SAMPLE_SPEC_VALUE_TN_ID4\n                 };\n                 for (int i = 0; i < values.length; ++i) {\n-                    assertEquals(values[i], idList.get(i).getIntValue());\n+                    assertEquals(values[i], idList.get(i).intValue());\n                 }\n                 int i = 0;\n                 for (JsonNode n : idList) {\n-                    assertEquals(values[i], n.getIntValue());\n+                    assertEquals(values[i], n.intValue());\n                     ++i;\n                 }\n             }\n         assertFalse(result.isTextual());\n         assertTrue(result.isBoolean());\n         assertType(result, BooleanNode.class);\n-        assertTrue(result.getBooleanValue());\n+        assertTrue(result.booleanValue());\n         assertEquals(\"true\", result.asText());\n         assertFalse(result.isMissingNode());\n \n         assertFalse(result.isTextual());\n         assertFalse(result.isMissingNode());\n \n-        assertEquals(value, result.getDoubleValue());\n-        assertEquals(value, result.getNumberValue().doubleValue());\n-        assertEquals((int) value, result.getIntValue());\n-        assertEquals((long) value, result.getLongValue());\n+        assertEquals(value, result.doubleValue());\n+        assertEquals(value, result.numberValue().doubleValue());\n+        assertEquals((int) value, result.intValue());\n+        assertEquals((long) value, result.longValue());\n         assertEquals(String.valueOf(value), result.asText());\n \n         // also, equality should work ok\n         assertFalse(result.isTextual());\n         assertFalse(result.isMissingNode());\n \n-        assertEquals(value, result.getNumberValue().intValue());\n-        assertEquals(value, result.getIntValue());\n+        assertEquals(value, result.numberValue().intValue());\n+        assertEquals(value, result.intValue());\n         assertEquals(String.valueOf(value), result.asText());\n-        assertEquals((double) value, result.getDoubleValue());\n-        assertEquals((long) value, result.getLongValue());\n+        assertEquals((double) value, result.doubleValue());\n+        assertEquals((long) value, result.longValue());\n \n         // also, equality should work ok\n         assertEquals(result, IntNode.valueOf(value));\n         assertFalse(result.isTextual());\n         assertFalse(result.isMissingNode());\n \n-        assertEquals(value, result.getNumberValue().longValue());\n-        assertEquals(value, result.getLongValue());\n+        assertEquals(value, result.numberValue().longValue());\n+        assertEquals(value, result.longValue());\n         assertEquals(String.valueOf(value), result.asText());\n-        assertEquals((double) value, result.getDoubleValue());\n+        assertEquals((double) value, result.doubleValue());\n \n         // also, equality should work ok\n         assertEquals(result, LongNode.valueOf(value));\n         assertFalse(result.isTextual());\n         assertFalse(result.isMissingNode());\n \n-        assertEquals(value, result.getNumberValue());\n+        assertEquals(value, result.numberValue());\n         assertEquals(value.toString(), result.asText());\n \n         // also, equality should work ok\n         assertTrue(result.isIntegralNumber());\n         assertTrue(result.isInt());\n         assertFalse(result.isTextual());\n-        assertEquals(12, result.getIntValue());\n+        assertEquals(12, result.intValue());\n \n         result = mapper.readTree(jp);\n         assertTrue(result.isTextual());\n         assertFalse(result.isIntegralNumber());\n         assertFalse(result.isInt());\n-        assertEquals(\"string\", result.getTextValue());\n+        assertEquals(\"string\", result.textValue());\n \n         result = mapper.readTree(jp);\n         assertTrue(result.isArray());\n         assertTrue(onode.isObject());\n         assertEquals(0, onode.size());\n         assertFalse(onode.isMissingNode()); // real node\n-        assertNull(onode.getTextValue());\n+        assertNull(onode.textValue());\n \n         // how about dereferencing?\n         assertNull(onode.get(0));\n--- a/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperMaps.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperMaps.java\n \n         // Ok, then, let's traverse via extended interface\n         ObjectNode obNode = (ObjectNode) root;\n-        Iterator<Map.Entry<String,JsonNode>> fit = obNode.getFields();\n+        Iterator<Map.Entry<String,JsonNode>> fit = obNode.fields();\n         // we also know that LinkedHashMap is used, i.e. order preserved\n         assertTrue(fit.hasNext());\n         Map.Entry<String,JsonNode> en = fit.next();\n         JsonNode rnode = root.path(\"results\");\n         assertNotNull(rnode);\n         assertTrue(rnode.isObject());\n-        assertEquals(3, rnode.path(\"a\").getIntValue());\n+        assertEquals(3, rnode.path(\"a\").intValue());\n     }\n \n }", "timestamp": 1327820896, "metainfo": ""}