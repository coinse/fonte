{"sha": "6679caeac9198802d271f8659017bb63eebd615f", "log": "Further simplification; eliminated StdSerializerProvider", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n                     _subtypeResolver, _mixInAnnotations);\n         _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n-        _serializerProvider = (sp == null) ? new StdSerializerProvider.Impl() : sp;\n+        _serializerProvider = (sp == null) ? new SerializerProvider.Impl() : sp;\n         _deserializerCache = (dp == null) ? new DeserializerCache(BeanDeserializerFactory.instance) : dp;\n \n         // Default serializer factory is stateless, can just assign\n         if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, config);\n         } else {\n-            _serializerProvider.serializeValue(config, jgen, value, _serializerFactory);\n+            _serializerProvider(config).serializeValue(jgen, value);\n             if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         throws IOException, JsonProcessingException\n     {\n         SerializationConfig config = getSerializationConfig();\n-        _serializerProvider.serializeValue(config, jgen, rootNode, _serializerFactory);\n+        _serializerProvider(config).serializeValue(jgen, rootNode);\n         if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n             jgen.flush();\n         }\n      *  given class (potentially serializable), false otherwise (not\n      *  serializable)\n      */\n-    public boolean canSerialize(Class<?> type)\n-    {\n-        return _serializerProvider.hasSerializerFor(getSerializationConfig(),\n-                type, _serializerFactory);\n+    public boolean canSerialize(Class<?> type) {\n+        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type);\n     }\n \n     /**\n             // first: disable wrapping when writing\n             SerializationConfig config = getSerializationConfig().without(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n             // no need to check for closing of TokenBuffer\n-            _serializerProvider.serializeValue(config, buf, fromValue, _serializerFactory);\n+            _serializerProvider(config).serializeValue(buf, fromValue);\n \n             // then matching read, inlined 'readValue' with minor mods:\n             final JsonParser jp = buf.asParser();\n      * @param t The class to generate schema for\n      * @return Constructed JSON schema.\n      */\n-    public JsonSchema generateJsonSchema(Class<?> t)\n-            throws JsonMappingException\n-    {\n-        return generateJsonSchema(t, getSerializationConfig());\n-    }\n-\n-    /**\n-     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n-     * instance for specified class, using specific\n-     * serialization configuration\n-     *\n-     * @param t The class to generate schema for\n-     * @return Constructed JSON schema.\n-     */\n-    public JsonSchema generateJsonSchema(Class<?> t, SerializationConfig cfg)\n-            throws JsonMappingException\n-    {\n-        return _serializerProvider.generateJsonSchema(t, cfg, _serializerFactory);\n+    public JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n+        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n     }\n \n     /*\n     /**********************************************************\n      */\n \n+    /**\n+     * Overridable helper method used for constructing\n+     * {@link SerializerProvider} to use for serialization.\n+     */\n+    protected SerializerProvider _serializerProvider(SerializationConfig config) {\n+        return _serializerProvider.createInstance(config, _serializerFactory);\n+    }\n+    \n     /**\n      * Helper method that should return default pretty-printer to\n      * use for generators constructed by this mapper, when instructed\n         }\n         boolean closed = false;\n         try {\n-            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            _serializerProvider(cfg).serializeValue(jgen, value);\n             closed = true;\n             jgen.close();\n         } finally {\n         }\n         boolean closed = false;\n         try {\n-            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            _serializerProvider(cfg).serializeValue(jgen, value);\n             closed = true;\n             jgen.close();\n         } finally {\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            _serializerProvider(cfg).serializeValue(jgen, value);\n             JsonGenerator tmpJgen = jgen;\n             jgen = null;\n             tmpJgen.close();\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            _serializerProvider(cfg).serializeValue(jgen, value);\n             if (cfg.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n      */\n     protected final SerializationConfig _config;\n    \n-    protected final SerializerProvider _provider;\n+    protected final SerializerProvider _serializerProvider;\n \n     protected final SerializerFactory _serializerFactory;\n \n     {\n         _config = config;\n \n-        _provider = mapper._serializerProvider;\n+        _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _jsonFactory = mapper._jsonFactory;\n \n     {\n         _config = config;\n \n-        _provider = mapper._serializerProvider;\n+        _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _jsonFactory = mapper._jsonFactory;\n \n     {\n         _config = config;\n \n-        _provider = mapper._serializerProvider;\n+        _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _jsonFactory = mapper._jsonFactory;\n \n     {\n         _config = config;\n \n-        _provider = base._provider;\n+        _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         _jsonFactory = base._jsonFactory;\n         \n     {\n         _config = config;\n \n-        _provider = base._provider;\n+        _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         _jsonFactory = base._jsonFactory;\n         _schema = base._schema;\n             _writeCloseableValue(jgen, value, _config);\n         } else {\n             if (_rootType == null) {\n-                _provider.serializeValue(_config, jgen, value, _serializerFactory);\n+                _serializerProvider(_config).serializeValue(jgen, value);\n             } else {\n-                _provider.serializeValue(_config, jgen, value, _rootType, _serializerFactory);\n+                _serializerProvider(_config).serializeValue(jgen, value, _rootType);\n             }\n             if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n     /**********************************************************\n      */\n \n-    public boolean canSerialize(Class<?> type)\n-    {\n-        return _provider.hasSerializerFor(_config, type, _serializerFactory);\n-    }\n-\n+    public boolean canSerialize(Class<?> type) {\n+        return _serializerProvider(_config).hasSerializerFor(type);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Overridable helper method used for constructing\n+     * {@link SerializerProvider} to use for serialization.\n+     */\n+    protected SerializerProvider _serializerProvider(SerializationConfig config) {\n+        return _serializerProvider.createInstance(config, _serializerFactory);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods\n         boolean closed = false;\n         try {\n             if (_rootType == null) {\n-                _provider.serializeValue(_config, jgen, value, _serializerFactory);\n+                _serializerProvider(_config).serializeValue(jgen, value);\n             } else {\n-                _provider.serializeValue(_config, jgen, value, _rootType, _serializerFactory);                \n+                _serializerProvider(_config).serializeValue(jgen, value, _rootType);                \n             }\n             closed = true;\n             jgen.close();\n         Closeable toClose = (Closeable) value;\n         try {\n             if (_rootType == null) {\n-                _provider.serializeValue(cfg, jgen, value, _serializerFactory);\n+                _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n-                _provider.serializeValue(cfg, jgen, value, _rootType, _serializerFactory);\n+                _serializerProvider(cfg).serializeValue(jgen, value);\n             }\n             // [JACKSON-520]: add support for pass-through schema:\n             if (_schema != null) {\n         Closeable toClose = (Closeable) value;\n         try {\n             if (_rootType == null) {\n-                _provider.serializeValue(cfg, jgen, value, _serializerFactory);\n+                _serializerProvider(cfg).serializeValue(jgen, value);\n             } else {\n-                _provider.serializeValue(cfg, jgen, value, _rootType, _serializerFactory);\n+                _serializerProvider(cfg).serializeValue(jgen, value, _rootType);\n             }\n             if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n+import java.text.DateFormat;\n import java.util.Date;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.ser.FilterProvider;\n-import com.fasterxml.jackson.databind.ser.SerializerFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.impl.*;\n+import com.fasterxml.jackson.databind.ser.std.NullSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdKeySerializers;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n /**\n- * Abstract class that defines API used by {@link ObjectMapper} and\n+ * Class that defines API used by {@link ObjectMapper} and\n  * {@link JsonSerializer}s to obtain serializers capable of serializing\n- * instances of specific types.\n+ * instances of specific types; as well as the default implementation\n+ * of the functionality.\n  *<p>\n- * Note about usage: for {@link JsonSerializer} instances, only accessors\n- * for locating other (sub-)serializers are to be used. {@link ObjectMapper},\n- * on the other hand, is to initialize recursive serialization process by\n- * calling {@link #serializeValue}.\n+ * Provider handles caching aspects of serializer handling; all construction\n+ * details are delegated to {@link SerializerFactory} instance.\n+ *<p>\n+ * Object life-cycle is such that an initial instance (\"blueprint\") is created\n+ * and referenced by {@link ObjectMapper} and {@link ObjectWriter} intances;\n+ * but for actual usage, a configured instance is created by using\n+ * {@link #createInstance}.\n+ * Only this instance can be used for actual serialization calls; blueprint\n+ * object is only to be used for creating instances.\n  */\n public abstract class SerializerProvider\n {\n     protected final static JavaType TYPE_OBJECT = TypeFactory.defaultInstance().uncheckedSimpleType(Object.class);\n+\n+    /**\n+     * Setting for determining whether mappings for \"unknown classes\" should be\n+     * cached for faster resolution. Usually this isn't needed, but maybe it\n+     * is in some cases?\n+     */\n+    protected final static boolean CACHE_UNKNOWN_MAPPINGS = false;\n+\n+    public final static JsonSerializer<Object> DEFAULT_NULL_KEY_SERIALIZER =\n+        new FailingSerializer(\"Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)\");\n+\n+    public final static JsonSerializer<Object> DEFAULT_UNKNOWN_SERIALIZER = new UnknownSerializer();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, general\n+    /**********************************************************\n+     */\n     \n     /**\n      * Serialization configuration to use for serialization processing.\n     protected final SerializationConfig _config;\n \n     /**\n-     * View used for currently active serialization\n+     * View used for currently active serialization, if any.\n      */\n     protected final Class<?> _serializationView;\n-\n-    protected SerializerProvider(SerializationConfig config)\n-    {\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, factories\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory used for constructing actual serializer instances.\n+     */\n+    final protected SerializerFactory _serializerFactory;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, caching\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Cache for doing type-to-value-serializer lookups.\n+     */\n+    final protected SerializerCache _serializerCache;\n+\n+    /**\n+     * Helper object for keeping track of introspected root names\n+     */\n+    final protected RootNameLookup _rootNames;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, specialized serializers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Serializer that gets called for values of types for which no\n+     * serializers can be constructed.\n+     *<p>\n+     * The default serializer will simply thrown an exception; a possible\n+     * alternative that can be used would be\n+     * {@link ToStringSerializer}.\n+     */\n+    protected JsonSerializer<Object> _unknownTypeSerializer = DEFAULT_UNKNOWN_SERIALIZER;\n+\n+    /**\n+     * Serializer used to output non-null keys of Maps (which will get\n+     * output as JSON Objects), if not null; if null, us the standard\n+     * default key serializer.\n+     */\n+    protected JsonSerializer<Object> _keySerializer;\n+\n+    /**\n+     * Serializer used to output a null value. Default implementation\n+     * writes nulls using {@link JsonGenerator#writeNull}.\n+     */\n+    protected JsonSerializer<Object> _nullValueSerializer = NullSerializer.instance;\n+\n+    /**\n+     * Serializer used to (try to) output a null key, due to an entry of\n+     * {@link java.util.Map} having null key.\n+     * The default implementation will throw an exception if this happens;\n+     * alternative implementation (like one that would write an Empty String)\n+     * can be defined.\n+     */\n+    protected JsonSerializer<Object> _nullKeySerializer = DEFAULT_NULL_KEY_SERIALIZER;\n+\n+    /*\n+    /**********************************************************\n+    /* State, for non-blueprint instances\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * For fast lookups, we will have a local non-shared read-only\n+     * map that contains serializers previously fetched.\n+     */\n+    protected final ReadOnlyClassToSerializerMap _knownSerializers;\n+\n+    /**\n+     * Lazily acquired and instantiated formatter object: initialized\n+     * first time it is needed, reused afterwards. Used via instances\n+     * (not blueprints), so that access need not be thread-safe.\n+     */\n+    protected DateFormat _dateFormat;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor for creating master (or \"blue-print\") provider object,\n+     * which is only used as the template for constructing per-binding\n+     * instances.\n+     */\n+    public SerializerProvider()\n+    {\n+        _config = null;\n+        _serializerFactory = null;\n+        _serializerCache = new SerializerCache();\n+        // Blueprints doesn't have access to any serializers...\n+        _knownSerializers = null;\n+        _rootNames = new RootNameLookup();\n+\n+        _serializationView = null;\n+    }\n+\n+    /**\n+     * \"Copy-constructor\", used from {@link #createInstance} (or by\n+     * sub-classes)\n+     *\n+     * @param src Blueprint object used as the baseline for this instance\n+     */\n+    protected SerializerProvider(SerializerProvider src,\n+            SerializationConfig config, SerializerFactory f)\n+    {\n+        if (config == null) {\n+            throw new NullPointerException();\n+        }\n+        _serializerFactory = f;\n         _config = config;\n-        _serializationView = (config == null) ? null : _config.getActiveView();\n-    }\n-\n+\n+        _serializerCache = src._serializerCache;\n+        _unknownTypeSerializer = src._unknownTypeSerializer;\n+        _keySerializer = src._keySerializer;\n+        _nullValueSerializer = src._nullValueSerializer;\n+        _nullKeySerializer = src._nullKeySerializer;\n+        _rootNames = src._rootNames;\n+\n+        /* Non-blueprint instances do have a read-only map; one that doesn't\n+         * need synchronization for lookups.\n+         */\n+        _knownSerializers = _serializerCache.getReadOnlyLookupMap();\n+\n+        _serializationView = config.getActiveView();\n+    }\n+\n+    /**\n+     * Overridable method, used to create a non-blueprint instances from the blueprint.\n+     * This is needed to retain state during serialization.\n+     */\n+    public abstract SerializerProvider createInstance(SerializationConfig config,\n+            SerializerFactory jsf);\n+    \n     /*\n     /**********************************************************\n     /* Methods for configuring default settings\n      * Maps (which will throw an exception if try write such property\n      * name)\n      */\n-    public abstract void setNullKeySerializer(JsonSerializer<Object> nks);\n+    public void setDefaultKeySerializer(JsonSerializer<Object> ks)\n+    {\n+        if (ks == null) {\n+            throw new IllegalArgumentException(\"Can not pass null JsonSerializer\");\n+        }\n+        _keySerializer = ks;\n+    }\n \n     /**\n      * Method that can be used to specify serializer that will be\n      * used to write JSON values matching Java null values\n      * instead of default one (which simply writes JSON null)\n      */\n-    public abstract void setNullValueSerializer(JsonSerializer<Object> nvs);\n-    \n+    public void setNullValueSerializer(JsonSerializer<Object> nvs)\n+    {\n+        if (nvs == null) {\n+            throw new IllegalArgumentException(\"Can not pass null JsonSerializer\");\n+        }\n+        _nullValueSerializer = nvs;\n+    }\n+\n     /**\n      * Method that can be used to specify serializer to use for serializing\n      * all non-null JSON property names, unless more specific key serializer\n      * Note that key serializer registration are different from value serializer\n      * registrations.\n      */\n-    public abstract void setDefaultKeySerializer(JsonSerializer<Object> ks);\n+    public void setNullKeySerializer(JsonSerializer<Object> nks)\n+    {\n+        if (nks == null) {\n+            throw new IllegalArgumentException(\"Can not pass null JsonSerializer\");\n+        }\n+        _nullKeySerializer = nks;\n+    }\n     \n     /*\n     /**********************************************************\n      */\n \n     /**\n-     * The method to be called by {@link ObjectMapper} to\n-     * execute recursive serialization, using serializers that\n-     * this provider has access to.\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * for serializing given value, using serializers that\n+     * this provider has access to (via caching and/or creating new serializers\n+     * as need be).\n      *\n      * @param jsf Underlying factory object used for creating serializers\n      *    as needed\n      */\n-    public abstract void serializeValue(SerializationConfig cfg, JsonGenerator jgen,\n-            Object value, SerializerFactory jsf)\n-        throws IOException, JsonGenerationException;\n-\n-    /**\n-     * The method to be called by {@link ObjectMapper} to\n-     * execute recursive serialization, using serializers that\n-     * this provider has access to; and using specified root type\n-     * for locating first-level serializer.\n+    public final void serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonGenerationException\n+    {\n+        // And then we can do actual serialization, through the instance\n+        _serializeValue(jgen, value);\n+    }\n+\n+    /**\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * for serializing given value (assumed to be of specified root type,\n+     * instead of runtime type of value),\n+     * using serializers that\n+     * this provider has access to (via caching and/or creating new serializers\n+     * as need be),\n      * \n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n      */\n-    public abstract void serializeValue(SerializationConfig cfg, JsonGenerator jgen,\n-            Object value, JavaType rootType, SerializerFactory jsf)\n-        throws IOException, JsonGenerationException;\n-    \n+    public final void serializeValue(JsonGenerator jgen, Object value,\n+            JavaType rootType)\n+        throws IOException, JsonGenerationException\n+    {\n+        _serializeValue(jgen, value, rootType);\n+    }\n+\n     /**\n      * Generate <a href=\"http://json-schema.org/\">Json-schema</a> for\n      * given type.\n      *\n      * @param type The type for which to generate schema\n      */\n-    public abstract JsonSchema generateJsonSchema(Class<?> type,\n-            SerializationConfig config, SerializerFactory jsf)\n-        throws JsonMappingException;\n+    public JsonSchema generateJsonSchema(Class<?> type)\n+        throws JsonMappingException\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"A class must be provided\");\n+        }\n+        /* no need for embedded type information for JSON schema generation (all\n+         * type information it needs is accessible via \"untyped\" serializer)\n+         */\n+        JsonSerializer<Object> ser = findValueSerializer(type, null);\n+        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                ((SchemaAware) ser).getSchema(this, null) : \n+                JsonSchema.getDefaultSchemaNode();\n+        if (!(schemaNode instanceof ObjectNode)) {\n+            throw new IllegalArgumentException(\"Class \" + type.getName() +\n+                    \" would not be serialized as a JSON object and therefore has no schema\");\n+        }\n+        return new JsonSchema((ObjectNode) schemaNode);\n+    }\n \n     /**\n      * Method that can be called to see if this serializer provider\n      * Note that no Exceptions are thrown, including unchecked ones:\n      * implementations are to swallow exceptions if necessary.\n      */\n-    public abstract boolean hasSerializerFor(SerializationConfig cfg,\n-            Class<?> cls, SerializerFactory jsf);\n-\n+    public boolean hasSerializerFor(Class<?> cls) {\n+        return _findExplicitUntypedSerializer(cls, null) != null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Access to configuration\n      *   accessing suitable serializer; including that of not\n      *   finding any serializer\n      */\n-    public abstract JsonSerializer<Object> findValueSerializer(Class<?> runtimeType,\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType,\n             BeanProperty property)\n-        throws JsonMappingException;\n-\n-    /**\n-     * Similar to {@link #findValueSerializer(Class,BeanProperty)}, but takes full generics-aware\n-     * type instead of raw class.\n+        throws JsonMappingException\n+    {\n+        // Fast lookup from local lookup thingy works?\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                // ... possibly as fully typed?\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    // If neither, must create\n+                    ser = _createAndCacheUntypedSerializer(valueType, property);\n+                    // Not found? Must use the unknown type serializer\n+                    /* Couldn't create? Need to return the fallback serializer, which\n+                     * most likely will report an error: but one question is whether\n+                     * we should cache it?\n+                     */\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        // Should this be added to lookups?\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                        return ser;\n+                    }\n+                }\n+            }\n+        }\n+        // at this point, resolution has occured, but not contextualization\n+        return _handleContextual(ser, property);\n+    }\n+\n+    /**\n+     * Similar to {@link #findValueSerializer(Class,BeanProperty)}, but takes\n+     * full generics-aware type instead of raw class.\n+     * This is necessary for accurate handling of external type information,\n+     * to handle polymorphic types.\n      * \n      * @param property When creating secondary serializers, property for which\n      *   serializer is needed: annotations of the property (or bean that contains it)\n      *   may be checked to create contextual serializers.\n      */\n-    public abstract JsonSerializer<Object> findValueSerializer(JavaType serializationType,\n-            BeanProperty property)\n-        throws JsonMappingException;\n+    public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Fast lookup from local lookup thingy works?\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                // If neither, must create\n+                ser = _createAndCacheUntypedSerializer(valueType, property);\n+                // Not found? Must use the unknown type serializer\n+                /* Couldn't create? Need to return the fallback serializer, which\n+                 * most likely will report an error: but one question is whether\n+                 * we should cache it?\n+                 */\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    // Should this be added to lookups?\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                    return ser;\n+                }\n+            }\n+        }\n+        return _handleContextual(ser, property);\n+    }\n     \n     /**\n      * Method called to locate regular serializer, matching type serializer,\n      *   serializer is needed: annotations of the property (or bean that contains it)\n      *   may be checked to create contextual serializers.\n      */\n-    public abstract JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n+    public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n             boolean cache, BeanProperty property)\n-        throws JsonMappingException;\n+        throws JsonMappingException\n+    {\n+        // Two-phase lookups; local non-shared cache, then shared:\n+        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        // If not, maybe shared map already has it?\n+        ser = _serializerCache.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+\n+        // Well, let's just compose from pieces:\n+        ser = findValueSerializer(valueType, property);\n+        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config,\n+                _config.constructType(valueType));\n+        if (typeSer != null) {\n+            typeSer = typeSer.forProperty(property);\n+            ser = new TypeWrappedSerializer(typeSer, ser);\n+        }\n+        if (cache) {\n+            _serializerCache.addTypedSerializer(valueType, ser);\n+        }\n+        return ser;\n+    }\n \n     /**\n      * Method called to locate regular serializer, matching type serializer,\n      *   serializer is needed: annotations of the property (or bean that contains it)\n      *   may be checked to create contextual serializers.\n      */\n-    public abstract JsonSerializer<Object> findTypedValueSerializer(JavaType valueType,\n-            boolean cache, BeanProperty property)\n-        throws JsonMappingException;\n+    public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Two-phase lookups; local non-shared cache, then shared:\n+        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        // If not, maybe shared map already has it?\n+        ser = _serializerCache.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+\n+        // Well, let's just compose from pieces:\n+        ser = findValueSerializer(valueType, property);\n+        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType);\n+        if (typeSer != null) {\n+            typeSer = typeSer.forProperty(property);\n+            ser = new TypeWrappedSerializer(typeSer, ser);\n+        }\n+        if (cache) {\n+            _serializerCache.addTypedSerializer(valueType, ser);\n+        }\n+        return ser;\n+    }\n \n     /**\n      * Method called to get the serializer to use for serializing\n      * Note that the serializer itself can be called with instances\n      * of any Java object, but not nulls.\n      */\n-    public abstract JsonSerializer<Object> findKeySerializer(JavaType keyType,\n+    public JsonSerializer<Object> findKeySerializer(JavaType keyType,\n             BeanProperty property)\n-        throws JsonMappingException;\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(this, keyType, property);\n+    \n+        // First things first: maybe there are registered custom implementations\n+        // if not, use default one:\n+        if (ser == null) {\n+            if (_keySerializer == null) {\n+                ser = StdKeySerializers.getStdKeySerializer(keyType);\n+            } else {\n+                ser = _keySerializer;\n+            }\n+        }\n+        // 25-Feb-2011, tatu: As per [JACKSON-519], need to ensure contextuality works here, too\n+        return _handleContextualResolvable(ser, property);\n+    }\n     \n     /*\n     /********************************************************\n     /**\n      * @since 2.0\n      */\n-    public abstract JsonSerializer<Object> getDefaultNullKeySerializer()\n-        throws JsonMappingException;\n+    public JsonSerializer<Object> getDefaultNullKeySerializer() {\n+        return _nullKeySerializer;\n+    }\n \n     /**\n      * @since 2.0\n      */\n-    public abstract JsonSerializer<Object> getDefaultNullValueSerializer()\n-        throws JsonMappingException;\n+    public JsonSerializer<Object> getDefaultNullValueSerializer() {\n+        return _nullValueSerializer;\n+    }\n     \n     /**\n      * Method called to get the serializer to use for serializing\n      *\n      * @param unknownType Type for which no serializer is found\n      */\n-    public abstract JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType);\n-\n+    public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) {\n+        return _unknownTypeSerializer;\n+    }\n \n     /*\n     /**********************************************************\n      * @param annotated Annotated entity that contained definition\n      * @param serDef Serializer definition: either an instance or class\n      */\n-    public abstract JsonSerializer<Object> serializerInstance(Annotated annotated,\n+    public JsonSerializer<Object> serializerInstance(Annotated annotated,\n             BeanProperty property, Object serDef)\n-        throws JsonMappingException;\n+        throws JsonMappingException\n+    {\n+        if (serDef == null) {\n+            return null;\n+        }\n+        JsonSerializer<?> ser;\n+        \n+        if (serDef instanceof JsonSerializer) {\n+            ser = (JsonSerializer<?>) serDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(serDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned serializer definition of type \"\n+                        +serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n+            }\n+            Class<?> serClass = (Class<?>)serDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (serClass == JsonSerializer.None.class || serClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonSerializer.class.isAssignableFrom(serClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"\n+                        +serClass.getName()+\"; expected Class<JsonSerializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                ser = hi.serializerInstance(_config, annotated, serClass);\n+            } else {\n+                ser = (JsonSerializer<?>) ClassUtil.createInstance(serClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        return (JsonSerializer<Object>) _handleContextualResolvable(ser, property);\n+    }\n     \n     /*\n     /********************************************************\n      * Note: date here means \"full\" date, that is, date AND time, as per\n      * Java convention (and not date-only values like in SQL)\n      */\n-    public abstract void defaultSerializeDateValue(long timestamp, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    /*\n+    /**********************************************************\n+    /* Abstract method impls, convenience methods\n+    /**********************************************************\n+     */\n \n     /**\n      * Method that will handle serialization of Date(-like) values, using\n      * Note: date here means \"full\" date, that is, date AND time, as per\n      * Java convention (and not date-only values like in SQL)\n      */\n-    public abstract void defaultSerializeDateValue(Date date, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n-\n+    public final void defaultSerializeDateValue(long timestamp, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-87]: Support both numeric timestamps and textual\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            jgen.writeNumber(timestamp);\n+        } else {\n+            if (_dateFormat == null) {\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)_config.getDateFormat().clone();\n+            }\n+            jgen.writeString(_dateFormat.format(new Date(timestamp)));\n+        }\n+    }\n+\n+    /**\n+     * Method that will handle serialization of Date(-like) values, using\n+     * {@link SerializationConfig} settings to determine expected serialization\n+     * behavior.\n+     * Note: date here means \"full\" date, that is, date AND time, as per\n+     * Java convention (and not date-only values like in SQL)\n+     */\n+    public final void defaultSerializeDateValue(Date date, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-87]: Support both numeric timestamps and textual\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            jgen.writeNumber(date.getTime());\n+        } else {\n+            if (_dateFormat == null) {\n+                DateFormat blueprint = _config.getDateFormat();\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)blueprint.clone();\n+            }\n+            jgen.writeString(_dateFormat.format(date));\n+        }\n+    }\n \n     /**\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n      * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n      */\n-    public abstract void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+            jgen.writeFieldName(String.valueOf(timestamp));\n+        } else {\n+            if (_dateFormat == null) {\n+                DateFormat blueprint = _config.getDateFormat();\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)blueprint.clone();\n+            }\n+            jgen.writeFieldName(_dateFormat.format(new Date(timestamp)));\n+        }\n+    }\n \n     /**\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n      * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n      */\n-    public abstract void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+            jgen.writeFieldName(String.valueOf(date.getTime()));\n+        } else {\n+            if (_dateFormat == null) {\n+                DateFormat blueprint = _config.getDateFormat();\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)blueprint.clone();\n+            }\n+            jgen.writeFieldName(_dateFormat.format(date));\n+        }\n+    }\n     \n     public final void defaultSerializeNull(JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n      * The main use case for this method is to allow conditional flushing of\n      * serializer cache, if certain number of entries is reached.\n      */\n-    public abstract int cachedSerializersCount();\n+    public int cachedSerializersCount() {\n+        return _serializerCache.size();\n+    }\n \n     /**\n      * Method that will drop all serializers currently cached by this provider.\n      * only used once or so), or to force re-construction of serializers after\n      * configuration changes for mapper than owns the provider.\n      */\n-    public abstract void flushCachedSerializers();\n+    public void flushCachedSerializers() {\n+        _serializerCache.flush();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods: can be overridden by sub-classes\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called on the actual non-blueprint provider instance object,\n+     * to kick off the serialization.\n+     */\n+    protected final void _serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonSerializer<Object> ser;\n+        boolean wrap;\n+\n+        if (value == null) {\n+            // no type provided; must just use the default null serializer\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false; // no name to use for wrapping; can't do!\n+        } else {\n+            Class<?> cls = value.getClass();\n+            // true, since we do want to cache root-level typed serializers (ditto for null property)\n+            ser = findTypedValueSerializer(cls, true, null);\n+\n+            // Ok: should we wrap result in an additional property (\"root name\")?\n+            String rootName = _config.getRootName();\n+            if (rootName == null) { // not explicitly specified\n+                // [JACKSON-163]\n+                wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+                if (wrap) {\n+                    jgen.writeStartObject();\n+                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+                }\n+            } else if (rootName.length() == 0) {\n+                wrap = false;\n+            } else { // [JACKSON-764]\n+                // empty String means explicitly disabled; non-empty that it is enabled\n+                wrap = true;\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(rootName);\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) {\n+            /* As per [JACKSON-99], should not wrap IOException or its\n+             * sub-classes (like JsonProcessingException, JsonMappingException)\n+             */\n+            throw ioe;\n+        } catch (Exception e) {\n+            // but others are wrapped\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * Method called on the actual non-blueprint provider instance object,\n+     * to kick off the serialization, when root type is explicitly\n+     * specified and not determined from value.\n+     */\n+    protected  void _serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-163]\n+        boolean wrap;\n+\n+        JsonSerializer<Object> ser;\n+        if (value == null) {\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false;\n+        } else {\n+            // Let's ensure types are compatible at this point\n+            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                _reportIncompatibleRootType(value, rootType);\n+            }\n+            // root value, not reached via property:\n+            ser = findTypedValueSerializer(rootType, true, null);\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    protected void _reportIncompatibleRootType(Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 07-Jan-2010, tatu: As per [JACKSON-456] better handle distinction between wrapper types,\n+         *    primitives\n+         */\n+        if (rootType.isPrimitive()) {\n+            Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass());\n+            // If it's just difference between wrapper, primitive, let it slide\n+            if (wrapperType.isAssignableFrom(value.getClass())) {\n+                return;\n+            }\n+        }\n+        throw new JsonMappingException(\"Incompatible types: declared root type (\"+rootType+\") vs \"\n+                +value.getClass().getName());\n+    }\n+    \n+    /**\n+     * Method that will try to find a serializer, either from cache\n+     * or by constructing one; but will not return an \"unknown\" serializer\n+     * if this can not be done but rather returns null.\n+     *\n+     * @return Serializer if one can be found, null if not.\n+     */\n+    protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType,\n+            BeanProperty property)\n+    {        \n+        // Fast lookup from local lookup thingy works?\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        // If not, maybe shared map already has it?\n+        ser = _serializerCache.untypedValueSerializer(runtimeType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        try {\n+            return _createAndCacheUntypedSerializer(runtimeType, property);\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Low-level methods for actually constructing and initializing\n+    /* serializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will try to construct a value serializer; and if\n+     * one is successfully created, cache it for reuse.\n+     */\n+    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {        \n+        JsonSerializer<Object> ser;\n+        try {\n+            ser = _createUntypedSerializer(_config.constructType(type), property);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+\n+        if (ser != null) {\n+            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n+        }\n+        return ser;\n+    }\n+\n+    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {        \n+        JsonSerializer<Object> ser;\n+        try {\n+            ser = _createUntypedSerializer(type, property);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+    \n+        if (ser != null) {\n+            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n+        }\n+        return ser;\n+    }\n+\n+    protected JsonSerializer<Object> _createUntypedSerializer(JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        /* 10-Dec-2008, tatu: Is there a possibility of infinite loops\n+         *   here? Shouldn't be, given that we do not pass back-reference\n+         *   to this provider. But if there is, we'd need to sync calls,\n+         *   and keep track of creation chain to look for loops -- fairly\n+         *   easy to do, but won't add yet since it seems unnecessary.\n+         */\n+        return (JsonSerializer<Object>)_serializerFactory.createSerializer(this, type, property);\n+    }\n+\n+    /**\n+     * Helper method called to resolve and contextualize given\n+     * serializer, if and as necessary.\n+     */\n+    protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<?> ser,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (ser instanceof ResolvableSerializer) {\n+            ((ResolvableSerializer) ser).resolve(this);\n+        }\n+        return _handleContextual(ser, property);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonSerializer<Object> _handleContextual(JsonSerializer<?> ser,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (ser instanceof ContextualSerializer) {\n+            ser = ((ContextualSerializer) ser).createContextual(this, property);\n+        }\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Standard implementation used by {@link ObjectMapper}; just implements\n+     * <code>createInstance</code> method which is abstract in\n+     * {@link SerializerProvider}\n+     */\n+    public final static class Impl extends SerializerProvider\n+    {\n+        public Impl() { super(); }\n+        private Impl( SerializerProvider src,\n+                SerializationConfig config,SerializerFactory f) {\n+            super(src, config, f);\n+        }\n+\n+        @Override\n+        public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {\n+            return new Impl(this, config, jsf);\n+        }\n+        \n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n \n import java.io.*;\n \n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.ser.StdSerializerProvider;\n \n public class TestNullSerialization\n     extends BaseMapTest\n         public String type = null;\n     }\n     \n-    static class MyNullProvider extends StdSerializerProvider\n+    static class MyNullProvider extends SerializerProvider\n     {\n         public MyNullProvider() { super(); }\n-        public MyNullProvider(SerializationConfig config, MyNullProvider base, SerializerFactory jsf) {\n-            super(config, base, jsf);\n+        public MyNullProvider(MyNullProvider base, SerializationConfig config, SerializerFactory jsf) {\n+            super(base, config, jsf);\n         }\n         \n-        protected StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {\n-            return new MyNullProvider(config, this, jsf);\n+        @Override\n+        public SerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {\n+            return new MyNullProvider(this, config, jsf);\n         }\n         \n         @Override\n \n     public void testOverriddenDefaultNulls() throws Exception\n     {\n-        StdSerializerProvider sp = new StdSerializerProvider.Impl();\n+        SerializerProvider sp = new SerializerProvider.Impl();\n         sp.setNullValueSerializer(new NullSerializer());\n         ObjectMapper m = new ObjectMapper();\n         m.setSerializerProvider(sp);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;\n-import com.fasterxml.jackson.databind.ser.StdSerializerProvider;\n \n public class TestSerializerProvider\n     extends com.fasterxml.jackson.databind.BaseMapTest\n         ObjectMapper mapper = new ObjectMapper();\n         SerializationConfig config = mapper.getSerializationConfig();\n         SerializerFactory f = new BeanSerializerFactory(null);\n-        StdSerializerProvider prov = new StdSerializerProvider.Impl().createInstance(config, f);\n+        SerializerProvider prov = new SerializerProvider.Impl().createInstance(config, f);\n \n         // Should have working default key and null key serializers\n         assertNotNull(prov.findKeySerializer(null, null));\n         // as well as 'unknown type' one (throws exception)\n         assertNotNull(prov.getUnknownTypeSerializer(getClass()));\n         \n-        assertTrue(prov.hasSerializerFor(config, String.class, f));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class));\n         // call twice to verify it'll be cached (second code path)\n-        assertTrue(prov.hasSerializerFor(config, String.class, f));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class));\n \n-        assertTrue(prov.hasSerializerFor(config, MyBean.class, f));\n-        assertTrue(prov.hasSerializerFor(config, MyBean.class, f));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class));\n     }\n }", "timestamp": 1328146362, "metainfo": ""}