{"sha": "e13574dbc83d4638f3061d5e25043aefcfca3eff", "log": "more cleanup, wrt deserializer registration", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n @SuppressWarnings(\"serial\")\n public class JdkDeserializers\n {\n+    private final static HashSet<String> _classNames = new HashSet<String>();\n+    static {\n+        // note: can skip primitive types; other ways to check them:\n+        Class<?>[] numberTypes = new Class<?>[] {\n+                UUID.class,\n+                URL.class,\n+                URI.class,\n+                File.class,\n+                Currency.class,\n+                Pattern.class,\n+                Locale.class,\n+                InetAddress.class,\n+                Charset.class,\n+                AtomicBoolean.class,\n+                Class.class,\n+                StackTraceElement.class\n+\n+        };\n+        for (Class<?> cls : numberTypes) {\n+            _classNames.add(cls.getName());\n+        }\n+    }\n+\n     /**\n      * @deprecated Since 2.2 -- use {@link #find} instead.\n      */\n     {\n         return new StdDeserializer[] {\n             // from String types:\n-            new UUIDDeserializer(),\n-            new URLDeserializer(),\n-            new URIDeserializer(),\n-            new FileDeserializer(),\n-            new CurrencyDeserializer(),\n-            new PatternDeserializer(),\n-            new LocaleDeserializer(),\n-            new InetAddressDeserializer(),\n-            new CharsetDeserializer(),\n+            UUIDDeserializer.instance,\n+            URLDeserializer.instance,\n+            URIDeserializer.instance,\n+            FileDeserializer.instance,\n+            CurrencyDeserializer.instance,\n+            PatternDeserializer.instance,\n+            LocaleDeserializer.instance,\n+            InetAddressDeserializer.instance,\n+            CharsetDeserializer.instance,\n             \n             // other types:\n \n             // (note: AtomicInteger/Long work due to single-arg constructor;\n-            new AtomicBooleanDeserializer(),\n-            new ClassDeserializer(),\n-            new StackTraceElementDeserializer()\n+            AtomicBooleanDeserializer.instance,\n+            ClassDeserializer.instance,\n+            StackTraceElementDeserializer.instance\n         };\n     }\n \n     public static JsonDeserializer<?> find(Class<?> rawType)\n     {\n+        if (!_classNames.contains(rawType.getName())) {\n+            return null;\n+        }\n+        /* Ok: following ones would work via String-arg detection too;\n+         * if we get more may want to formally change.\n+         */\n+        if (rawType == URI.class) {\n+            return URIDeserializer.instance;\n+        }\n+        if (rawType == URL.class) {\n+            return URLDeserializer.instance;\n+        }\n+        if (rawType == File.class) {\n+            return FileDeserializer.instance;\n+        }\n+        /* But these will require custom handling regardless:\n+         */\n         if (rawType == UUID.class) {\n             return UUIDDeserializer.instance;\n-        }\n-        if (rawType == URIDeserializer.class) {\n-            /* Ok: following ones would work via String-arg detection too;\n-             * if we get more may want to formally change.\n-             */\n-            return URIDeserializer.instance;\n-        }\n-        if (rawType == URL.class) {\n-            return URLDeserializer.instance;\n-        }\n-        if (rawType == File.class) {\n-            return FileDeserializer.instance;\n-            \n-            /* But these will require custom handling regardless:\n-             */\n         }\n         if (rawType == Currency.class) {\n             return CurrencyDeserializer.instance;\n             // (note: AtomicInteger/Long work due to single-arg constructor. For now?\n             return AtomicBooleanDeserializer.instance;\n         }\n-        return null;\n-    }\n-    \n+        // should never occur\n+        throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n {\n     private final static HashSet<String> _classNames = new HashSet<String>();\n     static {\n+        // note: can skip primitive types; other ways to check them:\n         Class<?>[] numberTypes = new Class<?>[] {\n-            Boolean.class, Boolean.TYPE,\n-            Byte.class, Byte.TYPE,\n-            Short.class, Short.TYPE,\n-            Character.class, Character.TYPE,\n-            Integer.class, Integer.TYPE,\n-            Long.class, Long.TYPE,\n-            Float.class, Float.TYPE,\n-            Double.class, Double.TYPE,\n+            Boolean.class,\n+            Byte.class,\n+            Short.class,\n+            Character.class,\n+            Integer.class,\n+            Long.class,\n+            Float.class,\n+            Double.class,\n             // and more generic ones\n             Number.class, BigDecimal.class, BigInteger.class\n         };\n     \n     public static JsonDeserializer<?> find(Class<?> rawType)\n     {\n-        if (!_classNames.contains(rawType.getName())) {\n+        if (rawType.isPrimitive()) {\n+            if (rawType == Integer.TYPE) {\n+                return IntegerDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Boolean.TYPE) {\n+                return BooleanDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Long.TYPE) {\n+                return LongDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Double.TYPE) {\n+                return DoubleDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Character.TYPE) {\n+                return CharacterDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Byte.TYPE) {\n+                return ByteDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Short.TYPE) {\n+                return ShortDeserializer.primitiveInstance;\n+            }\n+            if (rawType == Float.TYPE) {\n+                return FloatDeserializer.primitiveInstance;\n+            }\n+        } else if (_classNames.contains(rawType.getName())) {\n+            // Start with most common types; int, boolean, long, double\n+            if (rawType == Integer.class) {\n+                return IntegerDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Boolean.class) {\n+                return BooleanDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Long.class) {\n+                return LongDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Double.class) {\n+                return DoubleDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Character.class) {\n+                return CharacterDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Byte.class) {\n+                return ByteDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Short.class) {\n+                return ShortDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Float.class) {\n+                return FloatDeserializer.wrapperInstance;\n+            }\n+            if (rawType == Number.class) {\n+                return NumberDeserializer.instance;\n+            }\n+            if (rawType == BigDecimal.class) {\n+                return BigDecimalDeserializer.instance;\n+            }\n+            if (rawType == BigInteger.class) {\n+                return BigIntegerDeserializer.instance;\n+            }\n+        } else {\n             return null;\n-        }\n-        // Start with most common types; int, boolean, long, double\n-        if (rawType == Integer.TYPE) {\n-            return IntegerDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Integer.class) {\n-            return IntegerDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Boolean.TYPE) {\n-            return BooleanDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Boolean.class) {\n-            return BooleanDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Long.TYPE) {\n-            return LongDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Long.class) {\n-            return LongDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Double.TYPE) {\n-            return DoubleDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Double.class) {\n-            return DoubleDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Character.TYPE) {\n-            return CharacterDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Character.class) {\n-            return CharacterDeserializer.wrapperInstance;\n-        }\n-\n-        if (rawType == Byte.TYPE) {\n-            return ByteDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Byte.class) {\n-            return ByteDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Short.TYPE) {\n-            return ShortDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Short.class) {\n-            return ShortDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Float.TYPE) {\n-            return FloatDeserializer.primitiveInstance;\n-        }\n-        if (rawType == Float.class) {\n-            return FloatDeserializer.wrapperInstance;\n-        }\n-        if (rawType == Number.class) {\n-            return NumberDeserializer.instance;\n-        }\n-        if (rawType == BigDecimal.class) {\n-            return BigDecimalDeserializer.instance;\n-        }\n-        if (rawType == BigInteger.class) {\n-            return BigIntegerDeserializer.instance;\n         }\n         // should never occur\n         throw new IllegalArgumentException(\"Internal error: can't find deserializer for \"+rawType.getName());", "timestamp": 1361335381, "metainfo": ""}