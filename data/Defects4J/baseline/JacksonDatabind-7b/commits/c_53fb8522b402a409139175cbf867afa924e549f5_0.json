{"sha": "53fb8522b402a409139175cbf867afa924e549f5", "log": "Refactoring: make all structured standard deserializers implement proper resolve(), instead of resolving things on construction", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      */\n     public boolean canDeserialize(JavaType type)\n     {\n-        return _deserializerCache.hasValueDeserializerFor(getDeserializationConfig(), type);\n+        DeserializationContext ctxt = _createDeserializationContext(null,\n+                getDeserializationConfig());\n+        return _deserializerCache.hasValueDeserializerFor(ctxt, type);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         // false -> do not close as caller gave parser instance\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(_config, _valueType),\n+                _findRootDeserializer(ctxt, _valueType),\n                 false, _valueToUpdate);\n     }\n     \n         }\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt, \n-                _findRootDeserializer(_config, _valueType),\n+                _findRootDeserializer(ctxt, _valueType),\n                 true, _valueToUpdate);\n     }\n \n         }\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n     /**\n         }\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n     /**\n         }\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n     public final <T> MappingIterator<T> readValues(byte[] src)\n         }\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n     /**\n         }\n         DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n         return new MappingIterator<T>(_valueType, jp, ctxt,\n-                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n     /*\n         JsonToken t = _initForReading(jp);\n         if (t == JsonToken.VALUE_NULL) {\n             if (_valueToUpdate == null) {\n-                result = _findRootDeserializer(_config, _valueType).getNullValue();\n+                DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+                result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n             } else {\n                 result = _valueToUpdate;\n             }\n             result = _valueToUpdate;\n         } else { // pointing to event other than null\n             DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n-            JsonDeserializer<Object> deser = _findRootDeserializer(_config, _valueType);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n             if (_unwrapRoot) {\n                 result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n             } else {\n             JsonToken t = _initForReading(jp);\n             if (t == JsonToken.VALUE_NULL) {\n                 if (_valueToUpdate == null) {\n-                    result = _findRootDeserializer(_config, _valueType).getNullValue();\n+                    DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+                    result = _findRootDeserializer(ctxt, _valueType).getNullValue();\n                 } else {\n                     result = _valueToUpdate;\n                 }\n                 result = _valueToUpdate;\n             } else {\n                 DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n-                JsonDeserializer<Object> deser = _findRootDeserializer(_config, _valueType);\n+                JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, _valueType);\n                 if (_unwrapRoot) {\n                     result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n                 } else {\n             result = NullNode.instance;\n         } else {\n             DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n-            JsonDeserializer<Object> deser = _findRootDeserializer(_config, JSON_NODE_TYPE);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(ctxt, JSON_NODE_TYPE);\n             if (_unwrapRoot) {\n                 result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n             } else {\n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n-    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationConfig cfg, JavaType valueType)\n+    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n+            JavaType valueType)\n         throws JsonMappingException\n     {\n         // Sanity check: must have actual type...\n         if (deser != null) {\n             return deser;\n         }\n-\n         // Nope: need to ask provider to resolve it\n-        deser = _deserializerCache.findTypedValueDeserializer(cfg, valueType, null);\n+        deser = ctxt.findTypedValueDeserializer(valueType, null);\n         if (deser == null) { // can this happen?\n             throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         if (custom != null) {\n             return custom;\n         }\n-        \n-        if (contentDeser == null) {\n-            // 'null' -> arrays have no referring fields\n-            contentDeser = p.findValueDeserializer(config, elemType, property);\n-        }\n-        return new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n-    }\n-    \n-    @Override\n-    public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config, DeserializerCache p,\n+        return new ObjectArrayDeserializer(type, property, contentDeser, elemTypeDeser);\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n+            DeserializerCache p,\n             CollectionType type, BeanProperty property)\n         throws JsonMappingException\n     {\n                 return new EnumSetDeserializer(contentType.getRawClass(),\n                         createEnumDeserializer(config, p, contentType, property));\n             }\n-            // But otherwise we can just use a generic value deserializer:\n-            // 'null' -> collections have no referring fields\n-            contentDeser = p.findValueDeserializer(config, contentType, property);            \n         }\n         \n         /* One twist: if we are being asked to instantiate an interface or\n         // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n         if (contentType.getRawClass() == String.class) {\n             // no value type deserializer because Strings are one of natural/native types:\n-            return new StringCollectionDeserializer(type, contentDeser, inst);\n-        }\n-        return new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n+            return new StringCollectionDeserializer(type, property, contentDeser, inst);\n+        }\n+        return new CollectionDeserializer(type, property, contentDeser, contentTypeDeser, inst);\n     }\n \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n         if (custom != null) {\n             return custom;\n         }\n-\n-        if (contentDeser == null) { // nope...\n-            // 'null' -> maps have no referring fields\n-            contentDeser = p.findValueDeserializer(config, contentType, property);\n-        }\n         // Value handling is identical for all, but EnumMap requires special handling for keys\n         Class<?> mapClass = type.getRawClass();\n         if (EnumMap.class.isAssignableFrom(mapClass)) {\n             if (kt == null || !kt.isEnum()) {\n                 throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n             }\n-            return new EnumMapDeserializer(keyType.getRawClass(),\n+            return new EnumMapDeserializer(type, property,\n                     createEnumDeserializer(config, p, keyType, property),\n                     contentDeser);\n         }\n             beanDesc = config.introspectForCreation(type);\n         }\n         ValueInstantiator inst = findValueInstantiator(config, beanDesc);\n-        MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n+        MapDeserializer md = new MapDeserializer(type, property, inst, keyDes, contentDeser, contentTypeDeser);\n         md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n         return md;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n      * This is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerCache provider)\n+    public void resolve(DeserializationContext ctxt)\n         throws JsonMappingException\n     {\n         // if ValueInstantiator can use \"creator\" approach, need to resolve it here...\n         if (_valueInstantiator.canCreateFromObjectWith()) {\n-            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(config);\n+            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n             _propertyBasedCreator = new PropertyBasedCreator(_valueInstantiator, creatorProps);\n             for (SettableBeanProperty prop : creatorProps) {\n                 if (!prop.hasValueDeserializer()) {\n                     _propertyBasedCreator.assignDeserializer(prop,\n-                           findDeserializer(config, provider, prop.getType(), prop));\n+                           findDeserializer(ctxt, prop.getType(), prop));\n                 }\n             }\n         }\n             SettableBeanProperty prop = origProp;\n             // May already have deserializer from annotations, if so, skip:\n             if (!prop.hasValueDeserializer()) {\n-                prop = prop.withValueDeserializer(findDeserializer(config, provider, prop.getType(), prop));\n+                prop = prop.withValueDeserializer(findDeserializer(ctxt, prop.getType(), prop));\n             }\n             // [JACKSON-235]: need to link managed references with matching back references\n-            prop = _resolveManagedReferenceProperty(config, prop);\n+            prop = _resolveManagedReferenceProperty(ctxt, prop);\n             // [JACKSON-132]: support unwrapped values (via @JsonUnwrapped)\n-            SettableBeanProperty u = _resolveUnwrappedProperty(config, prop);\n+            SettableBeanProperty u = _resolveUnwrappedProperty(ctxt, prop);\n             if (u != null) {\n                 prop = u;\n                 if (unwrapped == null) {\n                 continue;\n             }\n             // [JACKSON-594]: non-static inner classes too:\n-            prop = _resolveInnerClassValuedProperty(config, prop);\n+            prop = _resolveInnerClassValuedProperty(ctxt, prop);\n             if (prop != origProp) {\n                 _beanProperties.replace(prop);\n             }\n \n         // Finally, \"any setter\" may also need to be resolved now\n         if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n-            _anySetter = _anySetter.withValueDeserializer(findDeserializer(config, provider, _anySetter.getType(), _anySetter.getProperty()));\n+            _anySetter = _anySetter.withValueDeserializer(findDeserializer(ctxt, _anySetter.getType(), _anySetter.getProperty()));\n         }\n \n         // as well as delegate-based constructor:\n         if (_valueInstantiator.canCreateUsingDelegate()) {\n-            JavaType delegateType = _valueInstantiator.getDelegateType(config);\n+            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n             if (delegateType == null) {\n                 throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n                         +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n             // Need to create a temporary property to allow contextual deserializers:\n             BeanProperty.Std property = new BeanProperty.Std(null,\n                     delegateType, _forClass.getAnnotations(), delegateCreator);\n-            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n         }\n         if (extTypes != null) {\n             _externalTypeIdHandler = extTypes.build();\n      * Helper method called to see if given property is part of 'managed' property\n      * pair (managed + back reference), and if so, handle resolution details.\n      */\n-    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationConfig config,\n+    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationContext ctxt,\n             SettableBeanProperty prop)\n     {\n         String refName = prop.getManagedReferenceName();\n      * Helper method called to see if given property might be so-called unwrapped\n      * property: these require special handling.\n      */\n-    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationConfig config,\n+    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationContext ctxt,\n             SettableBeanProperty prop)\n     {\n         AnnotatedMember am = prop.getMember();\n         if (am != null) {\n-            NameTransformer unwrapper = config.getAnnotationIntrospector().findUnwrappingNameTransformer(am);\n+            NameTransformer unwrapper = ctxt.getAnnotationIntrospector().findUnwrappingNameTransformer(am);\n             if (unwrapper != null) {\n                 JsonDeserializer<Object> orig = prop.getValueDeserializer();\n                 JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer(unwrapper);\n      * Helper method that will handle gruesome details of dealing with properties\n      * that have non-static inner class as value...\n      */\n-    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationConfig config,\n+    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationContext ctxt,\n             SettableBeanProperty prop)\n     {            \n         /* Should we encounter a property that has non-static inner-class\n                     for (Constructor<?> ctor : valueClass.getConstructors()) {\n                         Class<?>[] paramTypes = ctor.getParameterTypes();\n                         if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n-                            if (config.canOverrideAccessModifiers()) {\n+                            if (ctxt.getConfig().canOverrideAccessModifiers()) {\n                                 ClassUtil.checkAndFixAccess(ctor);\n                             }\n                             return new SettableBeanProperty.InnerClassProperty(prop, ctor);\n      * Helper method called to (try to) locate deserializer for given sub-type of\n      * type that this deserializer handles.\n      */\n-    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens)\n+    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt,\n+            Object bean, TokenBuffer unknownTokens)\n         throws IOException, JsonProcessingException\n     {  \n         JsonDeserializer<Object> subDeser;\n             /* 09-Dec-2010, tatu: Would be nice to know which property pointed to this\n              *    bean... but, alas, no such information is retained, so:\n              */\n-            subDeser = deserProv.findValueDeserializer(ctxt.getConfig(), type, _property);\n+            subDeser = ctxt.findValueDeserializer(type, _property);\n             // Also, need to cache it\n             if (subDeser != null) {\n                 synchronized (this) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n      *   finding any serializer\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonDeserializer<Object> findValueDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n             JavaType propertyType, BeanProperty property)\n         throws JsonMappingException\n     {\n         if (deser != null) {\n             // [JACKSON-385]: need to support contextualization:\n             if (deser instanceof ContextualDeserializer<?>) {\n-                JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(config, property);\n+                JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(ctxt.getConfig(), property);\n                 deser = (JsonDeserializer<Object>) d;\n             }\n             return deser;\n         }\n         // If not, need to request factory to construct (or recycle)\n-        deser = _createAndCacheValueDeserializer(config, propertyType, property);\n+        deser = _createAndCacheValueDeserializer(ctxt, propertyType, property);\n         if (deser == null) {\n             /* Should we let caller handle it? Let's have a helper method\n              * decide it; can throw an exception, or return a valid\n         }\n         // [JACKSON-385]: need to support contextualization:\n         if (deser instanceof ContextualDeserializer<?>) {\n-            JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(config, property);\n+            JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(ctxt.getConfig(), property);\n             deser = (JsonDeserializer<Object>) d;\n         }\n         return deser;\n      * Since this method is only called for root elements, no referral information\n      * is taken.\n      */\n-    public JsonDeserializer<Object> findTypedValueDeserializer(DeserializationConfig config,\n+    public JsonDeserializer<Object> findTypedValueDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n-        JsonDeserializer<Object> deser = findValueDeserializer(config, type, property);\n-        TypeDeserializer typeDeser = _factory.findTypeDeserializer(config, type, property);\n+        JsonDeserializer<Object> deser = findValueDeserializer(ctxt, type, property);\n+        TypeDeserializer typeDeser = _factory.findTypeDeserializer(ctxt.getConfig(), type, property);\n         if (typeDeser != null) {\n             return new WrappedDeserializer(typeDeser, deser);\n         }\n      * a deserializer for given type, using a root reference (i.e. not\n      * through fields or membership in an array or collection)\n      */\n-    public boolean hasValueDeserializerFor(DeserializationConfig config, JavaType type)\n+    public boolean hasValueDeserializerFor(DeserializationContext ctxt, JavaType type)\n     {\n         /* Note: mostly copied from findValueDeserializer, except for\n          * handling of unknown types\n         JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n         if (deser == null) {\n             try {\n-                deser = _createAndCacheValueDeserializer(config, type, null);\n+                deser = _createAndCacheValueDeserializer(ctxt, type, null);\n             } catch (Exception e) {\n                 return false;\n             }\n      * @param type Type of property to deserializer\n      * @param property Property (field, setter, ctor arg) to use deserializer for\n      */\n-    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationConfig config,\n+    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n             }\n             // Nope: need to create and possibly cache\n             try {\n-                return _createAndCache2(config, type, property);\n+                return _createAndCache2(ctxt, type, property);\n             } finally {\n                 // also: any deserializers that have been created are complete by now\n                 if (count == 0 && _incompleteDeserializers.size() > 0) {\n      * Method that handles actual construction (via factory) and caching (both\n      * intermediate and eventual)\n      */\n-    protected JsonDeserializer<Object> _createAndCache2(DeserializationConfig config, JavaType type,\n-            BeanProperty property)\n+    protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n+            JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         JsonDeserializer<Object> deser;\n         try {\n-            deser = _createDeserializer(config, type, property);\n+            deser = _createDeserializer(ctxt.getConfig(), type, property);\n         } catch (IllegalArgumentException iae) {\n             /* We better only expose checked exceptions, since those\n              * are what caller is expected to handle\n          */\n         if (isResolvable) {\n             _incompleteDeserializers.put(type, deser);\n-            _resolveDeserializer(config, (ResolvableDeserializer)deser);\n+            _resolveDeserializer(ctxt, (ResolvableDeserializer)deser);\n             _incompleteDeserializers.remove(type);\n         }\n         if (addToCache) {\n         return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, this, type, property);\n     }\n \n-    protected void _resolveDeserializer(DeserializationConfig config, ResolvableDeserializer ser)\n-        throws JsonMappingException\n-    {\n-        ser.resolve(config, this);\n+    protected void _resolveDeserializer(DeserializationContext ctxt, ResolvableDeserializer ser)\n+        throws JsonMappingException\n+    {\n+        ser.resolve(ctxt);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n package com.fasterxml.jackson.databind.deser;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonMappingException;\n \n /**\n      * Called object can then resolve its dependencies to other types,\n      * including self-references (direct or indirect).\n      *\n-     * @param provider Provider that has constructed deserializer this method\n-     *   is called on.\n+     * @param ctxt Context to use for accessing configuration, resolving\n+     *    secondary deserializers\n      */\n-    public abstract void resolve(DeserializationConfig config, DeserializerCache provider)\n+    public abstract void resolve(DeserializationContext ctxt)\n         throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n     @Override\n     public JsonDeserializer<Object> findValueDeserializer(JavaType type,\n             BeanProperty property) throws JsonMappingException {\n-        return _deserProvider.findValueDeserializer(_config, type, property);\n+        return _deserProvider.findValueDeserializer(this, type, property);\n     }\n     \n     @Override\n     public JsonDeserializer<Object> findTypedValueDeserializer(JavaType type,\n             BeanProperty property) throws JsonMappingException {\n-        return _deserProvider.findTypedValueDeserializer(_config, type, property);\n+        return _deserProvider.findTypedValueDeserializer(this, type, property);\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n \n     protected final JavaType _collectionType;\n \n+    protected final BeanProperty _property;\n+    \n     /**\n      * Value deserializer.\n      */\n-    protected final JsonDeserializer<Object> _valueDeserializer;\n+    protected JsonDeserializer<Object> _valueDeserializer;\n \n     /**\n      * If element instances have polymorphic type information, this\n     /**********************************************************\n      */\n     \n-    public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser,\n+    public CollectionDeserializer(JavaType collectionType, BeanProperty prop,\n+            JsonDeserializer<Object> valueDeser,\n             TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator)\n     {\n         super(collectionType.getRawClass());\n         _collectionType = collectionType;\n+        _property = prop;\n         _valueDeserializer = valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n         _valueInstantiator = valueInstantiator;\n     {\n         super(src._valueClass);\n         _collectionType = src._collectionType;\n+        _property = src._property;\n         _valueDeserializer = src._valueDeserializer;\n         _valueTypeDeserializer = src._valueTypeDeserializer;\n         _valueInstantiator = src._valueInstantiator;\n      * is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerCache provider)\n+    public void resolve(DeserializationContext ctxt)\n         throws JsonMappingException\n     {\n         // May need to resolve types for delegate-based creators:\n         if (_valueInstantiator.canCreateUsingDelegate()) {\n-            JavaType delegateType = _valueInstantiator.getDelegateType(config);\n+            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n             if (delegateType == null) {\n                 throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n                         +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n             // Note: unlike BeanDeserializer, we don't have an AnnotatedClass around; hence no annotations passed\n             BeanProperty.Std property = new BeanProperty.Std(null,\n                     delegateType, null, delegateCreator);\n-            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n+        }\n+        // also, often value deserializer is resolved here:\n+        if (_valueDeserializer == null) {\n+            _valueDeserializer = ctxt.findValueDeserializer(_collectionType.getContentType(), _property);\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n public class EnumMapDeserializer\n     extends StdDeserializer<EnumMap<?,?>>\n+    implements ResolvableDeserializer\n {\n+    protected final JavaType _mapType;\n+    \n+    protected final BeanProperty _property;\n+    \n     protected final Class<?> _enumClass;\n \n     protected final JsonDeserializer<Enum<?>> _keyDeserializer;\n \n-    protected final JsonDeserializer<Object> _valueDeserializer;\n+    protected JsonDeserializer<Object> _valueDeserializer;\n \n-    public EnumMapDeserializer(Class<?> enumClass, JsonDeserializer<?> keyDeserializer,\n-            JsonDeserializer<Object> valueDeser)\n+    public EnumMapDeserializer(JavaType mapType, BeanProperty prop,\n+            JsonDeserializer<?> keyDeserializer, JsonDeserializer<Object> valueDeser)\n     {\n         super(EnumMap.class);\n-        _enumClass = enumClass;\n+        _mapType = mapType;\n+        _property = prop;\n+        _enumClass = mapType.getKeyType().getRawClass();\n         _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n         _valueDeserializer = valueDeser;\n     }\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n+\n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n+    {\n+        if (_valueDeserializer == null) {\n+            // 'null' -> arrays have no referring fields\n+            _valueDeserializer = ctxt.findValueDeserializer(_mapType.getContentType(), _property);\n+        }\n+    }\n     \n     private EnumMap<?,?> constructMap() {\n         return new EnumMap(_enumClass);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n         }\n         \n         @Override\n-        public void resolve(DeserializationConfig config, DeserializerCache provider)\n+        public void resolve(DeserializationContext ctxt)\n             throws JsonMappingException\n         {\n             if (_valueDeserializer == null) {\n-                _valueDeserializer = provider.findValueDeserializer(config, _referencedType, _property);\n+                _valueDeserializer = ctxt.findValueDeserializer(_referencedType, _property);\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n \n     protected final JavaType _mapType;\n \n+    protected final BeanProperty _property;\n+    \n     /**\n      * Key deserializer used, if not null. If null, String from JSON\n      * content is used as is.\n     /**\n      * Value deserializer.\n      */\n-    protected final JsonDeserializer<Object> _valueDeserializer;\n+    protected JsonDeserializer<Object> _valueDeserializer;\n \n     /**\n      * If value instances have polymorphic type information, this\n     /**********************************************************\n      */\n \n-    public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator,\n+    public MapDeserializer(JavaType mapType, BeanProperty prop,\n+            ValueInstantiator valueInstantiator,\n             KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n             TypeDeserializer valueTypeDeser)\n     {\n         super(Map.class);\n         _mapType = mapType;\n+        _property = prop;\n         _keyDeserializer = keyDeser;\n         _valueDeserializer = valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n     {\n         super(src._valueClass);\n         _mapType = src._mapType;\n+        _property = src._property;\n         _keyDeserializer = src._keyDeserializer;\n         _valueDeserializer = src._valueDeserializer;\n         _valueTypeDeserializer = src._valueTypeDeserializer;\n      * is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerCache provider)\n+    public void resolve(DeserializationContext ctxt)\n         throws JsonMappingException\n     {\n         // May need to resolve types for delegate- and/or property-based creators:\n         if (_valueInstantiator.canCreateUsingDelegate()) {\n-            JavaType delegateType = _valueInstantiator.getDelegateType(config);\n+            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n             if (delegateType == null) {\n                 throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n                         +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n             // Note: unlike BeanDeserializer, we don't have an AnnotatedClass around; hence no annotations passed\n             BeanProperty.Std property = new BeanProperty.Std(null,\n                     delegateType, null, delegateCreator);\n-            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n         }\n         if (_valueInstantiator.canCreateFromObjectWith()) {\n-            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(config);\n+            SettableBeanProperty[] creatorProps = _valueInstantiator.getFromObjectArguments(ctxt.getConfig());\n             _propertyBasedCreator = new PropertyBasedCreator(_valueInstantiator, creatorProps);\n             for (SettableBeanProperty prop : creatorProps) {\n                 if (!prop.hasValueDeserializer()) {\n-                    _propertyBasedCreator.assignDeserializer(prop, findDeserializer(config, provider, prop.getType(), prop));\n+                    _propertyBasedCreator.assignDeserializer(prop,\n+                            findDeserializer(ctxt, prop.getType(), prop));\n                 }\n             }\n+        }\n+        if (_valueDeserializer == null) {\n+            _valueDeserializer = ctxt.findValueDeserializer(_mapType.getContentType(), _property);\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.ArrayType;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n @JacksonStdImpl\n public class ObjectArrayDeserializer\n     extends ContainerDeserializerBase<Object[]>\n+    implements ResolvableDeserializer\n {\n     // // Configuration\n \n+    /**\n+     * Full generic type of the array being deserialized\n+     */\n     protected final JavaType _arrayType;\n+\n+    /**\n+     * Bean property for which deserializer was created; null\n+     * for root-level deserializers.\n+     */\n+    protected final BeanProperty _property;\n     \n     /**\n      * Flag that indicates whether the component type is Object or not.\n     /**\n      * Element deserializer\n      */\n-    protected final JsonDeserializer<Object> _elementDeserializer;\n+    protected JsonDeserializer<Object> _elementDeserializer;\n \n     /**\n      * If element instances have polymorphic type information, this\n      */\n     protected final TypeDeserializer _elementTypeDeserializer;\n \n-    public ObjectArrayDeserializer(ArrayType arrayType, JsonDeserializer<Object> elemDeser,\n-            TypeDeserializer elemTypeDeser)\n+    public ObjectArrayDeserializer(ArrayType arrayType, BeanProperty prop,\n+            JsonDeserializer<Object> elemDeser, TypeDeserializer elemTypeDeser)\n     {\n         super(Object[].class);\n         _arrayType = arrayType;\n+        _property = prop;\n         _elementClass = arrayType.getContentType().getRawClass();\n         _untyped = (_elementClass == Object.class);\n         _elementDeserializer = elemDeser;\n         return (Object[]) typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n     }\n \n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n+    {\n+        if (_elementDeserializer == null) {\n+            _elementDeserializer = ctxt.findValueDeserializer(_arrayType.getContentType(), _property);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n      * type this deserializer handles contains (usually for properties of\n      * bean types)\n      * \n-     * @param config Active deserialization configuration \n-     * @param provider Deserializer provider to use for actually finding deserializer(s)\n      * @param type Type of property to deserialize\n      * @param property Actual property object (field, method, constuctor parameter) used\n      *     for passing deserialized values; provided so deserializer can be contextualized if necessary (since 1.7)\n      */\n-    protected JsonDeserializer<Object> findDeserializer(DeserializationConfig config,\n-            DeserializerCache provider,\n+    protected JsonDeserializer<Object> findDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n-        return provider.findValueDeserializer(config, type, property);\n+        return ctxt.findValueDeserializer(type, property);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.deser.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n \n     protected final JavaType _collectionType;\n \n-    /**\n-     * Value deserializer; needed even if it is the standard String\n-     * deserializer\n-     */\n-    protected final JsonDeserializer<String> _valueDeserializer;\n-\n-    /**\n-     * Flag that indicates whether value deserializer is the standard\n-     * Jackson-provided one; if it is, we can use more efficient\n-     * handling.\n-     */\n-    protected final boolean _isDefaultDeserializer;\n+    protected final BeanProperty _property;\n+    \n+    /**\n+     * Value deserializer to use, if NOT the standard one\n+     * (if it is, will be null).\n+     */\n+    protected JsonDeserializer<String> _valueDeserializer;\n \n     // // Instance construction settings:\n     \n      */\n     \n     @SuppressWarnings(\"unchecked\")\n-    public StringCollectionDeserializer(JavaType collectionType, JsonDeserializer<?> valueDeser,\n+    public StringCollectionDeserializer(JavaType collectionType, BeanProperty prop,\n+            JsonDeserializer<?> valueDeser,\n             ValueInstantiator valueInstantiator)\n     {\n         super(collectionType.getRawClass());\n+        _property = prop;\n         _collectionType = collectionType;\n         _valueDeserializer = (JsonDeserializer<String>) valueDeser;\n         _valueInstantiator = valueInstantiator;\n-        _isDefaultDeserializer = isDefaultSerializer(valueDeser);\n-    }\n-\n-    /**\n-     * Copy-constructor that can be used by sub-classes to allow\n-     * copy-on-write styling copying of settings of an existing instance.\n-     */\n-    protected StringCollectionDeserializer(StringCollectionDeserializer src)\n-    {\n-        super(src._valueClass);\n-        _collectionType = src._collectionType;\n-        _valueDeserializer = src._valueDeserializer;\n-        _valueInstantiator = src._valueInstantiator;\n-        _isDefaultDeserializer = src._isDefaultDeserializer;\n     }\n \n     /*\n     /**********************************************************\n      */\n \n+    @SuppressWarnings(\"unchecked\")\n     /**\n      * Method called to finalize setup of this deserializer,\n      * after deserializer itself has been registered. This\n      * is needed to handle recursive and transitive dependencies.\n      */\n     @Override\n-    public void resolve(DeserializationConfig config, DeserializerCache provider)\n+    public void resolve(DeserializationContext ctxt)\n         throws JsonMappingException\n     {\n         // May need to resolve types for delegate-based creators:\n         AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n         if (delegateCreator != null) {\n-            JavaType delegateType = _valueInstantiator.getDelegateType(config);\n+            JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n             // Need to create a temporary property to allow contextual deserializers:\n             BeanProperty.Std property = new BeanProperty.Std(null,\n                     delegateType, null, delegateCreator);\n-            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n+        }\n+        if (_valueDeserializer == null) {\n+            // And we may also need to get deserializer for String\n+            JsonDeserializer<?> deser = ctxt.findValueDeserializer(_collectionType.getContentType(), _property);\n+            _valueDeserializer = (JsonDeserializer<String>) deser;\n+        }\n+        if (isDefaultSerializer(_valueDeserializer)) {\n+            _valueDeserializer = null;\n         }\n     }\n     \n             return handleNonArray(jp, ctxt, result);\n         }\n \n-        if (!_isDefaultDeserializer) {\n-            return deserializeUsingCustom(jp, ctxt, result);\n+        if (_valueDeserializer != null) {\n+            return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer);\n         }\n         JsonToken t;\n \n     }\n     \n     private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,\n-            Collection<String> result)\n+            Collection<String> result, final JsonDeserializer<String> deser)\n         throws IOException, JsonProcessingException\n     {\n         JsonToken t;\n-        final JsonDeserializer<String> deser = _valueDeserializer;\n-\n         while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n             String value;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n         ObjectMapper mapper = new ObjectMapper();\n         assertEquals(0, mapper._deserializerCache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = mapper.readValue(\"{ \\\"c\\\" : 3 }\", Bean.class);\n+        Bean bean = mapper.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n         assertNotNull(bean);\n         assertEquals(1, mapper._deserializerCache.cachedDeserializersCount());\n         mapper._deserializerCache.flushCachedDeserializers();\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n         }\n \n         @Override\n-        public void resolve(DeserializationConfig config, DeserializerCache provider)\n-            throws JsonMappingException\n+        public void resolve(DeserializationContext ctxt) throws JsonMappingException\n         {\n             try {\n                 Thread.sleep(100L);", "timestamp": 1327438978, "metainfo": ""}