{"sha": "5b0fd4d803b3c453504eb0d4d2ffedba930780ee", "log": "Generates schema in TestGenerateJsonSchema without throwing errors", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * @return Constructed JSON schema.\n      */\n     public Schema generateJsonSchema(Class<?> t) throws JsonMappingException {\n-    \tSchemaFactory visitor = new SchemaFactory(this);\n-        _serializerProvider(getSerializationConfig()).acceptJsonFormatVisitor(t, visitor);\n+    \tDefaultSerializerProvider provider = _serializerProvider(getSerializationConfig());\n+    \tSchemaFactory visitor = new SchemaFactory(provider);\n+        provider.acceptJsonFormatVisitor(t, visitor);\n         return visitor.finalSchema();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/AnySchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/AnySchemaFactory.java\n \tprotected AnySchema anySchema;\n \t\n \tpublic AnySchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tanySchema = new AnySchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ArraySchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ArraySchemaFactory.java\n \tprotected BeanProperty _property;\n \t\n \tpublic ArraySchemaFactory(SchemaFactory parent, BeanProperty property) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tarraySchema = new ArraySchema();\n \t}\n \t\t\ttry {\n \t\t\t\tser = getProvider().findValueSerializer(contentType, _property);\n \t\t\t\tif (ser instanceof SchemaAware) {\n-\t            \tSchemaFactory visitor = new SchemaFactory(mapper);\n+\t            \tSchemaFactory visitor = new SchemaFactory(provider);\n \t                ((SchemaAware) ser).acceptJsonFormatVisitor(visitor, null);\n \t                arraySchema.setItemsSchema(visitor.finalSchema());\n \t            }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/BooleanSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/BooleanSchemaFactory.java\n \tprotected BooleanSchema booleanSchema;\n \t\n \tpublic BooleanSchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tbooleanSchema = new BooleanSchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/IntegerSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/IntegerSchemaFactory.java\n \tprotected IntegerSchema integerSchema;\n \t\n \tpublic IntegerSchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tintegerSchema = new IntegerSchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NullSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NullSchemaFactory.java\n \tprotected NullSchema nullSchema;\n \t\n \tpublic NullSchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tnullSchema = new NullSchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NumberSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/NumberSchemaFactory.java\n \tprotected NumberSchema numberSchema;\n \t\n \tpublic NumberSchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tnumberSchema = new NumberSchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ObjectSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ObjectSchemaFactory.java\n \n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsonschema.types.ObjectSchema;\n import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n \tprotected ObjectSchema objectSchema;\n \t\n \tpublic ObjectSchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tobjectSchema = new ObjectSchema();\n \t}\n \t\t\t\t// TODO: log error\n \t\t\t}\n \t\t}\n-\t\treturn null;\n+\t\treturn ser;\n \t}\t\n \t\n \tprivate Class<?> writerType(BeanPropertyWriter writer) {\n \t}\n \t\n \tprotected Schema propertySchema(BeanPropertyWriter writer) {\n-\t\tSchemaFactory visitor = new SchemaFactory(mapper);\n+\t\tSchemaFactory visitor = new SchemaFactory(provider);\n \t\tClass<?> serType = writerType(writer);\n \t\tJsonSerializer<Object> ser = getSer(writer, serType);\n \t\tif (ser != null && ser instanceof SchemaAware) {\n \t}\n \t\n \tprotected Schema propertySchema(SchemaAware handler, Type propertyTypeHint) {\n-\t\tSchemaFactory visitor = new SchemaFactory(mapper);\n+\t\tSchemaFactory visitor = new SchemaFactory(provider);\n \t\thandler.acceptJsonFormatVisitor(visitor, propertyTypeHint);\n \t\treturn visitor.finalSchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/SchemaFactory.java\n \n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n import com.fasterxml.jackson.databind.jsonschema.visitors.JsonAnyFormatVisitor;\n \n public class SchemaFactory implements JsonFormatVisitor {\n \n-\tprotected ObjectMapper mapper;\n \tprivate SchemaFactoryDelegate delegate;\n-\t\n-\tpublic SerializerProvider getProvider() {\n-\t\treturn mapper.getSerializerProvider();\n+\tprotected SerializerProvider provider;\n+\n+\tpublic SchemaFactory(SerializerProvider mapper) {\n+\t\tthis.provider = mapper;\n \t}\n \n-\tpublic SchemaFactory(ObjectMapper mapper) {\n-\t\tthis.mapper = mapper;\n-\t}\n-\t\n-\tpublic JsonObjectFormatVisitor objectFormat(Type type) {\n-\t\t//BasicClassIntrospector.instance.\n-\t\tdelegate = new ObjectSchemaFactory(this);\n-\t\treturn (JsonObjectFormatVisitor) delegate;\n+\tpublic JsonAnyFormatVisitor anyFormat() {\n+\t\tdelegate = new AnySchemaFactory(this);\n+\t\treturn (JsonAnyFormatVisitor) delegate;\n \t}\n \n \tpublic JsonArrayFormatVisitor arrayFormat(Type elementType) {\n \t\tdelegate = new ArraySchemaFactory(this);\n \t\treturn (JsonArrayFormatVisitor) delegate;\n \t}\n-\t\n-\tpublic JsonStringFormatVisitor stringFormat() { \n-\t\tdelegate = new StringSchemaFactory(this);\n-\t\treturn (JsonStringFormatVisitor) delegate;\n+\n+\tpublic JsonBooleanFormatVisitor booleanFormat() {\n+\t\tdelegate = new BooleanSchemaFactory(this);\n+\t\treturn (JsonBooleanFormatVisitor) delegate;\n \t}\n-\tpublic JsonNumberFormatVisitor numberFormat() { return new NumberSchemaFactory(this); }\n-\tpublic JsonIntegerFormatVisitor integerFormat() { return new IntegerSchemaFactory(this); }\n-\tpublic JsonBooleanFormatVisitor booleanFormat() { return new BooleanSchemaFactory(this); }\n-\tpublic JsonNullFormatVisitor nullFormat() { return new NullSchemaFactory(this); }\n-\tpublic JsonAnyFormatVisitor anyFormat() { return new AnySchemaFactory(this); }\n \n \tpublic Schema finalSchema() {\n \t\tassert delegate != null : \"SchemaFactory must envoke a delegate method before it can return a Schema.\";\n \t\t} else {\n \t\t\treturn delegate.getSchema();\n \t\t}\n-\t\t\n+\n \t}\n-\t\n+\n+\tpublic SerializerProvider getProvider() {\n+\t\treturn provider;\n+\t}\n+\n+\tpublic JsonIntegerFormatVisitor integerFormat() {\n+\t\tdelegate = new IntegerSchemaFactory(this);\n+\t\treturn (JsonIntegerFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonNullFormatVisitor nullFormat() {\n+\t\tdelegate = new NullSchemaFactory(this);\n+\t\treturn (JsonNullFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonNumberFormatVisitor numberFormat() {\n+\t\tdelegate = new NumberSchemaFactory(this);\n+\t\treturn (JsonNumberFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonObjectFormatVisitor objectFormat(Type type) {\n+\t\t// BasicClassIntrospector.instance.\n+\t\tdelegate = new ObjectSchemaFactory(this);\n+\t\treturn (JsonObjectFormatVisitor) delegate;\n+\t}\n+\n+\tpublic JsonStringFormatVisitor stringFormat() {\n+\t\tdelegate = new StringSchemaFactory(this);\n+\t\treturn (JsonStringFormatVisitor) delegate;\n+\t}\n+\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/StringSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/StringSchemaFactory.java\n \tprotected SchemaFactory parent;\n \t\n \tpublic StringSchemaFactory(SchemaFactory parent) {\n-\t\tsuper(parent.mapper);\n+\t\tsuper(parent.provider);\n \t\tthis.parent = parent;\n \t\tstringSchema = new StringSchema();\n \t}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ValueTypeSchemaFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/factories/ValueTypeSchemaFactory.java\n \n import java.util.Set;\n \n-import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n import com.fasterxml.jackson.databind.jsonschema.types.ValueTypeSchema;\n public abstract class ValueTypeSchemaFactory extends SchemaFactory implements\n \t\tSchemaFactoryDelegate, JsonValueFormatVisitor {\n \n-\tprotected ValueTypeSchemaFactory(ObjectMapper mapper) {\n-\t\tsuper(mapper);\n+\tprotected ValueTypeSchemaFactory(SerializerProvider provider) {\n+\t\tsuper(provider);\n \t}\n \n \tpublic Schema getSchema() {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/AnySchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/AnySchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import java.util.HashSet;\n import java.util.Set;\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n \n \n public class AnySchema extends SimpleTypeSchema {\n-\t\n-\t@JsonProperty(required = true)\n-\tpublic final SchemaType type = SchemaType.ANY;\n \t\n \t/**\n \t * This provides an enumeration of all possible values that are valid\n \t@JsonProperty\n \tprivate Set<String> enums;\n \t\n-\tpublic void setEnums(Set<String> enums) {\n-\t\tthis.enums = enums;\n+\t@JsonProperty(required = true)\n+\tpublic final SchemaType type = SchemaType.ANY;\n+\t\n+\t//instance initializer block\n+\t{\n+\t\tenums = new HashSet<String>();\n \t}\n+\t\n+\t@Override\n+\tpublic AnySchema asAnySchema() { return this; }\n \t\n \t@Override\n \tpublic boolean isAnySchema() { return true; }\n \t\n-\t@Override\n-\tpublic AnySchema asAnySchema() { return this; }\n+\tpublic void setEnums(Set<String> enums) {\n+\t\tthis.enums = enums;\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ArraySchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ArraySchema.java\n  */\n public class ArraySchema extends ContainerTypeSchema {\n \t\n-\t@JsonProperty(required = true)\n-\tpublic final SchemaType type = SchemaType.ARRAY;\n+\t@JsonProperty\n+\tprivate ArraySchema.AdditionalItems additionalItems;\n \t\n+\t@JsonProperty\n+\tprivate ArraySchema.Items items;\n+\t/**This attribute defines the maximum number of values in an array*/\n+\t@JsonProperty\n+\tprivate int maxItems;\n \t/**This attribute defines the minimum number of values in an array*/\n \t@JsonProperty\n \tprivate int minItems;\n-\t/**\n-\t * {@link ArraySchema#minItems}\n-\t * @param minItems the minItems to set\n-\t */\n-\tpublic void setMinItems(int minItems) {\n-\t\tthis.minItems = minItems;\n-\t}\n-\t/**\n-\t * {@link ArraySchema#minItems}\n-\t * @return the minItems\n-\t */\n-\tpublic int getMinItems() {\n-\t\treturn minItems;\n-\t}\n \t\n-\t/**This attribute defines the maximum number of values in an array*/\n-\t@JsonProperty\n-\tprivate int maxItems;\n-\t/**\n-\t * {@link ArraySchema#maxItems}\n-\t * @param maxItems the maxItems to set\n-\t */\n-\tpublic void setMaxItems(int maxItems) {\n-\t\tthis.maxItems = maxItems;\n-\t}\n-\t/**\n-\t * {@link ArraySchema#maxItems}\n-\t * @return the maxItems\n-\t */\n-\tpublic int getMaxItems() {\n-\t\treturn maxItems;\n-\t}\n-\t\n+\t@JsonProperty(required = true)\n+\tpublic final SchemaType type = SchemaType.ARRAY;\n \t/**\n \t * This attribute indicates that all items in an array instance MUST be\n \t   unique (contains no two identical values).\n \t */\n \t@JsonProperty\n \tprivate Boolean uniqueItems;\n+\t\t\n+\t@Override\n+\tpublic ArraySchema asArraySchema() { return this; }\n \t\n-\t/**\n-\t * {@link ArraySchema#uniqueItems}\n-\t * @param uniqueItems the uniqueItems to set\n-\t */\n-\tpublic void setUniqueItems(Boolean uniqueItems) {\n-\t\tthis.uniqueItems = uniqueItems;\n-\t}\n-\t/**\n-\t * {@link ArraySchema#uniqueItems}\n-\t * @return the uniqueItems\n-\t */\n-\tpublic Boolean getUniqueItems() {\n-\t\treturn uniqueItems;\n-\t}\n-\n-\t\n-\t@JsonProperty\n-\tprivate ArraySchema.Items items;\n-\t/**\n-\t * {@link ArraySchema#items}\n-\t * @param items the items to set\n-\t */\n-\tpublic void setItems(ArraySchema.Items items) {\n-\t\tthis.items = items;\n-\t}\n-\t/**\n-\t * {@link ArraySchema#items}\n-\t * @return the items\n-\t */\n-\tpublic ArraySchema.Items getItems() {\n-\t\treturn items;\n-\t}\n-\t\n-\tpublic void setItemsSchema(Schema schema) {\n-\t\titems = new SingleItems(schema);\n-\t}\n-\t\n-\t@JsonProperty\n-\tprivate ArraySchema.AdditionalItems additionalItems;\n-\t/**\n-\t * {@link ArraySchema#additionalItems}\n-\t * @param additionalItems the additionalItems to set\n-\t */\n-\tpublic void setAdditionalItems(ArraySchema.AdditionalItems additionalItems) {\n-\t\tthis.additionalItems = additionalItems;\n-\t}\n \t/**\n \t * {@link ArraySchema#additionalItems}\n \t * @return the additionalItems\n \t}\n \t\n \t/**\n-\t * This attribute defines the allowed items in an instance array, and\n-\t   MUST be a schema or an array of schemas.  The default value is an\n-\t   empty schema which allows any value for items in the instance array.\n+\t * {@link ArraySchema#items}\n+\t * @return the items\n \t */\n-\tpublic static abstract class Items {}\n+\tpublic ArraySchema.Items getItems() {\n+\t\treturn items;\n+\t}\n+\t/**\n+\t * {@link ArraySchema#maxItems}\n+\t * @return the maxItems\n+\t */\n+\tpublic int getMaxItems() {\n+\t\treturn maxItems;\n+\t}\n+\n \t\n \t/**\n-\t * When this attribute value is a schema and the instance value is an\n-\t   array, then all the items in the array MUST be valid according to the\n-\t   schema.\n+\t * {@link ArraySchema#minItems}\n+\t * @return the minItems\n \t */\n-\tpublic static class SingleItems extends ArraySchema.Items {\n-\t\t@JsonProperty\n-\t\tprivate Schema schema;\n-\t\tpublic SingleItems(Schema schema) {\n-\t\t\tthis.schema = schema;\n-\t\t}\n+\tpublic int getMinItems() {\n+\t\treturn minItems;\n \t}\n+\t/**\n+\t * {@link ArraySchema#uniqueItems}\n+\t * @return the uniqueItems\n+\t */\n+\tpublic Boolean getUniqueItems() {\n+\t\treturn uniqueItems;\n+\t}\n+\t@Override\n+\tpublic boolean isArraySchema() { return true; }\n+\t\n+\t/**\n+\t * {@link ArraySchema#additionalItems}\n+\t * @param additionalItems the additionalItems to set\n+\t */\n+\tpublic void setAdditionalItems(ArraySchema.AdditionalItems additionalItems) {\n+\t\tthis.additionalItems = additionalItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#items}\n+\t * @param items the items to set\n+\t */\n+\tpublic void setItems(ArraySchema.Items items) {\n+\t\tthis.items = items;\n+\t}\n+\tpublic void setItemsSchema(Schema schema) {\n+\t\titems = new SingleItems(schema);\n+\t}\n+\t/**\n+\t * {@link ArraySchema#maxItems}\n+\t * @param maxItems the maxItems to set\n+\t */\n+\tpublic void setMaxItems(int maxItems) {\n+\t\tthis.maxItems = maxItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#minItems}\n+\t * @param minItems the minItems to set\n+\t */\n+\tpublic void setMinItems(int minItems) {\n+\t\tthis.minItems = minItems;\n+\t}\n+\t\n+\t/**\n+\t * {@link ArraySchema#uniqueItems}\n+\t * @param uniqueItems the uniqueItems to set\n+\t */\n+\tpublic void setUniqueItems(Boolean uniqueItems) {\n+\t\tthis.uniqueItems = uniqueItems;\n+\t}\n+\t\n+\t/**\n+\t * This provides a definition for additional items in an array instance\n+   when tuple definitions of the items is provided.\n+\t */\n+\tpublic static abstract class AdditionalItems {}\n \t\n \t/**\n \t * When this attribute value is an array of schemas and the instance\n \t}\n \t\n \t/**\n-\t * This provides a definition for additional items in an array instance\n-   when tuple definitions of the items is provided.\n+\t * This attribute defines the allowed items in an instance array, and\n+\t   MUST be a schema or an array of schemas.  The default value is an\n+\t   empty schema which allows any value for items in the instance array.\n \t */\n-\tpublic static abstract class AdditionalItems {}\n+\tpublic static abstract class Items {}\n \t\n \t/**\n \t *  This can be false\n \t\tprivate Schema schema;\n \t}\n \t\n-\t@Override\n-\tpublic boolean isArraySchema() { return true; }\n-\t\n-\t@Override\n-\tpublic ArraySchema asArraySchema() { return this; }\n+\t/**\n+\t * When this attribute value is a schema and the instance value is an\n+\t   array, then all the items in the array MUST be valid according to the\n+\t   schema.\n+\t */\n+\tpublic static class SingleItems extends ArraySchema.Items {\n+\t\t@JsonProperty\n+\t\tprivate Schema schema;\n+\t\tpublic SingleItems(Schema schema) {\n+\t\t\tthis.schema = schema;\n+\t\t}\n+\t}\n  }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ContainerTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ContainerTypeSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import java.util.HashSet;\n import java.util.Set;\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.databind.JsonNode;\n \n \n public abstract class ContainerTypeSchema extends SimpleTypeSchema {\n \t   (Section 5.15).\n \t */\n \t@JsonProperty(required = true)\n-\tprivate Set<JsonNode> enums;\n+\tprivate Set<String> enums;\n+\t\n+\t//instance initializer block \n+\t{\n+\t\tenums = new HashSet<String>();\n+\t}\n+\t\n+\t/**\n+\t * {@link ContainerTypeSchema#enums}\n+\t * @param enums the enums to set\n+\t */\n+\tpublic void setEnums(Set<String> enums) {\n+\t\tthis.enums = enums;\n+\t}\n+\t/**\n+\t * {@link ContainerTypeSchema#enums}\n+\t * @return the enums\n+\t */\n+\tpublic Set<String> getEnums() {\n+\t\treturn enums;\n+\t}\n \t\n \t@Override\n \tpublic boolean isContainerTypeSchema() { return true; }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/IntegerSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/IntegerSchema.java\n \t */\n \t@JsonProperty\n \tprivate Integer divisibleBy;\n+\t\n+\t/**\n+\t * {@link IntegerSchema#divisibleBy}\n+\t * @param divisibleBy the divisibleBy to set\n+\t */\n+\tpublic void setDivisibleBy(Integer divisibleBy) {\n+\t\tthis.divisibleBy = divisibleBy;\n+\t}\n+\t/**\n+\t * {@link IntegerSchema#divisibleBy}\n+\t * @return the divisibleBy\n+\t */\n+\tpublic Integer getDivisibleBy() {\n+\t\treturn divisibleBy;\n+\t}\n \n \t@Override\n \tpublic boolean isIntegerSchema() { return true; }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NumberSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/NumberSchema.java\n \n public class NumberSchema extends ValueTypeSchema {\n \t\n-\t@JsonProperty(required = true)\n-\tpublic final SchemaType type = SchemaType.NUMBER;\n+\t/**\n+\t * This attribute indicates if the value of the instance (if the\n+\t   instance is a number) can not equal the number defined by the\n+\t   \"maximum\" attribute.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean exclusiveMaximum;\n+\t\n+\t/**\n+\t * This attribute indicates if the value of the instance (if the\n+\t   instance is a number) can not equal the number defined by the\n+\t   \"minimum\" attribute.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean exclusiveMinimum;\n+\t\n+\t/**This attribute defines the maximum value of the instance property*/\n+\t@JsonProperty\n+\tprivate Double maximum;\n \t\n \t/**This attribute defines the minimum value of the instance property*/\n \t@JsonProperty\n \tprivate Double minimum;\n+\t\n+\t@JsonProperty(required = true)\n+\tpublic final SchemaType type = SchemaType.NUMBER;\n+\t\n+\t@Override\n+\tpublic NumberSchema asNumberSchema() { return this; }\n \t/**\n-\t * {@link NumberSchema#minimum}\n-\t * @param minimum the minimum to set\n+\t * {@link NumberSchema#exclusiveMaximum}\n+\t * @return the exclusiveMaximum\n \t */\n-\tpublic void setMinimum(Double minimum) {\n-\t\tthis.minimum = minimum;\n+\tpublic Boolean getExclusiveMaximum() {\n+\t\treturn exclusiveMaximum;\n+\t}\n+\t\n+\t/**\n+\t * {@link NumberSchema#exclusiveMinimum}\n+\t * @return the exclusiveMinimum\n+\t */\n+\tpublic Boolean getExclusiveMinimum() {\n+\t\treturn exclusiveMinimum;\n+\t}\n+\t/**\n+\t * {@link NumberSchema#maximum}\n+\t * @return the maximum\n+\t */\n+\tpublic Double getMaximum() {\n+\t\treturn maximum;\n \t}\n \t/**\n \t * {@link NumberSchema#minimum}\n \t\treturn minimum;\n \t}\n \t\n-\t\n-\t/**This attribute defines the maximum value of the instance property*/\n-\t@JsonProperty\n-\tprivate Double maximum;\n-\t/**\n-\t * {@link NumberSchema#maximum}\n-\t * @param maximum the maximum to set\n-\t */\n-\tpublic void setMaximum(Double maximum) {\n-\t\tthis.maximum = maximum;\n-\t}\n-\t/**\n-\t * {@link NumberSchema#maximum}\n-\t * @return the maximum\n-\t */\n-\tpublic Double getMaximum() {\n-\t\treturn maximum;\n-\t}\n-\t\n-\t/**\n-\t * This attribute indicates if the value of the instance (if the\n-\t   instance is a number) can not equal the number defined by the\n-\t   \"minimum\" attribute.\n-\t */\n-\t@JsonProperty\n-\tprivate Boolean exclusiveMinimum;\n-\t/**\n-\t * {@link NumberSchema#exclusiveMinimum}\n-\t * @param exclusiveMinimum the exclusiveMinimum to set\n-\t */\n-\tpublic void setExclusiveMinimum(Boolean exclusiveMinimum) {\n-\t\tthis.exclusiveMinimum = exclusiveMinimum;\n-\t}\n-\t/**\n-\t * {@link NumberSchema#exclusiveMinimum}\n-\t * @return the exclusiveMinimum\n-\t */\n-\tpublic Boolean getExclusiveMinimum() {\n-\t\treturn exclusiveMinimum;\n-\t}\n-\t\n-\t/**\n-\t * This attribute indicates if the value of the instance (if the\n-\t   instance is a number) can not equal the number defined by the\n-\t   \"maximum\" attribute.\n-\t */\n-\t@JsonProperty\n-\tprivate Boolean exclusiveMaximum;\n+\t@Override\n+\tpublic boolean isNumberSchema() { return true; }\n \t/**\n \t * {@link NumberSchema#exclusiveMaximum}\n \t * @param exclusiveMaximum the exclusiveMaximum to set\n \t\tthis.exclusiveMaximum = exclusiveMaximum;\n \t}\n \t/**\n-\t * {@link NumberSchema#exclusiveMaximum}\n-\t * @return the exclusiveMaximum\n+\t * {@link NumberSchema#exclusiveMinimum}\n+\t * @param exclusiveMinimum the exclusiveMinimum to set\n \t */\n-\tpublic Boolean getExclusiveMaximum() {\n-\t\treturn exclusiveMaximum;\n+\tpublic void setExclusiveMinimum(Boolean exclusiveMinimum) {\n+\t\tthis.exclusiveMinimum = exclusiveMinimum;\n \t}\n \n-\t@Override\n-\tpublic boolean isNumberSchema() { return true; }\n+\t/**\n+\t * {@link NumberSchema#maximum}\n+\t * @param maximum the maximum to set\n+\t */\n+\tpublic void setMaximum(Double maximum) {\n+\t\tthis.maximum = maximum;\n+\t}\n \t\n-\t@Override\n-\tpublic NumberSchema asNumberSchema() { return this; }\n+\t/**\n+\t * {@link NumberSchema#minimum}\n+\t * @param minimum the minimum to set\n+\t */\n+\tpublic void setMinimum(Double minimum) {\n+\t\tthis.minimum = minimum;\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ObjectSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ObjectSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import java.util.ArrayList;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonValue;\n \n public class ObjectSchema extends ContainerTypeSchema {\n-\t\n+\n+\t/**\n+\t * This attribute defines a schema for all properties that are not\n+\t * explicitly defined in an object type definition. If specified, the value\n+\t * MUST be a schema or a boolean. If false is provided, no additional\n+\t * properties are allowed beyond the properties defined in the schema. The\n+\t * default value is an empty schema which allows any value for additional\n+\t * properties.\n+\t */\n+\t@JsonProperty\n+\tprivate AdditionalProperties additionalProperties;\n+\n+\t/**\n+\t * This attribute is an object that defines the requirements of a property\n+\t * on an instance object. If an object instance has a property with the same\n+\t * name as a property in this attribute's object, then the instance must be\n+\t * valid against the attribute's property value\n+\t */\n+\t@JsonProperty\n+\tprivate List<Dependency> dependencies;\n+\n+\t/**\n+\t * \n+\t This attribute is an object that defines the schema for a set of property\n+\t * names of an object instance. The name of each property of this\n+\t * attribute's object is a regular expression pattern in the ECMA 262/Perl 5\n+\t * format, while the value is a schema. If the pattern matches the name of a\n+\t * property on the instance object, the value of the instance's property\n+\t * MUST be valid against the pattern name's schema value.\n+\t */\n+\t@JsonProperty\n+\tprivate Map<String, Schema> patternProperties;\n+\n+\t/**\n+\t * This attribute is an object with property definitions that define the\n+\t * valid values of instance object property values. When the instance value\n+\t * is an object, the property values of the instance object MUST conform to\n+\t * the property definitions in this object. In this object, each property\n+\t * definition's value MUST be a schema, and the property's name MUST be the\n+\t * name of the instance property that it defines. The instance property\n+\t * value MUST be valid according to the schema from the property definition.\n+\t * Properties are considered unordered, the order of the instance properties\n+\t * MAY be in any order.\n+\t */\n+\t@JsonProperty\n+\tprivate Map<String, Schema> properties;\n+\n \t@JsonProperty(required = true)\n-\tpublic final String type = SchemaType.OBJECT.toString();\n-\t\n-\t/**\n-\t *  This attribute is an object with property definitions that define the\n-\t   valid values of instance object property values.  When the instance\n-\t   value is an object, the property values of the instance object MUST\n-\t   conform to the property definitions in this object.  In this object,\n-\t   each property definition's value MUST be a schema, and the property's\n-\t   name MUST be the name of the instance property that it defines.  The\n-\t   instance property value MUST be valid according to the schema from\n-\t   the property definition.  Properties are considered unordered, the\n-\t   order of the instance properties MAY be in any order.\n-\t */\n-\t@JsonProperty\n-\tprivate Map<String, Schema> properties;\n+\tpublic final SchemaType type = SchemaType.OBJECT;\n+\n+\t// instance initializer block\n+\t{\n+\t\tdependencies = new ArrayList<Dependency>();\n+\t\tpatternProperties = new HashMap<String, Schema>();\n+\t\tproperties = new HashMap<String, Schema>();\n+\t}\n+\n+\tpublic boolean addSchemaDependency(String depender, Schema parentMustMatch) {\n+\t\treturn dependencies\n+\t\t\t\t.add(new SchemaDependency(depender, parentMustMatch));\n+\t}\n+\n+\tpublic boolean addSimpleDependency(String depender, String dependsOn) {\n+\t\treturn dependencies.add(new SimpleDependency(depender, dependsOn));\n+\t}\n+\n+\t@Override\n+\tpublic ObjectSchema asObjectSchema() {\n+\t\treturn this;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#additionalProperties}\n+\t * \n+\t * @return the additionalProperties\n+\t */\n+\tpublic AdditionalProperties getAdditionalProperties() {\n+\t\treturn additionalProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#dependencies}\n+\t * \n+\t * @return the dependencies\n+\t */\n+\tpublic List<Dependency> getDependencies() {\n+\t\treturn dependencies;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#patternProperties}\n+\t * \n+\t * @return the patternProperties\n+\t */\n+\tpublic Map<String, Schema> getPatternProperties() {\n+\t\treturn patternProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#properties}\n+\t * \n+\t * @return the properties\n+\t */\n+\tpublic Map<String, Schema> getProperties() {\n+\t\treturn properties;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isObjectSchema() {\n+\t\treturn true;\n+\t}\n+\n+\tpublic void putOptionalProperty(String name, Schema schema) {\n+\t\t// just don't put anything in the property list\n+\t}\n+\n+\tpublic Schema putPatternProperty(String regex, Schema value) {\n+\t\treturn patternProperties.put(regex, value);\n+\t}\n+\n \tpublic Schema putProperty(String name, Schema value) {\n \t\treturn properties.put(name, value);\n \t}\n-\tpublic void putOptionalProperty(String name, Schema schema) {\n-\t\t// just don't put anything in the property list\n-\t}\n-\t/**\n-\t * {@link ObjectSchema#properties}\n-\t * @param properties the properties to set\n-\t */\n-\tpublic void setProperties(Map<String, Schema> properties) {\n-\t\tthis.properties = properties;\n-\t}\n-\t/**\n-\t * {@link ObjectSchema#properties}\n-\t * @return the properties\n-\t */\n-\tpublic Map<String, Schema> getProperties() {\n-\t\treturn properties;\n-\t}\n-\t\n-\t\n-\t/**\n-\t * \n-\t   This attribute is an object that defines the schema for a set of\n-\t   property names of an object instance.  The name of each property of\n-\t   this attribute's object is a regular expression pattern in the ECMA\n-\t   262/Perl 5 format, while the value is a schema.  If the pattern\n-\t   matches the name of a property on the instance object, the value of\n-\t   the instance's property MUST be valid against the pattern name's\n-\t   schema value.\n-\t */\n-\t@JsonProperty\n-\tprivate Map<String, Schema> patternProperties;\n-\tpublic Schema putPatternProperty(String regex, Schema value) {\n-\t\treturn patternProperties.put(regex, value);\n-\t}\n-\t/**\n-\t * {@link ObjectSchema#patternProperties}\n-\t * @param patternProperties the patternProperties to set\n-\t */\n-\tpublic void setPatternProperties(Map<String, Schema> patternProperties) {\n-\t\tthis.patternProperties = patternProperties;\n-\t}\n-\t/**\n-\t * {@link ObjectSchema#patternProperties}\n-\t * @return the patternProperties\n-\t */\n-\tpublic Map<String, Schema> getPatternProperties() {\n-\t\treturn patternProperties;\n-\t}\n-\t\n-\t/**\n-\t * This attribute defines a schema for all properties that are not\n-\t   explicitly defined in an object type definition.  If specified, the\n-\t   value MUST be a schema or a boolean.  If false is provided, no\n-\t   additional properties are allowed beyond the properties defined in\n-\t   the schema.  The default value is an empty schema which allows any\n-\t   value for additional properties.\n-\t */\n-\t@JsonProperty\n-\tprivate AdditionalProperties additionalProperties;\n+\n \tpublic void rejectAdditionalProperties() {\n \t\tadditionalProperties = NoAdditionalProperties.instance;\n \t}\n+\n \t/**\n \t * {@link ObjectSchema#additionalProperties}\n-\t * @param additionalProperties the additionalProperties to set\n+\t * \n+\t * @param additionalProperties\n+\t *            the additionalProperties to set\n \t */\n \tpublic void setAdditionalProperties(\n \t\t\tAdditionalProperties additionalProperties) {\n \t\tthis.additionalProperties = additionalProperties;\n \t}\n-\t/**\n-\t * {@link ObjectSchema#additionalProperties}\n-\t * @return the additionalProperties\n-\t */\n-\tpublic AdditionalProperties getAdditionalProperties() {\n-\t\treturn additionalProperties;\n-\t}\n-\t\n-\tpublic static abstract class AdditionalProperties {}\n+\n+\t/**\n+\t * {@link ObjectSchema#dependencies}\n+\t * \n+\t * @param dependencies\n+\t *            the dependencies to set\n+\t */\n+\tpublic void setDependencies(List<Dependency> dependencies) {\n+\t\tthis.dependencies = dependencies;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#patternProperties}\n+\t * \n+\t * @param patternProperties\n+\t *            the patternProperties to set\n+\t */\n+\tpublic void setPatternProperties(Map<String, Schema> patternProperties) {\n+\t\tthis.patternProperties = patternProperties;\n+\t}\n+\n+\t/**\n+\t * {@link ObjectSchema#properties}\n+\t * \n+\t * @param properties\n+\t *            the properties to set\n+\t */\n+\tpublic void setProperties(Map<String, Schema> properties) {\n+\t\tthis.properties = properties;\n+\t}\n+\n+\tpublic static abstract class AdditionalProperties {\n+\t}\n+\n+\tpublic static abstract class Dependency {\n+\t}\n+\n \tpublic static class NoAdditionalProperties extends AdditionalProperties {\n-\t\tpublic static final NoAdditionalProperties instance = new NoAdditionalProperties();\n-\t\t\n-\t\tprotected NoAdditionalProperties() {}\n-\t\t\n+\t\tpublic final Boolean schema = false;\n+\n+\t\tprotected NoAdditionalProperties() {\n+\t\t}\n+\n \t\t@JsonValue\n \t\tpublic Boolean value() {\n \t\t\treturn schema;\n \t\t}\n-\t\t\n-\t\tpublic final Boolean schema = false;\n-\t}\n-\tpublic static class SchemaAdditionalProperties extends AdditionalProperties{\n-\t\t\n+\n+\t\tpublic static final NoAdditionalProperties instance = new NoAdditionalProperties();\n+\t}\n+\n+\tpublic static class SchemaAdditionalProperties extends AdditionalProperties {\n+\n \t\t@JsonProperty\n \t\tprivate Schema schema;\n-\t\t\n+\n \t\tpublic SchemaAdditionalProperties(Schema schema) {\n \t\t\tthis.schema = schema;\n \t\t}\n \t}\n-\t/**\n-\t * This attribute is an object that defines the requirements of a\n-\t   property on an instance object.  If an object instance has a property\n-\t   with the same name as a property in this attribute's object, then the\n-\t   instance must be valid against the attribute's property value\n-\t */\n-\t@JsonProperty\n-\tprivate List<Dependency> dependencies;\n-\t/**\n-\t * {@link ObjectSchema#dependencies}\n-\t * @param dependencies the dependencies to set\n-\t */\n-\tpublic void setDependencies(List<Dependency> dependencies) {\n-\t\tthis.dependencies = dependencies;\n-\t}\n-\t/**\n-\t * {@link ObjectSchema#dependencies}\n-\t * @return the dependencies\n-\t */\n-\tpublic List<Dependency> getDependencies() {\n-\t\treturn dependencies;\n-\t}\n-\t\n-\tpublic boolean addSimpleDependency(String depender, String dependsOn) {\n-\t\treturn dependencies.add(new SimpleDependency(depender, dependsOn));\n-\t}\n-\tpublic boolean addSchemaDependency(String depender, Schema parentMustMatch) {\n-\t\treturn dependencies.add(new SchemaDependency(depender, parentMustMatch));\n-\t}\n-\t\n-\tpublic static abstract class Dependency {}\n-\n-\t/**\n-\t * Simple Dependency  If the dependency value is a string, then the\n-      instance object MUST have a property with the same name as the\n-      dependency value.  If the dependency value is an array of strings,\n-      then the instance object MUST have a property with the same name\n-      as each string in the dependency value's array.\n+\n+\t/**\n+\t * Schema Dependency If the dependency value is a schema, then the instance\n+\t * object MUST be valid against the schema.\n+\t */\n+\tpublic static class SchemaDependency extends Dependency {\n+\n+\t\t@JsonProperty(required = true)\n+\t\tprivate String depender;\n+\n+\t\t@JsonProperty(required = true)\n+\t\tprivate Schema parentMustMatch;\n+\n+\t\tpublic SchemaDependency(String depender, Schema parentMustMatch) {\n+\t\t\tthis.depender = depender;\n+\t\t\tthis.parentMustMatch = parentMustMatch;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Simple Dependency If the dependency value is a string, then the instance\n+\t * object MUST have a property with the same name as the dependency value.\n+\t * If the dependency value is an array of strings, then the instance object\n+\t * MUST have a property with the same name as each string in the dependency\n+\t * value's array.\n \t */\n \tpublic static class SimpleDependency extends Dependency {\n-\t\t\n+\n \t\t@JsonProperty(required = true)\n \t\tprivate String depender;\n-\t\t\n+\n \t\t@JsonProperty(required = true)\n \t\tprivate String dependsOn;\n-\t\t\n+\n \t\tpublic SimpleDependency(String depender, String dependsOn) {\n \t\t\tthis.depender = depender;\n \t\t\tthis.dependsOn = dependsOn;\n \t\t}\n \t}\n-\t\n-\t/**\n-\t * Schema Dependency  If the dependency value is a schema, then the\n-  \t\tinstance object MUST be valid against the schema.\n-\t */\n-\tpublic static class SchemaDependency extends Dependency {\n-\t\t\n-\t\t@JsonProperty(required = true)\n-\t\tprivate String depender;\n-\t\t\n-\t\t@JsonProperty(required = true)\n-\t\tprivate Schema parentMustMatch;\n-\t\tpublic SchemaDependency(String depender, Schema parentMustMatch) {\n-\t\t\tthis.depender = depender;\n-\t\t\tthis.parentMustMatch = parentMustMatch;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic boolean isObjectSchema() { return true ;}\n-\t\n-\t@Override\n-\tpublic ObjectSchema asObjectSchema() { return this; }\n \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/Schema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/Schema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n-\n \n import com.fasterxml.jackson.annotation.JsonGetter;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonSetter;\n \n /**\n- * <a href=\"http://tools.ietf.org/id/draft-zyp-json-schema-03.txt\"> Json Schema Draft </a>\n- *  <blockquote>\n-   \tJSON (JavaScript Object Notation) Schema defines the media type\n-\t\"application/schema+json\", a JSON based format for defining the\n-\tstructure of JSON data.  JSON Schema provides a contract for what\n-\tJSON data is required for a given application and how to interact\n-\twith it.  JSON Schema is intended to define validation,\n-\tdocumentation, hyperlink navigation, and interaction control of JSON\n-\tdata.\n-\t</blockquote>\n-\t\n-\t<blockquote>\n-\tJSON (JavaScript Object Notation) Schema is a JSON media type for\n-\tdefining the structure of JSON data.  JSON Schema provides a contract\n-\tfor what JSON data is required for a given application and how to\n-\tinteract with it.  JSON Schema is intended to define validation,\n-\tdocumentation, hyperlink navigation, and interaction control of JSON\n-\tdata.\n-\t</blockquote>\n-\t\n-\tAn example JSON Schema provided by the Schema draft:\n-\t<pre>\n-\t{\n-\t  \"name\":\"Product\",\n-\t  \"properties\":{\n-\t    \"id\":{\n-\t      \"type\":\"number\",\n-\t      \"description\":\"Product identifier\",\n-\t      \"required\":true\n-\t    },\n-\t    \"name\":{\n-\t      \"description\":\"Name of the product\",\n-\t      \"type\":\"string\",\n-\t      \"required\":true\n-\t    },\n-\t    \"price\":{\n-\t      \"required\":true,\n-\t      \"type\": \"number\",\n-\t      \"minimum\":0,\n-\t      \"required\":true\n-\t    },\n-\t    \"tags\":{\n-\t      \"type\":\"array\",\n-\t      \"items\":{\n-\t        \"type\":\"string\"\n-\t      }\n-\t    }\n-\t  },\n-\t  \"links\":[\n-\t    {\n-\t      \"rel\":\"full\",\n-\t      \"href\":\"{id}\"\n-\t    },\n-\t    {\n-\t      \"rel\":\"comments\",\n-\t      \"href\":\"comments/?id={id}\"\n-\t    }\n-\t  ]\n-\t}\n-\t</pre>\n-\n+ * <a href=\"http://tools.ietf.org/id/draft-zyp-json-schema-03.txt\"> Json Schema\n+ * Draft </a> <blockquote> JSON (JavaScript Object Notation) Schema defines the\n+ * media type \"application/schema+json\", a JSON based format for defining the\n+ * structure of JSON data. JSON Schema provides a contract for what JSON data is\n+ * required for a given application and how to interact with it. JSON Schema is\n+ * intended to define validation, documentation, hyperlink navigation, and\n+ * interaction control of JSON data. </blockquote>\n+ * \n+ * <blockquote> JSON (JavaScript Object Notation) Schema is a JSON media type\n+ * for defining the structure of JSON data. JSON Schema provides a contract for\n+ * what JSON data is required for a given application and how to interact with\n+ * it. JSON Schema is intended to define validation, documentation, hyperlink\n+ * navigation, and interaction control of JSON data. </blockquote>\n+ * \n+ * An example JSON Schema provided by the Schema draft:\n+ * \n+ * <pre>\n+ * \t{\n+ * \t  \"name\":\"Product\",\n+ * \t  \"properties\":{\n+ * \t    \"id\":{\n+ * \t      \"type\":\"number\",\n+ * \t      \"description\":\"Product identifier\",\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"name\":{\n+ * \t      \"description\":\"Name of the product\",\n+ * \t      \"type\":\"string\",\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"price\":{\n+ * \t      \"required\":true,\n+ * \t      \"type\": \"number\",\n+ * \t      \"minimum\":0,\n+ * \t      \"required\":true\n+ * \t    },\n+ * \t    \"tags\":{\n+ * \t      \"type\":\"array\",\n+ * \t      \"items\":{\n+ * \t        \"type\":\"string\"\n+ * \t      }\n+ * \t    }\n+ * \t  },\n+ * \t  \"links\":[\n+ * \t    {\n+ * \t      \"rel\":\"full\",\n+ * \t      \"href\":\"{id}\"\n+ * \t    },\n+ * \t    {\n+ * \t      \"rel\":\"comments\",\n+ * \t      \"href\":\"comments/?id={id}\"\n+ * \t    }\n+ * \t  ]\n+ * \t}\n+ * </pre>\n+ * \n  * @author jphelan\n  */\n-public abstract class Schema { \n-\t\n+public abstract class Schema {\n+\n+\t/**\n+\t * This attribute defines a URI of a schema that contains the full\n+\t * representation of this schema. When a validator encounters this\n+\t * attribute, it SHOULD replace the current schema with the schema\n+\t * referenced by the value's URI (if known and available) and re- validate\n+\t * the instance. This URI MAY be relative or absolute, and relative URIs\n+\t * SHOULD be resolved against the URI of the current schema.\n+\t */\n+\t@JsonProperty\n+\tprivate String $ref;\n+\n+\t/**\n+\t * This attribute defines a URI of a JSON Schema that is the schema of the\n+\t * current schema. When this attribute is defined, a validator SHOULD use\n+\t * the schema referenced by the value's URI (if known and available) when\n+\t * resolving Hyper Schema (Section 6) links (Section 6.1).\n+\t * \n+\t * A validator MAY use this attribute's value to determine which version of\n+\t * JSON Schema the current schema is written in, and provide the appropriate\n+\t * validation features and behavior. Therefore, it is RECOMMENDED that all\n+\t * schema authors include this attribute in their schemas to prevent\n+\t * conflicts with future JSON Schema specification changes.\n+\t */\n+\t@JsonProperty\n+\tprivate String $schema;\n+\n+\t/**\n+\t * This attribute takes the same values as the \"type\" attribute, however if\n+\t * the instance matches the type or if this value is an array and the\n+\t * instance matches any type or schema in the array, then this instance is\n+\t * not valid.\n+\t */\n+\t@JsonProperty\n+\tprivate Schema[] disallow;\n+\t/**\n+\t * The value of this property MUST be another schema which will provide a\n+\t * base schema which the current schema will inherit from. The inheritance\n+\t * rules are such that any instance that is valid according to the current\n+\t * schema MUST be valid according to the referenced schema. This MAY also be\n+\t * an array, in which case, the instance MUST be valid for all the schemas\n+\t * in the array. A schema that extends another schema MAY define additional\n+\t * attributes, constrain existing attributes, or add other constraints.\n+\t * \n+\t * Conceptually, the behavior of extends can be seen as validating an\n+\t * instance against all constraints in the extending schema as well as the\n+\t * extended schema(s). More optimized implementations that merge schemas are\n+\t * possible, but are not required. An example of using \"extends\":\n+\t * \n+\t * { \"description\":\"An adult\", \"properties\":{\"age\":{\"minimum\": 21}},\n+\t * \"extends\":\"person\" } { \"description\":\"Extended schema\",\n+\t * \"properties\":{\"deprecated\":{\"type\": \"boolean\"}},\n+\t * \"extends\":\"http://json-schema.org/draft-03/schema\" }\n+\t */\n+\t@JsonIgnore\n+\tprivate Schema[] extendsextends;\n+\t/**\n+\t * This attribute defines the current URI of this schema (this attribute is\n+\t * effectively a \"self\" link). This URI MAY be relative or absolute. If the\n+\t * URI is relative it is resolved against the current URI of the parent\n+\t * schema it is contained in. If this schema is not contained in any parent\n+\t * schema, the current URI of the parent schema is held to be the URI under\n+\t * which this schema was addressed. If id is missing, the current URI of a\n+\t * schema is defined to be that of the parent schema. The current URI of the\n+\t * schema is also used to construct relative references such as for $ref.\n+\t */\n+\t@JsonProperty\n+\tprivate String id;\n+\t/**\n+\t * This attribute indicates if the instance must have a value, and not be\n+\t * undefined. This is false by default, making the instance optional.\n+\t */\n+\t@JsonProperty\n+\tprivate Boolean required = false;// default = false;\n+\n+\t@JsonProperty(required = true)\n \tpublic final SchemaType type = null;\n-\t\n-\tpublic SchemaType getType() {\n-\t\treturn this.type;\n-\t}\n-\t\n-\t/**\n-\t * This attribute indicates if the instance must have a value, and not\n-\t   be undefined.  This is false by default, making the instance\n-\t   optional.\n-\t */\n-\t@JsonProperty\n-\tprivate Boolean required = false;// default = false;\n-\t/**\n-\t * {@link Schema#required}\n-\t * @param required the required to set\n-\t */\n-\tpublic void setRequired(Boolean required) {\n-\t\tthis.required = required;\n-\t}\n-\t/**\n-\t * {@link Schema#required}\n-\t * @return the required\n-\t */\n-\tpublic Boolean getRequired() {\n-\t\treturn required;\n-\t}\n-\t/**\n-\t *  This attribute defines the current URI of this schema (this attribute\n-\t   is effectively a \"self\" link).  This URI MAY be relative or absolute.\n-\t   If the URI is relative it is resolved against the current URI of the\n-\t   parent schema it is contained in.  If this schema is not contained in\n-\t   any parent schema, the current URI of the parent schema is held to be\n-\t   the URI under which this schema was addressed.  If id is missing, the\n-\t   current URI of a schema is defined to be that of the parent schema.\n-\t   The current URI of the schema is also used to construct relative\n-\t   references such as for $ref.\n-\t */\n-\t@JsonProperty\n-\tprivate String id;\n-\t/**\n-\t * {@link Schema#id}\n-\t * @param id the id to set\n-\t */\n-\tpublic void setId(String id) {\n-\t\tthis.id = id;\n-\t}\n-\t/**\n-\t * {@link Schema#id}\n-\t * @return the id\n-\t */\n-\tpublic String getId() {\n-\t\treturn id;\n-\t}\n-\t/**\n-\t * This attribute defines a URI of a schema that contains the full\n-\t   representation of this schema.  When a validator encounters this\n-\t   attribute, it SHOULD replace the current schema with the schema\n-\t   referenced by the value's URI (if known and available) and re-\n-\t   validate the instance.  This URI MAY be relative or absolute, and\n-\t   relative URIs SHOULD be resolved against the URI of the current\n-\t   schema.\n-\t */\n-\t@JsonProperty\n-\tprivate String $ref; \n+\n+\tpublic AnySchema asAnySchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic ArraySchema asArraySchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic BooleanSchema asBooleanSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic ContainerTypeSchema asContainerSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic IntegerSchema asIntegerSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic NullSchema asNullSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic NumberSchema asNumberSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic ObjectSchema asObjectSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic SimpleTypeSchema asSimpleTypeSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic StringSchema asStringSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic UnionTypeSchema asUnionTypeSchema() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic ValueTypeSchema asValueSchemaSchema() {\n+\t\treturn null;\n+\t}\n+\n \t/**\n \t * {@link Schema#$ref}\n-\t * @param $ref the $ref to set\n-\t */\n-\tpublic void set$ref(String $ref) {\n-\t\tthis.$ref = $ref;\n-\t}\n-\t/**\n-\t * {@link Schema#$ref}\n+\t * \n \t * @return the $ref\n \t */\n \tpublic String get$ref() {\n \t\treturn $ref;\n \t}\n-\t/**\n-\t * This attribute defines a URI of a JSON Schema that is the schema of\n-\t   the current schema.  When this attribute is defined, a validator\n-\t   SHOULD use the schema referenced by the value's URI (if known and\n-\t   available) when resolving Hyper Schema (Section 6) links\n-\t   (Section 6.1).\n-\t\n-\t   A validator MAY use this attribute's value to determine which version\n-\t   of JSON Schema the current schema is written in, and provide the\n-\t   appropriate validation features and behavior.  Therefore, it is\n-\t   RECOMMENDED that all schema authors include this attribute in their\n-\t   schemas to prevent conflicts with future JSON Schema specification\n-\t   changes.\n-\n-\t */\n-\t@JsonProperty\n-\tprivate String $schema;\n+\n \t/**\n \t * {@link Schema#$schema}\n-\t * @param $schema the $schema to set\n-\t */\n-\tpublic void set$schema(String $schema) {\n-\t\tthis.$schema = $schema;\n-\t}\n-\t/**\n-\t * {@link Schema#$schema}\n+\t * \n \t * @return the $schema\n \t */\n \tpublic String get$schema() {\n \t\treturn $schema;\n \t}\n-\t/**\n-\t * The value of this property MUST be another schema which will provide\n-\t   a base schema which the current schema will inherit from.  The\n-\t   inheritance rules are such that any instance that is valid according\n-\t   to the current schema MUST be valid according to the referenced\n-\t   schema.  This MAY also be an array, in which case, the instance MUST\n-\t   be valid for all the schemas in the array.  A schema that extends\n-\t   another schema MAY define additional attributes, constrain existing\n-\t   attributes, or add other constraints.\n-\t\n-\t   Conceptually, the behavior of extends can be seen as validating an\n-\t   instance against all constraints in the extending schema as well as\n-\t   the extended schema(s).  More optimized implementations that merge\n-\t   schemas are possible, but are not required.  An example of using\n-\t   \"extends\":\n-\t\n-\t   {\n-\t     \"description\":\"An adult\",\n-\t     \"properties\":{\"age\":{\"minimum\": 21}},\n-\t     \"extends\":\"person\"\n-\t   }\n-\t   {\n-\t     \"description\":\"Extended schema\",\n-\t     \"properties\":{\"deprecated\":{\"type\": \"boolean\"}},\n-\t     \"extends\":\"http://json-schema.org/draft-03/schema\"\n-\t   }\n-\t */\n-\t@JsonIgnore\n-\tprivate Schema[] extendsextends;\n+\n+\t/**\n+\t * {@link Schema#disallow}\n+\t * \n+\t * @return the disallow\n+\t */\n+\tpublic Schema[] getDisallow() {\n+\t\treturn disallow;\n+\t}\n+\n \t/**\n \t * {@link Schema#extendsextends}\n-\t * @param extendsextends the extendsextends to set\n-\t */\n-\t@JsonSetter(\"extends\")\t\n-\tpublic void setExtends(Schema[] extendsextends) {\n-\t\tthis.extendsextends = extendsextends;\n-\t}\n-\t/**\n-\t * {@link Schema#extendsextends}\n+\t * \n \t * @return the extendsextends\n \t */\n \t@JsonGetter(\"extends\")\n \tpublic Schema[] getExtends() {\n \t\treturn extendsextends;\n \t}\n-\t/**\n-\t * This attribute takes the same values as the \"type\" attribute, however\n-\t   if the instance matches the type or if this value is an array and the\n-\t   instance matches any type or schema in the array, then this instance\n-\t   is not valid.\n-\t */\n-\t@JsonProperty\n-\tprivate Schema[] disallow;\n-\t\n+\n+\t/**\n+\t * {@link Schema#id}\n+\t * \n+\t * @return the id\n+\t */\n+\tpublic String getId() {\n+\t\treturn id;\n+\t}\n+\n+\t/**\n+\t * {@link Schema#required}\n+\t * \n+\t * @return the required\n+\t */\n+\tpublic Boolean getRequired() {\n+\t\treturn required;\n+\t}\n+\n+\tpublic SchemaType getType() {\n+\t\treturn this.type;\n+\t}\n+\n+\tpublic boolean isAnySchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isArraySchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isBooleanSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isContainerTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isIntegerSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isNullSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isNumberSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isObjectSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isSimpleTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isStringSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isUnionTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\tpublic boolean isValueTypeSchema() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * {@link Schema#$ref}\n+\t * \n+\t * @param $ref\n+\t *            the $ref to set\n+\t */\n+\tpublic void set$ref(String $ref) {\n+\t\tthis.$ref = $ref;\n+\t}\n+\n+\t/**\n+\t * {@link Schema#$schema}\n+\t * \n+\t * @param $schema\n+\t *            the $schema to set\n+\t */\n+\tpublic void set$schema(String $schema) {\n+\t\tthis.$schema = $schema;\n+\t}\n+\n \t/**\n \t * {@link Schema#disallow}\n-\t * @param disallow the disallow to set\n+\t * \n+\t * @param disallow\n+\t *            the disallow to set\n \t */\n \tpublic void setDisallow(Schema[] disallow) {\n \t\tthis.disallow = disallow;\n \t}\n-\t/**\n-\t * {@link Schema#disallow}\n-\t * @return the disallow\n-\t */\n-\tpublic Schema[] getDisallow() {\n-\t\treturn disallow;\n-\t}\n-\n-\t//subtype oracles\n-\t\n-\tpublic boolean isUnionTypeSchema() { return false; }\n-\t\n-\tpublic boolean isSimpleTypeSchema() { return false; }\n-\n-\tpublic boolean isNullSchema() { return false; }\n-\tpublic boolean isAnySchema() { return false; }\n-\t\n-\tpublic boolean isContainerTypeSchema() { return false; }\n-\tpublic boolean isArraySchema() { return false; }\n-\tpublic boolean isObjectSchema() { return false; }\n-\t\n-\tpublic boolean isValueTypeSchema() { return false; }\n-\tpublic boolean isBooleanSchema() { return false; }\n-\tpublic boolean isIntegerSchema() { return false; }\n-\tpublic boolean isNumberSchema() { return false; }\n-\tpublic boolean isStringSchema() { return false; }\n-\t\n-\t// subtype retrievers:\n-\t\n-\tpublic UnionTypeSchema asUnionTypeSchema() { return null; }\n-\t\n-\tpublic SimpleTypeSchema asSimpleTypeSchema() { return null; }\n-\t\n-\tpublic NullSchema asNullSchema() { return null; }\n-\tpublic AnySchema asAnySchema() { return null; }\n-\t\n-\tpublic ContainerTypeSchema asContainerSchema() { return null; }\n-\tpublic ArraySchema asArraySchema() { return null; }\n-\tpublic ObjectSchema asObjectSchema() { return null; }\n-\t\n-\tpublic ValueTypeSchema asValueSchemaSchema() { return null; }\n-\tpublic BooleanSchema asBooleanSchema() { return null; }\n-\tpublic IntegerSchema asIntegerSchema() { return null; }\n-\tpublic NumberSchema asNumberSchema() { return null; }\n-\tpublic StringSchema asStringSchema() { return null; }\n-\t\n-\t\n+\n+\t/**\n+\t * {@link Schema#extendsextends}\n+\t * \n+\t * @param extendsextends\n+\t *            the extendsextends to set\n+\t */\n+\t@JsonSetter(\"extends\")\n+\tpublic void setExtends(Schema[] extendsextends) {\n+\t\tthis.extendsextends = extendsextends;\n+\t}\n+\n+\t/**\n+\t * {@link Schema#id}\n+\t * \n+\t * @param id\n+\t *            the id to set\n+\t */\n+\tpublic void setId(String id) {\n+\t\tthis.id = id;\n+\t}\n+\n+\t/**\n+\t * {@link Schema#required}\n+\t * \n+\t * @param required\n+\t *            the required to set\n+\t */\n+\tpublic void setRequired(Boolean required) {\n+\t\tthis.required = required;\n+\t}\n \n \tpublic static Schema minimalForFormat(SchemaType format) {\n \t\tswitch (format) {\n \t\tcase NUMBER:\n \t\t\treturn new NumberSchema();\n \t\tcase STRING:\n-\t\t\treturn new StringSchema();\t\t\t\n+\t\t\treturn new StringSchema();\n \t\tcase NULL:\n \t\t\treturn new NullSchema();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SimpleTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/SimpleTypeSchema.java\n import com.fasterxml.jackson.annotation.JsonSetter;\n \n public abstract class SimpleTypeSchema extends Schema {\n-\t\n \n \t/**\n \t * This attribute defines the default value of the instance when the\n-\t\tinstance is undefined.\n+\t * instance is undefined.\n \t */\n \t@JsonIgnore\n \tprivate String defaultdefault;\n \t/**\n-\t * {@link SimpleTypeSchema#defaultdefault}\n-\t * @param defaultdefault the defaultdefault to set\n+\t * This attribute is a string that provides a full description of the of\n+\t * purpose the instance property.\n \t */\n-\t@JsonSetter(\"default\")\n-\tpublic void setDefault(String defaultdefault) {\n-\t\tthis.defaultdefault = defaultdefault;\n+\t@JsonProperty\n+\tprivate String description;\n+\t/**\n+\t * This attribute is a string that provides a short description of the\n+\t * instance property.\n+\t */\n+\t@JsonProperty\n+\tprivate String title;\n+\n+\t@Override\n+\tpublic SimpleTypeSchema asSimpleTypeSchema() {\n+\t\treturn this;\n \t}\n+\n \t/**\n \t * {@link SimpleTypeSchema#defaultdefault}\n+\t * \n \t * @return the defaultdefault\n \t */\n \t@JsonGetter(\"default\")\n \tpublic String getDefault() {\n \t\treturn defaultdefault;\n \t}\n-\t\n+\n \t/**\n-\t * This attribute is a string that provides a short description of the\n-\t\tinstance property.\n+\t * {@link SimpleTypeSchema#description}\n+\t * \n+\t * @return the description\n \t */\n-\t@JsonProperty\n-\tprivate String title;\n+\tpublic String getDescription() {\n+\t\treturn description;\n+\t}\n+\n \t/**\n \t * {@link SimpleTypeSchema#title}\n-\t * @param title the title to set\n-\t */\n-\tpublic void setTitle(String title) {\n-\t\tthis.title = title;\n-\t}\n-\t/**\n-\t * {@link SimpleTypeSchema#title}\n+\t * \n \t * @return the title\n \t */\n \tpublic String getTitle() {\n \t\treturn title;\n \t}\n-\t\n+\n+\t@Override\n+\tpublic boolean isSimpleTypeSchema() {\n+\t\treturn true;\n+\t}\n+\n \t/**\n-\t * This attribute is a string that provides a full description of the of\n-\t\tpurpose the instance property.\n+\t * {@link SimpleTypeSchema#defaultdefault}\n+\t * \n+\t * @param defaultdefault\n+\t *            the defaultdefault to set\n \t */\n-\t@JsonProperty\n-\tprivate String description;\n+\t@JsonSetter(\"default\")\n+\tpublic void setDefault(String defaultdefault) {\n+\t\tthis.defaultdefault = defaultdefault;\n+\t}\n+\n \t/**\n \t * {@link SimpleTypeSchema#description}\n-\t * @param description the description to set\n+\t * \n+\t * @param description\n+\t *            the description to set\n \t */\n \tpublic void setDescription(String description) {\n \t\tthis.description = description;\n \t}\n+\n \t/**\n-\t * {@link SimpleTypeSchema#description}\n-\t * @return the description\n+\t * {@link SimpleTypeSchema#title}\n+\t * \n+\t * @param title\n+\t *            the title to set\n \t */\n-\tpublic String getDescription() {\n-\t\treturn description;\n+\tpublic void setTitle(String title) {\n+\t\tthis.title = title;\n \t}\n-\t\n-\t@Override\n-\tpublic boolean isSimpleTypeSchema() { return true; }\n-\t\n-\t@Override\n-\tpublic SimpleTypeSchema asSimpleTypeSchema() { return this; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/StringSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/StringSchema.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n public class StringSchema extends ValueTypeSchema {\n+\n+\t/** this defines the maximum length of the string. */\n+\t@JsonProperty\n+\tprivate Integer maxLength;\n+\n+\t/** this defines the minimum length of the string. */\n+\t@JsonProperty\n+\tprivate Integer minLength;\n+\t/**\n+\t * this provides a regular expression that a string instance MUST match in\n+\t * order to be valid. Regular expressions SHOULD follow the regular\n+\t * expression specification from ECMA 262/Perl 5\n+\t */\n+\t@JsonProperty\n+\tprivate String pattern;\n \t\n \t@JsonProperty(required = true)\n \tpublic final SchemaType type = SchemaType.STRING;\n-\t\n+\n+\t@Override\n+\tpublic StringSchema asStringSchema() {\n+\t\treturn this;\n+\t}\n+\n \t/**\n-\t * this provides a regular\n-\t   expression that a string instance MUST match in order to be valid.\n-\t   Regular expressions SHOULD follow the regular expression\n-\t   specification from ECMA 262/Perl 5\n+\t * {@link StringSchema#maxLength}\n+\t * \n+\t * @return the maxLength\n \t */\n-\t@JsonProperty\n-\tprivate String pattern;\n+\tpublic Integer getMaxLength() {\n+\t\treturn maxLength;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#minLength}\n+\t * \n+\t * @return the minLength\n+\t */\n+\tpublic Integer getMinLength() {\n+\t\treturn minLength;\n+\t}\n+\n \t/**\n \t * {@link StringSchema#pattern}\n-\t * @param pattern the pattern to set\n-\t */\n-\tpublic void setPattern(String pattern) {\n-\t\tthis.pattern = pattern;\n-\t}\n-\t/**\n-\t * {@link StringSchema#pattern}\n+\t * \n \t * @return the pattern\n \t */\n \tpublic String getPattern() {\n \t\treturn pattern;\n \t}\n-\t\n-\t/**this defines the minimum length of the string.*/\n-\t@JsonProperty\n-\tprivate Integer minLength;\n+\n+\t@Override\n+\tpublic boolean isStringSchema() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@link StringSchema#maxLength}\n+\t * \n+\t * @param maxLength\n+\t *            the maxLength to set\n+\t */\n+\tpublic void setMaxLength(Integer maxLength) {\n+\t\tthis.maxLength = maxLength;\n+\t}\n+\n \t/**\n \t * {@link StringSchema#minLength}\n-\t * @param minLength the minLength to set\n+\t * \n+\t * @param minLength\n+\t *            the minLength to set\n \t */\n \tpublic void setMinLength(Integer minLength) {\n \t\tthis.minLength = minLength;\n \t}\n+\n \t/**\n-\t * {@link StringSchema#minLength}\n-\t * @return the minLength\n+\t * {@link StringSchema#pattern}\n+\t * \n+\t * @param pattern\n+\t *            the pattern to set\n \t */\n-\tpublic Integer getMinLength() {\n-\t\treturn minLength;\n+\tpublic void setPattern(String pattern) {\n+\t\tthis.pattern = pattern;\n \t}\n-\t\n-\t/**this defines the maximum length of the string.*/\n-\t@JsonProperty\n-\tprivate Integer maxLength;\n-\t/**\n-\t * {@link StringSchema#maxLength}\n-\t * @param maxLength the maxLength to set\n-\t */\n-\tpublic void setMaxLength(Integer maxLength) {\n-\t\tthis.maxLength = maxLength;\n-\t}\n-\t/**\n-\t * {@link StringSchema#maxLength}\n-\t * @return the maxLength\n-\t */\n-\tpublic Integer getMaxLength() {\n-\t\treturn maxLength;\n-\t}\n-\t\n-\t@Override\n-\tpublic boolean isStringSchema() { return true; }\n-\t\n-\t@Override\n-\tpublic StringSchema asStringSchema() { return this; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/UnionTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/UnionTypeSchema.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n public class UnionTypeSchema extends Schema {\n-\t\n+\n \t@JsonProperty\n \tprivate ValueTypeSchema[] elements;\n+\n+\t@Override\n+\tpublic UnionTypeSchema asUnionTypeSchema() {\n+\t\treturn this;\n+\t}\n+\n \t/**\n \t * {@link UnionTypeSchema#elements}\n-\t * @param elements the elements to set\n-\t */\n-\tpublic void setElements(ValueTypeSchema[] elements) {\n-\t\tassert elements.length >= 2 : \"Union Type Schemas must contain two or more Simple Type Schemas\" ;\n-\t\tthis.elements = elements;\n-\t}\n-\t/**\n-\t * {@link UnionTypeSchema#elements}\n+\t * \n \t * @return the elements\n \t */\n \tpublic ValueTypeSchema[] getElements() {\n \t\treturn elements;\n \t}\n-\t\n+\n \t@Override\n-\tpublic UnionTypeSchema asUnionTypeSchema() { return this; }\n-\t\n-\t@Override\n-\tpublic boolean isUnionTypeSchema() { return true; }\n+\tpublic boolean isUnionTypeSchema() {\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * {@link UnionTypeSchema#elements}\n+\t * \n+\t * @param elements\n+\t *            the elements to set\n+\t */\n+\tpublic void setElements(ValueTypeSchema[] elements) {\n+\t\tassert elements.length >= 2 : \"Union Type Schemas must contain two or more Simple Type Schemas\";\n+\t\tthis.elements = elements;\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ValueTypeSchema.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/types/ValueTypeSchema.java\n package com.fasterxml.jackson.databind.jsonschema.types;\n \n+import java.util.HashSet;\n import java.util.Set;\n \n import com.fasterxml.jackson.annotation.JsonProperty;\n */\n public abstract class ValueTypeSchema extends SimpleTypeSchema {\n \t\t\t\n-\t/**\n-\t * This property defines the type of data, content type, or microformat\n-\t   to be expected in the instance property values.  A format attribute\n-\t   MAY be one of the values listed below, and if so, SHOULD adhere to\n-\t   the semantics describing for the format.  A format SHOULD only be\n-\t   used to give meaning to primitive types (string, integer, number, or\n-\t   boolean).  Validators MAY (but are not required to) validate that the\n-\t   instance values conform to a format.\n-\t   \n-\t    Additional custom formats MAY be created.  These custom formats MAY\n-\t   be expressed as an URI, and this URI MAY reference a schema of that\n-\t */\n-\t@JsonProperty\n-\tprivate JsonValueFormat format;\n-\t/**\n-\t * {@link ValueTypeSchema#format}\n-\t * @param format the format to set\n-\t */\n-\tpublic void setFormat(JsonValueFormat format) {\n-\t\tthis.format = format;\n-\t}\n-\t/**\n-\t * {@link ValueTypeSchema#format}\n-\t * @return the format\n-\t */\n-\tpublic JsonValueFormat getFormat() {\n-\t\treturn format;\n-\t}\n-\n-\t\n \t/**\n \t * This provides an enumeration of all possible values that are valid\n \t   for the instance property.  This MUST be an array, and each item in\n \t */\n \t@JsonProperty\n \tprivate Set<String> enums;\n+\t\n+\t/**\n+\t * This property defines the type of data, content type, or microformat to\n+\t * be expected in the instance property values. A format attribute MAY be\n+\t * one of the values listed below, and if so, SHOULD adhere to the semantics\n+\t * describing for the format. A format SHOULD only be used to give meaning\n+\t * to primitive types (string, integer, number, or boolean). Validators MAY\n+\t * (but are not required to) validate that the instance values conform to a\n+\t * format.\n+\t * \n+\t * Additional custom formats MAY be created. These custom formats MAY be\n+\t * expressed as an URI, and this URI MAY reference a schema of that\n+\t */\n+\t@JsonProperty\n+\tprivate JsonValueFormat format;\n+\t\n+\t//instance initializer block\n+\t{\n+\t\tenums = new HashSet<String>();\n+\t}\n+\t\n+\t@Override\n+\tpublic ValueTypeSchema asValueSchemaSchema() { return this; }\n+\n+\t\n+\t/**\n+\t * {@link ValueTypeSchema#enums}\n+\t * @return the enums\n+\t */\n+\tpublic Set<String> getEnums() {\n+\t\treturn enums;\n+\t}\n+\t/**\n+\t * {@link ValueTypeSchema#format}\n+\t * @return the format\n+\t */\n+\tpublic JsonValueFormat getFormat() {\n+\t\treturn format;\n+\t}\n+\t@Override\n+\tpublic boolean isValueTypeSchema() { return true; }\n+\t\n \t/**\n \t * {@link ValueTypeSchema#enums}\n \t * @param enums the enums to set\n \tpublic void setEnums(Set<String> enums) {\n \t\tthis.enums = enums;\n \t}\n+\t\n \t/**\n-\t * {@link ValueTypeSchema#enums}\n-\t * @return the enums\n+\t * {@link ValueTypeSchema#format}\n+\t * @param format the format to set\n \t */\n-\tpublic Set<String> getEnums() {\n-\t\treturn enums;\n+\tpublic void setFormat(JsonValueFormat format) {\n+\t\tthis.format = format;\n \t}\n-\t\n-\t@Override\n-\tpublic boolean isValueTypeSchema() { return true; }\n-\t\n-\t@Override\n-\tpublic ValueTypeSchema asValueSchemaSchema() { return this; }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.jsonschema.types.Schema;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n     public void testGeneratingJsonSchema()\n         throws Exception\n     {\n-        Schema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+    \tDefaultSerializerProvider sp = new DefaultSerializerProvider.Impl();\n+        ObjectMapper m = new ObjectMapper();\n+        m.setSerializerProvider(sp);\n+        Schema jsonSchema = m.generateJsonSchema(SimpleBean.class);\n         \n         assertNotNull(jsonSchema);\n ", "timestamp": 1343760453, "metainfo": ""}