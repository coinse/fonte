{"sha": "f52059d06c0b0c06b2a40633fbdcb01d624ca2c9", "log": "Complete handling of non-conflicts with implicit names", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n     @Override\n     public AnnotatedMethod getGetter()\n     {\n+        // Easy with zero or one getters...\n         Linked<AnnotatedMethod> curr = _getters;\n-        // If zero easy\n         if (curr == null) {\n             return null;\n         }\n         Linked<AnnotatedMethod> next = curr.next;\n-        // ditto, if one\n         if (next == null) {\n             return curr.value;\n         }\n-\n         // But if multiple, verify that they do not conflict...\n         for (; next != null; next = next.next) {\n-            \n             /* [JACKSON-255] Allow masking, i.e. do not report exception if one\n              *   is in super-class from the other\n              */\n-            Class<?> getterClass = curr.value.getDeclaringClass();\n+            Class<?> currClass = curr.value.getDeclaringClass();\n             Class<?> nextClass = next.value.getDeclaringClass();\n-            if (getterClass != nextClass) {\n-                if (getterClass.isAssignableFrom(nextClass)) { // next is more specific\n+            if (currClass != nextClass) {\n+                if (currClass.isAssignableFrom(nextClass)) { // next is more specific\n                     curr = next;\n                     continue;\n                 }\n-                if (nextClass.isAssignableFrom(getterClass)) { // current more specific\n+                if (nextClass.isAssignableFrom(currClass)) { // current more specific\n                     continue;\n                 }\n             }\n             throw new IllegalArgumentException(\"Conflicting getter definitions for property \\\"\"+getName()+\"\\\": \"\n                     +curr.value.getFullName()+\" vs \"+next.value.getFullName());\n         }\n-\n         // One more thing; to avoid having to do it again...\n         _getters = curr.withoutNext();\n         return curr.value;\n     }\n-\n-    protected int _getterPriority(AnnotatedMethod m)\n-    {\n-        final String name = m.getName();\n-        // [#238]: Also, regular getters have precedence over \"is-getters\"\n-        if (name.startsWith(\"get\") && name.length() > 3) {\n-            // should we check capitalization?\n-            return 1;\n-        }\n-        if (name.startsWith(\"is\") && name.length() > 2) {\n-            return 2;\n-        }\n-        return 3;\n-    }\n     \n     @Override\n     public AnnotatedMethod getSetter()\n     {\n-        if (_setters == null) {\n+        // Easy with zero or one getters...\n+        Linked<AnnotatedMethod> curr = _setters;\n+        if (curr == null) {\n             return null;\n         }\n-        // If multiple, verify that they do not conflict...\n-        AnnotatedMethod setter = _setters.value;\n-        Linked<AnnotatedMethod> next = _setters.next;\n+        Linked<AnnotatedMethod> next = curr.next;\n+        if (next == null) {\n+            return curr.value;\n+        }\n+        // But if multiple, verify that they do not conflict...\n         for (; next != null; next = next.next) {\n-            /* [JACKSON-255] Allow masking, i.e. report exception only if\n-             *   declarations in same class, or there's no inheritance relationship\n-             *   (sibling interfaces etc)\n+            /* [JACKSON-255] Allow masking, i.e. do not report exception if one\n+             *   is in super-class from the other\n              */\n-            AnnotatedMethod nextSetter = next.value;\n-            Class<?> setterClass = setter.getDeclaringClass();\n-            Class<?> nextClass = nextSetter.getDeclaringClass();\n-            if (setterClass != nextClass) {\n-                if (setterClass.isAssignableFrom(nextClass)) { // next is more specific\n-                    setter = nextSetter;\n+            Class<?> currClass = curr.value.getDeclaringClass();\n+            Class<?> nextClass = next.value.getDeclaringClass();\n+            if (currClass != nextClass) {\n+                if (currClass.isAssignableFrom(nextClass)) { // next is more specific\n+                    curr = next;\n                     continue;\n                 }\n-                if (nextClass.isAssignableFrom(setterClass)) { // getter more specific\n+                if (nextClass.isAssignableFrom(currClass)) { // current more specific\n                     continue;\n                 }\n             }\n+            /* 30-May-2014, tatu: Two levels of precedence:\n+             * \n+             * 1. Regular setters (\"setX(...)\")\n+             * 2. Implicit, possible setters (\"x(...)\")\n+             */\n+            int priNext = _setterPriority(next.value);\n+            int priCurr = _setterPriority(curr.value);\n+\n+            if (priNext != priCurr) {\n+                if (priNext < priCurr) {\n+                    curr = next;\n+                }\n+                continue;\n+            }\n             throw new IllegalArgumentException(\"Conflicting setter definitions for property \\\"\"+getName()+\"\\\": \"\n-                    +setter.getFullName()+\" vs \"+nextSetter.getFullName());\n-        }\n-        return setter;\n+                    +curr.value.getFullName()+\" vs \"+next.value.getFullName());\n+        }\n+        // One more thing; to avoid having to do it again...\n+        _setters = curr.withoutNext();\n+        return curr.value;\n     }\n \n     @Override\n         return getMutator();\n     }\n \n+    protected int _getterPriority(AnnotatedMethod m)\n+    {\n+        final String name = m.getName();\n+        // [#238]: Also, regular getters have precedence over \"is-getters\"\n+        if (name.startsWith(\"get\") && name.length() > 3) {\n+            // should we check capitalization?\n+            return 1;\n+        }\n+        if (name.startsWith(\"is\") && name.length() > 2) {\n+            return 2;\n+        }\n+        return 3;\n+    }\n+\n+    protected int _setterPriority(AnnotatedMethod m)\n+    {\n+        final String name = m.getName();\n+        if (name.startsWith(\"set\") && name.length() > 3) {\n+            // should we check capitalization?\n+            return 1;\n+        }\n+        return 2;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Implementations of refinement accessors\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.setAnnotationIntrospector(new InferingIntrospector());\n-        Infernal inf = mapper.readValue(aposToQuotes(\"{'name':'Bob'}\"), Infernal.class);\n+        Infernal inf = mapper.readValue(aposToQuotes(\"{'stuff':'Bob'}\"), Infernal.class);\n         assertNotNull(inf);\n     }\n }", "timestamp": 1401516478, "metainfo": ""}