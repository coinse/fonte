{"sha": "201c8ffd7931aa552fe42f077e23917695faf29a", "log": "Add test for [Issue-14]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * passes an immutable instance to be used for deserialization process.\n  *<p>\n  * Note that instances are considered immutable and as such no copies\n- * should need to be created (there are some implementation details\n- * with respect to mix-in annotations; where this is guaranteed as\n- * long as caller follow \"copy-then-use\" pattern)\n+ * should need to be created for sharing; all copying is done with\n+ * \"fluent factory\" methods.\n+ * Note also that unlike with Jackson 1, these instances can not be\n+ * assigned to {@link ObjectMapper}; in fact, application code should\n+ * rarely interact directly with these instance (unlike core Jackson code)\n  */\n public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n  * (either directly, or through {@link ObjectWriter}.\n  *<p>\n  * Note that instances are considered immutable and as such no copies\n- * should need to be created (there are some implementation details\n- * with respect to mix-in annotations; where this is guaranteed as\n- * long as caller follow \"copy-then-use\" pattern)\n+ * should need to be created for sharing; all copying is done with\n+ * \"fluent factory\" methods.\n+ * Note also that unlike with Jackson 1, these instances can not be\n+ * assigned to {@link ObjectMapper}; in fact, application code should\n+ * rarely interact directly with these instance (unlike core Jackson code)\n  */\n public final class SerializationConfig\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n \n         // and then augment these with annotations from super-types:\n         for (Class<?> cls : _superTypes) {\n-            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);\n+            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n             _addMemberMethods(cls, _memberMethods, mixin, mixins);\n         }\n         // Special case: mix-ins for Object.class? (to apply to ALL classes)\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n      * Code is needed to work around design flaw in JDK.\n      */\n     public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s)\n-\t{\n+    {\n     \t// First things first: if not empty, easy to determine\n     \tif (!s.isEmpty()) {\n     \t\treturn findEnumType(s.iterator().next());\n     @SuppressWarnings(\"unchecked\")\n \tpublic static Class<? extends Enum<?>> findEnumType(Enum<?> en)\n     {\n-\t\t// enums with \"body\" are sub-classes of the formal type\n+        // enums with \"body\" are sub-classes of the formal type\n     \tClass<?> ec = en.getClass();\n-\t\tif (ec.getSuperclass() != Enum.class) {\n-\t\t\tec = ec.getSuperclass();\n-\t\t}\n-\t\treturn (Class<? extends Enum<?>>) ec;\n+    \tif (ec.getSuperclass() != Enum.class) {\n+    \t    ec = ec.getSuperclass();\n+    \t}\n+    \treturn (Class<? extends Enum<?>>) ec;\n     }\n \n     /**\n     @SuppressWarnings(\"unchecked\")\n     public static Class<? extends Enum<?>> findEnumType(Class<?> cls)\n     {\n-\t\t// enums with \"body\" are sub-classes of the formal type\n-\t\tif (cls.getSuperclass() != Enum.class) {\n-\t\t\tcls = cls.getSuperclass();\n-\t\t}\n-\t\treturn (Class<? extends Enum<?>>) cls;\n+        // enums with \"body\" are sub-classes of the formal type\n+        if (cls.getSuperclass() != Enum.class) {\n+            cls = cls.getSuperclass();\n+        }\n+        return (Class<? extends Enum<?>>) cls;\n     }\n \n     /*\n     \tprivate final Field enumMapTypeField;\n     \t\n     \tprivate EnumTypeLocator() {\n-\t\t\t/* JDK uses following fields to store information about actual Enumeration\n-\t\t\t * type for EnumSets, EnumMaps...\n-\t\t\t */\n-\t\t\tenumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n-\t\t\tenumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n+    \t    /* JDK uses following fields to store information about actual Enumeration\n+    \t     * type for EnumSets, EnumMaps...\n+    \t     */\n+    \t    enumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n+    \t    enumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n     \t}\n \n     \t@SuppressWarnings(\"unchecked\")\n     \tpublic Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set)\n     \t{\n-    \t\tif (enumSetTypeField != null) {\n-    \t\t\treturn (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n-    \t\t}\n-    \t\tthrow new IllegalStateException(\"Can not figure out type for EnumSet (odd JDK platform?)\");\n-\t\t}\n+    \t    if (enumSetTypeField != null) {\n+    \t        return (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n+    \t    }\n+    \t    throw new IllegalStateException(\"Can not figure out type for EnumSet (odd JDK platform?)\");\n+    \t}\n \n     \t@SuppressWarnings(\"unchecked\")\n     \tpublic Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set)\n-\t\t        {\n-    \t\tif (enumMapTypeField != null) {\n-    \t\t\treturn (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n-    \t\t}\n-    \t\tthrow new IllegalStateException(\"Can not figure out type for EnumMap (odd JDK platform?)\");\n-\t\t        \n+        {\n+    \t    if (enumMapTypeField != null) {\n+    \t        return (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n+    \t    }\n+    \t    throw new IllegalStateException(\"Can not figure out type for EnumMap (odd JDK platform?)\");\n         }\n     \t\n     \tprivate Object get(Object bean, Field field)\n     \t{\n-    \t\ttry {\n-    \t\t\treturn field.get(bean);\n-    \t\t} catch (Exception e) {\n-    \t\t\tthrow new IllegalArgumentException(e);\n-    \t\t}\n+    \t    try {\n+    \t        return field.get(bean);\n+    \t    } catch (Exception e) {\n+    \t        throw new IllegalArgumentException(e);\n+    \t    }\n     \t}\n     \t\n     \tprivate static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)\n     \t{\n-    \t\tField found = null;\n-    \t\t// First: let's see if we can find exact match:\n-    \t\tField[] fields = fromClass.getDeclaredFields();\n-    \t\tfor (Field f : fields) {\n-    \t\t\tif (expectedName.equals(f.getName()) && f.getType() == type) {\n-    \t\t\t\tfound = f;\n-    \t\t\t\tbreak;\n-    \t\t\t}\n-    \t\t}\n-    \t\t// And if not, if there is just one field with the type, that field\n-    \t\tif (found == null) {\n-\t    \t\tfor (Field f : fields) {\n-\t    \t\t\tif (f.getType() == type) {\n-\t    \t\t\t\t// If more than one, can't choose\n-\t    \t\t\t\tif (found != null) return null;\n-\t    \t\t\t\tfound = f;\n-\t    \t\t\t}\n-\t    \t\t}\n-    \t\t}\n-    \t\tif (found != null) { // it's non-public, need to force accessible\n-    \t\t\ttry {\n-    \t\t\t\tfound.setAccessible(true);\n-    \t\t\t} catch (Throwable t) { }\n-    \t\t}\n-    \t\treturn found;\n+    \t    Field found = null;\n+    \t    // First: let's see if we can find exact match:\n+    \t    Field[] fields = fromClass.getDeclaredFields();\n+    \t    for (Field f : fields) {\n+    \t        if (expectedName.equals(f.getName()) && f.getType() == type) {\n+    \t            found = f;\n+    \t            break;\n+    \t        }\n+    \t    }\n+    \t    // And if not, if there is just one field with the type, that field\n+    \t    if (found == null) {\n+    \t        for (Field f : fields) {\n+    \t            if (f.getType() == type) {\n+    \t                // If more than one, can't choose\n+    \t                if (found != null) return null;\n+    \t                found = f;\n+    \t            }\n+    \t        }\n+    \t    }\n+    \t    if (found != null) { // it's non-public, need to force accessible\n+    \t        try {\n+    \t            found.setAccessible(true);\n+    \t        } catch (Throwable t) { }\n+    \t    }\n+    \t    return found;\n     \t}\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n         // also: add a dummy field that is NOT to match anything\n         @JsonProperty public String xyz;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Unit tests", "timestamp": 1335581763, "metainfo": ""}