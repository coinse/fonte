{"sha": "84a892017bebafe92a21d4394ab9070907dbec26", "log": "ObjectNode: make _children final  Simplifies quite a lot of code in the process.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n public class ObjectNode\n     extends ContainerNode<ObjectNode>\n {\n-    // note: until 2.1, was explicitly `LinkedHashMap`\n-    protected Map<String, JsonNode> _children = null;\n+    // Note: LinkedHashMap for backwards compatibility\n+    protected final Map<String, JsonNode> _children\n+        = new LinkedHashMap<String, JsonNode>();\n \n     public ObjectNode(JsonNodeFactory nc) { super(nc); }\n \n     protected ObjectNode(JsonNodeFactory nc, Map<String, JsonNode> children) {\n         super(nc);\n-        _children = children;\n+        _children.putAll(children);\n     }\n     \n     /* Question: should this delegate to `JsonNodeFactory`? It does not absolutely\n      */\n     protected ObjectNode _defaultDeepCopy()\n     {\n-        if (_children == null) {\n-            return new ObjectNode(_nodeFactory);\n-        }\n         final int len = _children.size();\n-        Map<String, JsonNode> newKids = _createMap(Math.max(4, len));\n+        Map<String, JsonNode> newKids\n+            = new LinkedHashMap<String, JsonNode>(Math.max(4, len));\n         for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n             newKids.put(entry.getKey(), entry.getValue().deepCopy());\n         }\n \n     @Override\n     public int size() {\n-        return (_children == null) ? 0 : _children.size();\n+        return _children.size();\n     }\n \n     @Override\n     public Iterator<JsonNode> elements()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.values().iterator();\n     }\n \n     @Override\n     public JsonNode get(String fieldName)\n     {\n-        if (_children != null) {\n-            return _children.get(fieldName);\n-        }\n-        return null;\n+        return _children.get(fieldName);\n     }\n \n     @Override\n     public Iterator<String> fieldNames()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.keySet().iterator();\n     }\n \n     @Override\n     public JsonNode path(String fieldName)\n     {\n-        if (_children != null) {\n-            JsonNode n = _children.get(fieldName);\n-            if (n != null) {\n-                return n;\n-            }\n+        JsonNode n = _children.get(fieldName);\n+        if (n != null) {\n+            return n;\n         }\n         return MissingNode.getInstance();\n     }\n     @Override\n     public Iterator<Map.Entry<String, JsonNode>> fields()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.entrySet().iterator();\n     }\n \n     @Override\n     public ObjectNode with(String propertyName)\n     {\n-        if (_children == null) {\n-            _children = _createMap();\n-        } else {\n-            JsonNode n = _children.get(propertyName);\n-            if (n != null) {\n-                if (n instanceof ObjectNode) {\n-                    return (ObjectNode) n;\n-                }\n-                throw new UnsupportedOperationException(\"Property '\"+propertyName\n-                        +\"' has value that is not of type ObjectNode (but \"\n-                        +n.getClass().getName()+\")\");\n-            }\n+        JsonNode n = _children.get(propertyName);\n+        if (n != null) {\n+            if (n instanceof ObjectNode) {\n+                return (ObjectNode) n;\n+            }\n+            throw new UnsupportedOperationException(\"Property '\" + propertyName\n+                + \"' has value that is not of type ObjectNode (but \" + n\n+                .getClass().getName() + \")\");\n         }\n         ObjectNode result = objectNode();\n         _children.put(propertyName, result);\n     @Override\n     public ArrayNode withArray(String propertyName)\n     {\n-        if (_children == null) {\n-            _children = _createMap();\n-        } else {\n-            JsonNode n = _children.get(propertyName);\n-            if (n != null) {\n-                if (n instanceof ArrayNode) {\n-                    return (ArrayNode) n;\n-                }\n-                throw new UnsupportedOperationException(\"Property '\"+propertyName\n-                        +\"' has value that is not of type ArrayNode (but \"\n-                        +n.getClass().getName()+\")\");\n-            }\n+        JsonNode n = _children.get(propertyName);\n+        if (n != null) {\n+            if (n instanceof ArrayNode) {\n+                return (ArrayNode) n;\n+            }\n+            throw new UnsupportedOperationException(\"Property '\" + propertyName\n+                + \"' has value that is not of type ArrayNode (but \" + n\n+                .getClass().getName() + \")\");\n         }\n         ArrayNode result = arrayNode();\n         _children.put(propertyName, result);\n     @Override\n     public JsonNode findValue(String fieldName)\n     {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    return entry.getValue();\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                return entry.getValue();\n+            }\n+            JsonNode value = entry.getValue().findValue(fieldName);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                if (foundSoFar == null) {\n+                    foundSoFar = new ArrayList<JsonNode>();\n                 }\n-                JsonNode value = entry.getValue().findValue(fieldName);\n-                if (value != null) {\n-                    return value;\n+                foundSoFar.add(entry.getValue());\n+            } else { // only add children if parent not added\n+                foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                if (foundSoFar == null) {\n+                    foundSoFar = new ArrayList<String>();\n                 }\n+                foundSoFar.add(entry.getValue().asText());\n+            } else { // only add children if parent not added\n+                foundSoFar = entry.getValue().findValuesAsText(fieldName,\n+                    foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                return this;\n+            }\n+            JsonNode value = entry.getValue().findParent(fieldName);\n+            if (value != null) {\n+                return (ObjectNode) value;\n             }\n         }\n         return null;\n     }\n-    \n-    @Override\n-    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    if (foundSoFar == null) {\n-                        foundSoFar = new ArrayList<JsonNode>();\n-                    }\n-                    foundSoFar.add(entry.getValue());\n-                } else { // only add children if parent not added\n-                    foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n+\n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                if (foundSoFar == null) {\n+                    foundSoFar = new ArrayList<JsonNode>();\n                 }\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-\n-    @Override\n-    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    if (foundSoFar == null) {\n-                        foundSoFar = new ArrayList<String>();\n-                    }\n-                    foundSoFar.add(entry.getValue().asText());\n-                } else { // only add children if parent not added\n-                    foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar);\n-                }\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-    \n-    @Override\n-    public ObjectNode findParent(String fieldName)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    return this;\n-                }\n-                JsonNode value = entry.getValue().findParent(fieldName);\n-                if (value != null) {\n-                    return (ObjectNode) value;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    if (foundSoFar == null) {\n-                        foundSoFar = new ArrayList<JsonNode>();\n-                    }\n-                    foundSoFar.add(this);\n-                } else { // only add children if parent not added\n-                    foundSoFar = entry.getValue().findParents(fieldName, foundSoFar);\n-                }\n+                foundSoFar.add(this);\n+            } else { // only add children if parent not added\n+                foundSoFar = entry.getValue()\n+                    .findParents(fieldName, foundSoFar);\n             }\n         }\n         return foundSoFar;\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartObject();\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                jg.writeFieldName(en.getKey());\n+        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+            jg.writeFieldName(en.getKey());\n                 /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n                  *   extend BaseJsonNode? Or if not, at least implement\n                  *   JsonSerializable? Let's start with former, change if\n                  *   we must.\n                  */\n-                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n-            }\n+            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n         }\n         jg.writeEndObject();\n     }\n         throws IOException, JsonProcessingException\n     {\n         typeSer.writeTypePrefixForObject(this, jg);\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                jg.writeFieldName(en.getKey());\n-                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n-            }\n+        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+            jg.writeFieldName(en.getKey());\n+            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n         }\n         typeSer.writeTypeSuffixForObject(this, jg);\n     }\n         if (value == null) {\n             value = nullNode();\n         }\n-        _put(fieldName, value);\n+        _children.put(fieldName, value);\n         return this;\n     }\n \n      */\n     public JsonNode setAll(Map<String,JsonNode> properties)\n     {\n-        if (_children == null) {\n-            _children = _createMap();\n-        }\n         for (Map.Entry<String, JsonNode> en : properties.entrySet()) {\n             JsonNode n = en.getValue();\n             if (n == null) {\n     {\n         int len = other.size();\n         if (len > 0) {\n-            if (_children == null) {\n-                _children = _createMap(len);\n-            }\n             other.putContentsTo(_children);\n         }\n         return this;\n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        return _put(fieldName, value);\n+        return _children.put(fieldName, value);\n     }\n \n     /**\n      */\n     public JsonNode without(String fieldName)\n     {\n-        if (_children != null) {\n-            _children.remove(fieldName);\n-        }\n+        _children.remove(fieldName);\n         return this;\n     }\n \n      */\n     public ObjectNode without(Collection<String> fieldNames)\n     {\n-        if (_children != null) {\n-            for (String fieldName : fieldNames) {\n-                _children.remove(fieldName);\n-            }\n-        }\n+        _children.keySet().removeAll(fieldNames);\n         return this;\n     }\n     \n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        return _put(fieldName, value);\n+        return _children.put(fieldName, value);\n     }\n     \n     /**\n      */\n     public JsonNode remove(String fieldName)\n     {\n-        if (_children != null) {\n-            return _children.remove(fieldName);\n-        }\n-        return null;\n+        return _children.remove(fieldName);\n     }\n \n     /**\n      */\n     public ObjectNode remove(Collection<String> fieldNames)\n     {\n-        if (_children != null) {\n-            for (String fieldName : fieldNames) {\n-                _children.remove(fieldName);\n-            }\n-        }\n+        _children.keySet().removeAll(fieldNames);\n         return this;\n     }\n     \n     @Override\n     public ObjectNode removeAll()\n     {\n-        _children = null;\n+        _children.clear();\n         return this;\n     }\n \n      */\n     public ObjectNode retain(Collection<String> fieldNames)\n     {\n-        if (_children != null) {\n-            Iterator<Map.Entry<String,JsonNode>> entries = _children.entrySet().iterator();\n-            while (entries.hasNext()) {\n-                Map.Entry<String, JsonNode> entry = entries.next();\n-                if (!fieldNames.contains(entry.getKey())) {\n-                    entries.remove();\n-                }\n-            }\n-        }\n+        _children.keySet().retainAll(fieldNames);\n         return this;\n     }\n \n     public ArrayNode putArray(String fieldName)\n     {\n         ArrayNode n  = arrayNode();\n-        _put(fieldName, n);\n+        _children.put(fieldName, n);\n         return n;\n     }\n \n     public ObjectNode putObject(String fieldName)\n     {\n         ObjectNode n  = objectNode();\n-        _put(fieldName, n);\n+        _children.put(fieldName, n);\n         return n;\n     }\n \n      * @return This node (to allow chaining)\n      */\n     public ObjectNode putPOJO(String fieldName, Object pojo) {\n-        _put(fieldName, POJONode(pojo));\n+        _children.put(fieldName, POJONode(pojo));\n         return this;\n     }\n \n      */\n     public ObjectNode putNull(String fieldName)\n     {\n-        _put(fieldName, nullNode());\n+        _children.put(fieldName, nullNode());\n         return this;\n     }\n \n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, int v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Integer value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.intValue()));\n+            _children.put(fieldName, numberNode(value.intValue()));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, long v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Long value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.longValue()));\n+            _children.put(fieldName, numberNode(value.longValue()));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, float v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Float value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.floatValue()));\n+            _children.put(fieldName, numberNode(value.floatValue()));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, double v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Double value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.doubleValue()));\n+            _children.put(fieldName, numberNode(value.doubleValue()));\n         }\n         return this;\n     }\n         if (v == null) {\n             putNull(fieldName);\n         } else {\n-            _put(fieldName, numberNode(v));\n+            _children.put(fieldName, numberNode(v));\n         }\n         return this;\n     }\n         if (v == null) {\n             putNull(fieldName);\n         } else {\n-            _put(fieldName, textNode(v));\n+            _children.put(fieldName, textNode(v));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, boolean v) {\n-        _put(fieldName, booleanNode(v));\n+        _children.put(fieldName, booleanNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Boolean value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, booleanNode(value.booleanValue()));\n+            _children.put(fieldName, booleanNode(value.booleanValue()));\n         }\n         return this;\n     }\n      */\n     public ObjectNode put(String fieldName, byte[] v) {\n         if (v == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, binaryNode(v));\n+            _children.put(fieldName, binaryNode(v));\n         }\n         return this;\n     }\n     /**********************************************************\n      */\n \n-    /**\n-     * Internal factory method for creating {@link Map} used for storing\n-     * child nodes. \n-     * Overridable by sub-classes, used when caller does not know what\n-     * optimal size would, used for example when constructing a Map when adding\n-     * the first one.\n-     * \n-     * @since 2.1\n-     */\n-    protected Map<String, JsonNode> _createMap() {\n-        return new LinkedHashMap<String, JsonNode>();\n-    }\n-    \n-    /**\n-     * Internal factory method for creating {@link Map} used for storing\n-     * child nodes. \n-     * Overridable by sub-classes, used when caller has an idea of what\n-     * optimal size should be: used when copying contents of an existing node.\n-     * \n-     * @since 2.1\n-     */\n-    protected Map<String, JsonNode> _createMap(int defaultSize) {\n-        return new LinkedHashMap<String, JsonNode>(defaultSize);\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Package methods (for other node classes to use)\n      */\n     protected boolean _equals(ObjectNode other)\n     {\n-        return _stdEquals(other)\n-                &&_customEquals(other)\n-                && other._customEquals(this)\n-                ;\n-    }\n-    \n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     *\n-     * @since 2.1\n-     */\n-    protected boolean _customEquals(ObjectNode other) {\n-        return true;\n-    }\n-\n-    /**\n-     * Standard equality checks, which may also be overridden by\n-     * sub-classes if necessary (but usually isn't).\n-     *\n-     * @since 2.1\n-     */\n-    protected final boolean _stdEquals(ObjectNode other)\n-    {\n-        if (other.size() != size()) {\n-            return false;\n-        }\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                String key = en.getKey();\n-                JsonNode value = en.getValue();\n-\n-                JsonNode otherValue = other.get(key);\n-\n-                if (otherValue == null || !otherValue.equals(value)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n+        return _children.equals(other._children);\n+    }\n+    \n     @Override\n     public int hashCode()\n     {\n-        return (_children == null) ? -1 : _children.hashCode();\n+        return _children.hashCode();\n     }\n \n     @Override\n     {\n         StringBuilder sb = new StringBuilder(32 + (size() << 4));\n         sb.append(\"{\");\n-        if (_children != null) {\n-            int count = 0;\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                if (count > 0) {\n-                    sb.append(\",\");\n-                }\n-                ++count;\n-                TextNode.appendQuoted(sb, en.getKey());\n-                sb.append(':');\n-                sb.append(en.getValue().toString());\n-            }\n+        int count = 0;\n+        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+            if (count > 0) {\n+                sb.append(\",\");\n+            }\n+            ++count;\n+            TextNode.appendQuoted(sb, en.getKey());\n+            sb.append(':');\n+            sb.append(en.getValue().toString());\n         }\n         sb.append(\"}\");\n         return sb.toString();\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Internal methods\n-    /**********************************************************\n-     */\n-\n-    private final JsonNode _put(String fieldName, JsonNode value)\n-    {\n-        if (_children == null) {\n-            _children = _createMap();\n-        }\n-        return _children.put(fieldName, value);\n-    }\n }", "timestamp": 1358994237, "metainfo": ""}