{"sha": "36634634fcce49cdb6b139fa8a72471a0033e8f5", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ArrayBlockingQueueDeserializer.java\n import java.util.concurrent.ArrayBlockingQueue;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n public class ArrayBlockingQueueDeserializer\n     extends CollectionDeserializer\n {\n-    private static final long serialVersionUID = 5471961369237518580L;\n+    private static final long serialVersionUID = 1;\n \n     /*\n     /**********************************************************\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n     }\n \n     @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Collection<Object> result0)\n-        throws IOException, JsonProcessingException\n+    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt, Collection<Object> result0) throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n         if (!jp.isExpectedStartArrayToken()) {\n     }\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicBooleanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicBooleanDeserializer.java\n import java.util.concurrent.atomic.AtomicBoolean;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationContext;\n \n-public class AtomicBooleanDeserializer\n-    extends StdScalarDeserializer<AtomicBoolean>\n+public class AtomicBooleanDeserializer extends StdScalarDeserializer<AtomicBoolean>\n {\n     private static final long serialVersionUID = 1L;\n \n     public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n     \n     @Override\n-    public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         // 16-Dec-2010, tatu: Should we actually convert null to null AtomicBoolean?\n         return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt));\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n     }\n \n     @Override\n-    public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         /* 06-Nov-2013, tatu: Looks like the only way to make polymorphic deser to work\n          *   correctly is to add support here; problem being that handler is not available\n          *   for nominal type of AtomicReference but only \"contained\" type...\n \n     @Override\n     public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n-    {\n+            TypeDeserializer typeDeserializer) throws IOException {\n         return (Object[]) typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n /**\n  * Simple container class for types with optional logical name, used\n  * as external identifier\n- * \n- * @author tatu\n  */\n-public final class NamedType\n-    implements java.io.Serializable\n+public final class NamedType implements java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n     \n     public NamedType(Class<?> c) { this(c, null); }\n     \n-    public NamedType(Class<?> c, String name)\n-    {\n+    public NamedType(Class<?> c, String name) {\n         _class = c;\n         _hashCode = c.getName().hashCode();\n         setName(name);\n \n     public Class<?> getType() { return _class; }\n     public String getName() { return _name; }\n-    public void setName(String name) {\n-        _name = (name == null || name.length() == 0) ? null : name;\n-    }\n+    public void setName(String name) { _name = (name == null || name.length() == 0) ? null : name; }\n \n     public boolean hasName() { return _name != null; }\n     \n      * Equality is defined based on class only, not on name\n      */\n     @Override\n-    public boolean equals(Object o)\n-    {\n+    public boolean equals(Object o) {\n         if (o == this) return true;\n         if (o == null) return false;\n         if (o.getClass() != getClass()) return false;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromObject(JsonParser jp,\n-            DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt) throws IOException;\n \n     /**\n      * Method called to let this type deserializer handle \n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromArray(JsonParser jp,\n-            DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException;\n \n     /**\n      * Method called to let this type deserializer handle \n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromScalar(JsonParser jp,\n-            DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt) throws IOException;\n \n     /**\n      * Method called to let this type deserializer handle \n      * using JSON node representation, or \"untyped\" Java object\n      * (which may be Map, Collection, wrapper/primitive etc).\n      */\n-    public abstract Object deserializeTypedFromAny(JsonParser jp,\n-            DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt) throws IOException;\n \n     /*\n     /**********************************************************\n      * a \"natural\" value, and one that would be acceptable as the\n      * result value (compatible with declared base type)\n      */\n-    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n-            JavaType baseType)\n-        throws IOException, JsonProcessingException\n-    {\n+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, JavaType baseType) throws IOException {\n         return deserializeIfNatural(jp, ctxt, baseType.getRawClass());\n     }\n     \n     @SuppressWarnings(\"incomplete-switch\")\n-    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n-            Class<?> base)\n-        throws IOException, JsonProcessingException\n+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt, Class<?> base) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         if (t == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n  * {@link com.fasterxml.jackson.databind.JsonSerializer}s using proper contextual\n  * calls, to add type information using mechanism type serializer was\n  * configured with.\n- * \n- * @author tatu\n  */\n public abstract class TypeSerializer\n {\n      *   to be written\n      * @param jgen Generator to use for writing type information\n      */\n-    public abstract void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTypePrefixForScalar(Object value, JsonGenerator jgen) throws IOException;\n \n     /**\n      * Method called to write initial part of type information for given\n      *   to be written\n      * @param jgen Generator to use for writing type information\n      */\n-    public abstract void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException;\n \n     /**\n      * Method called to write initial part of type information for given\n      *   to be written\n      * @param jgen Generator to use for writing type information\n      */\n-    public abstract void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTypePrefixForArray(Object value, JsonGenerator jgen) throws IOException;\n     \n     /**\n      * Method called after value has been serialized, to close any scopes opened\n      * Actual action to take may depend on various factors, but has to match with\n      * action {@link #writeTypePrefixForScalar} did (close array or object; or do nothing).\n      */\n-    public abstract void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTypeSuffixForScalar(Object value, JsonGenerator jgen) throws IOException;\n \n     /**\n      * Method called after value has been serialized, to close any scopes opened\n      * It needs to write closing END_OBJECT marker, and any other decoration\n      * that needs to be matched.\n      */\n-    public abstract void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTypeSuffixForObject(Object value, JsonGenerator jgen) throws IOException;\n \n     /**\n      * Method called after value has been serialized, to close any scopes opened\n      * It needs to write closing END_ARRAY marker, and any other decoration\n      * that needs to be matched.\n      */\n-    public abstract void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeTypeSuffixForArray(Object value, JsonGenerator jgen) throws IOException;\n \n     /**\n      * Alternative version of the prefix-for-scalar method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n      */\n-    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen,\n-            Class<?> type)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type) throws IOException {\n         writeTypePrefixForScalar(value, jgen);\n     }\n \n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n      */\n-    public void writeTypePrefixForObject(Object value, JsonGenerator jgen,\n-            Class<?> type)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException {\n         writeTypePrefixForObject(value, jgen);\n     }\n \n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n      */\n-    public void writeTypePrefixForArray(Object value, JsonGenerator jgen,\n-            Class<?> type)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type) throws IOException {\n         writeTypePrefixForArray(value, jgen);\n     }\n \n      * @param jgen Generator to use for writing type information\n      * @param typeId Exact type id to use\n      */\n-    public abstract void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen,\n-            String typeId)\n-        throws IOException, JsonProcessingException;\n+    public abstract void writeCustomTypePrefixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException, JsonProcessingException;\n     \n     /**\n      * Method called to write initial part of type information for given\n      * @param jgen Generator to use for writing type information\n      * @param typeId Exact type id to use\n      */\n-    public abstract void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen,\n-            String typeId)\n-        throws IOException, JsonProcessingException;\n-    \n-    public abstract void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen,\n-            String typeId)\n-        throws IOException, JsonProcessingException;\n-\n-    public abstract void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen,\n-            String typeId)\n-        throws IOException, JsonProcessingException;\n-\n-    public abstract void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen,\n-            String typeId)\n-        throws IOException, JsonProcessingException;\n-\n-    public abstract void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen,\n-            String typeId)\n-        throws IOException, JsonProcessingException;\n-\n+    public abstract void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException;\n+    \n+    public abstract void writeCustomTypePrefixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException;\n+\n+    public abstract void writeCustomTypeSuffixForScalar(Object value, JsonGenerator jgen, String typeId) throws IOException;\n+\n+    public abstract void writeCustomTypeSuffixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException;\n+\n+    public abstract void writeCustomTypeSuffixForArray(Object value, JsonGenerator jgen, String typeId) throws IOException;\n }", "timestamp": 1388558274, "metainfo": ""}