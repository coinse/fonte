{"sha": "e38b916ba1ebd3f5c00a6b6b8e77a4cdfea2800f", "log": "Merge branch 'parsesettings'", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n \n     /**\n      * Create a new attribute from unencoded (raw) key and value.\n-     * @param key attribute key\n+     * @param key attribute key; case is preserved.\n      * @param value attribute value\n      * @see #createFromEncoded\n      */\n     public Attribute(String key, String value) {\n         Validate.notEmpty(key);\n         Validate.notNull(value);\n-        this.key = key.trim().toLowerCase();\n+        this.key = key.trim();\n         this.value = value;\n     }\n \n     }\n \n     /**\n-     Set the attribute key. Gets normalised as per the constructor method.\n+     Set the attribute key; case is preserved.\n      @param key the new key; must not be null\n      */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key.trim().toLowerCase();\n+        this.key = key.trim();\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n import org.jsoup.helper.Validate;\n \n import java.io.IOException;\n-import java.util.*;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n \n /**\n  * The attributes of an Element.\n  * <p>\n- * Attributes are treated as a map: there can be only one value associated with an attribute key.\n+ * Attributes are treated as a map: there can be only one value associated with an attribute key/name.\n  * </p>\n  * <p>\n- * Attribute key and value comparisons are done case insensitively, and keys are normalised to\n- * lower-case.\n+ * Attribute name and value comparisons are  <b>case sensitive</b>. By default for HTML, attribute names are\n+ * normalized to lower-case on parsing. That means you should use lower-case strings when referring to attributes by\n+ * name.\n  * </p>\n- * \n+ *\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class Attributes implements Iterable<Attribute>, Cloneable {\n     protected static final String dataPrefix = \"data-\";\n-    \n+\n     private LinkedHashMap<String, Attribute> attributes = null;\n     // linked hash map to preserve insertion order.\n     // null be default as so many elements have no attributes -- saves a good chunk of memory\n \n     /**\n      Get an attribute value by key.\n-     @param key the attribute key\n+     @param key the (case-sensitive) attribute key\n      @return the attribute value if set; or empty string if not set.\n      @see #hasKey(String)\n      */\n         if (attributes == null)\n             return \"\";\n \n-        Attribute attr = attributes.get(key.toLowerCase());\n+        Attribute attr = attributes.get(key);\n         return attr != null ? attr.getValue() : \"\";\n+    }\n+\n+    /**\n+     * Get an attribute's value by case-insensitive key\n+     * @param key the attribute name\n+     * @return the first matching attribute value if set; or empty string if not set.\n+     */\n+    public String getIgnoreCase(String key) {\n+        Validate.notEmpty(key);\n+        if (attributes == null)\n+            return \"\";\n+\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                return attributes.get(attrKey).getValue();\n+        }\n+        return \"\";\n     }\n \n     /**\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n     }\n-    \n+\n     /**\n     Set a new boolean attribute, remove attribute if value is false.\n     @param key attribute key\n     }\n \n     /**\n-     Remove an attribute by key.\n+     Remove an attribute by key. <b>Case sensitive.</b>\n      @param key attribute key to remove\n      */\n     public void remove(String key) {\n         Validate.notEmpty(key);\n         if (attributes == null)\n             return;\n-        attributes.remove(key.toLowerCase());\n+        attributes.remove(key);\n+    }\n+\n+    /**\n+     Remove an attribute by key. <b>Case insensitive.</b>\n+     @param key attribute key to remove\n+     */\n+    public void removeIgnoreCase(String key) {\n+        Validate.notEmpty(key);\n+        if (attributes == null)\n+            return;\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                attributes.remove(attrKey);\n+        }\n+    }\n+\n+    /**\n+     Tests if these attributes contain an attribute with this key.\n+     @param key case-sensitive key to check for\n+     @return true if key exists, false otherwise\n+     */\n+    public boolean hasKey(String key) {\n+        return attributes != null && attributes.containsKey(key);\n     }\n \n     /**\n      @param key key to check for\n      @return true if key exists, false otherwise\n      */\n-    public boolean hasKey(String key) {\n-        return attributes != null && attributes.containsKey(key.toLowerCase());\n+    public boolean hasKeyIgnoreCase(String key) {\n+        if (attributes == null)\n+            return false;\n+        for (String attrKey : attributes.keySet()) {\n+            if (attrKey.equalsIgnoreCase(key))\n+                return true;\n+        }\n+        return false;\n     }\n \n     /**\n             attributes = new LinkedHashMap<String, Attribute>(incoming.size());\n         attributes.putAll(incoming.attributes);\n     }\n-    \n+\n     public Iterator<Attribute> iterator() {\n         return asList().iterator();\n     }\n         }\n         return accum.toString();\n     }\n-    \n+\n     void html(Appendable accum, Document.OutputSettings out) throws IOException {\n         if (attributes == null)\n             return;\n-        \n+\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n             Attribute attribute = entry.getValue();\n             accum.append(\" \");\n             attribute.html(accum, out);\n         }\n     }\n-    \n+\n     @Override\n     public String toString() {\n         return html();\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         if (!(o instanceof Attributes)) return false;\n-        \n+\n         Attributes that = (Attributes) o;\n-        \n+\n         return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n     }\n \n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n \n      @see #createShell\n      */\n     public Document(String baseUri) {\n-        super(Tag.valueOf(\"#root\"), baseUri);\n+        super(Tag.valueOf(\"#root\", ParseSettings.htmlDefault), baseUri);\n         this.location = baseUri;\n     }\n \n      @return new element\n      */\n     public Element createElement(String tagName) {\n-        return new Element(Tag.valueOf(tagName), this.baseUri());\n+        return new Element(Tag.valueOf(tagName, ParseSettings.preserveCase), this.baseUri());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n \n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.parser.ParseSettings;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.Collector;\n      * @param tag element tag\n      * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n      *            string, but not null.\n-     * @see Tag#valueOf(String)\n+     * @see Tag#valueOf(String, ParseSettings)\n      */\n     public Element(Tag tag, String baseUri) {\n         this(tag, baseUri, new Attributes());\n      */\n     public Element tagName(String tagName) {\n         Validate.notEmpty(tagName, \"Tag name must not be empty.\");\n-        tag = Tag.valueOf(tagName);\n+        tag = Tag.valueOf(tagName, ParseSettings.preserveCase); // preserve the requested tag case\n         return this;\n     }\n \n      * @return The id attribute, if present, or an empty string if not.\n      */\n     public String id() {\n-        return attributes.get(\"id\");\n+        return attributes.getIgnoreCase(\"id\");\n     }\n \n     /**\n      */\n     public Elements getElementsByAttribute(String key) {\n         Validate.notEmpty(key);\n-        key = key.trim().toLowerCase();\n+        key = key.trim();\n \n         return Collector.collect(new Evaluator.Attribute(key), this);\n     }\n      */\n     public Elements getElementsByAttributeStarting(String keyPrefix) {\n         Validate.notEmpty(keyPrefix);\n-        keyPrefix = keyPrefix.trim().toLowerCase();\n+        keyPrefix = keyPrefix.trim();\n \n         return Collector.collect(new Evaluator.AttributeStarting(keyPrefix), this);\n     }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n     public abstract String nodeName();\n \n     /**\n-     * Get an attribute's value by its key.\n+     * Get an attribute's value by its key. <b>Case insensitive</b>\n      * <p>\n      * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n      * which is a shortcut to the {@link #absUrl} method.\n     public String attr(String attributeKey) {\n         Validate.notNull(attributeKey);\n \n-        if (attributes.hasKey(attributeKey))\n-            return attributes.get(attributeKey);\n+        String val = attributes.getIgnoreCase(attributeKey);\n+        if (val.length() > 0)\n+            return val;\n         else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n             return absUrl(attributeKey.substring(\"abs:\".length()));\n         else return \"\";\n     }\n \n     /**\n-     * Test if this element has an attribute.\n+     * Test if this element has an attribute. <b>Case insensitive</b>\n      * @param attributeKey The attribute key to check.\n      * @return true if the attribute exists, false if not.\n      */\n \n         if (attributeKey.startsWith(\"abs:\")) {\n             String key = attributeKey.substring(\"abs:\".length());\n-            if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n+            if (attributes.hasKeyIgnoreCase(key) && !absUrl(key).equals(\"\"))\n                 return true;\n         }\n-        return attributes.hasKey(attributeKey);\n+        return attributes.hasKeyIgnoreCase(attributeKey);\n     }\n \n     /**\n      */\n     public Node removeAttr(String attributeKey) {\n         Validate.notNull(attributeKey);\n-        attributes.remove(attributeKey);\n+        attributes.removeIgnoreCase(attributeKey);\n         return this;\n     }\n \n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n     HtmlTreeBuilder() {}\n \n+    ParseSettings defaultSettings() {\n+        return ParseSettings.htmlDefault;\n+    }\n+\n     @Override\n-    Document parse(String input, String baseUri, ParseErrorList errors) {\n+    Document parse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         state = HtmlTreeBuilderState.Initial;\n         baseUriSetFromDoc = false;\n-        return super.parse(input, baseUri, errors);\n-    }\n-\n-    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n+        return super.parse(input, baseUri, errors, settings);\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         // context may be null\n         state = HtmlTreeBuilderState.Initial;\n-        initialiseParse(inputFragment, baseUri, errors);\n+        initialiseParse(inputFragment, baseUri, errors, settings);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\n             else\n                 tokeniser.transition(TokeniserState.Data); // default\n \n-            root = new Element(Tag.valueOf(\"html\"), baseUri);\n+            root = new Element(Tag.valueOf(\"html\", settings), baseUri);\n             doc.appendChild(root);\n             stack.add(root);\n             resetInsertionMode();\n             return el;\n         }\n         \n-        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n+        Element el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\n         insert(el);\n         return el;\n     }\n \n     Element insertStartTag(String startTagName) {\n-        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n+        Element el = new Element(Tag.valueOf(startTagName, settings), baseUri);\n         insert(el);\n         return el;\n     }\n     }\n \n     Element insertEmpty(Token.StartTag startTag) {\n-        Tag tag = Tag.valueOf(startTag.name());\n+        Tag tag = Tag.valueOf(startTag.name(), settings);\n         Element el = new Element(tag, baseUri, startTag.attributes);\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n     }\n \n     FormElement insertForm(Token.StartTag startTag, boolean onStack) {\n-        Tag tag = Tag.valueOf(startTag.name());\n+        Tag tag = Tag.valueOf(startTag.name(), settings);\n         FormElement el = new FormElement(tag, baseUri, startTag.attributes);\n         setFormElement(el);\n         insertNode(el);\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 // todo: parse error check on expected doctypes\n                 // todo: quirk state check on doctype ids\n                 Token.Doctype d = t.asDoctype();\n-                DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n+                DocumentType doctype = new DocumentType(\n+                    tb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n                 tb.getDocument().appendChild(doctype);\n                 if (d.isForceQuirks())\n                     tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n                 tb.insert(t.asComment());\n             } else if (isWhitespace(t)) {\n                 return true; // ignore whitespace\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 tb.insert(t.asStartTag());\n                 tb.transition(BeforeHead);\n-            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                 return anythingElse(t, tb);\n             } else if (t.isEndTag()) {\n                 tb.error(this);\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return InBody.process(t, tb); // does not transition\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\n                 Element head = tb.insert(t.asStartTag());\n                 tb.setHeadElement(head);\n                 tb.transition(InHead);\n-            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\n                 tb.processStartTag(\"head\");\n                 return tb.process(t);\n             } else if (t.isEndTag()) {\n                     return false;\n                 case StartTag:\n                     Token.StartTag start = t.asStartTag();\n-                    String name = start.name();\n+                    String name = start.normalName();\n                     if (name.equals(\"html\")) {\n                         return InBody.process(t, tb);\n                     } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n                     break;\n                 case EndTag:\n                     Token.EndTag end = t.asEndTag();\n-                    name = end.name();\n+                    name = end.normalName();\n                     if (name.equals(\"head\")) {\n                         tb.pop();\n                         tb.transition(AfterHead);\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isDoctype()) {\n                 tb.error(this);\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return tb.process(t, InBody);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"noscript\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"noscript\")) {\n                 tb.pop();\n                 tb.transition(InHead);\n-            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                     \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n                 return tb.process(t, InHead);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"br\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"br\")) {\n                 return anythingElse(t, tb);\n-            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"head\", \"noscript\")) || t.isEndTag()) {\n+            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"head\", \"noscript\")) || t.isEndTag()) {\n                 tb.error(this);\n                 return false;\n             } else {\n                 tb.error(this);\n             } else if (t.isStartTag()) {\n                 Token.StartTag startTag = t.asStartTag();\n-                String name = startTag.name();\n+                String name = startTag.normalName();\n                 if (name.equals(\"html\")) {\n                     return tb.process(t, InBody);\n                 } else if (name.equals(\"body\")) {\n                     anythingElse(t, tb);\n                 }\n             } else if (t.isEndTag()) {\n-                if (StringUtil.in(t.asEndTag().name(), \"body\", \"html\")) {\n+                if (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\n                     anythingElse(t, tb);\n                 } else {\n                     tb.error(this);\n                 }\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.name();\n+                    String name = startTag.normalName();\n                     if (name.equals(\"a\")) {\n                         if (tb.getActiveFormattingElement(\"a\") != null) {\n                             tb.error(this);\n \n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.name();\n+                    name = endTag.normalName();\n                     if (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n                         // Adoption Agency Algorithm.\n                         for (int i = 0; i < 8; i++) {\n                                 } else if (node == formatEl)\n                                     break;\n \n-                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n+                                Element replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n+                                // case will follow the original node (so honours ParseSettings)\n                                 tb.replaceActiveFormattingElement(node, replacement);\n                                 tb.replaceOnStack(node, replacement);\n                                 node = replacement;\n         }\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n-            String name = t.asEndTag().name();\n+            String name = t.asEndTag().normalName();\n             ArrayList<Element> stack = tb.getStack();\n             for (int pos = stack.size() -1; pos >= 0; pos--) {\n                 Element node = stack.get(pos);\n                 return false;\n             } else if (t.isStartTag()) {\n                 Token.StartTag startTag = t.asStartTag();\n-                String name = startTag.name();\n+                String name = startTag.normalName();\n                 if (name.equals(\"caption\")) {\n                     tb.clearStackToTableContext();\n                     tb.insertMarkerToFormattingElements();\n                 return true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable\n             } else if (t.isEndTag()) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n \n                 if (name.equals(\"table\")) {\n                     if (!tb.inTableScope(name)) {\n     },\n     InCaption {\n         boolean process(Token t, HtmlTreeBuilder tb) {\n-            if (t.isEndTag() && t.asEndTag().name().equals(\"caption\")) {\n+            if (t.isEndTag() && t.asEndTag().normalName().equals(\"caption\")) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n                 if (!tb.inTableScope(name)) {\n                     tb.error(this);\n                     return false;\n                     tb.transition(InTable);\n                 }\n             } else if ((\n-                    t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+                    t.isStartTag() && StringUtil.in(t.asStartTag().normalName(),\n                             \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n-                            t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n+                            t.isEndTag() && t.asEndTag().normalName().equals(\"table\"))\n                     ) {\n                 tb.error(this);\n                 boolean processed = tb.processEndTag(\"caption\");\n                 if (processed)\n                     return tb.process(t);\n-            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(),\n                     \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                 tb.error(this);\n                 return false;\n                     break;\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.name();\n+                    String name = startTag.normalName();\n                     if (name.equals(\"html\"))\n                         return tb.process(t, InBody);\n                     else if (name.equals(\"col\"))\n                     break;\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.name();\n+                    name = endTag.normalName();\n                     if (name.equals(\"colgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"html\")) { // frag case\n                             tb.error(this);\n             switch (t.type) {\n                 case StartTag:\n                     Token.StartTag startTag = t.asStartTag();\n-                    String name = startTag.name();\n+                    String name = startTag.normalName();\n                     if (name.equals(\"tr\")) {\n                         tb.clearStackToTableBodyContext();\n                         tb.insert(startTag);\n                     break;\n                 case EndTag:\n                     Token.EndTag endTag = t.asEndTag();\n-                    name = endTag.name();\n+                    name = endTag.normalName();\n                     if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                         if (!tb.inTableScope(name)) {\n                             tb.error(this);\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isStartTag()) {\n                 Token.StartTag startTag = t.asStartTag();\n-                String name = startTag.name();\n+                String name = startTag.normalName();\n \n                 if (StringUtil.in(name, \"th\", \"td\")) {\n                     tb.clearStackToTableRowContext();\n                 }\n             } else if (t.isEndTag()) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n \n                 if (name.equals(\"tr\")) {\n                     if (!tb.inTableScope(name)) {\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isEndTag()) {\n                 Token.EndTag endTag = t.asEndTag();\n-                String name = endTag.name();\n+                String name = endTag.normalName();\n \n                 if (StringUtil.in(name, \"td\", \"th\")) {\n                     if (!tb.inTableScope(name)) {\n                     return anythingElse(t, tb);\n                 }\n             } else if (t.isStartTag() &&\n-                    StringUtil.in(t.asStartTag().name(),\n+                    StringUtil.in(t.asStartTag().normalName(),\n                             \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n                 if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n                     tb.error(this);\n                     return false;\n                 case StartTag:\n                     Token.StartTag start = t.asStartTag();\n-                    String name = start.name();\n+                    String name = start.normalName();\n                     if (name.equals(\"html\"))\n                         return tb.process(start, InBody);\n                     else if (name.equals(\"option\")) {\n                     break;\n                 case EndTag:\n                     Token.EndTag end = t.asEndTag();\n-                    name = end.name();\n+                    name = end.normalName();\n                     if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n                             tb.processEndTag(\"option\");\n     },\n     InSelectInTable {\n         boolean process(Token t, HtmlTreeBuilder tb) {\n-            if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+            if (t.isStartTag() && StringUtil.in(t.asStartTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n                 tb.processEndTag(\"select\");\n                 return tb.process(t);\n-            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n-                tb.error(this);\n-                if (tb.inTableScope(t.asEndTag().name())) {\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().normalName(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+                tb.error(this);\n+                if (tb.inTableScope(t.asEndTag().normalName())) {\n                     tb.processEndTag(\"select\");\n                     return (tb.process(t));\n                 } else\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return tb.process(t, InBody);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                 if (tb.isFragmentParsing()) {\n                     tb.error(this);\n                     return false;\n                 return false;\n             } else if (t.isStartTag()) {\n                 Token.StartTag start = t.asStartTag();\n-                String name = start.name();\n+                String name = start.normalName();\n                 if (name.equals(\"html\")) {\n                     return tb.process(start, InBody);\n                 } else if (name.equals(\"frameset\")) {\n                     tb.error(this);\n                     return false;\n                 }\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"frameset\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"frameset\")) {\n                 if (tb.currentElement().nodeName().equals(\"html\")) { // frag\n                     tb.error(this);\n                     return false;\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\n                 return tb.process(t, InBody);\n-            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+            } else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\n                 tb.transition(AfterAfterFrameset);\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"noframes\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                 return tb.process(t, InHead);\n             } else if (t.isEOF()) {\n                 // cool your heels, we're complete\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isComment()) {\n                 tb.insert(t.asComment());\n-            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                 return tb.process(t, InBody);\n             } else if (t.isEOF()) {\n                 // nice work chuck\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isComment()) {\n                 tb.insert(t.asComment());\n-            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\n                 return tb.process(t, InBody);\n             } else if (t.isEOF()) {\n                 // nice work chuck\n-            } else if (t.isStartTag() && t.asStartTag().name().equals(\"noframes\")) {\n+            } else if (t.isStartTag() && t.asStartTag().normalName().equals(\"noframes\")) {\n                 return tb.process(t, InHead);\n             } else {\n                 tb.error(this);\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/ParseSettings.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n+\n+/**\n+ * Controls parser settings, to optionally preserve tag and/or attribute name case.\n+ */\n+public class ParseSettings {\n+    /**\n+     * HTML default settings: both tag and attribute names are lower-cased during parsing.\n+     */\n+    public static final ParseSettings htmlDefault;\n+    /**\n+     * Preserve both tag and attribute case.\n+     */\n+    public static final ParseSettings preserveCase;\n+\n+    static {\n+        htmlDefault = new ParseSettings(false, false);\n+        preserveCase = new ParseSettings(true, true);\n+    }\n+\n+    private final boolean preserveTagCase;\n+    private final boolean preserveAttributeCase;\n+\n+    /**\n+     * Define parse settings.\n+     * @param tag preserve tag case?\n+     * @param attribute preserve attribute name case?\n+     */\n+    public ParseSettings(boolean tag, boolean attribute) {\n+        preserveTagCase = tag;\n+        preserveAttributeCase = attribute;\n+    }\n+\n+    String normalizeTag(String name) {\n+        name = name.trim();\n+        if (!preserveTagCase)\n+            name = name.toLowerCase();\n+        return name;\n+    }\n+\n+    String normalizeAttribute(String name) {\n+        name = name.trim();\n+        if (!preserveAttributeCase)\n+            name = name.toLowerCase();\n+        return name;\n+    }\n+\n+    Attributes normalizeAttributes(Attributes attributes) {\n+        if (!preserveAttributeCase) {\n+            for (Attribute attr : attributes) {\n+                attr.setKey(attr.getKey().toLowerCase());\n+            }\n+        }\n+        return attributes;\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     private TreeBuilder treeBuilder;\n     private int maxErrors = DEFAULT_MAX_ERRORS;\n     private ParseErrorList errors;\n+    private ParseSettings settings;\n \n     /**\n      * Create a new Parser, using the specified TreeBuilder\n      */\n     public Parser(TreeBuilder treeBuilder) {\n         this.treeBuilder = treeBuilder;\n+        settings = treeBuilder.defaultSettings();\n     }\n     \n     public Document parseInput(String html, String baseUri) {\n         errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        return treeBuilder.parse(html, baseUri, errors);\n+        return treeBuilder.parse(html, baseUri, errors, settings);\n     }\n \n     // gets & sets\n         return errors;\n     }\n \n+    public Parser settings(ParseSettings settings) {\n+        this.settings = settings;\n+        return this;\n+    }\n+\n+    public ParseSettings settings() {\n+        return settings;\n+    }\n+\n     // static parse functions below\n     /**\n      * Parse HTML into a Document.\n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking());\n+        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking());\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\n      */\n     public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n         XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking());\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n     private boolean formSubmit = false; // a control that can be submitted in a form: input etc\n \n     private Tag(String tagName) {\n-        this.tagName = tagName.toLowerCase();\n+        this.tagName = tagName;\n     }\n \n     /**\n      * </p>\n      * \n      * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n+     * @param settings used to control tag name sensitivity\n      * @return The tag, either defined or new generic.\n      */\n-    public static Tag valueOf(String tagName) {\n+    public static Tag valueOf(String tagName, ParseSettings settings) {\n         Validate.notNull(tagName);\n         Tag tag = tags.get(tagName);\n \n         if (tag == null) {\n-            tagName = tagName.trim().toLowerCase();\n+            tagName = settings.normalizeTag(tagName);\n             Validate.notEmpty(tagName);\n             tag = tags.get(tagName);\n \n             }\n         }\n         return tag;\n+    }\n+\n+    /**\n+     * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n+     * <p>\n+     * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n+     * </p>\n+     *\n+     * @param tagName Name of tag, e.g. \"p\". <b>Case sensitive</b>.\n+     * @return The tag, either defined or new generic.\n+     */\n+    public static Tag valueOf(String tagName) {\n+        return valueOf(tagName, ParseSettings.preserveCase);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n \n     static abstract class Tag extends Token {\n         protected String tagName;\n+        protected String normalName; // lc version of tag name, for case insensitive tree build\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n         private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n         private String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\n         @Override\n         Tag reset() {\n             tagName = null;\n+            normalName = null;\n             pendingAttributeName = null;\n             reset(pendingAttributeValue);\n             pendingAttributeValueS = null;\n             }\n         }\n \n-        final String name() {\n+        final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\n             Validate.isFalse(tagName == null || tagName.length() == 0);\n             return tagName;\n         }\n \n+        final String normalName() { // loses case, used in tree building for working out where in tree it should go\n+            return normalName;\n+        }\n+\n         final Tag name(String name) {\n             tagName = name;\n+            normalName = name.toLowerCase();\n             return this;\n         }\n \n         // these appenders are rarely hit in not null state-- caused by null chars.\n         final void appendTagName(String append) {\n             tagName = tagName == null ? append : tagName.concat(append);\n+            normalName = tagName.toLowerCase();\n         }\n \n         final void appendTagName(char append) {\n         StartTag nameAttr(String name, Attributes attributes) {\n             this.tagName = name;\n             this.attributes = attributes;\n+            normalName = tagName.toLowerCase();\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         Arrays.sort(notCharRefCharsSorted);\n     }\n \n-    private CharacterReader reader; // html input\n-    private ParseErrorList errors; // errors found while tokenising\n+    private final CharacterReader reader; // html input\n+    private final ParseErrorList errors; // errors found while tokenising\n \n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     }\n \n     boolean isAppropriateEndTagToken() {\n-        return lastStartTag != null && tagPending.tagName.equals(lastStartTag);\n+        return lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n     }\n \n     String appropriateEndTagName() {\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n         void read(Tokeniser t, CharacterReader r) {\n             // previous TagOpen state did NOT consume, will have a letter char in current\n             //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n-            String tagName = r.consumeTagName().toLowerCase();\n+            String tagName = r.consumeTagName();\n             t.tagPending.appendTagName(tagName);\n \n             switch (r.consume()) {\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 t.createTagPending(false);\n-                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n-                t.dataBuffer.append(Character.toLowerCase(r.current()));\n+                t.tagPending.appendTagName(r.current());\n+                t.dataBuffer.append(r.current());\n                 t.advanceTransition(RCDATAEndTagName);\n             } else {\n                 t.emit(\"</\");\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n-                t.tagPending.appendTagName(name.toLowerCase());\n+                t.tagPending.appendTagName(name);\n                 t.dataBuffer.append(name);\n                 return;\n             }\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 t.createTempBuffer();\n-                t.dataBuffer.append(Character.toLowerCase(r.current()));\n+                t.dataBuffer.append(r.current());\n                 t.emit(\"<\" + r.current());\n                 t.advanceTransition(ScriptDataDoubleEscapeStart);\n             } else if (r.matches('/')) {\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 t.createTagPending(false);\n-                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n+                t.tagPending.appendTagName(r.current());\n                 t.dataBuffer.append(r.current());\n                 t.advanceTransition(ScriptDataEscapedEndTagName);\n             } else {\n         // from before attribute name\n         void read(Tokeniser t, CharacterReader r) {\n             String name = r.consumeToAnySorted(attributeNameCharsSorted);\n-            t.tagPending.appendAttributeName(name.toLowerCase());\n+            t.tagPending.appendAttributeName(name);\n \n             char c = r.consume();\n             switch (c) {\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n-                t.doctypePending.name.append(name.toLowerCase());\n+                t.doctypePending.name.append(name);\n                 return;\n             }\n             char c = r.consume();\n     private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n-            t.tagPending.appendTagName(name.toLowerCase());\n+            t.tagPending.appendTagName(name);\n             t.dataBuffer.append(name);\n             return;\n         }\n     private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n-            t.dataBuffer.append(name.toLowerCase());\n+            t.dataBuffer.append(name);\n             t.emit(name);\n             return;\n         }\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n+    protected ParseSettings settings;\n \n     private Token.StartTag start = new Token.StartTag(); // start tag to process\n     private Token.EndTag end  = new Token.EndTag();\n \n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n+    abstract ParseSettings defaultSettings();\n+\n+    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         Validate.notNull(input, \"String input must not be null\");\n         Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n         doc = new Document(baseUri);\n+        this.settings = settings;\n         reader = new CharacterReader(input);\n         this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n         this.baseUri = baseUri;\n     }\n \n-    Document parse(String input, String baseUri) {\n-        return parse(input, baseUri, ParseErrorList.noTracking());\n-    }\n-\n-    Document parse(String input, String baseUri, ParseErrorList errors) {\n-        initialiseParse(input, baseUri, errors);\n+    Document parse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        initialiseParse(input, baseUri, errors, settings);\n         runParser();\n         return doc;\n     }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n  * @author Jonathan Hedley\n  */\n public class XmlTreeBuilder extends TreeBuilder {\n+    ParseSettings defaultSettings() {\n+        return ParseSettings.preserveCase;\n+    }\n+\n+    Document parse(String input, String baseUri) {\n+        return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n+    }\n+\n     @Override\n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n-        super.initialiseParse(input, baseUri, errors);\n+    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        super.initialiseParse(input, baseUri, errors, settings);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n         doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n     }\n     }\n \n     Element insert(Token.StartTag startTag) {\n-        Tag tag = Tag.valueOf(startTag.name());\n+        Tag tag = Tag.valueOf(startTag.name(), settings);\n         // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n-        Element el = new Element(tag, baseUri, startTag.attributes);\n+        Element el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n             tokeniser.acknowledgeSelfClosingFlag();\n             if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                 Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                 Element el = doc.child(0);\n-                insert = new XmlDeclaration(el.tagName(), comment.baseUri(), data.startsWith(\"!\"));\n+                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), comment.baseUri(), data.startsWith(\"!\"));\n                 insert.attributes().addAll(el.attributes());\n             }\n         }\n     }\n \n     void insert(Token.Doctype d) {\n-        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n+        DocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n         insertNode(doctypeNode);\n     }\n \n         }\n     }\n \n-    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n-        initialiseParse(inputFragment, baseUri, errors);\n+    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+        initialiseParse(inputFragment, baseUri, errors, settings);\n         runParser();\n         return doc.childNodes();\n     }\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return (element.tagName().equals(tagName));\n+            return (element.tagName().equalsIgnoreCase(tagName));\n         }\n \n         @Override\n         private String keyPrefix;\n \n         public AttributeStarting(String keyPrefix) {\n-            this.keyPrefix = keyPrefix;\n+            Validate.notEmpty(keyPrefix);\n+            this.keyPrefix = keyPrefix.toLowerCase();\n         }\n \n         @Override\n         public boolean matches(Element root, Element element) {\n             List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n             for (org.jsoup.nodes.Attribute attribute : values) {\n-                if (attribute.getKey().startsWith(keyPrefix))\n+                if (attribute.getKey().toLowerCase().startsWith(keyPrefix))\n                     return true;\n             }\n             return false;\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n     private void byClass() {\n         String className = tq.consumeCssIdentifier();\n         Validate.notEmpty(className);\n-        evals.add(new Evaluator.Class(className.trim().toLowerCase()));\n+        evals.add(new Evaluator.Class(className.trim()));\n     }\n \n     private void byTag() {\n             if (tagName.contains(\"|\"))\n                 tagName = tagName.replace(\"|\", \":\");\n \n-            evals.add(new Evaluator.Tag(tagName.trim().toLowerCase()));\n+            evals.add(new Evaluator.Tag(tagName.trim()));\n         }\n     }\n \n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * \n  * <h2>Selector syntax</h2>\n  * <p>\n- * A selector is a chain of simple selectors, separated by combinators. Selectors are case insensitive (including against\n+ * A selector is a chain of simple selectors, separated by combinators. Selectors are <b>case insensitive</b> (including against\n  * elements, attributes, and attribute values).\n  * </p>\n  * <p>\n--- a/src/test/java/org/jsoup/nodes/AttributesTest.java\n+++ b/src/test/java/org/jsoup/nodes/AttributesTest.java\n         a.put(\"data-name\", \"Jsoup\");\n \n         assertEquals(3, a.size());\n-        assertTrue(a.hasKey(\"tot\"));\n+        assertTrue(a.hasKey(\"Tot\"));\n         assertTrue(a.hasKey(\"Hello\"));\n         assertTrue(a.hasKey(\"data-name\"));\n+        assertFalse(a.hasKey(\"tot\"));\n+        assertTrue(a.hasKeyIgnoreCase(\"tot\"));\n+        assertEquals(\"There\", a.getIgnoreCase(\"hEllo\"));\n+\n         assertEquals(1, a.dataset().size());\n         assertEquals(\"Jsoup\", a.dataset().get(\"name\"));\n-        assertEquals(\"a&p\", a.get(\"tot\"));\n+        assertEquals(\"\", a.get(\"tot\"));\n+        assertEquals(\"a&p\", a.get(\"Tot\"));\n+        assertEquals(\"a&p\", a.getIgnoreCase(\"tot\"));\n \n-        assertEquals(\" tot=\\\"a&amp;p\\\" hello=\\\"There\\\" data-name=\\\"Jsoup\\\"\", a.html());\n+        assertEquals(\" Tot=\\\"a&amp;p\\\" Hello=\\\"There\\\" data-name=\\\"Jsoup\\\"\", a.html());\n         assertEquals(a.html(), a.toString());\n     }\n \n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         Document doc = Jsoup.parse(\"<div id=1><p>Hello</p></div>\");\n         Element div = doc.getElementById(\"1\");\n         div.appendElement(\"p\").text(\"there\");\n-        div.appendElement(\"P\").attr(\"class\", \"second\").text(\"now\");\n-        assertEquals(\"<html><head></head><body><div id=\\\"1\\\"><p>Hello</p><p>there</p><p class=\\\"second\\\">now</p></div></body></html>\",\n+        div.appendElement(\"P\").attr(\"CLASS\", \"second\").text(\"now\");\n+        // manually specifying tag and attributes should now preserve case, regardless of parse mode\n+        assertEquals(\"<html><head></head><body><div id=\\\"1\\\"><p>Hello</p><p>there</p><P CLASS=\\\"second\\\">now</P></div></body></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n \n         // check sibling index (with short circuit on reindexChildren):\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         assertEquals(\"Check\", els.text());\n     }\n \n-    @Test public void testFragement() {\n+    @Test public void testFragment() {\n         // make sure when parsing a body fragment, a script tag at start goes into the body\n         String html =\n             \"<script type=\\\"text/javascript\\\">console.log('foo');</script>\\n\" +\n             \"</div> \\n\" +\n             \"<script type=\\\"text/javascript\\\">console.log('bar');</script>\", body.body().html());\n     }\n+\n+    @Test public void testHtmlLowerCase() {\n+        String html = \"<!doctype HTML><DIV ID=1>One</DIV>\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<!doctype html> <html> <head></head> <body> <div id=\\\"1\\\"> One </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void canPreserveTagCase() {\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(new ParseSettings(true, false));\n+        Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n+        assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <SPAN id=\\\"2\\\"></SPAN> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void canPreserveAttributeCase() {\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(new ParseSettings(false, true));\n+        Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n+        assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <span ID=\\\"2\\\"></span> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n+\n+    @Test public void canPreserveBothCase() {\n+        Parser parser = Parser.htmlParser();\n+        parser.settings(new ParseSettings(true, true));\n+        Document doc = parser.parseInput(\"<div id=1><SPAN ID=2>\", \"\");\n+        assertEquals(\"<html> <head></head> <body> <div id=\\\"1\\\"> <SPAN ID=\\\"2\\\"></SPAN> </div> </body> </html>\", StringUtil.normaliseWhitespace(doc.outerHtml()));\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/ParserSettingsTest.java\n+package org.jsoup.parser;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.assertEquals;\n+\n+public class ParserSettingsTest {\n+    @Test\n+    public void caseSupport() {\n+        ParseSettings bothOn = new ParseSettings(true, true);\n+        ParseSettings bothOff = new ParseSettings(false, false);\n+        ParseSettings tagOn = new ParseSettings(true, false);\n+        ParseSettings attrOn = new ParseSettings(false, true);\n+\n+        assertEquals(\"FOO\", bothOn.normalizeTag(\"FOO\"));\n+        assertEquals(\"FOO\", bothOn.normalizeAttribute(\"FOO\"));\n+\n+        assertEquals(\"foo\", bothOff.normalizeTag(\"FOO\"));\n+        assertEquals(\"foo\", bothOff.normalizeAttribute(\"FOO\"));\n+\n+        assertEquals(\"FOO\", tagOn.normalizeTag(\"FOO\"));\n+        assertEquals(\"foo\", tagOn.normalizeAttribute(\"FOO\"));\n+\n+        assertEquals(\"foo\", attrOn.normalizeTag(\"FOO\"));\n+        assertEquals(\"FOO\", attrOn.normalizeAttribute(\"FOO\"));\n+\n+    }\n+}\n--- a/src/test/java/org/jsoup/parser/TagTest.java\n+++ b/src/test/java/org/jsoup/parser/TagTest.java\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TagTest {\n \n-    @Test public void isCaseInsensitive() {\n+    @Test public void isCaseSensitive() {\n         Tag p1 = Tag.valueOf(\"P\");\n         Tag p2 = Tag.valueOf(\"p\");\n+        assertFalse(p1.equals(p2));\n+    }\n+\n+    @Test public void canBeInsensitive() {\n+        Tag p1 = Tag.valueOf(\"P\", ParseSettings.htmlDefault);\n+        Tag p2 = Tag.valueOf(\"p\", ParseSettings.htmlDefault);\n         assertEquals(p1, p2);\n     }\n \n     }\n \n     @Test public void defaultSemantics() {\n-        Tag foo = Tag.valueOf(\"foo\"); // not defined\n+        Tag foo = Tag.valueOf(\"FOO\"); // not defined\n         Tag foo2 = Tag.valueOf(\"FOO\");\n \n         assertEquals(foo, foo2);\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n \n     @Test\n     public void testCommentAndDocType() {\n-        String xml = \"<!DOCTYPE html><!-- a comment -->One <qux />Two\";\n+        String xml = \"<!DOCTYPE HTML><!-- a comment -->One <qux />Two\";\n         XmlTreeBuilder tb = new XmlTreeBuilder();\n         Document doc = tb.parse(xml, \"http://foo.com/\");\n-        assertEquals(\"<!DOCTYPE html><!-- a comment -->One <qux />Two\",\n+        assertEquals(\"<!DOCTYPE HTML><!-- a comment -->One <qux />Two\",\n                 TextUtil.stripNewlines(doc.html()));\n     }\n \n     }\n \n     @Test\n+    public void caseSensitiveDeclaration() {\n+        String xml = \"<?XML version='1' encoding='UTF-8' something='else'?>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        assertEquals(\"<?XML version=\\\"1\\\" encoding=\\\"UTF-8\\\" something=\\\"else\\\"?>\", doc.outerHtml());\n+    }\n+\n+    @Test\n     public void testCreatesValidProlog() {\n         Document document = Document.createShell(\"\");\n         document.outputSettings().syntax(Syntax.xml);\n             \" <body></body>\\n\" +\n             \"</html>\", document.outerHtml());\n     }\n+\n+    @Test\n+    public void preservesCaseByDefault() {\n+        String xml = \"<TEST ID=1>Check</TEST>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+        assertEquals(\"<TEST ID=\\\"1\\\">Check</TEST>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n+    public void canNormalizeCase() {\n+        String xml = \"<TEST ID=1>Check</TEST>\";\n+        Document doc = Jsoup.parse(xml, \"\", Parser.xmlParser().settings(ParseSettings.htmlDefault));\n+        assertEquals(\"<test id=\\\"1\\\">Check</test>\", TextUtil.stripNewlines(doc.html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n  */\n public class SelectorTest {\n     @Test public void testByTag() {\n-        Elements els = Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><div id=3>\").select(\"div\");\n+        // should be case insensitive\n+        Elements els = Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><DIV id=3>\").select(\"DIV\");\n         assertEquals(3, els.size());\n         assertEquals(\"1\", els.get(0).id());\n         assertEquals(\"2\", els.get(1).id());\n     }\n \n     @Test public void testByClass() {\n-        Elements els = Jsoup.parse(\"<p id=0 class='one two'><p id=1 class='one'><p id=2 class='two'>\").select(\"p.one\");\n+        Elements els = Jsoup.parse(\"<p id=0 class='ONE two'><p id=1 class='one'><p id=2 class='two'>\").select(\"P.One\");\n         assertEquals(2, els.size());\n         assertEquals(\"0\", els.get(0).id());\n         assertEquals(\"1\", els.get(1).id());\n         Elements withTitle = doc.select(\"[title]\");\n         assertEquals(4, withTitle.size());\n \n-        Elements foo = doc.select(\"[title=foo]\");\n+        Elements foo = doc.select(\"[TITLE=foo]\");\n         assertEquals(1, foo.size());\n \n         Elements foo2 = doc.select(\"[title=\\\"foo\\\"]\");\n     @Test public void descendant() {\n         String h = \"<div class=head><p class=first>Hello</p><p>There</p></div><p>None</p>\";\n         Document doc = Jsoup.parse(h);\n-        Element root = doc.getElementsByClass(\"head\").first();\n+        Element root = doc.getElementsByClass(\"HEAD\").first();\n         \n         Elements els = root.select(\".head p\");\n         assertEquals(2, els.size());\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     Connection header(String name, String value);\n \n     /**\n+     * Adds each of the supplied headers to the request.\n+     * @param headers map of headers name {@literal ->} value pairs\n+     * @return this Connection, for chaining\n+     * @see org.jsoup.Connection.Request#headers()\n+     */\n+    Connection headers(Map<String,String> headers);\n+\n+    /**\n      * Set a cookie to be sent in the request.\n      * @param name name of cookie\n      * @param value value of cookie\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n \n     public Connection header(String name, String value) {\n         req.header(name, value);\n+        return this;\n+    }\n+\n+    public Connection headers(Map<String,String> headers) {\n+        Validate.notNull(headers, \"Header map must not be null\");\n+        for (Map.Entry<String,String> entry : headers.entrySet()) {\n+            req.header(entry.getKey(),entry.getValue());\n+        }\n         return this;\n     }\n \n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n \n         private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n             for (Attribute attribute : source.attributes()) {\n-                el.setAttribute(attribute.getKey(), attribute.getValue());\n+                // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n+                String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n+                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n+                    el.setAttribute(key, attribute.getValue());\n             }\n         }\n \n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n     }\n     \n     /**\n-     * Consume a CSS element selector (tag name, but | instead of : for namespaces, to not conflict with :pseudo selects).\n+     * Consume a CSS element selector (tag name, but | instead of : for namespaces (or *| for wildcard namespace), to not conflict with :pseudo selects).\n      * \n      * @return tag name\n      */\n     public String consumeElementSelector() {\n         int start = pos;\n-        while (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\n+        while (!isEmpty() && (matchesWord() || matchesAny(\"*|\",\"|\", \"_\", \"-\")))\n             pos++;\n         \n         return queue.substring(start, pos);\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n             updateNumEvaluators();\n         }\n \n+        Or(Evaluator... evaluators) { this(Arrays.asList(evaluators)); }\n+\n         Or() {\n             super();\n         }\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n         @Override\n         public boolean matches(Element root, Element element) {\n             return (element.tagName().equalsIgnoreCase(tagName));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"%s\", tagName);\n+        }\n+    }\n+\n+\n+    /**\n+     * Evaluator for tag name that ends with\n+     */\n+    public static final class TagEndsWith extends Evaluator {\n+        private String tagName;\n+\n+        public TagEndsWith(String tagName) {\n+            this.tagName = tagName;\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return (element.tagName().endsWith(tagName));\n         }\n \n         @Override\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n             byId();\n         else if (tq.matchChomp(\".\"))\n             byClass();\n-        else if (tq.matchesWord())\n+        else if (tq.matchesWord() || tq.matches(\"*|\"))\n             byTag();\n         else if (tq.matches(\"[\"))\n             byAttribute();\n \n     private void byTag() {\n         String tagName = tq.consumeElementSelector();\n+\n         Validate.notEmpty(tagName);\n \n-        // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n-        if (tagName.contains(\"|\"))\n-            tagName = tagName.replace(\"|\", \":\");\n-\n-        evals.add(new Evaluator.Tag(tagName.trim()));\n+        // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n+        if (tagName.startsWith(\"*|\")) {\n+            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName.trim().toLowerCase()), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\").trim().toLowerCase())));\n+        } else {\n+            // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n+            if (tagName.contains(\"|\"))\n+                tagName = tagName.replace(\"|\", \":\");\n+\n+            evals.add(new Evaluator.Tag(tagName.trim()));\n+        }\n     }\n \n     private void byAttribute() {\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * <tr><th align=\"left\">Pattern</th><th align=\"left\">Matches</th><th align=\"left\">Example</th></tr>\n  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n+ * <tr><td><code>*|E</code></td><td>elements of type E in any namespace <i>ns</i></td><td><code>*|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  * <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n         res.header(\"accept-encoding\", \"deflate\");\n         assertEquals(\"deflate\", res.header(\"Accept-Encoding\"));\n         assertEquals(\"deflate\", res.header(\"accept-Encoding\"));\n+    }\n+\n+    @Test public void headers() {\n+        Connection con = HttpConnection.connect(\"http://example.com\");\n+        Map<String, String> headers = new HashMap<String, String>();\n+        headers.put(\"content-type\", \"text/html\");\n+        headers.put(\"Connection\", \"keep-alive\");\n+        headers.put(\"Host\", \"http://example.com\");\n+        con.headers(headers);\n+        assertEquals(\"text/html\", con.request().header(\"content-type\"));\n+        assertEquals(\"keep-alive\", con.request().header(\"Connection\"));\n+        assertEquals(\"http://example.com\", con.request().header(\"Host\"));\n     }\n \n     @Test public void sameHeadersCombineWithComma() {\n--- a/src/test/java/org/jsoup/helper/W3CDomTest.java\n+++ b/src/test/java/org/jsoup/helper/W3CDomTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.Element;\n import org.junit.Test;\n import org.w3c.dom.Document;\n import org.w3c.dom.Node;\n         assertEquals(\"section\", xSection.getLocalName());\n         assertEquals(\"x:section\", xSection.getNodeName());\n     }\n+\n+    @Test\n+    public void handlesInvalidAttributeNames() {\n+        String html = \"<html><head></head><body style=\\\"color: red\\\" \\\" name\\\"></body></html>\";\n+        org.jsoup.nodes.Document jsoupDoc;\n+        jsoupDoc = Jsoup.parse(html);\n+        Element body = jsoupDoc.select(\"body\").first();\n+        assertTrue(body.hasAttr(\"\\\"\")); // actually an attribute with key '\"'. Correct per HTML5 spec, but w3c xml dom doesn't dig it\n+        assertTrue(body.hasAttr(\"name\\\"\"));\n+\n+        Document w3Doc = new W3CDom().fromJsoup(jsoupDoc);\n+    }\n }\n \n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         assertEquals(\"Check\", els.text());\n     }\n \n+    @Test public void testFragment() {\n+        // make sure when parsing a body fragment, a script tag at start goes into the body\n+        String html =\n+            \"<script type=\\\"text/javascript\\\">console.log('foo');</script>\\n\" +\n+                \"<div id=\\\"somecontent\\\">some content</div>\\n\" +\n+                \"<script type=\\\"text/javascript\\\">console.log('bar');</script>\";\n+\n+        Document body = Jsoup.parseBodyFragment(html);\n+        assertEquals(\"<script type=\\\"text/javascript\\\">console.log('foo');</script> \\n\" +\n+            \"<div id=\\\"somecontent\\\">\\n\" +\n+            \" some content\\n\" +\n+            \"</div> \\n\" +\n+            \"<script type=\\\"text/javascript\\\">console.log('bar');</script>\", body.body().html());\n+    }\n+\n     @Test public void testHtmlLowerCase() {\n         String html = \"<!doctype HTML><DIV ID=1>One</DIV>\";\n         Document doc = Jsoup.parse(html);\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         assertEquals(\"2\", byTagAttr.last().id());\n \n         Elements byContains = doc.select(\"abc|def:contains(e)\");\n+        assertEquals(2, byContains.size());\n+        assertEquals(\"1\", byContains.first().id());\n+        assertEquals(\"2\", byContains.last().id());\n+    }\n+\n+    @Test public void testWildcardNamespacedTag() {\n+        Document doc = Jsoup.parse(\"<div><abc:def id=1>Hello</abc:def></div> <abc:def class=bold id=2>There</abc:def>\");\n+        Elements byTag = doc.select(\"*|def\");\n+        assertEquals(2, byTag.size());\n+        assertEquals(\"1\", byTag.first().id());\n+        assertEquals(\"2\", byTag.last().id());\n+\n+        Elements byAttr = doc.select(\".bold\");\n+        assertEquals(1, byAttr.size());\n+        assertEquals(\"2\", byAttr.last().id());\n+\n+        Elements byTagAttr = doc.select(\"*|def.bold\");\n+        assertEquals(1, byTagAttr.size());\n+        assertEquals(\"2\", byTagAttr.last().id());\n+\n+        Elements byContains = doc.select(\"*|def:contains(e)\");\n         assertEquals(2, byContains.size());\n         assertEquals(\"1\", byContains.first().id());\n         assertEquals(\"2\", byContains.last().id());", "timestamp": 1470503836, "metainfo": ""}