{"sha": "6dc38f26dd31f1a367961f27c56b143cd0462e5a", "log": "Use jsoup's CharacterReader instead of regexes to parse Entities  Faster, less memory.", "commit": "\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n public final class DataUtil {\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n-    private static final int bufferSize = 0x20000; // ~130K.\n-    private static final int UNICODE_BOM = 0xFEFF;\n+    private static final int bufferSize = 60000;\n     private static final char[] mimeBoundaryChars =\n             \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n     static final int boundaryLength = 32;\n      * @return the filled byte buffer\n      * @throws IOException if an exception occurs whilst reading from the input stream.\n      */\n-    static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n+    public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n         Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n         final boolean capped = maxSize > 0;\n-        byte[] buffer = new byte[bufferSize];\n-        ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n+        byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n+        ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n         int read;\n         int remaining = maxSize;\n \n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n+import org.jsoup.helper.DataUtil;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.parser.CharacterReader;\n import org.jsoup.parser.Parser;\n \n-import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.InputStreamReader;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n import java.nio.charset.CharsetEncoder;\n import java.util.Arrays;\n import java.util.HashMap;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n import static org.jsoup.nodes.Entities.EscapeMode.base;\n import static org.jsoup.nodes.Entities.EscapeMode.extended;\n  * named character references</a>.\n  */\n public class Entities {\n-    private static Pattern entityPattern = Pattern.compile(\"^(\\\\w+)=(\\\\w+)(?:,(\\\\w+))?;(\\\\w+)$\");\n-    static final int empty = -1;\n-    static final String emptyName = \"\";\n+    private static final int empty = -1;\n+    private static final String emptyName = \"\";\n     static final int codepointRadix = 36;\n \n     public enum EscapeMode {\n-        /** Restricted entities suitable for XHTML output: lt, gt, amp, and quot only. */\n+        /**\n+         * Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n+         */\n         xhtml(\"entities-xhtml.properties\", 4),\n-        /** Default HTML output entities. */\n+        /**\n+         * Default HTML output entities.\n+         */\n         base(\"entities-base.properties\", 106),\n-        /** Complete HTML entities. */\n+        /**\n+         * Complete HTML entities.\n+         */\n         extended(\"entities-full.properties\", 2125);\n \n         // table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\n             if (index >= 0) {\n                 // the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n                 // (and binary search for same item with multi results is undefined\n-                return (index < nameVals.length-1 && codeKeys[index+1] == codepoint) ?\n-                    nameVals[index+1] : nameVals[index];\n+                return (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\n+                    nameVals[index + 1] : nameVals[index];\n             }\n             return emptyName;\n         }\n \n     /**\n      * Check if the input is a known named entity\n+     *\n      * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity\n      */\n \n     /**\n      * Check if the input is a known named entity in the base entity set.\n+     *\n      * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity in the base set\n      * @see #isNamedEntity(String)\n \n     /**\n      * Get the Character value of the named entity\n+     *\n      * @param name named entity (e.g. \"lt\" or \"amp\")\n      * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n      * @deprecated does not support characters outside the BMP or multiple character names\n \n     /**\n      * Get the character(s) represented by the named entitiy\n+     *\n      * @param name entity (e.g. \"lt\" or \"amp\")\n      * @return the string value of the character(s) represented by this entity, or \"\" if not defined\n      */\n \n     /**\n      * Unescape the input string.\n+     *\n      * @param string to un-HTML-escape\n      * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n      * @return unescaped string\n         }\n     }\n \n+    private static final char[] codeDelims = {',', ';'};\n+\n     private static void load(EscapeMode e, String file, int size) {\n         e.nameKeys = new String[size];\n         e.codeVals = new int[size];\n         InputStream stream = Entities.class.getResourceAsStream(file);\n         if (stream == null)\n             throw new IllegalStateException(\"Could not read resource \" + file + \". Make sure you copy resources for \" + Entities.class.getCanonicalName());\n-        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n-        String entry;\n+\n         int i = 0;\n         try {\n-            while ((entry = reader.readLine()) != null) {\n+            ByteBuffer bytes = DataUtil.readToByteBuffer(stream, 0);\n+            String contents = Charset.forName(\"ascii\").decode(bytes).toString();\n+            CharacterReader reader = new CharacterReader(contents);\n+\n+            while (!reader.isEmpty()) {\n                 // NotNestedLessLess=10913,824;1887\n-                final Matcher match = entityPattern.matcher(entry);\n-                if (match.find()) {\n-                    final String name = match.group(1);\n-                    final int cp1 = Integer.parseInt(match.group(2), codepointRadix);\n-                    final int cp2 = match.group(3) != null ? Integer.parseInt(match.group(3), codepointRadix) : empty;\n-                    final int index = Integer.parseInt(match.group(4), codepointRadix);\n-\n-                    e.nameKeys[i] = name;\n-                    e.codeVals[i] = cp1;\n-                    e.codeKeys[index] = cp1;\n-                    e.nameVals[index] = name;\n-\n-                    if (cp2 != empty) {\n-                        multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n-                    }\n-                    i++;\n+\n+                final String name = reader.consumeTo('=');\n+                reader.advance();\n+                final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n+                final char codeDelim = reader.current();\n+                reader.advance();\n+                final int cp2;\n+                if (codeDelim == ',') {\n+                    cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n+                    reader.advance();\n+                } else {\n+                    cp2 = empty;\n                 }\n+                final int index = Integer.parseInt(reader.consumeTo('\\n'), codepointRadix);\n+                reader.advance();\n+\n+                e.nameKeys[i] = name;\n+                e.codeVals[i] = cp1;\n+                e.codeKeys[index] = cp1;\n+                e.nameVals[index] = name;\n+\n+                if (cp2 != empty) {\n+                    multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n+                }\n+                i++;\n+\n \n             }\n-            reader.close();\n         } catch (IOException err) {\n             throw new IllegalStateException(\"Error reading resource \" + file);\n         }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n import java.util.Locale;\n \n /**\n- CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n+ CharacterReader consumes tokens off a string. Used internally by jsoup. API subject to changes.\n  */\n-final class CharacterReader {\n+public final class CharacterReader {\n     static final char EOF = (char) -1;\n     private static final int maxCacheLen = 12;\n \n     private int mark = 0;\n     private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n-    CharacterReader(String input) {\n+    public CharacterReader(String input) {\n         Validate.notNull(input);\n         this.input = input.toCharArray();\n         this.length = this.input.length;\n     }\n \n-    int pos() {\n+    /**\n+     * Gets the current cursor position in the content.\n+     * @return current position\n+     */\n+    public int pos() {\n         return pos;\n     }\n \n-    boolean isEmpty() {\n+    /**\n+     * Tests if all the content has been read.\n+     * @return true if nothing left to read.\n+     */\n+    public boolean isEmpty() {\n         return pos >= length;\n     }\n \n-    char current() {\n+    /**\n+     * Get the char at the current position.\n+     * @return char\n+     */\n+    public char current() {\n         return pos >= length ? EOF : input[pos];\n     }\n \n         pos--;\n     }\n \n-    void advance() {\n+    /**\n+     * Moves the current position by one.\n+     */\n+    public void advance() {\n         pos++;\n     }\n \n         return -1;\n     }\n \n-    String consumeTo(char c) {\n+    /**\n+     * Reads characters up to the specific char.\n+     * @param c the delimiter\n+     * @return the chars read\n+     */\n+    public String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n             String consumed = cacheString(pos, offset);\n         }\n     }\n \n-    String consumeToAny(final char... chars) {\n+    /**\n+     * Read characters until the first of any delimiters is found.\n+     * @param chars delimiters to scan for\n+     * @return characters read up to the matched delimiter.\n+     */\n+    public String consumeToAny(final char... chars) {\n         final int start = pos;\n         final int remaining = length;\n         final char[] val = input;", "timestamp": 1477270765, "metainfo": ""}