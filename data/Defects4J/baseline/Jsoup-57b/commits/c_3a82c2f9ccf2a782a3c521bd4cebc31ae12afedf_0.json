{"sha": "3a82c2f9ccf2a782a3c521bd4cebc31ae12afedf", "log": "Merge branch 'speedbird'", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n      */\n     public Element appendChild(Node child) {\n         Validate.notNull(child);\n-        \n-        addChildren(child);\n+\n+        // was - Node#addChildren(child). short-circuits an array create and a loop.\n+        reparentChild(child);\n+        childNodes.add(child);\n+        child.setSiblingIndex(childNodes.size()-1);\n         return this;\n     }\n \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n         reindexChildren();\n     }\n \n-    private void reparentChild(Node child) {\n+    protected void reparentChild(Node child) {\n         if (child.parentNode != null)\n             child.parentNode.removeChild(child);\n         child.setParentNode(this);\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n \n import org.jsoup.helper.Validate;\n \n+import java.util.Arrays;\n import java.util.Locale;\n \n /**\n  CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n  */\n-class CharacterReader {\n+final class CharacterReader {\n     static final char EOF = (char) -1;\n+    private static final int maxCacheLen = 12;\n \n     private final char[] input;\n     private final int length;\n     private int pos = 0;\n     private int mark = 0;\n+    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n     String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     }\n \n     String consumeToAny(final char... chars) {\n-        int start = pos;\n-\n-        OUTER: while (pos < length) {\n-            for (int i = 0; i < chars.length; i++) {\n-                if (input[pos] == chars[i])\n+        final int start = pos;\n+        final int remaining = length;\n+\n+        OUTER: while (pos < remaining) {\n+            for (char c : chars) {\n+                if (input[pos] == c)\n                     break OUTER;\n             }\n             pos++;\n         }\n \n-        return pos > start ? new String(input, start, pos-start) : \"\";\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeToAnySorted(final char... chars) {\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeData() {\n+        // &, <, null\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeTagName() {\n+        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = new String(input, pos, length-pos);\n+        String data = cacheString(pos, length-pos);\n         pos = length;\n         return data;\n     }\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeHexSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeDigitSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     boolean matches(char c) {\n         return false;\n     }\n \n+    boolean matchesAnySorted(char[] seq) {\n+        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+    }\n+\n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n     public String toString() {\n         return new String(input, pos, length - pos);\n     }\n+\n+    /**\n+     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n+     * <p />\n+     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n+     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n+     * some more duplicates.\n+     */\n+    private String cacheString(final int start, final int count) {\n+        final char[] val = input;\n+        final String[] cache = stringCache;\n+\n+        // limit (no cache):\n+        if (count > maxCacheLen)\n+            return new String(val, start, count);\n+\n+        // calculate hash:\n+        int hash = 0;\n+        int offset = start;\n+        for (int i = 0; i < count; i++) {\n+            hash = 31 * hash + val[offset++];\n+        }\n+\n+        // get from cache\n+        final int index = hash & cache.length - 1;\n+        String cached = cache[index];\n+\n+        if (cached == null) { // miss, add\n+            cached = new String(val, start, count);\n+            cache[index] = cached;\n+        } else { // hashcode hit, check equality\n+            if (rangeEquals(start, count, cached)) {\n+                // hit\n+                return cached;\n+            } else { // hashcode conflict\n+                cached = new String(val, start, count);\n+            }\n+        }\n+        return cached;\n+    }\n+\n+    /**\n+     * Check if the value of the provided range equals the string.\n+     */\n+    boolean rangeEquals(final int start, int count, final String cached) {\n+        if (count == cached.length()) {\n+            char one[] = input;\n+            int i = start;\n+            int j = 0;\n+            while (count-- != 0) {\n+                if (one[i++] != cached.charAt(j++))\n+                    return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n import org.jsoup.select.Elements;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n import java.util.List;\n \n /**\n     private Element headElement; // the current head element\n     private FormElement formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n-    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n+    private ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\n+    private List<String> pendingTableCharacters = new ArrayList<String>(); // chars in table to be shifted out\n+    private Token.EndTag emptyEnd = new Token.EndTag(); // reused empty end tag\n \n     private boolean framesetOk = true; // if ok to go into frameset\n     private boolean fosterInserts = false; // if next inserts should be fostered\n \n             root = new Element(Tag.valueOf(\"html\"), baseUri);\n             doc.appendChild(root);\n-            stack.push(root);\n+            stack.add(root);\n             resetInsertionMode();\n \n             // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n             Element el = insertEmpty(startTag);\n             stack.add(el);\n             tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\n-            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n+            tokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n         \n         return el;\n     }\n \n-    Element insert(String startTagName) {\n+    Element insertStartTag(String startTagName) {\n         Element el = new Element(Tag.valueOf(startTagName), baseUri);\n         insert(el);\n         return el;\n     }\n \n     Element pop() {\n-        // todo - dev, remove validation check\n-        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n-            Validate.isFalse(true, \"pop td not in cell\");\n-        if (stack.peekLast().nodeName().equals(\"html\"))\n-            Validate.isFalse(true, \"popping html!\");\n-        return stack.pollLast();\n+        int size = stack.size();\n+        return stack.remove(size-1);\n     }\n \n     void push(Element element) {\n         stack.add(element);\n     }\n \n-    DescendableLinkedList<Element> getStack() {\n+    ArrayList<Element> getStack() {\n         return stack;\n     }\n \n         return isElementInQueue(stack, el);\n     }\n \n-    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n-        Iterator<Element> it = queue.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n+        for (int pos = queue.size() -1; pos >= 0; pos--) {\n+            Element next = queue.get(pos);\n             if (next == element) {\n                 return true;\n             }\n     }\n \n     Element getFromStack(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 return next;\n             }\n     }\n \n     boolean removeFromStack(Element el) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                it.remove();\n+                stack.remove(pos);\n                 return true;\n             }\n         }\n     }\n \n     void popStackToClose(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next.nodeName().equals(elName))\n+                break;\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (StringUtil.in(next.nodeName(), elNames))\n+                break;\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n-                it.remove();\n                 break;\n             } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToClose(String... elNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (StringUtil.in(next.nodeName(), elNames)) {\n-                it.remove();\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToBefore(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                break;\n-            } else {\n-                it.remove();\n+                stack.remove(pos);\n             }\n         }\n     }\n     }\n \n     private void clearStackToContext(String... nodeNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                 break;\n             else\n-                it.remove();\n+                stack.remove(pos);\n         }\n     }\n \n     Element aboveOnStack(Element el) {\n         assert onStack(el);\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                return it.next();\n+                return stack.get(pos-1);\n             }\n         }\n         return null;\n         replaceInQueue(stack, out, in);\n     }\n \n-    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n         int i = queue.lastIndexOf(out);\n         Validate.isTrue(i != -1);\n-        queue.remove(i);\n-        queue.add(i, in);\n+        queue.set(i, in);\n     }\n \n     void resetInsertionMode() {\n         boolean last = false;\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element node = it.next();\n-            if (!it.hasNext()) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element node = stack.get(pos);\n+            if (pos == 0) {\n                 last = true;\n                 node = contextElement;\n             }\n     }\n \n     // todo: tidy up in specific scope methods\n+    private String[] specificScopeTarget = {null};\n+\n     private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n-        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n+        specificScopeTarget[0] = targetName;\n+        return inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n     }\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (StringUtil.in(elName, targetNames))\n                 return true;\n     }\n \n     boolean inScope(String targetName, String[] extras) {\n-        return inSpecificScope(targetName, TagsSearchInScope , extras);\n+        return inSpecificScope(targetName, TagsSearchInScope, extras);\n         // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n         // todo: in svg namespace: forignOjbect, desc, title\n     }\n     }\n \n     boolean inSelectScope(String targetName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (elName.equals(targetName))\n                 return true;\n     }\n \n     void newPendingTableCharacters() {\n-        pendingTableCharacters = new ArrayList<Token.Character>();\n-    }\n-\n-    List<Token.Character> getPendingTableCharacters() {\n+        pendingTableCharacters = new ArrayList<String>();\n+    }\n+\n+    List<String> getPendingTableCharacters() {\n         return pendingTableCharacters;\n     }\n \n-    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n+    void setPendingTableCharacters(List<String> pendingTableCharacters) {\n         this.pendingTableCharacters = pendingTableCharacters;\n     }\n \n         return StringUtil.in(name, TagSearchSpecial);\n     }\n \n+    Element lastFormattingElement() {\n+        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n+    }\n+\n+    Element removeLastFormattingElement() {\n+        int size = formattingElements.size();\n+        if (size > 0)\n+            return formattingElements.remove(size-1);\n+        else\n+            return null;\n+    }\n+\n     // active formatting elements\n     void pushActiveFormattingElements(Element in) {\n         int numSeen = 0;\n-        Iterator<Element> iter = formattingElements.descendingIterator();\n-        while (iter.hasNext()) {\n-            Element el =  iter.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element el = formattingElements.get(pos);\n             if (el == null) // marker\n                 break;\n \n                 numSeen++;\n \n             if (numSeen == 3) {\n-                iter.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     void reconstructFormattingElements() {\n+        Element last = lastFormattingElement();\n+        if (last == null || onStack(last))\n+            return;\n+\n+        Element entry = last;\n         int size = formattingElements.size();\n-        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n-            return;\n-\n-        Element entry = formattingElements.getLast();\n         int pos = size - 1;\n         boolean skip = false;\n         while (true) {\n \n             // 8. create new element from element, 9 insert into current node, onto stack\n             skip = false; // can only skip increment from 4.\n-            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n+            Element newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n             // newEl.namespace(entry.namespace()); // todo: namespaces\n             newEl.attributes().addAll(entry.attributes());\n \n             // 10. replace entry with new entry\n-            formattingElements.add(pos, newEl);\n-            formattingElements.remove(pos + 1);\n+            formattingElements.set(pos, newEl);\n \n             // 11\n             if (pos == size-1) // if not last entry in list, jump to 7\n \n     void clearFormattingElementsToLastMarker() {\n         while (!formattingElements.isEmpty()) {\n-            Element el = formattingElements.peekLast();\n-            formattingElements.removeLast();\n+            Element el = removeLastFormattingElement();\n             if (el == null)\n                 break;\n         }\n     }\n \n     void removeFromActiveFormattingElements(Element el) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == el) {\n-                it.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     Element getActiveFormattingElement(String nodeName) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == null) // scope marker\n                 break;\n             else if (next.nodeName().equals(nodeName))\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n \n /**\n  * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n         }\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n-            tb.insert(\"html\");\n+            tb.insertStartTag(\"html\");\n             tb.transition(BeforeHead);\n             return tb.process(t);\n         }\n                 tb.setHeadElement(head);\n                 tb.transition(InHead);\n             } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n-                tb.process(new Token.StartTag(\"head\"));\n+                tb.processStartTag(\"head\");\n                 return tb.process(t);\n             } else if (t.isEndTag()) {\n                 tb.error(this);\n                 return false;\n             } else {\n-                tb.process(new Token.StartTag(\"head\"));\n+                tb.processStartTag(\"head\");\n                 return tb.process(t);\n             }\n             return true;\n         }\n \n         private boolean anythingElse(Token t, TreeBuilder tb) {\n-            tb.process(new Token.EndTag(\"head\"));\n+            tb.processEndTag(\"head\");\n             return tb.process(t);\n         }\n     },\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            tb.process(new Token.EndTag(\"noscript\"));\n+            tb.processEndTag(\"noscript\");\n             return tb.process(t);\n         }\n     },\n         }\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n-            tb.process(new Token.StartTag(\"body\"));\n+            tb.processStartTag(\"body\");\n             tb.framesetOk(true);\n             return tb.process(t);\n         }\n                     if (name.equals(\"html\")) {\n                         tb.error(this);\n                         // merge attributes onto real html\n-                        Element html = tb.getStack().getFirst();\n+                        Element html = tb.getStack().get(0);\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                         }\n                     } else if (name.equals(\"frameset\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                                 second.remove();\n                             // pop up to html element\n                             while (stack.size() > 1)\n-                                stack.removeLast();\n+                                stack.remove(stack.size()-1);\n                             tb.insert(startTag);\n                             tb.transition(InFrameset);\n                         }\n                     } else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.Headings)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         if (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\n                             tb.error(this);\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         // todo: ignore LF if next token\n                             return false;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insertForm(startTag, true);\n                     } else if (name.equals(\"li\")) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (el.nodeName().equals(\"li\")) {\n-                                tb.process(new Token.EndTag(\"li\"));\n+                                tb.processEndTag(\"li\");\n                                 break;\n                             }\n                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.DdDt)) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n-                                tb.process(new Token.EndTag(el.nodeName()));\n+                                tb.processEndTag(el.nodeName());\n                                 break;\n                             }\n                             if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\n                                 break;\n                         }\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                     } else if (name.equals(\"plaintext\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n                         if (tb.inButtonScope(\"button\")) {\n                             // close and reprocess\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"button\"));\n+                            tb.processEndTag(\"button\");\n                             tb.process(startTag);\n                         } else {\n                             tb.reconstructFormattingElements();\n                     } else if (name.equals(\"a\")) {\n                         if (tb.getActiveFormattingElement(\"a\") != null) {\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"a\"));\n+                            tb.processEndTag(\"a\");\n \n                             // still on stack?\n                             Element remainingA = tb.getFromStack(\"a\");\n                         tb.reconstructFormattingElements();\n                         if (tb.inScope(\"nobr\")) {\n                             tb.error(this);\n-                            tb.process(new Token.EndTag(\"nobr\"));\n+                            tb.processEndTag(\"nobr\");\n                             tb.reconstructFormattingElements();\n                         }\n                         Element el = tb.insert(startTag);\n                         tb.framesetOk(false);\n                     } else if (name.equals(\"table\")) {\n                         if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insert(startTag);\n                         tb.framesetOk(false);\n                         tb.insertEmpty(startTag);\n                     } else if (name.equals(\"hr\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.insertEmpty(startTag);\n                         tb.framesetOk(false);\n                             return false;\n \n                         tb.tokeniser.acknowledgeSelfClosingFlag();\n-                        tb.process(new Token.StartTag(\"form\"));\n+                        tb.processStartTag(\"form\");\n                         if (startTag.attributes.hasKey(\"action\")) {\n                             Element form = tb.getFormElement();\n                             form.attr(\"action\", startTag.attributes.get(\"action\"));\n                         }\n-                        tb.process(new Token.StartTag(\"hr\"));\n-                        tb.process(new Token.StartTag(\"label\"));\n+                        tb.processStartTag(\"hr\");\n+                        tb.processStartTag(\"label\");\n                         // hope you like english.\n                         String prompt = startTag.attributes.hasKey(\"prompt\") ?\n                                 startTag.attributes.get(\"prompt\") :\n                                 \"This is a searchable index. Enter search keywords: \";\n \n-                        tb.process(new Token.Character(prompt));\n+                        tb.process(new Token.Character().data(prompt));\n \n                         // input\n                         Attributes inputAttribs = new Attributes();\n                                 inputAttribs.put(attr);\n                         }\n                         inputAttribs.put(\"name\", \"isindex\");\n-                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n-                        tb.process(new Token.EndTag(\"label\"));\n-                        tb.process(new Token.StartTag(\"hr\"));\n-                        tb.process(new Token.EndTag(\"form\"));\n+                        tb.processStartTag(\"input\", inputAttribs);\n+                        tb.processEndTag(\"label\");\n+                        tb.processStartTag(\"hr\");\n+                        tb.processEndTag(\"form\");\n                     } else if (name.equals(\"textarea\")) {\n                         tb.insert(startTag);\n                         // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n                         tb.transition(Text);\n                     } else if (name.equals(\"xmp\")) {\n                         if (tb.inButtonScope(\"p\")) {\n-                            tb.process(new Token.EndTag(\"p\"));\n+                            tb.processEndTag(\"p\");\n                         }\n                         tb.reconstructFormattingElements();\n                         tb.framesetOk(false);\n                             tb.transition(InSelect);\n                     } else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         tb.reconstructFormattingElements();\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\n                             tb.transition(AfterBody);\n                         }\n                     } else if (name.equals(\"html\")) {\n-                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n+                        boolean notIgnored = tb.processEndTag(\"body\");\n                         if (notIgnored)\n                             return tb.process(endTag);\n                     } else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\n                     } else if (name.equals(\"p\")) {\n                         if (!tb.inButtonScope(name)) {\n                             tb.error(this);\n-                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n+                            tb.processStartTag(name); // if no p to close, creates an empty <p></p>\n                             return tb.process(endTag);\n                         } else {\n                             tb.generateImpliedEndTags(name);\n                             Element furthestBlock = null;\n                             Element commonAncestor = null;\n                             boolean seenFormattingElement = false;\n-                            LinkedList<Element> stack = tb.getStack();\n+                            ArrayList<Element> stack = tb.getStack();\n                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                             // run-aways\n                             final int stackSize = stack.size();\n                         }\n                     } else if (name.equals(\"br\")) {\n                         tb.error(this);\n-                        tb.process(new Token.StartTag(\"br\"));\n+                        tb.processStartTag(\"br\");\n                         return false;\n                     } else {\n                         return anyOtherEndTag(t, tb);\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n             String name = t.asEndTag().name();\n-            DescendableLinkedList<Element> stack = tb.getStack();\n-            Iterator<Element> it = stack.descendingIterator();\n-            while (it.hasNext()) {\n-                Element node = it.next();\n+            ArrayList<Element> stack = tb.getStack();\n+            for (int pos = stack.size() -1; pos >= 0; pos--) {\n+                Element node = stack.get(pos);\n                 if (node.nodeName().equals(name)) {\n                     tb.generateImpliedEndTags(name);\n                     if (!name.equals(tb.currentElement().nodeName()))\n                     tb.insert(startTag);\n                     tb.transition(InColumnGroup);\n                 } else if (name.equals(\"col\")) {\n-                    tb.process(new Token.StartTag(\"colgroup\"));\n+                    tb.processStartTag(\"colgroup\");\n                     return tb.process(t);\n                 } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n                     tb.clearStackToTableContext();\n                     tb.insert(startTag);\n                     tb.transition(InTableBody);\n                 } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n-                    tb.process(new Token.StartTag(\"tbody\"));\n+                    tb.processStartTag(\"tbody\");\n                     return tb.process(t);\n                 } else if (name.equals(\"table\")) {\n                     tb.error(this);\n-                    boolean processed = tb.process(new Token.EndTag(\"table\"));\n+                    boolean processed = tb.processEndTag(\"table\");\n                     if (processed) // only ignored if in fragment\n                         return tb.process(t);\n                 } else if (StringUtil.in(name, \"style\", \"script\")) {\n                         tb.error(this);\n                         return false;\n                     } else {\n-                        tb.getPendingTableCharacters().add(c);\n+                        tb.getPendingTableCharacters().add(c.getData());\n                     }\n                     break;\n                 default:\n+                    // todo - don't really like the way these table character data lists are built\n                     if (tb.getPendingTableCharacters().size() > 0) {\n-                        for (Token.Character character : tb.getPendingTableCharacters()) {\n+                        for (String character : tb.getPendingTableCharacters()) {\n                             if (!isWhitespace(character)) {\n                                 // InTable anything else section:\n                                 tb.error(this);\n                                 if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                                     tb.setFosterInserts(true);\n-                                    tb.process(character, InBody);\n+                                    tb.process(new Token.Character().data(character), InBody);\n                                     tb.setFosterInserts(false);\n                                 } else {\n-                                    tb.process(character, InBody);\n+                                    tb.process(new Token.Character().data(character), InBody);\n                                 }\n                             } else\n-                                tb.insert(character);\n+                                tb.insert(new Token.Character().data(character));\n                         }\n                         tb.newPendingTableCharacters();\n                     }\n                             t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n                     ) {\n                 tb.error(this);\n-                boolean processed = tb.process(new Token.EndTag(\"caption\"));\n+                boolean processed = tb.processEndTag(\"caption\");\n                 if (processed)\n                     return tb.process(t);\n             } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n         }\n \n         private boolean anythingElse(Token t, TreeBuilder tb) {\n-            boolean processed = tb.process(new Token.EndTag(\"colgroup\"));\n+            boolean processed = tb.processEndTag(\"colgroup\");\n             if (processed) // only ignored in frag case\n                 return tb.process(t);\n             return true;\n                         tb.transition(InRow);\n                     } else if (StringUtil.in(name, \"th\", \"td\")) {\n                         tb.error(this);\n-                        tb.process(new Token.StartTag(\"tr\"));\n+                        tb.processStartTag(\"tr\");\n                         return tb.process(startTag);\n                     } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n                         return exitTableBody(t, tb);\n                 return false;\n             }\n             tb.clearStackToTableBodyContext();\n-            tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead\n+            tb.processEndTag(tb.currentElement().nodeName()); // tbody, tfoot, thead\n             return tb.process(t);\n         }\n \n                         tb.error(this);\n                         return false;\n                     }\n-                    tb.process(new Token.EndTag(\"tr\"));\n+                    tb.processEndTag(\"tr\");\n                     return tb.process(t);\n                 } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n                     tb.error(this);\n         }\n \n         private boolean handleMissingTr(Token t, TreeBuilder tb) {\n-            boolean processed = tb.process(new Token.EndTag(\"tr\"));\n+            boolean processed = tb.processEndTag(\"tr\");\n             if (processed)\n                 return tb.process(t);\n             else\n \n         private void closeCell(HtmlTreeBuilder tb) {\n             if (tb.inTableScope(\"td\"))\n-                tb.process(new Token.EndTag(\"td\"));\n+                tb.processEndTag(\"td\");\n             else\n-                tb.process(new Token.EndTag(\"th\")); // only here if th or td in scope\n+                tb.processEndTag(\"th\"); // only here if th or td in scope\n         }\n     },\n     InSelect {\n                     if (name.equals(\"html\"))\n                         return tb.process(start, InBody);\n                     else if (name.equals(\"option\")) {\n-                        tb.process(new Token.EndTag(\"option\"));\n+                        tb.processEndTag(\"option\");\n                         tb.insert(start);\n                     } else if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n-                            tb.process(new Token.EndTag(\"optgroup\"));\n+                            tb.processEndTag(\"optgroup\");\n                         tb.insert(start);\n                     } else if (name.equals(\"select\")) {\n                         tb.error(this);\n-                        return tb.process(new Token.EndTag(\"select\"));\n+                        return tb.processEndTag(\"select\");\n                     } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n                         tb.error(this);\n                         if (!tb.inSelectScope(\"select\"))\n                             return false; // frag\n-                        tb.process(new Token.EndTag(\"select\"));\n+                        tb.processEndTag(\"select\");\n                         return tb.process(start);\n                     } else if (name.equals(\"script\")) {\n                         return tb.process(t, InHead);\n                     name = end.name();\n                     if (name.equals(\"optgroup\")) {\n                         if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n-                            tb.process(new Token.EndTag(\"option\"));\n+                            tb.processEndTag(\"option\");\n                         if (tb.currentElement().nodeName().equals(\"optgroup\"))\n                             tb.pop();\n                         else\n         boolean process(Token t, HtmlTreeBuilder tb) {\n             if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n-                tb.process(new Token.EndTag(\"select\"));\n+                tb.processEndTag(\"select\");\n                 return tb.process(t);\n             } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n                 tb.error(this);\n                 if (tb.inTableScope(t.asEndTag().name())) {\n-                    tb.process(new Token.EndTag(\"select\"));\n+                    tb.processEndTag(\"select\");\n                     return (tb.process(t));\n                 } else\n                     return false;\n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n             String data = t.asCharacter().getData();\n-            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n-            for (int i = 0; i < data.length(); i++) {\n-                char c = data.charAt(i);\n-                if (!StringUtil.isWhitespace(c))\n-                    return false;\n-            }\n-            return true;\n+            return isWhitespace(data);\n         }\n         return false;\n+    }\n+\n+    private static boolean isWhitespace(String data) {\n+        // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n+        for (int i = 0; i < data.length(); i++) {\n+            char c = data.charAt(i);\n+            if (!StringUtil.isWhitespace(c))\n+                return false;\n+        }\n+        return true;\n     }\n \n     private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         return this.getClass().getSimpleName();\n     }\n \n-    static class Doctype extends Token {\n+    /**\n+     * Reset the data represent by this token, for reuse. Prevents the need to create transfer objects for every\n+     * piece of data, which immediately get GCed.\n+     */\n+    abstract Token reset();\n+\n+    static void reset(StringBuilder sb) {\n+        if (sb != null) {\n+            sb.delete(0, sb.length());\n+        }\n+    }\n+\n+    static final class Doctype extends Token {\n         final StringBuilder name = new StringBuilder();\n         final StringBuilder publicIdentifier = new StringBuilder();\n         final StringBuilder systemIdentifier = new StringBuilder();\n             type = TokenType.Doctype;\n         }\n \n+        @Override\n+        Token reset() {\n+            reset(name);\n+            reset(publicIdentifier);\n+            reset(systemIdentifier);\n+            forceQuirks = false;\n+            return this;\n+        }\n+\n         String getName() {\n             return name.toString();\n         }\n     static abstract class Tag extends Token {\n         protected String tagName;\n         private String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\n-        private StringBuilder pendingAttributeValue; // but values are accumulated, from e.g. & in hrefs\n-\n+        private StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\n+        private boolean hasPendingAttributeValue = false;\n         boolean selfClosing = false;\n         Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n \n-        void newAttribute() {\n+        @Override\n+        Tag reset() {\n+            tagName = null;\n+            pendingAttributeName = null;\n+            reset(pendingAttributeValue);\n+            hasPendingAttributeValue = false;\n+            selfClosing = false;\n+            attributes = null;\n+            return this;\n+        }\n+\n+        final void newAttribute() {\n             if (attributes == null)\n                 attributes = new Attributes();\n \n             if (pendingAttributeName != null) {\n                 Attribute attribute;\n-                if (pendingAttributeValue == null)\n+                if (!hasPendingAttributeValue)\n                     attribute = new Attribute(pendingAttributeName, \"\");\n                 else\n                     attribute = new Attribute(pendingAttributeName, pendingAttributeValue.toString());\n                 attributes.put(attribute);\n             }\n             pendingAttributeName = null;\n-            if (pendingAttributeValue != null)\n-                pendingAttributeValue.delete(0, pendingAttributeValue.length());\n-        }\n-\n-        void finaliseTag() {\n+            reset(pendingAttributeValue);\n+        }\n+\n+        final void finaliseTag() {\n             // finalises for emit\n             if (pendingAttributeName != null) {\n                 // todo: check if attribute name exists; if so, drop and error\n             }\n         }\n \n-        String name() {\n+        final String name() {\n             Validate.isFalse(tagName == null || tagName.length() == 0);\n             return tagName;\n         }\n \n-        Tag name(String name) {\n+        final Tag name(String name) {\n             tagName = name;\n             return this;\n         }\n \n-        boolean isSelfClosing() {\n+        final boolean isSelfClosing() {\n             return selfClosing;\n         }\n \n         @SuppressWarnings({\"TypeMayBeWeakened\"})\n-        Attributes getAttributes() {\n+        final Attributes getAttributes() {\n             return attributes;\n         }\n \n         // these appenders are rarely hit in not null state-- caused by null chars.\n-        void appendTagName(String append) {\n+        final void appendTagName(String append) {\n             tagName = tagName == null ? append : tagName.concat(append);\n         }\n \n-        void appendTagName(char append) {\n+        final void appendTagName(char append) {\n             appendTagName(String.valueOf(append));\n         }\n \n-        void appendAttributeName(String append) {\n+        final void appendAttributeName(String append) {\n             pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n         }\n \n-        void appendAttributeName(char append) {\n+        final void appendAttributeName(char append) {\n             appendAttributeName(String.valueOf(append));\n         }\n \n-        void appendAttributeValue(String append) {\n+        final void appendAttributeValue(String append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        void appendAttributeValue(char append) {\n+        final void appendAttributeValue(char append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        void appendAttributeValue(char[] append) {\n+        final void appendAttributeValue(char[] append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        private final void ensureAttributeValue() {\n-            if (pendingAttributeValue == null)\n-                pendingAttributeValue = new StringBuilder();\n-        }\n-    }\n-\n-    static class StartTag extends Tag {\n+        private void ensureAttributeValue() {\n+            hasPendingAttributeValue = true;\n+        }\n+    }\n+\n+    final static class StartTag extends Tag {\n         StartTag() {\n             super();\n             attributes = new Attributes();\n             type = TokenType.StartTag;\n         }\n \n-        StartTag(String name) {\n-            this();\n-            this.tagName = name;\n-        }\n-\n-        StartTag(String name, Attributes attributes) {\n-            this();\n+        @Override\n+        Tag reset() {\n+            super.reset();\n+            attributes = new Attributes();\n+            // todo - would prefer these to be null, but need to check Element assertions\n+            return this;\n+        }\n+\n+        StartTag nameAttr(String name, Attributes attributes) {\n             this.tagName = name;\n             this.attributes = attributes;\n+            return this;\n         }\n \n         @Override\n         }\n     }\n \n-    static class EndTag extends Tag{\n+    final static class EndTag extends Tag{\n         EndTag() {\n             super();\n             type = TokenType.EndTag;\n         }\n \n-        EndTag(String name) {\n-            this();\n-            this.tagName = name;\n-        }\n-\n         @Override\n         public String toString() {\n             return \"</\" + name() + \">\";\n         }\n     }\n \n-    static class Comment extends Token {\n+    final static class Comment extends Token {\n         final StringBuilder data = new StringBuilder();\n         boolean bogus = false;\n \n+        @Override\n+        Token reset() {\n+            reset(data);\n+            bogus = false;\n+            return this;\n+        }\n+\n         Comment() {\n             type = TokenType.Comment;\n         }\n         }\n     }\n \n-    static class Character extends Token {\n-        private final String data;\n-\n-        Character(String data) {\n+    final static class Character extends Token {\n+        private String data;\n+\n+        Character() {\n+            super();\n             type = TokenType.Character;\n+        }\n+\n+        @Override\n+        Token reset() {\n+            data = null;\n+            return this;\n+        }\n+\n+        Character data(String data) {\n             this.data = data;\n+            return this;\n         }\n \n         String getData() {\n         }\n     }\n \n-    static class EOF extends Token {\n+    final static class EOF extends Token {\n         EOF() {\n             type = Token.TokenType.EOF;\n         }\n-    }\n-\n-    boolean isDoctype() {\n+\n+        @Override\n+        Token reset() {\n+            return this;\n+        }\n+    }\n+\n+    final boolean isDoctype() {\n         return type == TokenType.Doctype;\n     }\n \n-    Doctype asDoctype() {\n+    final Doctype asDoctype() {\n         return (Doctype) this;\n     }\n \n-    boolean isStartTag() {\n+    final boolean isStartTag() {\n         return type == TokenType.StartTag;\n     }\n \n-    StartTag asStartTag() {\n+    final StartTag asStartTag() {\n         return (StartTag) this;\n     }\n \n-    boolean isEndTag() {\n+    final boolean isEndTag() {\n         return type == TokenType.EndTag;\n     }\n \n-    EndTag asEndTag() {\n+    final EndTag asEndTag() {\n         return (EndTag) this;\n     }\n \n-    boolean isComment() {\n+    final boolean isComment() {\n         return type == TokenType.Comment;\n     }\n \n-    Comment asComment() {\n+    final Comment asComment() {\n         return (Comment) this;\n     }\n \n-    boolean isCharacter() {\n+    final boolean isCharacter() {\n         return type == TokenType.Character;\n     }\n \n-    Character asCharacter() {\n+    final Character asCharacter() {\n         return (Character) this;\n     }\n \n-    boolean isEOF() {\n+    final boolean isEOF() {\n         return type == TokenType.EOF;\n     }\n \n-    enum TokenType {\n+    static enum TokenType {\n         Doctype,\n         StartTag,\n         EndTag,\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Entities;\n \n+import java.util.Arrays;\n \n /**\n  * Readers the input stream into tokens.\n  */\n-class Tokeniser {\n+final class Tokeniser {\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n+    private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};\n+\n+    static {\n+        Arrays.sort(notCharRefCharsSorted);\n+    }\n \n     private CharacterReader reader; // html input\n     private ParseErrorList errors; // errors found while tokenising\n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private boolean isEmitPending = false;\n-    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n-    StringBuilder dataBuffer; // buffers data looking for </script>\n+    private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\n+    private StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\n+    StringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\n \n     Token.Tag tagPending; // tag we are building up\n-    Token.Doctype doctypePending; // doctype building up\n-    Token.Comment commentPending; // comment building up\n-    private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n+    Token.StartTag startPending = new Token.StartTag();\n+    Token.EndTag endPending = new Token.EndTag();\n+    Token.Character charPending = new Token.Character();\n+    Token.Doctype doctypePending = new Token.Doctype(); // doctype building up\n+    Token.Comment commentPending = new Token.Comment(); // comment building up\n+    private String lastStartTag; // the last start tag emitted, to test appropriate end tag\n     private boolean selfClosingFlagAcknowledged = true;\n \n     Tokeniser(CharacterReader reader, ParseErrorList errors) {\n             state.read(this, reader);\n \n         // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n-        if (charBuffer.length() > 0) {\n-            String str = charBuffer.toString();\n-            charBuffer.delete(0, charBuffer.length());\n-            return new Token.Character(str);\n+        if (charsBuilder.length() > 0) {\n+            String str = charsBuilder.toString();\n+            charsBuilder.delete(0, charsBuilder.length());\n+            charsString = null;\n+            return charPending.data(str);\n+        } else if (charsString != null) {\n+            Token token = charPending.data(charsString);\n+            charsString = null;\n+            return token;\n         } else {\n             isEmitPending = false;\n             return emitPending;\n \n         if (token.type == Token.TokenType.StartTag) {\n             Token.StartTag startTag = (Token.StartTag) token;\n-            lastStartTag = startTag;\n+            lastStartTag = startTag.tagName;\n             if (startTag.selfClosing)\n                 selfClosingFlagAcknowledged = false;\n         } else if (token.type == Token.TokenType.EndTag) {\n         }\n     }\n \n-    void emit(String str) {\n+    void emit(final String str) {\n         // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n         // does not set isEmitPending; read checks that\n-        charBuffer.append(str);\n+        if (charsString == null) {\n+            charsString = str;\n+        }\n+        else {\n+            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n+                charsBuilder.append(charsString);\n+            }\n+            charsBuilder.append(str);\n+        }\n     }\n \n     void emit(char[] chars) {\n-        charBuffer.append(chars);\n+        emit(String.valueOf(chars));\n     }\n \n     void emit(char c) {\n-        charBuffer.append(c);\n+        emit(String.valueOf(c));\n     }\n \n     TokeniserState getState() {\n         selfClosingFlagAcknowledged = true;\n     }\n \n+    final private char[] charRefHolder = new char[1]; // holder to not have to keep creating arrays\n     char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             return null;\n-        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n-            return null;\n-\n+        if (reader.matchesAnySorted(notCharRefCharsSorted))\n+            return null;\n+\n+        final char[] charRef = charRefHolder;\n         reader.mark();\n         if (reader.matchConsume(\"#\")) { // numbered\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                return new char[]{replacementChar};\n+                charRef[0] = replacementChar;\n+                return charRef;\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n+                if (charval < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n+                    charRef[0] = (char) charval;\n+                    return charRef;\n+                } else\n                 return Character.toChars(charval);\n             }\n         } else { // named\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            return new char[]{Entities.getCharacterByName(nameRef)};\n+            charRef[0] = Entities.getCharacterByName(nameRef);\n+            return charRef;\n         }\n     }\n \n     Token.Tag createTagPending(boolean start) {\n-        tagPending = start ? new Token.StartTag() : new Token.EndTag();\n+        tagPending = start ? startPending.reset() : endPending.reset();\n         return tagPending;\n     }\n \n     }\n \n     void createCommentPending() {\n-        commentPending = new Token.Comment();\n+        commentPending.reset();\n     }\n \n     void emitCommentPending() {\n     }\n \n     void createDoctypePending() {\n-        doctypePending = new Token.Doctype();\n+        doctypePending.reset();\n     }\n \n     void emitDoctypePending() {\n     }\n \n     void createTempBuffer() {\n-        dataBuffer = new StringBuilder();\n+        Token.reset(dataBuffer);\n     }\n \n     boolean isAppropriateEndTagToken() {\n-        if (lastStartTag == null)\n-            return false;\n-        return tagPending.tagName.equals(lastStartTag.tagName);\n+        return lastStartTag != null && tagPending.tagName.equals(lastStartTag);\n     }\n \n     String appropriateEndTagName() {\n         if (lastStartTag == null)\n             return null;\n-        return lastStartTag.tagName;\n+        return lastStartTag;\n     }\n \n     void error(TokeniserState state) {\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n package org.jsoup.parser;\n+\n+import java.util.Arrays;\n \n /**\n  * States and transition activations for the Tokeniser.\n                     t.emit(new Token.EOF());\n                     break;\n                 default:\n-                    String data = r.consumeToAny('&', '<', nullChar);\n+                    String data = r.consumeData();\n                     t.emit(data);\n                     break;\n             }\n         // from < or </ in data, will have start or end tag pending\n         void read(Tokeniser t, CharacterReader r) {\n             // previous TagOpen state did NOT consume, will have a letter char in current\n-            String tagName = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n+            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+            String tagName = r.consumeTagName().toLowerCase();\n             t.tagPending.appendTagName(tagName);\n \n             switch (r.consume()) {\n             } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                 // diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n                 // consuming to EOF; break out here\n-                t.tagPending = new Token.EndTag(t.appropriateEndTagName());\n+                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                 t.emitTagPending();\n                 r.unconsume(); // undo \"<\"\n                 t.transition(Data);\n     AttributeName {\n         // from before attribute name\n         void read(Tokeniser t, CharacterReader r) {\n-            String name = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<');\n+            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n             t.tagPending.appendAttributeName(name.toLowerCase());\n \n             char c = r.consume();\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\"', '&', nullChar);\n+            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\'', '&', nullChar);\n+            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n \n     abstract void read(Tokeniser t, CharacterReader r);\n \n-    private static final char nullChar = '\\u0000';\n+    static final char nullChar = '\\u0000';\n+    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n+    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n+    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n+\n+    static {\n+        Arrays.sort(attributeSingleValueCharsSorted);\n+        Arrays.sort(attributeDoubleValueCharsSorted);\n+        Arrays.sort(attributeNameCharsSorted);\n+    }\n \n     /**\n      * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n      * different else exit transitions.\n      */\n-    private static final void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n+    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.tagPending.appendTagName(name.toLowerCase());\n         }\n     }\n \n-    private static final void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n+    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.dataBuffer.append(name.toLowerCase());\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n+import java.util.ArrayList;\n \n /**\n  * @author Jonathan Hedley\n     CharacterReader reader;\n     Tokeniser tokeniser;\n     protected Document doc; // current doc we are building into\n-    protected DescendableLinkedList<Element> stack; // the stack of open elements\n+    protected ArrayList<Element> stack; // the stack of open elements\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n+\n+    private Token.StartTag start = new Token.StartTag(); // start tag to process\n+    private Token.EndTag end  = new Token.EndTag();\n \n     protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n         Validate.notNull(input, \"String input must not be null\");\n         reader = new CharacterReader(input);\n         this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n-        stack = new DescendableLinkedList<Element>();\n+        stack = new ArrayList<Element>(32);\n         this.baseUri = baseUri;\n     }\n \n         while (true) {\n             Token token = tokeniser.read();\n             process(token);\n+            token.reset();\n \n             if (token.type == Token.TokenType.EOF)\n                 break;\n \n     protected abstract boolean process(Token token);\n \n+    protected boolean processStartTag(String name) {\n+        return process(start.reset().name(name));\n+    }\n+\n+    public boolean processStartTag(String name, Attributes attrs) {\n+        start.reset();\n+        start.nameAttr(name, attrs);\n+        return process(start);\n+    }\n+\n+    protected boolean processEndTag(String name) {\n+        return process(end.reset().name(name));\n+    }\n+\n+\n     protected Element currentElement() {\n-        return stack.getLast();\n+        int size = stack.size();\n+        return size > 0 ? stack.get(size-1) : null;\n     }\n }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n import java.util.List;\n \n /**\n         String elName = endTag.name();\n         Element firstFound = null;\n \n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 firstFound = next;\n                 break;\n         if (firstFound == null)\n             return; // not found, skip\n \n-        it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == firstFound) {\n-                it.remove();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next == firstFound)\n                 break;\n-            } else {\n-                it.remove();\n-            }\n         }\n     }\n \n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertFalse(r.matchesAny(scan));\n     }\n \n+    @Test public void cachesStrings() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\\tA string that is longer than 16 chars\");\n+        String one = r.consumeTo('\\t');\n+        r.consume();\n+        String two = r.consumeTo('\\t');\n+        r.consume();\n+        String three = r.consumeTo('\\t');\n+        r.consume();\n+        String four = r.consumeTo('\\t');\n+        r.consume();\n+        String five = r.consumeTo('\\t');\n+\n+        assertEquals(\"Check\", one);\n+        assertEquals(\"Check\", two);\n+        assertEquals(\"Check\", three);\n+        assertEquals(\"CHOKE\", four);\n+        assertTrue(one == two);\n+        assertTrue(two == three);\n+        assertTrue(three != four);\n+        assertTrue(four != five);\n+        assertEquals(five, \"A string that is longer than 16 chars\");\n+    }\n+\n+    @Test\n+    public void rangeEquals() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\");\n+        assertTrue(r.rangeEquals(0, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(0, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(0, 5, \"Chec\"));\n+\n+        assertTrue(r.rangeEquals(6, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(6, 5, \"Chuck\"));\n+\n+        assertTrue(r.rangeEquals(12, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(12, 5, \"Cheeky\"));\n+\n+        assertTrue(r.rangeEquals(18, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(18, 5, \"CHIKE\"));\n+    }\n+\n+\n }", "timestamp": 1414560948, "metainfo": ""}