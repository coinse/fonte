{"sha": "e9909538549c96800dad1e94284b99575d1be628", "log": "Working parser except the root node selector. Added basic tests", "commit": "\n--- a/src/main/java/org/jsoup/select/ng/parser/Parser.java\n+++ b/src/main/java/org/jsoup/select/ng/parser/Parser.java\n import java.util.List;\n import java.util.regex.Pattern;\n \n+import org.jsoup.Jsoup;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Evaluator;\n import org.jsoup.parser.TokenQueue;\n import org.jsoup.select.ng.AndSelector;\n import org.jsoup.select.ng.BasicSelector;\n import org.jsoup.select.ng.ElementContainerSelector;\n+import org.jsoup.select.ng.HasSelector;\n+import org.jsoup.select.ng.ImmediateParentSelector;\n+import org.jsoup.select.ng.NotSelector;\n+import org.jsoup.select.ng.OrSelector;\n import org.jsoup.select.ng.ParentSelector;\n+import org.jsoup.select.ng.PrevSiblingSelector;\n+import org.jsoup.select.ng.PreviousSequentSiblingSelector;\n+import org.jsoup.select.ng.SelectMatch;\n \n public class Parser {\n \tTokenQueue tq;\n     \tthis.tq = new TokenQueue(query);\n     }\n     \n-    public static Evaluator select(String query) {\n+    public static Evaluator parse(String query) {\n     \tParser p = new Parser(query);\n-    \treturn p.select();\n-    }\n-    \n-    public Evaluator select() {\n+    \treturn p.parse();\n+    }\n+    \n+    public Evaluator parse() {\n         tq.consumeWhitespace();\n         \n         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n             //elements.add(root);\n-            combinator(tq.consume().toString());\n+            combinator(tq.consume());\n         } else if (tq.matches(\":has(\")) {\n             //elements.addAll(root.getAllElements());\n         } else {\n             boolean seenWhite = tq.consumeWhitespace();\n             \n             if (tq.matchChomp(\",\")) { // group or\n-\n+            \tOrSelector or = new OrSelector(s);\n+            \ts.clear();\n+            \ts.push(or);\n             \twhile (!tq.isEmpty()) {\n                     String subQuery = tq.chompTo(\",\");\n-                    \n-                    \n-                    \n-                    //elements.addAll(select(subQuery, root));\n-                    //select(subQuery);\n+                    or.add(parse(subQuery));\n                 }\n             } else if (tq.matchesAny(combinators)) {\n-                combinator(tq.consume().toString());\n+                combinator(tq.consume());\n             } else if (seenWhite) {\n-                combinator(\" \");\n+                combinator(' ');\n             } else { // E.class, E#id, E[attr] etc. AND\n                 findElements(); // take next el, #. etc off queue\n             }\n         return new AndSelector(s);\n     }\n     \n-    private void combinator(String combinator) {\n+    private void combinator(char combinator) {\n         tq.consumeWhitespace();\n         String subQuery = tq.consumeToAny(combinators); // support multi > childs\n         \n         \n-\n-        if (combinator.equals(\">\")) {\n-            //output = filterForChildren(elements, select(subQuery, elements));\n-        } else if (combinator.equals(\" \")) {\n-        \tAndSelector a = new AndSelector();\n-        \ta.add(select(subQuery));\n-        \ta.add(new ParentSelector(new AndSelector(s)));\n+        Evaluator e = null;\n+        \n+        if(s.size() == 1)\n+        \te = s.pop();\n+        else {\n+        \te = new AndSelector(s);\n         \ts.clear();\n-        \ts.push(a);\n-        \t\n-        \t\n-            //output = filterForDescendants(elements, select(subQuery, elements));\n-        } else if (combinator.equals(\"+\")) {\n-            //output = filterForAdjacentSiblings(elements, select(subQuery, root));\n-        } else if (combinator.equals(\"~\")) {\n-            //output = filterForGeneralSiblings(elements, select(subQuery, root));\n+        }\n+        Evaluator f = parse(subQuery);\n+        \n+\n+        if (combinator == '>') {\n+        \ts.push(BasicSelector.and(f, new ImmediateParentSelector(e)));\n+        } else if (combinator == ' ') {\n+        \ts.push(BasicSelector.and(f, new ParentSelector(e)));\n+        } else if (combinator == '+') {\n+        \ts.push(BasicSelector.and(f, new PrevSiblingSelector(e)));\n+        } else if (combinator == '~') {\n+        \ts.push(BasicSelector.and(f, new PreviousSequentSiblingSelector(e)));\n         } else\n             throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n         \n             else\n             \tecPush(new Evaluator.Attribute(key));\n         } else {\n-        \tString value = cq.remainder();\n             if (cq.matchChomp(\"=\"))\n-            \tecPush(new Evaluator.AttributeWithValue(key, value));\n+            \tecPush(new Evaluator.AttributeWithValue(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"!=\"))\n-                ecPush(new Evaluator.AttributeWithValueNot(key, value));\n+                ecPush(new Evaluator.AttributeWithValueNot(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"^=\"))\n-            \tecPush(new Evaluator.AttributeWithValueStarting(key, value));\n+            \tecPush(new Evaluator.AttributeWithValueStarting(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"$=\"))\n-            \tecPush(new Evaluator.AttributeWithValueEnding(key, value));\n+            \tecPush(new Evaluator.AttributeWithValueEnding(key, cq.remainder()));\n \n             else if (cq.matchChomp(\"*=\"))\n-            \tecPush(new Evaluator.AttributeWithValueContaining(key, value));\n+            \tecPush(new Evaluator.AttributeWithValueContaining(key, cq.remainder()));\n             \n             else if (cq.matchChomp(\"~=\"))\n-            \tecPush(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(value)));\n-            \n+            \tecPush(new Evaluator.AttributeWithValueMatching(key, Pattern.compile(cq.remainder())));\n             else\n                 throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, cq.remainder());\n         }\n         tq.consume(\":has\");\n         String subQuery = tq.chompBalanced('(',')');\n         Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n-        // TODO: add has parsing\n+        s.push(new HasSelector(parse(subQuery)));\n+        \n+\n+\n     }\n     \n     // pseudo selector :contains(text), containsOwn(text)\n         tq.consume(own ? \":containsOwn\" : \":contains\");\n         String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n         Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n-        \n-        // TODO: add :contains parsing\n+        if(own)\n+        \ts.push(new Evaluator.ContainsOwnText(searchText));\n+        else\n+        \ts.push(new Evaluator.ContainsText(searchText));\n     }\n     \n     // :matches(regex), matchesOwn(regex)\n         String regex = tq.chompBalanced('(', ')'); // don't unescape, as regex bits will be escaped\n         Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n         \n-        // TODO: add :matches parsing\n+        if(own)\n+        \ts.push(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n+        else\n+        \ts.push(new Evaluator.Matches(Pattern.compile(regex)));\n+\n         \n     }\n \n         tq.consume(\":not\");\n         String subQuery = tq.chompBalanced('(', ')');\n         Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n-\n-        // TODO: add :not parsing\n+        \n+        s.push(new NotSelector(parse(subQuery)));\n     }\n \n \n     }\n     \n     void ecPush(Evaluator e) {\n-    \tEvaluator p = s.peek();\n+    \t/*Evaluator p = s.peek();\n \n     \tif(p == null || !(p instanceof ElementContainerSelector)) {\n     \t\ts.push(new ElementContainerSelector().add(e));\n     \t\treturn;\n     \t}\n     \t\n-    \tElementContainerSelector ec = (ElementContainerSelector) p;\n-    \tec.add(e);\n+    \tElementContainerSelector ec = (ElementContainerSelector) p;*/\n+    \t//ec.add(e);\n+    \ts.push(e);\n     }\n \n     \n     public static void main(String[] args) {\n-    \tEvaluator e = select(\"div p href\");\n+        // make sure doesn't get nested\n+        Document doc = Jsoup.parse(\"<div id=1><div id=2><div id=3></div></div></div>\");\n+        Element div = SelectMatch.match(SelectMatch.match(doc, Parser.parse(\"div\")), Parser.parse(\" > div\")).first();\n \t}\n     \n \n--- /dev/null\n+++ b/src/test/java/org/jsoup/select/ParserSelectorNG.java\n+package org.jsoup.select;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.select.ng.SelectMatch;\n+import org.jsoup.select.ng.parser.Parser;\n+import org.junit.Test;\n+\n+import junit.framework.TestCase;\n+\n+public class ParserSelectorNG extends TestCase {\n+    @Test \n+    public void testByTag() {\n+        Elements els = SelectMatch.match(Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><div id=3>\"), Parser.parse(\"div\"));\n+        assertEquals(3, els.size());\n+        assertEquals(\"1\", els.get(0).id());\n+        assertEquals(\"2\", els.get(1).id());\n+        assertEquals(\"3\", els.get(2).id());\n+\n+        Elements none = SelectMatch.match(Jsoup.parse(\"<div id=1><div id=2><p>Hello</p></div></div><div id=3>\"), Parser.parse(\"span\"));\n+        assertEquals(0, none.size());\n+    }\n+\n+    @Test \n+    public void testById() {\n+        Elements els = SelectMatch.match(Jsoup.parse(\"<div><p id=foo>Hello</p><p id=foo>Foo two!</p></div>\"), Parser.parse(\"#foo\"));\n+        assertEquals(2, els.size());\n+        assertEquals(\"Hello\", els.get(0).text());\n+\n+        Elements none = SelectMatch.match(Jsoup.parse(\"<div id=1></div>\"), Parser.parse(\"#foo\"));\n+        assertEquals(0, none.size());\n+    }\n+\n+    @Test \n+    public void testByClass() {\n+        Elements els = SelectMatch.match(Jsoup.parse(\"<p id=0 class='one two'><p id=1 class='one'><p id=2 class='two'>\"), Parser.parse(\"p.one\"));\n+        assertEquals(2, els.size());\n+        assertEquals(\"0\", els.get(0).id());\n+        assertEquals(\"1\", els.get(1).id());\n+\n+        Elements none = SelectMatch.match(Jsoup.parse(\"<div class='one'></div>\"), Parser.parse(\".foo\"));\n+        assertEquals(0, none.size());\n+\n+        Elements els2 = SelectMatch.match(Jsoup.parse(\"<div class='one-two'></div>\"), Parser.parse(\".one-two\"));\n+        assertEquals(1, els2.size());\n+    }\n+\n+    @Test \n+    public void testByAttribute() {\n+        String h = \"<div Title=Foo /><div Title=Bar /><div Style=Qux /><div title=Bam /><div title=SLAM /><div />\";\n+        Document doc = Jsoup.parse(h);\n+\n+        Elements withTitle = SelectMatch.match(doc, Parser.parse(\"[title]\"));\n+        assertEquals(4, withTitle.size());\n+\n+        Elements foo = SelectMatch.match(doc, Parser.parse(\"[title=foo]\"));\n+        assertEquals(1, foo.size());\n+\n+        Elements not = SelectMatch.match(doc, Parser.parse(\"div[title!=bar]\"));\n+        assertEquals(5, not.size());\n+        assertEquals(\"Foo\", not.first().attr(\"title\"));\n+\n+        Elements starts = SelectMatch.match(doc, Parser.parse(\"[title^=ba]\"));\n+        assertEquals(2, starts.size());\n+        assertEquals(\"Bar\", starts.first().attr(\"title\"));\n+        assertEquals(\"Bam\", starts.last().attr(\"title\"));\n+\n+        Elements ends = SelectMatch.match(doc, Parser.parse(\"[title$=am]\"));\n+        assertEquals(2, ends.size());\n+        assertEquals(\"Bam\", ends.first().attr(\"title\"));\n+        assertEquals(\"SLAM\", ends.last().attr(\"title\"));\n+\n+        Elements contains = SelectMatch.match(doc, Parser.parse(\"[title*=a]\"));\n+        assertEquals(3, contains.size());\n+        assertEquals(\"Bar\", contains.first().attr(\"title\"));\n+        assertEquals(\"SLAM\", contains.last().attr(\"title\"));\n+    }\n+    \n+    @Test \n+    public void testNamespacedTag() {\n+        Document doc = Jsoup.parse(\"<div><abc:def id=1>Hello</abc:def></div> <abc:def class=bold id=2>There</abc:def>\");\n+        Elements byTag = SelectMatch.match(doc, Parser.parse(\"abc|def\"));\n+        assertEquals(2, byTag.size());\n+        assertEquals(\"1\", byTag.first().id());\n+        assertEquals(\"2\", byTag.last().id());\n+        \n+        Elements byAttr = SelectMatch.match(doc, Parser.parse(\".bold\"));\n+        assertEquals(1, byAttr.size());\n+        assertEquals(\"2\", byAttr.last().id());\n+        \n+        Elements byTagAttr = SelectMatch.match(doc, Parser.parse(\"abc|def.bold\"));\n+        assertEquals(1, byTagAttr.size());\n+        assertEquals(\"2\", byTagAttr.last().id());\n+        \n+        Elements byContains = SelectMatch.match(doc, Parser.parse(\"abc|def:contains(e)\"));\n+        assertEquals(2, byContains.size());\n+        assertEquals(\"1\", byContains.first().id());\n+        assertEquals(\"2\", byContains.last().id());\n+    }\n+\n+    @Test \n+    public void testByAttributeStarting() {\n+        Document doc = Jsoup.parse(\"<div id=1 data-name=jsoup>Hello</div><p data-val=5 id=2>There</p><p id=3>No</p>\");\n+        Elements withData = SelectMatch.match(doc, Parser.parse(\"[^data-]\"));\n+        assertEquals(2, withData.size());\n+        assertEquals(\"1\", withData.first().id());\n+        assertEquals(\"2\", withData.last().id());\n+\n+        withData = SelectMatch.match(doc, Parser.parse(\"p[^data-]\"));\n+        assertEquals(1, withData.size());\n+        assertEquals(\"2\", withData.first().id());\n+    }\n+    \n+    @Test \n+    public void testByAttributeRegex() {\n+        Document doc = Jsoup.parse(\"<p><img src=foo.png id=1><img src=bar.jpg id=2><img src=qux.JPEG id=3><img src=old.gif><img></p>\");\n+        Elements imgs = SelectMatch.match(doc, Parser.parse(\"img[src~=(?i)\\\\.(png|jpe?g)]\"));\n+        assertEquals(3, imgs.size());\n+        assertEquals(\"1\", imgs.get(0).id());\n+        assertEquals(\"2\", imgs.get(1).id());\n+        assertEquals(\"3\", imgs.get(2).id());\n+    }\n+\n+    @Test \n+    public void testByAttributeRegexCharacterClass() {\n+        Document doc = Jsoup.parse(\"<p><img src=foo.png id=1><img src=bar.jpg id=2><img src=qux.JPEG id=3><img src=old.gif id=4></p>\");\n+        Elements imgs = SelectMatch.match(doc, Parser.parse(\"img[src~=[o]]\"));\n+        assertEquals(2, imgs.size());\n+        assertEquals(\"1\", imgs.get(0).id());\n+        assertEquals(\"4\", imgs.get(1).id());\n+    }\n+\n+    @Test \n+    public void testAllElements() {\n+        String h = \"<div><p>Hello</p><p><b>there</b></p></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements allDoc = SelectMatch.match(doc, Parser.parse(\"*\"));\n+        Elements allUnderDiv = SelectMatch.match(doc, Parser.parse(\"div *\"));\n+        assertEquals(8, allDoc.size());\n+        assertEquals(3, allUnderDiv.size());\n+        assertEquals(\"p\", allUnderDiv.first().tagName());\n+    }\n+    \n+    @Test \n+    public void testAllWithClass() {\n+        String h = \"<p class=first>One<p class=first>Two<p>Three\";\n+        Document doc = Jsoup.parse(h);\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"*.first\"));\n+        assertEquals(2, ps.size());\n+    }\n+\n+    @Test \n+    public void testGroupOr() {\n+        String h = \"<div title=foo /><div title=bar /><div /><p></p><img /><span title=qux>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = SelectMatch.match(doc, Parser.parse(\"p,div,[title]\"));\n+\n+        assertEquals(5, els.size());\n+        assertEquals(\"div\", els.get(0).tagName());\n+        assertEquals(\"foo\", els.get(0).attr(\"title\"));\n+        assertEquals(\"div\", els.get(1).tagName());\n+        assertEquals(\"bar\", els.get(1).attr(\"title\"));\n+        assertEquals(\"div\", els.get(2).tagName());\n+        assertTrue(els.get(2).attr(\"title\").length() == 0); // missing attributes come back as empty string\n+        assertFalse(els.get(2).hasAttr(\"title\"));\n+        assertEquals(\"p\", els.get(3).tagName());\n+        assertEquals(\"span\", els.get(4).tagName());\n+    }\n+\n+    @Test \n+    public void testGroupOrAttribute() {\n+        String h = \"<div id=1 /><div id=2 /><div title=foo /><div title=bar />\";\n+        Elements els = SelectMatch.match(Jsoup.parse(h), Parser.parse(\"[id],[title=foo]\"));\n+\n+        assertEquals(3, els.size());\n+        assertEquals(\"1\", els.get(0).id());\n+        assertEquals(\"2\", els.get(1).id());\n+        assertEquals(\"foo\", els.get(2).attr(\"title\"));\n+    }\n+\n+    @Test \n+    public void testDescendant() {\n+        String h = \"<div class=head><p class=first>Hello</p><p>There</p></div><p>None</p>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = SelectMatch.match(doc, Parser.parse(\".head p\"));\n+        assertEquals(2, els.size());\n+        assertEquals(\"Hello\", els.get(0).text());\n+        assertEquals(\"There\", els.get(1).text());\n+\n+        Elements p = SelectMatch.match(doc, Parser.parse(\"p.first\"));\n+        assertEquals(1, p.size());\n+        assertEquals(\"Hello\", p.get(0).text());\n+\n+        Elements empty = SelectMatch.match(doc, Parser.parse(\"p .first\")); // self, not descend, should not match\n+        assertEquals(0, empty.size());\n+    }\n+    \n+    @Test \n+    public void testAnd() {\n+        String h = \"<div id=1 class='foo bar' title=bar name=qux><p class=foo title=bar>Hello</p></div\";\n+        Document doc = Jsoup.parse(h);\n+        \n+        Elements div = SelectMatch.match(doc, Parser.parse(\"div.foo\"));\n+        assertEquals(1, div.size());\n+        assertEquals(\"div\", div.first().tagName());\n+        \n+        Elements p = SelectMatch.match(doc, Parser.parse(\"div .foo\")); // space indicates like \"div *.foo\"\n+        assertEquals(1, p.size());\n+        assertEquals(\"p\", p.first().tagName());\n+        \n+        Elements div2 = SelectMatch.match(doc, Parser.parse(\"div#1.foo.bar[title=bar][name=qux]\")); // very specific!\n+        assertEquals(1, div2.size());\n+        assertEquals(\"div\", div2.first().tagName());\n+        \n+        Elements p2 = SelectMatch.match(doc, Parser.parse(\"div *.foo\")); // space indicates like \"div *.foo\"\n+        assertEquals(1, p2.size());\n+        assertEquals(\"p\", p2.first().tagName());\n+    }\n+\n+    @Test \n+    public void testDescendant2() {\n+        String h = \"<div class=head><p><span class=first>Hello</div><div class=head><p class=first><span>Another</span><p>Again</div>\";\n+        Elements els = SelectMatch.match(Jsoup.parse(h), Parser.parse(\"div p .first\"));\n+        assertEquals(1, els.size());\n+        assertEquals(\"Hello\", els.first().text());\n+        assertEquals(\"span\", els.first().tagName());\n+    }\n+\n+    @Test \n+    public void testParentChildElement() {\n+        String h = \"<div id=1><div id=2><div id = 3></div></div></div><div id=4></div>\";\n+        Document doc = Jsoup.parse(h);\n+\n+        Elements divs = SelectMatch.match(doc, Parser.parse(\"div > div\"));\n+        assertEquals(2, divs.size());\n+        assertEquals(\"2\", divs.get(0).id()); // 2 is child of 1\n+        assertEquals(\"3\", divs.get(1).id()); // 3 is child of 2\n+\n+        Elements div2 = SelectMatch.match(doc, Parser.parse(\"div#1 > div\"));\n+        assertEquals(1, div2.size());\n+        assertEquals(\"2\", div2.get(0).id());\n+    }\n+    \n+    @Test \n+    public void testParentWithClassChild() {\n+        String h = \"<h1 class=foo><a href=1 /></h1><h1 class=foo><a href=2 class=bar /></h1><h1><a href=3 /></h1>\";\n+        Document doc = Jsoup.parse(h);\n+        \n+        Elements allAs = SelectMatch.match(doc, Parser.parse(\"h1 > a\"));\n+        assertEquals(3, allAs.size());\n+        assertEquals(\"a\", allAs.first().tagName());\n+        \n+        Elements fooAs = SelectMatch.match(doc, Parser.parse(\"h1.foo > a\"));\n+        assertEquals(2, fooAs.size());\n+        assertEquals(\"a\", fooAs.first().tagName());\n+        \n+        Elements barAs = SelectMatch.match(doc, Parser.parse(\"h1.foo > a.bar\"));\n+        assertEquals(1, barAs.size());\n+    }\n+\n+    @Test \n+    public void testParentChildStar() {\n+        String h = \"<div id=1><p>Hello<p><b>there</b></p></div><div id=2><span>Hi</span></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements divChilds = SelectMatch.match(doc, Parser.parse(\"div > *\"));\n+        assertEquals(3, divChilds.size());\n+        assertEquals(\"p\", divChilds.get(0).tagName());\n+        assertEquals(\"p\", divChilds.get(1).tagName());\n+        assertEquals(\"span\", divChilds.get(2).tagName());\n+    }\n+    \n+    @Test \n+    public void testMultiChildDescent() {\n+        String h = \"<div id=foo><h1 class=bar><a href=http://example.com/>One</a></h1></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = SelectMatch.match(doc, Parser.parse(\"div#foo > h1.bar > a[href*=example]\"));\n+        assertEquals(1, els.size());\n+        assertEquals(\"a\", els.first().tagName());\n+    }\n+\n+    /*@Test \n+    public void testCaseInsensitive() {\n+        String h = \"<dIv tItle=bAr><div>\"; // mixed case so a simple toLowerCase() on value doesn't catch\n+        Document doc = Jsoup.parse(h);\n+\n+        assertEquals(2, SelectMatch.match(doc, Parser.parse(\"DIV\")).size());\n+        assertEquals(1, SelectMatch.match(doc, Parser.parse(\"DIV[TITLE]\")).size());\n+        assertEquals(1, SelectMatch.match(doc, Parser.parse(\"DIV[TITLE=BAR]\")).size());\n+        assertEquals(0, SelectMatch.match(doc, Parser.parse(\"DIV[TITLE=BARBARELLA\")).size());\n+    }*/\n+    \n+    @Test \n+    public void testAdjacentSiblings() {\n+        String h = \"<ol><li>One<li>Two<li>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = SelectMatch.match(doc, Parser.parse(\"li + li\"));\n+        assertEquals(2, sibs.size());\n+        assertEquals(\"Two\", sibs.get(0).text());\n+        assertEquals(\"Three\", sibs.get(1).text());\n+    }\n+    \n+    @Test \n+    public void testAdjacentSiblingsWithId() {\n+        String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = SelectMatch.match(doc, Parser.parse(\"li#1 + li#2\"));\n+        assertEquals(1, sibs.size());\n+        assertEquals(\"Two\", sibs.get(0).text());\n+    }\n+    \n+    @Test \n+    public void testNotAdjacent() {\n+        String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = SelectMatch.match(doc, Parser.parse(\"li#1 + li#3\"));\n+        assertEquals(0, sibs.size());\n+    }\n+    \n+    @Test \n+    public void testMixCombinator() {\n+        String h = \"<div class=foo><ol><li>One<li>Two<li>Three</ol></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements sibs = SelectMatch.match(doc, Parser.parse(\"body > div.foo li + li\"));\n+        \n+        assertEquals(2, sibs.size());\n+        assertEquals(\"Two\", sibs.get(0).text());\n+        assertEquals(\"Three\", sibs.get(1).text());\n+    }\n+    \n+    @Test \n+    public void testMixCombinatorGroup() {\n+        String h = \"<div class=foo><ol><li>One<li>Two<li>Three</ol></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = SelectMatch.match(doc, Parser.parse(\".foo > ol, ol > li + li\"));\n+        \n+        assertEquals(3, els.size());\n+        assertEquals(\"ol\", els.get(0).tagName());\n+        assertEquals(\"Two\", els.get(1).text());\n+        assertEquals(\"Three\", els.get(2).text());\n+    }\n+    \n+    @Test \n+    public void testGeneralSiblings() {\n+        String h = \"<ol><li id=1>One<li id=2>Two<li id=3>Three</ol>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements els = SelectMatch.match(doc, Parser.parse(\"#1 ~ #3\"));\n+        assertEquals(1, els.size());\n+        assertEquals(\"Three\", els.first().text());\n+    }\n+    \n+    // for http://github.com/jhy/jsoup/issues#issue/10\n+    @Test \n+    public void testCharactersInIdAndClass() {\n+        // using CSS spec for identifiers (id and class): a-z0-9, -, _. NOT . (which is OK in html spec, but not css)\n+        String h = \"<div><p id='a1-foo_bar'>One</p><p class='b2-qux_bif'>Two</p></div>\";\n+        Document doc = Jsoup.parse(h);\n+        \n+        Element el1 = doc.getElementById(\"a1-foo_bar\");\n+        assertEquals(\"One\", el1.text());\n+        Element el2 = doc.getElementsByClass(\"b2-qux_bif\").first();\n+        assertEquals(\"Two\", el2.text());\n+        \n+        Element el3 = SelectMatch.match(doc, Parser.parse(\"#a1-foo_bar\")).first();\n+        assertEquals(\"One\", el3.text());\n+        Element el4 = SelectMatch.match(doc, Parser.parse(\".b2-qux_bif\")).first();\n+        assertEquals(\"Two\", el4.text());\n+    }\n+    \n+    // for http://github.com/jhy/jsoup/issues#issue/13\n+    @Test \n+    public void testSupportsLeadingCombinator() {\n+        String h = \"<div><p><span>One</span><span>Two</span></p></div>\";\n+        Document doc = Jsoup.parse(h);\n+        \n+        Element p = SelectMatch.match(doc, Parser.parse(\"div > p\")).first();\n+        Elements spans = p.select(\"> span\");\n+        assertEquals(2, spans.size());\n+        assertEquals(\"One\", spans.first().text());\n+        \n+        // make sure doesn't get nested\n+        h = \"<div id=1><div id=2><div id=3></div></div></div>\";\n+        doc = Jsoup.parse(h);\n+        Element div = SelectMatch.match(SelectMatch.match(doc, Parser.parse(\"div\")), Parser.parse(\" > div\")).first();\n+        assertEquals(\"2\", div.id());\n+    }\n+    \n+    @Test public void testPseudoLessThan() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p><p>Three</>p></div><div><p>Four</p>\");\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"div p:lt(2)\"));\n+        assertEquals(3, ps.size());\n+        assertEquals(\"One\", ps.get(0).text());\n+        assertEquals(\"Two\", ps.get(1).text());\n+        assertEquals(\"Four\", ps.get(2).text());\n+    }\n+    \n+    @Test public void testPseudoGreaterThan() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p><p>Three</p></div><div><p>Four</p>\");\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"div p:gt(0)\"));\n+        assertEquals(2, ps.size());\n+        assertEquals(\"Two\", ps.get(0).text());\n+        assertEquals(\"Three\", ps.get(1).text());\n+    }\n+    \n+    @Test public void testPseudoEquals() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p><p>Three</>p></div><div><p>Four</p>\");\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"div p:eq(0)\"));\n+        assertEquals(2, ps.size());\n+        assertEquals(\"One\", ps.get(0).text());\n+        assertEquals(\"Four\", ps.get(1).text());\n+        \n+        Elements ps2 = SelectMatch.match(doc, Parser.parse(\"div:eq(0) p:eq(0)\"));\n+        assertEquals(1, ps2.size());\n+        assertEquals(\"One\", ps2.get(0).text());\n+        assertEquals(\"p\", ps2.get(0).tagName());\n+    }\n+    \n+    @Test public void testPseudoBetween() {\n+        Document doc = Jsoup.parse(\"<div><p>One</p><p>Two</p><p>Three</>p></div><div><p>Four</p>\");\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"div p:gt(0):lt(2)\"));\n+        assertEquals(1, ps.size());\n+        assertEquals(\"Two\", ps.get(0).text());\n+    }\n+    \n+    @Test public void testPseudoCombined() {\n+        Document doc = Jsoup.parse(\"<div class='foo'><p>One</p><p>Two</p></div><div><p>Three</p><p>Four</p></div>\");\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"div.foo p:gt(0)\"));\n+        assertEquals(1, ps.size());\n+        assertEquals(\"Two\", ps.get(0).text());\n+    }\n+\n+    @Test public void testPseudoHas() {\n+        Document doc = Jsoup.parse(\"<div id=0><p><span>Hello</span></p></div> <div id=1><span class=foo>There</span></div> <div id=2><p>Not</p></div>\");\n+\n+        Elements divs1 = SelectMatch.match(doc, Parser.parse(\"div:has(span)\"));\n+        assertEquals(2, divs1.size());\n+        assertEquals(\"0\", divs1.get(0).id());\n+        assertEquals(\"1\", divs1.get(1).id());\n+\n+        Elements divs2 = SelectMatch.match(doc, Parser.parse(\"div:has([class]\"));\n+        assertEquals(1, divs2.size());\n+        assertEquals(\"1\", divs2.get(0).id());\n+\n+        Elements divs3 = SelectMatch.match(doc, Parser.parse(\"div:has(span, p)\"));\n+        assertEquals(3, divs3.size());\n+        assertEquals(\"0\", divs3.get(0).id());\n+        assertEquals(\"1\", divs3.get(1).id());\n+        assertEquals(\"2\", divs3.get(2).id());\n+\n+        Elements els1 = SelectMatch.match(doc.body(), Parser.parse(\":has(p)\"));\n+        assertEquals(3, els1.size()); // body, div, dib\n+        assertEquals(\"body\", els1.first().tagName());\n+        assertEquals(\"0\", els1.get(1).id());\n+        assertEquals(\"2\", els1.get(2).id());\n+    }\n+\n+    @Test public void testNestedHas() {\n+        Document doc = Jsoup.parse(\"<div><p><span>One</span></p></div> <div><p>Two</p></div>\");\n+        Elements divs = SelectMatch.match(doc, Parser.parse(\"div:has(p:has(span))\"));\n+        assertEquals(1, divs.size());\n+        assertEquals(\"One\", divs.first().text());\n+\n+        // test matches in has\n+        divs = SelectMatch.match(doc, Parser.parse(\"div:has(p:matches((?i)two))\"));\n+        assertEquals(1, divs.size());\n+        assertEquals(\"div\", divs.first().tagName());\n+        assertEquals(\"Two\", divs.first().text());\n+\n+        // test contains in has\n+        divs = SelectMatch.match(doc, Parser.parse(\"div:has(p:contains(two))\"));\n+        assertEquals(1, divs.size());\n+        assertEquals(\"div\", divs.first().tagName());\n+        assertEquals(\"Two\", divs.first().text());\n+    }\n+    \n+    @Test public void testPseudoContains() {\n+        Document doc = Jsoup.parse(\"<div><p>The Rain.</p> <p class=light>The <i>rain</i>.</p> <p>Rain, the.</p></div>\");\n+        \n+        Elements ps1 = SelectMatch.match(doc, Parser.parse(\"p:contains(Rain)\"));\n+        assertEquals(3, ps1.size());\n+        \n+        Elements ps2 = SelectMatch.match(doc, Parser.parse(\"p:contains(the rain)\"));\n+        assertEquals(2, ps2.size());\n+        assertEquals(\"The Rain.\", ps2.first().html());\n+        assertEquals(\"The <i>rain</i>.\", ps2.last().html());\n+        \n+        Elements ps3 = SelectMatch.match(doc, Parser.parse(\"p:contains(the Rain):has(i)\"));\n+        assertEquals(1, ps3.size());\n+        assertEquals(\"light\", ps3.first().className());\n+\n+        Elements ps4 = SelectMatch.match(doc, Parser.parse(\".light:contains(rain)\"));\n+        assertEquals(1, ps4.size());\n+        assertEquals(\"light\", ps3.first().className());\n+\n+        Elements ps5 = SelectMatch.match(doc, Parser.parse(\":contains(rain)\"));\n+        assertEquals(8, ps5.size()); // html, body, div,...\n+    }\n+    \n+    @Test public void testPsuedoContainsWithParentheses() {\n+        Document doc = Jsoup.parse(\"<div><p id=1>This (is good)</p><p id=2>This is bad)</p>\");\n+        \n+        Elements ps1 = SelectMatch.match(doc, Parser.parse(\"p:contains(this (is good))\"));\n+        assertEquals(1, ps1.size());\n+        assertEquals(\"1\", ps1.first().id());\n+        \n+        Elements ps2 = SelectMatch.match(doc, Parser.parse(\"p:contains(this is bad\\\\))\"));\n+        assertEquals(1, ps2.size());\n+        assertEquals(\"2\", ps2.first().id());\n+    }\n+    \n+    @Test public void testContainsOwn() {\n+        Document doc = Jsoup.parse(\"<p id=1>Hello <b>there</b> now</p>\");\n+        Elements ps = SelectMatch.match(doc, Parser.parse(\"p:containsOwn(Hello now)\"));\n+        assertEquals(1, ps.size());\n+        assertEquals(\"1\", ps.first().id());\n+        \n+        assertEquals(0, SelectMatch.match(doc, Parser.parse(\"p:containsOwn(there)\")).size());\n+    }\n+    \n+    @Test public void testMatches() {       \n+        Document doc = Jsoup.parse(\"<p id=1>The <i>Rain</i></p> <p id=2>There are 99 bottles.</p> <p id=3>Harder (this)</p> <p id=4>Rain</p>\");\n+        \n+        Elements p1 = SelectMatch.match(doc, Parser.parse(\"p:matches(The rain)\")); // no match, case sensitive\n+        assertEquals(0, p1.size());\n+        \n+        Elements p2 = SelectMatch.match(doc, Parser.parse(\"p:matches((?i)the rain)\")); // case insense. should include root, html, body\n+        assertEquals(1, p2.size());\n+        assertEquals(\"1\", p2.first().id());\n+        \n+        Elements p4 = SelectMatch.match(doc, Parser.parse(\"p:matches((?i)^rain$)\")); // bounding\n+        assertEquals(1, p4.size());\n+        assertEquals(\"4\", p4.first().id());\n+        \n+        Elements p5 = SelectMatch.match(doc, Parser.parse(\"p:matches(\\\\d+)\"));\n+        assertEquals(1, p5.size());\n+        assertEquals(\"2\", p5.first().id());\n+        \n+        Elements p6 = SelectMatch.match(doc, Parser.parse(\"p:matches(\\\\w+\\\\s+\\\\(\\\\w+\\\\))\")); // test bracket matching\n+        assertEquals(1, p6.size());\n+        assertEquals(\"3\", p6.first().id());\n+        \n+        Elements p7 = SelectMatch.match(doc, Parser.parse(\"p:matches((?i)the):has(i)\")); // multi\n+        assertEquals(1, p7.size());\n+        assertEquals(\"1\", p7.first().id());\n+    }\n+    \n+    @Test public void testMatchesOwn() {\n+        Document doc = Jsoup.parse(\"<p id=1>Hello <b>there</b> now</p>\");\n+        \n+        Elements p1 = SelectMatch.match(doc, Parser.parse(\"p:matchesOwn((?i)hello now)\"));\n+        assertEquals(1, p1.size());\n+        assertEquals(\"1\", p1.first().id());\n+        \n+        assertEquals(0, SelectMatch.match(doc, Parser.parse(\"p:matchesOwn(there)\")).size());\n+    }\n+    \n+    @Test public void testRelaxedTags() {\n+        Document doc = Jsoup.parse(\"<abc_def id=1>Hello</abc_def> <abc-def id=2>There</abc-def>\");\n+        \n+        Elements el1 = SelectMatch.match(doc, Parser.parse(\"abc_def\"));\n+        assertEquals(1, el1.size());\n+        assertEquals(\"1\", el1.first().id());\n+        \n+        Elements el2 = SelectMatch.match(doc, Parser.parse(\"abc-def\"));\n+        assertEquals(1, el2.size());\n+        assertEquals(\"2\", el2.first().id());\n+    }\n+\n+    @Test public void notParas() {\n+        Document doc = Jsoup.parse(\"<p id=1>One</p> <p>Two</p> <p><span>Three</span></p>\");\n+\n+        Elements el1 = SelectMatch.match(doc, Parser.parse(\"p:not([id=1])\"));\n+        assertEquals(2, el1.size());\n+        assertEquals(\"Two\", el1.first().text());\n+        assertEquals(\"Three\", el1.last().text());\n+\n+        Elements el2 = SelectMatch.match(doc, Parser.parse(\"p:not(:has(span))\"));\n+        assertEquals(2, el2.size());\n+        assertEquals(\"One\", el2.first().text());\n+        assertEquals(\"Two\", el2.last().text());\n+    }\n+\n+    @Test \n+    public void testNotAll() {\n+        Document doc = Jsoup.parse(\"<p>Two</p> <p><span>Three</span></p>\");\n+\n+        Elements el1 = doc.body().select(\":not(p)\"); // should just be the span\n+        assertEquals(2, el1.size());\n+        assertEquals(\"body\", el1.first().tagName());\n+        assertEquals(\"span\", el1.last().tagName());\n+    }\n+\n+    @Test \n+    public void testNotClass() {\n+        Document doc = Jsoup.parse(\"<div class=left>One</div><div class=right id=1><p>Two</p></div>\");\n+\n+        Elements el1 = SelectMatch.match(doc, Parser.parse(\"div:not(.left)\"));\n+        assertEquals(1, el1.size());\n+        assertEquals(\"1\", el1.first().id());\n+    }\n+\n+\t\n+\n+}", "timestamp": 1309605124, "metainfo": ""}