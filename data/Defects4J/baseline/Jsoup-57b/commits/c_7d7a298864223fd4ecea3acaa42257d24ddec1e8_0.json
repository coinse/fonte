{"sha": "7d7a298864223fd4ecea3acaa42257d24ddec1e8", "log": "Revert \"Use a CharacterBuffer in CharacterReader\"  This reverts commit e47d90818b1918b436d252212e90a03ddf503b59.  On further review this has a negative impact. Counter intuitive, need to dig in more.", "commit": "\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n \n import java.io.*;\n import java.nio.ByteBuffer;\n-import java.nio.CharBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n import java.util.Random;\n     // switching the chartset midstream when a meta http-equiv tag defines the charset.\n     // todo - this is getting gnarly. needs a rewrite.\n     static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n-        CharBuffer docData;\n+        String docData;\n         Document doc = null;\n         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-            docData = Charset.forName(defaultCharset).decode(byteData);\n+            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             doc = parser.parseInput(docData, baseUri);\n             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n             if (meta != null) { // if not found, will keep utf-8 as best attempt\n                     foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                     charsetName = foundCharset;\n                     byteData.rewind();\n-                    docData = Charset.forName(foundCharset).decode(byteData);\n+                    docData = Charset.forName(foundCharset).decode(byteData).toString();\n                     doc = null;\n                 }\n             }\n         } else { // specified by content type header (or by user on file load)\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n-            docData = Charset.forName(charsetName).decode(byteData);\n+            docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n         if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n             byteData.rewind();\n-            docData = Charset.forName(defaultCharset).decode(byteData);\n-            docData.get(); // advance the pos by one, to skip the BOM\n+            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n+            docData = docData.substring(1);\n             charsetName = defaultCharset;\n             doc = null;\n         }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n \n import org.jsoup.helper.Validate;\n \n-import java.nio.CharBuffer;\n import java.util.Arrays;\n import java.util.Locale;\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n         this.input = input.toCharArray();\n-        this.length = this.input.length;\n-    }\n-\n-    CharacterReader(CharBuffer input) {\n-        Validate.notNull(input);\n-        if (input.hasArray()) {\n-            this.input = input.array();\n-            this.pos = input.position();\n-        } else {\n-            // yuck -- can't get the backing array. read it into a string and get its array\n-            this.input = input.toString().toCharArray();\n-        }\n         this.length = this.input.length;\n     }\n \n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n     HtmlTreeBuilder() {}\n \n     @Override\n-    protected void init(String baseUri, ParseErrorList errors) {\n-        super.init(baseUri, errors);\n+    Document parse(String input, String baseUri, ParseErrorList errors) {\n         state = HtmlTreeBuilderState.Initial;\n         baseUriSetFromDoc = false;\n+        return super.parse(input, baseUri, errors);\n     }\n \n     List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n \n-import java.nio.CharBuffer;\n import java.util.List;\n \n /**\n     }\n     \n     public Document parseInput(String html, String baseUri) {\n-        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        Document doc = treeBuilder.parse(html, baseUri, errors);\n-        return doc;\n-    }\n-\n-    public Document parseInput(CharBuffer html, String baseUri) {\n         errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n         Document doc = treeBuilder.parse(html, baseUri, errors);\n         return doc;\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n-import java.nio.CharBuffer;\n import java.util.ArrayList;\n \n /**\n \n     protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n         Validate.notNull(input, \"String input must not be null\");\n+        Validate.notNull(baseUri, \"BaseURI must not be null\");\n+\n+        doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n-        init(baseUri, errors);\n-    }\n-\n-    protected void initialiseParse(CharBuffer input, String baseUri, ParseErrorList errors) {\n-        Validate.notNull(input, \"Input buffer must not be null\");\n-        reader = new CharacterReader(input);\n-        init(baseUri, errors);\n-    }\n-\n-    protected void init(String baseUri, ParseErrorList errors) {\n-        Validate.notNull(baseUri, \"BaseURI must not be null\");\n-        doc = new Document(baseUri);\n         this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n         stack = new ArrayList<Element>(32);\n     }\n \n     Document parse(String input, String baseUri, ParseErrorList errors) {\n-        return parse(CharBuffer.wrap(input), baseUri, errors);\n-    }\n-\n-    Document parse(CharBuffer input, String baseUri, ParseErrorList errors) {\n         initialiseParse(input, baseUri, errors);\n         runParser();\n         return doc;\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n  */\n public class XmlTreeBuilder extends TreeBuilder {\n     @Override\n-    protected void init(String baseUri, ParseErrorList errors) {\n-        super.init(baseUri, errors);\n+    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n+        super.initialiseParse(input, baseUri, errors);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n         doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n     }", "timestamp": 1414559668, "metainfo": ""}