{"sha": "e97f564d2450702d2b74ff35ecc5ad5c1e57fc0d", "log": "Implicit parent creation for elements, more general document structure creation.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Document extends Element {\n-    private Element head;\n-    private Element body;\n     private String title;\n \n     public Document() {\n-        super(new StartTag(Tag.valueOf(\"html\")));\n-        head = new Element (new StartTag(Tag.valueOf(\"head\")));\n-        body = new Element (new StartTag(Tag.valueOf(\"body\")));\n-\n-        this.addChild(head);\n-        this.addChild(body);\n+        super(new StartTag(Tag.valueOf(\"#root\")));\n     }\n \n     public Element getHead() {\n-        return head;\n+        return getElementsByTag(\"head\").get(0);\n     }\n \n     public Element getBody() {\n-        return body;\n+        return getElementsByTag(\"body\").get(0);\n     }\n \n     public String getTitle() {\n     public void setTitle(String title) {\n         this.title = title;\n     }\n+\n+    @Override\n+    public String outerHtml() {\n+        return super.html(); // no outer wrapper tag\n+    }\n }\n \n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n import org.jsoup.nodes.*;\n \n import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n /**\n  Parses HTML into a {@link Document}\n \n         doc = new Document();\n         stack.add(doc);\n-        stack.add(doc.getHead());\n     }\n \n     public static Document parse(String html) {\n     }\n \n     private void parseComment() {\n-        // TODO: this puts comments into nodes that should not hold the (e.g. img).\n+        // TODO: this puts comments into nodes that should not hold them (e.g. img).\n         tq.consume(\"<!--\");\n         String data = tq.chompTo(\"->\");\n \n \n         if (!tagName.isEmpty()) {\n             Tag tag = Tag.valueOf(tagName);\n-            Element closed = popStackToClose(tag);\n+            popStackToClose(tag);\n         }\n     }\n \n         StartTag startTag = new StartTag(tag, attributes);\n         Element child = new Element(startTag);\n \n-        boolean emptyTag;\n-        if (tq.matchChomp(\"/>\")) { // empty tag, don't add to stack\n-            emptyTag = true;\n-        } else {\n-            tq.matchChomp(\">\"); // safe because checked above (or ran out of data)\n-            emptyTag = false;\n+        if (!tq.matchChomp(\"/>\")) { // close empty element or tag\n+            tq.matchChomp(\">\");\n         }\n \n         // pc data only tags (textarea, script): chomp to end tag, add content as text node\n             if (tag.equals(titleTag))\n                 doc.setTitle(child.text());\n         }\n-\n-        // switch between html, head, body, to preserve doc structure\n-        if (tag.equals(htmlTag)) {\n-            doc.getAttributes().mergeAttributes(attributes);\n-        } else if (tag.equals(headTag)) {\n-            doc.getHead().getAttributes().mergeAttributes(attributes);\n-            // head is on stack from start, no action required\n-        } else if (last().getTag().equals(headTag) && !headTag.canContain(tag)) {\n-            // switch to body\n-            stack.removeLast();\n-            stack.addLast(doc.getBody());\n-            last().addChild(child);\n-            if (!emptyTag)\n-                stack.addLast(child);\n-        } else if (tag.equals(bodyTag) && last().getTag().equals(htmlTag)) {\n-            doc.getBody().getAttributes().mergeAttributes(attributes);\n-            stack.removeLast();\n-            stack.addLast(doc.getBody());\n-        } else {\n-            Element parent = popStackToSuitableContainer(tag);\n-            parent.addChild(child);\n-            if (!emptyTag && !tag.isData()) // TODO: only check for data here because last() == head is wrong; should be ancestor is head\n-                stack.addLast(child);\n-        }\n+        addChildToParent(child);\n     }\n \n     private Attribute parseAttribute() {\n         last().addChild(textNode);\n     }\n \n+    private Element addChildToParent(Element child) {\n+        Element parent = popStackToSuitableContainer(child.getTag());\n+        Tag childTag = child.getTag();\n+        boolean validAncestor = stackHasValidParent(childTag);\n+\n+        if (!validAncestor) {\n+            // create implicit parent around this child\n+            Tag parentTag = childTag.getImplicitParent();\n+            StartTag parentStart = new StartTag(parentTag);\n+            Element implicit = new Element(parentStart);\n+            // special case: make sure there's a head before putting in body\n+            if (child.getTag().equals(bodyTag)) {\n+                Element head = new Element(new StartTag(headTag));\n+                implicit.addChild(head);\n+            }\n+            implicit.addChild(child);\n+\n+            // recurse to ensure somewhere to put parent\n+            Element root = addChildToParent(implicit);\n+            stack.addLast(child);\n+            return root;\n+        }\n+\n+        parent.addChild(child);\n+        stack.addLast(child);\n+        return parent;\n+    }\n+\n+    private boolean stackHasValidParent(Tag childTag) {\n+        if (stack.size() == 1 && childTag.equals(htmlTag))\n+            return true; // root is valid for html node\n+        \n+        for (int i = stack.size() -1; i > 0; i--) { // not all the way to end\n+            Element el = stack.get(i);\n+            Tag parent2 = el.getTag();\n+            if (parent2.isValidParent(childTag)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n     private Element popStackToSuitableContainer(Tag tag) {\n         while (!stack.isEmpty()) {\n             if (last().getTag().canContain(tag))\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n import org.apache.commons.lang.Validate;\n \n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.*;\n \n /**\n  HTML Tag specifications. This is a very simplistic model without the full expressiveness as the DTD,\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Tag {\n     private static final Map<String, Tag> tags = new HashMap<String, Tag>();\n+    private static final Tag defaultAncestor;\n+    static {\n+        defaultAncestor = new Tag(\"BODY\", true, true, true, false, false);\n+        tags.put(defaultAncestor.tagName, defaultAncestor);\n+    }\n \n     private String tagName;\n     private boolean isBlock; // block or inline\n     private boolean canContainInline; // only pcdata if not\n     private boolean optionalClosing; // If tag is open, and another seen, close previous tag\n     private boolean empty; // can hold nothing; e.g. img\n+    private List<Tag> ancestors;\n \n     private Tag(String tagName, boolean block, boolean canContainBlock, boolean canContainInline, boolean optionalClosing, boolean empty) {\n         this.tagName = tagName.toLowerCase();\n \n         if (this.optionalClosing && this.equals(child))\n             return false;\n-        // TODO: the optional closing may need more context to decide?\n-\n-        if (this.empty)\n+\n+        if (this.empty || this.isData())\n             return false;\n \n         // head can only contain a few. if more than head in here, modify to have a list of valids\n \n     public boolean isEmpty() {\n         return empty;\n+    }\n+\n+    public Tag getImplicitParent() {\n+        return (!ancestors.isEmpty()) ? ancestors.get(0) : null;\n+    }\n+\n+    public boolean isValidParent(Tag child) {\n+        if (child.ancestors.isEmpty())\n+            return true; // HTML tag\n+\n+        for (Tag tag : child.ancestors) {\n+            if (this.equals(tag))\n+                return true;\n+        }\n+        return false;\n     }\n \n     @Override\n         // prepped from http://www.w3.org/TR/REC-html40/sgml/dtd.html#inline\n         // tags are set here in uppercase for legibility, but internally held as lowercase.\n         // TODO[must]: incorporate html 5 as appropriate\n+\n+        // document\n+        createBlock(\"HTML\").setAncestor(null); // specific includes not impl\n+        createBlock(\"HEAD\").setAncestor(\"HTML\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT\n+        createBlock(\"BODY\").setAncestor(\"HTML\"); // specific includes not impl\n+\n+        // head\n+        // all ancestors set to (head, body): so implicitly create head, but allow in body\n+        createInline(\"SCRIPT\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n+        createInline(\"STYLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n+        createInline(\"META\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n+        createBlock(\"LINK\").setAncestor(\"HEAD\", \"BODY\").setEmpty(); // only within head\n+        createInline(\"OBJECT\").setAncestor(\"HEAD\", \"BODY\"); // flow (block/inline) or param\n+        createInline(\"TITLE\").setAncestor(\"HEAD\", \"BODY\").setContainDataOnly();\n+        createInline(\"BASE\").setAncestor(\"HEAD\", \"BODY\").setEmpty();\n+\n+\n \n         // fontstyle\n         createInline(\"TT\");\n         // special\n         createInline(\"A\").setOptionalClosing(); // cannot contain self\n         createInline(\"IMG\").setEmpty();\n-        createInline(\"OBJECT\"); // flow (block/inline) or param\n         createInline(\"BR\").setEmpty();\n-        createInline(\"SCRIPT\").setContainDataOnly();\n         createInline(\"MAP\"); // map is defined as inline, but can hold block (what?) or area. Seldom used so NBD.\n         createInline(\"Q\");\n         createInline(\"SUB\");\n         createBlock(\"UL\");\n         createBlock(\"OL\");\n         createBlock(\"PRE\").setContainInlineOnly();\n-        createBlock(\"DL\");\n         createBlock(\"DIV\");\n         createBlock(\"NOSCRIPT\");\n         createBlock(\"BLOCKQUOTE\");\n+        createBlock(\"HR\").setEmpty();\n+        createBlock(\"ADDRESS\").setContainInlineOnly();\n+\n+\n+        // formctrl\n         createBlock(\"FORM\").setOptionalClosing(); // can't contian self\n-        createBlock(\"HR\").setEmpty();\n-        createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented\n-        createBlock(\"FIELDSET\");\n-        createBlock(\"ADDRESS\").setContainInlineOnly();\n-\n-\n-        // formctrl\n-        createInline(\"INPUT\").setEmpty();\n-        createInline(\"SELECT\"); // just optgroup or option\n-        createInline(\"TEXTAREA\").setContainDataOnly();\n-        createInline(\"LABEL\").setOptionalClosing(); // not self\n-        createInline(\"BUTTON\"); // bunch of excludes not defined\n-        createInline(\"OPTGROUP\"); // only in select, only contain option\n-        createInline(\"OPTION\").setContainDataOnly();\n-        createInline(\"LEGEND\"); // only within fieldset (implicit?)\n-\n-        // document\n-        createBlock(\"HTML\"); // specific includes not impl\n-        createBlock(\"HEAD\"); // specific includes not impl: SCRIPT, STYLE, META, LINK, OBJECT\n-        createBlock(\"BODY\"); // specific includes not impl\n+        createInline(\"INPUT\").setAncestor(\"FORM\").setEmpty();\n+        createInline(\"SELECT\").setAncestor(\"FORM\"); // just contain optgroup or option\n+        createInline(\"TEXTAREA\").setAncestor(\"FORM\").setContainDataOnly();\n+        createInline(\"LABEL\").setAncestor(\"FORM\").setOptionalClosing(); // not self\n+        createInline(\"BUTTON\").setAncestor(\"FORM\"); // bunch of excludes not defined\n+        createInline(\"OPTGROUP\").setAncestor(\"SELECT\"); //  only contain option\n+        createInline(\"OPTION\").setAncestor(\"SELECT\").setContainDataOnly();\n+        createBlock(\"FIELDSET\").setAncestor(\"FORM\");\n+        createInline(\"LEGEND\").setAncestor(\"FIELDSET\");\n \n         // other\n         createInline(\"AREA\").setEmpty(); // not an inline per-se\n-        createBlock(\"LINK\").setEmpty(); // only within head\n-        createInline(\"PARAM\").setEmpty(); // only within object\n+        createInline(\"PARAM\").setAncestor(\"OBJECT\").setEmpty();\n         createBlock(\"INS\"); // only within body\n         createBlock(\"DEL\"); // only within body\n \n-        createInline(\"DT\").setOptionalClosing(); // only within DL. Prolly should create implicit DL?\n-        createInline(\"DD\").setOptionalClosing(); // only within DL. Prolly should create implicit DL?\n-\n-        createBlock(\"LI\").setOptionalClosing(); // only within OL or UL. Implicit?\n-\n-\n+        createBlock(\"DL\");\n+        createInline(\"DT\").setAncestor(\"DL\").setOptionalClosing(); // only within DL.\n+        createInline(\"DD\").setAncestor(\"DL\").setOptionalClosing(); // only within DL.\n+\n+        createBlock(\"LI\").setAncestor(\"UL\", \"OL\").setOptionalClosing(); // only within OL or UL.\n \n         // tables\n-        createInline(\"CAPTION\");\n-        createInline(\"THEAD\").setOptionalClosing(); // just TR\n-        createInline(\"TFOOT\").setOptionalClosing(); // just TR\n-        createInline(\"TBODY\").setOptionalClosing(); // optional / implicit open too. just TR\n-        createInline(\"COLGROUP\").setOptionalClosing(); // just COL\n-        createInline(\"COL\").setEmpty();\n-        createInline(\"TR\").setOptionalClosing(); // just TH, TD\n-        createBlock(\"TD\").setOptionalClosing();\n-        \n-        // head\n-        createInline(\"TITLE\").setContainDataOnly();\n-        createInline(\"BASE\").setEmpty();\n-        createInline(\"META\").setEmpty();\n-        createInline(\"STYLE\").setContainDataOnly();\n+        createBlock(\"TABLE\"); // specific list of only includes (tr, td, thead etc) not implemented\n+        createBlock(\"CAPTION\").setAncestor(\"TABLE\");\n+        createBlock(\"THEAD\").setAncestor(\"TABLE\").setOptionalClosing(); // just TR\n+        createBlock(\"TFOOT\").setAncestor(\"TABLE\").setOptionalClosing(); // just TR\n+        createBlock(\"TBODY\").setAncestor(\"TABLE\").setOptionalClosing(); // optional / implicit open too. just TR\n+        createBlock(\"COLGROUP\").setAncestor(\"TABLE\").setOptionalClosing(); // just COL\n+        createBlock(\"COL\").setAncestor(\"COLGROUP\").setEmpty();\n+        createBlock(\"TR\").setAncestor(\"TABLE\").setOptionalClosing(); // just TH, TD\n+        createBlock(\"TH\").setAncestor(\"TR\").setOptionalClosing();\n+        createBlock(\"TD\").setAncestor(\"TR\").setOptionalClosing();\n     }\n \n     private static Tag createBlock(String tagName) {\n     }\n \n     private static Tag register(Tag tag) {\n+        tag.setAncestor(defaultAncestor.tagName);\n         synchronized (tags) {\n             tags.put(tag.tagName, tag);\n         }\n         optionalClosing = true;\n         return this;\n     }\n+\n+    private Tag setAncestor(String... tagNames) {\n+        if (tagNames == null) {\n+            ancestors = Collections.emptyList();\n+        } else {\n+            ancestors = new ArrayList<Tag>(tagNames.length);\n+            for (String name : tagNames) {\n+                ancestors.add(Tag.valueOf(name));\n+            }\n+        }\n+        return this;\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/ParserTest.java\n+++ b/src/test/java/org/jsoup/parser/ParserTest.java\n         String html = \"<html><head><title>First!</title></head><body><p>First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n         Document doc = Jsoup.parse(html);\n         // need a better way to verify these:\n-        Element p = doc.child(1).child(0);\n+        Element p = doc.getBody().child(0);\n         assertEquals(\"p\", p.tagName());\n         Element img = p.child(0);\n         assertEquals(\"foo.png\", img.attr(\"src\"));\n         Document doc = Jsoup.parse(html);\n \n         // need a better way to verify these:\n-        Element p = doc.child(1).child(0);\n+        Element p = doc.getBody().child(0);\n         assertEquals(\"p\", p.tagName());\n         assertEquals(\"foo > bar\", p.attr(\"class\"));\n     }\n         String html = \"<html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html>\";\n         Document doc = Jsoup.parse(html);\n         \n-        Element body = doc.child(1);\n+        Element body = doc.getBody();\n         Comment comment = (Comment) body.childNode(0);\n         assertEquals(\" <table><tr><td></table> \", comment.getData());\n         Element p = body.child(0);\n         Element head = doc.getHead();\n         Element body = doc.getBody();\n \n-        assertEquals(2, doc.children().size());\n+        assertEquals(1, doc.children().size()); // root node: contains html node\n+        assertEquals(2, doc.child(0).children().size()); // html node: head and body\n         assertEquals(3, head.children().size());\n         assertEquals(1, body.children().size());\n \n         assertEquals(\"<p>Foo</p>\\n<p>Bar</p>\", tels.get(0).text());\n     }\n \n+    @Test public void createsImplicitLists() {\n+        String h = \"<li>Point one<li>Point two\";\n+        Document doc = Jsoup.parse(h);\n+        Elements ol = doc.select(\"ul\"); // should have created a default ul.\n+        assertEquals(1, ol.size());\n+        assertEquals(2, ol.get(0).children().size());\n+\n+        // no fiddling with non-implicit lists\n+        String h2 = \"<ol><li><p>Point the first<li><p>Point the second\";\n+        Document doc2 = Jsoup.parse(h2);\n+\n+        assertEquals(0, doc2.select(\"ul\").size());\n+        assertEquals(1, doc2.select(\"ol\").size());\n+        assertEquals(2, doc2.select(\"ol li\").size());\n+        assertEquals(2, doc2.select(\"ol li p\").size());\n+        assertEquals(1, doc2.select(\"ol li\").get(0).children().size()); // one p in first li\n+    }\n+\n+    @Test public void createsImplicitTable() {\n+        String h = \"<td>Hello<td><p>There<p>now\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<table><tr><td>Hello</td><td><p>There</p><p>now</p></td></tr></table>\", doc.getBody().html());\n+    }\n+\n \n }", "timestamp": 1309605102, "metainfo": ""}