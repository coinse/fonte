{"sha": "ad03c445e1384a2b7168c6889461f973b008317b", "log": "Implemented an example HTML to plain-text converter.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+package org.jsoup.examples;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n+\n+import java.io.IOException;\n+\n+/**\n+ * HTML to plain-text. This example program demonstrates the use of jsoup to convert HTML input to lightly-formatted\n+ * plain-text. That is divergent from the general goal of jsoup's .text() methods, which is to get clean data from a\n+ * scrape.\n+ * <p/>\n+ * Note that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.\n+ *\n+ * @author Jonathan Hedley, jonathan@hedley.net\n+ */\n+public class HtmlToPlainText {\n+    public static void main(String... args) throws IOException {\n+        Validate.isTrue(args.length == 1, \"usage: supply url to fetch\");\n+        String url = args[0];\n+        Document doc = Jsoup.connect(url).get();\n+\n+        HtmlToPlainText formatter = new HtmlToPlainText();\n+        String plainText = formatter.getPlainText(doc);\n+        System.out.println(plainText);\n+    }\n+\n+    public String getPlainText(Element element) {\n+        FormattingVisitor formatter = new FormattingVisitor();\n+        NodeTraversor traversor = new NodeTraversor(formatter);\n+        traversor.traverse(element); // walk the DOM, and call .head() and .tail() for each node\n+\n+        return formatter.toString();\n+    }\n+\n+    // the formatting rules, implemented in a breadth-first DOM travarse\n+    private class FormattingVisitor implements NodeVisitor {\n+        private static final int maxWidth = 80;\n+        private int width = 0;\n+        private StringBuilder accum = new StringBuilder(); // holds the accumulated text\n+\n+        // hit when the node is first seen\n+        public void head(Node node, int depth) {\n+            String name = node.nodeName();\n+            if (node instanceof TextNode)\n+                append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n+            else if (name.equals(\"li\"))\n+                append(\"\\n * \");\n+        }\n+\n+        // hit when all of the node's children (if any) have been visited\n+        public void tail(Node node, int depth) {\n+            String name = node.nodeName();\n+            if (name.equals(\"br\"))\n+                append(\"\\n\");\n+            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n+                append(\"\\n\\n\");\n+            else if (name.equals(\"a\"))\n+                append(String.format(\" <%s>\", node.absUrl(\"href\")));\n+        }\n+\n+        // appends text to the string builder with a simple word wrap method\n+        private void append(String text) {\n+            if (text.startsWith(\"\\n\"))\n+                width = 0; // reset counter if starts with a newline. only from formats above, not in natural text\n+            if (text.equals(\" \") &&\n+                    (accum.length() == 0 || StringUtil.in(accum.substring(accum.length() - 1), \" \", \"\\n\")))\n+                return; // don't accumulate long runs of empty spaces\n+\n+            if (text.length() + width > maxWidth) { // won't fit, needs to wrap\n+                String words[] = text.split(\"\\\\s+\");\n+                for (int i = 0; i < words.length; i++) {\n+                    String word = words[i];\n+                    boolean last = i == words.length - 1;\n+                    if (!last) // insert a space if not the last word\n+                        word = word + \" \";\n+                    if (word.length() + width > maxWidth) { // wrap and reset counter\n+                        accum.append(\"\\n\").append(word);\n+                        width = word.length();\n+                    } else {\n+                        accum.append(word);\n+                        width += word.length();\n+                    }\n+                }\n+            } else { // fits as is, without need to wrap text\n+                accum.append(text);\n+                width += text.length();\n+            }\n+        }\n+\n+        public String toString() {\n+            return accum.toString();\n+        }\n+    }\n+}", "timestamp": 1314883225, "metainfo": ""}