{"sha": "28418f8335d2b359690e80e61d0081f4e892769c", "log": "Javadoc", "commit": "\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n package org.jsoup;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.net.URL;\n \n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.safety.Cleaner;\n import org.jsoup.safety.Whitelist;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+\n /**\n- * Jsoup HTML Parser.\n- *\n- * @author Jonathan Hedley\n- */\n+ The core public access point to the jsoup functionality.\n+\n+ @author Jonathan Hedley */\n public class Jsoup {\n     private Jsoup() {}\n-    \n+\n     /**\n-     * Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n-     * @param html HTML to parse\n-     * @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, until\n-     * the HTML declares a {@code <base href>} tag.\n-     * @return sane HTML\n+     Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.\n+\n+     @param html    HTML to parse\n+     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n+     before the HTML declares a {@code <base href>} tag.\n+     @return sane HTML\n      */\n     public static Document parse(String html, String baseUri) {\n         return Parser.parse(html, baseUri);\n     }\n \n     /**\n-     * Parse HTML into a Document. As no base URI is specified, absolute URL detection relies on the HTML including a \n-     * {@code <base href>} tag.\n-     * @param html HTML to parse\n-     * @return sane HTML\n-     * @see #parse(String, String)\n+     Parse HTML into a Document. As no base URI is specified, absolute URL detection relies on the HTML including a\n+     {@code <base href>} tag.\n+\n+     @param html HTML to parse\n+     @return sane HTML\n+\n+     @see #parse(String, String)\n      */\n     public static Document parse(String html) {\n         return Parser.parse(html, \"\");\n \n     /**\n      Fetch a URL, and parse it as HTML.\n-     @param url URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n+\n+     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n      @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n      @return The parsed HTML.\n+\n      @throws IOException If the final server response != 200 OK (redirects are followed), or if there's an error reading\n-        the response stream.\n+     the response stream.\n      */\n     public static Document parse(URL url, int timeoutMillis) throws IOException {\n         String html = DataUtil.load(url, timeoutMillis);\n         return parse(html, url.toExternalForm());\n     }\n-    \n+\n     /**\n-     * Parse the contents of a file as HTML.\n-     * @param in file to load HTML from\n-     * @param charsetName character set of file contents. If you don't know the charset, generally the best guess is\n-     * {@code UTF-8}.\n-     * @param baseUri The URL where the HTML was retrieved from, to generate absolute URLs relative to.\n-     * @return sane HTML\n-     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n+     Parse the contents of a file as HTML.\n+\n+     @param in          file to load HTML from\n+     @param charsetName character set of file contents. If you don't know the charset, generally the best guess is {@code UTF-8}.\n+     @param baseUri     The URL where the HTML was retrieved from, to generate absolute URLs relative to.\n+     @return sane HTML\n+\n+     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n      */\n     public static Document parse(File in, String charsetName, String baseUri) throws IOException {\n         String html = DataUtil.load(in, charsetName);\n         return parse(html, baseUri);\n     }\n-    \n+\n     /**\n-     * Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n-     * @param in file to load HTML from\n-     * @param charsetName character set of file contents. If you don't know the charset, generally the best guess is\n-     * {@code UTF-8}.\n-     * @return sane HTML\n-     * @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n-     * @see #parse(File, String, String)\n+     Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n+\n+     @param in          file to load HTML from\n+     @param charsetName character set of file contents. If you don't know the charset, generally the best guess is {@code UTF-8}.\n+     @return sane HTML\n+\n+     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n+     @see #parse(File, String, String)\n      */\n     public static Document parse(File in, String charsetName) throws IOException {\n         String html = DataUtil.load(in, charsetName);\n         return parse(html, in.getAbsolutePath());\n     }\n-    \n+\n     /**\n-     * Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n-     * @param bodyHtml body HTML fragment\n-     * @param baseUri URL to resolve relative URLs against.\n-     * @return sane HTML document\n-     * @see Document#body()\n+     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n+\n+     @param bodyHtml body HTML fragment\n+     @param baseUri  URL to resolve relative URLs against.\n+     @return sane HTML document\n+\n+     @see Document#body()\n      */\n     public static Document parseBodyFragment(String bodyHtml, String baseUri) {\n         return Parser.parseBodyFragment(bodyHtml, baseUri);\n     }\n-    \n+\n     /**\n-     * Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n-     * @param bodyHtml body HTML fragment\n-     * @return sane HTML document\n-     * @see Document#body()\n+     Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n+\n+     @param bodyHtml body HTML fragment\n+     @return sane HTML document\n+\n+     @see Document#body()\n      */\n     public static Document parseBodyFragment(String bodyHtml) {\n         return Parser.parseBodyFragment(bodyHtml, \"\");\n     }\n \n     /**\n-     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of \n-     * permitted tags and attributes.\n-     * @param bodyHtml input untrusted HMTL\n-     * @param baseUri URL to resolve relative URLs against\n-     * @param whitelist white-list of permitted HTML elements\n-     * @return safe HTML\n-     * @see Cleaner#clean(Document)\n+     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted\n+     tags and attributes.\n+\n+     @param bodyHtml  input untrusted HMTL\n+     @param baseUri   URL to resolve relative URLs against\n+     @param whitelist white-list of permitted HTML elements\n+     @return safe HTML\n+\n+     @see Cleaner#clean(Document)\n      */\n     public static String clean(String bodyHtml, String baseUri, Whitelist whitelist) {\n         Document dirty = parseBodyFragment(bodyHtml, baseUri);\n         Document clean = cleaner.clean(dirty);\n         return clean.body().html();\n     }\n-    \n+\n     /**\n-     * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of \n-     * permitted tags and attributes.\n-     * @param bodyHtml input untrusted HTML\n-     * @param whitelist white-list of permitted HTML elements\n-     * @return safe HTML\n-     * @see Cleaner#clean(Document)\n+     Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of permitted\n+     tags and attributes.\n+\n+     @param bodyHtml  input untrusted HTML\n+     @param whitelist white-list of permitted HTML elements\n+     @return safe HTML\n+\n+     @see Cleaner#clean(Document)\n      */\n     public static String clean(String bodyHtml, Whitelist whitelist) {\n         return clean(bodyHtml, \"\", whitelist);\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n         this.value = value;\n     }\n \n+    /**\n+     Get the attribute key.\n+     @return the attribute key\n+     */\n     public String getKey() {\n         return key;\n     }\n \n+    /**\n+     Set the attribute key. Gets normalised as per the constructor method.\n+     @param key the new key; must not be null\n+     */\n     public void setKey(String key) {\n         Validate.notEmpty(key);\n-        this.key = key;\n+        this.key = key.trim().toLowerCase();\n     }\n \n+    /**\n+     Get the attribute value.\n+     @return the attribute value\n+     */\n     public String getValue() {\n         return value;\n     }\n \n+    /**\n+     Set the attribute value.\n+     @param value the new attribute value; must not be null\n+     */\n     public void setValue(String value) {\n         Validate.notNull(value);\n         this.value = value;\n     }\n \n+    /**\n+     Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n+     @return HTML\n+     */\n     public String html() {\n         return String.format(\"%s=\\\"%s\\\"\", key, StringEscapeUtils.escapeHtml(value));\n     }\n \n+    /**\n+     Get the string representation of this attribute, implemented as {@link #html()}.\n+     @return string\n+     */\n     public String toString() {\n         return html();\n     }\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n  */\n public class Attributes implements Iterable<Attribute> {\n     private LinkedHashMap<String, Attribute> attributes = new LinkedHashMap<String, Attribute>();\n-    \n     // linked hash map to preserve insertion order.\n-    \n+\n+    /**\n+     Get an attribute value by key.\n+     @param key the attribute key\n+     @return the attribute value if set; or empty string if not set.\n+     @see #hasKey(String)\n+     */\n     public String get(String key) {\n         Validate.notEmpty(key);\n         \n         Attribute attr = attributes.get(key.toLowerCase());\n         return attr != null ? attr.getValue() : \"\";\n     }\n-    \n+\n+    /**\n+     Set a new attribute, or replace an existing one by key.\n+     @param key attribute key\n+     @param value attribute value\n+     */\n     public void put(String key, String value) {\n         Attribute attr = new Attribute(key, value);\n         put(attr);\n     }\n-    \n+\n+    /**\n+     Set a new attribute, or replace an existing one by key.\n+     @param attribute attribute\n+     */\n     public void put(Attribute attribute) {\n         Validate.notNull(attribute);\n         attributes.put(attribute.getKey(), attribute);\n     }\n-    \n+\n+    /**\n+     Remove an attribute by key.\n+     @param key attribute key to remove\n+     */\n     public void remove(String key) {\n         Validate.notEmpty(key);\n         attributes.remove(key.toLowerCase());\n     }\n-    \n+\n+    /**\n+     Tests if these attributes contain an attribute with this key.\n+     @param key key to check for\n+     @return true if key exists, false otherwise\n+     */\n     public boolean hasKey(String key) {\n         return attributes.containsKey(key.toLowerCase());\n     }\n-    \n+\n+    /**\n+     Get the number of attributes in this set.\n+     @return size\n+     */\n     public int size() {\n         return attributes.size();\n     }\n-    \n-    public void mergeAttributes(Attributes incoming) {\n-        for (Attribute attribute : incoming) {\n-            this.put(attribute);\n-        }\n+\n+    /**\n+     Add all the attributes from the incoming set to this set.\n+     @param incoming attributes to add to these attributes.\n+     */\n+    public void addAll(Attributes incoming) {\n+        attributes.putAll(incoming.attributes);\n     }\n     \n     public Iterator<Attribute> iterator() {\n         return asList().iterator();\n     }\n-    \n+\n+    /**\n+     Get the attributes as a List, for iteration. Do not modify the keys of the attributes via this view, as changes\n+     to keys will not be recognised in the containing set.\n+     @return an view of the attributes as a List.\n+     */\n     public List<Attribute> asList() {\n         List<Attribute> list = new ArrayList<Attribute>(attributes.size());\n         for (Map.Entry<String, Attribute> entry : attributes.entrySet()) {\n         }\n         return Collections.unmodifiableList(list);\n     }\n-    \n+\n+    /**\n+     Get the HTML representation of these attributes.\n+     @return HTML\n+     */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         for (Attribute attribute : this) {\n     public int hashCode() {\n         return attributes != null ? attributes.hashCode() : 0;\n     }\n-    \n+\n }\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n public class Comment extends Node {\n     private static final String COMMENT_KEY = \"comment\";\n \n+    /**\n+     Create a new comment node.\n+     @param data The contents of the comment\n+     @param baseUri base URI\n+     */\n     public Comment(String data, String baseUri) {\n         super(baseUri);\n         attributes.put(COMMENT_KEY, data);\n         return \"#comment\";\n     }\n \n+    /**\n+     Get the contents of the comment.\n+     @return comment content\n+     */\n     public String getData() {\n         return attributes.get(COMMENT_KEY);\n     }\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n public class DataNode extends Node{\n     private static final String DATA_KEY = \"data\";\n \n+    /**\n+     Create a new DataNode.\n+     @param data data contents\n+     @param baseUri base URI\n+     */\n     public DataNode(String data, String baseUri) {\n         super(baseUri);\n         attributes.put(DATA_KEY, data);\n         return \"#data\";\n     }\n \n+    /**\n+     Get the data contents of this node. Will be unescaped and with original new lines, space etc.\n+     @return data\n+     */\n     public String getWholeData() {\n         return attributes.get(DATA_KEY);\n     }\n         return outerHtml();\n     }\n \n+    /**\n+     Create a new DataNode from HTML encoded data.\n+     @param encodedData encoded data\n+     @param baseUri bass URI\n+     @return new DataNode\n+     */\n     public static DataNode createFromEncoded(String encodedData, String baseUri) {\n         String data = StringEscapeUtils.unescapeHtml(encodedData);\n         return new DataNode(data, baseUri);\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n import org.jsoup.parser.Tag;\n \n /**\n- Document element.\n+ A HTML Document.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class Document extends Element {\n \n+    /**\n+     Create a new, empty Document.\n+     @param baseUri base URI of document\n+     @see org.jsoup.Jsoup#parse\n+     @see #createShell\n+     */\n     public Document(String baseUri) {\n         super(Tag.valueOf(\"#root\"), baseUri);\n     }\n \n     /**\n-     Create a valid, empty shell of a document, suitable for adding more elements to (without parsing).\n+     Create a valid, empty shell of a document, suitable for adding more elements to.\n      @param baseUri baseUri of document\n      @return document with html, head, and body elements.\n      */\n         Validate.notNull(baseUri);\n \n         Document doc = new Document(baseUri);\n-        Element html = doc.createElement(Tag.valueOf(\"html\"));\n-        Element head = doc.createElement(Tag.valueOf(\"head\"));\n-        Element body = doc.createElement(Tag.valueOf(\"body\"));\n-\n-        doc.appendChild(html);\n-        html.appendChild(head);\n-        html.appendChild(body);\n+        Element html = doc.appendElement(\"html\");\n+        html.appendElement(\"head\");\n+        html.appendElement(\"body\");\n \n         return doc;\n     }\n \n+    /**\n+     Accessor to the document's {@code head} element.\n+     @return {@code head}\n+     */\n     public Element head() {\n         return getElementsByTag(\"head\").first();\n     }\n \n+    /**\n+     Accessor to the document's {@code body} element.\n+     @return {@code body}\n+     */\n     public Element body() {\n         return getElementsByTag(\"body\").first();\n     }\n \n+    /**\n+     Get the string contents of the document's {@code title} element.\n+     @return Trimed title, or empty string if none set.\n+     */\n     public String title() {\n         Element titleEl = getElementsByTag(\"title\").first();\n         return titleEl != null ? titleEl.text().trim() : \"\";\n     }\n \n+    /**\n+     Set the document's {@code title} element. Updates the existing element, or adds {@code title} to {@code head} if\n+     not present\n+     @param title string to set as title\n+     */\n     public void title(String title) {\n+        Validate.notNull(title);\n         Element titleEl = getElementsByTag(\"title\").first();\n         if (titleEl == null) { // add to head\n             head().appendElement(\"title\").text(title);\n         }\n     }\n \n-    public Element createElement(Tag tag) {\n-        return new Element(tag, baseUri());\n-    }\n-\n     @Override\n     public String outerHtml() {\n         return super.html(); // no outer wrapper tag\n     }\n \n+    /**\n+     Set the text of the {@code body} of this document. Any existing nodes within the body will be cleared.\n+     @param text unencoded text\n+     @return this document\n+     */\n     @Override\n     public Element text(String text) {\n         body().text(text); // overridden to not nuke doc structure\n     public String nodeName() {\n         return \"#document\";\n     }\n-    \n-    \n }\n \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import java.util.List;\n \n /**\n- Base Node model.\n+ The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public abstract class Node {\n     String baseUri;\n \n     /**\n-     Create a new node.\n+     Create a new Node.\n+     @param baseUri base URI\n+     @param attributes attributes (not null, but may be empty)\n      */\n     protected Node(String baseUri, Attributes attributes) {\n         Validate.notNull(baseUri);\n         this(baseUri, new Attributes());\n     }\n \n+    /**\n+     Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).\n+     @return node name\n+     */\n     public abstract String nodeName();\n \n     /**\n         return this;\n     }\n \n+    /**\n+     Get the base URI of this node.\n+     @return base URI\n+     */\n     public String baseUri() {\n         return baseUri;\n     }\n \n+    /**\n+     Update the base URI of this node.\n+     @param baseUri base URI to set\n+     */\n     public void setBaseUri(String baseUri) {\n         Validate.notNull(baseUri);\n         this.baseUri = baseUri;\n         }\n     }\n \n+    /**\n+     Get a child node by index\n+     @param index index of child node\n+     @return the child node at this index.\n+     */\n     public Node childNode(int index) {\n         return childNodes.get(index);\n     }\n \n+    /**\n+     Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes\n+     themselves can be manipulated.\n+     @return list of children. If no children, returns an empty list.\n+     */\n     public List<Node> childNodes() {\n         return Collections.unmodifiableList(childNodes);\n     }\n \n+    /**\n+     Gets this node's parent node.\n+     @return parent node; or null if no parent.\n+     */\n     public Node parent() {\n         return parentNode;\n     }\n             throw new NotImplementedException(\"Cannot (yet) move nodes in tree\"); // TODO: remove from prev node children\n         this.parentNode = parentNode;\n     }\n-    \n+\n+    /**\n+     Retrieves this node's sibling nodes. Effectively, {@link #childNodes()  node.parent.childNodes()}.\n+     @return node siblings, including this node\n+     */\n     public List<Node> siblingNodes() {\n-        return parent().childNodes();\n-    }\n-\n+        return parent().childNodes(); // TODO: should this strip out this node? i.e. not a sibling of self?\n+    }\n+\n+    /**\n+     Get this node's next sibling.\n+     @return next sibling, or null if this is the last sibling\n+     */\n     public Node nextSibling() {\n         List<Node> siblings = parentNode.childNodes;\n         Integer index = indexInList(this, siblings);\n             return null;\n     }\n \n+    /**\n+     Get this node's previous sibling.\n+     @return the previous sibling, or null if this is the first sibling\n+     */\n     public Node previousSibling() {\n         List<Node> siblings = parentNode.childNodes;\n         Integer index = indexInList(this, siblings);\n         return null;\n     }\n \n+    /**\n+     Get the outer HTML of this node.\n+     @return HTML\n+     */\n     public String outerHtml() {\n         StringBuilder accum = new StringBuilder();\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n+    /**\n+     Get the outer HTML of this node.\n+     @param accum accumulator to place HTML into\n+     */\n     abstract void outerHtml(StringBuilder accum);\n \n     public String toString() {\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n     private static final String TEXT_KEY = \"text\";\n \n     /**\n-     * Create a new TextNode representing the supplied (unencoded) text).\n-     * @param text raw text\n-     * @see #createFromEncoded(String, String)\n+     Create a new TextNode representing the supplied (unencoded) text).\n+\n+     @param text raw text\n+     @param baseUri base uri\n+     @see #createFromEncoded(String, String)\n      */\n     public TextNode(String text, String baseUri) {\n         super(baseUri);\n         return \"#text\";\n     }\n \n+    /**\n+     Get the (unencoded) text of this text node, including any newlines and spaces present in the original.\n+     @return text\n+     */\n     public String getWholeText() {\n         return attributes.get(TEXT_KEY);\n     }\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n     private static final String DECL_KEY = \"declaration\";\n     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n \n+    /**\n+     Create a new XML declaration\n+     @param data data\n+     @param baseUri base uri\n+     @param isProcessingInstruction is processing instruction\n+     */\n     public XmlDeclaration(String data, String baseUri, boolean isProcessingInstruction) {\n         super(baseUri);\n         attributes.put(DECL_KEY, data);\n         return \"#declaration\";\n     }\n \n+    /**\n+     Get the unencoded XML declaration.\n+     @return XML declaration\n+     */\n     public String getWholeDeclaration() {\n         return attributes.get(DECL_KEY);\n     }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/nodes/package-info.java\n+/**\n+ HTML document structure nodes.\n+ */\n+package org.jsoup.nodes;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/package-info.java\n+/**\n+ Contains the main {@link org.jsoup.Jsoup} class, which provides convenient static access to the jsoup functionality. \n+ */\n+package org.jsoup;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/package-info.java\n+/**\n+ Contains the HTML parser, tag specifications, and HTML tokeniser.\n+ */\n+package org.jsoup.parser;\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n                 destAttrs.put(sourceAttr);\n         }\n         Attributes enforcedAttrs = whitelist.getEnforcedAttributes(sourceTag);\n-        destAttrs.mergeAttributes(enforcedAttrs);\n+        destAttrs.addAll(enforcedAttrs);\n         return dest;\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/jsoup/safety/package-info.java\n+/**\n+ Contains the jsoup HMTL cleaner, and whitelist definitions.\n+ */\n+package org.jsoup.safety;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/select/package-info.java\n+/**\n+ Packages to support the CSS-style element selector.\n+ */\n+package org.jsoup.select;", "timestamp": 1309605108, "metainfo": ""}