{"sha": "231aab61e228513853d08374e188217933f70986", "log": "Replaced Strings with char array in CharacterReader, for well improved parse times.  Faster to scan, and less garbage created.", "commit": "\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n class CharacterReader {\n     static final char EOF = (char) -1;\n \n-    private final String input;\n+    private final char[] input;\n     private final int length;\n     private int pos = 0;\n     private int mark = 0;\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n-        this.input = input;\n-        this.length = input.length();\n+        this.input = input.toCharArray();\n+        this.length = this.input.length;\n     }\n \n     int pos() {\n     }\n \n     char current() {\n-        return isEmpty() ? EOF : input.charAt(pos);\n+        return isEmpty() ? EOF : input[pos];\n     }\n \n     char consume() {\n-        char val = isEmpty() ? EOF : input.charAt(pos);\n+        char val = isEmpty() ? EOF : input[pos];\n         pos++;\n         return val;\n     }\n     }\n \n     String consumeAsString() {\n-        return new String(input.substring(pos, pos++));\n+        return new String(input, pos++, 1);\n+    }\n+\n+    /**\n+     * Returns the number of characters between the current position and the next instance of the input char\n+     * @param c scan target\n+     * @return offset between current position and next instance of target. -1 if not found.\n+     */\n+    int nextIndexOf(char c) {\n+        // doesn't handle scanning for surrogates\n+        for (int i = pos; i < length; i++) {\n+            if (c == input[i])\n+                return i - pos;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Returns the number of characters between the current position and the next instance of the input sequence\n+     *\n+     * @param seq scan target\n+     * @return offset between current position and next instance of target. -1 if not found.\n+     */\n+    int nextIndexOf(CharSequence seq) {\n+        // doesn't handle scanning for surrogates\n+        char startChar = seq.charAt(0);\n+        for (int offset = pos; offset < length; offset++) {\n+            // scan to first instance of startchar:\n+            if (startChar != input[offset])\n+                while(++offset < length && startChar != input[offset]);\n+            if (offset < length) {\n+                int i = offset + 1;\n+                int last = i + seq.length()-1;\n+                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n+                if (i == last) // found full sequence\n+                    return offset - pos;\n+            }\n+        }\n+        return -1;\n     }\n \n     String consumeTo(char c) {\n-        int offset = input.indexOf(c, pos);\n+        int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = new String(input.substring(pos, offset));\n-            pos += consumed.length();\n+            String consumed = new String(input, pos, offset);\n+            pos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n     }\n \n     String consumeTo(String seq) {\n-        int offset = input.indexOf(seq, pos);\n+        int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = new String(input.substring(pos, offset));\n-            pos += consumed.length();\n+            String consumed = new String(input, pos, offset);\n+            pos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n         }\n     }\n \n-    String consumeToAny(char... seq) {\n-        int start = pos;\n-\n-        OUTER: while (!isEmpty()) {\n-            char c = input.charAt(pos);\n-            for (char seek : seq) {\n-                if (seek == c)\n+    String consumeToAny(final char... chars) {\n+        int start = pos;\n+\n+        OUTER: while (pos < length) {\n+            for (int i = 0; i < chars.length; i++) {\n+                if (input[pos] == chars[i])\n                     break OUTER;\n             }\n             pos++;\n         }\n \n-        return pos > start ? new String(input.substring(start, pos)) : \"\";\n+        return pos > start ? new String(input, start, pos-start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = new String(input.substring(pos, input.length()));\n-        pos = input.length();\n+        String data = new String(input, pos, length-pos);\n+        pos = length;\n         return data;\n     }\n \n     String consumeLetterSequence() {\n         int start = pos;\n+        while (pos < length) {\n+            char c = input[pos];\n+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n+                pos++;\n+            else\n+                break;\n+        }\n+\n+        return new String(input, start, pos - start);\n+    }\n+\n+    String consumeLetterThenDigitSequence() {\n+        int start = pos;\n+        while (pos < length) {\n+            char c = input[pos];\n+            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n+                pos++;\n+            else\n+                break;\n+        }\n         while (!isEmpty()) {\n-            char c = input.charAt(pos);\n-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n-                pos++;\n-            else\n-                break;\n-        }\n-\n-        return new String(input.substring(start, pos));\n-    }\n-\n-    String consumeLetterThenDigitSequence() {\n-        int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n-            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\n-                pos++;\n-            else\n-                break;\n-        }\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+            char c = input[pos];\n             if (c >= '0' && c <= '9')\n                 pos++;\n             else\n                 break;\n         }\n \n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     String consumeHexSequence() {\n         int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+        while (pos < length) {\n+            char c = input[pos];\n             if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n                 pos++;\n             else\n                 break;\n         }\n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     String consumeDigitSequence() {\n         int start = pos;\n-        while (!isEmpty()) {\n-            char c = input.charAt(pos);\n+        while (pos < length) {\n+            char c = input[pos];\n             if (c >= '0' && c <= '9')\n                 pos++;\n             else\n                 break;\n         }\n-        return new String(input.substring(start, pos));\n+        return new String(input, start, pos - start);\n     }\n \n     boolean matches(char c) {\n-        return !isEmpty() && input.charAt(pos) == c;\n+        return !isEmpty() && input[pos] == c;\n \n     }\n \n     boolean matches(String seq) {\n-        return input.startsWith(seq, pos);\n+        int scanLength = seq.length();\n+        if (scanLength > length - pos)\n+            return false;\n+\n+        for (int offset = 0; offset < scanLength; offset++)\n+            if (seq.charAt(offset) != input[pos+offset])\n+                return false;\n+        return true;\n     }\n \n     boolean matchesIgnoreCase(String seq) {\n-        return input.regionMatches(true, pos, seq, 0, seq.length());\n+        int scanLength = seq.length();\n+        if (scanLength > length - pos)\n+            return false;\n+\n+        for (int offset = 0; offset < scanLength; offset++) {\n+            char upScan = Character.toUpperCase(seq.charAt(offset));\n+            char upTarget = Character.toUpperCase(input[pos + offset]);\n+            if (upScan != upTarget)\n+                return false;\n+        }\n+        return true;\n     }\n \n     boolean matchesAny(char... seq) {\n         if (isEmpty())\n             return false;\n \n-        char c = input.charAt(pos);\n+        char c = input[pos];\n         for (char seek : seq) {\n             if (seek == c)\n                 return true;\n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n-        char c = input.charAt(pos);\n+        char c = input[pos];\n         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n     }\n \n     boolean matchesDigit() {\n         if (isEmpty())\n             return false;\n-        char c = input.charAt(pos);\n+        char c = input[pos];\n         return (c >= '0' && c <= '9');\n     }\n \n         // used to check presence of </title>, </style>. only finds consistent case.\n         String loScan = seq.toLowerCase(Locale.ENGLISH);\n         String hiScan = seq.toUpperCase(Locale.ENGLISH);\n-        return (input.indexOf(loScan, pos) > -1) || (input.indexOf(hiScan, pos) > -1);\n+        return (nextIndexOf(loScan) > -1) || (nextIndexOf(hiScan) > -1);\n     }\n \n     @Override\n     public String toString() {\n-        return input.substring(pos);\n+        return new String(input, pos, length - pos);\n     }\n }\n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertEquals(in, toEnd);\n         assertTrue(r.isEmpty());\n     }\n+\n+    @Test public void nextIndexOfChar() {\n+        String in = \"blah blah\";\n+        CharacterReader r = new CharacterReader(in);\n+\n+        assertEquals(-1, r.nextIndexOf('x'));\n+        assertEquals(3, r.nextIndexOf('h'));\n+        String pull = r.consumeTo('h');\n+        assertEquals(\"bla\", pull);\n+        r.consume();\n+        assertEquals(2, r.nextIndexOf('l'));\n+        assertEquals(\" blah\", r.consumeToEnd());\n+        assertEquals(-1, r.nextIndexOf('x'));\n+    }\n+\n+    @Test public void nextIndexOfString() {\n+        String in = \"One Two something Two Three Four\";\n+        CharacterReader r = new CharacterReader(in);\n+\n+        assertEquals(-1, r.nextIndexOf(\"Foo\"));\n+        assertEquals(4, r.nextIndexOf(\"Two\"));\n+        assertEquals(\"One Two \", r.consumeTo(\"something\"));\n+        assertEquals(10, r.nextIndexOf(\"Two\"));\n+        assertEquals(\"something Two Three Four\", r.consumeToEnd());\n+        assertEquals(-1, r.nextIndexOf(\"Two\"));\n+    }\n+\n+    @Test public void consumeToChar() {\n+        CharacterReader r = new CharacterReader(\"One Two Three\");\n+        assertEquals(\"One \", r.consumeTo('T'));\n+        assertEquals(\"\", r.consumeTo('T')); // on Two\n+        assertEquals('T', r.consume());\n+        assertEquals(\"wo \", r.consumeTo('T'));\n+        assertEquals('T', r.consume());\n+        assertEquals(\"hree\", r.consumeTo('T')); // consume to end\n+    }\n+\n+    @Test public void consumeToString() {\n+        CharacterReader r = new CharacterReader(\"One Two Two Four\");\n+        assertEquals(\"One \", r.consumeTo(\"Two\"));\n+        assertEquals('T', r.consume());\n+        assertEquals(\"wo \", r.consumeTo(\"Two\"));\n+        assertEquals('T', r.consume());\n+        assertEquals(\"wo Four\", r.consumeTo(\"Qux\"));\n+    }\n+\n+    @Test public void advance() {\n+        CharacterReader r = new CharacterReader(\"One Two Three\");\n+        assertEquals('O', r.consume());\n+        r.advance();\n+        assertEquals('e', r.consume());\n+    }\n+\n+    @Test public void consumeToAny() {\n+        CharacterReader r = new CharacterReader(\"One &bar; qux\");\n+        assertEquals(\"One \", r.consumeToAny('&', ';'));\n+        assertTrue(r.matches('&'));\n+        assertTrue(r.matches(\"&bar;\"));\n+        assertEquals('&', r.consume());\n+        assertEquals(\"bar\", r.consumeToAny('&', ';'));\n+        assertEquals(';', r.consume());\n+        assertEquals(\" qux\", r.consumeToAny('&', ';'));\n+    }\n+\n+    @Test public void consumeLetterSequence() {\n+        CharacterReader r = new CharacterReader(\"One &bar; qux\");\n+        assertEquals(\"One\", r.consumeLetterSequence());\n+        assertEquals(\" &\", r.consumeTo(\"bar;\"));\n+        assertEquals(\"bar\", r.consumeLetterSequence());\n+        assertEquals(\"; qux\", r.consumeToEnd());\n+    }\n+\n+    @Test public void consumeLetterThenDigitSequence() {\n+        CharacterReader r = new CharacterReader(\"One12 Two &bar; qux\");\n+        assertEquals(\"One12\", r.consumeLetterThenDigitSequence());\n+        assertEquals(' ', r.consume());\n+        assertEquals(\"Two\", r.consumeLetterThenDigitSequence());\n+        assertEquals(\" &bar; qux\", r.consumeToEnd());\n+    }\n+\n+    @Test public void matches() {\n+        CharacterReader r = new CharacterReader(\"One Two Three\");\n+        assertTrue(r.matches('O'));\n+        assertTrue(r.matches(\"One Two Three\"));\n+        assertTrue(r.matches(\"One\"));\n+        assertFalse(r.matches(\"one\"));\n+        assertEquals('O', r.consume());\n+        assertFalse(r.matches(\"One\"));\n+        assertTrue(r.matches(\"ne Two Three\"));\n+        assertFalse(r.matches(\"ne Two Three Four\"));\n+        assertEquals(\"ne Two Three\", r.consumeToEnd());\n+        assertFalse(r.matches(\"ne\"));\n+    }\n+\n+    @Test\n+    public void matchesIgnoreCase() {\n+        CharacterReader r = new CharacterReader(\"One Two Three\");\n+        assertTrue(r.matchesIgnoreCase(\"O\"));\n+        assertTrue(r.matchesIgnoreCase(\"o\"));\n+        assertTrue(r.matches('O'));\n+        assertFalse(r.matches('o'));\n+        assertTrue(r.matchesIgnoreCase(\"One Two Three\"));\n+        assertTrue(r.matchesIgnoreCase(\"ONE two THREE\"));\n+        assertTrue(r.matchesIgnoreCase(\"One\"));\n+        assertTrue(r.matchesIgnoreCase(\"one\"));\n+        assertEquals('O', r.consume());\n+        assertFalse(r.matchesIgnoreCase(\"One\"));\n+        assertTrue(r.matchesIgnoreCase(\"NE Two Three\"));\n+        assertFalse(r.matchesIgnoreCase(\"ne Two Three Four\"));\n+        assertEquals(\"ne Two Three\", r.consumeToEnd());\n+        assertFalse(r.matchesIgnoreCase(\"ne\"));\n+    }\n+\n+    @Test public void containsIgnoreCase() {\n+        CharacterReader r = new CharacterReader(\"One TWO three\");\n+        assertTrue(r.containsIgnoreCase(\"two\"));\n+        assertTrue(r.containsIgnoreCase(\"three\"));\n+        // weird one: does not find one, because it scans for consistent case only\n+        assertFalse(r.containsIgnoreCase(\"one\"));\n+    }\n+\n+    @Test public void matchesAny() {\n+        char[] scan = {' ', '\\n', '\\t'};\n+        CharacterReader r = new CharacterReader(\"One\\nTwo\\tThree\");\n+        assertFalse(r.matchesAny(scan));\n+        assertEquals(\"One\", r.consumeToAny(scan));\n+        assertTrue(r.matchesAny(scan));\n+        assertEquals('\\n', r.consume());\n+        assertFalse(r.matchesAny(scan));\n+    }\n+\n }", "timestamp": 1338774254, "metainfo": ""}