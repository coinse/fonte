{"sha": "a0493b9732636879b4d06538787f74e2757cd92a", "log": "New code that can split an AVL tree into two AVL trees.  This is in preparation for a new feature where LinkedTreeMap will have multiple roots, each in its own hash bucket.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n import java.io.Serializable;\n import java.util.AbstractMap;\n import java.util.AbstractSet;\n+import java.util.ArrayDeque;\n import java.util.Comparator;\n import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n     final K key;\n     V value;\n     int height;\n+    int hash;\n \n     /** Create the header entry */\n     Node() {\n     }\n   }\n \n+  /**\n+   * Returns a new array containing the same nodes as {@code oldTable}, but with\n+   * twice as many trees, each of (approximately) half the previous size.\n+   */\n+  static <K, V> Node<K, V>[] doubleCapacity(Node<K, V>[] oldTable) {\n+    // TODO: don't do anything if we're already at MAX_CAPACITY\n+    int oldCapacity = oldTable.length;\n+    @SuppressWarnings(\"unchecked\") // Arrays and generics don't get along.\n+    Node<K, V>[] newTable = new Node[oldCapacity * 2];\n+    AvlIterator<K, V> iterator = new AvlIterator<K, V>();\n+    AvlBuilder<K, V> leftBuilder = new AvlBuilder<K, V>();\n+    AvlBuilder<K, V> rightBuilder = new AvlBuilder<K, V>();\n+\n+    // Split each tree into two trees.\n+    for (int i = 0; i < oldCapacity; i++) {\n+      Node<K, V> root = oldTable[i];\n+      if (root == null) {\n+        continue;\n+      }\n+\n+      // Compute the sizes of the left and right trees.\n+      iterator.reset(root);\n+      int leftSize = 0;\n+      int rightSize = 0;\n+      while (iterator.hasNext()) {\n+        Node<K, V> node = iterator.next();\n+        if ((node.hash & oldCapacity) == 0) {\n+          leftSize++;\n+        } else {\n+          rightSize++;\n+        }\n+      }\n+\n+      // Split the tree into two.\n+      Node<K, V> leftRoot = null;\n+      Node<K, V> rightRoot = null;\n+      if (leftSize > 0 && rightSize > 0) {\n+        leftBuilder.reset(leftSize);\n+        rightBuilder.reset(rightSize);\n+        iterator.reset(root);\n+        while (iterator.hasNext()) {\n+          Node<K, V> node = iterator.next();\n+          if ((node.hash & oldCapacity) == 0) {\n+            leftBuilder.add(node);\n+          } else {\n+            rightBuilder.add(node);\n+          }\n+        }\n+        leftRoot = leftBuilder.root();\n+        rightRoot = rightBuilder.root();\n+      } else if (leftSize > 0) {\n+        leftRoot = root;\n+      } else {\n+        rightRoot = root;\n+      }\n+\n+      // Populate the enlarged array with these new roots.\n+      newTable[i] = leftRoot;\n+      newTable[i + oldCapacity] = rightRoot;\n+    }\n+    return newTable;\n+  }\n+\n+  /**\n+   * Walks an AVL tree in iteration order. Once a node has been returned, its\n+   * left, right and parent links are <strong>no longer used</strong>. For this\n+   * reason it is safe to transform these links as you walk a tree.\n+   */\n+  static class AvlIterator<K, V> implements Iterator<Node<K, V>> {\n+    private final ArrayDeque<Node<K, V>> stack = new ArrayDeque<Node<K, V>>();\n+\n+    void reset(Node<K, V> root) {\n+      stack.clear();\n+      for (Node<K, V> n = root; n != null; n = n.left) {\n+        stack.add(n);\n+      }\n+    }\n+\n+    public boolean hasNext() {\n+      return !stack.isEmpty();\n+    }\n+\n+    public Node<K, V> next() {\n+      Node<K, V> node = stack.removeLast();\n+      for (Node<K, V> n = node.right; n != null; n = n.left) {\n+        stack.add(n);\n+      }\n+      return node;\n+    }\n+\n+    public void remove() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+\n+  /**\n+   * Builds AVL trees of a predetermined size by accepting nodes of increasing\n+   * value. To use:\n+   * <ol>\n+   *   <li>Call {@link #reset} to initialize the target size <i>size</i>.\n+   *   <li>Call {@link #add} <i>size</i> times with increasing values.\n+   *   <li>Call {@link #root} to get the root of the balanced tree.\n+   * </ol>\n+   *\n+   * <p>The returned tree will satisfy the AVL constraint: for every node\n+   * <i>N</i>, the height of <i>N.left</i> and <i>N.right</i> is different by at\n+   * most 1. It accomplishes this by omitting deepest-level leaf nodes when\n+   * building trees whose size isn't a power of 2 minus 1.\n+   *\n+   * <p>Unlike rebuilding a tree from scratch, this approach requires no value\n+   * comparisons. Using this class to create a tree of size <i>S</i> is\n+   * {@code O(S)}.\n+   */\n+  static class AvlBuilder<K, V> {\n+    private final ArrayDeque<Node<K, V>> stack = new ArrayDeque<Node<K, V>>();\n+    private int leavesToSkip;\n+    private int leavesSkipped;\n+    private int size;\n+\n+    void reset(int targetSize) {\n+      // compute the target tree size. This is a power of 2 minus one, like 15 or 31.\n+      int treeCapacity = Integer.highestOneBit(targetSize) * 2 - 1;\n+      leavesToSkip = treeCapacity - targetSize;\n+      size = 0;\n+      leavesSkipped = 0;\n+      stack.clear();\n+    }\n+\n+    void add(Node<K, V> node) {\n+      node.left = node.parent = node.right = null;\n+      node.height = 1;\n+\n+      // Skip a leaf if necessary.\n+      if (leavesToSkip > 0 && (size & 1) == 0) {\n+        size++;\n+        leavesToSkip--;\n+        leavesSkipped++;\n+      }\n+\n+      stack.addLast(node);\n+      size++;\n+\n+      // Skip a leaf if necessary.\n+      if (leavesToSkip > 0 && (size & 1) == 0) {\n+        size++;\n+        leavesToSkip--;\n+        leavesSkipped++;\n+      }\n+\n+      /*\n+       * Combine 3 nodes into subtrees whenever the size is one less than a\n+       * multiple of 4. For example we combine the nodes A, B, C into a\n+       * 3-element tree with B as the root.\n+       *\n+       * Combine two subtrees and a spare single value whenever the size is one\n+       * less than a multiple of 8. For example at 8 we may combine subtrees\n+       * (A B C) and (E F G) with D as the root to form ((A B C) D (E F G)).\n+       *\n+       * Just as we combine single nodes when size nears a multiple of 4, and\n+       * 3-element trees when size nears a multiple of 8, we combine subtrees of\n+       * size (N-1) whenever the total size is 2N-1 whenever N is a power of 2.\n+       */\n+      int centerHeight = 2;\n+      for (int scale = 4; (size & scale - 1) == scale - 1; scale *= 2) {\n+        if (leavesSkipped == 0) {\n+          Node<K, V> right = stack.removeLast();\n+          Node<K, V> center = stack.removeLast();\n+          Node<K, V> left = stack.removeLast();\n+          center.left = left;\n+          left.parent = center;\n+          center.right = right;\n+          right.parent = center;\n+          center.height = centerHeight;\n+          stack.addLast(center);\n+        } else if (leavesSkipped == 1) {\n+          Node<K, V> right = stack.removeLast();\n+          Node<K, V> center = stack.removeLast();\n+          center.right = right;\n+          center.height = centerHeight;\n+          center.height++;\n+          stack.addLast(center);\n+          leavesSkipped = 0;\n+        } else if (leavesSkipped == 2) {\n+          leavesSkipped = 0;\n+        }\n+        centerHeight++;\n+      }\n+    }\n+\n+    Node<K, V> root() {\n+      if (stack.size() != 1) {\n+        throw new IllegalStateException();\n+      }\n+      return stack.getLast();\n+    }\n+  }\n+\n   private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {\n     Node<K, V> next = header.next;\n     Node<K, V> lastReturned = null;\n--- a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n \n package com.google.gson.internal;\n \n+import com.google.gson.internal.LinkedTreeMap.AvlBuilder;\n+import com.google.gson.internal.LinkedTreeMap.Node;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Iterator;\n     }\n   }\n \n+  public void testAvlWalker() {\n+    assertAvlWalker(node(node(\"a\"), \"b\", node(\"c\")),\n+        \"a\", \"b\", \"c\");\n+    assertAvlWalker(node(node(node(\"a\"), \"b\", node(\"c\")), \"d\", node(node(\"e\"), \"f\", node(\"g\"))),\n+        \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\");\n+    assertAvlWalker(node(node(null, \"a\", node(\"b\")), \"c\", node(node(\"d\"), \"e\", null)),\n+        \"a\", \"b\", \"c\", \"d\", \"e\");\n+    assertAvlWalker(node(null, \"a\", node(null, \"b\", node(null, \"c\", node(\"d\")))),\n+        \"a\", \"b\", \"c\", \"d\");\n+    assertAvlWalker(node(node(node(node(\"a\"), \"b\", null), \"c\", null), \"d\", null),\n+        \"a\", \"b\", \"c\", \"d\");\n+  }\n+\n+  private void assertAvlWalker(Node<String, String> root, String... values) {\n+    LinkedTreeMap.AvlIterator<String, String> iterator = new LinkedTreeMap.AvlIterator<String, String>();\n+    iterator.reset(root);\n+    for (String value : values) {\n+      assertTrue(iterator.hasNext());\n+      assertEquals(value, iterator.next().getKey());\n+    }\n+    assertFalse(iterator.hasNext());\n+  }\n+\n+  public void testAvlBuilder() {\n+    assertAvlBuilder(1, \"a\");\n+    assertAvlBuilder(2, \"(. a b)\");\n+    assertAvlBuilder(3, \"(a b c)\");\n+    assertAvlBuilder(4, \"(a b (. c d))\");\n+    assertAvlBuilder(5, \"(a b (c d e))\");\n+    assertAvlBuilder(6, \"((. a b) c (d e f))\");\n+    assertAvlBuilder(7, \"((a b c) d (e f g))\");\n+    assertAvlBuilder(8, \"((a b c) d (e f (. g h)))\");\n+    assertAvlBuilder(9, \"((a b c) d (e f (g h i)))\");\n+    assertAvlBuilder(10, \"((a b c) d ((. e f) g (h i j)))\");\n+    assertAvlBuilder(11, \"((a b c) d ((e f g) h (i j k)))\");\n+    assertAvlBuilder(12, \"((a b (. c d)) e ((f g h) i (j k l)))\");\n+    assertAvlBuilder(13, \"((a b (c d e)) f ((g h i) j (k l m)))\");\n+    assertAvlBuilder(14, \"(((. a b) c (d e f)) g ((h i j) k (l m n)))\");\n+    assertAvlBuilder(15, \"(((a b c) d (e f g)) h ((i j k) l (m n o)))\");\n+    assertAvlBuilder(16, \"(((a b c) d (e f g)) h ((i j k) l (m n (. o p))))\");\n+    assertAvlBuilder(30, \"((((. a b) c (d e f)) g ((h i j) k (l m n))) o \"\n+        + \"(((p q r) s (t u v)) w ((x y z) A (B C D))))\");\n+    assertAvlBuilder(31, \"((((a b c) d (e f g)) h ((i j k) l (m n o))) p \"\n+        + \"(((q r s) t (u v w)) x ((y z A) B (C D E))))\");\n+  }\n+\n+  private void assertAvlBuilder(int size, String expected) {\n+    char[] values = \"abcdefghijklmnopqrstuvwxyzABCDE\".toCharArray();\n+    AvlBuilder<String, String> avlBuilder = new AvlBuilder<String, String>();\n+    avlBuilder.reset(size);\n+    for (int i = 0; i < size; i++) {\n+      avlBuilder.add(node(Character.toString(values[i])));\n+    }\n+    assertEquals(expected, toString(avlBuilder.root()));\n+  }\n+\n+  public void testDoubleCapacity() {\n+    @SuppressWarnings(\"unchecked\") // Arrays and generics don't get along.\n+    Node<String, String>[] oldTable = new Node[1];\n+    oldTable[0] = node(node(node(\"a\"), \"b\", node(\"c\")), \"d\", node(node(\"e\"), \"f\", node(\"g\")));\n+\n+    Node<String, String>[] newTable = LinkedTreeMap.doubleCapacity(oldTable);\n+    assertEquals(\"(b d f)\", toString(newTable[0])); // Even hash codes!\n+    assertEquals(\"(a c (. e g))\", toString(newTable[1])); // Odd hash codes!\n+  }\n+\n+  private static final Node<String, String> head = new Node<String, String>();\n+\n+  private Node<String, String> node(String value) {\n+    Node<String, String> result = new Node<String, String>(null, value, head, head);\n+    result.hash = value.hashCode();\n+    return result;\n+  }\n+\n+  private Node<String, String> node(Node<String, String> left, String value,\n+      Node<String, String> right) {\n+    Node<String, String> result = node(value);\n+    if (left != null) {\n+      result.left = left;\n+      left.parent = result;\n+    }\n+    if (right != null) {\n+      result.right = right;\n+      right.parent = result;\n+    }\n+    return result;\n+  }\n+\n+  private String toString(Node<?, ?> root) {\n+    if (root == null) {\n+      return \".\";\n+    } else if (root.left == null && root.right == null) {\n+      return String.valueOf(root.key);\n+    } else {\n+      return String.format(\"(%s %s %s)\", toString(root.left), root.key, toString(root.right));\n+    }\n+  }\n+\n   private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {\n     ArrayList<T> actualList = new ArrayList<T>();\n     for (T t : actual) {", "timestamp": 1347689613, "metainfo": ""}