{"sha": "0c7e39981975fa88fbab012d42047ba5bc9522fd", "log": "Merge pull request #818 from google/gsoncontext_refactoring  moved the JsonSerializationContext/JsonDeserializationContext fields \u2026", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   private final boolean generateNonExecutableJson;\n   private final boolean prettyPrinting;\n   private final boolean lenient;\n-\n-  final JsonDeserializationContext deserializationContext = new JsonDeserializationContext() {\n-    @SuppressWarnings(\"unchecked\")\n-    @Override public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n-      return (T) fromJson(json, typeOfT);\n-    }\n-  };\n-\n-  final JsonSerializationContext serializationContext = new JsonSerializationContext() {\n-    @Override public JsonElement serialize(Object src) {\n-      return toJsonTree(src);\n-    }\n-    @Override public JsonElement serialize(Object src, Type typeOfSrc) {\n-      return toJsonTree(src, typeOfSrc);\n-    }\n-  };\n \n   /**\n    * Constructs a Gson object with default configuration. The default configuration has the\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Excluder;\n+import com.google.gson.internal.bind.TreeTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TreeTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.Streams;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the\n+ * tree adapter may be serialization-only or deserialization-only, this class\n+ * has a facility to lookup a delegate type adapter on demand.\n+ */\n+public final class TreeTypeAdapter<T> extends TypeAdapter<T> {\n+  private final JsonSerializer<T> serializer;\n+  private final JsonDeserializer<T> deserializer;\n+  private final Gson gson;\n+  private final TypeToken<T> typeToken;\n+  private final TypeAdapterFactory skipPast;\n+  private final GsonContextImpl context = new GsonContextImpl();\n+\n+  /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n+  private TypeAdapter<T> delegate;\n+\n+  public TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n+      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n+    this.serializer = serializer;\n+    this.deserializer = deserializer;\n+    this.gson = gson;\n+    this.typeToken = typeToken;\n+    this.skipPast = skipPast;\n+  }\n+\n+  @Override public T read(JsonReader in) throws IOException {\n+    if (deserializer == null) {\n+      return delegate().read(in);\n+    }\n+    JsonElement value = Streams.parse(in);\n+    if (value.isJsonNull()) {\n+      return null;\n+    }\n+    return deserializer.deserialize(value, typeToken.getType(), context);\n+  }\n+\n+  @Override public void write(JsonWriter out, T value) throws IOException {\n+    if (serializer == null) {\n+      delegate().write(out, value);\n+      return;\n+    }\n+    if (value == null) {\n+      out.nullValue();\n+      return;\n+    }\n+    JsonElement tree = serializer.serialize(value, typeToken.getType(), context);\n+    Streams.write(tree, out);\n+  }\n+\n+  private TypeAdapter<T> delegate() {\n+    TypeAdapter<T> d = delegate;\n+    return d != null\n+        ? d\n+        : (delegate = gson.getDelegateAdapter(skipPast, typeToken));\n+  }\n+\n+  /**\n+   * Returns a new factory that will match each type against {@code exactType}.\n+   */\n+  public static TypeAdapterFactory newFactory(TypeToken<?> exactType, Object typeAdapter) {\n+    return new SingleTypeFactory(typeAdapter, exactType, false, null);\n+  }\n+\n+  /**\n+   * Returns a new factory that will match each type and its raw type against\n+   * {@code exactType}.\n+   */\n+  public static TypeAdapterFactory newFactoryWithMatchRawType(\n+      TypeToken<?> exactType, Object typeAdapter) {\n+    // only bother matching raw types if exact type is a raw type\n+    boolean matchRawType = exactType.getType() == exactType.getRawType();\n+    return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\n+  }\n+\n+  /**\n+   * Returns a new factory that will match each type's raw type for assignability\n+   * to {@code hierarchyType}.\n+   */\n+  public static TypeAdapterFactory newTypeHierarchyFactory(\n+      Class<?> hierarchyType, Object typeAdapter) {\n+    return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\n+  }\n+\n+  private static final class SingleTypeFactory implements TypeAdapterFactory {\n+    private final TypeToken<?> exactType;\n+    private final boolean matchRawType;\n+    private final Class<?> hierarchyType;\n+    private final JsonSerializer<?> serializer;\n+    private final JsonDeserializer<?> deserializer;\n+\n+    SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, boolean matchRawType,\n+        Class<?> hierarchyType) {\n+      serializer = typeAdapter instanceof JsonSerializer\n+          ? (JsonSerializer<?>) typeAdapter\n+          : null;\n+      deserializer = typeAdapter instanceof JsonDeserializer\n+          ? (JsonDeserializer<?>) typeAdapter\n+          : null;\n+      $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);\n+      this.exactType = exactType;\n+      this.matchRawType = matchRawType;\n+      this.hierarchyType = hierarchyType;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") // guarded by typeToken.equals() call\n+    @Override\n+    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+      boolean matches = exactType != null\n+          ? exactType.equals(type) || matchRawType && exactType.getType() == type.getRawType()\n+          : hierarchyType.isAssignableFrom(type.getRawType());\n+      return matches\n+          ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,\n+              (JsonDeserializer<T>) deserializer, gson, type, this)\n+          : null;\n+    }\n+  }\n+\n+  private final class GsonContextImpl implements JsonSerializationContext, JsonDeserializationContext {\n+    @Override public JsonElement serialize(Object src) {\n+      return gson.toJsonTree(src);\n+    }\n+    @Override public JsonElement serialize(Object src, Type typeOfSrc) {\n+      return gson.toJsonTree(src, typeOfSrc);\n+    }\n+    @SuppressWarnings(\"unchecked\")\n+    @Override public <R> R deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n+      return (R) gson.fromJson(json, typeOfT);\n+    }\n+  };\n+}", "timestamp": 1459207202, "metainfo": ""}