{"sha": "d7fbac03844aa86dbb1c65a8ba50ac364c4b2050", "log": "Rename TypeAdapter.Factory to TypeAdapterFactory.", "commit": "\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapterFactory.java\n \n import com.google.gson.Gson;\n import com.google.gson.JsonElement;\n+import com.google.gson.JsonIOException;\n import com.google.gson.JsonObject;\n import com.google.gson.JsonParseException;\n import com.google.gson.JsonPrimitive;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.internal.Streams;\n+import com.google.gson.internal.bind.JsonElementWriter;\n+import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n  *       .registerSubtype(Diamond.class);\n  * }</pre>\n  */\n-public final class RuntimeTypeAdapterFactory<T> implements TypeAdapter.Factory {\n+public final class RuntimeTypeAdapterFactory<T> implements TypeAdapterFactory {\n   private final Class<?> baseType;\n   private final String typeFieldName;\n   private final Map<String, Class<?>> labelToSubtype = new LinkedHashMap<String, Class<?>>();\n           throw new JsonParseException(\"cannot deserialize \" + baseType + \" subtype named \"\n               + label + \"; did you forget to register a subtype?\");\n         }\n-        return delegate.fromJsonTree(jsonElement);\n+        return fromJsonTree(delegate, jsonElement);\n+      }\n+\n+      // TODO: remove this when TypeAdapter.fromJsonTree() is public\n+      private T fromJsonTree(TypeAdapter<T> delegate, JsonElement jsonTree) {\n+        try {\n+          JsonReader jsonReader = new JsonTreeReader(jsonTree);\n+          jsonReader.setLenient(true);\n+          return delegate.read(jsonReader);\n+        } catch (IOException e) {\n+          throw new JsonIOException(e);\n+        }\n       }\n \n       @Override public void write(JsonWriter out, T value) throws IOException {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \"; did you forget to register a subtype?\");\n         }\n-        JsonObject jsonObject = delegate.toJsonTree(value).getAsJsonObject();\n+        JsonObject jsonObject = toJsonTree(delegate, value).getAsJsonObject();\n         if (jsonObject.has(typeFieldName)) {\n           throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n               + \" because it already defines a field named \" + typeFieldName);\n         }\n         Streams.write(clone, out);\n       }\n+\n+      // TODO: remove this when TypeAdapter.toJsonTree() is public\n+      private JsonElement toJsonTree(TypeAdapter<T> delegate, T value) {\n+        try {\n+          JsonElementWriter jsonWriter = new JsonElementWriter();\n+          jsonWriter.setLenient(true);\n+          delegate.write(jsonWriter, value);\n+          return jsonWriter.get();\n+        } catch (IOException e) {\n+          throw new JsonIOException(e);\n+        }\n+      }\n     };\n   }\n }\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   private final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache\n       = Collections.synchronizedMap(new HashMap<TypeToken<?>, TypeAdapter<?>>());\n \n-  private final List<TypeAdapter.Factory> factories;\n+  private final List<TypeAdapterFactory> factories;\n   private final ConstructorConstructor constructorConstructor;\n \n   private final boolean serializeNulls;\n     this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n         Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\n         true, false, false, LongSerializationPolicy.DEFAULT,\n-        Collections.<TypeAdapter.Factory>emptyList());\n+        Collections.<TypeAdapterFactory>emptyList());\n   }\n \n   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n       boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n       LongSerializationPolicy longSerializationPolicy,\n-      List<TypeAdapter.Factory> typeAdapterFactories) {\n+      List<TypeAdapterFactory> typeAdapterFactories) {\n     this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n     this.serializeNulls = serializeNulls;\n     this.generateNonExecutableJson = generateNonExecutableGson;\n     this.htmlSafe = htmlSafe;\n     this.prettyPrinting = prettyPrinting;\n \n-    TypeAdapter.Factory reflectiveTypeAdapterFactory = new ReflectiveTypeAdapterFactory(\n+    TypeAdapterFactory reflectiveTypeAdapterFactory = new ReflectiveTypeAdapterFactory(\n         constructorConstructor, fieldNamingPolicy, excluder);\n \n     ConstructorConstructor constructorConstructor = new ConstructorConstructor();\n-    List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n \n     // built-in type adapters that cannot be overridden\n     factories.add(TypeAdapters.STRING_FACTORY);\n     FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n     threadCalls.put(type, call);\n     try {\n-      for (TypeAdapter.Factory factory : factories) {\n+      for (TypeAdapterFactory factory : factories) {\n         TypeAdapter<T> candidate = factory.create(this, type);\n         if (candidate != null) {\n           call.setDelegate(candidate);\n    *     deserialize {@code type}.\n    * @since 2.1\n    */\n-  public <T> TypeAdapter<T> getNextAdapter(TypeAdapter.Factory skipPast, TypeToken<T> type) {\n+  public <T> TypeAdapter<T> getNextAdapter(TypeAdapterFactory skipPast, TypeToken<T> type) {\n     boolean skipPastFound = false;\n \n-    for (TypeAdapter.Factory factory : factories) {\n+    for (TypeAdapterFactory factory : factories) {\n       if (!skipPastFound) {\n         if (factory == skipPast) {\n           skipPastFound = true;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\n   private final Map<Type, InstanceCreator<?>> instanceCreators\n       = new HashMap<Type, InstanceCreator<?>>();\n-  private final List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+  private final List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n   /** tree-style hierarchy factories. These come after factories for backwards compatibility. */\n-  private final List<TypeAdapter.Factory> hierarchyFactories = new ArrayList<TypeAdapter.Factory>();\n+  private final List<TypeAdapterFactory> hierarchyFactories = new ArrayList<TypeAdapterFactory>();\n   private boolean serializeNulls;\n   private String datePattern;\n   private int dateStyle = DateFormat.DEFAULT;\n    *\n    * @since 2.1\n    */\n-  public GsonBuilder registerTypeAdapterFactory(TypeAdapter.Factory factory) {\n+  public GsonBuilder registerTypeAdapterFactory(TypeAdapterFactory factory) {\n     factories.add(factory);\n     return this;\n   }\n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    List<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n     factories.addAll(this.factories);\n     Collections.reverse(factories);\n     factories.addAll(this.hierarchyFactories);\n   }\n \n   private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n-      List<TypeAdapter.Factory> factories) {\n+      List<TypeAdapterFactory> factories) {\n     DefaultDateTypeAdapter dateTypeAdapter;\n     if (datePattern != null && !\"\".equals(datePattern.trim())) {\n       dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n   private final JsonDeserializer<T> deserializer;\n   private final Gson gson;\n   private final TypeToken<T> typeToken;\n-  private final Factory skipPast;\n+  private final TypeAdapterFactory skipPast;\n \n   /** The delegate is lazily created because it may not be needed, and creating it may fail. */\n   private TypeAdapter<T> delegate;\n \n   private TreeTypeAdapter(JsonSerializer<T> serializer, JsonDeserializer<T> deserializer,\n-      Gson gson, TypeToken<T> typeToken, Factory skipPast) {\n+      Gson gson, TypeToken<T> typeToken, TypeAdapterFactory skipPast) {\n     this.serializer = serializer;\n     this.deserializer = deserializer;\n     this.gson = gson;\n   /**\n    * Returns a new factory that will match each type against {@code exactType}.\n    */\n-  public static Factory newFactory(TypeToken<?> exactType, Object typeAdapter) {\n+  public static TypeAdapterFactory newFactory(TypeToken<?> exactType, Object typeAdapter) {\n     return new SingleTypeFactory(typeAdapter, exactType, false, null);\n   }\n \n    * Returns a new factory that will match each type and its raw type against\n    * {@code exactType}.\n    */\n-  public static Factory newFactoryWithMatchRawType(TypeToken<?> exactType, Object typeAdapter) {\n+  public static TypeAdapterFactory newFactoryWithMatchRawType(\n+      TypeToken<?> exactType, Object typeAdapter) {\n     // only bother matching raw types if exact type is a raw type\n     boolean matchRawType = exactType.getType() == exactType.getRawType();\n     return new SingleTypeFactory(typeAdapter, exactType, matchRawType, null);\n    * Returns a new factory that will match each type's raw type for assignability\n    * to {@code hierarchyType}.\n    */\n-  public static Factory newTypeHierarchyFactory(Class<?> hierarchyType, Object typeAdapter) {\n+  public static TypeAdapterFactory newTypeHierarchyFactory(\n+      Class<?> hierarchyType, Object typeAdapter) {\n     return new SingleTypeFactory(typeAdapter, null, false, hierarchyType);\n   }\n \n-  private static class SingleTypeFactory implements TypeAdapter.Factory {\n+  private static class SingleTypeFactory implements TypeAdapterFactory {\n     private final TypeToken<?> exactType;\n     private final boolean matchRawType;\n     private final Class<?> hierarchyType;\n--- a/gson/src/main/java/com/google/gson/TypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TypeAdapter.java\n       throw new JsonIOException(e);\n     }\n   }\n-\n-  /**\n-   * Creates type adapters for set of related types. Type adapter factories are\n-   * most useful when several types share similar structure in their JSON form.\n-   *\n-   * <h3>Example: Converting enums to lowercase</h3>\n-   * In this example, we implement a factory that creates type adapters for all\n-   * enums. The type adapters will write enums in lowercase, despite the fact\n-   * that they're defined in {@code CONSTANT_CASE} in the corresponding Java\n-   * model: <pre>   {@code\n-   *\n-   *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapter.Factory {\n-   *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n-   *       Class<T> rawType = (Class<T>) type.getRawType();\n-   *       if (!rawType.isEnum()) {\n-   *         return null;\n-   *       }\n-   *\n-   *       final Map<String, T> lowercaseToConstant = new HashMap<String, T>();\n-   *       for (T constant : rawType.getEnumConstants()) {\n-   *         lowercaseToConstant.put(toLowercase(constant), constant);\n-   *       }\n-   *\n-   *       return new TypeAdapter<T>() {\n-   *         public void write(JsonWriter out, T value) throws IOException {\n-   *           if (value == null) {\n-   *             out.nullValue();\n-   *           } else {\n-   *             out.value(toLowercase(value));\n-   *           }\n-   *         }\n-   *\n-   *         public T read(JsonReader reader) throws IOException {\n-   *           if (reader.peek() == JsonToken.NULL) {\n-   *             reader.nextNull();\n-   *             return null;\n-   *           } else {\n-   *             return lowercaseToConstant.get(reader.nextString());\n-   *           }\n-   *         }\n-   *       };\n-   *     }\n-   *\n-   *     private String toLowercase(Object o) {\n-   *       return o.toString().toLowerCase(Locale.US);\n-   *     }\n-   *   }\n-   * }</pre>\n-   *\n-   * <p>Type adapter factories select which types they provide type adapters\n-   * for. If a factory cannot support a given type, it must return null when\n-   * that type is passed to {@link #create}. Factories should expect {@code\n-   * create()} to be called on them for many types and should return null for\n-   * most of those types. In the above example the factory returns null for\n-   * calls to {@code create()} where {@code type} is not an enum.\n-   *\n-   * <p>A factory is typically called once per type, but the returned type\n-   * adapter may be used many times. It is most efficient to do expensive work\n-   * like reflection in {@code create()} so that the type adapter's {@code\n-   * read()} and {@code write()} methods can be very fast. In this example the\n-   * mapping from lowercase name to enum value is computed eagerly.\n-   *\n-   * <p>As with type adapters, factories must be <i>registered</i> with a {@link\n-   * GsonBuilder} for them to take effect: <pre>   {@code\n-   *\n-   *  GsonBuilder builder = new GsonBuilder();\n-   *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());\n-   *  ...\n-   *  Gson gson = builder.create();\n-   * }</pre>\n-   * If multiple factories support the same type, the factory registered earlier\n-   * takes precedence.\n-   *\n-   * <h3>Example: composing other type adapters</h3>\n-   * In this example we implement a factory for Guava's {@code Multiset}\n-   * collection type. The factory can be used to create type adapters for\n-   * multisets of any element type: the type adapter for {@code\n-   * Multiset<String>} is different from the type adapter for {@code\n-   * Multiset<URL>}.\n-   *\n-   * <p>The type adapter <i>delegates</i> to another type adapter for the\n-   * multiset elements. It figures out the element type by reflecting on the\n-   * multiset's type token. A {@code Gson} is passed in to {@code create} for\n-   * just this purpose: <pre>   {@code\n-   *\n-   *   public class MultisetTypeAdapterFactory implements TypeAdapter.Factory {\n-   *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n-   *       Type type = typeToken.getType();\n-   *       if (typeToken.getRawType() != Multiset.class\n-   *           || !(type instanceof ParameterizedType)) {\n-   *         return null;\n-   *       }\n-   *\n-   *       Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n-   *       TypeAdapter<?> elementAdapter = gson.getAdapter(TypeToken.get(elementType));\n-   *       return (TypeAdapter<T>) newMultisetAdapter(elementAdapter);\n-   *     }\n-   *\n-   *     private <E> TypeAdapter<Multiset<E>> newMultisetAdapter(\n-   *         final TypeAdapter<E> elementAdapter) {\n-   *       return new TypeAdapter<Multiset<E>>() {\n-   *         public void write(JsonWriter out, Multiset<E> value) throws IOException {\n-   *           if (value == null) {\n-   *             out.nullValue();\n-   *             return;\n-   *           }\n-   *\n-   *           out.beginArray();\n-   *           for (Multiset.Entry<E> entry : value.entrySet()) {\n-   *             out.value(entry.getCount());\n-   *             elementAdapter.write(out, entry.getElement());\n-   *           }\n-   *           out.endArray();\n-   *         }\n-   *\n-   *         public Multiset<E> read(JsonReader in) throws IOException {\n-   *           if (in.peek() == JsonToken.NULL) {\n-   *             in.nextNull();\n-   *             return null;\n-   *           }\n-   *\n-   *           Multiset<E> result = LinkedHashMultiset.create();\n-   *           in.beginArray();\n-   *           while (in.hasNext()) {\n-   *             int count = in.nextInt();\n-   *             E element = elementAdapter.read(in);\n-   *             result.add(element, count);\n-   *           }\n-   *           in.endArray();\n-   *           return result;\n-   *         }\n-   *       };\n-   *     }\n-   *   }\n-   * }</pre>\n-   * Delegating from one type adapter to another is extremely powerful; it's\n-   * the foundation of how Gson converts Java objects and collections. Whenever\n-   * possible your factory should retrieve its delegate type adapter in the\n-   * {@code create()} method; this ensures potentially-expensive type adapter\n-   * creation happens only once.\n-   *\n-   * @since 2.1\n-   */\n-  public interface Factory {\n-\n-    /**\n-     * Returns a type adapter for {@code type}, or null if this factory doesn't\n-     * support {@code type}.\n-     */\n-    <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);\n-  }\n }\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/TypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * Creates type adapters for set of related types. Type adapter factories are\n+ * most useful when several types share similar structure in their JSON form.\n+ *\n+ * <h3>Example: Converting enums to lowercase</h3>\n+ * In this example, we implement a factory that creates type adapters for all\n+ * enums. The type adapters will write enums in lowercase, despite the fact\n+ * that they're defined in {@code CONSTANT_CASE} in the corresponding Java\n+ * model: <pre>   {@code\n+ *\n+ *   public class LowercaseEnumTypeAdapterFactory implements TypeAdapter.Factory {\n+ *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+ *       Class<T> rawType = (Class<T>) type.getRawType();\n+ *       if (!rawType.isEnum()) {\n+ *         return null;\n+ *       }\n+ *\n+ *       final Map<String, T> lowercaseToConstant = new HashMap<String, T>();\n+ *       for (T constant : rawType.getEnumConstants()) {\n+ *         lowercaseToConstant.put(toLowercase(constant), constant);\n+ *       }\n+ *\n+ *       return new TypeAdapter<T>() {\n+ *         public void write(JsonWriter out, T value) throws IOException {\n+ *           if (value == null) {\n+ *             out.nullValue();\n+ *           } else {\n+ *             out.value(toLowercase(value));\n+ *           }\n+ *         }\n+ *\n+ *         public T read(JsonReader reader) throws IOException {\n+ *           if (reader.peek() == JsonToken.NULL) {\n+ *             reader.nextNull();\n+ *             return null;\n+ *           } else {\n+ *             return lowercaseToConstant.get(reader.nextString());\n+ *           }\n+ *         }\n+ *       };\n+ *     }\n+ *\n+ *     private String toLowercase(Object o) {\n+ *       return o.toString().toLowerCase(Locale.US);\n+ *     }\n+ *   }\n+ * }</pre>\n+ *\n+ * <p>Type adapter factories select which types they provide type adapters\n+ * for. If a factory cannot support a given type, it must return null when\n+ * that type is passed to {@link #create}. Factories should expect {@code\n+ * create()} to be called on them for many types and should return null for\n+ * most of those types. In the above example the factory returns null for\n+ * calls to {@code create()} where {@code type} is not an enum.\n+ *\n+ * <p>A factory is typically called once per type, but the returned type\n+ * adapter may be used many times. It is most efficient to do expensive work\n+ * like reflection in {@code create()} so that the type adapter's {@code\n+ * read()} and {@code write()} methods can be very fast. In this example the\n+ * mapping from lowercase name to enum value is computed eagerly.\n+ *\n+ * <p>As with type adapters, factories must be <i>registered</i> with a {@link\n+ * com.google.gson.GsonBuilder} for them to take effect: <pre>   {@code\n+ *\n+ *  GsonBuilder builder = new GsonBuilder();\n+ *  builder.registerTypeAdapterFactory(new LowercaseEnumTypeAdapterFactory());\n+ *  ...\n+ *  Gson gson = builder.create();\n+ * }</pre>\n+ * If multiple factories support the same type, the factory registered earlier\n+ * takes precedence.\n+ *\n+ * <h3>Example: composing other type adapters</h3>\n+ * In this example we implement a factory for Guava's {@code Multiset}\n+ * collection type. The factory can be used to create type adapters for\n+ * multisets of any element type: the type adapter for {@code\n+ * Multiset<String>} is different from the type adapter for {@code\n+ * Multiset<URL>}.\n+ *\n+ * <p>The type adapter <i>delegates</i> to another type adapter for the\n+ * multiset elements. It figures out the element type by reflecting on the\n+ * multiset's type token. A {@code Gson} is passed in to {@code create} for\n+ * just this purpose: <pre>   {@code\n+ *\n+ *   public class MultisetTypeAdapterFactory implements TypeAdapter.Factory {\n+ *     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n+ *       Type type = typeToken.getType();\n+ *       if (typeToken.getRawType() != Multiset.class\n+ *           || !(type instanceof ParameterizedType)) {\n+ *         return null;\n+ *       }\n+ *\n+ *       Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n+ *       TypeAdapter<?> elementAdapter = gson.getAdapter(TypeToken.get(elementType));\n+ *       return (TypeAdapter<T>) newMultisetAdapter(elementAdapter);\n+ *     }\n+ *\n+ *     private <E> TypeAdapter<Multiset<E>> newMultisetAdapter(\n+ *         final TypeAdapter<E> elementAdapter) {\n+ *       return new TypeAdapter<Multiset<E>>() {\n+ *         public void write(JsonWriter out, Multiset<E> value) throws IOException {\n+ *           if (value == null) {\n+ *             out.nullValue();\n+ *             return;\n+ *           }\n+ *\n+ *           out.beginArray();\n+ *           for (Multiset.Entry<E> entry : value.entrySet()) {\n+ *             out.value(entry.getCount());\n+ *             elementAdapter.write(out, entry.getElement());\n+ *           }\n+ *           out.endArray();\n+ *         }\n+ *\n+ *         public Multiset<E> read(JsonReader in) throws IOException {\n+ *           if (in.peek() == JsonToken.NULL) {\n+ *             in.nextNull();\n+ *             return null;\n+ *           }\n+ *\n+ *           Multiset<E> result = LinkedHashMultiset.create();\n+ *           in.beginArray();\n+ *           while (in.hasNext()) {\n+ *             int count = in.nextInt();\n+ *             E element = elementAdapter.read(in);\n+ *             result.add(element, count);\n+ *           }\n+ *           in.endArray();\n+ *           return result;\n+ *         }\n+ *       };\n+ *     }\n+ *   }\n+ * }</pre>\n+ * Delegating from one type adapter to another is extremely powerful; it's\n+ * the foundation of how Gson converts Java objects and collections. Whenever\n+ * possible your factory should retrieve its delegate type adapter in the\n+ * {@code create()} method; this ensures potentially-expensive type adapter\n+ * creation happens only once.\n+ *\n+ * @since 2.1\n+ */\n+public interface TypeAdapterFactory {\n+\n+  /**\n+   * Returns a type adapter for {@code type}, or null if this factory doesn't\n+   * support {@code type}.\n+   */\n+  <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type);\n+}\n--- a/gson/src/main/java/com/google/gson/internal/Excluder.java\n+++ b/gson/src/main/java/com/google/gson/internal/Excluder.java\n import com.google.gson.FieldAttributes;\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.annotations.Expose;\n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n  * @author Joel Leitch\n  * @author Jesse Wilson\n  */\n-public final class Excluder implements TypeAdapter.Factory, Cloneable {\n+public final class Excluder implements TypeAdapterFactory, Cloneable {\n   private static final double IGNORE_VERSIONS = -1.0d;\n   public static final Excluder DEFAULT = new Excluder();\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n \n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import java.io.IOException;\n import java.lang.reflect.Array;\n import java.lang.reflect.GenericArrayType;\n  * Adapt an array of objects.\n  */\n public final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n-  public static final Factory FACTORY = new Factory() {\n+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n     @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       Type type = typeToken.getType();\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n \n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.ObjectConstructor;\n /**\n  * Adapt a homogeneous collection of objects.\n  */\n-public final class CollectionTypeAdapterFactory implements TypeAdapter.Factory {\n+public final class CollectionTypeAdapterFactory implements TypeAdapterFactory {\n   private final ConstructorConstructor constructorConstructor;\n \n   public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/DateTypeAdapter.java\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n  * to synchronize its read and write methods.\n  */\n public final class DateTypeAdapter extends TypeAdapter<Date> {\n-  public static final Factory FACTORY = new Factory() {\n+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n import com.google.gson.JsonPrimitive;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.JsonReaderInternalAccess;\n  * This format will serialize and deserialize just fine as long as this adapter\n  * is registered.\n  */\n-public final class MapTypeAdapterFactory implements TypeAdapter.Factory {\n+public final class MapTypeAdapterFactory implements TypeAdapterFactory {\n   private final ConstructorConstructor constructorConstructor;\n   private final boolean complexMapKeySerialization;\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n \n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n  * serialization and a primitive/Map/List on deserialization.\n  */\n public final class ObjectTypeAdapter extends TypeAdapter<Object> {\n-  public static final Factory FACTORY = new Factory() {\n+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n     @SuppressWarnings(\"unchecked\")\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n       if (type.getRawType() == Object.class) {\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.annotations.SerializedName;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.internal.ConstructorConstructor;\n /**\n  * Type adapter that reflects over the fields and methods of a class.\n  */\n-public final class ReflectiveTypeAdapterFactory implements TypeAdapter.Factory {\n+public final class ReflectiveTypeAdapterFactory implements TypeAdapterFactory {\n   private final ConstructorConstructor constructorConstructor;\n   private final FieldNamingStrategy fieldNamingPolicy;\n   private final Excluder excluder;\n--- a/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/SqlDateTypeAdapter.java\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n  * to synchronize its read and write methods.\n  */\n public final class SqlDateTypeAdapter extends TypeAdapter<java.sql.Date> {\n-  public static final Factory FACTORY = new Factory() {\n+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == java.sql.Date.class\n--- a/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TimeTypeAdapter.java\n import com.google.gson.Gson;\n import com.google.gson.JsonSyntaxException;\n import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n  * to synchronize its read and write methods.\n  */\n public final class TimeTypeAdapter extends TypeAdapter<Time> {\n-  public static final Factory FACTORY = new Factory() {\n+  public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       return typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n \n package com.google.gson.internal.bind;\n \n+import com.google.gson.TypeAdapterFactory;\n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.URI;\n           \"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n \t}\n   };\n-  public static final TypeAdapter.Factory CLASS_FACTORY = newFactory(Class.class, CLASS);\n+  public static final TypeAdapterFactory CLASS_FACTORY = newFactory(Class.class, CLASS);\n \n   public static final TypeAdapter<BitSet> BIT_SET = new TypeAdapter<BitSet>() {\n     public BitSet read(JsonReader in) throws IOException {\n     }\n   };\n \n-  public static final TypeAdapter.Factory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n+  public static final TypeAdapterFactory BIT_SET_FACTORY = newFactory(BitSet.class, BIT_SET);\n \n   public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n     @Override\n     }\n   };\n \n-  public static final TypeAdapter.Factory BOOLEAN_FACTORY\n+  public static final TypeAdapterFactory BOOLEAN_FACTORY\n       = newFactory(boolean.class, Boolean.class, BOOLEAN);\n \n   public static final TypeAdapter<Number> BYTE = new TypeAdapter<Number>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory BYTE_FACTORY\n+  public static final TypeAdapterFactory BYTE_FACTORY\n       = newFactory(byte.class, Byte.class, BYTE);\n \n   public static final TypeAdapter<Number> SHORT = new TypeAdapter<Number>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory SHORT_FACTORY\n+  public static final TypeAdapterFactory SHORT_FACTORY\n       = newFactory(short.class, Short.class, SHORT);\n \n   public static final TypeAdapter<Number> INTEGER = new TypeAdapter<Number>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory INTEGER_FACTORY\n+  public static final TypeAdapterFactory INTEGER_FACTORY\n       = newFactory(int.class, Integer.class, INTEGER);\n \n   public static final TypeAdapter<Number> LONG = new TypeAdapter<Number>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n+  public static final TypeAdapterFactory NUMBER_FACTORY = newFactory(Number.class, NUMBER);\n \n   public static final TypeAdapter<Character> CHARACTER = new TypeAdapter<Character>() {\n     @Override\n     }\n   };\n \n-  public static final TypeAdapter.Factory CHARACTER_FACTORY\n+  public static final TypeAdapterFactory CHARACTER_FACTORY\n       = newFactory(char.class, Character.class, CHARACTER);\n \n   public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory STRING_FACTORY = newFactory(String.class, STRING);\n+  public static final TypeAdapterFactory STRING_FACTORY = newFactory(String.class, STRING);\n \n   public static final TypeAdapter<StringBuilder> STRING_BUILDER = new TypeAdapter<StringBuilder>() {\n     @Override\n     }\n   };\n \n-  public static final TypeAdapter.Factory STRING_BUILDER_FACTORY =\n+  public static final TypeAdapterFactory STRING_BUILDER_FACTORY =\n     newFactory(StringBuilder.class, STRING_BUILDER);\n \n   public static final TypeAdapter<StringBuffer> STRING_BUFFER = new TypeAdapter<StringBuffer>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory STRING_BUFFER_FACTORY =\n+  public static final TypeAdapterFactory STRING_BUFFER_FACTORY =\n     newFactory(StringBuffer.class, STRING_BUFFER);\n \n   public static final TypeAdapter<URL> URL = new TypeAdapter<URL>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory URL_FACTORY = newFactory(URL.class, URL);\n+  public static final TypeAdapterFactory URL_FACTORY = newFactory(URL.class, URL);\n \n   public static final TypeAdapter<URI> URI = new TypeAdapter<URI>() {\n     @Override\n     }\n   };\n \n-  public static final TypeAdapter.Factory URI_FACTORY = newFactory(URI.class, URI);\n+  public static final TypeAdapterFactory URI_FACTORY = newFactory(URI.class, URI);\n \n   public static final TypeAdapter<InetAddress> INET_ADDRESS = new TypeAdapter<InetAddress>() {\n     @Override\n     }\n   };\n \n-  public static final TypeAdapter.Factory INET_ADDRESS_FACTORY =\n+  public static final TypeAdapterFactory INET_ADDRESS_FACTORY =\n     newTypeHierarchyFactory(InetAddress.class, INET_ADDRESS);\n \n   public static final TypeAdapter<UUID> UUID = new TypeAdapter<UUID>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory UUID_FACTORY = newFactory(UUID.class, UUID);\n-\n-  public static final TypeAdapter.Factory TIMESTAMP_FACTORY = new TypeAdapter.Factory() {\n+  public static final TypeAdapterFactory UUID_FACTORY = newFactory(UUID.class, UUID);\n+\n+  public static final TypeAdapterFactory TIMESTAMP_FACTORY = new TypeAdapterFactory() {\n     @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n     public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n       if (typeToken.getRawType() != Timestamp.class) {\n     }\n   };\n \n-  public static final TypeAdapter.Factory CALENDAR_FACTORY =\n+  public static final TypeAdapterFactory CALENDAR_FACTORY =\n     newFactoryForMultipleTypes(Calendar.class, GregorianCalendar.class, CALENDAR);\n \n   public static final TypeAdapter<Locale> LOCALE = new TypeAdapter<Locale>() {\n     }\n   };\n \n-  public static final TypeAdapter.Factory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n+  public static final TypeAdapterFactory LOCALE_FACTORY = newFactory(Locale.class, LOCALE);\n \n   public static final TypeAdapter<JsonElement> JSON_ELEMENT = new TypeAdapter<JsonElement>() {\n     @Override public JsonElement read(JsonReader in) throws IOException {\n     }\n   };\n \n-  public static final TypeAdapter.Factory JSON_ELEMENT_FACTORY\n+  public static final TypeAdapterFactory JSON_ELEMENT_FACTORY\n       = newFactory(JsonElement.class, JSON_ELEMENT);\n \n   private static final class EnumTypeAdapter<T extends Enum<T>> extends TypeAdapter<T> {\n     }\n   }\n \n-  public static final TypeAdapter.Factory ENUM_FACTORY = newEnumTypeHierarchyFactory();\n-\n-  public static <TT> TypeAdapter.Factory newEnumTypeHierarchyFactory() {\n-    return new TypeAdapter.Factory() {\n+  public static final TypeAdapterFactory ENUM_FACTORY = newEnumTypeHierarchyFactory();\n+\n+  public static <TT> TypeAdapterFactory newEnumTypeHierarchyFactory() {\n+    return new TypeAdapterFactory() {\n       @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n     };\n   }\n \n-  public static <TT> TypeAdapter.Factory newFactory(\n+  public static <TT> TypeAdapterFactory newFactory(\n       final TypeToken<TT> type, final TypeAdapter<TT> typeAdapter) {\n-    return new TypeAdapter.Factory() {\n+    return new TypeAdapterFactory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n     };\n   }\n \n-  public static <TT> TypeAdapter.Factory newFactory(\n+  public static <TT> TypeAdapterFactory newFactory(\n       final Class<TT> type, final TypeAdapter<TT> typeAdapter) {\n-    return new TypeAdapter.Factory() {\n+    return new TypeAdapterFactory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n     };\n   }\n \n-  public static <TT> TypeAdapter.Factory newFactory(\n+  public static <TT> TypeAdapterFactory newFactory(\n       final Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\n-    return new TypeAdapter.Factory() {\n+    return new TypeAdapterFactory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n     };\n   }\n \n-  public static <TT> TypeAdapter.Factory newFactoryForMultipleTypes(\n-      final Class<TT> base, final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n-    return new TypeAdapter.Factory() {\n+  public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\n+      final Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\n+    return new TypeAdapterFactory() {\n       @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         Class<? super T> rawType = typeToken.getRawType();\n     };\n   }\n \n-  public static <TT> TypeAdapter.Factory newTypeHierarchyFactory(\n+  public static <TT> TypeAdapterFactory newTypeHierarchyFactory(\n       final Class<TT> clazz, final TypeAdapter<TT> typeAdapter) {\n-    return new TypeAdapter.Factory() {\n+    return new TypeAdapterFactory() {\n       @SuppressWarnings(\"unchecked\")\n       public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\n         return clazz.isAssignableFrom(typeToken.getRawType()) ? (TypeAdapter<T>) typeAdapter : null;", "timestamp": 1324664833, "metainfo": ""}