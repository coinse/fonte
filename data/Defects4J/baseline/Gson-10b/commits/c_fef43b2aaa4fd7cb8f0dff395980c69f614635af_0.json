{"sha": "fef43b2aaa4fd7cb8f0dff395980c69f614635af", "log": "Added support to serialize/deserialize ConcurrentMap and ConcurrentNavigableMap.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n  */\n \n package com.google.gson.internal;\n-\n-import com.google.gson.InstanceCreator;\n-import com.google.gson.JsonIOException;\n-import com.google.gson.reflect.TypeToken;\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.util.SortedSet;\n import java.util.TreeMap;\n import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n+import com.google.gson.InstanceCreator;\n+import com.google.gson.JsonIOException;\n+import com.google.gson.reflect.TypeToken;\n \n /**\n  * Returns a function that can construct an instance of a requested type.\n     final InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\n     if (typeCreator != null) {\n       return new ObjectConstructor<T>() {\n-        public T construct() {\n+        @Override public T construct() {\n           return typeCreator.createInstance(type);\n         }\n       };\n         (InstanceCreator<T>) instanceCreators.get(rawType);\n     if (rawTypeCreator != null) {\n       return new ObjectConstructor<T>() {\n-        public T construct() {\n+        @Override public T construct() {\n           return rawTypeCreator.createInstance(type);\n         }\n       };\n       }\n       return new ObjectConstructor<T>() {\n         @SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n-        public T construct() {\n+        @Override public T construct() {\n           try {\n             Object[] args = null;\n             return (T) constructor.newInstance(args);\n     if (Collection.class.isAssignableFrom(rawType)) {\n       if (SortedSet.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n-          public T construct() {\n+          @Override public T construct() {\n             return (T) new TreeSet<Object>();\n           }\n         };\n       } else if (EnumSet.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n           @SuppressWarnings(\"rawtypes\")\n-          public T construct() {\n+          @Override public T construct() {\n             if (type instanceof ParameterizedType) {\n               Type elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\n               if (elementType instanceof Class) {\n         };\n       } else if (Set.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n-          public T construct() {\n+          @Override public T construct() {\n             return (T) new LinkedHashSet<Object>();\n           }\n         };\n       } else if (Queue.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n-          public T construct() {\n+          @Override public T construct() {\n             return (T) new LinkedList<Object>();\n           }\n         };\n       } else {\n         return new ObjectConstructor<T>() {\n-          public T construct() {\n+          @Override public T construct() {\n             return (T) new ArrayList<Object>();\n           }\n         };\n     }\n \n     if (Map.class.isAssignableFrom(rawType)) {\n-      if (SortedMap.class.isAssignableFrom(rawType)) {\n-        return new ObjectConstructor<T>() {\n-          public T construct() {\n+      if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n+            return (T) new ConcurrentSkipListMap<Object, Object>();\n+          }\n+        };\n+      } else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n+            return (T) new ConcurrentHashMap<Object, Object>();\n+          }\n+        };\n+      } else if (SortedMap.class.isAssignableFrom(rawType)) {\n+        return new ObjectConstructor<T>() {\n+          @Override public T construct() {\n             return (T) new TreeMap<Object, Object>();\n           }\n         };\n       } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n           TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n         return new ObjectConstructor<T>() {\n-          public T construct() {\n+          @Override public T construct() {\n             return (T) new LinkedHashMap<Object, Object>();\n           }\n         };\n       } else {\n         return new ObjectConstructor<T>() {\n-          public T construct() {\n+          @Override public T construct() {\n             return (T) new LinkedTreeMap<String, Object>();\n           }\n         };\n     return new ObjectConstructor<T>() {\n       private final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n       @SuppressWarnings(\"unchecked\")\n-      public T construct() {\n+      @Override public T construct() {\n         try {\n           Object newInstance = unsafeAllocator.newInstance(rawType);\n           return (T) newInstance;\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n \n package com.google.gson.functional;\n \n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.InstanceCreator;\n \n import junit.framework.TestCase;\n \n-import java.lang.reflect.Type;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.SortedMap;\n-import java.util.TreeMap;\n-\n /**\n  * Functional test for Json serialization and deserialization for Maps\n  *\n     assertEquals(1, map.size());\n     assertTrue(map.containsKey(123));\n     assertEquals(\"456\", map.get(123));\n+  }\n+\n+  public void testConcurrentMap() throws Exception {\n+    Type typeOfMap = new TypeToken<ConcurrentMap<Integer, String>>() {}.getType();\n+    ConcurrentMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n+    assertEquals(1, map.size());\n+    assertTrue(map.containsKey(123));\n+    assertEquals(\"456\", map.get(123));\n+    String json = gson.toJson(map);\n+    assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n+  }\n+\n+  public void testConcurrentHashMap() throws Exception {\n+    Type typeOfMap = new TypeToken<ConcurrentHashMap<Integer, String>>() {}.getType();\n+    ConcurrentHashMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n+    assertEquals(1, map.size());\n+    assertTrue(map.containsKey(123));\n+    assertEquals(\"456\", map.get(123));\n+    String json = gson.toJson(map);\n+    assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n+  }\n+\n+  public void testConcurrentNavigableMap() throws Exception {\n+    Type typeOfMap = new TypeToken<ConcurrentNavigableMap<Integer, String>>() {}.getType();\n+    ConcurrentNavigableMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n+    assertEquals(1, map.size());\n+    assertTrue(map.containsKey(123));\n+    assertEquals(\"456\", map.get(123));\n+    String json = gson.toJson(map);\n+    assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n+  }\n+\n+  public void testConcurrentSkipListMap() throws Exception {\n+    Type typeOfMap = new TypeToken<ConcurrentSkipListMap<Integer, String>>() {}.getType();\n+    ConcurrentSkipListMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n+    assertEquals(1, map.size());\n+    assertTrue(map.containsKey(123));\n+    assertEquals(\"456\", map.get(123));\n+    String json = gson.toJson(map);\n+    assertEquals(\"{\\\"123\\\":\\\"456\\\"}\", json);\n   }\n \n   public void testParameterizedMapSubclassSerialization() {", "timestamp": 1446701115, "metainfo": ""}