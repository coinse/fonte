{"sha": "0e3708be82830ab1862cc8c752e9efa841e0fae7", "log": "updated UTC type adapter to support JDK 1.6 using Jackson ISO8601 parsing util", "commit": "\n--- a/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/UtcDateTypeAdapter.java\n import java.io.IOException;\n import java.text.DateFormat;\n import java.text.ParseException;\n+import java.text.ParsePosition;\n import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n import java.util.Date;\n+import java.util.GregorianCalendar;\n import java.util.Locale;\n import java.util.TimeZone;\n \n \n public final class UtcDateTypeAdapter extends TypeAdapter<Date> {\n   private final DateFormat iso8601Format;\n+  private final TimeZone UTC_TIME_ZONE = TimeZone.getTimeZone(\"UTC\");\n \n   public UtcDateTypeAdapter() {\n-    this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", Locale.US);\n-    this.iso8601Format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-  }\n-\n-  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n-  // See issue 162\n+    this(false);\n+  }\n+\n+  public UtcDateTypeAdapter(boolean jdk6Compatible) {\n+    if (jdk6Compatible) {\n+      this.iso8601Format = null;\n+    } else {\n+      // XXX is only supported by JDK 1.7+\n+      this.iso8601Format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\", Locale.US);\n+      this.iso8601Format.setTimeZone(UTC_TIME_ZONE);\n+    }\n+  }\n+\n   @Override\n-  public synchronized void write(JsonWriter out, Date date) throws IOException {\n+  public void write(JsonWriter out, Date date) throws IOException {\n     if (date == null) {\n       out.nullValue();\n     }\n-    out.value(iso8601Format.format(date));\n-  }\n-\n-  // These methods need to be synchronized since JDK DateFormat classes are not thread-safe\n-  // See issue 162\n+    String value = null;\n+    if (iso8601Format != null) {\n+      synchronized (iso8601Format) {\n+        // Need synchronization since JDK DateFormat classes are not thread-safe\n+        try {\n+          value = iso8601Format.format(date);\n+        } catch (Exception e) {\n+          value = null;\n+        }\n+      }\n+    }\n+    if (value == null) { // Try other formatter\n+      value = format(date, true, UTC_TIME_ZONE);\n+    }\n+    out.value(value);\n+  }\n+\n   @Override\n-  public synchronized Date read(JsonReader in) throws IOException {\n+  public Date read(JsonReader in) throws IOException {\n     try {\n       switch (in.peek()) {\n-      case NULL: return null;\n-      default: return iso8601Format.parse(in.nextString());\n+      case NULL:\n+        in.nextNull();\n+        return null;\n+      default:\n+        String date = in.nextString();\n+        if (iso8601Format != null) {\n+          synchronized (iso8601Format) {\n+            // Need synchronization since JDK DateFormat classes are not thread-safe\n+            try {\n+              return iso8601Format.parse(date);\n+            } catch (Exception e) {\n+              // Ignore and try the other parser\n+            }\n+          }\n+        }\n+        // Instead of using iso8601Format.parse(value), we use Jackson's date parsing\n+        // This is because Android doesn't support XXX because it is JDK 1.6\n+        return parse(date, new ParsePosition(0));\n       }\n     } catch (ParseException e) {\n       throw new JsonParseException(e);\n     }\n   }\n+\n+  // Date parsing code from Jackson databind ISO8601Utils.java\n+  // https://github.com/FasterXML/jackson-databind/blob/master/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+  private static final String GMT_ID = \"GMT\";\n+\n+  /**\n+   * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+   *\n+   * @param date the date to format\n+   * @param millis true to include millis precision otherwise false\n+   * @param tz timezone to use for the formatting (GMT will produce 'Z')\n+   * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+   */\n+  private static String format(Date date, boolean millis, TimeZone tz) {\n+      Calendar calendar = new GregorianCalendar(tz, Locale.US);\n+      calendar.setTime(date);\n+\n+      // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n+      int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n+      capacity += millis ? \".sss\".length() : 0;\n+      capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n+      StringBuilder formatted = new StringBuilder(capacity);\n+\n+      padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n+      formatted.append('-');\n+      padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n+      formatted.append('-');\n+      padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n+      formatted.append('T');\n+      padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n+      formatted.append(':');\n+      padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n+      formatted.append(':');\n+      padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n+      if (millis) {\n+          formatted.append('.');\n+          padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n+      }\n+\n+      int offset = tz.getOffset(calendar.getTimeInMillis());\n+      if (offset != 0) {\n+          int hours = Math.abs((offset / (60 * 1000)) / 60);\n+          int minutes = Math.abs((offset / (60 * 1000)) % 60);\n+          formatted.append(offset < 0 ? '-' : '+');\n+          padInt(formatted, hours, \"hh\".length());\n+          formatted.append(':');\n+          padInt(formatted, minutes, \"mm\".length());\n+      } else {\n+          formatted.append('Z');\n+      }\n+\n+      return formatted.toString();\n+  }\n+  /**\n+   * Zero pad a number to a specified length\n+   *\n+   * @param buffer buffer to use for padding\n+   * @param value the integer value to pad if necessary.\n+   * @param length the length of the string we should zero pad\n+   */\n+  private static void padInt(StringBuilder buffer, int value, int length) {\n+      String strValue = Integer.toString(value);\n+      for (int i = length - strValue.length(); i > 0; i--) {\n+          buffer.append('0');\n+      }\n+      buffer.append(strValue);\n+  }\n+\n+  /**\n+   * Parse a date from ISO-8601 formatted string. It expects a format\n+   * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+   *\n+   * @param date ISO string to parse in the appropriate format.\n+   * @param pos The position to start parsing from, updated to where parsing stopped.\n+   * @return the parsed date\n+   * @throws ParseException if the date is not in the appropriate format\n+   */\n+  private static Date parse(String date, ParsePosition pos) throws ParseException {\n+    Exception fail = null;\n+    try {\n+      int offset = pos.getIndex();\n+\n+      // extract year\n+      int year = parseInt(date, offset, offset += 4);\n+      if (checkOffset(date, offset, '-')) {\n+        offset += 1;\n+      }\n+\n+      // extract month\n+      int month = parseInt(date, offset, offset += 2);\n+      if (checkOffset(date, offset, '-')) {\n+        offset += 1;\n+      }\n+\n+      // extract day\n+      int day = parseInt(date, offset, offset += 2);\n+      // default time value\n+      int hour = 0;\n+      int minutes = 0;\n+      int seconds = 0;\n+      int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n+      if (checkOffset(date, offset, 'T')) {\n+\n+        // extract hours, minutes, seconds and milliseconds\n+        hour = parseInt(date, offset += 1, offset += 2);\n+        if (checkOffset(date, offset, ':')) {\n+          offset += 1;\n+        }\n+\n+        minutes = parseInt(date, offset, offset += 2);\n+        if (checkOffset(date, offset, ':')) {\n+          offset += 1;\n+        }\n+        // second and milliseconds can be optional\n+        if (date.length() > offset) {\n+          char c = date.charAt(offset);\n+          if (c != 'Z' && c != '+' && c != '-') {\n+            seconds = parseInt(date, offset, offset += 2);\n+            // milliseconds can be optional in the format\n+            if (checkOffset(date, offset, '.')) {\n+              milliseconds = parseInt(date, offset += 1, offset += 3);\n+            }\n+          }\n+        }\n+      }\n+\n+      // extract timezone\n+      String timezoneId;\n+      if (date.length() <= offset) {\n+        throw new IllegalArgumentException(\"No time zone indicator\");\n+      }\n+      char timezoneIndicator = date.charAt(offset);\n+      if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+        String timezoneOffset = date.substring(offset);\n+        timezoneId = GMT_ID + timezoneOffset;\n+        offset += timezoneOffset.length();\n+      } else if (timezoneIndicator == 'Z') {\n+        timezoneId = GMT_ID;\n+        offset += 1;\n+      } else {\n+        throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneIndicator);\n+      }\n+\n+      TimeZone timezone = TimeZone.getTimeZone(timezoneId);\n+      if (!timezone.getID().equals(timezoneId)) {\n+        throw new IndexOutOfBoundsException();\n+      }\n+\n+      Calendar calendar = new GregorianCalendar(timezone);\n+      calendar.setLenient(false);\n+      calendar.set(Calendar.YEAR, year);\n+      calendar.set(Calendar.MONTH, month - 1);\n+      calendar.set(Calendar.DAY_OF_MONTH, day);\n+      calendar.set(Calendar.HOUR_OF_DAY, hour);\n+      calendar.set(Calendar.MINUTE, minutes);\n+      calendar.set(Calendar.SECOND, seconds);\n+      calendar.set(Calendar.MILLISECOND, milliseconds);\n+\n+      pos.setIndex(offset);\n+      return calendar.getTime();\n+      // If we get a ParseException it'll already have the right message/offset.\n+      // Other exception types can convert here.\n+    } catch (IndexOutOfBoundsException e) {\n+      fail = e;\n+    } catch (NumberFormatException e) {\n+      fail = e;\n+    } catch (IllegalArgumentException e) {\n+      fail = e;\n+    }\n+    String input = (date == null) ? null : ('\"' + date + \"'\");\n+    throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\n+  }\n+\n+  /**\n+   * Check if the expected character exist at the given offset in the value.\n+   *\n+   * @param value the string to check at the specified offset\n+   * @param offset the offset to look for the expected character\n+   * @param expected the expected character\n+   * @return true if the expected character exist at the given offset\n+   */\n+  private static boolean checkOffset(String value, int offset, char expected) {\n+    return (offset < value.length()) && (value.charAt(offset) == expected);\n+  }\n+\n+  /**\n+   * Parse an integer located between 2 given offsets in a string\n+   *\n+   * @param value the string to parse\n+   * @param beginIndex the start index for the integer in the string\n+   * @param endIndex the end index for the integer in the string\n+   * @return the int\n+   * @throws NumberFormatException if the value is not a number\n+   */\n+  private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n+    if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n+      throw new NumberFormatException(value);\n+    }\n+    // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n+    int i = beginIndex;\n+    int result = 0;\n+    int digit;\n+    if (i < endIndex) {\n+      digit = Character.digit(value.charAt(i++), 10);\n+      if (digit < 0) {\n+        throw new NumberFormatException(\"Invalid number: \" + value);\n+      }\n+      result = -digit;\n+    }\n+    while (i < endIndex) {\n+      digit = Character.digit(value.charAt(i++), 10);\n+      if (digit < 0) {\n+        throw new NumberFormatException(\"Invalid number: \" + value);\n+      }\n+      result *= 10;\n+      result -= digit;\n+    }\n+    return -result;\n+  }\n }\n--- a/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java\n+++ b/extras/src/test/java/com/google/gson/typeadapters/UtcDateTypeAdapterTest.java\n       assertEquals(expected.getTime(), actual.getTime());\n     }\n   }\n+\n+  /**\n+   * JDK 1.7 introduced support for XXX format to indicate UTC date. But Android is older JDK.\n+   * We want to make sure that this date is parseable in Android.\n+   */\n+  public void testUtcDatesOnJdkBefore1_7() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(Date.class, new UtcDateTypeAdapter(true))\n+      .create();\n+    gson.fromJson(\"'2014-12-05T04:00:00.000Z'\", Date.class);\n+  }\n }", "timestamp": 1417765268, "metainfo": ""}