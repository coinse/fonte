{"sha": "8d5a41329ec2f4db3aed02c20d379baf92840b37", "log": "added tests for Throwable. Revised ReflectiveTypeAdapterFactory to ignore self-referencing fields.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n  */\n \n package com.google.gson;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n-import com.google.gson.internal.bind.ThrowableTypeAdapterFactory;\n import com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.StringReader;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n     factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n     factories.add(TypeAdapters.ENUM_FACTORY);\n-    factories.add(new ThrowableTypeAdapterFactory(fieldNamingPolicy, excluder));\n     factories.add(new ReflectiveTypeAdapterFactory(\n         constructorConstructor, fieldNamingPolicy, excluder));\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n           field.set(value, fieldValue);\n         }\n       }\n+      public boolean writeField(Object value) throws IOException, IllegalAccessException {\n+        if (!serialized) return false;\n+        Object fieldValue = field.get(value);\n+        return fieldValue != value; // avoid recursion for example for Throwable.cause\n+      }\n     };\n   }\n \n       this.serialized = serialized;\n       this.deserialized = deserialized;\n     }\n-\n+    abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\n     abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n     abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n   }\n       out.beginObject();\n       try {\n         for (BoundField boundField : boundFields.values()) {\n-          if (boundField.serialized) {\n+          if (boundField.writeField(value)) {\n             out.name(boundField.name);\n             boundField.write(out, value);\n           }\n--- a/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CircularReferenceTest.java\n     }\n   }\n \n-  public void testSelfReferenceSerialization() throws Exception {\n+  public void testSelfReferenceIgnoredInSerialization() throws Exception {\n     ClassOverridingEquals objA = new ClassOverridingEquals();\n     objA.ref = objA;\n \n-    try {\n-      gson.toJson(objA);\n-      fail(\"Circular reference to self can not be serialized!\");\n-    } catch (StackOverflowError expected) {\n-    }\n+    String json = gson.toJson(objA);\n+    assertFalse(json.contains(\"ref\")); // self-reference is ignored\n   }\n \n   public void testSelfReferenceArrayFieldSerialization() throws Exception {\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/ThrowableFunctionalTest.java\n+// Copyright (C) 2014 Trymph Inc.\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.annotations.SerializedName;\n+\n+@SuppressWarnings(\"serial\")\n+public final class ThrowableFunctionalTest extends TestCase {\n+  private final Gson gson = new Gson();\n+\n+  public void testExceptionWithoutCause() {\n+    RuntimeException e = new RuntimeException(\"hello\");\n+    String json = gson.toJson(e);\n+    assertTrue(json.contains(\"hello\"));\n+\n+    e = gson.fromJson(\"{'detailMessage':'hello'}\", RuntimeException.class);\n+    assertEquals(\"hello\", e.getMessage());\n+  }\n+\n+  public void testExceptionWithCause() {\n+    Exception e = new Exception(\"top level\", new IOException(\"io error\"));\n+    String json = gson.toJson(e);\n+    assertEquals(\"{\\\"detailMessage\\\":\\\"top level\\\",\\\"cause\\\":{\\\"detailMessage\\\":\\\"io error\\\"}}\", json);\n+\n+    e = gson.fromJson(\"{'detailMessage':'top level','cause':{'detailMessage':'io error'}}\", Exception.class);\n+    assertEquals(\"top level\", e.getMessage());\n+    assertTrue(e.getCause() instanceof Throwable); // cause is not parameterized so type info is lost\n+    assertEquals(\"io error\", e.getCause().getMessage());\n+  }\n+\n+  public void testSerializedNameOnExceptionFields() {\n+    MyException e = new MyException();\n+    String json = gson.toJson(e);\n+    assertEquals(\"{\\\"my_custom_name\\\":\\\"myCustomMessageValue\\\"}\", json);\n+  }\n+\n+  public void testErrorWithoutCause() {\n+    OutOfMemoryError e = new OutOfMemoryError(\"hello\");\n+    String json = gson.toJson(e);\n+    assertTrue(json.contains(\"hello\"));\n+\n+    e = gson.fromJson(\"{'detailMessage':'hello'}\", OutOfMemoryError.class);\n+    assertEquals(\"hello\", e.getMessage());\n+  }\n+\n+  public void testErrornWithCause() {\n+    Error e = new Error(\"top level\", new IOException(\"io error\"));\n+    String json = gson.toJson(e);\n+    assertTrue(json.contains(\"top level\"));\n+    assertTrue(json.contains(\"io error\"));\n+\n+    e = gson.fromJson(\"{'detailMessage':'top level','cause':{'detailMessage':'io error'}}\", Error.class);\n+    assertEquals(\"top level\", e.getMessage());\n+    assertTrue(e.getCause() instanceof Throwable); // cause is not parameterized so type info is lost\n+    assertEquals(\"io error\", e.getCause().getMessage());\n+  }\n+\n+  private static final class MyException extends Throwable {\n+    @SerializedName(\"my_custom_name\") String myCustomMessage = \"myCustomMessageValue\";\n+  }\n+}", "timestamp": 1416178518, "metainfo": ""}