{"sha": "c8bd121db2b382cc0e15d317b19178e6db373d9b", "log": "Renamed $Preconditions to $Gson$Preconditions and $Types to $Gson$Types. Marked the two private classes in $Types as final.", "commit": "\n--- a/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n    *         is null or empty.\n    */\n   public CamelCaseSeparatorNamingPolicy(String separatorString) {\n-    $Preconditions.checkNotNull(separatorString);\n-    $Preconditions.checkArgument(!\"\".equals(separatorString));\n+    $Gson$Preconditions.checkNotNull(separatorString);\n+    $Gson$Preconditions.checkArgument(!\"\".equals(separatorString));\n     this.separatorString = separatorString;\n   }\n \n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.math.BigDecimal;\n       JsonArray array = new JsonArray();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        Class<?> rawTypeOfSrc = $Types.getRawType(typeOfSrc);\n-        childGenericType = $Types.getCollectionElementType(typeOfSrc, rawTypeOfSrc);\n+        Class<?> rawTypeOfSrc = $Gson$Types.getRawType(typeOfSrc);\n+        childGenericType = $Gson$Types.getCollectionElementType(typeOfSrc, rawTypeOfSrc);\n       }\n       for (Object child : src) {\n         if (child == null) {\n       // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Collection.\n       Collection collection = constructCollectionType(typeOfT, context);\n-      Type childType = $Types.getCollectionElementType(typeOfT, $Types.getRawType(typeOfT));\n+      Type childType = $Gson$Types.getCollectionElementType(typeOfT, $Gson$Types.getRawType(typeOfT));\n       for (JsonElement childElement : json.getAsJsonArray()) {\n         if (childElement == null || childElement.isJsonNull()) {\n           collection.add(null);\n     }\n \n     public T createInstance(Type type) {\n-      Class<?> rawType = $Types.getRawType(type);\n+      Class<?> rawType = $Gson$Types.getRawType(type);\n       try {\n         T specificInstance = (T) allocator.newInstance(rawType);\n         return (specificInstance == null)\n--- a/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n+++ b/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.io.IOException;\n \n   private final JsonElementVisitor delegate;\n \n   protected DelegatingJsonElementVisitor(JsonElementVisitor delegate) {\n-    this.delegate = $Preconditions.checkNotNull(delegate);\n+    this.delegate = $Gson$Preconditions.checkNotNull(delegate);\n   }\n \n   public void endArray(JsonArray array) throws IOException {\n--- a/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.util.Collection;\n \n   private final Collection<ExclusionStrategy> strategies;\n \n   DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\n-    this.strategies = $Preconditions.checkNotNull(strategies);\n+    this.strategies = $Gson$Preconditions.checkNotNull(strategies);\n   }\n \n   public boolean shouldSkipField(FieldAttributes f) {\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n   private Collection<Annotation> annotations;\n \n   FieldAttributes(Class<?> declaringClazz, Field f) {\n-    this.declaringClazz = $Preconditions.checkNotNull(declaringClazz);\n+    this.declaringClazz = $Gson$Preconditions.checkNotNull(declaringClazz);\n     this.name = f.getName();\n     this.declaredType = f.getType();\n     this.isSynthetic = f.isSynthetic();\n    * @param declaringType The type in which the field is declared\n    */\n   FieldAttributes(Class<?> declaringClazz, Field f, Type declaringType) {\n-    this.declaringClazz = $Preconditions.checkNotNull(declaringClazz);\n+    this.declaringClazz = $Gson$Preconditions.checkNotNull(declaringClazz);\n     this.name = f.getName();\n     this.declaredType = f.getType();\n     this.isSynthetic = f.isSynthetic();\n    * @return the type information for the field\n    */\n   static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n-    Class<?> rawType = $Types.getRawType(typeDefiningF);\n+    Class<?> rawType = $Gson$Types.getRawType(typeDefiningF);\n     if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n       // this field is unrelated to the type; the user probably omitted type information\n       return f.getGenericType();\n     }\n-    return $Types.resolve(typeDefiningF, rawType, f.getGenericType());\n+    return $Gson$Types.resolve(typeDefiningF, rawType, f.getGenericType());\n   }\n }\n--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n /**\n  * Adapts the old \"deprecated\" FieldNamingStrategy to the new {@link FieldNamingStrategy2}\n   private final FieldNamingStrategy adaptee;\n \n   public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) {\n-    this.adaptee = $Preconditions.checkNotNull(adaptee);\n+    this.adaptee = $Gson$Preconditions.checkNotNull(adaptee);\n   }\n \n   public String translateName(FieldAttributes f) {\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n package com.google.gson;\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.lang.reflect.Type;\n import java.sql.Timestamp;\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n-    $Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n+    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n             || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n    * @since 1.7\n    */\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n-    $Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n+    $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n             || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n       throw new JsonParseException(\"Expecting array found: \" + json);\n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n-    if ($Types.isArray(targetType)) {\n+    if ($Gson$Types.isArray(targetType)) {\n       // We know that we are getting back an array of the required type, so\n       // this typecasting is safe.\n-      return (T) objectConstructor.constructArray($Types.getArrayComponentType(targetType),\n+      return (T) objectConstructor.constructArray($Gson$Types.getArrayComponentType(targetType),\n           jsonArray.size());\n     }\n     // is a collection\n-    return (T) objectConstructor.construct($Types.getRawType(targetType));\n+    return (T) objectConstructor.construct($Gson$Types.getRawType(targetType));\n   }\n \n   public void visitArray(Object array, Type arrayType) {\n       if (jsonChild == null || jsonChild.isJsonNull()) {\n         child = null;\n       } else if (jsonChild instanceof JsonObject) {\n-        child = visitChildAsObject($Types.getArrayComponentType(arrayType), jsonChild);\n+        child = visitChildAsObject($Gson$Types.getArrayComponentType(arrayType), jsonChild);\n       } else if (jsonChild instanceof JsonArray) {\n-        child = visitChildAsArray($Types.getArrayComponentType(arrayType),\n+        child = visitChildAsArray($Gson$Types.getArrayComponentType(arrayType),\n             jsonChild.getAsJsonArray());\n       } else if (jsonChild instanceof JsonPrimitive) {\n-        child = visitChildAsObject($Types.getArrayComponentType(arrayType),\n+        child = visitChildAsObject($Gson$Types.getArrayComponentType(arrayType),\n             jsonChild.getAsJsonPrimitive());\n       } else {\n         throw new IllegalStateException();\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.lang.reflect.Type;\n \n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.objectConstructor = objectConstructor;\n     this.deserializers = deserializers;\n-    this.json = $Preconditions.checkNotNull(json);\n+    this.json = $Gson$Preconditions.checkNotNull(json);\n     this.context = context;\n     this.constructed = false;\n   }\n--- a/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.lang.reflect.Type;\n \n    * @throws IllegalArgumentException if {@code delegate} is {@code null}.\n    */\n   JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {\n-    this.delegate = $Preconditions.checkNotNull(delegate);\n+    this.delegate = $Gson$Preconditions.checkNotNull(delegate);\n   }\n \n   public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n--- a/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n+++ b/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n    * @throws IllegalArgumentException if the field name is an invalid JSON field name\n    */\n   public String validate(String fieldName) {\n-    $Preconditions.checkNotNull(fieldName);\n-    $Preconditions.checkArgument(!\"\".equals(fieldName.trim()));\n+    $Gson$Preconditions.checkNotNull(fieldName);\n+    $Gson$Preconditions.checkArgument(!\"\".equals(fieldName.trim()));\n \n     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName);\n     if (!matcher.matches()) {\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.io.IOException;\n import java.util.LinkedHashMap;\n     if (value == null) {\n       value = JsonNull.createJsonNull();\n     }\n-    members.put($Preconditions.checkNotNull(property), value);\n+    members.put($Gson$Preconditions.checkNotNull(property), value);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.io.IOException;\n import java.math.BigDecimal;\n       char c = ((Character) primitive).charValue();\n       this.value = String.valueOf(c);\n     } else {\n-      $Preconditions.checkArgument(primitive instanceof Number\n+      $Gson$Preconditions.checkArgument(primitive instanceof Number\n               || isPrimitiveOrString(primitive));\n       this.value = primitive;\n     }\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n   public void visitArray(Object array, Type arrayType) {\n     assignToRoot(new JsonArray());\n     int length = Array.getLength(array);\n-    Type componentType = $Types.getArrayComponentType(arrayType);\n+    Type componentType = $Gson$Types.getArrayComponentType(arrayType);\n     for (int i = 0; i < length; ++i) {\n       Object child = Array.get(array, i);\n       // we should not get more specific component type yet since it is possible\n   public boolean visitFieldUsingCustomHandler(\n       FieldAttributes f, Type declaredTypeOfField, Object parent) {\n     try {\n-      $Preconditions.checkState(root.isJsonObject());\n+      $Gson$Preconditions.checkState(root.isJsonObject());\n       Object obj = f.get(parent);\n       if (obj == null) {\n         if (serializeNulls) {\n   }\n \n   private void assignToRoot(JsonElement newRoot) {\n-    root = $Preconditions.checkNotNull(newRoot);\n+    root = $Gson$Preconditions.checkNotNull(newRoot);\n   }\n \n   private boolean isFieldNull(FieldAttributes f, Object obj) {\n--- a/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n     JsonObject map = new JsonObject();\n     Type childGenericType = null;\n     if (typeOfSrc instanceof ParameterizedType) {\n-      Class<?> rawTypeOfSrc = $Types.getRawType(typeOfSrc);\n-      childGenericType = $Types.getMapKeyAndValueTypes(typeOfSrc, rawTypeOfSrc)[1];\n+      Class<?> rawTypeOfSrc = $Gson$Types.getRawType(typeOfSrc);\n+      childGenericType = $Gson$Types.getMapKeyAndValueTypes(typeOfSrc, rawTypeOfSrc)[1];\n     }\n \n     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) {\n     // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n     // This handles cases where users are using their own subclass of Map.\n     Map<Object, Object> map = constructMapType(typeOfT, context);\n-    Type[] keyAndValueTypes = $Types.getMapKeyAndValueTypes(typeOfT, $Types.getRawType(typeOfT));\n+    Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(typeOfT, $Gson$Types.getRawType(typeOfT));\n     for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) {\n       Object key = context.deserialize(new JsonPrimitive(entry.getKey()), keyAndValueTypes[0]);\n       Object value = context.deserialize(entry.getValue(), keyAndValueTypes[1]);\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n   }\n \n   public Object constructArray(Type type, int length) {\n-    return Array.newInstance($Types.getRawType(type), length);\n+    return Array.newInstance($Gson$Types.getRawType(type), length);\n   }\n \n   @SuppressWarnings({\"unchecked\", \"cast\"})\n   private <T> T constructWithAllocators(Type typeOfT) {\n     try {\n-      Class<T> clazz = (Class<T>) $Types.getRawType(typeOfT);\n+      Class<T> clazz = (Class<T>) $Gson$Types.getRawType(typeOfT);\n       T obj = defaultConstructorAllocator.newInstance(clazz);\n       return (obj == null)\n           ? unsafeAllocator.newInstance(clazz)\n--- a/gson/src/main/java/com/google/gson/MemoryRefStack.java\n+++ b/gson/src/main/java/com/google/gson/MemoryRefStack.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.util.Stack;\n \n    * @return the object that was added\n    */\n   public ObjectTypePair push(ObjectTypePair obj) {\n-    $Preconditions.checkNotNull(obj);\n+    $Gson$Preconditions.checkNotNull(obj);\n     return stack.push(obj);\n   }\n \n--- a/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n    * @throws IllegalArgumentException if {@code modifier} is null\n    */\n   ModifyFirstLetterNamingPolicy(LetterModifier modifier) {\n-    this.letterModifier = $Preconditions.checkNotNull(modifier);\n+    this.letterModifier = $Gson$Preconditions.checkNotNull(modifier);\n   }\n \n   @Override\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.reflect.Type;\n \n    * @param objTypePair The object,type (fully genericized) being navigated\n    */\n   public void accept(ObjectTypePair objTypePair, Visitor visitor) {\n-    if (exclusionStrategy.shouldSkipClass($Types.getRawType(objTypePair.type))) {\n+    if (exclusionStrategy.shouldSkipClass($Gson$Types.getRawType(objTypePair.type))) {\n       return;\n     }\n     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\n       objTypePair.setObject(objectToVisit);\n       visitor.start(objTypePair);\n       try {\n-        if ($Types.isArray(objTypePair.type)) {\n+        if ($Gson$Types.isArray(objTypePair.type)) {\n           visitor.visitArray(objectToVisit, objTypePair.type);\n         } else if (objTypePair.type == Object.class && isPrimitiveOrString(objectToVisit)) {\n           // TODO(Joel): this is only used for deserialization of \"primitives\"\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.reflect.Type;\n import java.util.ArrayList;\n   public synchronized T getHandlerFor(Type type) {\n     T handler = map.get(type);\n     if (handler == null) {\n-      Class<?> rawClass = $Types.getRawType(type);\n+      Class<?> rawClass = $Gson$Types.getRawType(type);\n       if (rawClass != type) {\n         handler = getHandlerFor(rawClass);\n       }\n   }\n \n   private String typeToString(Type type) {\n-    return $Types.getRawType(type).getSimpleName();\n+    return $Gson$Types.getRawType(type).getSimpleName();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/Primitives.java\n+++ b/gson/src/main/java/com/google/gson/Primitives.java\n import java.util.HashMap;\n import java.util.Map;\n \n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n /**\n  * Contains static utility methods pertaining to primitive types and their\n    */\n   public static boolean isWrapperType(Class<?> type) {\n     return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n-        $Preconditions.checkNotNull(type));\n+        $Gson$Preconditions.checkNotNull(type));\n   }\n \n   /**\n     // cast is safe: long.class and Long.class are both of type Class<Long>\n     @SuppressWarnings(\"unchecked\")\n     Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n-        $Preconditions.checkNotNull(type));\n+        $Gson$Preconditions.checkNotNull(type));\n     return (wrapped == null) ? type : wrapped;\n   }\n \n     // cast is safe: long.class and Long.class are both of type Class<Long>\n     @SuppressWarnings(\"unchecked\")\n     Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(\n-        $Preconditions.checkNotNull(type));\n+        $Gson$Preconditions.checkNotNull(type));\n     return (unwrapped == null) ? type : unwrapped;\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n import java.util.List;\n \n import com.google.gson.ObjectNavigator.Visitor;\n-import com.google.gson.internal.$Preconditions;\n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Preconditions;\n+import com.google.gson.internal.$Gson$Types;\n \n /**\n  * Visits each of the fields of the specified class using reflection\n    *   object.\n    */\n   ReflectingFieldNavigator(ExclusionStrategy exclusionStrategy) {\n-    this.exclusionStrategy = $Preconditions.checkNotNull(exclusionStrategy);\n+    this.exclusionStrategy = $Gson$Preconditions.checkNotNull(exclusionStrategy);\n   }\n \n   /**\n       boolean visitedWithCustomHandler =\n         visitor.visitFieldUsingCustomHandler(fieldAttributes, resolvedTypeOfField, obj);\n       if (!visitedWithCustomHandler) {\n-        if ($Types.isArray(resolvedTypeOfField)) {\n+        if ($Gson$Types.isArray(resolvedTypeOfField)) {\n           visitor.visitArrayField(fieldAttributes, resolvedTypeOfField, obj);\n         } else {\n           visitor.visitObjectField(fieldAttributes, resolvedTypeOfField, obj);\n    */\n   private List<Class<?>> getInheritanceHierarchy(Type type) {\n     List<Class<?>> classes = new ArrayList<Class<?>>();\n-    Class<?> topLevelClass = $Types.getRawType(type);\n+    Class<?> topLevelClass = $Gson$Types.getRawType(type);\n     for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n       curr.getSuperclass()) {\n       if (!curr.isSynthetic()) {\n--- a/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n \n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Preconditions;\n \n /**\n  * This strategy will exclude any files and/or class that are passed the\n   private final double version;\n \n   VersionExclusionStrategy(double version) {\n-    $Preconditions.checkArgument(version >= 0.0D);\n+    $Gson$Preconditions.checkArgument(version >= 0.0D);\n     this.version = version;\n   }\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Preconditions.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * A simple utility class used to check method Preconditions.\n+ *\n+ * <pre>\n+ * public long divideBy(long value) {\n+ *   Preconditions.checkArgument(value != 0);\n+ *   return this.value / value;\n+ * }\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class $Gson$Preconditions {\n+  public static <T> T checkNotNull(T obj) {\n+    if (obj == null) {\n+      throw new NullPointerException();\n+    }\n+    return obj;\n+  }\n+\n+  public static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+\n+  public static void checkState(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalStateException();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+/**\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import static com.google.gson.internal.$Gson$Preconditions.checkArgument;\n+import static com.google.gson.internal.$Gson$Preconditions.checkNotNull;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+\n+/**\n+ * Static methods for working with types.\n+ *\n+ * @author Bob Lee\n+ * @author Jesse Wilson\n+ */\n+public final class $Gson$Types {\n+  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n+\n+  private $Gson$Types() {}\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to\n+   * {@code rawType} and enclosed by {@code ownerType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType newParameterizedTypeWithOwner(\n+      Type ownerType, Type rawType, Type... typeArguments) {\n+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n+  }\n+\n+  /**\n+   * Returns an array type whose elements are all instances of\n+   * {@code componentType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} generic array type.\n+   */\n+  public static GenericArrayType arrayOf(Type componentType) {\n+    return new GenericArrayTypeImpl(componentType);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}.\n+   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n+   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n+   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n+   */\n+  public static WildcardType subtypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For\n+   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n+   * super String}.\n+   */\n+  public static WildcardType supertypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n+  }\n+\n+  /**\n+   * Returns a type that is functionally equal but not necessarily equal\n+   * according to {@link Object#equals(Object) Object.equals()}. The returned\n+   * type is {@link java.io.Serializable}.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static Type canonicalize(Type type) {\n+    if (type instanceof Class) {\n+      Class<?> c = (Class<?>) type;\n+      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType p = (ParameterizedType) type;\n+      return new ParameterizedTypeImpl(p.getOwnerType(),\n+          p.getRawType(), p.getActualTypeArguments());\n+\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType g = (GenericArrayType) type;\n+      return new GenericArrayTypeImpl(g.getGenericComponentType());\n+\n+    } else if (type instanceof WildcardType) {\n+      WildcardType w = (WildcardType) type;\n+      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n+\n+    } else {\n+      // type is either serializable as-is or unsupported\n+      return type;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Class<?> getRawType(Type type) {\n+    if (type instanceof Class<?>) {\n+      // type is a normal class.\n+      return (Class<?>) type;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+\n+      // I'm not exactly sure why getRawType() returns Type instead of Class.\n+      // Neal isn't either but suspects some pathological case related\n+      // to nested classes exists.\n+      Type rawType = parameterizedType.getRawType();\n+      checkArgument(rawType instanceof Class);\n+      return (Class<?>) rawType;\n+\n+    } else if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n+      return Array.newInstance(getRawType(componentType), 0).getClass();\n+\n+    } else if (type instanceof TypeVariable) {\n+      // we could use the variable's bounds, but that won't work if there are multiple.\n+      // having a raw type that's more general than necessary is okay\n+      return Object.class;\n+\n+    } else if (type instanceof WildcardType) {\n+      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n+\n+    } else {\n+      String className = type == null ? \"null\" : type.getClass().getName();\n+      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n+    }\n+  }\n+\n+  static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Returns true if {@code a} and {@code b} are equal.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static boolean equals(Type a, Type b) {\n+    if (a == b) {\n+      // also handles (a == null && b == null)\n+      return true;\n+\n+    } else if (a instanceof Class) {\n+      // Class already specifies equals().\n+      return a.equals(b);\n+\n+    } else if (a instanceof ParameterizedType) {\n+      if (!(b instanceof ParameterizedType)) {\n+        return false;\n+      }\n+\n+      // TODO: save a .clone() call\n+      ParameterizedType pa = (ParameterizedType) a;\n+      ParameterizedType pb = (ParameterizedType) b;\n+      return equal(pa.getOwnerType(), pb.getOwnerType())\n+          && pa.getRawType().equals(pb.getRawType())\n+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n+\n+    } else if (a instanceof GenericArrayType) {\n+      if (!(b instanceof GenericArrayType)) {\n+        return false;\n+      }\n+\n+      GenericArrayType ga = (GenericArrayType) a;\n+      GenericArrayType gb = (GenericArrayType) b;\n+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n+\n+    } else if (a instanceof WildcardType) {\n+      if (!(b instanceof WildcardType)) {\n+        return false;\n+      }\n+\n+      WildcardType wa = (WildcardType) a;\n+      WildcardType wb = (WildcardType) b;\n+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n+\n+    } else if (a instanceof TypeVariable) {\n+      if (!(b instanceof TypeVariable)) {\n+        return false;\n+      }\n+      TypeVariable<?> va = (TypeVariable<?>) a;\n+      TypeVariable<?> vb = (TypeVariable<?>) b;\n+      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n+          && va.getName().equals(vb.getName());\n+\n+    } else {\n+      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n+      return false;\n+    }\n+  }\n+\n+  private static int hashCodeOrZero(Object o) {\n+    return o != null ? o.hashCode() : 0;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static String typeToString(Type type) {\n+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n+  }\n+\n+  /**\n+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n+   */\n+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n+    if (toResolve == rawType) {\n+      return context;\n+    }\n+\n+    // we skip searching through interfaces if unknown is an interface\n+    if (toResolve.isInterface()) {\n+      Class<?>[] interfaces = rawType.getInterfaces();\n+      for (int i = 0, length = interfaces.length; i < length; i++) {\n+        if (interfaces[i] == toResolve) {\n+          return rawType.getGenericInterfaces()[i];\n+        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n+        }\n+      }\n+    }\n+\n+    // check our supertypes\n+    if (!rawType.isInterface()) {\n+      while (rawType != Object.class) {\n+        Class<?> rawSupertype = rawType.getSuperclass();\n+        if (rawSupertype == toResolve) {\n+          return rawType.getGenericSuperclass();\n+        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n+        }\n+        rawType = rawSupertype;\n+      }\n+    }\n+\n+    // we can't resolve this further\n+    return toResolve;\n+  }\n+\n+  /**\n+   * Returns the generic form of {@code supertype}. For example, if this is {@code\n+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n+   * Iterable.class}.\n+   *\n+   * @param supertype a superclass of, or interface implemented by, this.\n+   */\n+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n+    checkArgument(supertype.isAssignableFrom(contextRawType));\n+    return resolve(context, contextRawType,\n+        $Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n+  }\n+\n+  /**\n+   * Returns true if this type is an array.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static boolean isArray(Type type) {\n+    return type instanceof GenericArrayType\n+        || (type instanceof Class && ((Class<?>) type).isArray());\n+  }\n+\n+  /**\n+   * Returns the component type of this array type.\n+   * @throws ClassCastException if this type is not an array.\n+   */\n+  public static Type getArrayComponentType(Type array) {\n+    return array instanceof GenericArrayType\n+        ? ((GenericArrayType) array).getGenericComponentType()\n+        : ((Class<?>) array).getComponentType();\n+  }\n+\n+  /**\n+   * Returns the element type of this collection type.\n+   * @throws IllegalArgumentException if this type is not a collection.\n+   */\n+  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n+    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n+    return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n+  }\n+\n+  /**\n+   * Returns a two element array containing this map's key and value types in\n+   * positions 0 and 1 respectively.\n+   */\n+  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n+    /*\n+     * Work around a problem with the declaration of java.util.Properties. That\n+     * class should extend Hashtable<String, String>, but it's declared to\n+     * extend Hashtable<Object, Object>.\n+     */\n+    if (context == Properties.class) {\n+      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n+    }\n+\n+    Type mapType = getSupertype(context, contextRawType, Map.class);\n+    ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n+    return mapParameterizedType.getActualTypeArguments();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n+    // this implementation is made a little more complicated in an attempt to avoid object-creation\n+    while (true) {\n+      if (toResolve instanceof TypeVariable) {\n+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n+        if (toResolve == typeVariable) {\n+          return toResolve;\n+        }\n+\n+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n+        Class<?> original = (Class<?>) toResolve;\n+        Type componentType = original.getComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof GenericArrayType) {\n+        GenericArrayType original = (GenericArrayType) toResolve;\n+        Type componentType = original.getGenericComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof ParameterizedType) {\n+        ParameterizedType original = (ParameterizedType) toResolve;\n+        Type ownerType = original.getOwnerType();\n+        Type newOwnerType = resolve(context, contextRawType, ownerType);\n+        boolean changed = newOwnerType != ownerType;\n+\n+        Type[] args = original.getActualTypeArguments();\n+        for (int t = 0, length = args.length; t < length; t++) {\n+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n+          if (resolvedTypeArgument != args[t]) {\n+            if (!changed) {\n+              args = args.clone();\n+              changed = true;\n+            }\n+            args[t] = resolvedTypeArgument;\n+          }\n+        }\n+\n+        return changed\n+            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n+            : original;\n+\n+      } else if (toResolve instanceof WildcardType) {\n+        WildcardType original = (WildcardType) toResolve;\n+        Type[] originalLowerBound = original.getLowerBounds();\n+        Type[] originalUpperBound = original.getUpperBounds();\n+\n+        if (originalLowerBound.length == 1) {\n+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n+          if (lowerBound != originalLowerBound[0]) {\n+            return supertypeOf(lowerBound);\n+          }\n+        } else if (originalUpperBound.length == 1) {\n+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n+          if (upperBound != originalUpperBound[0]) {\n+            return subtypeOf(upperBound);\n+          }\n+        }\n+        return original;\n+\n+      } else {\n+        return toResolve;\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable unknown) {\n+    Class<?> declaredByRaw = declaringClassOf(unknown);\n+\n+    // we can't reduce this further\n+    if (declaredByRaw == null) {\n+      return unknown;\n+    }\n+\n+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n+    if (declaredBy instanceof ParameterizedType) {\n+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n+    }\n+\n+    return unknown;\n+  }\n+\n+  private static int indexOf(Object[] array, Object toFind) {\n+    for (int i = 0; i < array.length; i++) {\n+      if (toFind.equals(array[i])) {\n+        return i;\n+      }\n+    }\n+    throw new NoSuchElementException();\n+  }\n+\n+  /**\n+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n+   * a class.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n+    return genericDeclaration instanceof Class\n+        ? (Class<?>) genericDeclaration\n+        : null;\n+  }\n+\n+  private static void checkNotPrimitive(Type type) {\n+    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n+  }\n+\n+  private static final class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n+    private final Type ownerType;\n+    private final Type rawType;\n+    private final Type[] typeArguments;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n+      // require an owner type if the raw type needs it\n+      if (rawType instanceof Class<?>) {\n+        Class rawTypeAsClass = (Class) rawType;\n+        checkArgument(ownerType != null || rawTypeAsClass.getEnclosingClass() == null);\n+        checkArgument(ownerType == null || rawTypeAsClass.getEnclosingClass() != null);\n+      }\n+\n+      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n+      this.rawType = canonicalize(rawType);\n+      this.typeArguments = typeArguments.clone();\n+      for (int t = 0; t < this.typeArguments.length; t++) {\n+        checkNotNull(this.typeArguments[t]);\n+        checkNotPrimitive(this.typeArguments[t]);\n+        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n+      }\n+    }\n+\n+    public Type[] getActualTypeArguments() {\n+      return typeArguments.clone();\n+    }\n+\n+    public Type getRawType() {\n+      return rawType;\n+    }\n+\n+    public Type getOwnerType() {\n+      return ownerType;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof ParameterizedType\n+          && $Gson$Types.equals(this, (ParameterizedType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      return Arrays.hashCode(typeArguments)\n+          ^ rawType.hashCode()\n+          ^ hashCodeOrZero(ownerType);\n+    }\n+\n+    @Override public String toString() {\n+      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));\n+      stringBuilder.append(typeToString(rawType));\n+\n+      if (typeArguments.length == 0) {\n+        return stringBuilder.toString();\n+      }\n+\n+      stringBuilder.append(\"<\").append(typeToString(typeArguments[0]));\n+      for (int i = 1; i < typeArguments.length; i++) {\n+        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n+      }\n+      return stringBuilder.append(\">\").toString();\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static final class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n+    private final Type componentType;\n+\n+    public GenericArrayTypeImpl(Type componentType) {\n+      this.componentType = canonicalize(componentType);\n+    }\n+\n+    public Type getGenericComponentType() {\n+      return componentType;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof GenericArrayType\n+          && $Gson$Types.equals(this, (GenericArrayType) o);\n+    }\n+\n+    @Override public int hashCode() {\n+      return componentType.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return typeToString(componentType) + \"[]\";\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  /**\n+   * The WildcardType interface supports multiple upper bounds and multiple\n+   * lower bounds. We only support what the Java 6 language needs - at most one\n+   * bound. If a lower bound is set, the upper bound must be Object.class.\n+   */\n+  private static final class WildcardTypeImpl implements WildcardType, Serializable {\n+    private final Type upperBound;\n+    private final Type lowerBound;\n+\n+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n+      checkArgument(lowerBounds.length <= 1);\n+      checkArgument(upperBounds.length == 1);\n+\n+      if (lowerBounds.length == 1) {\n+        checkNotNull(lowerBounds[0]);\n+        checkNotPrimitive(lowerBounds[0]);\n+        checkArgument(upperBounds[0] == Object.class);\n+        this.lowerBound = canonicalize(lowerBounds[0]);\n+        this.upperBound = Object.class;\n+\n+      } else {\n+        checkNotNull(upperBounds[0]);\n+        checkNotPrimitive(upperBounds[0]);\n+        this.lowerBound = null;\n+        this.upperBound = canonicalize(upperBounds[0]);\n+      }\n+    }\n+\n+    public Type[] getUpperBounds() {\n+      return new Type[] { upperBound };\n+    }\n+\n+    public Type[] getLowerBounds() {\n+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof WildcardType\n+          && $Gson$Types.equals(this, (WildcardType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n+          ^ (31 + upperBound.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      if (lowerBound != null) {\n+        return \"? super \" + typeToString(lowerBound);\n+      } else if (upperBound == Object.class) {\n+        return \"?\";\n+      } else {\n+        return \"? extends \" + typeToString(upperBound);\n+      }\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n \n package com.google.gson.reflect;\n \n-import com.google.gson.internal.$Types;\n-import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.internal.$Gson$Preconditions;\n import java.lang.reflect.GenericArrayType;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n   @SuppressWarnings(\"unchecked\")\n   protected TypeToken() {\n     this.type = getSuperclassTypeParameter(getClass());\n-    this.rawType = (Class<? super T>) $Types.getRawType(type);\n+    this.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\n     this.hashCode = type.hashCode();\n   }\n \n    */\n   @SuppressWarnings(\"unchecked\")\n   TypeToken(Type type) {\n-    this.type = $Types.canonicalize($Preconditions.checkNotNull(type));\n-    this.rawType = (Class<? super T>) $Types.getRawType(this.type);\n+    this.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n+    this.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\n     this.hashCode = this.type.hashCode();\n   }\n \n   /**\n-   * Returns the type from super class's type parameter in {@link $Types#canonicalize\n+   * Returns the type from super class's type parameter in {@link $Gson$Types#canonicalize\n    * canonical form}.\n    */\n   @SuppressWarnings(\"unchecked\")\n       throw new RuntimeException(\"Missing type parameter.\");\n     }\n     ParameterizedType parameterized = (ParameterizedType) superclass;\n-    return $Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n+    return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n   }\n \n   /**\n     }\n \n     if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom($Types.getRawType(from));\n+      return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n     } else if (type instanceof ParameterizedType) {\n       return isAssignableFrom(from, (ParameterizedType) type,\n           new HashMap<String, Type>());\n     } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom($Types.getRawType(from))\n+      return rawType.isAssignableFrom($Gson$Types.getRawType(from))\n           && isAssignableFrom(from, (GenericArrayType) type);\n     } else {\n       throw buildUnexpectedTypeError(\n     }\n \n     // First figure out the class and any type information.\n-    Class<?> clazz = $Types.getRawType(from);\n+    Class<?> clazz = $Gson$Types.getRawType(from);\n     ParameterizedType ptype = null;\n     if (from instanceof ParameterizedType) {\n       ptype = (ParameterizedType) from;\n \n   @Override public final boolean equals(Object o) {\n     return o instanceof TypeToken<?>\n-        && $Types.equals(type, ((TypeToken<?>) o).type);\n+        && $Gson$Types.equals(type, ((TypeToken<?>) o).type);\n   }\n \n   @Override public final String toString() {\n-    return $Types.typeToString(type);\n+    return $Gson$Types.typeToString(type);\n   }\n \n   /**\n--- a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n import java.util.List;\n \n /**\n- * Unit tests for the {@code GenericArrayType}s created by the {@link $Types} class.\n+ * Unit tests for the {@code GenericArrayType}s created by the {@link $Gson$Types} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    ourType = $Types.arrayOf($Types.newParameterizedTypeWithOwner(null, List.class, String.class));\n+    ourType = $Gson$Types.arrayOf($Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class));\n   }\n \n   public void testOurTypeFunctionality() throws Exception {\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n import java.util.List;\n \n /**\n- * Unit tests for {@code ParamterizedType}s created by the {@link $Types} class.\n+ * Unit tests for {@code ParamterizedType}s created by the {@link $Gson$Types} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    ourType = $Types.newParameterizedTypeWithOwner(null, List.class, String.class);\n+    ourType = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, String.class);\n   }\n \n   public void testOurTypeFunctionality() throws Exception {\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Gson$Types;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n     public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n-      Class<?> rawType = $Types.getRawType(genericClass);\n+      Class<?> rawType = $Gson$Types.getRawType(genericClass);\n       String className = rawType.getSimpleName();\n       T value = (T) json.getAsJsonObject().get(className).getAsObject();\n       if (Primitives.isPrimitive(genericClass)) {", "timestamp": 1302049617, "metainfo": ""}