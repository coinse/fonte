{"sha": "aceadaecf18cf7ad011ae3040aa3fe570559902d", "log": "Add a hashing layer to LinkedTreeMap. Instead of having 1 root node, the class now has several root nodes, one for each hash bucket in a hash table.    Compared to LinkedTreeMap, this is slower for small (size=5) maps: 124% slower to get() and 33% slower to create and populate. It's a win for large (size=500) maps: 46% faster to get() but 8% slower to create and populate. And it's a big win for very large (size=50,000) maps: 81% faster to get() and 46% faster to create and populate.  http://microbenchmarks.appspot.com/run/limpbizkit@gmail.com/com.google.common.collect.MapBenchmark  I'm going to follow this up with some simple optimizations: caching local fields and simplifying access. That should narrow the performance gap.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n import java.util.AbstractMap;\n import java.util.AbstractSet;\n import java.util.ArrayDeque;\n+import java.util.Arrays;\n import java.util.Comparator;\n import java.util.ConcurrentModificationException;\n import java.util.Iterator;\n import java.util.LinkedHashMap;\n-import java.util.Map;\n import java.util.NoSuchElementException;\n import java.util.Set;\n \n   };\n \n   Comparator<? super K> comparator;\n-  Node<K, V> root;\n+  Node<K, V>[] table;\n   final Node<K, V> header;\n   int size = 0;\n   int modCount = 0;\n+  int threshold;\n \n   /**\n    * Create a natural order, empty tree map whose keys must be mutually\n         ? comparator\n         : (Comparator) NATURAL_ORDER;\n     this.header = new Node<K, V>();\n+    this.table = new Node[16]; // TODO: sizing/resizing policies\n+    this.threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity\n   }\n \n   @Override public int size() {\n   }\n \n   @Override public void clear() {\n-    root = null;\n+    Arrays.fill(table, null);\n     size = 0;\n     modCount++;\n+\n+    // Clear all links to help GC\n+    Node<K, V> header = this.header;\n+    for (Node<K, V> e = header.next; e != header; ) {\n+      Node<K, V> next = e.next;\n+      e.next = e.prev = null;\n+      e = next;\n+    }\n+\n+    header.next = header.prev = header;\n   }\n \n   @Override public V remove(Object key) {\n    *     mutually comparable.\n    */\n   Node<K, V> find(K key, boolean create) {\n-    if (root == null) {\n+    int hash = secondaryHash(key.hashCode());\n+    int index = hash & (table.length - 1);\n+\n+    if (table[index] == null) {\n       if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\n         throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n       }\n       if (create) {\n-        root = new Node<K, V>(null, key, header, header);\n-        size = 1;\n+        Node<K, V> created = new Node<K, V>(null, key, hash, header, header.prev);\n+        size++;\n+        table[index] = created;\n         modCount++;\n-        return root;\n+        if (size > threshold) {\n+          doubleCapacity();\n+        }\n+        return created;\n       } else {\n         return null;\n       }\n     }\n \n-    Node<K, V> nearest = root;\n+    Node<K, V> nearest = table[index];\n     while (true) {\n       int comparison = comparator.compare(key, nearest.key);\n \n \n       // The key doesn't exist in this tree. Create it here, then rebalance.\n       if (create) {\n-        Node<K, V> created = new Node<K, V>(nearest, key, header, header.prev);\n+        Node<K, V> created = new Node<K, V>(nearest, key, hash, header, header.prev);\n         if (comparison < 0) { // nearest.key is higher\n           nearest.left = created;\n         } else { // comparison > 0, nearest.key is lower\n         size++;\n         modCount++;\n         rebalance(nearest, true);\n+        if (size > threshold) {\n+          doubleCapacity();\n+        }\n         return created;\n       } else {\n         return null;\n \n   private boolean equal(Object a, Object b) {\n     return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Applies a supplemental hash function to a given hashCode, which defends\n+   * against poor quality hash functions. This is critical because HashMap\n+   * uses power-of-two length hash tables, that otherwise encounter collisions\n+   * for hashCodes that do not differ in lower or upper bits.\n+   */\n+  private static int secondaryHash(int h) {\n+    // Doug Lea's supplemental hash function\n+    h ^= (h >>> 20) ^ (h >>> 12);\n+    return h ^ (h >>> 7) ^ (h >>> 4);\n   }\n \n   /**\n         parent.right = replacement;\n       }\n     } else {\n-      root = replacement;\n+      int index = node.hash & (table.length - 1);\n+      table[index] = replacement;\n     }\n   }\n \n     return result != null ? result : (keySet = new KeySet());\n   }\n \n-  static class Node<K, V> implements Map.Entry<K, V> {\n+  static class Node<K, V> implements Entry<K, V> {\n     Node<K, V> parent;\n     Node<K, V> left;\n     Node<K, V> right;\n     Node<K, V> next;\n     Node<K, V> prev;\n     final K key;\n+    final int hash;\n     V value;\n     int height;\n-    int hash;\n \n     /** Create the header entry */\n     Node() {\n       key = null;\n+      hash = -1;\n       next = prev = this;\n     }\n \n     /** Create a regular entry */\n-    Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\n+    Node(Node<K, V> parent, K key, int hash, Node<K, V> next, Node<K, V> prev) {\n       this.parent = parent;\n       this.key = key;\n+      this.hash = hash;\n       this.height = 1;\n       this.next = next;\n       this.prev = prev;\n     }\n \n     @Override public boolean equals(Object o) {\n-      if (o instanceof Map.Entry) {\n-        Map.Entry other = (Map.Entry) o;\n+      if (o instanceof Entry) {\n+        Entry other = (Entry) o;\n         return (key == null ? other.getKey() == null : key.equals(other.getKey()))\n             && (value == null ? other.getValue() == null : value.equals(other.getValue()));\n       }\n       }\n       return node;\n     }\n+  }\n+\n+  private void doubleCapacity() {\n+    table = doubleCapacity(table);\n+    threshold = (table.length / 2) + (table.length / 4); // 3/4 capacity\n   }\n \n   /**\n       if (lastReturned == null) {\n         throw new IllegalStateException();\n       }\n-      LinkedTreeMap.this.removeInternal(lastReturned, true);\n+      removeInternal(lastReturned, true);\n       lastReturned = null;\n       expectedModCount = modCount;\n     }\n   }\n \n-  class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n+  class EntrySet extends AbstractSet<Entry<K, V>> {\n     @Override public int size() {\n       return size;\n     }\n--- a/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n package com.google.gson.internal;\n \n import com.google.gson.internal.LinkedTreeMap.AvlBuilder;\n+import com.google.gson.internal.LinkedTreeMap.AvlIterator;\n import com.google.gson.internal.LinkedTreeMap.Node;\n import java.util.ArrayList;\n import java.util.Arrays;\n     }\n   }\n \n+  public void testClear() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    map.put(\"c\", \"cola\");\n+    map.put(\"b\", \"bbq\");\n+    map.clear();\n+    assertIterationOrder(map.keySet());\n+    assertEquals(0, map.size());\n+  }\n+\n   public void testAvlWalker() {\n     assertAvlWalker(node(node(\"a\"), \"b\", node(\"c\")),\n         \"a\", \"b\", \"c\");\n   }\n \n   private void assertAvlWalker(Node<String, String> root, String... values) {\n-    LinkedTreeMap.AvlIterator<String, String> iterator = new LinkedTreeMap.AvlIterator<String, String>();\n+    AvlIterator<String, String> iterator = new AvlIterator<String, String>();\n     iterator.reset(root);\n     for (String value : values) {\n       assertTrue(iterator.hasNext());\n   private static final Node<String, String> head = new Node<String, String>();\n \n   private Node<String, String> node(String value) {\n-    Node<String, String> result = new Node<String, String>(null, value, head, head);\n-    result.hash = value.hashCode();\n-    return result;\n+    return new Node<String, String>(null, value, value.hashCode(), head, head);\n   }\n \n   private Node<String, String> node(Node<String, String> left, String value,", "timestamp": 1347841184, "metainfo": ""}