{"sha": "bf4ab04413ce091971175ff594c794116925b44a", "log": "replaced multiple caches in ReflectingFieldNavigator with a single one.  Two additional optimizations: - storing the field list for the entire type hierarchy in the cache instead of navigating it every time. - storing the resolved type for the field in FieldAttributes instead of using reflection every time.", "commit": "\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n package com.google.gson;\n \n import com.google.gson.internal.$Preconditions;\n+import com.google.gson.internal.$Types;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n   private final boolean isSynthetic;\n   private final int modifiers;\n   private final String name;\n+  private final Type resolvedType;\n \n   // Fields used for lazy initialization\n   private Type genericType;\n   private Collection<Annotation> annotations;\n \n+  FieldAttributes(Class<?> declaringClazz, Field f) {\n+    this(declaringClazz, f, declaringClazz);\n+  }\n+\n   /**\n    * Constructs a Field Attributes object from the {@code f}.\n    *\n    * @param f the field to pull attributes from\n-   */\n-  FieldAttributes(final Class<?> declaringClazz, final Field f) {\n+   * @param declaringType The type in which the field is declared\n+   */\n+  FieldAttributes(Class<?> declaringClazz, Field f, Type declaringType) {\n     this.declaringClazz = $Preconditions.checkNotNull(declaringClazz);\n     this.name = f.getName();\n     this.declaredType = f.getType();\n     this.isSynthetic = f.isSynthetic();\n     this.modifiers = f.getModifiers();\n     this.field = f;\n+    this.resolvedType = getTypeInfoForField(f, declaringType);\n   }\n \n   private static int getMaxCacheSize() {\n     return field;\n   }\n \n+  Type getResolvedType() {\n+    return resolvedType;\n+  }\n+\n   @SuppressWarnings(\"unchecked\")\n   private static <T extends Annotation> T getAnnotationFromArray(\n       Collection<Annotation> annotations, Class<T> annotation) {\n     }\n     return null;\n   }\n+\n+  /**\n+   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n+   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n+   *\n+   * @param f the actual field object to retrieve the type from\n+   * @param typeDefiningF the type that contains the field {@code f}\n+   * @return the type information for the field\n+   */\n+  public static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n+    Class<?> rawType = $Types.getRawType(typeDefiningF);\n+    if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n+      // this field is unrelated to the type; the user probably omitted type information\n+      return f.getGenericType();\n+    }\n+    return $Types.resolve(typeDefiningF, rawType, f.getGenericType());\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n  * @author Jesse Wilson\n  */\n final class ReflectingFieldNavigator {\n-  private static final LruCache<Type, List<Class<?>>> classCache =\n-    new LruCache<Type, List<Class<?>>>(500);\n-  private static final LruCache<Class<?>, Field[]> fieldsCache =\n-    new LruCache<Class<?>, Field[]>(500);\n+\n+  private static final LruCache<Type, List<FieldAttributes>> fieldsCache =\n+    new LruCache<Type, List<FieldAttributes>>(500);\n \n   private final ExclusionStrategy exclusionStrategy;\n \n    * @param visitor the visitor to visit each field with\n    */\n   void visitFieldsReflectively(ObjectTypePair objTypePair, Visitor visitor) {\n-    for (Class<?> curr : getInheritanceHierarchy(objTypePair.getMoreSpecificType())) {\n-      navigateClassFields(objTypePair.getObject(), objTypePair.type, curr, visitor);\n+    Type moreSpecificType = objTypePair.getMoreSpecificType();\n+    Object obj = objTypePair.getObject();\n+    for (FieldAttributes fieldAttributes : getAllFields(moreSpecificType, objTypePair.getType())) {\n+      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n+          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n+        continue; // skip\n+      }\n+      Type resolvedTypeOfField = fieldAttributes.getResolvedType();\n+      boolean visitedWithCustomHandler =\n+        visitor.visitFieldUsingCustomHandler(fieldAttributes, resolvedTypeOfField, obj);\n+      if (!visitedWithCustomHandler) {\n+        if ($Types.isArray(resolvedTypeOfField)) {\n+          visitor.visitArrayField(fieldAttributes, resolvedTypeOfField, obj);\n+        } else {\n+          visitor.visitObjectField(fieldAttributes, resolvedTypeOfField, obj);\n+        }\n+      }\n     }\n+  }\n+\n+  private List<FieldAttributes> getAllFields(Type type, Type declaredType) {\n+    List<FieldAttributes> fields = fieldsCache.get(type);\n+    if (fields == null) {\n+      fields = new ArrayList<FieldAttributes>();\n+      for (Class<?> curr : getInheritanceHierarchy(type)) {\n+        Field[] fields1 = curr.getDeclaredFields();\n+        AccessibleObject.setAccessible(fields1, true);\n+        Field[] classFields = fields1;\n+        for (Field f : classFields) {\n+          fields.add(new FieldAttributes(curr, f, declaredType));\n+        }\n+      }\n+      fieldsCache.addElement(type, fields);\n+    }\n+    return fields;\n   }\n \n   /**\n    * Returns a list of classes corresponding to the inheritance of specified type\n    */\n   private List<Class<?>> getInheritanceHierarchy(Type type) {\n-    List<Class<?>> classes = classCache.get(type);\n-    if (classes == null) {\n-      classes = new ArrayList<Class<?>>();\n-      Class<?> topLevelClass = $Types.getRawType(type);\n-      for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n-        curr.getSuperclass()) {\n-        if (!curr.isSynthetic()) {\n-          classes.add(curr);\n-        }\n+    List<Class<?>> classes = new ArrayList<Class<?>>();\n+    Class<?> topLevelClass = $Types.getRawType(type);\n+    for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n+      curr.getSuperclass()) {\n+      if (!curr.isSynthetic()) {\n+        classes.add(curr);\n       }\n-      classCache.put(type, classes);\n     }\n     return classes;\n   }\n-\n-  private void navigateClassFields(Object obj, Type objType,\n-      Class<?> classInInheritanceHierarchyForObj, Visitor visitor) {\n-    Field[] fields = getFields(classInInheritanceHierarchyForObj);\n-    for (Field f : fields) {\n-      FieldAttributes fieldAttributes = new FieldAttributes(classInInheritanceHierarchyForObj, f);\n-      if (exclusionStrategy.shouldSkipField(fieldAttributes)\n-          || exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\n-        continue; // skip\n-      }\n-      Type declaredTypeOfField = getTypeInfoForField(f, objType);\n-      boolean visitedWithCustomHandler =\n-          visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n-      if (!visitedWithCustomHandler) {\n-        if ($Types.isArray(declaredTypeOfField)) {\n-          visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n-        } else {\n-          visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n-        }\n-      }\n-    }\n-  }\n-\n-  private Field[] getFields(Class<?> clazz) {\n-    Field[] fields = fieldsCache.get(clazz);\n-    if (fields == null) {\n-      fields = clazz.getDeclaredFields();\n-      AccessibleObject.setAccessible(fields, true);\n-      fieldsCache.put(clazz, fields);\n-    }\n-    return fields;\n-  }\n-\n-\n-  /**\n-   * Evaluates the \"actual\" type for the field.  If the field is a \"TypeVariable\" or has a\n-   * \"TypeVariable\" in a parameterized type then it evaluates the real type.\n-   *\n-   * @param f the actual field object to retrieve the type from\n-   * @param typeDefiningF the type that contains the field {@code f}\n-   * @return the type information for the field\n-   */\n-  public static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n-    Class<?> rawType = $Types.getRawType(typeDefiningF);\n-    if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n-      // this field is unrelated to the type; the user probably omitted type information\n-      return f.getGenericType();\n-    }\n-    return $Types.resolve(typeDefiningF, rawType, f.getGenericType());\n-  }\n }", "timestamp": 1301702081, "metainfo": ""}