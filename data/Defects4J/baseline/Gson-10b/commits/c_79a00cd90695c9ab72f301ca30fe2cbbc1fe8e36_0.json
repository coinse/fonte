{"sha": "79a00cd90695c9ab72f301ca30fe2cbbc1fe8e36", "log": "incorporated code review feedback. Simplified the code, merged Device and Control and removed unnecessary fields.", "commit": "\n--- a/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java\n+++ b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n import com.google.gson.annotations.JsonAdapter;\n-import com.google.gson.annotations.SerializedName;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n-import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n \n import junit.framework.TestCase;\n \n public class JsonAdapterNullSafeTest extends TestCase {\n+  // The recursiveCall in {@link Device.JsonAdapterFactory} is the source of this bug\n+  // because it returns a null type adapter.\n+\n   private final Gson gson = new Gson();\n \n-  /**\n-   * The recursiveCall in {@link ControlData.JsonAdapterFactory} is the source of this bug\n-   * because it returns a null type adapter.\n-   */\n-  public void testTypeAdapterFactoryNullSafeBug() throws IOException {\n-      ControlData control = new ControlData(\"ec57803e\", 2, true, 11211);\n-      Device device = new Device(\"device1\", control);\n-      String json = gson.toJson(device);\n-\n-      json = \"\\\"{\\\\\\\"id\\\\\\\":\\\\\\\"ec57803e2\\\\\\\",\\\\\\\"category\\\\\\\":2,\\\\\\\"alwaysOn\\\\\\\":true,\\\\\\\"codeset_id\\\\\\\":11211}\\\"\";\n-      control = gson.fromJson(json, ControlData.class);\n-      assertEquals(\"ec57803e2\", control.id);\n-      assertTrue(control.alwaysOn);\n-      assertEquals(11211, control.codesetId);\n-      assertEquals(2, control.category);\n-\n-      String deviceJson = \"{'id':'device1','controlData':null}\";\n-      device = gson.fromJson(deviceJson, Device.class);\n-      assertNull(device.controlData);\n-\n-      deviceJson = \"{'id':'device1','controlData':{'id':'ec57803e2','category':2,'alwaysOn':true,'codeset_id':12221}}\";\n-      device = gson.fromJson(deviceJson, Device.class);\n-      assertEquals(12221, device.controlData.codesetId);\n-\n-      deviceJson = \"{'id':'device1','controlData':'\\\\\\\"{}\\\\\\\"'}\";\n-      device = gson.fromJson(deviceJson, Device.class);\n-\n-      try {\n-          deviceJson = \"{'id':'device1','controlData':'a'}\";\n-          device = gson.fromJson(deviceJson, Device.class);\n-          assertNotNull(device.controlData);\n-          fail();\n-      } catch (JsonSyntaxException expected) {}\n-\n-      deviceJson = \"{'id':'device1','controlData':'  '}\";\n-      device = gson.fromJson(deviceJson, Device.class);\n-      assertNull(device.controlData);\n+  public void testNullSafeBugSerialize() throws Exception {\n+    Device device = new Device(\"ec57803e\", 2);\n+    gson.toJson(device);\n   }\n \n-  private static final class Device {\n-    @SuppressWarnings(\"unused\")\n-    String id;\n-    ControlData controlData;\n-\n-    public Device(String id, ControlData controlData) {\n-      this.id = id;\n-      this.controlData = controlData;\n-    }\n+  public void testNullSafeBugDeserialize() throws Exception {\n+    String json = \"\\\"{\\\\\\\"id\\\\\\\":\\\\\\\"ec57803e2\\\\\\\",\\\\\\\"category\\\\\\\":2}\\\"\";\n+    Device device = gson.fromJson(json, Device.class);\n+    assertEquals(\"ec57803e2\", device.id);\n+    assertEquals(2, device.category);\n   }\n \n-  @JsonAdapter(ControlData.JsonAdapterFactory.class)\n-  private static final class ControlData {\n+  @JsonAdapter(Device.JsonAdapterFactory.class)\n+  private static final class Device {\n     String id;\n     int category;\n-    boolean alwaysOn;\n-    @SerializedName(\"codeset_id\") int codesetId;\n-    ControlData(String id, int category, boolean alwaysOn, int codesetId) {\n+    Device(String id, int category) {\n       this.id = id;\n       this.category = category;\n-      this.alwaysOn = alwaysOn;\n-      this.codesetId = codesetId;\n     }\n \n     /**\n-     * DeviceControlData is received as String in JSON instead of proper JSON.\n-     * So, we need to write a special type adapter.\n+     * Write the value as a String, not JSON.\n      */\n-    static final class JsonAdapterFactory extends StringifiedJsonAdapterFactory<ControlData> {\n+    static final class JsonAdapterFactory implements TypeAdapterFactory {\n       private static final ThreadLocal<Boolean> recursiveCall = new ThreadLocal<Boolean>();\n-      public JsonAdapterFactory() {\n-        super(recursiveCall, ControlData.class, true);\n+\n+      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+      @Override public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {\n+        if (type.getRawType() != Device.class || recursiveCall.get() != null) {\n+          recursiveCall.set(null); // clear for subsequent use\n+          return null;\n+        }\n+        recursiveCall.set(Boolean.TRUE);\n+        final TypeAdapter<Device> delegate = (TypeAdapter) gson.getDelegateAdapter(this, type);\n+        return (TypeAdapter) new TypeAdapter<Device>() {\n+          @Override public void write(JsonWriter out, Device value) throws IOException {\n+            delegate.write(out, value);\n+          }\n+          @Override public Device read(JsonReader in) throws IOException {\n+            String json = in.nextString();\n+            JsonParser parser = new JsonParser();\n+            JsonElement root = parseString(parser, json, null);\n+            return root == null ? null : delegate.fromJsonTree(root);\n+          }\n+          private JsonElement parseString(JsonParser parser, String json, String prevJson)\n+              throws IOException { // called recursively\n+            if (json == null || json.trim().isEmpty()) {\n+              return null;\n+            }\n+            JsonElement root = parser.parse(json);\n+            if (root instanceof JsonPrimitive) {\n+              prevJson = json;\n+              json = root.getAsString();\n+              if (Objects.equals(json, prevJson)) {\n+                throw new JsonSyntaxException(\"Unexpected Json: \" + json);\n+              }\n+              return parseString(parser, json, prevJson);\n+            }\n+            return root;\n+          }\n+        };\n       }\n     }\n   }\n-\n-  /**\n-   * Converts an object to Stringified JSON for saving in a JSON field as a string type.\n-   */\n-  private static class StringifiedJsonAdapterFactory<R> implements TypeAdapterFactory {\n-    private final Class<R> targetType;\n-    private final ThreadLocal<Boolean> recursiveCall;\n-    private final boolean writeAsJson;\n-\n-    /**\n-     * @param recursiveCall provide a static ThreadLocal to workaround a Gson bug where\n-     *   annotation-based type adapter factories can't be skipped over.\n-     * @param targetType The class whose instances needs to be written in stringified form.\n-     * @param writeAsJson Set this to true to write the output as JSON not string.\n-     */\n-    public StringifiedJsonAdapterFactory(ThreadLocal<Boolean> recursiveCall, Class<R> targetType,\n-        boolean writeAsJson) {\n-      this.recursiveCall = recursiveCall;\n-      this.targetType = targetType;\n-      this.writeAsJson = writeAsJson;\n-    }\n-\n-    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-    @Override public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {\n-      if (type.getRawType() != targetType || recursiveCall.get() != null) {\n-        recursiveCall.set(null); // clear for subsequent use\n-        return null;\n-      }\n-      recursiveCall.set(Boolean.TRUE);\n-      final TypeAdapter<R> delegate = (TypeAdapter) gson.getDelegateAdapter(this, type);\n-      return (TypeAdapter) new TypeAdapter<R>() {\n-        @Override public void write(JsonWriter out, R value) throws IOException {\n-          if (writeAsJson) {\n-            delegate.write(out, value);\n-          } else {\n-            // delegate.toJson(value) will write nulls. avoid that by using gson.toJson()\n-            String json = gson.toJson(delegate.toJsonTree(value));\n-            out.value(json);\n-          }\n-        }\n-        @Override public R read(JsonReader in) throws IOException {\n-          JsonToken token = in.peek();\n-          JsonElement root;\n-          if (token == JsonToken.BEGIN_OBJECT) {\n-            return delegate.read(in);\n-          } else { // assume to be string\n-            String json = in.nextString();\n-            JsonParser parser = new JsonParser();\n-            root = parseString(parser, json, null);\n-            return root == null ? null : delegate.fromJsonTree(root);\n-          }\n-        }\n-\n-        private JsonElement parseString(JsonParser parser, String json, String prevJson)\n-            throws IOException {\n-          if (json == null || json.trim().isEmpty()) {\n-            return null;\n-          }\n-          JsonElement root = parser.parse(json);\n-          if (root instanceof JsonPrimitive) {\n-            prevJson = json;\n-            json = root.getAsString();\n-            if (Objects.equals(json, prevJson)) {\n-              throw new JsonSyntaxException(\"Unexpected Json: \" + json);\n-            }\n-            return parseString(parser, json, prevJson);\n-          }\n-          return root;\n-        }\n-      }.nullSafe();\n-    }\n-  }\n }", "timestamp": 1456450728, "metainfo": ""}