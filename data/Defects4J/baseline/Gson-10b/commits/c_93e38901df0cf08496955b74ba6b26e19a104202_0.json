{"sha": "93e38901df0cf08496955b74ba6b26e19a104202", "log": "Draft of LinkedTreeMap. Its ordered like a LinkedHashMap but it doesn't do any hashing for DoS resistance.  Not yet adopted in our code.  Known critical bugs:  - throws ClassCastException when get() is called with a non-comparable key  - throws NullPointerException on get(null)", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+/*\n+ * Copyright (C) 2010 The Android Open Source Project\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Comparator;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+/**\n+ * A map of comparable keys to values. Unlike {@code TreeMap}, this class uses\n+ * insertion order for iteration order. Comparison order is only used as an\n+ * optimization for efficient insertion and removal.\n+ *\n+ * <p>This implementation was derived from Android 4.1's TreeMap and\n+ * LinkedHashMap classes.\n+ */\n+public final class LinkedTreeMap<K, V> extends AbstractMap<K, V> implements Serializable {\n+  @SuppressWarnings(\"unchecked\") // to avoid Comparable<Comparable<Comparable<...>>>\n+  private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n+    public int compare(Comparable a, Comparable b) {\n+      return a.compareTo(b);\n+    }\n+  };\n+\n+  Comparator<? super K> comparator;\n+  Node<K, V> root;\n+  final Node<K, V> header;\n+  int size = 0;\n+  int modCount = 0;\n+\n+  /**\n+   * Create a natural order, empty tree map whose keys must be mutually\n+   * comparable and non-null.\n+   */\n+  @SuppressWarnings(\"unchecked\") // unsafe! this assumes K is comparable\n+  public LinkedTreeMap() {\n+    this((Comparator<? super K>) NATURAL_ORDER);\n+  }\n+\n+  /**\n+   * Create a tree map ordered by {@code comparator}. This map's keys may only\n+   * be null if {@code comparator} permits.\n+   *\n+   * @param comparator the comparator to order elements with, or {@code null} to\n+   *     use the natural ordering.\n+   */\n+  @SuppressWarnings(\"unchecked\") // unsafe! if comparator is null, this assumes K is comparable\n+  public LinkedTreeMap(Comparator<? super K> comparator) {\n+    this.comparator = comparator != null\n+        ? comparator\n+        : (Comparator) NATURAL_ORDER;\n+    this.header = new Node<K, V>();\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public V get(Object key) {\n+    Entry<K, V> entry = findByObject(key);\n+    return entry != null ? entry.getValue() : null;\n+  }\n+\n+  @Override public boolean containsKey(Object key) {\n+    return findByObject(key) != null;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    return putInternal(key, value);\n+  }\n+\n+  @Override public void clear() {\n+    root = null;\n+    size = 0;\n+    modCount++;\n+  }\n+\n+  @Override public V remove(Object key) {\n+    Node<K, V> node = removeInternalByKey(key);\n+    return node != null ? node.value : null;\n+  }\n+\n+  V putInternal(K key, V value) {\n+    Node<K, V> created = find(key, true);\n+    V result = created.value;\n+    created.value = value;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the node at or adjacent to the given key, creating it if requested.\n+   *\n+   * @throws ClassCastException if {@code key} and the tree's keys aren't\n+   *     mutually comparable.\n+   */\n+  Node<K, V> find(K key, boolean create) {\n+    if (root == null) {\n+      if (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\n+        throw new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n+      }\n+      if (create) {\n+        root = new Node<K, V>(null, key, header, header);\n+        size = 1;\n+        modCount++;\n+        return root;\n+      } else {\n+        return null;\n+      }\n+    }\n+\n+    Node<K, V> nearest = root;\n+    while (true) {\n+      int comparison = comparator.compare(key, nearest.key);\n+\n+      // We found the requested key.\n+      if (comparison == 0) {\n+        return nearest;\n+      }\n+\n+      // If it exists, the key is in a subtree. Go deeper.\n+      Node<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\n+      if (child != null) {\n+        nearest = child;\n+        continue;\n+      }\n+\n+      // The key doesn't exist in this tree. Create it here, then rebalance.\n+      if (create) {\n+        Node<K, V> created = new Node<K, V>(nearest, key, header, header.prev);\n+        if (comparison < 0) { // nearest.key is higher\n+          nearest.left = created;\n+        } else { // comparison > 0, nearest.key is lower\n+          nearest.right = created;\n+        }\n+        size++;\n+        modCount++;\n+        rebalance(nearest, true);\n+        return created;\n+      } else {\n+        return null;\n+      }\n+    }\n+  }\n+\n+  // TODO(jwilson): don't throw ClassCastExceptions on unknown types\n+  @SuppressWarnings(\"unchecked\") // this method throws ClassCastExceptions!\n+  Node<K, V> findByObject(Object key) {\n+    return find((K) key, false);\n+  }\n+\n+  /**\n+   * Returns this map's entry that has the same key and value as {@code\n+   * entry}, or null if this map has no such entry.\n+   *\n+   * <p>This method uses the comparator for key equality rather than {@code\n+   * equals}. If this map's comparator isn't consistent with equals (such as\n+   * {@code String.CASE_INSENSITIVE_ORDER}), then {@code remove()} and {@code\n+   * contains()} will violate the collections API.\n+   */\n+  Node<K, V> findByEntry(Entry<?, ?> entry) {\n+    Node<K, V> mine = findByObject(entry.getKey());\n+    boolean valuesEqual = mine != null && equal(mine.value, entry.getValue());\n+    return valuesEqual ? mine : null;\n+  }\n+\n+  private boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Removes {@code node} from this tree, rearranging the tree's structure as\n+   * necessary.\n+   */\n+  void removeInternal(Node<K, V> node) {\n+    // Unlink the node.\n+    node.prev.next = node.next;\n+    node.next.prev = node.prev;\n+    node.next = node.prev = null; // Help the GC (for performance)\n+\n+    Node<K, V> left = node.left;\n+    Node<K, V> right = node.right;\n+    Node<K, V> originalParent = node.parent;\n+    if (left != null && right != null) {\n+\n+      /*\n+       * To remove a node with both left and right subtrees, move an\n+       * adjacent node from one of those subtrees into this node's place.\n+       *\n+       * Removing the adjacent node may change this node's subtrees. This\n+       * node may no longer have two subtrees once the adjacent node is\n+       * gone!\n+       */\n+\n+      Node<K, V> adjacent = (left.height > right.height) ? left.last() : right.first();\n+      removeInternal(adjacent); // takes care of rebalance and size--\n+\n+      int leftHeight = 0;\n+      left = node.left;\n+      if (left != null) {\n+        leftHeight = left.height;\n+        adjacent.left = left;\n+        left.parent = adjacent;\n+        node.left = null;\n+      }\n+      int rightHeight = 0;\n+      right = node.right;\n+      if (right != null) {\n+        rightHeight = right.height;\n+        adjacent.right = right;\n+        right.parent = adjacent;\n+        node.right = null;\n+      }\n+      adjacent.height = Math.max(leftHeight, rightHeight) + 1;\n+      replaceInParent(node, adjacent);\n+      return;\n+    } else if (left != null) {\n+      replaceInParent(node, left);\n+      node.left = null;\n+    } else if (right != null) {\n+      replaceInParent(node, right);\n+      node.right = null;\n+    } else {\n+      replaceInParent(node, null);\n+    }\n+\n+    rebalance(originalParent, false);\n+    size--;\n+    modCount++;\n+  }\n+\n+  Node<K, V> removeInternalByKey(Object key) {\n+    Node<K, V> node = findByObject(key);\n+    if (node != null) {\n+      removeInternal(node);\n+    }\n+    return node;\n+  }\n+\n+  private void replaceInParent(Node<K, V> node, Node<K, V> replacement) {\n+    Node<K, V> parent = node.parent;\n+    node.parent = null;\n+    if (replacement != null) {\n+      replacement.parent = parent;\n+    }\n+\n+    if (parent != null) {\n+      if (parent.left == node) {\n+        parent.left = replacement;\n+      } else {\n+        assert (parent.right == node);\n+        parent.right = replacement;\n+      }\n+    } else {\n+      root = replacement;\n+    }\n+  }\n+\n+  /**\n+   * Rebalances the tree by making any AVL rotations necessary between the\n+   * newly-unbalanced node and the tree's root.\n+   *\n+   * @param insert true if the node was unbalanced by an insert; false if it\n+   *     was by a removal.\n+   */\n+  private void rebalance(Node<K, V> unbalanced, boolean insert) {\n+    for (Node<K, V> node = unbalanced; node != null; node = node.parent) {\n+      Node<K, V> left = node.left;\n+      Node<K, V> right = node.right;\n+      int leftHeight = left != null ? left.height : 0;\n+      int rightHeight = right != null ? right.height : 0;\n+\n+      int delta = leftHeight - rightHeight;\n+      if (delta == -2) {\n+        Node<K, V> rightLeft = right.left;\n+        Node<K, V> rightRight = right.right;\n+        int rightRightHeight = rightRight != null ? rightRight.height : 0;\n+        int rightLeftHeight = rightLeft != null ? rightLeft.height : 0;\n+\n+        int rightDelta = rightLeftHeight - rightRightHeight;\n+        if (rightDelta == -1 || (rightDelta == 0 && !insert)) {\n+          rotateLeft(node); // AVL right right\n+        } else {\n+          assert (rightDelta == 1);\n+          rotateRight(right); // AVL right left\n+          rotateLeft(node);\n+        }\n+        if (insert) {\n+          break; // no further rotations will be necessary\n+        }\n+\n+      } else if (delta == 2) {\n+        Node<K, V> leftLeft = left.left;\n+        Node<K, V> leftRight = left.right;\n+        int leftRightHeight = leftRight != null ? leftRight.height : 0;\n+        int leftLeftHeight = leftLeft != null ? leftLeft.height : 0;\n+\n+        int leftDelta = leftLeftHeight - leftRightHeight;\n+        if (leftDelta == 1 || (leftDelta == 0 && !insert)) {\n+          rotateRight(node); // AVL left left\n+        } else {\n+          assert (leftDelta == -1);\n+          rotateLeft(left); // AVL left right\n+          rotateRight(node);\n+        }\n+        if (insert) {\n+          break; // no further rotations will be necessary\n+        }\n+\n+      } else if (delta == 0) {\n+        node.height = leftHeight + 1; // leftHeight == rightHeight\n+        if (insert) {\n+          break; // the insert caused balance, so rebalancing is done!\n+        }\n+\n+      } else {\n+        assert (delta == -1 || delta == 1);\n+        node.height = Math.max(leftHeight, rightHeight) + 1;\n+        if (!insert) {\n+          break; // the height hasn't changed, so rebalancing is done!\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Rotates the subtree so that its root's right child is the new root.\n+   */\n+  private void rotateLeft(Node<K, V> root) {\n+    Node<K, V> left = root.left;\n+    Node<K, V> pivot = root.right;\n+    Node<K, V> pivotLeft = pivot.left;\n+    Node<K, V> pivotRight = pivot.right;\n+\n+    // move the pivot's left child to the root's right\n+    root.right = pivotLeft;\n+    if (pivotLeft != null) {\n+      pivotLeft.parent = root;\n+    }\n+\n+    replaceInParent(root, pivot);\n+\n+    // move the root to the pivot's left\n+    pivot.left = root;\n+    root.parent = pivot;\n+\n+    // fix heights\n+    root.height = Math.max(left != null ? left.height : 0,\n+        pivotLeft != null ? pivotLeft.height : 0) + 1;\n+    pivot.height = Math.max(root.height,\n+        pivotRight != null ? pivotRight.height : 0) + 1;\n+  }\n+\n+  /**\n+   * Rotates the subtree so that its root's left child is the new root.\n+   */\n+  private void rotateRight(Node<K, V> root) {\n+    Node<K, V> pivot = root.left;\n+    Node<K, V> right = root.right;\n+    Node<K, V> pivotLeft = pivot.left;\n+    Node<K, V> pivotRight = pivot.right;\n+\n+    // move the pivot's right child to the root's left\n+    root.left = pivotRight;\n+    if (pivotRight != null) {\n+      pivotRight.parent = root;\n+    }\n+\n+    replaceInParent(root, pivot);\n+\n+    // move the root to the pivot's right\n+    pivot.right = root;\n+    root.parent = pivot;\n+\n+    // fixup heights\n+    root.height = Math.max(right != null ? right.height : 0,\n+        pivotRight != null ? pivotRight.height : 0) + 1;\n+    pivot.height = Math.max(root.height,\n+        pivotLeft != null ? pivotLeft.height : 0) + 1;\n+  }\n+\n+  private EntrySet entrySet;\n+  private KeySet keySet;\n+\n+  @Override public Set<Entry<K, V>> entrySet() {\n+    EntrySet result = entrySet;\n+    return result != null ? result : (entrySet = new EntrySet());\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    KeySet result = keySet;\n+    return result != null ? result : (keySet = new KeySet());\n+  }\n+\n+  static class Node<K, V> implements Map.Entry<K, V> {\n+    Node<K, V> parent;\n+    Node<K, V> left;\n+    Node<K, V> right;\n+    Node<K, V> next;\n+    Node<K, V> prev;\n+    final K key;\n+    V value;\n+    int height;\n+\n+    /** Create the header entry */\n+    Node() {\n+      key = null;\n+      next = prev = this;\n+    }\n+\n+    /** Create a regular entry */\n+    Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\n+      this.parent = parent;\n+      this.key = key;\n+      this.height = 1;\n+      this.next = next;\n+      this.prev = prev;\n+      prev.next = this;\n+      next.prev = this;\n+    }\n+\n+    public K getKey() {\n+      return key;\n+    }\n+\n+    public V getValue() {\n+      return value;\n+    }\n+\n+    public V setValue(V value) {\n+      V oldValue = this.value;\n+      this.value = value;\n+      return oldValue;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      if (o instanceof Map.Entry) {\n+        Map.Entry other = (Map.Entry) o;\n+        return (key == null ? other.getKey() == null : key.equals(other.getKey()))\n+            && (value == null ? other.getValue() == null : value.equals(other.getValue()));\n+      }\n+      return false;\n+    }\n+\n+    @Override public int hashCode() {\n+      return (key == null ? 0 : key.hashCode())\n+          ^ (value == null ? 0 : value.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      return key + \"=\" + value;\n+    }\n+\n+    /**\n+     * Returns the first node in this subtree.\n+     */\n+    public Node<K, V> first() {\n+      Node<K, V> node = this;\n+      Node<K, V> child = node.left;\n+      while (child != null) {\n+        node = child;\n+        child = node.left;\n+      }\n+      return node;\n+    }\n+\n+    /**\n+     * Returns the last node in this subtree.\n+     */\n+    public Node<K, V> last() {\n+      Node<K, V> node = this;\n+      Node<K, V> child = node.right;\n+      while (child != null) {\n+        node = child;\n+        child = node.right;\n+      }\n+      return node;\n+    }\n+  }\n+\n+  private abstract class LinkedTreeMapIterator<T> implements Iterator<T> {\n+    Node<K, V> next = header.next;\n+    Node<K, V> lastReturned = null;\n+    int expectedModCount = modCount;\n+\n+    public final boolean hasNext() {\n+      return next != header;\n+    }\n+\n+    final Node<K, V> nextNode() {\n+      Node<K, V> e = next;\n+      if (e == header) {\n+        throw new NoSuchElementException();\n+      }\n+      if (modCount != expectedModCount) {\n+        throw new ConcurrentModificationException();\n+      }\n+      next = e.next;\n+      return lastReturned = e;\n+    }\n+\n+    public final void remove() {\n+      if (lastReturned == null) {\n+        throw new IllegalStateException();\n+      }\n+      LinkedTreeMap.this.removeInternal(lastReturned);\n+      lastReturned = null;\n+      expectedModCount = modCount;\n+    }\n+  }\n+\n+  class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    @Override public Iterator<Entry<K, V>> iterator() {\n+      return new LinkedTreeMapIterator<Entry<K, V>>() {\n+        public Entry<K, V> next() {\n+          return nextNode();\n+        }\n+      };\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return o instanceof Entry && findByEntry((Entry<?, ?>) o) != null;\n+    }\n+\n+    @Override public boolean remove(Object o) {\n+      if (!(o instanceof Entry)) {\n+        return false;\n+      }\n+\n+      Node<K, V> node = findByEntry((Entry<?, ?>) o);\n+      if (node == null) {\n+        return false;\n+      }\n+      removeInternal(node);\n+      return true;\n+    }\n+\n+    @Override public void clear() {\n+      LinkedTreeMap.this.clear();\n+    }\n+  }\n+\n+  class KeySet extends AbstractSet<K> {\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    @Override public Iterator<K> iterator() {\n+      return new LinkedTreeMapIterator<K>() {\n+        public K next() {\n+          return nextNode().key;\n+        }\n+      };\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+\n+    @Override public boolean remove(Object key) {\n+      return removeInternalByKey(key) != null;\n+    }\n+\n+    @Override public void clear() {\n+      LinkedTreeMap.this.clear();\n+    }\n+  }\n+\n+  /**\n+   * If somebody is unlucky enough to have to serialize one of these, serialize\n+   * it as a LinkedHashMap so that they won't need Gson on the other side to\n+   * deserialize it. Using serialization defeats our DoS defence, so most apps\n+   * shouldn't use it.\n+   */\n+  private Object writeReplace() throws ObjectStreamException {\n+    return new LinkedHashMap<K, V>(this);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import junit.framework.TestCase;\n+\n+public final class LinkedTreeMapTest extends TestCase {\n+  public void testIterationOrder() {\n+    LinkedTreeMap<String, String> map = new LinkedTreeMap<String, String>();\n+    map.put(\"a\", \"android\");\n+    map.put(\"c\", \"cola\");\n+    map.put(\"b\", \"bbq\");\n+    assertIterationOrder(map.keySet(), \"a\", \"c\", \"b\");\n+    assertIterationOrder(map.values(), \"android\", \"cola\", \"bbq\");\n+  }\n+\n+  // TODO: test contains with non-string key\n+\n+  private <T> void assertIterationOrder(Iterable<T> actual, T... expected) {\n+    ArrayList<T> actualList = new ArrayList<T>();\n+    for (T t : actual) {\n+      actualList.add(t);\n+    }\n+    assertEquals(Arrays.asList(expected), actualList);\n+  }\n+}", "timestamp": 1347307478, "metainfo": ""}