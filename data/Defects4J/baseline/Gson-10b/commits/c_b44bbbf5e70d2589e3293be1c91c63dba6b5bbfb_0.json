{"sha": "b44bbbf5e70d2589e3293be1c91c63dba6b5bbfb", "log": "Added an API method to create a tree of JsonElement from an object.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   }\n \n   /**\n+   * This method serializes the specified object into its equivalent representation as a tree of \n+   * {JsonElement}s. This method should be used when the specified object is not a generic type. \n+   * This method uses {@link Class#getClass()} to get the type for the specified object, but the\n+   * {@code getClass()} loses the generic type information because of the Type Erasure feature\n+   * of Java. Note that this method works fine if the any of the object fields are of generic type,\n+   * just the object itself should not be of a generic type. If the object is of generic type, use\n+   * {@link #toJson(Object, Type)} instead. If you want to write out the object to a\n+   * {@link Writer}, use {@link #toJson(Object, Appendable)} instead.\n+   *\n+   * @param src the object for which Json representation is to be created setting for Gson\n+   * @return Json representation of {@code src}.\n+   * @since 1.4\n+   */\n+  public JsonElement toJsonTree(Object src) {\n+    if (src == null) {\n+      return JsonNull.createJsonNull();\n+    }\n+    return toJsonTree(src, src.getClass());\n+  }\n+\n+  /**\n+   * This method serializes the specified object, including those of generic types, into its\n+   * equivalent representation as a tree of {@link JsonElement}s. This method must be used if the \n+   * specified object is a generic type. For non-generic objects, use {@link #toJson(Object)} \n+   * instead. If you want to write out the object to a {@link Appendable}, \n+   * use {@link #toJson(Object, Type, Appendable)} instead.\n+   *\n+   * @param src the object for which JSON representation is to be created\n+   * @param typeOfSrc The specific genericized type of src. You can obtain\n+   * this type by using the {@link com.google.gson.reflect.TypeToken} class. For example,\n+   * to get the type for {@code Collection<Foo>}, you should use:\n+   * <pre>\n+   * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n+   * </pre>\n+   * @return Json representation of {@code src}\n+   * @since 1.4\n+   */\n+  public JsonElement toJsonTree(Object src, Type typeOfSrc) {\n+    if (src == null) {\n+      return JsonNull.createJsonNull();\n+    }\n+    JsonSerializationContext context = new JsonSerializationContextDefault(\n+        createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n+    return context.serialize(src, typeOfSrc);\n+  }\n+\n+  /**\n    * This method serializes the specified object into its equivalent Json representation.\n    * This method should be used when the specified object is not a generic type. This method uses\n    * {@link Class#getClass()} to get the type for the specified object, but the\n     toJson(src, typeOfSrc, writer);\n     return writer.toString();\n   }\n-\n+  \n   /**\n    * This method serializes the specified object into its equivalent Json representation.\n    * This method should be used when the specified object is not a generic type. This method uses\n    */\n   public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n     try {\n-      if (src != null) {\n-        JsonSerializationContext context = new JsonSerializationContextDefault(\n-            createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n-        JsonElement jsonElement = context.serialize(src, typeOfSrc);\n-\n-        if (generateNonExecutableJson) {\n-          writer.append(JSON_NON_EXECUTABLE_PREFIX);\n-        }\n-        //TODO(Joel): instead of navigating the \"JsonElement\" inside the formatter, do it here.\n-        formatter.format(jsonElement, writer, serializeNulls);\n-      } else {\n-        if (serializeNulls) {\n-          writeOutNullString(writer);\n-        }\n+      if (generateNonExecutableJson) {\n+        writer.append(JSON_NON_EXECUTABLE_PREFIX);\n       }\n+      JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n+      formatter.format(jsonElement, writer, serializeNulls);\n     } catch (IOException ioe) {\n       throw new RuntimeException(ioe);\n     }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/JsonTreeTest.java\n+package com.google.gson.functional;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.Map.Entry;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.common.TestTypes.BagOfPrimitives;\n+\n+/**\n+ * Functional tests for {@link Gson#toJsonTree(Object) and \n+ * {@link Gson#toJsonTree(Object, java.lang.reflect.Type)\n+ * \n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public class JsonTreeTest extends TestCase {\n+  private Gson gson;\n+\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    gson = new Gson();\n+  }\n+\n+  public void testToJsonTree() {\n+    BagOfPrimitives bag = new BagOfPrimitives(10L, 5, false, \"foo\");\n+    JsonElement json = gson.toJsonTree(bag);\n+    assertTrue(json.isJsonObject());\n+    JsonObject obj = json.getAsJsonObject();\n+    Set<Entry<String, JsonElement>> children = obj.entrySet();\n+    assertEquals(4, children.size());\n+    assertContains(obj, new JsonPrimitive(10L));\n+    assertContains(obj, new JsonPrimitive(5));\n+    assertContains(obj, new JsonPrimitive(false));\n+    assertContains(obj, new JsonPrimitive(\"foo\"));\n+  }\n+\n+  public void testToJsonTreeObjectType() {\n+    SubTypeOfBagOfPrimitives bag = new SubTypeOfBagOfPrimitives(10L, 5, false, \"foo\", 1.4F);\n+    JsonElement json = gson.toJsonTree(bag, BagOfPrimitives.class);\n+    assertTrue(json.isJsonObject());\n+    JsonObject obj = json.getAsJsonObject();\n+    Set<Entry<String, JsonElement>> children = obj.entrySet();\n+    assertEquals(4, children.size());\n+    assertContains(obj, new JsonPrimitive(10L));\n+    assertContains(obj, new JsonPrimitive(5));\n+    assertContains(obj, new JsonPrimitive(false));\n+    assertContains(obj, new JsonPrimitive(\"foo\"));\n+  }\n+\n+  private void assertContains(JsonObject json, JsonPrimitive child) {\n+    for (Map.Entry<String, JsonElement> entry : json.entrySet()) {\n+      JsonElement node = entry.getValue();\n+      if (node.isJsonPrimitive()) {\n+        if (node.getAsJsonPrimitive().equals(child)) {\n+          return;\n+        }\n+      }\n+    }\n+    fail();\n+  }\n+  \n+  private static class SubTypeOfBagOfPrimitives extends BagOfPrimitives {\n+    float f = 1.2F;\n+    public SubTypeOfBagOfPrimitives(long l, int i, boolean b, String string, float f) {\n+      super(l, i, b, string);\n+      this.f = f;\n+    }\n+  }\n+}", "timestamp": 1238794381, "metainfo": ""}