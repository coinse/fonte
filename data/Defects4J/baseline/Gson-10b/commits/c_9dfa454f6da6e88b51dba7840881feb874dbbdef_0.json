{"sha": "9dfa454f6da6e88b51dba7840881feb874dbbdef", "log": "Fixed issue 63 where Gson could not operate in a thread-safe manner. Resolved the issue by recreating ObjectNavigatorFactory for each call instead of reusing the same object everywhere. This is needed since ObjectNavigatorFactory had MemoryRefStack that was incorrectly being shared across calls.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n   static final Logger logger = Logger.getLogger(Gson.class.getName());\n \n-  private final ObjectNavigatorFactory navigatorFactory;\n+  private final ExclusionStrategy strategy;\n+  private final FieldNamingStrategy fieldNamingPolicy;\n   private final MappedObjectConstructor objectConstructor;\n   private final TypeAdapter typeAdapter;\n \n    * </ul>\n    */\n   public Gson() {\n-    this(createDefaultObjectNavigatorFactory());\n+    this(createExclusionStrategy(VersionConstants.IGNORE_VERSIONS), DEFAULT_NAMING_POLICY);\n   }\n \n   /**\n    * @param factory the object navigator factory to use when creating a new {@link ObjectNavigator}\n    * instance\n    */\n-  Gson(ObjectNavigatorFactory factory) {\n-    this(factory, createObjectConstructor(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS),\n+  Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy) {\n+    this(strategy, fieldNamingPolicy, createObjectConstructor(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS),\n         DEFAULT_TYPE_ADAPTER, DEFAULT_JSON_FORMATTER, false,\n         DefaultTypeAdapters.DEFAULT_SERIALIZERS, DefaultTypeAdapters.DEFAULT_DESERIALIZERS);\n   }\n \n-  Gson(ObjectNavigatorFactory factory, MappedObjectConstructor objectConstructor,\n+  Gson(ExclusionStrategy strategy, FieldNamingStrategy fieldNamingPolicy, \n+      MappedObjectConstructor objectConstructor,\n       TypeAdapter typeAdapter, JsonFormatter formatter, boolean serializeNulls,\n       ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n       ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers) {\n-    this.navigatorFactory = factory;\n+    this.strategy = strategy;\n+    this.fieldNamingPolicy = fieldNamingPolicy;\n     this.objectConstructor = objectConstructor;\n     this.typeAdapter = typeAdapter;\n     this.formatter = formatter;\n     return objectConstructor;\n   }\n \n-  private static ObjectNavigatorFactory createDefaultObjectNavigatorFactory() {\n-    return new ObjectNavigatorFactory(\n-        createExclusionStrategy(VersionConstants.IGNORE_VERSIONS), DEFAULT_NAMING_POLICY);\n+  private ObjectNavigatorFactory createDefaultObjectNavigatorFactory() {\n+    return new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n   }\n \n   private static ExclusionStrategy createExclusionStrategy(double version) {\n    */\n   public void toJson(Object src, Type typeOfSrc, Writer writer) {\n     if (src != null) {\n-      JsonSerializationContext context =\n-          new JsonSerializationContextDefault(navigatorFactory, serializeNulls, serializers);\n+      JsonSerializationContext context = new JsonSerializationContextDefault(\n+          createDefaultObjectNavigatorFactory(), serializeNulls, serializers);\n       JsonElement jsonElement = context.serialize(src, typeOfSrc);\n \n       //TODO(Joel): instead of navigating the \"JsonElement\" inside the formatter, do it here.\n     try {\n       JsonParser parser = new JsonParser(json);\n       JsonElement root = parser.parse();\n-      JsonDeserializationContext context = new JsonDeserializationContextDefault(navigatorFactory,\n-          deserializers, objectConstructor, typeAdapter);\n+      JsonDeserializationContext context = new JsonDeserializationContextDefault(\n+          createDefaultObjectNavigatorFactory(), deserializers, objectConstructor, typeAdapter);\n       T target = (T) context.deserialize(root, typeOfT);\n       return target;\n     } catch (TokenMgrError e) {\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n       strategies.add(new ExposeAnnotationBasedExclusionStrategy());\n     }\n     ExclusionStrategy exclusionStrategy = new DisjunctionExclusionStrategy(strategies);\n-    ObjectNavigatorFactory objectNavigatorFactory =\n-        new ObjectNavigatorFactory(exclusionStrategy, fieldNamingPolicy);\n \n     ParameterizedTypeHandlerMap<JsonSerializer<?>> customSerializers = serializers.copyOf();\n     ParameterizedTypeHandlerMap<JsonDeserializer<?>> customDeserializers = deserializers.copyOf();\n     customInstanceCreators.registerIfAbsent(DefaultTypeAdapters.DEFAULT_INSTANCE_CREATORS);\n     MappedObjectConstructor objConstructor = Gson.createObjectConstructor(customInstanceCreators);\n \n-    Gson gson = new Gson(objectNavigatorFactory, objConstructor, typeAdapter, formatter,\n-        serializeNulls, customSerializers, customDeserializers);\n+    Gson gson = new Gson(exclusionStrategy, fieldNamingPolicy, objConstructor, typeAdapter, \n+        formatter, serializeNulls, customSerializers, customDeserializers);\n     return gson;\n   }\n \n--- a/gson/src/test/java/com/google/gson/FunctionalWithInternalDependenciesTest.java\n+++ b/gson/src/test/java/com/google/gson/FunctionalWithInternalDependenciesTest.java\n   }\n \n   public void testAnonymousLocalClassesSerialization() {\n-    Gson gson = new Gson(new ObjectNavigatorFactory(new ModifierBasedExclusionStrategy(\n-        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY));\n+    Gson gson = new Gson(new ModifierBasedExclusionStrategy(\n+        true, Modifier.TRANSIENT, Modifier.STATIC), Gson.DEFAULT_NAMING_POLICY);\n     assertEquals(\"{}\", gson.toJson(new ClassWithNoFields() {\n       // empty anonymous class\n     }));\n--- a/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ConcurrencyTest.java\n    * Source-code based on\n    * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\n    */\n-  public void testSingleThread() { \n-    MyObject myObj = new MyObject(\"hello\", \"world\", 42); \n+  public void testSingleThreadSerialization() { \n+    MyObject myObj = new MyObject(); \n     for (int i = 0; i < 10; i++) { \n       gson.toJson(myObj); \n     } \n    * Source-code based on\n    * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\n    */\n-  public void testMultiThread() throws InterruptedException {\n+  public void testSingleThreadDeserialization() { \n+    for (int i = 0; i < 10; i++) { \n+      gson.fromJson(\"{'a':'hello','b':'world','i':1}\", MyObject.class); \n+    } \n+  } \n+\n+  /**\n+   * Source-code based on\n+   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\n+   */\n+  public void testMultiThreadSerialization() throws InterruptedException {\n     final CountDownLatch startLatch = new CountDownLatch(1);\n     final CountDownLatch finishedLatch = new CountDownLatch(10);\n     final AtomicBoolean failed = new AtomicBoolean(false);\n           try {\n             startLatch.await();\n             for (int i = 0; i < 10; i++) {\n-              String json = gson.toJson(myObj);\n+              gson.toJson(myObj);\n             }\n           } catch (Throwable t) {\n             failed.set(true);\n     assertFalse(failed.get());\n   }\n \n+  /**\n+   * Source-code based on\n+   * http://groups.google.com/group/google-gson/browse_thread/thread/563bb51ee2495081\n+   */\n+  public void testMultiThreadDeserialization() throws InterruptedException {\n+    final CountDownLatch startLatch = new CountDownLatch(1);\n+    final CountDownLatch finishedLatch = new CountDownLatch(10);\n+    final AtomicBoolean failed = new AtomicBoolean(false);\n+    ExecutorService executor = Executors.newFixedThreadPool(10);\n+    for (int taskCount = 0; taskCount < 10; taskCount++) {\n+      executor.execute(new Runnable() {\n+        public void run() {\n+          try {\n+            startLatch.await();\n+            for (int i = 0; i < 10; i++) {\n+              gson.fromJson(\"{'a':'hello','b':'world','i':1}\", MyObject.class); \n+            }\n+          } catch (Throwable t) {\n+            failed.set(true);\n+          } finally {\n+            finishedLatch.countDown();\n+          }\n+        }\n+      });\n+    }\n+    startLatch.countDown();\n+    finishedLatch.await();\n+    assertFalse(failed.get());\n+  }\n+  \n   private static class MyObject {\n     private String a;\n     private String b;", "timestamp": 1224533382, "metainfo": ""}