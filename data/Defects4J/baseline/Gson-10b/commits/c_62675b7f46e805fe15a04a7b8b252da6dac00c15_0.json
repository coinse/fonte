{"sha": "62675b7f46e805fe15a04a7b8b252da6dac00c15", "log": "Added serializeDefault and deserializeDefault methods in contexts that only invoke system type adapters on the top-level object. With this, the RuntimeTypeAdapterTest passes.", "commit": "\n--- a/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapter.java\n+++ b/extras/src/main/java/com/google/gson/typeadapters/RuntimeTypeAdapter.java\n       throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n           + \"; did you forget to register a subtype?\");\n     }\n-    JsonElement serialized = context.serialize(src, srcType);\n+    JsonElement serialized = context.serializeDefault(src, srcType);\n     final JsonObject jsonObject = serialized.getAsJsonObject();\n     if (jsonObject.has(typeFieldName)) {\n       throw new JsonParseException(\"cannot serialize \" + srcType.getName()\n           + label + \"; did you forget to register a subtype?\");\n     }\n     @SuppressWarnings(\"unchecked\") // registration requires that subtype extends T\n-    T result = (T) context.deserialize(json, subtype);\n+    T result = (T) context.deserializeDefault(json, subtype);\n     return result;\n   }\n }\n--- a/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterTest.java\n+++ b/extras/src/test/java/com/google/gson/typeadapters/RuntimeTypeAdapterTest.java\n     assertEquals(\"{\\\"type\\\":\\\"BillingInstrument\\\",\\\"ownerName\\\":\\\"Jesse\\\"}\",\n         gson.toJson(original, BillingInstrument.class));\n     BillingInstrument deserialized = gson.fromJson(\n-        \"{type:'CreditCard',ownerName:'Jesse'}\", BillingInstrument.class);\n+        \"{type:'BillingInstrument',ownerName:'Jesse'}\", BillingInstrument.class);\n     assertEquals(\"Jesse\", deserialized.ownerName);\n   }\n \n--- a/gson/src/main/java/com/google/gson/BaseMapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/BaseMapTypeAdapter.java\n \n   protected static final JsonElement serialize(JsonSerializationContext context,\n       Object src, Type srcType) {\n-    return context.serialize(src, srcType, false);\n+    return context.serialize(src, srcType, false, false);\n   }\n \n   protected static final Map<Object, Object> constructMapType(\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n         } else {\n           Type childType = (childGenericType == null || childGenericType == Object.class)\n               ? child.getClass() : childGenericType;\n-          JsonElement element = context.serialize(child, childType, false);\n+          JsonElement element = context.serialize(child, childType, false, false);\n           array.add(element);\n         }\n       }\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n \n \n   private <T> T fromJsonArray(Type arrayType, JsonArray jsonArray,\n-      JsonDeserializationContext context) throws JsonParseException {\n+      JsonDeserializationContext context, boolean systemOnly) throws JsonParseException {\n     JsonArrayDeserializationVisitor<T> visitor = new JsonArrayDeserializationVisitor<T>(\n         jsonArray, arrayType, objectNavigator, fieldNamingPolicy,\n         objectConstructor, deserializers, context);\n-    objectNavigator.accept(new ObjectTypePair(null, arrayType, true), visitor);\n+    objectNavigator.accept(new ObjectTypePair(null, arrayType, true, systemOnly), visitor);\n     return visitor.getTarget();\n   }\n \n   private <T> T fromJsonObject(Type typeOfT, JsonObject jsonObject,\n-      JsonDeserializationContext context) throws JsonParseException {\n+      JsonDeserializationContext context, boolean systemOnly) throws JsonParseException {\n     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n         jsonObject, typeOfT, objectNavigator, fieldNamingPolicy,\n         objectConstructor, deserializers, context);\n-    objectNavigator.accept(new ObjectTypePair(null, typeOfT, true), visitor);\n+    objectNavigator.accept(new ObjectTypePair(null, typeOfT, true, systemOnly), visitor);\n     return visitor.getTarget();\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,\n-      JsonDeserializationContext context) throws JsonParseException {\n+      JsonDeserializationContext context, boolean systemOnly) throws JsonParseException {\n     JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n         json, typeOfT, objectNavigator, fieldNamingPolicy, objectConstructor, deserializers, context);\n-    objectNavigator.accept(new ObjectTypePair(json.getAsObject(), typeOfT, true), visitor);\n+    objectNavigator.accept(new ObjectTypePair(json.getAsObject(), typeOfT, true, systemOnly), visitor);\n     Object target = visitor.getTarget();\n     return (T) target;\n   }\n     if (json == null || json.isJsonNull()) {\n       return null;\n     } else if (json.isJsonArray()) {\n-      Object array = fromJsonArray(typeOfT, json.getAsJsonArray(), this);\n+      Object array = fromJsonArray(typeOfT, json.getAsJsonArray(), this, false);\n       return (T) array;\n     } else if (json.isJsonObject()) {\n-      Object object = fromJsonObject(typeOfT, json.getAsJsonObject(), this);\n+      Object object = fromJsonObject(typeOfT, json.getAsJsonObject(), this, false);\n       return (T) object;\n     } else if (json.isJsonPrimitive()) {\n-      Object primitive = fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this);\n+      Object primitive = fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this, false);\n+      return (T) primitive;\n+    } else {\n+      throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\");\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T deserializeDefault(JsonElement json, Type typeOfT) throws JsonParseException {\n+    if (json == null || json.isJsonNull()) {\n+      return null;\n+    } else if (json.isJsonArray()) {\n+      Object array = fromJsonArray(typeOfT, json.getAsJsonArray(), this, true);\n+      return (T) array;\n+    } else if (json.isJsonObject()) {\n+      Object object = fromJsonObject(typeOfT, json.getAsJsonObject(), this, true);\n+      return (T) object;\n+    } else if (json.isJsonPrimitive()) {\n+      Object primitive = fromJsonPrimitive(typeOfT, json.getAsJsonPrimitive(), this, true);\n       return (T) primitive;\n     } else {\n       throw new JsonParseException(\"Failed parsing JSON source: \" + json + \" to Json\");\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n   }\n \n   private Object visitChild(Type type, JsonDeserializationVisitor<?> childVisitor) {\n-    objectNavigator.accept(new ObjectTypePair(null, type, false), childVisitor);\n+    objectNavigator.accept(new ObjectTypePair(null, type, false, false), childVisitor);\n     // the underlying object may have changed during the construction phase\n     // This happens primarily because of custom deserializers\n     return childVisitor.getTarget();\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n         }\n         return true;\n       }\n-      ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false);\n+      ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false, false);\n       Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n       if (pair == null) {\n         return false;\n--- a/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n     if (src == null) {\n       return JsonNull.INSTANCE;\n     }\n-    return serialize(src, src.getClass(), false);\n+    return serialize(src, src.getClass(), false, false);\n   }\n \n   /**\n    * @return a tree of {@link JsonElement}s corresponding to the serialized form of {@code src}.\n    */\n   public JsonElement serialize(Object src, Type typeOfSrc) {\n-    return serialize(src, typeOfSrc, true);\n+    return serialize(src, typeOfSrc, true, false);\n   }\n \n-  JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\n+  public JsonElement serializeDefault(Object src, Type typeOfSrc) {\n+    return serialize(src, typeOfSrc, true, true);\n+  }\n+\n+  JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType, boolean defaultOnly) {\n     if (src == null) {\n       return JsonNull.INSTANCE;\n     }\n     JsonSerializationVisitor visitor = new JsonSerializationVisitor(\n         objectNavigator, fieldNamingPolicy, serializeNulls, serializers, this, ancestors);\n-    ObjectTypePair objTypePair = new ObjectTypePair(src, typeOfSrc, preserveType);\n+    ObjectTypePair objTypePair = new ObjectTypePair(src, typeOfSrc, preserveType, defaultOnly);\n     objectNavigator.accept(objTypePair, visitor);\n     return visitor.getJsonElement();\n   }\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n   }\n \n   public void start(ObjectTypePair node) {\n-    if (node == null) {\n+    if (node == null || node.isSystemOnly()) {\n       return;\n     }\n     if (ancestors.contains(node)) {\n   }\n \n   public void end(ObjectTypePair node) {\n-    if (node != null) {\n+    if (node != null && !node.isSystemOnly()) {\n       ancestors.pop();\n     }\n   }\n       Object child = Array.get(array, i);\n       // we should not get more specific component type yet since it is possible\n       // that a custom serializer is registered for the componentType\n-      addAsArrayElement(new ObjectTypePair(child, componentType, false));\n+      addAsArrayElement(new ObjectTypePair(child, componentType, false, false));\n     }\n   }\n \n         }\n       } else {\n         Object array = getFieldValue(f, obj);\n-        addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false));\n+        addAsChildOfObject(f, new ObjectTypePair(array, typeOfF, false, false));\n       }\n     } catch (CircularReferenceException e) {\n       throw e.createDetailedException(f);\n         // we should not get more specific component type yet since it is\n         // possible that a custom\n         // serializer is registered for the componentType\n-        addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false));\n+        addAsChildOfObject(f, new ObjectTypePair(fieldValue, typeOfF, false, false));\n       }\n     } catch (CircularReferenceException e) {\n       throw e.createDetailedException(f);\n         }\n         return true;\n       }\n-      ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false);\n+      ObjectTypePair objTypePair = new ObjectTypePair(obj, declaredTypeOfField, false, false);\n       JsonElement child = findAndInvokeCustomSerializer(objTypePair);\n       if (child != null) {\n         addChildAsElement(f, child);\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T construct(Type typeOfT) {\n-    InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT);\n+    InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreatorMap.getHandlerFor(typeOfT, false);\n     if (creator != null) {\n       return creator.createInstance(typeOfT);\n     }\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n   private Object obj;\n   final Type type;\n   private final boolean preserveType;\n+  private final boolean systemOnly;\n \n-  ObjectTypePair(Object obj, Type type, boolean preserveType) {\n+  ObjectTypePair(Object obj, Type type, boolean preserveType, boolean systemOnly) {\n     this.obj = obj;\n     this.type = type;\n     this.preserveType = preserveType;\n+    this.systemOnly = systemOnly;\n   }\n \n   Object getObject() {\n     if (!preserveType && obj != null) {\n       // First try looking up the handler for the actual type\n       ObjectTypePair moreSpecificType = toMoreSpecificType();\n-      handler = handlers.getHandlerFor(moreSpecificType.type);\n+      handler = handlers.getHandlerFor(moreSpecificType.type, systemOnly);\n       if (handler != null) {\n         return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n       }\n     }\n     // Try the specified type\n-    handler = handlers.getHandlerFor(type);\n+    handler = handlers.getHandlerFor(type, systemOnly);\n     return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this);\n   }\n \n     if (actualType == type) {\n       return this;\n     }\n-    return new ObjectTypePair(obj, actualType, true);\n+    return new ObjectTypePair(obj, actualType, true, systemOnly);\n   }\n \n   Type getMoreSpecificType() {\n     } else if (!type.equals(other.type)) {\n       return false;\n     }\n-    return preserveType == other.preserveType;\n+    return preserveType == other.preserveType && systemOnly == other.systemOnly;\n   }\n \n   public boolean isPreserveType() {\n     return preserveType;\n   }\n+\n+  public boolean isSystemOnly() {\n+    return systemOnly;\n+  }\n }\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n     modifiable = false;\n   }\n \n-  public synchronized T getHandlerFor(Type type) {\n-    T handler = userMap.get(type);\n-    if (handler != null) {\n-      return handler;\n+  public synchronized T getHandlerFor(Type type, boolean systemOnly) {\n+    T handler;\n+    if (!systemOnly) {\n+      handler = userMap.get(type);\n+      if (handler != null) {\n+        return handler;\n+      }\n     }\n     handler = systemMap.get(type);\n     if (handler != null) {\n     }\n     Class<?> rawClass = $Gson$Types.getRawType(type);\n     if (rawClass != type) {\n-      handler = getHandlerFor(rawClass);\n+      handler = getHandlerFor(rawClass, systemOnly);\n       if (handler != null) {\n         return handler;\n       }\n     }\n     // check if something registered for type hierarchy\n-    handler = getHandlerForTypeHierarchy(rawClass);\n+    handler = getHandlerForTypeHierarchy(rawClass, systemOnly);\n     return handler;\n   }\n \n-  private T getHandlerForTypeHierarchy(Class<?> type) {\n-    for (Pair<Class<?>, T> entry : userTypeHierarchyList) {\n-      if (entry.first.isAssignableFrom(type)) {\n-        return entry.second;\n+  private T getHandlerForTypeHierarchy(Class<?> type, boolean systemOnly) {\n+    if (!systemOnly) {\n+      for (Pair<Class<?>, T> entry : userTypeHierarchyList) {\n+        if (entry.first.isAssignableFrom(type)) {\n+          return entry.second;\n+        }\n       }\n     }\n     for (Pair<Class<?>, T> entry : systemTypeHierarchyList) {\n--- a/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n+++ b/gson/src/test/java/com/google/gson/MemoryRefStackTest.java\n   }\n \n   public void testPushPeekAndPop() throws Exception {\n-    ObjectTypePair obj = new ObjectTypePair(this, getClass(), true);\n+    ObjectTypePair obj = new ObjectTypePair(this, getClass(), true, false);\n \n     assertEquals(obj, stack.push(obj));\n     assertEquals(obj, stack.peek());\n   }\n \n   public void testPopTooMany() throws Exception {\n-    ObjectTypePair obj = new ObjectTypePair(this, getClass(), true);\n+    ObjectTypePair obj = new ObjectTypePair(this, getClass(), true, false);\n     stack.push(obj);\n     assertEquals(obj, stack.pop());\n \n     MockObject objA = new MockObject();\n     MockObject objB = new MockObject();\n     assertEquals(objA, objB);\n-    stack.push(new ObjectTypePair(objA, MockObject.class, true));\n-    assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true)));\n-    assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true)));\n+    stack.push(new ObjectTypePair(objA, MockObject.class, true, false));\n+    assertTrue(stack.contains(new ObjectTypePair(objA, MockObject.class, true, false)));\n+    assertFalse(stack.contains(new ObjectTypePair(objB, MockObject.class, true, false)));\n   }\n \n   private static class MockObject {\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeHandlerMapTest.java\n \n   public void testNullMap() throws Exception {\n     assertFalse(paramMap.hasSpecificHandlerFor(String.class));\n-    assertNull(paramMap.getHandlerFor(String.class));\n-    assertNull(paramMap.getHandlerFor(String.class));\n+    assertNull(paramMap.getHandlerFor(String.class, false));\n+    assertNull(paramMap.getHandlerFor(String.class, false));\n   }\n \n   public void testHasGenericButNotSpecific() throws Exception {\n \n     assertFalse(paramMap.hasSpecificHandlerFor(specificType));\n     assertTrue(paramMap.hasSpecificHandlerFor(List.class));\n-    assertNotNull(paramMap.getHandlerFor(specificType));\n-    assertNotNull(paramMap.getHandlerFor(List.class));\n-    assertEquals(handler, paramMap.getHandlerFor(specificType));\n+    assertNotNull(paramMap.getHandlerFor(specificType, false));\n+    assertNotNull(paramMap.getHandlerFor(List.class, false));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType, false));\n   }\n \n   public void testHasSpecificType() throws Exception {\n \n     assertTrue(paramMap.hasSpecificHandlerFor(specificType));\n     assertFalse(paramMap.hasSpecificHandlerFor(List.class));\n-    assertNotNull(paramMap.getHandlerFor(specificType));\n-    assertNull(paramMap.getHandlerFor(List.class));\n-    assertEquals(handler, paramMap.getHandlerFor(specificType));\n+    assertNotNull(paramMap.getHandlerFor(specificType, false));\n+    assertNull(paramMap.getHandlerFor(List.class, false));\n+    assertEquals(handler, paramMap.getHandlerFor(specificType, false));\n   }\n \n   public void testTypeOverridding() throws Exception {\n     paramMap.register(String.class, handler2, false);\n \n     assertTrue(paramMap.hasSpecificHandlerFor(String.class));\n-    assertEquals(handler2, paramMap.getHandlerFor(String.class));\n+    assertEquals(handler2, paramMap.getHandlerFor(String.class, false));\n   }\n \n   public void testMakeUnmodifiable() throws Exception {\n \n   public void testTypeHierarchy() {\n     paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n-    String handler = paramMap.getHandlerFor(Sub.class);\n+    String handler = paramMap.getHandlerFor(Sub.class, false);\n     assertEquals(\"baseHandler\", handler);\n   }\n \n   public void testTypeHierarchyMultipleHandlers() {\n     paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n     paramMap.registerForTypeHierarchy(Sub.class, \"subHandler\", false);\n-    String handler = paramMap.getHandlerFor(SubOfSub.class);\n+    String handler = paramMap.getHandlerFor(SubOfSub.class, false);\n     assertEquals(\"subHandler\", handler);\n   }\n \n     ParameterizedTypeHandlerMap<String> otherMap = new ParameterizedTypeHandlerMap<String>();\n     otherMap.registerForTypeHierarchy(Base.class, \"baseHandler2\", false);\n     paramMap.registerIfAbsent(otherMap);\n-    String handler = paramMap.getHandlerFor(Base.class);\n+    String handler = paramMap.getHandlerFor(Base.class, false);\n     assertEquals(\"baseHandler\", handler);\n   }\n \n   public void testReplaceExistingTypeHierarchyHandler() {\n     paramMap.registerForTypeHierarchy(Base.class, \"baseHandler\", false);\n     paramMap.registerForTypeHierarchy(Base.class, \"base2Handler\", false);\n-    String handler = paramMap.getHandlerFor(Base.class);\n+    String handler = paramMap.getHandlerFor(Base.class, false);\n     assertEquals(\"base2Handler\", handler);\n   }\n \n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/SystemOnlyTypeAdaptersTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.functional;\n+\n+import java.lang.reflect.Type;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+\n+/**\n+ * Functional tests for serialize default behavior where a custom type adapter is allowed to invoke\n+ * context.serialize on self.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public class SystemOnlyTypeAdaptersTest extends TestCase {\n+\n+  private Gson gson;\n+  @Override\n+  protected void setUp() throws Exception {\n+    super.setUp();\n+    this.gson = new GsonBuilder().registerTypeAdapter(Foo.class, new FooTypeAdapter()).create();\n+  }\n+\n+  public void testSerializeDefault() {\n+    String json = gson.toJson(new Foo());\n+    assertEquals(\"{\\\"a\\\":10,\\\"secret-key\\\":\\\"abracadabra\\\"}\", json);\n+  }\n+\n+  public void testDeserializeDefault() {\n+    String json = \"{a:5,'secret-key':'abracadabra'}\";\n+    Foo foo = gson.fromJson(json, Foo.class);\n+    assertEquals(5, foo.a);\n+  }\n+\n+  private static class Foo {\n+    int a = 10;\n+  }\n+\n+  private static class FooTypeAdapter implements JsonSerializer<Foo>, JsonDeserializer<Foo> {\n+    public JsonElement serialize(Foo src, Type typeOfSrc, JsonSerializationContext context) {\n+      JsonObject json = context.serializeDefault(src, typeOfSrc).getAsJsonObject();\n+      json.addProperty(\"secret-key\", \"abracadabra\");\n+      return json;\n+    }\n+\n+    public Foo deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      if (!\"abracadabra\".equals(json.getAsJsonObject().get(\"secret-key\").getAsString())) {\n+        throw new IllegalArgumentException(\"invalid key\");\n+      }\n+      return context.deserializeDefault(json, typeOfT);\n+    }\n+  }\n+}", "timestamp": 1309555760, "metainfo": ""}