{"sha": "d1de4cf676f669fe6771d12dd220e1a9f8d1a42a", "log": "renamed GsonBuilder.factory() to GsonBuilder.registerTypeAdapterFactory() revised GsonBuilder.registerTypeAdapter/registerTypeHierarchyAdapter to take streaming type adapters as well. Removed the typeAdapter() and typeHierarchyAdapter() methods from the public API.", "commit": "\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n   }\n \n   // TODO: nice documentation\n-  public GsonBuilder factory(TypeAdapter.Factory factory) {\n+  public GsonBuilder registerTypeAdapterFactory(TypeAdapter.Factory factory) {\n     typeAdapterFactories.add(factory);\n-    return this;\n-  }\n-\n-  // TODO: nice documentation\n-  public <T> GsonBuilder typeAdapter(final Class<T> type, final TypeAdapter<T> typeAdapter) {\n-    typeAdapterFactories.add(TypeAdapters.newFactory(type, typeAdapter));\n-    return this;\n-  }\n-\n-  // TODO: nice documentation\n-  // TODO: accept a Type instead of a TypeToken? It's less typesafe but more Gson-like\n-  public <T> GsonBuilder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n-    typeAdapterFactories.add(TypeAdapters.newFactory(type, typeAdapter));\n-    return this;\n-  }\n-\n-  // TODO: nice documentation\n-  public <T> GsonBuilder typeHierarchyAdapter(Class<T> type, TypeAdapter<T> typeAdapter) {\n-    typeAdapterFactories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n     return this;\n   }\n \n    * {@link JsonSerializer}, and a {@link JsonDeserializer} interfaces.\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n         || typeAdapter instanceof JsonDeserializer<?>\n         || typeAdapter instanceof InstanceCreator<?>\n-        || typeAdapter instanceof TypeAdapter.Factory);\n+        || typeAdapter instanceof TypeAdapter<?>);\n     if (Primitives.isPrimitive(type) || Primitives.isWrapperType(type)) {\n       throw new IllegalArgumentException(\n           \"Cannot register type adapters for \" + type);\n       TypeToken<?> typeToken = TypeToken.get(type);\n       typeAdapterFactories.add(new TreeTypeAdapter.SingleTypeFactory(typeToken, typeAdapter));\n     }\n-    if (typeAdapter instanceof TypeAdapter.Factory) {\n-      typeAdapterFactories.add((TypeAdapter.Factory) typeAdapter);\n-    }\n+    if (typeAdapter instanceof TypeAdapter<?>) {\n+      typeAdapter(TypeToken.get(type), (TypeAdapter)typeAdapter);\n+    }\n+    return this;\n+  }\n+\n+  // TODO: inline this method?\n+  private <T> GsonBuilder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+    typeAdapterFactories.add(TypeAdapters.newFactory(type, typeAdapter));\n     return this;\n   }\n \n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.7\n    */\n+  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>\n+        || typeAdapter instanceof TypeAdapter<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n     }\n     if (typeAdapter instanceof JsonDeserializer<?>) {\n       registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter);\n     }\n+    if (typeAdapter instanceof TypeAdapter<?>) {\n+      typeHierarchyAdapter(baseType, (TypeAdapter)typeAdapter);\n+    }\n+    return this;\n+  }\n+\n+  // TODO: inline this method?\n+  private <T> GsonBuilder typeHierarchyAdapter(Class<T> type, TypeAdapter<T> typeAdapter) {\n+    typeAdapterFactories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n     return this;\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/StreamingTypeAdaptersTest.java\n         writer.value(value.name);\n       }\n     };\n-    miniGson = new GsonBuilder().typeAdapter(Person.class, personNameAdapter).create();\n+    miniGson = new GsonBuilder().registerTypeAdapter(Person.class, personNameAdapter).create();\n     truckAdapter = miniGson.getAdapter(Truck.class);\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java\n   public void testSerializeNonstreamingTypeAdapterFollowedByStreamingTypeAdapter() {\n     Gson gson = new GsonBuilder()\n         .registerTypeAdapter(Foo.class, FOO_SERIALIZER)\n-        .typeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n+        .registerTypeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n         .create();\n     assertEquals(\"\\\"foo (via FOO_SERIALIZER)\\\"\", gson.toJson(new Foo(\"foo\")));\n   }\n \n   public void testSerializeStreamingTypeAdapterFollowedByNonstreamingTypeAdapter() {\n     Gson gson = new GsonBuilder()\n-        .typeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n+        .registerTypeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n         .registerTypeAdapter(Foo.class, FOO_SERIALIZER)\n         .create();\n     assertEquals(\"\\\"foo (via FOO_TYPE_ADAPTER)\\\"\", gson.toJson(new Foo(\"foo\")));\n   public void testDeserializeNonstreamingTypeAdapterFollowedByStreamingTypeAdapter() {\n     Gson gson = new GsonBuilder()\n         .registerTypeAdapter(Foo.class, FOO_DESERIALIZER)\n-        .typeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n+        .registerTypeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n         .create();\n     assertEquals(\"foo (via FOO_DESERIALIZER)\", gson.fromJson(\"foo\", Foo.class).name);\n   }\n \n   public void testDeserializeStreamingTypeAdapterFollowedByNonstreamingTypeAdapter() {\n     Gson gson = new GsonBuilder()\n-        .typeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n+        .registerTypeAdapter(Foo.class, FOO_TYPE_ADAPTER)\n         .registerTypeAdapter(Foo.class, FOO_DESERIALIZER)\n         .create();\n     assertEquals(\"foo (via FOO_TYPE_ADAPTER)\", gson.fromJson(\"foo\", Foo.class).name);", "timestamp": 1322006170, "metainfo": ""}