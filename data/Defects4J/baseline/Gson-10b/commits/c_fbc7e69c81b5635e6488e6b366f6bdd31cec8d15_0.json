{"sha": "fbc7e69c81b5635e6488e6b366f6bdd31cec8d15", "log": "Implement JsonPath in JsonReader.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   {\n     stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n   }\n+\n+  /*\n+   * The path members. It corresponds directly to stack: At indices where the\n+   * stack contains an object (EMPTY_OBJECT, DANGLING_NAME or NONEMPTY_OBJECT),\n+   * pathNames contains the name at this scope. Where it contains an array\n+   * (EMPTY_ARRAY, NONEMPTY_ARRAY) pathIndices contains the current index in\n+   * that array. Otherwise the value is undefined, and we take advantage of that\n+   * by incrementing pathIndices when doing so isn't useful.\n+   */\n+  private String[] pathNames = new String[32];\n+  private int[] pathIndices = new int[32];\n \n   /**\n    * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n     }\n     if (p == PEEKED_BEGIN_ARRAY) {\n       push(JsonScope.EMPTY_ARRAY);\n+      pathIndices[stackSize - 1] = 0;\n       peeked = PEEKED_NONE;\n     } else {\n       throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n   }\n \n       peeked = PEEKED_NONE;\n     } else {\n       throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n   }\n \n       peeked = PEEKED_NONE;\n     } else {\n       throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n   }\n \n     }\n     if (p == PEEKED_END_OBJECT) {\n       stackSize--;\n+      pathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\n       peeked = PEEKED_NONE;\n     } else {\n       throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n   }\n \n       result = nextQuotedValue('\"');\n     } else {\n       throw new IllegalStateException(\"Expected a name but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n     peeked = PEEKED_NONE;\n+    pathNames[stackSize - 1] = result;\n     return result;\n   }\n \n       pos += peekedNumberLength;\n     } else {\n       throw new IllegalStateException(\"Expected a string but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n     peeked = PEEKED_NONE;\n+    pathIndices[stackSize - 1]++;\n     return result;\n   }\n \n     }\n     if (p == PEEKED_TRUE) {\n       peeked = PEEKED_NONE;\n+      pathIndices[stackSize - 1]++;\n       return true;\n     } else if (p == PEEKED_FALSE) {\n       peeked = PEEKED_NONE;\n+      pathIndices[stackSize - 1]++;\n       return false;\n     }\n     throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n   }\n \n   /**\n     }\n     if (p == PEEKED_NULL) {\n       peeked = PEEKED_NONE;\n+      pathIndices[stackSize - 1]++;\n     } else {\n       throw new IllegalStateException(\"Expected null but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n   }\n \n \n     if (p == PEEKED_LONG) {\n       peeked = PEEKED_NONE;\n+      pathIndices[stackSize - 1]++;\n       return (double) peekedLong;\n     }\n \n       peekedString = nextUnquotedValue();\n     } else if (p != PEEKED_BUFFERED) {\n       throw new IllegalStateException(\"Expected a double but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n       throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n+    pathIndices[stackSize - 1]++;\n     return result;\n   }\n \n \n     if (p == PEEKED_LONG) {\n       peeked = PEEKED_NONE;\n+      pathIndices[stackSize - 1]++;\n       return peekedLong;\n     }\n \n       try {\n         long result = Long.parseLong(peekedString);\n         peeked = PEEKED_NONE;\n+        pathIndices[stackSize - 1]++;\n         return result;\n       } catch (NumberFormatException ignored) {\n         // Fall back to parse as a double below.\n       }\n     } else {\n       throw new IllegalStateException(\"Expected a long but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     long result = (long) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n       throw new NumberFormatException(\"Expected a long but was \" + peekedString\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n+    pathIndices[stackSize - 1]++;\n     return result;\n   }\n \n       result = (int) peekedLong;\n       if (peekedLong != result) { // Make sure no precision was lost casting to 'int'.\n         throw new NumberFormatException(\"Expected an int but was \" + peekedLong\n-            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n       }\n       peeked = PEEKED_NONE;\n+      pathIndices[stackSize - 1]++;\n       return result;\n     }\n \n       try {\n         result = Integer.parseInt(peekedString);\n         peeked = PEEKED_NONE;\n+        pathIndices[stackSize - 1]++;\n         return result;\n       } catch (NumberFormatException ignored) {\n         // Fall back to parse as a double below.\n       }\n     } else {\n       throw new IllegalStateException(\"Expected an int but was \" + peek()\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n \n     peeked = PEEKED_BUFFERED;\n     result = (int) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n       throw new NumberFormatException(\"Expected an int but was \" + peekedString\n-          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n     }\n     peekedString = null;\n     peeked = PEEKED_NONE;\n+    pathIndices[stackSize - 1]++;\n     return result;\n   }\n \n       }\n       peeked = PEEKED_NONE;\n     } while (count != 0);\n+\n+    pathIndices[stackSize - 1]++;\n+    pathNames[stackSize - 1] = \"null\";\n   }\n \n   private void push(int newTop) {\n     if (stackSize == stack.length) {\n       int[] newStack = new int[stackSize * 2];\n+      int[] newPathIndices = new int[stackSize * 2];\n+      String[] newPathNames = new String[stackSize * 2];\n       System.arraycopy(stack, 0, newStack, 0, stackSize);\n+      System.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\n+      System.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\n       stack = newStack;\n+      pathIndices = newPathIndices;\n+      pathNames = newPathNames;\n     }\n     stack[stackSize++] = newTop;\n   }\n   }\n \n   /**\n+   * Returns a <a href=\"http://goessner.net/articles/JsonPath/\">JsonPath</a> to\n+   * the current location in the JSON value.\n+   */\n+  public String getPath() {\n+    StringBuilder result = new StringBuilder().append('$');\n+    for (int i = 0, size = stackSize; i < size; i++) {\n+      switch (stack[i]) {\n+        case JsonScope.EMPTY_ARRAY:\n+        case JsonScope.NONEMPTY_ARRAY:\n+          result.append('[').append(pathIndices[i]).append(']');\n+          break;\n+\n+        case JsonScope.EMPTY_OBJECT:\n+        case JsonScope.DANGLING_NAME:\n+        case JsonScope.NONEMPTY_OBJECT:\n+          result.append('.');\n+          if (pathNames[i] != null) {\n+            result.append(pathNames[i]);\n+          }\n+          break;\n+\n+        case JsonScope.NONEMPTY_DOCUMENT:\n+        case JsonScope.EMPTY_DOCUMENT:\n+        case JsonScope.CLOSED:\n+          break;\n+      }\n+    }\n+    return result.toString();\n+  }\n+\n+  /**\n    * Unescapes the character identified by the character or characters that\n    * immediately follow a backslash. The backslash '\\' should have already\n    * been read. This supports both unicode escapes \"u000A\" and two-character\n    */\n   private IOException syntaxError(String message) throws IOException {\n     throw new MalformedJsonException(message\n-        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n   }\n \n   /**\n           reader.peeked = PEEKED_UNQUOTED;\n         } else {\n           throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n-              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber());\n+              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber()\n+              + \" path \" + reader.getPath());\n         }\n       }\n     };\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderPathTest.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import junit.framework.TestCase;\n+\n+public class JsonReaderPathTest extends TestCase {\n+  public void testPath() throws IOException {\n+    JsonReader reader = new JsonReader(\n+        new StringReader(\"{\\\"a\\\":[2,true,false,null,\\\"b\\\",{\\\"c\\\":\\\"d\\\"},[3]]}\"));\n+    assertEquals(\"$\", reader.getPath());\n+    reader.beginObject();\n+    assertEquals(\"$.\", reader.getPath());\n+    reader.nextName();\n+    assertEquals(\"$.a\", reader.getPath());\n+    reader.beginArray();\n+    assertEquals(\"$.a[0]\", reader.getPath());\n+    reader.nextInt();\n+    assertEquals(\"$.a[1]\", reader.getPath());\n+    reader.nextBoolean();\n+    assertEquals(\"$.a[2]\", reader.getPath());\n+    reader.nextBoolean();\n+    assertEquals(\"$.a[3]\", reader.getPath());\n+    reader.nextNull();\n+    assertEquals(\"$.a[4]\", reader.getPath());\n+    reader.nextString();\n+    assertEquals(\"$.a[5]\", reader.getPath());\n+    reader.beginObject();\n+    assertEquals(\"$.a[5].\", reader.getPath());\n+    reader.nextName();\n+    assertEquals(\"$.a[5].c\", reader.getPath());\n+    reader.nextString();\n+    assertEquals(\"$.a[5].c\", reader.getPath());\n+    reader.endObject();\n+    assertEquals(\"$.a[5]\", reader.getPath());\n+    reader.beginArray();\n+    assertEquals(\"$.a[5][0]\", reader.getPath());\n+    reader.nextInt();\n+    assertEquals(\"$.a[5][1]\", reader.getPath());\n+    reader.endArray();\n+    assertEquals(\"$.a[5]\", reader.getPath());\n+    reader.endArray();\n+    assertEquals(\"$.a\", reader.getPath());\n+    reader.endObject();\n+    assertEquals(\"$\", reader.getPath());\n+  }\n+\n+  public void testObjectPath() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n+    assertEquals(\"$\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$\", reader.getPath());\n+    reader.beginObject();\n+    assertEquals(\"$.\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$.\", reader.getPath());\n+    reader.nextName();\n+    assertEquals(\"$.a\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$.a\", reader.getPath());\n+    reader.nextInt();\n+    assertEquals(\"$.a\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$.a\", reader.getPath());\n+    reader.nextName();\n+    assertEquals(\"$.b\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$.b\", reader.getPath());\n+    reader.nextInt();\n+    assertEquals(\"$.b\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$.b\", reader.getPath());\n+    reader.endObject();\n+    assertEquals(\"$\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$\", reader.getPath());\n+    reader.close();\n+    assertEquals(\"$\", reader.getPath());\n+  }\n+\n+  public void testArrayPath() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[1,2]\"));\n+    assertEquals(\"$\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$\", reader.getPath());\n+    reader.beginArray();\n+    assertEquals(\"$[0]\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$[0]\", reader.getPath());\n+    reader.nextInt();\n+    assertEquals(\"$[1]\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$[1]\", reader.getPath());\n+    reader.nextInt();\n+    assertEquals(\"$[2]\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$[2]\", reader.getPath());\n+    reader.endArray();\n+    assertEquals(\"$\", reader.getPath());\n+\n+    reader.peek();\n+    assertEquals(\"$\", reader.getPath());\n+    reader.close();\n+    assertEquals(\"$\", reader.getPath());\n+  }\n+\n+  public void testMultipleTopLevelValuesInOneDocument() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[][]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    reader.endArray();\n+    assertEquals(\"$\", reader.getPath());\n+    reader.beginArray();\n+    reader.endArray();\n+    assertEquals(\"$\", reader.getPath());\n+  }\n+\n+  public void testSkipArrayElements() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[1,2,3]\"));\n+    reader.beginArray();\n+    reader.skipValue();\n+    reader.skipValue();\n+    assertEquals(\"$[2]\", reader.getPath());\n+  }\n+\n+  public void testSkipObjectNames() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1}\"));\n+    reader.beginObject();\n+    reader.skipValue();\n+    assertEquals(\"$.null\", reader.getPath());\n+  }\n+\n+  public void testSkipObjectValues() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":1,\\\"b\\\":2}\"));\n+    reader.beginObject();\n+    reader.nextName();\n+    reader.skipValue();\n+    assertEquals(\"$.null\", reader.getPath());\n+    reader.nextName();\n+    assertEquals(\"$.b\", reader.getPath());\n+  }\n+\n+  public void testSkipNestedStructures() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[[1,2,3],4]\"));\n+    reader.beginArray();\n+    reader.skipValue();\n+    assertEquals(\"$[1]\", reader.getPath());\n+  }\n+}\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n   }\n \n   public void testFailWithPosition() throws IOException {\n-    testFailWithPosition(\"Expected value at line 6 column 5\",\n+    testFailWithPosition(\"Expected value at line 6 column 5 path $[1]\",\n         \"[\\n\\n\\n\\n\\n\\\"a\\\",}]\");\n   }\n \n   public void testFailWithPositionGreaterThanBufferSize() throws IOException {\n     String spaces = repeat(' ', 8192);\n-    testFailWithPosition(\"Expected value at line 6 column 5\",\n+    testFailWithPosition(\"Expected value at line 6 column 5 path $[1]\",\n         \"[\\n\\n\" + spaces + \"\\n\\n\\n\\\"a\\\",}]\");\n   }\n \n   public void testFailWithPositionOverSlashSlashEndOfLineComment() throws IOException {\n-    testFailWithPosition(\"Expected value at line 5 column 6\",\n+    testFailWithPosition(\"Expected value at line 5 column 6 path $[1]\",\n         \"\\n// foo\\n\\n//bar\\r\\n[\\\"a\\\",}\");\n   }\n \n   public void testFailWithPositionOverHashEndOfLineComment() throws IOException {\n-    testFailWithPosition(\"Expected value at line 5 column 6\",\n+    testFailWithPosition(\"Expected value at line 5 column 6 path $[1]\",\n         \"\\n# foo\\n\\n#bar\\r\\n[\\\"a\\\",}\");\n   }\n \n   public void testFailWithPositionOverCStyleComment() throws IOException {\n-    testFailWithPosition(\"Expected value at line 6 column 12\",\n+    testFailWithPosition(\"Expected value at line 6 column 12 path $[1]\",\n         \"\\n\\n/* foo\\n*\\n*\\r\\nbar */[\\\"a\\\",}\");\n   }\n \n   public void testFailWithPositionOverQuotedString() throws IOException {\n-    testFailWithPosition(\"Expected value at line 5 column 3\", \"[\\\"foo\\nbar\\r\\nbaz\\n\\\",\\n  }\");\n+    testFailWithPosition(\"Expected value at line 5 column 3 path $[1]\",\n+        \"[\\\"foo\\nbar\\r\\nbaz\\n\\\",\\n  }\");\n   }\n \n   public void testFailWithPositionOverUnquotedString() throws IOException {\n-    testFailWithPosition(\"Expected value at line 5 column 2\", \"[\\n\\nabcd\\n\\n,}\");\n+    testFailWithPosition(\"Expected value at line 5 column 2 path $[1]\", \"[\\n\\nabcd\\n\\n,}\");\n   }\n \n   public void testFailWithEscapedNewlineCharacter() throws IOException {\n-    testFailWithPosition(\"Expected value at line 5 column 3\", \"[\\n\\n\\\"\\\\\\n\\n\\\",}\");\n+    testFailWithPosition(\"Expected value at line 5 column 3 path $[1]\", \"[\\n\\n\\\"\\\\\\n\\n\\\",}\");\n   }\n \n   public void testFailWithPositionIsOffsetByBom() throws IOException {\n-    testFailWithPosition(\"Expected value at line 1 column 6\",\n+    testFailWithPosition(\"Expected value at line 1 column 6 path $[1]\",\n         \"\\ufeff[\\\"a\\\",}]\");\n   }\n \n     }\n   }\n \n+  public void testFailWithPositionDeepPath() throws IOException {\n+    JsonReader reader = new JsonReader(reader(\"[1,{\\\"a\\\":[2,3,}\"));\n+    reader.beginArray();\n+    reader.nextInt();\n+    reader.beginObject();\n+    reader.nextName();\n+    reader.beginArray();\n+    reader.nextInt();\n+    reader.nextInt();\n+    try {\n+      reader.peek();\n+      fail();\n+    } catch (IOException expected) {\n+      assertEquals(\"Expected value at line 1 column 14 path $[1].a[2]\", expected.getMessage());\n+    }\n+  }\n+\n   public void testStrictVeryLongNumber() throws IOException {\n     JsonReader reader = new JsonReader(reader(\"[0.\" + repeat('9', 8192) + \"]\"));\n     reader.beginArray();\n     for (int i = 0; i < 40; i++) {\n       reader.beginArray();\n     }\n+    assertEquals(\"$[0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0][0]\"\n+        + \"[0][0][0][0][0][0][0][0][0][0][0][0][0][0]\", reader.getPath());\n     for (int i = 0; i < 40; i++) {\n       reader.endArray();\n     }\n       reader.beginObject();\n       assertEquals(\"a\", reader.nextName());\n     }\n+    assertEquals(\"$.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a\"\n+        + \".a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a.a\", reader.getPath());\n     assertEquals(true, reader.nextBoolean());\n     for (int i = 0; i < 40; i++) {\n       reader.endObject();", "timestamp": 1406783874, "metainfo": ""}