{"sha": "1794182a560588973c6ec131e9c24bd39508433d", "log": "Commit to factories as the mechanism to lookup type adapters. This uses factories for type hierarchy adapters. We keep a separate list of factories for tree-style adapters registered with registerTypeHierarchyAdapter to guarantee that these come after the non-hierarchy adapters.  This drops support for type hierarchy instance creators. I don't expect this to be a problem. We'll also detect fewer errors where multiple type adapters can serialize the same type. With APIs like getNextTypeAdapter, I think this might actually be an improvement!", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.Excluder;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.TypeMap;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.BigDecimalTypeAdapter;\n import com.google.gson.internal.bind.BigIntegerTypeAdapter;\n  * @author Joel Leitch\n  */\n public final class Gson {\n-  @SuppressWarnings(\"rawtypes\")\n-  static final TypeMap EMPTY_MAP = new TypeMap().makeUnmodifiable();\n-\n   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n \n   private static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n \n   private final List<TypeAdapter.Factory> factories;\n   private final ConstructorConstructor constructorConstructor;\n-\n-  /** Map containing Type or Class objects as keys */\n-  private final TypeMap<JsonSerializer<?>> serializers;\n-\n-  /** Map containing Type or Class objects as keys */\n-  private final TypeMap<JsonDeserializer<?>> deserializers;\n \n   private final boolean serializeNulls;\n   private final boolean htmlSafe;\n   @SuppressWarnings(\"unchecked\")\n   public Gson() {\n     this(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\n-        EMPTY_MAP, false, EMPTY_MAP, EMPTY_MAP, false, DEFAULT_JSON_NON_EXECUTABLE, true,\n-        false, false, LongSerializationPolicy.DEFAULT,\n+        Collections.<Type, InstanceCreator<?>>emptyMap(), false, false, DEFAULT_JSON_NON_EXECUTABLE,\n+        true, false, false, LongSerializationPolicy.DEFAULT,\n         Collections.<TypeAdapter.Factory>emptyList());\n   }\n \n   Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingPolicy,\n-      final TypeMap<InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n-      final TypeMap<JsonSerializer<?>> serializers,\n-      final TypeMap<JsonDeserializer<?>> deserializers,\n+      final Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\n       boolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\n       boolean prettyPrinting, boolean serializeSpecialFloatingPointValues,\n       LongSerializationPolicy longSerializationPolicy,\n       List<TypeAdapter.Factory> typeAdapterFactories) {\n     this.constructorConstructor = new ConstructorConstructor(instanceCreators);\n     this.serializeNulls = serializeNulls;\n-    this.serializers = serializers;\n-    this.deserializers = deserializers;\n     this.generateNonExecutableJson = generateNonExecutableGson;\n     this.htmlSafe = htmlSafe;\n     this.prettyPrinting = prettyPrinting;\n       factories.add(factory);\n     }\n \n-    factories.add(new TreeTypeAdapter.TypeHierarchyFactory(serializers, deserializers));\n     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(TypeAdapters.URL_FACTORY);\n     factories.add(TypeAdapters.URI_FACTORY);\n   public String toString() {\n   \tStringBuilder sb = new StringBuilder(\"{\")\n   \t    .append(\"serializeNulls:\").append(serializeNulls)\n-  \t    .append(\",serializers:\").append(serializers)\n-  \t    .append(\",deserializers:\").append(deserializers)\n-\n+  \t    .append(\"factories:\").append(factories)\n       \t// using the name instanceCreator instead of ObjectConstructor since the users of Gson are\n       \t// more familiar with the concept of Instance Creators. Moreover, the objectConstructor is\n       \t// just a utility class around instance creators, and its toString() only displays them.\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Excluder;\n import com.google.gson.internal.Primitives;\n-import com.google.gson.internal.TypeMap;\n import com.google.gson.internal.bind.TypeAdapters;\n import com.google.gson.reflect.TypeToken;\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.util.ArrayList;\n import java.util.Date;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n  */\n public final class GsonBuilder {\n   private Excluder excluder = Excluder.DEFAULT;\n-\n-  private LongSerializationPolicy longSerializationPolicy;\n-  private FieldNamingStrategy fieldNamingPolicy;\n-  private final TypeMap<InstanceCreator<?>> instanceCreators;\n-  private final TypeMap<JsonSerializer<?>> serializers;\n-  private final TypeMap<JsonDeserializer<?>> deserializers;\n-  private final List<TypeAdapter.Factory> typeAdapterFactories\n+  private LongSerializationPolicy longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n+  private FieldNamingStrategy fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\n+  private final Map<Type, InstanceCreator<?>> instanceCreators\n+      = new HashMap<Type, InstanceCreator<?>>();\n+  private final List<TypeAdapter.Factory> factories\n+      = new ArrayList<TypeAdapter.Factory>();\n+  /** tree-style hierarchy factories. These come after factories for backwards compatibility. */\n+  private final List<TypeAdapter.Factory> hierarchyFactories\n       = new ArrayList<TypeAdapter.Factory>();\n   private boolean serializeNulls;\n   private String datePattern;\n-  private int dateStyle;\n-  private int timeStyle;\n-  private boolean complexMapKeySerialization = false;\n+  private int dateStyle = DateFormat.DEFAULT;\n+  private int timeStyle = DateFormat.DEFAULT;\n+  private boolean complexMapKeySerialization;\n   private boolean serializeSpecialFloatingPointValues;\n-  private boolean escapeHtmlChars;\n+  private boolean escapeHtmlChars = true;\n   private boolean prettyPrinting;\n   private boolean generateNonExecutableJson;\n \n    * {@link #create()}.\n    */\n   public GsonBuilder() {\n-    // setup default values\n-    prettyPrinting = false;\n-    escapeHtmlChars = true;\n-    longSerializationPolicy = LongSerializationPolicy.DEFAULT;\n-    fieldNamingPolicy = FieldNamingPolicy.IDENTITY;\n-    instanceCreators = new TypeMap<InstanceCreator<?>>();\n-    serializers = new TypeMap<JsonSerializer<?>>();\n-    deserializers = new TypeMap<JsonDeserializer<?>>();\n-    serializeNulls = false;\n-    dateStyle = DateFormat.DEFAULT;\n-    timeStyle = DateFormat.DEFAULT;\n-    serializeSpecialFloatingPointValues = false;\n-    generateNonExecutableJson = false;\n   }\n \n   // TODO: nice documentation\n   public GsonBuilder registerTypeAdapterFactory(TypeAdapter.Factory factory) {\n-    typeAdapterFactories.add(factory);\n+    factories.add(factory);\n     return this;\n   }\n \n     }\n     if (typeAdapter instanceof JsonSerializer<?> || typeAdapter instanceof JsonDeserializer<?>) {\n       TypeToken<?> typeToken = TypeToken.get(type);\n-      typeAdapterFactories.add(new TreeTypeAdapter.SingleTypeFactory(typeToken, typeAdapter));\n+      factories.add(TreeTypeAdapter.newFactory(typeToken, typeAdapter));\n     }\n     if (typeAdapter instanceof TypeAdapter<?>) {\n       typeAdapter(TypeToken.get(type), (TypeAdapter)typeAdapter);\n \n   // TODO: inline this method?\n   private <T> GsonBuilder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n-    typeAdapterFactories.add(TypeAdapters.newFactory(type, typeAdapter));\n+    factories.add(TypeAdapters.newFactory(type, typeAdapter));\n     return this;\n   }\n \n    */\n   private <T> GsonBuilder registerInstanceCreator(Type typeOfT,\n       InstanceCreator<? extends T> instanceCreator) {\n-    instanceCreators.register(typeOfT, instanceCreator);\n+    instanceCreators.put(typeOfT, instanceCreator);\n     return this;\n   }\n \n   @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n     $Gson$Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>\n+        || typeAdapter instanceof JsonDeserializer<?>\n         || typeAdapter instanceof TypeAdapter<?>);\n-    if (typeAdapter instanceof InstanceCreator<?>) {\n-      registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n-    }\n-    if (typeAdapter instanceof JsonSerializer<?>) {\n-      registerSerializerForTypeHierarchy(baseType, (JsonSerializer<?>) typeAdapter);\n-    }\n-    if (typeAdapter instanceof JsonDeserializer<?>) {\n-      registerDeserializerForTypeHierarchy(baseType, (JsonDeserializer<?>) typeAdapter);\n+    if (typeAdapter instanceof JsonDeserializer || typeAdapter instanceof JsonSerializer) {\n+      hierarchyFactories.add(0,\n+          TreeTypeAdapter.newTypeHierarchyFactory(baseType, typeAdapter));\n     }\n     if (typeAdapter instanceof TypeAdapter<?>) {\n       typeHierarchyAdapter(baseType, (TypeAdapter)typeAdapter);\n \n   // TODO: inline this method?\n   private <T> GsonBuilder typeHierarchyAdapter(Class<T> type, TypeAdapter<T> typeAdapter) {\n-    typeAdapterFactories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n-    return this;\n-  }\n-\n-  private <T> GsonBuilder registerInstanceCreatorForTypeHierarchy(Class<?> classOfT,\n-      InstanceCreator<? extends T> instanceCreator) {\n-    instanceCreators.registerForTypeHierarchy(classOfT, instanceCreator);\n-    return this;\n-  }\n-\n-  private <T> GsonBuilder registerSerializerForTypeHierarchy(Class<?> classOfT,\n-      JsonSerializer<T> serializer) {\n-    serializers.registerForTypeHierarchy(classOfT, serializer);\n-    return this;\n-  }\n-\n-  private <T> GsonBuilder registerDeserializerForTypeHierarchy(Class<?> classOfT,\n-      JsonDeserializer<T> deserializer) {\n-    deserializers.registerForTypeHierarchy(classOfT,\n-        new JsonDeserializerExceptionWrapper<T>(deserializer));\n+    factories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n     return this;\n   }\n \n    * @return an instance of Gson configured with the options currently set in this builder\n    */\n   public Gson create() {\n-    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, serializers, deserializers);\n-\n-    return new Gson(excluder, fieldNamingPolicy, instanceCreators.copyOf().makeUnmodifiable(),\n-        serializeNulls, serializers.copyOf().makeUnmodifiable(),\n-        deserializers.copyOf().makeUnmodifiable(), complexMapKeySerialization,\n+    List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    factories.addAll(this.factories);\n+    factories.addAll(this.hierarchyFactories);\n+    addTypeAdaptersForDate(datePattern, dateStyle, timeStyle, factories);\n+\n+    return new Gson(excluder, fieldNamingPolicy, instanceCreators,\n+        serializeNulls, complexMapKeySerialization,\n         generateNonExecutableJson, escapeHtmlChars, prettyPrinting,\n-        serializeSpecialFloatingPointValues, longSerializationPolicy, typeAdapterFactories);\n-  }\n-\n-  private static void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n-      TypeMap<JsonSerializer<?>> serializers, TypeMap<JsonDeserializer<?>> deserializers) {\n-    DefaultDateTypeAdapter dateTypeAdapter = null;\n+        serializeSpecialFloatingPointValues, longSerializationPolicy, factories);\n+  }\n+\n+  private void addTypeAdaptersForDate(String datePattern, int dateStyle, int timeStyle,\n+      List<TypeAdapter.Factory> factories) {\n+    DefaultDateTypeAdapter dateTypeAdapter;\n     if (datePattern != null && !\"\".equals(datePattern.trim())) {\n       dateTypeAdapter = new DefaultDateTypeAdapter(datePattern);\n     } else if (dateStyle != DateFormat.DEFAULT && timeStyle != DateFormat.DEFAULT) {\n       dateTypeAdapter = new DefaultDateTypeAdapter(dateStyle, timeStyle);\n-    }\n-\n-    if (dateTypeAdapter != null) {\n-      registerIfAbsent(Date.class, serializers, dateTypeAdapter);\n-      registerIfAbsent(Date.class, deserializers, dateTypeAdapter);\n-      registerIfAbsent(Timestamp.class, serializers, dateTypeAdapter);\n-      registerIfAbsent(Timestamp.class, deserializers, dateTypeAdapter);\n-      registerIfAbsent(java.sql.Date.class, serializers, dateTypeAdapter);\n-      registerIfAbsent(java.sql.Date.class, deserializers, dateTypeAdapter);\n-    }\n-  }\n-\n-  private static <T> void registerIfAbsent(Class<?> type, TypeMap<T> adapters, T adapter) {\n-    if (!adapters.hasSpecificHandlerFor(type)) {\n-      adapters.register(type, adapter);\n-    }\n+    } else {\n+      return;\n+    }\n+\n+    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Date.class), dateTypeAdapter));\n+    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(Timestamp.class), dateTypeAdapter));\n+    factories.add(TreeTypeAdapter.newFactory(TypeToken.get(java.sql.Date.class), dateTypeAdapter));\n   }\n }\n--- a/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/TreeTypeAdapter.java\n \n import com.google.gson.internal.$Gson$Preconditions;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.TypeMap;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonWriter;\n import java.io.IOException;\n-import java.lang.reflect.Type;\n \n /**\n  * Adapts a Gson 1.x tree-style adapter as a streaming TypeAdapter. Since the\n         : (delegate = gson.getNextAdapter(skipPast, typeToken));\n   }\n \n-  public static class SingleTypeFactory implements TypeAdapter.Factory {\n-    private final TypeToken<?> typeToken;\n+  public static Factory newFactory(TypeToken<?> exactType, Object typeAdapter) {\n+    return new SingleTypeFactory(typeAdapter, exactType, null);\n+  }\n+\n+  public static Factory newTypeHierarchyFactory(Class<?> hierarchyType, Object typeAdapter) {\n+    return new SingleTypeFactory(typeAdapter, null, hierarchyType);\n+  }\n+\n+  private static class SingleTypeFactory implements TypeAdapter.Factory {\n+    private final TypeToken<?> exactType;\n+    private final Class<?> hierarchyType;\n     private final JsonSerializer<?> serializer;\n     private final JsonDeserializer<?> deserializer;\n \n-    public SingleTypeFactory(TypeToken<?> typeToken, Object typeAdapter) {\n-      this.typeToken = typeToken;\n+    private SingleTypeFactory(Object typeAdapter, TypeToken<?> exactType, Class<?> hierarchyType) {\n       serializer = typeAdapter instanceof JsonSerializer\n           ? (JsonSerializer) typeAdapter\n           : null;\n           ? (JsonDeserializer) typeAdapter\n           : null;\n       $Gson$Preconditions.checkArgument(serializer != null || deserializer != null);\n+      this.exactType = exactType;\n+      this.hierarchyType = hierarchyType;\n     }\n \n     @SuppressWarnings(\"unchecked\") // guarded by typeToken.equals() call\n     public <T> TypeAdapter<T> create(Gson context, TypeToken<T> type) {\n-      return typeToken.equals(type)\n+      boolean matches = exactType != null\n+          ? exactType.equals(type)\n+          : hierarchyType.isAssignableFrom(type.getRawType());\n+      return matches\n           ? new TreeTypeAdapter<T>((JsonSerializer<T>) serializer,\n               (JsonDeserializer<T>) deserializer, context, type, this)\n           : null;\n     }\n   }\n-\n-  public static class TypeHierarchyFactory implements TypeAdapter.Factory {\n-    private final TypeMap<JsonSerializer<?>> serializers;\n-    private final TypeMap<JsonDeserializer<?>> deserializers;\n-\n-    public TypeHierarchyFactory(TypeMap<JsonSerializer<?>> serializers,\n-        TypeMap<JsonDeserializer<?>> deserializers) {\n-      this.serializers = serializers;\n-      this.deserializers = deserializers;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\") // guaranteed by serializers lookup matching type\n-    public <T> TypeAdapter<T> create(Gson context, TypeToken<T> typeToken) {\n-      Type type = typeToken.getType();\n-      JsonSerializer<T> serializer = (JsonSerializer<T>) serializers.getHandlerFor(type);\n-      JsonDeserializer<T> deserializer = (JsonDeserializer<T>) deserializers.getHandlerFor(type);\n-      return (serializer != null || deserializer != null)\n-          ? new TreeTypeAdapter<T>(serializer, deserializer, context, typeToken, this)\n-          : null;\n-    }\n-  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n import java.lang.reflect.Type;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.LinkedHashMap;\n import java.util.LinkedHashSet;\n import java.util.LinkedList;\n  * Returns a function that can construct an instance of a requested type.\n  */\n public final class ConstructorConstructor {\n-  private final TypeMap<InstanceCreator<?>> instanceCreators;\n+  private final Map<Type, InstanceCreator<?>> instanceCreators;\n \n-  public ConstructorConstructor(TypeMap<InstanceCreator<?>> instanceCreators) {\n+  public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\n     this.instanceCreators = instanceCreators;\n   }\n \n   public ConstructorConstructor() {\n-    this(new TypeMap<InstanceCreator<?>>());\n+    this(Collections.<Type, InstanceCreator<?>>emptyMap());\n   }\n \n   public <T> ObjectConstructor<T> getConstructor(TypeToken<T> typeToken) {\n     // first try an instance creator\n \n     @SuppressWarnings(\"unchecked\") // types must agree\n-    final InstanceCreator<T> creator\n-        = (InstanceCreator<T>) instanceCreators.getHandlerFor(type);\n+    final InstanceCreator<T> creator = (InstanceCreator<T>) instanceCreators.get(type);\n     if (creator != null) {\n       return new ObjectConstructor<T>() {\n         public T construct() {\n--- a/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TypeAdapterPrecedenceTest.java\n     assertEquals(\"foo via type adapter\", gson.fromJson(\"foo\", Foo.class).name);\n   }\n \n+  public void testNonstreamingHierarchicalFollowedByNonstreaming() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeHierarchyAdapter(Foo.class, newSerializer(\"hierarchical\"))\n+        .registerTypeHierarchyAdapter(Foo.class, newDeserializer(\"hierarchical\"))\n+        .registerTypeAdapter(Foo.class, newSerializer(\"non hierarchical\"))\n+        .registerTypeAdapter(Foo.class, newDeserializer(\"non hierarchical\"))\n+        .create();\n+    assertEquals(\"\\\"foo via non hierarchical\\\"\", gson.toJson(new Foo(\"foo\")));\n+    assertEquals(\"foo via non hierarchical\", gson.fromJson(\"foo\", Foo.class).name);\n+  }\n+\n   private static class Foo {\n     final String name;\n     private Foo(String name) {\n--- a/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/TypeHierarchyAdapterTest.java\n     assertEquals(manager.userid, copied.userid);\n   }\n \n-  public void testRegisterSubTypeFirstNotAllowed() {\n-    try {\n-      new GsonBuilder()\n-          .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())\n-          .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())\n-          .create();\n-      fail();\n-    } catch (IllegalArgumentException expected) {\n-    }\n+  /** This behaviour changed in Gson 2.1; it used to throw. */\n+  public void testRegisterSubTypeFirstAllowed() {\n+    new GsonBuilder()\n+        .registerTypeHierarchyAdapter(Manager.class, new ManagerAdapter())\n+        .registerTypeHierarchyAdapter(Employee.class, new EmployeeAdapter())\n+        .create();\n   }\n \n   static class ManagerAdapter implements JsonSerializer<Manager>, JsonDeserializer<Manager> {", "timestamp": 1322029015, "metainfo": ""}