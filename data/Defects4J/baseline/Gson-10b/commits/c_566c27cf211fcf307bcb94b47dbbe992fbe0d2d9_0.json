{"sha": "566c27cf211fcf307bcb94b47dbbe992fbe0d2d9", "log": "Adapted legacy Gson adapters into mini Gson.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n   //TODO(inder): get rid of all the registerXXX methods and take all such parameters in the\n   // constructor instead. At the minimum, mark those methods private.\n \n-  static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n+   static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n \n   // Default instances of plug-ins\n   static final AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY =\n \n   Gson(ExclusionStrategy deserializationExclusionStrategy,\n       ExclusionStrategy serializationExclusionStrategy, FieldNamingStrategy2 fieldNamingPolicy,\n-      MappedObjectConstructor objectConstructor, boolean serializeNulls,\n-      ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n-      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n+      final MappedObjectConstructor objectConstructor, boolean serializeNulls,\n+      final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n       boolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) {\n     this.deserializationExclusionStrategy = deserializationExclusionStrategy;\n     this.serializationExclusionStrategy = serializationExclusionStrategy;\n             new FieldAttributes(declaringClazz, f, declaredType));\n       }\n     };\n-    \n+\n     this.miniGson = new MiniGson.Builder()\n         .withoutDefaultFactories()\n         .factory(TypeAdapters.BOOLEAN_FACTORY)\n         .factory(TypeAdapters.DOUBLE_FACTORY)\n         .factory(TypeAdapters.LONG_FACTORY)\n         .factory(TypeAdapters.STRING_FACTORY)\n+        .factory(new GsonToMiniGsonTypeAdapter(serializers, deserializers, serializeNulls))\n         .factory(CollectionTypeAdapter.FACTORY)\n         .factory(StringToValueMapTypeAdapter.FACTORY)\n         .factory(ArrayTypeAdapter.FACTORY)\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/GsonToMiniGsonTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson;\n+\n+import java.beans.DesignMode;\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+final class GsonToMiniGsonTypeAdapter implements TypeAdapter.Factory {\n+  private final ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers;\n+  private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n+  private final boolean serializeNulls;\n+\n+  GsonToMiniGsonTypeAdapter(ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\n+      ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers, boolean serializeNulls) {\n+    this.serializers = serializers;\n+    this.deserializers = deserializers;\n+    this.serializeNulls = serializeNulls;\n+  }\n+\n+  public <T> TypeAdapter<T> create(final MiniGson miniGson, TypeToken<T> type) {\n+    final Type typeOfT = type.getType();\n+    final JsonSerializer serializer = serializers.getHandlerFor(typeOfT, false);\n+    final JsonDeserializer deserializer = deserializers.getHandlerFor(typeOfT, false);\n+    if (serializer == null && deserializer == null) {\n+      return null;\n+    }\n+    return new TypeAdapter() {\n+      @Override\n+      public Object read(JsonReader reader) throws IOException {\n+        if (deserializer == null) {\n+          // TODO: handle if deserializer is null\n+          throw new UnsupportedOperationException();\n+        }\n+        return deserializer.deserialize(Streams.parse(reader), typeOfT, createDeserializationContext(miniGson));\n+      }\n+      @Override\n+      public void write(JsonWriter writer, Object value) throws IOException {\n+        if (serializer == null) {\n+          // TODO: handle if serializer is null\n+          throw new UnsupportedOperationException();\n+        }\n+        JsonElement element = serializer.serialize(value, typeOfT, createSerializationContext(miniGson));\n+        Streams.write(element, serializeNulls, writer);\n+      }\n+    };\n+  }\n+  \n+  public JsonSerializationContext createSerializationContext(final MiniGson miniGson) {\n+    return new JsonSerializationContext() {\n+      @Override\n+      JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType, boolean defaultOnly) {\n+        try {\n+          TypeToken typeToken = TypeToken.get(typeOfSrc);\n+          String json = miniGson.getAdapter(typeToken).toJson(src);\n+          JsonReader jsonReader = new JsonReader(new StringReader(json));\n+          jsonReader.setLenient(true);\n+          return Streams.parse(jsonReader);\n+        } catch (IOException e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+    };\n+  }\n+  public JsonDeserializationContext createDeserializationContext(final MiniGson miniGson) {\n+    return new JsonDeserializationContext() {\n+      @Override\n+      public <T> T deserialize(JsonElement json, Type typeOfT) throws JsonParseException {\n+        try {\n+          TypeToken typeToken = TypeToken.get(typeOfT);\n+          StringWriter stringWriter = new StringWriter();\n+          JsonWriter jsonWriter = new JsonWriter(stringWriter);\n+          jsonWriter.setLenient(true);\n+          Streams.write(json, serializeNulls, jsonWriter);\n+          Object target = miniGson.getAdapter(typeToken).fromJson(stringWriter.toString());\n+          return (T) target;\n+        } catch (IOException e) {\n+          throw new JsonParseException(e);\n+        }\n+      }\n+    };\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContext.java\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n-public final class JsonDeserializationContext {\n+public class JsonDeserializationContext {\n   private final ObjectNavigator objectNavigator;\n   private final FieldNamingStrategy2 fieldNamingPolicy;\n   private final ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers;\n     this.objectConstructor = objectConstructor;\n   }\n \n+  JsonDeserializationContext() {\n+    this(null, null, null, null);\n+  }\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T construct(Type type) {\n--- a/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationContext.java\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n-public final class JsonSerializationContext {\n+public class JsonSerializationContext {\n \n   private final ObjectNavigator objectNavigator;\n   private final FieldNamingStrategy2 fieldNamingPolicy;\n     this.serializeNulls = serializeNulls;\n     this.serializers = serializers;\n     this.ancestors = new MemoryRefStack();\n+  }\n+  \n+  JsonSerializationContext() {\n+    this(null, null, false, null);\n   }\n \n   /**", "timestamp": 1312337862, "metainfo": ""}