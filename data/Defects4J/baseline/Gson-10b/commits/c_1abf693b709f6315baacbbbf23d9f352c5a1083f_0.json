{"sha": "1abf693b709f6315baacbbbf23d9f352c5a1083f", "log": "Fix for Issue 55 where GSON was unable to deserialize JSON with single quotes (') used for field name/values. Gson now supports different fields with-in the JSON to use either single quote or double quote. However, a single field name or value must use ' or \"\" to delimit itself.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonParser.java\n+++ b/gson/src/main/java/com/google/gson/JsonParser.java\n   final public JsonElement parse() throws ParseException {\n   JsonElement json = null;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 15:\n+    case 17:\n       json = JsonObject();\n       break;\n-    case 20:\n+    case 22:\n       json = JsonArray();\n       break;\n     case DIGITS:\n+    case SINGLE_QUOTE_LITERAL:\n     case QUOTE:\n-    case 22:\n-    case 23:\n     case 24:\n+    case 25:\n+    case 26:\n       json = JsonPrimitive();\n       break;\n-    case 17:\n+    case 19:\n       json = JsonNull();\n       break;\n     default:\n \n   final private JsonObject JsonObject() throws ParseException {\n   JsonObject o = new JsonObject();\n-    jj_consume_token(15);\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    jj_consume_token(17);\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n     case QUOTE:\n       Members(o);\n       break;\n       jj_la1[1] = jj_gen;\n       ;\n     }\n-    jj_consume_token(16);\n+    jj_consume_token(18);\n     {if (true) return o;}\n     throw new Error(\"Missing return statement in function\");\n   }\n \n   final private JsonNull JsonNull() throws ParseException {\n   JsonNull json = new JsonNull();\n-    jj_consume_token(17);\n+    jj_consume_token(19);\n     {if (true) return json;}\n     throw new Error(\"Missing return statement in function\");\n   }\n   final private void Members(JsonObject o) throws ParseException {\n     Pair(o);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 18:\n-      jj_consume_token(18);\n+    case 20:\n+      jj_consume_token(20);\n       Members(o);\n       break;\n     default:\n   JsonPrimitive property;\n   JsonElement value;\n     property = JsonString();\n-    jj_consume_token(19);\n+    jj_consume_token(21);\n     value = JsonValue();\n     o.add(property.getAsString(), value);\n   }\n \n   final private JsonArray JsonArray() throws ParseException {\n   JsonArray array = new JsonArray();\n-    jj_consume_token(20);\n+    jj_consume_token(22);\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n     case DIGITS:\n+    case SINGLE_QUOTE_LITERAL:\n     case QUOTE:\n-    case 15:\n     case 17:\n-    case 20:\n+    case 19:\n     case 22:\n-    case 23:\n     case 24:\n+    case 25:\n+    case 26:\n       Elements(array);\n       break;\n     default:\n       jj_la1[3] = jj_gen;\n       ;\n     }\n-    jj_consume_token(21);\n+    jj_consume_token(23);\n     array.reverse();\n     {if (true) return array;}\n     throw new Error(\"Missing return statement in function\");\n   JsonElement element;\n     element = JsonValue();\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 18:\n-      jj_consume_token(18);\n+    case 20:\n+      jj_consume_token(20);\n       Elements(array);\n       break;\n     default:\n   final private JsonElement JsonValue() throws ParseException {\n   JsonElement o = null;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n     case QUOTE:\n       o = JsonString();\n       break;\n     case DIGITS:\n+    case 26:\n+      o = JsonNumber();\n+      break;\n+    case 17:\n+      o = JsonObject();\n+      break;\n+    case 22:\n+      o = JsonArray();\n+      break;\n     case 24:\n-      o = JsonNumber();\n-      break;\n-    case 15:\n-      o = JsonObject();\n-      break;\n-    case 20:\n-      o = JsonArray();\n-      break;\n-    case 22:\n-      jj_consume_token(22);\n+      jj_consume_token(24);\n              o = new JsonPrimitive(true);\n       break;\n-    case 23:\n-      jj_consume_token(23);\n+    case 25:\n+      jj_consume_token(25);\n               o = new JsonPrimitive(false);\n       break;\n-    case 17:\n-      jj_consume_token(17);\n+    case 19:\n+      jj_consume_token(19);\n       break;\n     default:\n       jj_la1[5] = jj_gen;\n   final private JsonPrimitive JsonPrimitive() throws ParseException {\n   JsonPrimitive value;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n     case QUOTE:\n       value = JsonString();\n                           {if (true) return value;}\n       break;\n     case DIGITS:\n-    case 24:\n+    case 26:\n       value = JsonNumber();\n                           {if (true) return value;}\n       break;\n-    case 22:\n-      jj_consume_token(22);\n+    case 24:\n+      jj_consume_token(24);\n              {if (true) return new JsonPrimitive(true);}\n       break;\n-    case 23:\n-      jj_consume_token(23);\n+    case 25:\n+      jj_consume_token(25);\n               {if (true) return new JsonPrimitive(false);}\n       break;\n     default:\n          exppart = null;\n     intpart = JsonInt();\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 25:\n+    case 27:\n       fracpart = JsonFrac();\n       break;\n     default:\n   String digits;\n   boolean negative = false;\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case 24:\n-      jj_consume_token(24);\n+    case 26:\n+      jj_consume_token(26);\n          negative = true;\n       break;\n     default:\n \n   final private String JsonFrac() throws ParseException {\n   String digits;\n-    jj_consume_token(25);\n+    jj_consume_token(27);\n     digits = Digits();\n     {if (true) return \".\" + digits;}\n     throw new Error(\"Missing return statement in function\");\n   }\n \n   final private JsonPrimitive JsonString() throws ParseException {\n-  StringBuffer strbuf = new StringBuffer();\n-    jj_consume_token(QUOTE);\n+  StringBuffer strbuf = new StringBuffer(); Token t;\n+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+    case SINGLE_QUOTE_LITERAL:\n+      t = jj_consume_token(SINGLE_QUOTE_LITERAL);\n+    String value = t.image;\n+    String valueWithInQuotes = value.substring(1, value.length()-1);\n+    {if (true) return new JsonPrimitive(valueWithInQuotes);}\n+      break;\n+    case QUOTE:\n+      jj_consume_token(QUOTE);\n+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n+      case CHAR:\n+      case CNTRL_ESC:\n+      case HEX_ESC:\n+        Chars(strbuf);\n+        break;\n+      default:\n+        jj_la1[10] = jj_gen;\n+        ;\n+      }\n+      jj_consume_token(ENDQUOTE);\n+    {if (true) return new JsonPrimitive(strbuf.toString());}\n+      break;\n+    default:\n+      jj_la1[11] = jj_gen;\n+      jj_consume_token(-1);\n+      throw new ParseException();\n+    }\n+    throw new Error(\"Missing return statement in function\");\n+  }\n+\n+  final private void Chars(StringBuffer strbuf) throws ParseException {\n+  char c;\n+    c = Char();\n     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n     case CHAR:\n     case CNTRL_ESC:\n       Chars(strbuf);\n       break;\n     default:\n-      jj_la1[10] = jj_gen;\n-      ;\n-    }\n-    jj_consume_token(ENDQUOTE);\n-    {if (true) return new JsonPrimitive(strbuf.toString());}\n-    throw new Error(\"Missing return statement in function\");\n-  }\n-\n-  final private void Chars(StringBuffer strbuf) throws ParseException {\n-  char c;\n-    c = Char();\n-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n-    case CHAR:\n-    case CNTRL_ESC:\n-    case HEX_ESC:\n-      Chars(strbuf);\n-      break;\n-    default:\n-      jj_la1[11] = jj_gen;\n+      jj_la1[12] = jj_gen;\n       ;\n     }\n     strbuf.insert(0, c);\n       t = jj_consume_token(HEX_ESC);\n       break;\n     default:\n-      jj_la1[12] = jj_gen;\n+      jj_la1[13] = jj_gen;\n       jj_consume_token(-1);\n       throw new ParseException();\n     }\n   public Token token, jj_nt;\n   private int jj_ntk;\n   private int jj_gen;\n-  final private int[] jj_la1 = new int[13];\n+  final private int[] jj_la1 = new int[14];\n   static private int[] jj_la1_0;\n   static {\n       jj_la1_0();\n    }\n    private static void jj_la1_0() {\n-      jj_la1_0 = new int[] {0x1d280c0,0x80,0x40000,0x1d280c0,0x40000,0x1d280c0,0x1c000c0,0x2000000,0x20,0x1000000,0x4c00,0x4c00,0x4c00,};\n+      jj_la1_0 = new int[] {0x74a0340,0x300,0x100000,0x74a0340,0x100000,0x74a0340,0x7000340,0x8000000,0x20,0x4000000,0x13000,0x300,0x13000,0x13000,};\n    }\n \n   public JsonParser(java.io.InputStream stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 14; i++) jj_la1[i] = -1;\n   }\n \n   public void ReInit(java.io.InputStream stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 14; i++) jj_la1[i] = -1;\n   }\n \n   public JsonParser(java.io.Reader stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 14; i++) jj_la1[i] = -1;\n   }\n \n   public void ReInit(java.io.Reader stream) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 14; i++) jj_la1[i] = -1;\n   }\n \n   public JsonParser(JsonParserTokenManager tm) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 14; i++) jj_la1[i] = -1;\n   }\n \n   public void ReInit(JsonParserTokenManager tm) {\n     token = new Token();\n     jj_ntk = -1;\n     jj_gen = 0;\n-    for (int i = 0; i < 13; i++) jj_la1[i] = -1;\n+    for (int i = 0; i < 14; i++) jj_la1[i] = -1;\n   }\n \n   final private Token jj_consume_token(int kind) throws ParseException {\n \n   public ParseException generateParseException() {\n     jj_expentries.removeAllElements();\n-    boolean[] la1tokens = new boolean[26];\n-    for (int i = 0; i < 26; i++) {\n+    boolean[] la1tokens = new boolean[28];\n+    for (int i = 0; i < 28; i++) {\n       la1tokens[i] = false;\n     }\n     if (jj_kind >= 0) {\n       la1tokens[jj_kind] = true;\n       jj_kind = -1;\n     }\n-    for (int i = 0; i < 13; i++) {\n+    for (int i = 0; i < 14; i++) {\n       if (jj_la1[i] == jj_gen) {\n         for (int j = 0; j < 32; j++) {\n           if ((jj_la1_0[i] & (1<<j)) != 0) {\n         }\n       }\n     }\n-    for (int i = 0; i < 26; i++) {\n+    for (int i = 0; i < 28; i++) {\n       if (la1tokens[i]) {\n         jj_expentry = new int[1];\n         jj_expentry[0] = i;\n--- a/gson/src/main/java/com/google/gson/JsonParserConstants.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserConstants.java\n   int EOF = 0;\n   int E = 5;\n   int DIGITS = 6;\n-  int QUOTE = 7;\n-  int ENDQUOTE = 9;\n-  int CHAR = 10;\n-  int CNTRL_ESC = 11;\n-  int HEX = 13;\n-  int HEX_ESC = 14;\n+  int ESCAPE_CHAR = 7;\n+  int SINGLE_QUOTE_LITERAL = 8;\n+  int QUOTE = 9;\n+  int ENDQUOTE = 11;\n+  int CHAR = 12;\n+  int CNTRL_ESC = 13;\n+  int HEX = 15;\n+  int HEX_ESC = 16;\n \n   int DEFAULT = 0;\n   int STRING_STATE = 1;\n     \"\\\"\\\\r\\\"\",\n     \"<E>\",\n     \"<DIGITS>\",\n+    \"<ESCAPE_CHAR>\",\n+    \"<SINGLE_QUOTE_LITERAL>\",\n     \"\\\"\\\\\\\"\\\"\",\n     \"\\\"\\\\\\\\\\\"\",\n     \"<ENDQUOTE>\",\n--- a/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n+++ b/gson/src/main/java/com/google/gson/JsonParserTokenManager.java\n                      jjstateSet[jjnewStateCnt++] = 3;\n                   break;\n                case 3:\n-                  if ((0x3ff000000000000L & l) != 0L && kind > 14)\n-                     kind = 14;\n+                  if ((0x3ff000000000000L & l) != 0L && kind > 16)\n+                     kind = 16;\n                   break;\n                default : break;\n             }\n                      jjstateSet[jjnewStateCnt++] = 3;\n                   break;\n                case 3:\n-                  if ((0x7e0000007eL & l) != 0L && kind > 14)\n-                     kind = 14;\n+                  if ((0x7e0000007eL & l) != 0L && kind > 16)\n+                     kind = 16;\n                   break;\n                default : break;\n             }\n    switch(curChar)\n    {\n       case 34:\n-         return jjStopAtPos(0, 7);\n+         return jjStopAtPos(0, 9);\n       case 44:\n+         return jjStopAtPos(0, 20);\n+      case 45:\n+         return jjStopAtPos(0, 26);\n+      case 46:\n+         return jjStopAtPos(0, 27);\n+      case 58:\n+         return jjStopAtPos(0, 21);\n+      case 91:\n+         return jjStopAtPos(0, 22);\n+      case 93:\n+         return jjStopAtPos(0, 23);\n+      case 102:\n+         return jjMoveStringLiteralDfa1_0(0x2000000L);\n+      case 110:\n+         return jjMoveStringLiteralDfa1_0(0x80000L);\n+      case 116:\n+         return jjMoveStringLiteralDfa1_0(0x1000000L);\n+      case 123:\n+         return jjStopAtPos(0, 17);\n+      case 125:\n          return jjStopAtPos(0, 18);\n-      case 45:\n-         return jjStopAtPos(0, 24);\n-      case 46:\n-         return jjStopAtPos(0, 25);\n-      case 58:\n-         return jjStopAtPos(0, 19);\n-      case 91:\n-         return jjStopAtPos(0, 20);\n-      case 93:\n-         return jjStopAtPos(0, 21);\n-      case 102:\n-         return jjMoveStringLiteralDfa1_0(0x800000L);\n-      case 110:\n-         return jjMoveStringLiteralDfa1_0(0x20000L);\n-      case 116:\n-         return jjMoveStringLiteralDfa1_0(0x400000L);\n-      case 123:\n-         return jjStopAtPos(0, 15);\n-      case 125:\n-         return jjStopAtPos(0, 16);\n       default :\n          return jjMoveNfa_0(0, 0);\n    }\n    switch(curChar)\n    {\n       case 97:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x800000L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x2000000L);\n       case 114:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x400000L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x1000000L);\n       case 117:\n-         return jjMoveStringLiteralDfa2_0(active0, 0x20000L);\n+         return jjMoveStringLiteralDfa2_0(active0, 0x80000L);\n       default :\n          break;\n    }\n private final int jjMoveStringLiteralDfa2_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(0, old0);\n+      return jjStartNfa_0(0, old0); \n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(1, active0);\n    switch(curChar)\n    {\n       case 108:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x820000L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x2080000L);\n       case 117:\n-         return jjMoveStringLiteralDfa3_0(active0, 0x400000L);\n+         return jjMoveStringLiteralDfa3_0(active0, 0x1000000L);\n       default :\n          break;\n    }\n private final int jjMoveStringLiteralDfa3_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(1, old0);\n+      return jjStartNfa_0(1, old0); \n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(2, active0);\n    switch(curChar)\n    {\n       case 101:\n-         if ((active0 & 0x400000L) != 0L)\n-            return jjStopAtPos(3, 22);\n+         if ((active0 & 0x1000000L) != 0L)\n+            return jjStopAtPos(3, 24);\n          break;\n       case 108:\n-         if ((active0 & 0x20000L) != 0L)\n-            return jjStopAtPos(3, 17);\n+         if ((active0 & 0x80000L) != 0L)\n+            return jjStopAtPos(3, 19);\n          break;\n       case 115:\n-         return jjMoveStringLiteralDfa4_0(active0, 0x800000L);\n+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000L);\n       default :\n          break;\n    }\n private final int jjMoveStringLiteralDfa4_0(long old0, long active0)\n {\n    if (((active0 &= old0)) == 0L)\n-      return jjStartNfa_0(2, old0);\n+      return jjStartNfa_0(2, old0); \n    try { curChar = input_stream.readChar(); }\n    catch(java.io.IOException e) {\n       jjStopStringLiteralDfa_0(3, active0);\n    switch(curChar)\n    {\n       case 101:\n-         if ((active0 & 0x800000L) != 0L)\n-            return jjStopAtPos(4, 23);\n+         if ((active0 & 0x2000000L) != 0L)\n+            return jjStopAtPos(4, 25);\n          break;\n       default :\n          break;\n    }\n    return jjStartNfa_0(3, active0);\n }\n+static final long[] jjbitVec0 = {\n+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n+static final long[] jjbitVec2 = {\n+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n+};\n private final int jjMoveNfa_0(int startState, int curPos)\n {\n    int[] nextStates;\n    int startsAt = 0;\n-   jjnewStateCnt = 3;\n+   jjnewStateCnt = 8;\n    int i = 1;\n    jjstateSet[0] = startState;\n    int j, kind = 0x7fffffff;\n             switch(jjstateSet[--i])\n             {\n                case 0:\n+                  if ((0x3ff000000000000L & l) != 0L)\n+                  {\n+                     if (kind > 6)\n+                        kind = 6;\n+                     jjCheckNAdd(2);\n+                  }\n+                  else if (curChar == 39)\n+                     jjCheckNAddStates(0, 2);\n+                  break;\n+               case 1:\n+                  if ((0x280000000000L & l) != 0L && kind > 5)\n+                     kind = 5;\n+                  break;\n                case 2:\n                   if ((0x3ff000000000000L & l) == 0L)\n                      break;\n-                  kind = 6;\n+                  if (kind > 6)\n+                     kind = 6;\n                   jjCheckNAdd(2);\n                   break;\n-               case 1:\n-                  if ((0x280000000000L & l) != 0L)\n-                     kind = 5;\n+               case 3:\n+                  if (curChar == 39)\n+                     jjCheckNAddStates(0, 2);\n+                  break;\n+               case 4:\n+                  if ((0xffffff7fffffdbffL & l) != 0L)\n+                     jjCheckNAddStates(0, 2);\n+                  break;\n+               case 6:\n+                  if ((0x8400000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 2);\n+                  break;\n+               case 7:\n+                  if (curChar == 39 && kind > 8)\n+                     kind = 8;\n                   break;\n                default : break;\n             }\n                case 0:\n                   if ((0x2000000020L & l) == 0L)\n                      break;\n-                  kind = 5;\n+                  if (kind > 5)\n+                     kind = 5;\n                   jjstateSet[jjnewStateCnt++] = 1;\n+                  break;\n+               case 4:\n+                  if ((0xffffffffefffffffL & l) != 0L)\n+                     jjCheckNAddStates(0, 2);\n+                  break;\n+               case 5:\n+                  if (curChar == 92)\n+                     jjstateSet[jjnewStateCnt++] = 6;\n+                  break;\n+               case 6:\n+                  if ((0x14404410000000L & l) != 0L)\n+                     jjCheckNAddStates(0, 2);\n                   break;\n                default : break;\n             }\n          {\n             switch(jjstateSet[--i])\n             {\n+               case 4:\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2))\n+                     jjAddStates(0, 2);\n+                  break;\n                default : break;\n             }\n          } while(i != startsAt);\n          kind = 0x7fffffff;\n       }\n       ++curPos;\n-      if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt)))\n+      if ((i = jjnewStateCnt) == (startsAt = 8 - (jjnewStateCnt = startsAt)))\n          return curPos;\n       try { curChar = input_stream.readChar(); }\n       catch(java.io.IOException e) { return curPos; }\n    switch(curChar)\n    {\n       case 117:\n-         return jjStopAtPos(0, 12);\n+         return jjStopAtPos(0, 14);\n       default :\n          return jjMoveNfa_2(0, 0);\n    }\n             {\n                case 0:\n                   if ((0x800400000000L & l) != 0L)\n-                     kind = 11;\n+                     kind = 13;\n                   break;\n                default : break;\n             }\n             {\n                case 0:\n                   if ((0x14404410000000L & l) != 0L)\n-                     kind = 11;\n+                     kind = 13;\n                   break;\n                default : break;\n             }\n    switch(curChar)\n    {\n       case 92:\n-         return jjStopAtPos(0, 8);\n+         return jjStopAtPos(0, 10);\n       default :\n          return jjMoveNfa_1(0, 0);\n    }\n }\n-static final long[] jjbitVec0 = {\n-   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL\n-};\n-static final long[] jjbitVec2 = {\n-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL\n-};\n private final int jjMoveNfa_1(int startState, int curPos)\n {\n    int[] nextStates;\n                case 0:\n                   if ((0xfffffffbffffffffL & l) != 0L)\n                   {\n-                     if (kind > 10)\n-                        kind = 10;\n+                     if (kind > 12)\n+                        kind = 12;\n                   }\n                   else if (curChar == 34)\n                   {\n-                     if (kind > 9)\n-                        kind = 9;\n+                     if (kind > 11)\n+                        kind = 11;\n                   }\n                   break;\n                case 1:\n                   if ((0xfffffffbffffffffL & l) != 0L)\n-                     kind = 10;\n+                     kind = 12;\n                   break;\n                default : break;\n             }\n             {\n                case 0:\n                   if ((0xffffffffefffffffL & l) != 0L)\n-                     kind = 10;\n+                     kind = 12;\n                   break;\n                default : break;\n             }\n             switch(jjstateSet[--i])\n             {\n                case 0:\n-                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 10)\n-                     kind = 10;\n+                  if (jjCanMove_0(hiByte, i1, i2, l1, l2) && kind > 12)\n+                     kind = 12;\n                   break;\n                default : break;\n             }\n    }\n }\n static final int[] jjnextStates = {\n+   4, 5, 7, \n };\n private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)\n {\n    {\n       case 0:\n          return ((jjbitVec2[i2] & l2) != 0L);\n-      default :\n+      default : \n          if ((jjbitVec0[i1] & l1) != 0L)\n             return true;\n          return false;\n    }\n }\n public static final String[] jjstrLiteralImages = {\n-\"\", null, null, null, null, null, null, \"\\42\", null, null, null, null, null,\n-null, null, \"\\173\", \"\\175\", \"\\156\\165\\154\\154\", \"\\54\", \"\\72\", \"\\133\", \"\\135\",\n-\"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\55\", \"\\56\", };\n+\"\", null, null, null, null, null, null, null, null, \"\\42\", null, null, null, \n+null, null, null, null, \"\\173\", \"\\175\", \"\\156\\165\\154\\154\", \"\\54\", \"\\72\", \"\\133\", \n+\"\\135\", \"\\164\\162\\165\\145\", \"\\146\\141\\154\\163\\145\", \"\\55\", \"\\56\", };\n public static final String[] lexStateNames = {\n-   \"DEFAULT\",\n-   \"STRING_STATE\",\n-   \"ESC_STATE\",\n-   \"HEX_STATE\",\n+   \"DEFAULT\", \n+   \"STRING_STATE\", \n+   \"ESC_STATE\", \n+   \"HEX_STATE\", \n };\n public static final int[] jjnewLexState = {\n-   -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n-   -1,\n+   -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 0, -1, 1, 3, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, \n+   -1, -1, -1, \n };\n static final long[] jjtoToken = {\n-   0x3ffcee1L,\n+   0xfff3b61L, \n };\n static final long[] jjtoSkip = {\n-   0x1eL,\n+   0x1eL, \n };\n static final long[] jjtoMore = {\n-   0x1100L,\n+   0x4400L, \n };\n protected SimpleCharStream input_stream;\n-private final int[] jjrounds = new int[4];\n-private final int[] jjstateSet = new int[8];\n+private final int[] jjrounds = new int[8];\n+private final int[] jjstateSet = new int[16];\n protected char curChar;\n public JsonParserTokenManager(SimpleCharStream stream){\n    if (SimpleCharStream.staticFlag)\n {\n    int i;\n    jjround = 0x80000001;\n-   for (i = 4; i-- > 0;)\n+   for (i = 8; i-- > 0;)\n       jjrounds[i] = 0x80000000;\n }\n public void ReInit(SimpleCharStream stream, int lexState)\n int jjmatchedPos;\n int jjmatchedKind;\n \n-public Token getNextToken()\n+public Token getNextToken() \n {\n   int kind;\n   Token specialToken = null;\n \n   EOFLoop :\n   for (;;)\n-  {\n-   try\n-   {\n+  {   \n+   try   \n+   {     \n       curChar = input_stream.BeginToken();\n-   }\n+   }     \n    catch(java.io.IOException e)\n-   {\n+   {        \n       jjmatchedKind = 0;\n       matchedToken = jjFillToken();\n       return matchedToken;\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n     gson = new Gson();\n   }\n \n-  public void testJsonInSingleQuotes() {\n-    String json = \"{'stringValue':'no message'}\";\n+  public void testJsonInSingleQuotesDeserialization() {\n+    String json = \"{'stringValue':'no message','intValue':10,'longValue':20}\";\n     BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n     assertEquals(\"no message\", target.stringValue);\n+    assertEquals(10, target.intValue);\n+    assertEquals(20, target.longValue);\n+  }\n+  \n+  public void testJsonInMixedQuotesDeserialization() {\n+    String json = \"{\\\"stringValue\\\":'no message','intValue':10,'longValue':20}\";\n+    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);\n+    assertEquals(\"no message\", target.stringValue);\n+    assertEquals(10, target.intValue);\n+    assertEquals(20, target.longValue);\n   }\n   \n   public void testBagOfPrimitivesSerialization() throws Exception {", "timestamp": 1223607234, "metainfo": ""}