{"sha": "085856c12843a6b58d6de59672d37da47afdaa72", "log": "Don't leave the JsonReader in an invalid state if nextInt(), nextDouble() or nextLong() fails. We now save a reference to the string before we parse it, and keep that referenced value if parsing fails.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   private static final int PEEKED_SINGLE_QUOTED = 8;\n   private static final int PEEKED_DOUBLE_QUOTED = 9;\n   private static final int PEEKED_UNQUOTED = 10;\n-  private static final int PEEKED_SINGLE_QUOTED_NAME = 11;\n-  private static final int PEEKED_DOUBLE_QUOTED_NAME = 12;\n-  private static final int PEEKED_UNQUOTED_NAME = 13;\n+  private static final int PEEKED_BUFFERED = 11;\n+  private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n+  private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n+  private static final int PEEKED_UNQUOTED_NAME = 14;\n   /** When this is returned, the integer value is stored in peekedInteger. */\n-  private static final int PEEKED_INTEGER = 14;\n-  private static final int PEEKED_NUMBER = 15;\n-  private static final int PEEKED_EOF = 16;\n+  private static final int PEEKED_INTEGER = 15;\n+  private static final int PEEKED_NUMBER = 16;\n+  private static final int PEEKED_EOF = 17;\n \n   /** The input JSON. */\n   private final Reader in;\n    * The number of characters in the peeked number.\n    */\n   private int peekedNumberLength;\n+\n+  private String peekedString;\n \n   /*\n    * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n     case PEEKED_SINGLE_QUOTED:\n     case PEEKED_DOUBLE_QUOTED:\n     case PEEKED_UNQUOTED:\n+    case PEEKED_BUFFERED:\n       return JsonToken.STRING;\n     case PEEKED_INTEGER:\n     case PEEKED_NUMBER:\n     }\n \n     if (stackSize == 1) {\n-      checkLenient();\n+      checkLenient(); // Top-level value isn't an array or an object.\n     }\n \n     int result = peekKeyword();\n       result = nextQuotedValue('\\'');\n     } else if (p == PEEKED_DOUBLE_QUOTED) {\n       result = nextQuotedValue('\"');\n+    } else if (p == PEEKED_BUFFERED) {\n+      result = peekedString;\n+      peekedString = null;\n     } else if (p == PEEKED_INTEGER) {\n       result = Long.toString(peekedInteger);\n     } else if (p == PEEKED_NUMBER) {\n       return (double) peekedInteger;\n     }\n \n-    String asString;\n     if (p == PEEKED_NUMBER) {\n-      asString = new String(buffer, pos, peekedNumberLength);\n+      peekedString = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n-      asString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n+      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n     } else if (p == PEEKED_UNQUOTED) {\n-      asString = nextUnquotedValue();\n-    } else {\n+      peekedString = nextUnquotedValue();\n+    } else if (p != PEEKED_BUFFERED) {\n       throw new IllegalStateException(\"Expected a double but was \" + peek()\n           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n     }\n \n-    double result = Double.parseDouble(asString); // don't catch this NumberFormatException.\n+    peeked = PEEKED_BUFFERED;\n+    double result = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n       throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n     }\n+    peekedString = null;\n     peeked = PEEKED_NONE;\n     return result;\n   }\n       return peekedInteger;\n     }\n \n-    String asString;\n     if (p == PEEKED_NUMBER) {\n-      asString = new String(buffer, pos, peekedNumberLength);\n+      peekedString = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n-      asString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n+      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n       try {\n-        long result = Long.parseLong(asString);\n+        long result = Long.parseLong(peekedString);\n         peeked = PEEKED_NONE;\n         return result;\n       } catch (NumberFormatException ignored) {\n           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n     }\n \n-    double asDouble = Double.parseDouble(asString); // don't catch this NumberFormatException.\n+    peeked = PEEKED_BUFFERED;\n+    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     long result = (long) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n-      throw new NumberFormatException(\"Expected a long but was \" + asString\n+      throw new NumberFormatException(\"Expected a long but was \" + peekedString\n           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n     }\n+    peekedString = null;\n     peeked = PEEKED_NONE;\n     return result;\n   }\n       return result;\n     }\n \n-    String asString;\n     if (p == PEEKED_NUMBER) {\n-      asString = new String(buffer, pos, peekedNumberLength);\n+      peekedString = new String(buffer, pos, peekedNumberLength);\n       pos += peekedNumberLength;\n     } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n-      asString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n+      peekedString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n       try {\n-        result = Integer.parseInt(asString);\n+        result = Integer.parseInt(peekedString);\n         peeked = PEEKED_NONE;\n         return result;\n       } catch (NumberFormatException ignored) {\n           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n     }\n \n-    double asDouble = Double.parseDouble(asString); // don't catch this NumberFormatException.\n+    peeked = PEEKED_BUFFERED;\n+    double asDouble = Double.parseDouble(peekedString); // don't catch this NumberFormatException.\n     result = (int) asDouble;\n     if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n-      throw new NumberFormatException(\"Expected an int but was \" + asString\n+      throw new NumberFormatException(\"Expected an int but was \" + peekedString\n           + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n     }\n+    peekedString = null;\n     peeked = PEEKED_NONE;\n     return result;\n   }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n     assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n+  public void testNumberWithOctalPrefix() throws IOException {\n+    String json = \"[01]\";\n+    JsonReader reader = new JsonReader(new StringReader(json));\n+    reader.beginArray();\n+    try {\n+      reader.peek();\n+      fail();\n+    } catch (MalformedJsonException expected) {\n+    }\n+    try {\n+      reader.nextInt();\n+      fail();\n+    } catch (MalformedJsonException expected) {\n+    }\n+    try {\n+      reader.nextLong();\n+      fail();\n+    } catch (MalformedJsonException expected) {\n+    }\n+    try {\n+      reader.nextDouble();\n+      fail();\n+    } catch (MalformedJsonException expected) {\n+    }\n+    assertEquals(\"01\", reader.nextString());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testBooleans() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[true,false]\"));\n+    reader.beginArray();\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(false, reader.nextBoolean());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testPeekingUnquotedStringsPrefixedWithBooleans() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[truey]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(STRING, reader.peek());\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    assertEquals(\"truey\", reader.nextString());\n+    reader.endArray();\n+  }\n+\n+  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[12.34e5x]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(STRING, reader.peek());\n+    try {\n+      reader.nextInt();\n+      fail();\n+    } catch (IllegalStateException expected) {\n+    }\n+    assertEquals(\"12.34e5x\", reader.nextString());\n+  }\n+\n+  public void testPeekLongMinValue() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[-9223372036854775808]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(NUMBER, reader.peek());\n+    assertEquals(-9223372036854775808L, reader.nextLong());\n+  }\n+\n+  /**\n+   * This test fails because there's no double for -9223372036854775809, and our\n+   * long parsing uses Double.parseDouble() for fractional values.\n+   */\n+  public void disabled_testPeekLargerThanLongMinValue() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[-9223372036854775809]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(NUMBER, reader.peek());\n+    try {\n+      reader.nextLong();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    assertEquals(-9223372036854775809d, reader.nextDouble());\n+  }\n+\n   /**\n    * This test fails because there's no double for 9223372036854775806, and\n    * our long parsing uses Double.parseDouble() for fractional values.\n     reader.endArray();\n   }\n \n-  public void testNumberWithOctalPrefix() throws IOException {\n-    String json = \"[01]\";\n-    JsonReader reader = new JsonReader(new StringReader(json));\n-    reader.beginArray();\n-    try {\n-      reader.peek();\n-      fail();\n-    } catch (MalformedJsonException expected) {\n-    }\n-    try {\n-      reader.nextInt();\n-      fail();\n-    } catch (MalformedJsonException expected) {\n-    }\n-    try {\n-      reader.nextLong();\n-      fail();\n-    } catch (MalformedJsonException expected) {\n-    }\n-    try {\n-      reader.nextDouble();\n-      fail();\n-    } catch (MalformedJsonException expected) {\n-    }\n-    assertEquals(\"01\", reader.nextString());\n-    reader.endArray();\n-    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n-  }\n-\n-  public void testBooleans() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[true,false]\"));\n-    reader.beginArray();\n-    assertEquals(true, reader.nextBoolean());\n-    assertEquals(false, reader.nextBoolean());\n-    reader.endArray();\n-    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n-  }\n-\n-  public void testPeekingUnquotedStringsPrefixedWithBooleans() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[truey]\"));\n-    reader.setLenient(true);\n-    reader.beginArray();\n-    assertEquals(STRING, reader.peek());\n-    try {\n-      reader.nextBoolean();\n-      fail();\n-    } catch (IllegalStateException expected) {\n-    }\n-    assertEquals(\"truey\", reader.nextString());\n-    reader.endArray();\n-  }\n-\n-  public void testPeekingUnquotedStringsPrefixedWithIntegers() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[12.34e5x]\"));\n-    reader.setLenient(true);\n-    reader.beginArray();\n-    assertEquals(STRING, reader.peek());\n-    try {\n-      reader.nextInt();\n-      fail();\n-    } catch (IllegalStateException expected) {\n-    }\n-    assertEquals(\"12.34e5x\", reader.nextString());\n-  }\n-\n-  public void testPeekLongMinValue() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[-9223372036854775808]\"));\n-    reader.setLenient(true);\n-    reader.beginArray();\n-    assertEquals(NUMBER, reader.peek());\n-    assertEquals(-9223372036854775808L, reader.nextLong());\n-  }\n-\n-  /**\n-   * This test fails because there's no double for -9223372036854775809, and our\n-   * long parsing uses Double.parseDouble() for fractional values.\n-   */\n-  public void testPeekLargerThanLongMinValue() throws IOException {\n-    JsonReader reader = new JsonReader(new StringReader(\"[-9223372036854775809]\"));\n-    reader.setLenient(true);\n-    reader.beginArray();\n-    assertEquals(NUMBER, reader.peek());\n-    try {\n-      reader.nextLong();\n-      fail();\n-    } catch (NumberFormatException expected) {\n-    }\n-    assertEquals(-9223372036854775809d, reader.nextDouble());\n-  }\n-\n   public void testPeekMuchLargerThanLongMinValue() throws IOException {\n     JsonReader reader = new JsonReader(new StringReader(\"[-92233720368547758080]\"));\n     reader.setLenient(true);\n   public void testStrictTopLevelString() {\n     JsonReader reader = new JsonReader(new StringReader(\"\\\"a\\\"\"));\n     try {\n-      reader.nextBoolean();\n+      reader.nextString();\n       fail();\n     } catch (IOException expected) {\n     }", "timestamp": 1346018817, "metainfo": ""}