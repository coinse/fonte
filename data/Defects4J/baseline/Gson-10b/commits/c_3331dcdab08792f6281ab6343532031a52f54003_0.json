{"sha": "3331dcdab08792f6281ab6343532031a52f54003", "log": "Using serializationExclusionStrategy while navigating through fields to decide which ones to skip.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.ReflectiveTypeAdapter;\n import com.google.gson.internal.bind.TypeAdapter;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.StringReader;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n         serializeNulls\n         serializers\n      */\n+    TypeAdapter.Factory factory = new ReflectiveTypeAdapter.FactoryImpl() {\n+      @Override\n+      public boolean skipField(Class<?> declaringClazz, Field f, Type declaredType) {\n+        // TODO: support deserialization policy as well\n+        return Gson.this.serializationExclusionStrategy.shouldSkipField(\n+            new FieldAttributes(declaringClazz, f, declaredType));\n+      }\n+    };\n+    \n     this.miniGson = new MiniGson.Builder()\n+        .factory(factory)\n         .build();\n   }\n \n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n /**\n  * Adapts the fields of an object to the properties of a JSON object.\n  */\n-final class ReflectiveTypeAdapter<T> extends TypeAdapter<T>  {\n-  public static final Factory FACTORY = new Factory() {\n-    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n-      Class<? super T> raw = type.getRawType();\n-\n-      if (!Object.class.isAssignableFrom(raw)) {\n-        return null; // it's a primitive!\n-      }\n-\n-      // TODO: use Joel's constructor calling code (with setAccessible)\n-      Constructor<? super T> constructor;\n-      try {\n-        constructor = raw.getDeclaredConstructor();\n-      } catch (NoSuchMethodException e) {\n-        return null;\n-      }\n-\n-      return new ReflectiveTypeAdapter<T>(constructor, getBoundFields(context, type, raw));\n-    }\n-\n-    private Map<String, BoundField> getBoundFields(\n-        MiniGson context, TypeToken<?> type, Class<?> raw) {\n-      Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n-      while (raw != Object.class) {\n-        for (Field field : raw.getDeclaredFields()) {\n-          field.setAccessible(true); // TODO: don't call setAccessible unless necessary\n-          Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n-          BoundField boundField = createBoundField(context, field, TypeToken.get(fieldType));\n-          result.put(boundField.name, boundField);\n-        }\n-        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n-        raw = type.getRawType();\n-      }\n-      return result;\n-    }\n-  };\n+public final class ReflectiveTypeAdapter<T> extends TypeAdapter<T>  {\n+  public static final Factory FACTORY = new FactoryImpl();\n \n   private final Constructor<? super T> constructor;\n   private final Map<String, BoundField> map;\n     };\n   }\n \n+  public static class FactoryImpl implements Factory {\n+    public boolean skipField(Class<?> declaringClazz, Field f, Type declaringType) {\n+      return false;\n+    }\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+      Class<? super T> raw = type.getRawType();\n+\n+      if (!Object.class.isAssignableFrom(raw)) {\n+        return null; // it's a primitive!\n+      }\n+\n+      // TODO: use Joel's constructor calling code (with setAccessible)\n+      Constructor<? super T> constructor;\n+      try {\n+        constructor = raw.getDeclaredConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      return new ReflectiveTypeAdapter<T>(constructor, getBoundFields(context, type, raw));\n+    }\n+\n+    private Map<String, BoundField> getBoundFields(\n+        MiniGson context, TypeToken<?> type, Class<?> raw) {\n+      Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n+      Type declaredType = type.getType();\n+      while (raw != Object.class) {\n+        for (Field field : raw.getDeclaredFields()) {\n+          if (skipField(raw, field, declaredType)) {\n+            continue;\n+          }\n+          field.setAccessible(true); // TODO: don't call setAccessible unless necessary\n+          Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+          BoundField boundField = createBoundField(context, field, TypeToken.get(fieldType));\n+          result.put(boundField.name, boundField);\n+        }\n+        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n+        raw = type.getRawType();\n+      }\n+      return result;\n+    }\n+  }\n+\n   static abstract class BoundField {\n     final String name;\n ", "timestamp": 1312332456, "metainfo": ""}