{"sha": "10db917e9380ca4d741e06152fd1ee506666c1c3", "log": "Updated fromJson and toJson signatures to indicate the kind of exceptions (JsonIOException, JsonSyntaxException) that can be thrown.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n    *\n    * @param src the object for which Json representation is to be created setting for Gson\n    * @param writer Writer to which the Json representation needs to be written\n+   * @throws JsonIOException if there was a problem writing to the writer\n    * @since 1.2\n    */\n-  public void toJson(Object src, Appendable writer) {\n+  public void toJson(Object src, Appendable writer) throws JsonIOException {\n     try {\n       if (src != null) {\n         toJson(src, src.getClass(), writer);\n    * Type typeOfSrc = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n    * </pre>\n    * @param writer Writer to which the Json representation of src needs to be written.\n+   * @throws JsonIOException if there was a problem writing to the writer\n    * @since 1.2\n    */\n-  public void toJson(Object src, Type typeOfSrc, Appendable writer) {\n+  public void toJson(Object src, Type typeOfSrc, Appendable writer) throws JsonIOException {\n     JsonElement jsonElement = toJsonTree(src, typeOfSrc);\n     toJson(jsonElement, writer);\n   }\n   /**\n    * Writes the JSON representation of {@code src} of type {@code typeOfSrc} to\n    * {@code writer}.\n-   */\n-  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) {\n+   * @throws JsonIOException if there was a problem writing to the writer\n+   */\n+  public void toJson(Object src, Type typeOfSrc, JsonWriter writer) throws JsonIOException {\n     toJson(toJsonTree(src, typeOfSrc), writer);\n   }\n \n    *\n    * @param jsonElement root of a tree of {@link JsonElement}s\n    * @param writer Writer to which the Json representation needs to be written\n+   * @throws JsonIOException if there was a problem writing to the writer\n    * @since 1.4\n    */\n-  public void toJson(JsonElement jsonElement, Appendable writer) {\n+  public void toJson(JsonElement jsonElement, Appendable writer) throws JsonIOException {\n     try {\n       if (generateNonExecutableJson) {\n         writer.append(JSON_NON_EXECUTABLE_PREFIX);\n \n   /**\n    * Writes the JSON for {@code jsonElement} to {@code writer}.\n-   */\n-  public void toJson(JsonElement jsonElement, JsonWriter writer) {\n+   * @throws JsonIOException if there was a problem writing to the writer\n+   */\n+  public void toJson(JsonElement jsonElement, JsonWriter writer) throws JsonIOException {\n     boolean oldLenient = writer.isLenient();\n     writer.setLenient(true);\n     boolean oldHtmlSafe = writer.isHtmlSafe();\n    * @param json the string from which the object is to be deserialized\n    * @param classOfT the class of T\n    * @return an object of type T from the string\n-   * @throws JsonParseException if json is not a valid representation for an object of type\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n    * classOfT\n    */\n-  public <T> T fromJson(String json, Class<T> classOfT) throws JsonParseException {\n+  public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\n     Object object = fromJson(json, (Type) classOfT);\n     return Primitives.wrap(classOfT).cast(object);\n   }\n    * </pre>\n    * @return an object of type T from the string\n    * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n    */\n   @SuppressWarnings(\"unchecked\")\n-  public <T> T fromJson(String json, Type typeOfT) throws JsonParseException {\n+  public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\n     if (json == null) {\n       return null;\n     }\n    * @param json the reader producing the Json from which the object is to be deserialized.\n    * @param classOfT the class of T\n    * @return an object of type T from the string\n-   * @throws JsonParseException if json is not a valid representation for an object of type\n-   * classOfT\n+   * @throws JsonIOException if there was a problem reading from the Reader\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n    * @since 1.2\n    */\n-  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonParseException {\n+  public <T> T fromJson(Reader json, Class<T> classOfT) throws JsonSyntaxException, JsonIOException {\n     Object object = fromJson(new JsonReader(json), classOfT);\n     return Primitives.wrap(classOfT).cast(object);\n   }\n    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n    * </pre>\n    * @return an object of type T from the json\n-   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n+   * @throws JsonIOException if there was a problem reading from the Reader\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n    * @since 1.2\n    */\n-  public <T> T fromJson(Reader json, Type typeOfT) throws JsonParseException {\n+  public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     return this.<T>fromJson(new JsonReader(json), typeOfT);\n   }\n \n   /**\n    * Reads the next JSON value from {@code reader} and convert it to an object\n    * of type {@code typeOfT}.\n-   */\n-  @SuppressWarnings(\"unchecked\") // this method is unsafe and should be used very carefully\n-  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonParseException {\n+   * Since Type is not parameterized by T, this method is type unsafe and should be used carefully\n+   *\n+   * @throws JsonIOException if there was a problem writing to the Reader\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\n     boolean oldLenient = reader.isLenient();\n     reader.setLenient(true);\n     try {\n    * be deserialized\n    * @param classOfT The class of T\n    * @return an object of type T from the json\n-   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n    * @since 1.3\n    */\n-  public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonParseException {\n+  public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n     Object object = fromJson(json, (Type) classOfT);\n     return Primitives.wrap(classOfT).cast(object);\n   }\n    * Type typeOfT = new TypeToken&lt;Collection&lt;Foo&gt;&gt;(){}.getType();\n    * </pre>\n    * @return an object of type T from the json\n-   * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n+   * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n    * @since 1.3\n    */\n   @SuppressWarnings(\"unchecked\")\n-  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonParseException {\n+  public <T> T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException {\n     if (json == null) {\n       return null;\n     }", "timestamp": 1288813589, "metainfo": ""}