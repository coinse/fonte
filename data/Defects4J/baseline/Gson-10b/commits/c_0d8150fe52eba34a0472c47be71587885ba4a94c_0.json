{"sha": "0d8150fe52eba34a0472c47be71587885ba4a94c", "log": "Major restructuring of Primitve type serialization and deserializtion.  From the end-user's point of view there should be no difference other than the user can now override the default serialization/deserialization their own custom type adapter (not sure if there is a real use-case out there for this).  This restructuring greatly cleans up the code and reduces some complexity; however, there is more that can be done to clean this up (i.e. get rid of \"InstanceCreators\" for primitive Type Adapters).", "commit": "\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n   private static final BigDecimalTypeAdapter BIG_DECIMAL_TYPE_ADAPTER = new BigDecimalTypeAdapter();\n   private static final BigIntegerTypeAdapter BIG_INTEGER_TYPE_ADAPTER = new BigIntegerTypeAdapter();\n \n-  private static final BooleanCreator BOOLEAN_CREATOR = new BooleanCreator();\n-  private static final ByteCreator BYTE_CREATOR = new ByteCreator();\n-  private static final CharacterCreator CHARACTER_CREATOR = new CharacterCreator();\n-  private static final DoubleCreator DOUBLE_CREATOR = new DoubleCreator();\n-  private static final FloatCreator FLOAT_CREATOR = new FloatCreator();\n-  private static final IntegerCreator INTEGER_CREATOR = new IntegerCreator();\n-  private static final LongCreator LONG_CREATOR = new LongCreator();\n-  private static final ShortCreator SHORT_CREATOR = new ShortCreator();\n+  private static final BooleanTypeAdapter BOOLEAN_TYPE_ADAPTER = new BooleanTypeAdapter();\n+  private static final ByteTypeAdapter BYTE_TYPE_ADAPTER = new ByteTypeAdapter();\n+  private static final CharacterTypeAdapter CHARACTER_TYPE_ADAPTER = new CharacterTypeAdapter();\n+  private static final DoubleTypeAdapter DOUBLE_TYPE_ADAPTER = new DoubleTypeAdapter();\n+  private static final FloatTypeAdapter FLOAT_TYPE_ADAPTER = new FloatTypeAdapter();\n+  private static final IntegerTypeAdapter INTEGER_TYPE_ADAPTER = new IntegerTypeAdapter();\n+  private static final LongTypeAdapter LONG_TYPE_ADAPTER = new LongTypeAdapter();\n+  private static final ShortTypeAdapter SHORT_TYPE_ADAPTER = new ShortTypeAdapter();\n+  private static final StringTypeAdapter STRING_TYPE_ADAPTER = new StringTypeAdapter();\n+\n   private static final LinkedListCreator LINKED_LIST_CREATOR = new LinkedListCreator();\n   private static final TreeSetCreator TREE_SET_CREATOR = new TreeSetCreator();\n \n     map.register(Date.class, DATE_TYPE_ADAPTER);\n     map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n     map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n+    \n+    // Add primitive serializers\n+    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\n+    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\n+    map.register(Byte.class, BYTE_TYPE_ADAPTER);\n+    map.register(byte.class, BYTE_TYPE_ADAPTER);\n+    map.register(Character.class, CHARACTER_TYPE_ADAPTER);\n+    map.register(char.class, CHARACTER_TYPE_ADAPTER);\n+    map.register(Double.class, DOUBLE_TYPE_ADAPTER);\n+    map.register(double.class, DOUBLE_TYPE_ADAPTER);\n+    map.register(Float.class, FLOAT_TYPE_ADAPTER);\n+    map.register(float.class, FLOAT_TYPE_ADAPTER);\n+    map.register(Integer.class, INTEGER_TYPE_ADAPTER);\n+    map.register(int.class, INTEGER_TYPE_ADAPTER);\n+    map.register(Long.class, LONG_TYPE_ADAPTER);\n+    map.register(long.class, LONG_TYPE_ADAPTER);\n+    map.register(Short.class, SHORT_TYPE_ADAPTER);\n+    map.register(short.class, SHORT_TYPE_ADAPTER);\n+    map.register(String.class, STRING_TYPE_ADAPTER);\n+\n     map.makeUnmodifiable();\n     return map;\n   }\n     map.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\n     map.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\n     map.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER));\n+    \n+    // Add primitive deserializers\n+    map.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\n+    map.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\n+    map.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\n+    map.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\n+    map.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\n+    map.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\n+    map.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\n+    map.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\n+    map.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\n+    map.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\n+    map.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\n+    map.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\n+    map.register(Long.class, wrapDeserializer(LONG_TYPE_ADAPTER));\n+    map.register(long.class, wrapDeserializer(LONG_TYPE_ADAPTER));\n+    map.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\n+    map.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\n+    map.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER));\n+\n     map.makeUnmodifiable();\n     return map;\n   }\n     map.register(Enum.class, ENUM_TYPE_ADAPTER);\n     map.register(URL.class, URL_TYPE_ADAPTER);\n     map.register(Locale.class, LOCALE_TYPE_ADAPTER);\n-    map.register(Collection.class, COLLECTION_TYPE_ADAPTER);\n     map.register(Map.class, MAP_TYPE_ADAPTER);\n     map.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\n     map.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n \n     // Add primitive instance creators\n-    map.register(Boolean.class, BOOLEAN_CREATOR);\n-    map.register(boolean.class, BOOLEAN_CREATOR);\n-    map.register(Byte.class, BYTE_CREATOR);\n-    map.register(byte.class, BYTE_CREATOR);\n-    map.register(Character.class, CHARACTER_CREATOR);\n-    map.register(char.class, CHARACTER_CREATOR);\n-    map.register(Double.class, DOUBLE_CREATOR);\n-    map.register(double.class, DOUBLE_CREATOR);\n-    map.register(Float.class, FLOAT_CREATOR);\n-    map.register(float.class, FLOAT_CREATOR);\n-    map.register(Integer.class, INTEGER_CREATOR);\n-    map.register(int.class, INTEGER_CREATOR);\n-    map.register(Long.class, LONG_CREATOR);\n-    map.register(long.class, LONG_CREATOR);\n-    map.register(Short.class, SHORT_CREATOR);\n-    map.register(short.class, SHORT_CREATOR);\n-\n-    map.register(Collection.class, LINKED_LIST_CREATOR);\n+    map.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\n+    map.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\n+    map.register(Byte.class, BYTE_TYPE_ADAPTER);\n+    map.register(byte.class, BYTE_TYPE_ADAPTER);\n+    map.register(Character.class, CHARACTER_TYPE_ADAPTER);\n+    map.register(char.class, CHARACTER_TYPE_ADAPTER);\n+    map.register(Double.class, DOUBLE_TYPE_ADAPTER);\n+    map.register(double.class, DOUBLE_TYPE_ADAPTER);\n+    map.register(Float.class, FLOAT_TYPE_ADAPTER);\n+    map.register(float.class, FLOAT_TYPE_ADAPTER);\n+    map.register(Integer.class, INTEGER_TYPE_ADAPTER);\n+    map.register(int.class, INTEGER_TYPE_ADAPTER);\n+    map.register(Long.class, LONG_TYPE_ADAPTER);\n+    map.register(long.class, LONG_TYPE_ADAPTER);\n+    map.register(Short.class, SHORT_TYPE_ADAPTER);\n+    map.register(short.class, SHORT_TYPE_ADAPTER);\n+    map.register(String.class, STRING_TYPE_ADAPTER);\n+    \n+    // Add Collection type instance creators\n+    map.register(Collection.class, COLLECTION_TYPE_ADAPTER);\n     map.register(List.class, LINKED_LIST_CREATOR);\n     map.register(Queue.class, LINKED_LIST_CREATOR);\n \n     }\n   }\n \n-  private static class LongCreator implements InstanceCreator<Long> {\n+  private static class LongTypeAdapter\n+      implements InstanceCreator<Long>, JsonSerializer<Long>, JsonDeserializer<Long> {\n+    public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsLong();\n+    }\n+    \n     public Long createInstance(Type type) {\n       return new Long(0L);\n     }\n-    @Override\n-    public String toString() {\n-      return LongCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class IntegerCreator implements InstanceCreator<Integer> {\n+\n+    @Override\n+    public String toString() {\n+      return LongTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class IntegerTypeAdapter \n+      implements InstanceCreator<Integer>, JsonSerializer<Integer>, JsonDeserializer<Integer> {\n+    public JsonElement serialize(Integer src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsInt();\n+    }\n+    \n     public Integer createInstance(Type type) {\n       return new Integer(0);\n     }\n-    @Override\n-    public String toString() {\n-      return IntegerCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class ShortCreator implements InstanceCreator<Short> {\n+\n+    @Override\n+    public String toString() {\n+      return IntegerTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class ShortTypeAdapter\n+      implements InstanceCreator<Short>, JsonSerializer<Short>, JsonDeserializer<Short> {\n+    public JsonElement serialize(Short src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Short deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsShort();\n+    }\n+\n     public Short createInstance(Type type) {\n       return new Short((short) 0);\n     }\n-    @Override\n-    public String toString() {\n-      return ShortCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class ByteCreator implements InstanceCreator<Byte> {\n+    \n+    @Override\n+    public String toString() {\n+      return ShortTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class ByteTypeAdapter\n+      implements InstanceCreator<Byte>, JsonSerializer<Byte>, JsonDeserializer<Byte> {\n+    public JsonElement serialize(Byte src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Byte deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsByte();\n+    }\n+    \n     public Byte createInstance(Type type) {\n       return new Byte((byte) 0);\n     }\n-    @Override\n-    public String toString() {\n-      return ByteCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class FloatCreator implements InstanceCreator<Float> {\n+\n+    @Override\n+    public String toString() {\n+      return ByteTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class FloatTypeAdapter\n+      implements InstanceCreator<Float>, JsonSerializer<Float>, JsonDeserializer<Float> {\n+    public JsonElement serialize(Float src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Float deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsFloat();\n+    }\n+    \n     public Float createInstance(Type type) {\n       return new Float(0F);\n     }\n-    @Override\n-    public String toString() {\n-      return FloatCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class DoubleCreator implements InstanceCreator<Double> {\n+\n+    @Override\n+    public String toString() {\n+      return FloatTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class DoubleTypeAdapter\n+      implements InstanceCreator<Double>, JsonSerializer<Double>, JsonDeserializer<Double> {\n+    public JsonElement serialize(Double src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Double deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsDouble();\n+    }\n+    \n     public Double createInstance(Type type) {\n       return new Double(0D);\n     }\n-    @Override\n-    public String toString() {\n-      return DoubleCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class CharacterCreator implements InstanceCreator<Character> {\n+\n+    @Override\n+    public String toString() {\n+      return DoubleTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class CharacterTypeAdapter implements InstanceCreator<Character>,\n+      JsonSerializer<Character>, JsonDeserializer<Character> {\n+    public JsonElement serialize(Character src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Character deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsCharacter();\n+    }\n+    \n     public Character createInstance(Type type) {\n-      return new Character((char) 0);\n-    }\n-    @Override\n-    public String toString() {\n-      return CharacterCreator.class.getSimpleName();\n-    }\n-  }\n-\n-  private static class BooleanCreator implements InstanceCreator<Boolean> {\n+      return new Character('0');\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return CharacterTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+  \n+  private static class StringTypeAdapter \n+      implements InstanceCreator<String>, JsonSerializer<String>, JsonDeserializer<String> {\n+    public JsonElement serialize(String src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+    \n+    public String deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsString();\n+    }\n+    \n+    public String createInstance(Type type) {\n+      return \"\";\n+    }\n+    \n+    @Override\n+    public String toString() {\n+      return StringTypeAdapter.class.getSimpleName();\n+    }\n+  }\n+\n+  private static class BooleanTypeAdapter \n+      implements InstanceCreator<Boolean>, JsonSerializer<Boolean>, JsonDeserializer<Boolean> {\n+    public JsonElement serialize(Boolean src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src);\n+    }\n+\n+    public Boolean deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsBoolean();\n+    }\n+    \n     public Boolean createInstance(Type type) {\n       return new Boolean(false);\n     }\n-    @Override\n-    public String toString() {\n-      return BooleanCreator.class.getSimpleName();\n+\n+    @Override\n+    public String toString() {\n+      return BooleanTypeAdapter.class.getSimpleName();\n     }\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonArray.java\n+++ b/gson/src/main/java/com/google/gson/JsonArray.java\n     }\n     throw new IllegalStateException();\n   }\n+  \n+  @Override\n+  public byte getAsByte() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsByte();\n+    }\n+    throw new IllegalStateException();\n+  }\n+  \n+  @Override\n+  public char getAsCharacter() {\n+    if (elements.size() == 1) {\n+      return elements.get(0).getAsCharacter();\n+    }\n+    throw new IllegalStateException();\n+  }\n \n   /**\n    * convenience method to get this array as a primitive short if it contains a single element.\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n  * @author Joel Leitch\n  */\n final class JsonArrayDeserializationVisitor<T> extends JsonDeserializationVisitor<T> {\n-  private final Class<?> componentType;\n \n   JsonArrayDeserializationVisitor(JsonArray jsonArray, Type arrayType,\n       ObjectNavigatorFactory factory, ObjectConstructor objectConstructor,\n       TypeAdapter typeAdapter, ParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\n       JsonDeserializationContext context) {\n     super(jsonArray, arrayType, factory, objectConstructor, typeAdapter, deserializers, context);\n-    this.componentType = TypeUtils.toRawClass(arrayType);\n   }\n \n   @Override\n     TypeInfo typeInfo = new TypeInfo(targetType);\n \n     JsonArray jsonArray = json.getAsJsonArray();\n-    if (typeInfo.isPrimitiveOrStringAndNotAnArray()) {\n-      if (jsonArray.size() != 1) {\n-        throw new IllegalArgumentException(\n-            \"Primitives should be an array of length 1, but was: \" + jsonArray);\n-      }\n-      return (T) objectConstructor.construct(typeInfo.getWrappedClass());\n-    } else if (typeInfo.isArray()) {\n+    if (typeInfo.isArray()) {\n       TypeInfoArray arrayTypeInfo = TypeInfoFactory.getTypeInfoForArray(targetType);\n       // We know that we are getting back an array of the required type, so\n       // this typecasting is safe.\n       } else if (jsonChild instanceof JsonArray) {\n         child = visitChildAsArray(arrayTypeInfo.getSecondLevelType(), jsonChild.getAsJsonArray());\n       } else if (jsonChild instanceof JsonPrimitive) {\n-        child = visitChildAsPrimitive(arrayTypeInfo.getComponentRawType(),\n+        child = visitChildAsObject(arrayTypeInfo.getComponentRawType(),\n             jsonChild.getAsJsonPrimitive());\n       } else {\n         throw new IllegalStateException();\n       }\n       Array.set(array, i, child);\n     }\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public void visitPrimitiveValue(Object obj) {\n-    target = (T) typeAdapter.adaptType(json.getAsJsonArray().get(0).getAsObject(), componentType);\n   }\n \n   // We should not implement any other method from Visitor interface since\n     throw new UnsupportedOperationException();\n   }\n \n-  public void visitPrimitiveField(Field f, Type typeOfF, Object obj) {\n-    throw new UnsupportedOperationException();\n-  }\n-\n   public boolean visitFieldUsingCustomHandler(Field f, Type actualTypeOfField, Object parent) {\n     throw new UnsupportedOperationException();\n   }\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationContextDefault.java\n   @SuppressWarnings(\"unchecked\")\n   private <T> T fromJsonPrimitive(Type typeOfT, JsonPrimitive json,\n       JsonDeserializationContext context) throws JsonParseException {\n-    JsonPrimitiveDeserializationVisitor<T> visitor = new JsonPrimitiveDeserializationVisitor<T>(\n+    JsonObjectDeserializationVisitor<T> visitor = new JsonObjectDeserializationVisitor<T>(\n         json, typeOfT, navigatorFactory, objectConstructor, typeAdapter, deserializers, context);\n+    ObjectNavigator on = navigatorFactory.create(json.getAsObject(), typeOfT);\n+    on.accept(visitor);\n     Object target = visitor.getTarget();\n-    ObjectNavigator on = navigatorFactory.create(target, typeOfT);\n-    on.accept(visitor);\n-    target = visitor.getTarget();\n     if (typeOfT instanceof Class) {\n       target = typeAdapter.adaptType(target, (Class) typeOfT);\n     }\n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n     return visitChild(childType, childVisitor);\n   }\n \n-  final Object visitChildAsPrimitive(Type childType, JsonPrimitive jsonChild) {\n-    Preconditions.checkNotNull(jsonChild);\n-    Class<?> childClass;\n-    if (childType instanceof Class) {\n-      childClass = (Class<?>) childType;\n-    } else {\n-      childClass = TypeUtils.toRawClass(childType);\n-    }\n-    return typeAdapter.adaptType(jsonChild.getAsObject(), childClass);\n-  }\n-\n-  final Object visitChild(Type childType, JsonElement jsonChild) {\n-    if (jsonChild == null) {\n-      return null;\n-    } else if (jsonChild instanceof JsonArray) {\n-      return visitChildAsArray(childType, jsonChild.getAsJsonArray());\n-    } else if (jsonChild instanceof JsonObject) {\n-      return visitChildAsObject(childType, jsonChild);\n-    } else if (jsonChild instanceof JsonPrimitive) {\n-      return visitChildAsPrimitive(childType, jsonChild.getAsJsonPrimitive());\n-    } else {\n-      throw new IllegalStateException();\n-    }\n-  }\n-\n   private Object visitChild(Type type, JsonDeserializationVisitor<?> childVisitor) {\n     Object child = childVisitor.getTarget();\n     ObjectNavigator on = factory.create(child, type);\n--- a/gson/src/main/java/com/google/gson/JsonElement.java\n+++ b/gson/src/main/java/com/google/gson/JsonElement.java\n   public int getAsInt() {\n     throw new UnsupportedOperationException();\n   }\n+  \n+  /**\n+   * convenience method to get this element as a primitive byte value.\n+   *\n+   * @return get this element as a primitive byte value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * byte value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public byte getAsByte() {\n+    throw new UnsupportedOperationException();\n+  }\n+  \n+  /**\n+   * convenience method to get this element as a primitive character value.\n+   *\n+   * @return get this element as a primitive char value.\n+   * @throws ClassCastException if the element is of not a {@link JsonPrimitive} and is not a valid\n+   * char value.\n+   * @throws IllegalStateException if the element is of the type {@link JsonArray} but contains\n+   * more than a single element.\n+   */\n+  public char getAsCharacter() {\n+    throw new UnsupportedOperationException();\n+  }\n \n   /**\n    * convenience method to get this element as a {@link BigDecimal}.\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n     throw new IllegalStateException();\n   }\n \n-  public void visitPrimitiveValue(Object obj) {\n-    // should not be called since this case should invoke JsonPrimitiveDeserializationVisitor\n-    throw new IllegalStateException();\n-  }\n-\n   public void visitObjectField(Field f, Type typeOfF, Object obj) {\n     try {\n       JsonObject jsonObject = json.getAsJsonObject();\n         f.set(obj, array);\n       } else {\n         f.set(obj, null);\n-      }\n-    } catch (IllegalAccessException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  public void visitPrimitiveField(Field f, Type typeOfF, Object obj) {\n-    try {\n-      JsonObject jsonObject = json.getAsJsonObject();\n-      String fName = getFieldName(f);\n-      JsonPrimitive value = jsonObject.getAsJsonPrimitive(fName);\n-      if (value != null) {\n-        f.set(obj, typeAdapter.adaptType(value.getAsObject(), TypeUtils.toRawClass(typeOfF)));\n-      } else {\n-        // For Strings, we need to set the field to null\n-        // For other primitive types, any value created during default construction is fine\n-        if (f.getType() == String.class) {\n-          f.set(obj, null);\n-        }\n       }\n     } catch (IllegalAccessException e) {\n       throw new RuntimeException(e);\n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n   public int getAsInt() {\n     return ((Number) value).intValue();\n   }\n+  \n+  @Override\n+  public byte getAsByte() {\n+    return ((Number) value).byteValue();\n+  }\n+  \n+  @Override\n+  public char getAsCharacter() {\n+    return getAsString().charAt(0);\n+  }\n \n   /**\n    * convenience method to get this element as an Object.\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n     return childVisitor.getJsonElement();\n   }\n \n-  public void visitPrimitiveField(Field f, Type typeOfF, Object obj) {    \n-    if (isFieldNull(f, obj)) {\n-      if (serializeNulls) {\n-        addChildAsElement(f, JsonNull.INSTANCE);\n-      }      \n-    } else {\n-      TypeInfo typeInfo = new TypeInfo(typeOfF);\n-      if (typeInfo.isPrimitiveOrStringAndNotAnArray()) {\n-        Object fieldValue = getFieldValue(f, obj);\n-        addAsChildOfObject(f, typeOfF, fieldValue);\n-      } else {\n-        throw new IllegalArgumentException(\"Not a primitive type\");\n-      }\n-    }\n-  }\n-\n-  public void visitPrimitiveValue(Object obj) {\n-    assignToRoot(new JsonPrimitive(obj));\n-  }\n-\n   @SuppressWarnings(\"unchecked\")\n   public boolean visitUsingCustomHandler(Object obj, Type objType) {\n     JsonSerializer serializer = serializers.getHandlerFor(objType);\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n     void visitArray(Object array, Type componentType);\n \n     /**\n-     * This is called to visit the current object if it is a primitive\n-     */\n-    void visitPrimitiveValue(Object obj);\n-\n-    /**\n      * This is called to visit an object field of the current object\n      */\n     void visitObjectField(Field f, Type typeOfF, Object obj);\n      * This is called to visit an array field of the current object\n      */\n     void visitArrayField(Field f, Type typeOfF, Object obj);\n-\n-    /**\n-     * This is called to visit a primitive field of the current object\n-     */\n-    void visitPrimitiveField(Field f, Type typeOfF, Object obj);\n \n     /**\n      * This is called to visit an object using a custom handler\n       if (!visitedWithCustomHandler) {\n         if (objTypeInfo.isArray()) {\n           visitor.visitArray(obj, objType);\n-        } else if (objTypeInfo.isPrimitiveOrStringAndNotAnArray()) {\n-          visitor.visitPrimitiveValue(obj);\n         } else {\n           visitor.startVisitingObject(obj);\n           // For all classes in the inheritance hierarchy (including the current class),\n         if (!visitedWithCustomHandler) {\n           if (fieldTypeInfo.isArray()) {\n             visitor.visitArrayField(f, actualTypeOfField, obj);\n-          } else if (fieldTypeInfo.isPrimitiveOrStringAndNotAnArray()) {\n-            visitor.visitPrimitiveField(f, actualTypeOfField, obj);\n           } else {\n             visitor.visitObjectField(f, actualTypeOfField, obj);\n           }\n--- a/gson/src/main/java/com/google/gson/TypeInfo.java\n+++ b/gson/src/main/java/com/google/gson/TypeInfo.java\n   public final boolean isPrimitive() {\n     return Primitives.isWrapperType(Primitives.wrap(rawClass));\n   }\n-\n-  public final boolean isString() {\n-    return rawClass == String.class;\n-  }\n-\n-  public final boolean isPrimitiveOrStringAndNotAnArray() {\n-    return (isPrimitive() || isString()) && !isArray();\n-  }\n }\n--- a/gson/src/test/java/com/google/gson/TypeInfoArrayTest.java\n+++ b/gson/src/test/java/com/google/gson/TypeInfoArrayTest.java\n     TypeInfoArray arrayTypeInfo = new TypeInfoArray(int[].class);\n \n     assertTrue(arrayTypeInfo.isArray());\n+    assertFalse(arrayTypeInfo.isPrimitive());\n     assertEquals(int.class, arrayTypeInfo.getSecondLevelType());\n-    assertFalse(arrayTypeInfo.isPrimitiveOrStringAndNotAnArray());\n   }\n \n   public void testStringArray() throws Exception {\n--- a/gson/src/test/java/com/google/gson/TypeInfoTest.java\n+++ b/gson/src/test/java/com/google/gson/TypeInfoTest.java\n     TypeInfo typeInfo = new TypeInfo(boolean.class);\n \n     assertFalse(typeInfo.isArray());\n-    assertFalse(typeInfo.isString());\n     assertTrue(typeInfo.isPrimitive());\n     assertEquals(boolean.class, typeInfo.getRawClass());\n     assertEquals(Boolean.class, typeInfo.getWrappedClass());\n \n     assertEquals(Integer.class, typeInfo.getRawClass());\n     assertTrue(typeInfo.isPrimitive());\n-    assertTrue(typeInfo.isPrimitiveOrStringAndNotAnArray());\n+    assertFalse(typeInfo.isArray());\n   }\n \n   public void testString() throws Exception {\n     assertFalse(typeInfo.isArray());\n     assertFalse(typeInfo.isPrimitive());\n     assertEquals(String.class, typeInfo.getRawClass());\n-    assertTrue(typeInfo.isPrimitiveOrStringAndNotAnArray());\n   }\n \n   public void testObject() throws Exception {\n     assertFalse(typeInfo.isArray());\n     assertFalse(typeInfo.isPrimitive());\n     assertEquals(Object.class, typeInfo.getRawClass());\n-    assertFalse(typeInfo.isPrimitiveOrStringAndNotAnArray());\n   }\n \n   public void testPrimitiveType() throws Exception {\n   public void testObjectType() throws Exception {\n     TypeInfo typeInfo = new TypeInfo(String.class);\n     assertFalse(typeInfo.isArray());\n-    assertTrue(typeInfo.isString());\n+    assertFalse(typeInfo.isPrimitive());\n     assertEquals(String.class, typeInfo.getRawClass());\n   }\n \n--- a/gson/src/test/java/com/google/gson/common/TestTypes.java\n+++ b/gson/src/test/java/com/google/gson/common/TestTypes.java\n \n package com.google.gson.common;\n \n+import java.lang.reflect.Type;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n import com.google.gson.annotations.SerializedName;\n \n /**\n       return '{' + \"\\\"fooBar\\\":\" + f + '}';\n     }\n   }\n+  \n+  public static class CrazyLongTypeAdapter\n+      implements JsonSerializer<Long>, JsonDeserializer<Long> {\n+    public static final long DIFFERENCE = 5L;\n+    public JsonElement serialize(Long src, Type typeOfSrc, JsonSerializationContext context) {\n+      return new JsonPrimitive(src + DIFFERENCE);\n+    }\n+    \n+    public Long deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+        throws JsonParseException {\n+      return json.getAsLong() - DIFFERENCE;\n+    }\n+}\n }\n--- a/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ArrayTest.java\n package com.google.gson.functional;\n \n import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n import com.google.gson.common.MoreAsserts;\n+import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n import com.google.gson.common.TestTypes.MyEnum;\n import com.google.gson.reflect.TypeToken;\n \n     MoreAsserts.assertEquals(new Integer[] { 1, 2 }, target[0].toArray(new Integer[0]));\n     MoreAsserts.assertEquals(new Integer[] { 3, 4 }, target[1].toArray(new Integer[0]));\n   }\n+  \n+  public void testArrayOfPrimitivesWithCustomTypeAdapter() throws Exception {\n+    CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();\n+    gson = new GsonBuilder()\n+        .registerTypeAdapter(long.class, typeAdapter)\n+        .registerTypeAdapter(Long.class, typeAdapter)\n+        .create();\n+    long[] value = { 1L };\n+    String serializedValue = gson.toJson(value);\n+    String expected = \"[\" + String.valueOf(value[0] + CrazyLongTypeAdapter.DIFFERENCE) + \"]\";\n+    assertEquals(expected, serializedValue);\n+    \n+    long[] deserializedValue = gson.fromJson(serializedValue, long[].class);\n+    assertEquals(1, deserializedValue.length);\n+    assertEquals(value[0], deserializedValue[0]);\n+  }\n }\n--- a/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/CustomTypeAdaptersTest.java\n       return new JsonPrimitive(contents);\n     }\n   }\n+  \n+  // Test created from Issue 70\n+  public void testCustomAdapterInvokedForCollectionElementSerializationWithType() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())\n+      .create();\n+    Type setType = new TypeToken<Set<StringHolder>>() {}.getType();\n+    StringHolder holder = new StringHolder(\"Jacob\", \"Tomaw\");\n+    Set<StringHolder> setOfHolders = new HashSet<StringHolder>();\n+    setOfHolders.add(holder);\n+    String json = gson.toJson(setOfHolders, setType);\n+    assertTrue(json.contains(\"Jacob:Tomaw\"));\n+  }\n \n   // Test created from Issue 70\n   public void testCustomAdapterInvokedForCollectionElementSerialization() {\n     Gson gson = new GsonBuilder()\n       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())\n       .create();\n-    Type setType = new TypeToken<Set<StringHolder>>() {}.getType();\n     StringHolder holder = new StringHolder(\"Jacob\", \"Tomaw\");\n     Set<StringHolder> setOfHolders = new HashSet<StringHolder>();\n     setOfHolders.add(holder);\n   }\n   \n   // Test created from Issue 70\n+  public void testCustomAdapterInvokedForMapElementSerializationWithType() {\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())\n+      .create();\n+    Type mapType = new TypeToken<Map<String,StringHolder>>() {}.getType();\n+    StringHolder holder = new StringHolder(\"Jacob\", \"Tomaw\");\n+    Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();\n+    mapOfHolders.put(\"foo\", holder);\n+    String json = gson.toJson(mapOfHolders, mapType);\n+    assertTrue(json.contains(\"\\\"foo\\\":\\\"Jacob:Tomaw\\\"\"));\n+  }\n+  \n+  // Test created from Issue 70\n   public void testCustomAdapterInvokedForMapElementSerialization() {\n     Gson gson = new GsonBuilder()\n       .registerTypeAdapter(StringHolder.class, new StringHolderTypeAdapter())\n       .create();\n-    Type mapType = new TypeToken<Map<String,StringHolder>>() {}.getType();\n     StringHolder holder = new StringHolder(\"Jacob\", \"Tomaw\");\n     Map<String, StringHolder> mapOfHolders = new HashMap<String, StringHolder>();\n     mapOfHolders.put(\"foo\", holder);\n--- a/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ObjectTest.java\n   public void testSubInterfacesOfCollectionDeserialization() throws Exception {\n     String json = \"{\\\"list\\\":[0,1,2,3],\\\"queue\\\":[0,1,2,3],\\\"set\\\":[0.1,0.2,0.3,0.4],\"\n         + \"\\\"sortedSet\\\":[\\\"a\\\",\\\"b\\\",\\\"c\\\",\\\"d\\\"]\"\n-//        + \",\\\"navigableSet\\\":[\\\"abc\\\",\\\"def\\\",\\\"ghi\\\",\\\"jkl\\\"]\"\n         + \"}\";\n     ClassWithSubInterfacesOfCollection target = gson.fromJson(\n         json, ClassWithSubInterfacesOfCollection.class);\n--- a/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/ParameterizedTypesTest.java\n         .create();\n \n     String json = expected.getExpectedJson();\n-    MyParameterizedType<Integer> actual = gson.fromJson(json, expectedType);\n+    MyParameterizedType<BagOfPrimitives> actual = gson.fromJson(json, expectedType);\n     assertEquals(expected, actual);\n   }\n \n--- a/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/PrimitiveTest.java\n \n package com.google.gson.functional;\n \n-import com.google.gson.Gson;\n-import com.google.gson.JsonParseException;\n-\n-import junit.framework.TestCase;\n-\n import java.math.BigDecimal;\n import java.math.BigInteger;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.common.TestTypes.CrazyLongTypeAdapter;\n \n /**\n  * Functional tests for Json primitive values: integers, and floating point numbers.\n       fail(\"BigInteger can not be decimal values.\");\n     } catch (JsonParseException expected) { }\n   }\n+  \n+  public void testOverridingDefaultPrimitiveSerialization() {\n+    CrazyLongTypeAdapter typeAdapter = new CrazyLongTypeAdapter();\n+    gson = new GsonBuilder()\n+        .registerTypeAdapter(long.class, typeAdapter)\n+        .registerTypeAdapter(Long.class, typeAdapter)\n+        .create();\n+    long value = 1L;\n+    String serializedValue = gson.toJson(value);\n+    assertEquals(String.valueOf(value + CrazyLongTypeAdapter.DIFFERENCE), serializedValue);\n+    \n+    long deserializedValue = gson.fromJson(serializedValue, long.class);\n+    assertEquals(value, deserializedValue);\n+  }\n \n   private String extractElementFromArray(String json) {\n     return json.substring(json.indexOf('[') + 1, json.indexOf(']'));", "timestamp": 1226716017, "metainfo": ""}