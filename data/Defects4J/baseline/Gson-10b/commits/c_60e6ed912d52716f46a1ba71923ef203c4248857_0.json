{"sha": "60e6ed912d52716f46a1ba71923ef203c4248857", "log": "Promote MiniGson to gson.internal.bind", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Adapt an array of objects.\n+ */\n+final class ArrayTypeAdapter<E> extends TypeAdapter<Object> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\n+        return null;\n+      }\n+\n+      Type componentType = $Gson$Types.getArrayComponentType(type);\n+      TypeAdapter<?> componentTypeAdapter = context.getAdapter(TypeToken.get(componentType));\n+      @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n+      TypeAdapter<T> result = new ArrayTypeAdapter(\n+          componentTypeAdapter, $Gson$Types.getRawType(componentType));\n+      return result;\n+    }\n+  };\n+\n+  private final Class<E> componentType;\n+  private final TypeAdapter<E> componentTypeAdapter;\n+\n+  public ArrayTypeAdapter(TypeAdapter<E> componentTypeAdapter, Class<E> componentType) {\n+    this.componentTypeAdapter = componentTypeAdapter;\n+    this.componentType = componentType;\n+  }\n+\n+  public Object read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    List<E> list = new ArrayList<E>();\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      E instance = componentTypeAdapter.read(reader);\n+      list.add(instance);\n+    }\n+    reader.endArray();\n+    Object array = Array.newInstance(componentType, list.size());\n+    for (int i = 0; i < list.size(); i++) {\n+      Array.set(array, i, list.get(i));\n+    }\n+    return array;\n+  }\n+\n+  @Override public void write(JsonWriter writer, Object array) throws IOException {\n+    if (array == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginArray();\n+    for (int i = 0, length = Array.getLength(array); i < length; i++) {\n+      final E value = (E) Array.get(array, i);\n+      componentTypeAdapter.write(writer, value);\n+    }\n+    writer.endArray();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Adapt a homogeneous collection of objects.\n+ */\n+final class CollectionTypeAdapter<E> extends TypeAdapter<Collection<E>> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof ParameterizedType)) {\n+        return null;\n+      }\n+\n+      Class<? super T> rawType = typeToken.getRawType();\n+      if (!Collection.class.isAssignableFrom(rawType)) {\n+        return null;\n+      }\n+\n+      Type elementType = $Gson$Types.getCollectionElementType(type, rawType);\n+      TypeAdapter<?> elementTypeAdapter = context.getAdapter(TypeToken.get(elementType));\n+\n+      Class<?> constructorType;\n+\n+      if (rawType == List.class || rawType == Collection.class) {\n+        constructorType = ArrayList.class;\n+      } else if (rawType == Set.class) {\n+        constructorType = LinkedHashSet.class;\n+      } else {\n+        constructorType = rawType;\n+      }\n+\n+      Constructor<?> constructor;\n+      try {\n+        constructor = constructorType.getConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // create() doesn't define a type parameter\n+      TypeAdapter<T> result = new CollectionTypeAdapter(elementTypeAdapter, constructor);\n+      return result;\n+    }\n+  };\n+\n+  private final TypeAdapter<E> elementTypeAdapter;\n+  private final Constructor<? extends Collection<E>> constructor;\n+\n+  public CollectionTypeAdapter(TypeAdapter<E> elementTypeAdapter,\n+      Constructor<? extends Collection<E>> constructor) {\n+    this.elementTypeAdapter = elementTypeAdapter;\n+    this.constructor = constructor;\n+  }\n+\n+  public Collection<E> read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    Collection<E> collection = MiniGson.newInstance(constructor);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      E instance = elementTypeAdapter.read(reader);\n+      collection.add(instance);\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  public void write(JsonWriter writer, Collection<E> collection) throws IOException {\n+    if (collection == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginArray();\n+    for (E element : collection) {\n+      elementTypeAdapter.write(writer, element);\n+    }\n+    writer.endArray();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MiniGson.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * A basic binding between JSON and Java objects.\n+ */\n+public final class MiniGson {\n+  /**\n+   * This thread local guards against reentrant calls to getAdapter(). In\n+   * certain object graphs, creating an adapter for a type may recursively\n+   * require an adapter for the same type! Without intervention, the recursive\n+   * lookup would stack overflow. We cheat by returning a proxy type adapter.\n+   * The proxy is wired up once the initial adapter has been created.\n+   */\n+  private final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n+      = new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>() {\n+    @Override protected Map<TypeToken<?>, FutureTypeAdapter<?>> initialValue() {\n+      return new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\n+    }\n+  };\n+\n+  private final List<TypeAdapter.Factory> factories;\n+\n+  private MiniGson(Builder builder) {\n+    List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+    factories.add(TypeAdapters.BOOLEAN_FACTORY);\n+    factories.add(TypeAdapters.INTEGER_FACTORY);\n+    factories.add(TypeAdapters.DOUBLE_FACTORY);\n+    factories.add(TypeAdapters.LONG_FACTORY);\n+    factories.add(TypeAdapters.STRING_FACTORY);\n+    factories.addAll(builder.factories);\n+    factories.add(CollectionTypeAdapter.FACTORY);\n+    factories.add(StringToValueMapTypeAdapter.FACTORY);\n+    factories.add(ArrayTypeAdapter.FACTORY);\n+    factories.add(ReflectiveTypeAdapter.FACTORY);\n+    this.factories = Collections.unmodifiableList(factories);\n+  }\n+\n+  // TODO: this should use Joel's unsafe constructor stuff\n+  static <T> T newInstance(Constructor<T> constructor) {\n+    try {\n+      Object[] args = null;\n+      return constructor.newInstance(args);\n+    } catch (InstantiationException e) {\n+      // TODO: JsonParseException ?\n+      throw new RuntimeException(e);\n+    } catch (InvocationTargetException e) {\n+      // TODO: don't wrap if cause is unchecked!\n+      // TODO: JsonParseException ?\n+      throw new RuntimeException(e.getTargetException());\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError(e);\n+    }\n+  }\n+\n+  /**\n+   * Returns the type adapter for {@code} type.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\n+    // TODO: create a cache!\n+\n+    Map<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\n+    @SuppressWarnings(\"unchecked\") // the key and value type parameters always agree\n+    FutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\n+    if (ongoingCall != null) {\n+      return ongoingCall;\n+    }\n+\n+    FutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\n+    threadCalls.put(type, call);\n+    try {\n+      for (TypeAdapter.Factory factory : factories) {\n+        TypeAdapter<T> candidate = factory.create(this, type);\n+        if (candidate != null) {\n+          call.setDelegate(candidate);\n+          return candidate;\n+        }\n+      }\n+      throw new IllegalArgumentException(\"This MiniGSON cannot serialize \" + type);\n+    } finally {\n+      threadCalls.remove(type);\n+    }\n+  }\n+\n+  static class FutureTypeAdapter<T> extends TypeAdapter<T> {\n+    private TypeAdapter<T> delegate;\n+\n+    public void setDelegate(TypeAdapter<T> typeAdapter) {\n+      if (delegate != null) {\n+        throw new AssertionError();\n+      }\n+      delegate = typeAdapter;\n+    }\n+\n+    @Override public T read(JsonReader reader) throws IOException {\n+      if (delegate == null) {\n+        throw new IllegalStateException();\n+      }\n+      return delegate.read(reader);\n+    }\n+\n+    @Override public void write(JsonWriter writer, T value) throws IOException {\n+      if (delegate == null) {\n+        throw new IllegalStateException();\n+      }\n+      delegate.write(writer, value);\n+    }\n+  }\n+\n+  /**\n+   * Returns the type adapter for {@code} type.\n+   *\n+   * @throws IllegalArgumentException if this GSON cannot serialize and\n+   *     deserialize {@code type}.\n+   */\n+  public <T> TypeAdapter<T> getAdapter(Class<T> type) {\n+    return getAdapter(TypeToken.get(type));\n+  }\n+\n+  /**\n+   * Returns the type adapters of this context in order of precedence.\n+   */\n+  public List<TypeAdapter.Factory> getFactories() {\n+    return factories;\n+  }\n+\n+  public static final class Builder {\n+    private final List<TypeAdapter.Factory> factories = new ArrayList<TypeAdapter.Factory>();\n+\n+    public Builder factory(TypeAdapter.Factory factory) {\n+      factories.add(factory);\n+      return this;\n+    }\n+\n+    public <T> Builder typeAdapter(final Class<T> type, final TypeAdapter<T> typeAdapter) {\n+      factories.add(TypeAdapters.newFactory(type, typeAdapter));\n+      return this;\n+    }\n+\n+    public <T> Builder typeAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+      factories.add(TypeAdapters.newFactory(type, typeAdapter));\n+      return this;\n+    }\n+\n+    public <T> Builder typeHierarchyAdapter(TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+      factories.add(TypeAdapters.newTypeHierarchyFactory(type, typeAdapter));\n+      return this;\n+    }\n+\n+    public MiniGson build() {\n+      return new MiniGson(this);\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapts the fields of an object to the properties of a JSON object.\n+ */\n+final class ReflectiveTypeAdapter<T> extends TypeAdapter<T>  {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type) {\n+      Class<? super T> raw = type.getRawType();\n+\n+      if (!Object.class.isAssignableFrom(raw)) {\n+        return null; // it's a primitive!\n+      }\n+\n+      // TODO: use Joel's constructor calling code (with setAccessible)\n+      Constructor<? super T> constructor;\n+      try {\n+        constructor = raw.getDeclaredConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      return new ReflectiveTypeAdapter<T>(constructor, getBoundFields(context, type, raw));\n+    }\n+\n+    private Map<String, BoundField> getBoundFields(\n+        MiniGson context, TypeToken<?> type, Class<?> raw) {\n+      Map<String, BoundField> result = new LinkedHashMap<String, BoundField>();\n+      while (raw != Object.class) {\n+        for (Field field : raw.getDeclaredFields()) {\n+          field.setAccessible(true); // TODO: don't call setAccessible unless necessary\n+          Type fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\n+          BoundField boundField = createBoundField(context, field, TypeToken.get(fieldType));\n+          result.put(boundField.name, boundField);\n+        }\n+        type = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\n+        raw = type.getRawType();\n+      }\n+      return result;\n+    }\n+  };\n+\n+  private final Constructor<? super T> constructor;\n+  private final Map<String, BoundField> map;\n+  private final BoundField[] boundFields;\n+\n+  ReflectiveTypeAdapter(Constructor<? super T> constructor, Map<String, BoundField> map) {\n+    this.constructor = constructor;\n+    this.map = map;\n+    this.boundFields = map.values().toArray(new BoundField[map.size()]);\n+  }\n+\n+  public T read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") // the '? super T' is a raw T (the only kind we can construct)\n+    T instance = (T) MiniGson.newInstance(constructor);\n+\n+    // TODO: null out the other fields?\n+\n+    reader.beginObject();\n+    try {\n+      while (reader.hasNext()) {\n+        String name = reader.nextName();\n+        BoundField field = map.get(name);\n+        if (field == null) {\n+          // TODO: define a better policy\n+          reader.skipValue();\n+        } else {\n+          field.read(reader, instance);\n+        }\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError();\n+    }\n+    reader.endObject();\n+    return instance;\n+  }\n+\n+  public void write(JsonWriter writer, T value) throws IOException {\n+    if (value == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginObject();\n+    try {\n+      for (BoundField boundField : boundFields) {\n+        writer.name(boundField.name);\n+        boundField.write(writer, value);\n+      }\n+    } catch (IllegalAccessException e) {\n+      throw new AssertionError();\n+    }\n+    writer.endObject();\n+  }\n+\n+  static BoundField createBoundField(\n+      final MiniGson context, final Field field, final TypeToken<?> fieldType) {\n+    // special casing primitives here saves ~5% on Android...\n+    return new BoundField(field.getName()) {\n+      final TypeAdapter<?> typeAdapter = context.getAdapter(fieldType);\n+      @SuppressWarnings(\"unchecked\") // the type adapter and field type always agree\n+      @Override void write(JsonWriter writer, Object value)\n+          throws IOException, IllegalAccessException {\n+        Object fieldValue = field.get(value);\n+        ((TypeAdapter) typeAdapter).write(writer, fieldValue);\n+      }\n+      @Override void read(JsonReader reader, Object value)\n+          throws IOException, IllegalAccessException {\n+        Object fieldValue = typeAdapter.read(reader);\n+        field.set(value, fieldValue);\n+      }\n+    };\n+  }\n+\n+  static abstract class BoundField {\n+    final String name;\n+\n+    protected BoundField(String name) {\n+      this.name = name;\n+    }\n+\n+    abstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\n+    abstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/StringToValueMapTypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonToken;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Adapt a map whose keys are strings.\n+ */\n+final class StringToValueMapTypeAdapter<V> extends TypeAdapter<Map<String, V>> {\n+  public static final Factory FACTORY = new Factory() {\n+    public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+      Type type = typeToken.getType();\n+      if (!(type instanceof ParameterizedType)) {\n+        return null;\n+      }\n+\n+      Class<? super T> rawType = typeToken.getRawType();\n+      if (!Map.class.isAssignableFrom(rawType)) {\n+        return null;\n+      }\n+\n+      Type[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawType);\n+      if (keyAndValueTypes[0] != String.class) {\n+        return null;\n+      }\n+      TypeAdapter<?> valueAdapter = context.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n+\n+      Constructor<?> constructor;\n+      try {\n+        Class<?> constructorType = (rawType == Map.class) ? LinkedHashMap.class : rawType;\n+        constructor = constructorType.getConstructor();\n+      } catch (NoSuchMethodException e) {\n+        return null;\n+      }\n+\n+      @SuppressWarnings(\"unchecked\") // we don't define a type parameter for the key or value types\n+      TypeAdapter<T> result = new StringToValueMapTypeAdapter(valueAdapter, constructor);\n+      return result;\n+    }\n+  };\n+\n+  private final TypeAdapter<V> valueTypeAdapter;\n+  private final Constructor<? extends Map<String, V>> constructor;\n+\n+  public StringToValueMapTypeAdapter(TypeAdapter<V> valueTypeAdapter,\n+      Constructor<? extends Map<String, V>> constructor) {\n+    this.valueTypeAdapter = valueTypeAdapter;\n+    this.constructor = constructor;\n+  }\n+\n+  public Map<String, V> read(JsonReader reader) throws IOException {\n+    if (reader.peek() == JsonToken.NULL) {\n+      reader.nextNull(); // TODO: does this belong here?\n+      return null;\n+    }\n+\n+    Map<String, V> map = MiniGson.newInstance(constructor);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String key = reader.nextName();\n+      V value = valueTypeAdapter.read(reader);\n+      map.put(key, value);\n+    }\n+    reader.endObject();\n+    return map;\n+  }\n+\n+  public void write(JsonWriter writer, Map<String, V> map) throws IOException {\n+    if (map == null) {\n+      writer.nullValue(); // TODO: better policy here?\n+      return;\n+    }\n+\n+    writer.beginObject();\n+    for (Map.Entry<String, V> entry : map.entrySet()) {\n+      writer.name(entry.getKey());\n+      valueTypeAdapter.write(writer, entry.getValue());\n+    }\n+    writer.endObject();\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapter.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+public abstract class TypeAdapter<T> {\n+  public abstract T read(JsonReader reader) throws IOException;\n+  public abstract void write(JsonWriter writer, T value) throws IOException;\n+\n+  public final String toJson(T value) throws IOException {\n+    StringWriter stringWriter = new StringWriter();\n+    write(stringWriter, value);\n+    return stringWriter.toString();\n+  }\n+\n+  public final void write(Writer out, T value) throws IOException {\n+    JsonWriter writer = new JsonWriter(out);\n+    write(writer, value);\n+  }\n+\n+  public final T fromJson(String json) throws IOException {\n+    return read(new StringReader(json));\n+  }\n+\n+  public final T read(Reader in) throws IOException {\n+    JsonReader reader = new JsonReader(in);\n+    reader.setLenient(true);\n+    return read(reader);\n+  }\n+\n+  public interface Factory {\n+    <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> type);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+\n+/**\n+ * Type adapters for basic types.\n+ */\n+final class TypeAdapters {\n+  private TypeAdapters() {}\n+\n+  public static final TypeAdapter<Boolean> BOOLEAN = new TypeAdapter<Boolean>() {\n+    public Boolean read(JsonReader reader) throws IOException {\n+      return reader.nextBoolean();\n+    }\n+    public void write(JsonWriter writer, Boolean value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory BOOLEAN_FACTORY\n+      = newFactory(boolean.class, Boolean.class, BOOLEAN);\n+\n+  public static final TypeAdapter<Integer> INTEGER = new TypeAdapter<Integer>() {\n+    public Integer read(JsonReader reader) throws IOException {\n+      return reader.nextInt();\n+    }\n+    public void write(JsonWriter writer, Integer value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory INTEGER_FACTORY\n+      = newFactory(int.class, Integer.class, INTEGER);\n+\n+  public static final TypeAdapter<Long> LONG = new TypeAdapter<Long>() {\n+    public Long read(JsonReader reader) throws IOException {\n+      return reader.nextLong();\n+    }\n+    public void write(JsonWriter writer, Long value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory LONG_FACTORY\n+      = newFactory(long.class, Long.class, LONG);\n+\n+  public static final TypeAdapter<Double> DOUBLE = new TypeAdapter<Double>() {\n+    public Double read(JsonReader reader) throws IOException {\n+      return reader.nextDouble();\n+    }\n+    public void write(JsonWriter writer, Double value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory DOUBLE_FACTORY\n+      = newFactory(double.class, Double.class, DOUBLE);\n+\n+  public static final TypeAdapter<String> STRING = new TypeAdapter<String>() {\n+    public String read(JsonReader reader) throws IOException {\n+      return reader.nextString();\n+    }\n+    public void write(JsonWriter writer, String value) throws IOException {\n+      writer.value(value);\n+    }\n+  };\n+\n+  public static final TypeAdapter.Factory STRING_FACTORY = newFactory(String.class, STRING);\n+\n+  public static <T> TypeAdapter.Factory newFactory(\n+      final TypeToken<T> type, final TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        return typeToken.equals(type) ? (TypeAdapter<T>) typeAdapter : null;\n+      }\n+    };\n+  }\n+\n+  public static <T> TypeAdapter.Factory newFactory(\n+      final Class<T> type, final TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        return typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n+      }\n+    };\n+  }\n+\n+  private static <T> TypeAdapter.Factory newFactory(\n+      final Class<T> unboxed, final Class<T> boxed, final TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      @SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        Class<? super T> rawType = typeToken.getRawType();\n+        return (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n+      }\n+    };\n+  }\n+\n+  public static <T> TypeAdapter.Factory newTypeHierarchyFactory(\n+      TypeToken<T> type, TypeAdapter<T> typeAdapter) {\n+    return new TypeAdapter.Factory() {\n+      public <T> TypeAdapter<T> create(MiniGson context, TypeToken<T> typeToken) {\n+        // TODO: use Inder's TypeHierarchyAdapter here\n+        throw new UnsupportedOperationException();\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/bind/MiniGsonTest.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import com.google.gson.internal.bind.MiniGson;\n+import com.google.gson.internal.bind.TypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import junit.framework.TestCase;\n+\n+public final class MiniGsonTest extends TestCase {\n+  private MiniGson miniGson = new MiniGson.Builder().build();\n+  private TypeAdapter<Truck> truckAdapter = miniGson.getAdapter(Truck.class);\n+  private TypeAdapter<Map<String, Double>> mapAdapter\n+      = miniGson.getAdapter(new TypeToken<Map<String, Double>>() {});\n+\n+  public void testSerialize() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\n+    truck.horsePower = 300;\n+\n+    assertEquals(\"{'horsePower':300.0,\"\n+        + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserialize() throws IOException {\n+    String json = \"{'horsePower':300.0,\"\n+        + \"'passengers':[{'age':29,'name':'Jesse'},{'age':29,'name':'Jodie'}]}\";\n+    Truck truck = truckAdapter.fromJson(json);\n+    assertEquals(300.0, truck.horsePower);\n+    assertEquals(Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29)), truck.passengers);\n+  }\n+\n+  public void testSerializeNullField() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = null;\n+    assertEquals(\"{'horsePower':0.0,'passengers':null}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeNullField() throws IOException {\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':null}\");\n+    assertNull(truck.passengers);\n+  }\n+\n+  public void testSerializeNullObject() throws IOException {\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList((Person) null);\n+    assertEquals(\"{'horsePower':0.0,'passengers':[null]}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeNullObject() throws IOException {\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':[null]}\");\n+    assertEquals(Arrays.asList((Person) null), truck.passengers);\n+  }\n+\n+  public void testSerializeWithCustomTypeAdapter() throws IOException {\n+    usePersonNameAdapter();\n+    Truck truck = new Truck();\n+    truck.passengers = Arrays.asList(new Person(\"Jesse\", 29), new Person(\"Jodie\", 29));\n+    assertEquals(\"{'horsePower':0.0,'passengers':['Jesse','Jodie']}\",\n+        truckAdapter.toJson(truck).replace('\\\"', '\\''));\n+  }\n+\n+  public void testDeserializeWithCustomTypeAdapter() throws IOException {\n+    usePersonNameAdapter();\n+    Truck truck = truckAdapter.fromJson(\"{'horsePower':0.0,'passengers':['Jesse','Jodie']}\");\n+    assertEquals(Arrays.asList(new Person(\"Jesse\", -1), new Person(\"Jodie\", -1)), truck.passengers);\n+  }\n+\n+  private void usePersonNameAdapter() {\n+    TypeAdapter<Person> personNameAdapter = new TypeAdapter<Person>() {\n+      @Override public Person read(JsonReader reader) throws IOException {\n+        String name = reader.nextString();\n+        return new Person(name, -1);\n+      }\n+      @Override public void write(JsonWriter writer, Person value) throws IOException {\n+        writer.value(value.name);\n+      }\n+    };\n+    miniGson = new MiniGson.Builder().typeAdapter(Person.class, personNameAdapter).build();\n+    truckAdapter = miniGson.getAdapter(Truck.class);\n+  }\n+\n+  public void testSerializeMap() throws IOException {\n+    Map<String, Double> map = new LinkedHashMap<String, Double>();\n+    map.put(\"a\", 5.0);\n+    map.put(\"b\", 10.0);\n+    assertEquals(\"{'a':5.0,'b':10.0}\", mapAdapter.toJson(map).replace('\"', '\\''));\n+  }\n+\n+  public void testDeserializeMap() throws IOException {\n+    Map<String, Double> map = new LinkedHashMap<String, Double>();\n+    map.put(\"a\", 5.0);\n+    map.put(\"b\", 10.0);\n+    assertEquals(map, mapAdapter.fromJson(\"{'a':5.0,'b':10.0}\"));\n+  }\n+\n+  public void testSerialize1dArray() throws IOException {\n+    TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});\n+    assertEquals(\"[1.0,2.0,3.0]\", arrayAdapter.toJson(new double[]{1.0, 2.0, 3.0}));\n+  }\n+\n+  public void testDeserialize1dArray() throws IOException {\n+    TypeAdapter<double[]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[]>() {});\n+    double[] array = arrayAdapter.fromJson(\"[1.0,2.0,3.0]\");\n+    assertTrue(Arrays.toString(array), Arrays.equals(new double[]{1.0, 2.0, 3.0}, array));\n+  }\n+\n+  public void testSerialize2dArray() throws IOException {\n+    TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});\n+    double[][] array = { {1.0, 2.0 }, { 3.0 } };\n+    assertEquals(\"[[1.0,2.0],[3.0]]\", arrayAdapter.toJson(array));\n+  }\n+\n+  public void testDeserialize2dArray() throws IOException {\n+    TypeAdapter<double[][]> arrayAdapter = miniGson.getAdapter(new TypeToken<double[][]>() {});\n+    double[][] array = arrayAdapter.fromJson(\"[[1.0,2.0],[3.0]]\");\n+    double[][] expected = { {1.0, 2.0 }, { 3.0 } };\n+    assertTrue(Arrays.toString(array), Arrays.deepEquals(expected, array));\n+  }\n+\n+  public void testSerializeRecursive() throws IOException {\n+    TypeAdapter<Node> nodeAdapter = miniGson.getAdapter(Node.class);\n+    Node root = new Node(\"root\");\n+    root.left = new Node(\"left\");\n+    root.right = new Node(\"right\");\n+    assertEquals(\"{'label':'root',\"\n+        + \"'left':{'label':'left','left':null,'right':null},\"\n+        + \"'right':{'label':'right','left':null,'right':null}}\",\n+        nodeAdapter.toJson(root).replace('\"', '\\''));\n+  }\n+\n+  static class Truck {\n+    double horsePower;\n+    List<Person> passengers = Collections.emptyList();\n+  }\n+\n+  static class Person {\n+    int age;\n+    String name;\n+    Person(String name, int age) {\n+      this.name = name;\n+      this.age = age;\n+    }\n+\n+    public Person() {} // TODO: use Joel's constructor code so we don't need this\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof Person\n+          && ((Person) o).name.equals(name)\n+          && ((Person) o).age == age;\n+    }\n+    @Override public int hashCode() {\n+      return name.hashCode() ^ age;\n+    }\n+  }\n+\n+  static class Node {\n+    String label;\n+    Node left;\n+    Node right;\n+    Node(String label) {\n+      this.label = label;\n+    }\n+    public Node() {} // TODO: use Joel's constructor code so we don't need this\n+  }\n+}", "timestamp": 1312331110, "metainfo": ""}