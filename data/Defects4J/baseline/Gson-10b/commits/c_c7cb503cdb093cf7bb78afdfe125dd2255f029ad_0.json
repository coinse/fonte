{"sha": "c7cb503cdb093cf7bb78afdfe125dd2255f029ad", "log": "Restore fast skips.      document            api      ns linear runtime       TWEETS    GSON_STREAM  397568 =========       TWEETS      GSON_SKIP  300058 ======= READER_SHORT    GSON_STREAM   76632 = READER_SHORT      GSON_SKIP   57796 =  READER_LONG    GSON_STREAM  894690 =====================  READER_LONG      GSON_SKIP  565114 =============", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   private static final int PEEKED_SINGLE_QUOTED = 8;\n   private static final int PEEKED_DOUBLE_QUOTED = 9;\n   private static final int PEEKED_UNQUOTED = 10;\n+  /** When this is returned, the string value is stored in peekedString. */\n   private static final int PEEKED_BUFFERED = 11;\n   private static final int PEEKED_SINGLE_QUOTED_NAME = 12;\n   private static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\n   private long peekedInteger;\n \n   /**\n-   * The number of characters in the peeked number.\n+   * The number of characters in a peeked number literal. Increment 'pos' by\n+   * this after reading a number.\n    */\n   private int peekedNumberLength;\n \n+  /**\n+   * A peeked string that should be parsed on the next double, long or string.\n+   * This is populated before a numeric value is parsed and used if that parsing\n+   * fails.\n+   */\n   private String peekedString;\n \n   /*\n \n         if (c == quote) {\n           pos = p;\n-          if (false /* TODO: fast skipping */) {\n-            return \"skipped!\";\n-          } else if (builder == null) {\n+          if (builder == null) {\n             return new String(buffer, start, p - start - 1);\n           } else {\n             builder.append(buffer, start, p - start - 1);\n     }\n \n     String result;\n-    if (false /* TODO: fast skipping */) {\n-      result = \"skipped!\";\n-    } else if (builder == null) {\n+    if (builder == null) {\n       result = new String(buffer, pos, i);\n     } else {\n       builder.append(buffer, pos, i);\n     }\n     pos += i;\n     return result;\n+  }\n+\n+  private void skipQuotedValue(char quote) throws IOException {\n+    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n+    char[] buffer = this.buffer;\n+    do {\n+      int p = pos;\n+      int l = limit;\n+      /* the index of the first character not yet appended to the builder. */\n+      while (p < l) {\n+        int c = buffer[p++];\n+        if (c == quote) {\n+          pos = p;\n+          return;\n+        } else if (c == '\\\\') {\n+          pos = p;\n+          readEscapeCharacter();\n+          p = pos;\n+          l = limit;\n+        }\n+      }\n+      pos = p;\n+    } while (fillBuffer(1));\n+    throw syntaxError(\"Unterminated string\");\n+  }\n+\n+  private void skipUnquotedValue() throws IOException {\n+    do {\n+      int i = 0;\n+      for (; pos + i < limit; i++) {\n+        switch (buffer[pos + i]) {\n+        case '/':\n+        case '\\\\':\n+        case ';':\n+        case '#':\n+        case '=':\n+          checkLenient(); // fall-through\n+        case '{':\n+        case '}':\n+        case '[':\n+        case ']':\n+        case ':':\n+        case ',':\n+        case ' ':\n+        case '\\t':\n+        case '\\f':\n+        case '\\r':\n+        case '\\n':\n+          pos += i;\n+          return;\n+        }\n+      }\n+      pos += i;\n+    } while (fillBuffer(1));\n   }\n \n   /**\n         stackSize--;\n         count--;\n       } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n-        nextUnquotedValue();\n+        skipUnquotedValue();\n       } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n-        nextQuotedValue('\\'');\n+        skipQuotedValue('\\'');\n       } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n-        nextQuotedValue('\"');\n+        skipQuotedValue('\"');\n       } else if (p == PEEKED_NUMBER) {\n         pos += peekedNumberLength;\n       }\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n         \"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\");\n   }\n \n+  public void disabled_testVeryLongNumber() throws IOException {\n+    // TODO: this is a completely broken case that needs to be fixed!\n+    JsonReader reader = new JsonReader(new StringReader(\"[0.\" + repeat('9', 8192) + \"]\"));\n+    reader.beginArray();\n+    assertEquals(1d, reader.nextDouble());\n+    reader.endArray();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testVeryLongUnquotedLiteral() throws IOException {\n+    String literal = \"a\" + repeat('b', 8192) + \"c\";\n+    JsonReader reader = new JsonReader(new StringReader(\"[\" + literal + \"]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(literal, reader.nextString());\n+    reader.endArray();\n+  }\n+\n   public void testFailWithPositionIsOffsetByBom() throws IOException {\n     testFailWithPosition(\"Expected value at line 1 column 4\",\n         \"\\ufeff[0,}]\");\n   }\n \n   public void testSkipVeryLongUnquotedString() throws IOException {\n-    char[] stringChars = new char[1024 * 16];\n-    Arrays.fill(stringChars, 'x');\n-    String string = new String(stringChars);\n-    String json = \"[\" + string + \"]\";\n-    JsonReader reader = new JsonReader(new StringReader(json));\n+    JsonReader reader = new JsonReader(new StringReader(\"[\" + repeat('x', 8192) + \"]\"));\n     reader.setLenient(true);\n     reader.beginArray();\n     reader.skipValue();\n     reader.endArray();\n+  }\n+\n+  public void testSkipTopLevelUnquotedString() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(repeat('x', 8192)));\n+    reader.setLenient(true);\n+    reader.skipValue();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testSkipVeryLongQuotedString() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[\\\"\" + repeat('x', 8192) + \"\\\"]\"));\n+    reader.beginArray();\n+    reader.skipValue();\n+    reader.endArray();\n+  }\n+\n+  public void testSkipTopLevelQuotedString() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"\\\"\" + repeat('x', 8192) + \"\\\"\"));\n+    reader.setLenient(true);\n+    reader.skipValue();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n   }\n \n   public void testStringAsNumberWithTruncatedExponent() throws IOException {\n--- a/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java\n+++ b/metrics/src/main/java/com/google/gson/metrics/ParseBenchmark.java\n         return new GsonStreamParser();\n       }\n     },\n+    GSON_SKIP {\n+      @Override Parser newParser() {\n+        return new GsonSkipParser();\n+      }\n+    },\n     GSON_DOM {\n       @Override Parser newParser() {\n         return new GsonDomParser();\n       default:\n         throw new IllegalArgumentException(\"Unexpected token\" + reader.peek());\n       }\n+    }\n+  }\n+\n+  private static class GsonSkipParser implements Parser {\n+    public void parse(char[] data, Document document) throws Exception {\n+      com.google.gson.stream.JsonReader jsonReader\n+          = new com.google.gson.stream.JsonReader(new CharArrayReader(data));\n+      jsonReader.skipValue();\n+      jsonReader.close();\n     }\n   }\n ", "timestamp": 1346030270, "metainfo": ""}