{"sha": "aa5243595135991edefd07201b5967b48808c728", "log": "Apply an ugly optimization to save 5% on pretty printed JSON documents. This uses locals instead of fields in an inner loop to save field reads and writes.", "commit": "\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n   }\n \n   private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n-    while (pos < limit || fillBuffer(1)) {\n-      int c = buffer[pos++];\n+    /*\n+     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n+     * and 'limit' fields respectively. Using locals rather than fields saves\n+     * a few field reads for each whitespace character in a pretty-printed\n+     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n+     * before any (potentially indirect) call to fillBuffer() and reread both\n+     * 'p' and 'l' after any (potentially indirect) call to the same method.\n+     */\n+    char[] buffer = this.buffer;\n+    int p = pos;\n+    int l = limit;\n+    while (true) {\n+      if (p == l) {\n+        pos = p;\n+        if (!fillBuffer(1)) {\n+          break;\n+        }\n+        p = pos;\n+        l = limit;\n+      }\n+\n+      int c = buffer[p++];\n       switch (c) {\n       case '\\t':\n       case ' ':\n         continue;\n \n       case '/':\n-        if (pos == limit && !fillBuffer(1)) {\n+        pos = p;\n+        if (p == l && !fillBuffer(1)) {\n           return c;\n         }\n \n           if (!skipTo(\"*/\")) {\n             throw syntaxError(\"Unterminated comment\");\n           }\n-          pos += 2;\n+          p = pos + 2;\n+          l = limit;\n           continue;\n \n         case '/':\n           // skip a // end-of-line comment\n           pos++;\n           skipToEndOfLine();\n+          p = pos;\n+          l = limit;\n           continue;\n \n         default:\n         }\n \n       case '#':\n+        pos = p;\n         /*\n          * Skip a # hash end-of-line comment. The JSON RFC doesn't\n          * specify this behaviour, but it's required to parse\n          */\n         checkLenient();\n         skipToEndOfLine();\n+        p = pos;\n+        l = limit;\n         continue;\n \n       default:\n+        pos = p;\n         return c;\n       }\n     }", "timestamp": 1323840389, "metainfo": ""}