{"sha": "5e3f5a6bbecb6a83bd1995621bd4e8131943e8a7", "log": "Ensuring that the hash is unpredictable and well distributed.  We achieve this by using the same algorithm as the Perl version, but this implementation is being written from scratch for license compliance.", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/StringMap.java\n+++ b/gson/src/main/java/com/google/gson/internal/StringMap.java\n import java.util.Iterator;\n import java.util.Map;\n import java.util.NoSuchElementException;\n+import java.util.Random;\n import java.util.Set;\n \n /**\n     }\n   }\n \n+  private static final int seed = new Random().nextInt();\n   private static int hash(String key) {\n-    // TODO: use an unpredictable hash function\n-\n-    int h = 0;\n-    for (int i = 0; i < key.length(); i++) {\n-      h = 31 * h + key.charAt(i);\n+    // Ensuring that the hash is unpredictable and well distributed.\n+    //\n+    // Finding unpredictable hash functions is a bit of a dark art as we need to balance\n+    // good unpredictability (to avoid DoS) and good distribution (for performance).\n+    //\n+    // We achieve this by using the same algorithm as the Perl version, but this implementation\n+    // is being written from scratch by inder who has never seen the\n+    // Perl version (for license compliance).\n+    //\n+    // TODO: investigate http://code.google.com/p/cityhash/ and http://code.google.com/p/smhasher/\n+    // both of which may have better distribution and/or unpredictability.\n+    int h = seed;\n+    for (int i = 0; i < key.length(); ++i) {\n+      int h2 = h + key.charAt(i);\n+      int h3 = h2 + h2 << 10; // h2 * 1024\n+      h = h3 ^ (h3 >>> 6); // h3 / 64\n     }\n \n     /*\n     h ^= (h >>> 20) ^ (h >>> 12);\n     return h ^ (h >>> 7) ^ (h >>> 4);\n   }\n-}\n+}", "timestamp": 1331850475, "metainfo": ""}