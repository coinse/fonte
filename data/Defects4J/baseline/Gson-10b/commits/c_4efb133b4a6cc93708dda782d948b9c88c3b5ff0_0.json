{"sha": "4efb133b4a6cc93708dda782d948b9c88c3b5ff0", "log": "bling bling  Prefix internal classes with $ to prevent them from interfering with IDE's auto import functionality.", "commit": "\n--- a/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/CamelCaseSeparatorNamingPolicy.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n    *         is null or empty.\n    */\n   public CamelCaseSeparatorNamingPolicy(String separatorString) {\n-    Preconditions.checkNotNull(separatorString);\n-    Preconditions.checkArgument(!\"\".equals(separatorString));\n+    $Preconditions.checkNotNull(separatorString);\n+    $Preconditions.checkArgument(!\"\".equals(separatorString));\n     this.separatorString = separatorString;\n   }\n \n--- a/gson/src/main/java/com/google/gson/DefaultConstructorAllocator.java\n+++ b/gson/src/main/java/com/google/gson/DefaultConstructorAllocator.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Cache;\n-import com.google.gson.internal.LruCache;\n+import com.google.gson.internal.$Cache;\n+import com.google.gson.internal.$LruCache;\n \n import java.lang.reflect.Constructor;\n \n   private static final Constructor<Null> NULL_CONSTRUCTOR = createNullConstructor();\n \n   // Package private for testing purposes.\n-  final Cache<Class<?>, Constructor<?>> constructorCache;\n+  final $Cache<Class<?>, Constructor<?>> constructorCache;\n \n   public DefaultConstructorAllocator() {\n     this(200);\n   }\n \n   public DefaultConstructorAllocator(int cacheSize) {\n-    constructorCache = new LruCache<Class<?>, Constructor<?>>(cacheSize);\n+    constructorCache = new $LruCache<Class<?>, Constructor<?>>(cacheSize);\n   }\n \n   private static final Constructor<Null> createNullConstructor() {\n--- a/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/DefaultTypeAdapters.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Types;\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n       JsonArray array = new JsonArray();\n       Type childGenericType = null;\n       if (typeOfSrc instanceof ParameterizedType) {\n-        Class<?> rawTypeOfSrc = Types.getRawType(typeOfSrc);\n-        childGenericType = Types.getCollectionElementType(typeOfSrc, rawTypeOfSrc);\n+        Class<?> rawTypeOfSrc = $Types.getRawType(typeOfSrc);\n+        childGenericType = $Types.getCollectionElementType(typeOfSrc, rawTypeOfSrc);\n       }\n       for (Object child : src) {\n         if (child == null) {\n       // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n       // This handles cases where users are using their own subclass of Collection.\n       Collection collection = constructCollectionType(typeOfT, context);\n-      Type childType = Types.getCollectionElementType(typeOfT, Types.getRawType(typeOfT));\n+      Type childType = $Types.getCollectionElementType(typeOfT, $Types.getRawType(typeOfT));\n       for (JsonElement childElement : json.getAsJsonArray()) {\n         if (childElement == null || childElement.isJsonNull()) {\n           collection.add(null);\n     }\n \n     public T createInstance(Type type) {\n-      Class<?> rawType = Types.getRawType(type);\n+      Class<?> rawType = $Types.getRawType(type);\n       try {\n         T specificInstance = (T) allocator.newInstance(rawType);\n         return (specificInstance == null)\n--- a/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n+++ b/gson/src/main/java/com/google/gson/DelegatingJsonElementVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.io.IOException;\n \n   private final JsonElementVisitor delegate;\n \n   protected DelegatingJsonElementVisitor(JsonElementVisitor delegate) {\n-    this.delegate = Preconditions.checkNotNull(delegate);\n+    this.delegate = $Preconditions.checkNotNull(delegate);\n   }\n \n   public void endArray(JsonArray array) throws IOException {\n     delegate.startObject(object);\n   }\n \n-  public void visitArrayMember(JsonArray parent, JsonPrimitive member, \n+  public void visitArrayMember(JsonArray parent, JsonPrimitive member,\n       boolean isFirst) throws IOException {\n     delegate.visitArrayMember(parent, member, isFirst);\n   }\n \n-  public void visitArrayMember(JsonArray parent, JsonArray member, \n+  public void visitArrayMember(JsonArray parent, JsonArray member,\n       boolean isFirst) throws IOException {\n     delegate.visitArrayMember(parent, member, isFirst);\n   }\n \n-  public void visitArrayMember(JsonArray parent, JsonObject member, \n+  public void visitArrayMember(JsonArray parent, JsonObject member,\n       boolean isFirst) throws IOException {\n     delegate.visitArrayMember(parent, member, isFirst);\n   }\n \n-  public void visitObjectMember(JsonObject parent, String memberName, JsonPrimitive member, \n+  public void visitObjectMember(JsonObject parent, String memberName, JsonPrimitive member,\n       boolean isFirst) throws IOException {\n     delegate.visitObjectMember(parent, memberName, member, isFirst);\n   }\n \n-  public void visitObjectMember(JsonObject parent, String memberName, JsonArray member, \n+  public void visitObjectMember(JsonObject parent, String memberName, JsonArray member,\n       boolean isFirst) throws IOException {\n     delegate.visitObjectMember(parent, memberName, member, isFirst);\n   }\n \n-  public void visitObjectMember(JsonObject parent, String memberName, JsonObject member, \n+  public void visitObjectMember(JsonObject parent, String memberName, JsonObject member,\n       boolean isFirst) throws IOException {\n     delegate.visitObjectMember(parent, memberName, member, isFirst);\n   }\n \n-  public void visitNullObjectMember(JsonObject parent, String memberName, \n+  public void visitNullObjectMember(JsonObject parent, String memberName,\n       boolean isFirst) throws IOException {\n     delegate.visitNullObjectMember(parent, memberName, isFirst);\n   }\n--- a/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/DisjunctionExclusionStrategy.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.util.Collection;\n \n   private final Collection<ExclusionStrategy> strategies;\n \n   DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\n-    this.strategies = Preconditions.checkNotNull(strategies);\n+    this.strategies = $Preconditions.checkNotNull(strategies);\n   }\n \n   public boolean shouldSkipField(FieldAttributes f) {\n--- a/gson/src/main/java/com/google/gson/FieldAttributes.java\n+++ b/gson/src/main/java/com/google/gson/FieldAttributes.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Cache;\n-import com.google.gson.internal.LruCache;\n-import com.google.gson.internal.Pair;\n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Cache;\n+import com.google.gson.internal.$LruCache;\n+import com.google.gson.internal.$Pair;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n   private static final String MAX_CACHE_PROPERTY_NAME =\n       \"com.google.gson.annotation_cache_size_hint\";\n \n-  private static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n-      new LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n+  private static final $Cache<$Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\n+      new $LruCache<$Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n \n   private final Class<?> declaringClazz;\n   private final Field field;\n    * @param f the field to pull attributes from\n    */\n   FieldAttributes(final Class<?> declaringClazz, final Field f) {\n-    this.declaringClazz = Preconditions.checkNotNull(declaringClazz);\n+    this.declaringClazz = $Preconditions.checkNotNull(declaringClazz);\n     this.name = f.getName();\n     this.declaredType = f.getType();\n     this.isSynthetic = f.isSynthetic();\n    */\n   public Collection<Annotation> getAnnotations() {\n     if (annotations == null) {\n-      Pair<Class<?>, String> key = new Pair<Class<?>, String>(declaringClazz, name);\n+      $Pair<Class<?>, String> key = new $Pair<Class<?>, String>(declaringClazz, name);\n       annotations = ANNOTATION_CACHE.getElement(key);\n       if (annotations == null) {\n         annotations = Collections.unmodifiableCollection(\n--- a/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n+++ b/gson/src/main/java/com/google/gson/FieldNamingStrategy2Adapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n /**\n  * Adapts the old \"deprecated\" FieldNamingStrategy to the new {@link FieldNamingStrategy2}\n- * type. \n- * \n+ * type.\n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n   private final FieldNamingStrategy adaptee;\n \n   public FieldNamingStrategy2Adapter(FieldNamingStrategy adaptee) {\n-    this.adaptee = Preconditions.checkNotNull(adaptee);\n+    this.adaptee = $Preconditions.checkNotNull(adaptee);\n   }\n \n   public String translateName(FieldAttributes f) {\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.$Primitives;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n    */\n   public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\n     Object object = fromJson(json, (Type) classOfT);\n-    return Primitives.wrap(classOfT).cast(object);\n+    return $Primitives.wrap(classOfT).cast(object);\n   }\n \n   /**\n     JsonReader jsonReader = new JsonReader(json);\n     Object object = fromJson(jsonReader, classOfT);\n     assertFullConsumption(object, jsonReader);\n-    return Primitives.wrap(classOfT).cast(object);\n+    return $Primitives.wrap(classOfT).cast(object);\n   }\n \n   /**\n    */\n   public <T> T fromJson(JsonElement json, Class<T> classOfT) throws JsonSyntaxException {\n     Object object = fromJson(json, (Type) classOfT);\n-    return Primitives.wrap(classOfT).cast(object);\n+    return $Primitives.wrap(classOfT).cast(object);\n   }\n \n   /**\n       return null;\n     }\n     JsonDeserializationContext context = new JsonDeserializationContextDefault(\n-        new ObjectNavigator(deserializationExclusionStrategy), fieldNamingPolicy, \n+        new ObjectNavigator(deserializationExclusionStrategy), fieldNamingPolicy,\n         deserializers, objectConstructor);\n     T target = (T) context.deserialize(json, typeOfT);\n     return target;\n--- a/gson/src/main/java/com/google/gson/GsonBuilder.java\n+++ b/gson/src/main/java/com/google/gson/GsonBuilder.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.$Preconditions;\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.util.Arrays;\n import java.util.Set;\n \n import com.google.gson.DefaultTypeAdapters.DefaultDateTypeAdapter;\n-import com.google.gson.internal.Preconditions;\n \n /**\n  * <p>Use this builder to construct a {@link Gson} instance when you need to set configuration\n     this.serializeNulls = true;\n     return this;\n   }\n-  \n+\n   /**\n    * Enabling this feature will only change the serialized form if the map key is\n    * a complex type (i.e. non-primitive) in its <strong>serialized</strong> JSON\n    * <h3>Maps as JSON objects</h3>\n    * For this case, assume that a type adapter is registered to serialize and\n    * deserialize some {@code Point} class, which contains an x and y coordinate,\n-   * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would \n+   * to/from the JSON Primitive string value {@code \"(x,y)\"}. The Java map would\n    * then be serialized as a {@link JsonObject}.\n-   * \n+   *\n    * <p>Below is an example:\n    * <pre>  {@code\n    *   Gson gson = new GsonBuilder()\n    * {@code Point} class, but rather the default Gson serialization is applied.\n    * In this case, some {@code new Point(2,3)} would serialize as {@code\n    * {\"x\":2,\"y\":5}}.\n-   * \n+   *\n    * <p>Given the assumption above, a {@code Map<Point, String>} will be\n    * serialize as an array of arrays (can be viewed as an entry set of pairs).\n-   * \n+   *\n    * <p>Below is an example of serializing complex types as JSON arrays:\n    * <pre> {@code\n    *   Gson gson = new GsonBuilder()\n    *   original.put(new Point(8, 8), \"b\");\n    *   System.out.println(gson.toJson(original, type));\n    * }\n-   * \n+   *\n    * The JSON output would look as follows:\n    * <pre>   {@code\n    *   [\n    *     ]\n    *   ]\n    * }</pre>\n-   * \n+   *\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    * @since 1.7\n    */\n     deserializeExclusionStrategies.addAll(strategyList);\n     return this;\n   }\n-  \n+\n   /**\n    * Configures Gson to apply a set of exclusion strategies during either serialization or\n    * deserialization. Each of the {@code strategies} will be applied as a disjunction rule.\n    * @since 1.7\n    */\n   public GsonBuilder setExclusionStrategies(Mode mode, ExclusionStrategy... strategies) {\n-    Set<ExclusionStrategy> strategySet = \n-        (Preconditions.checkNotNull(mode) == Mode.SERIALIZE) \n+    Set<ExclusionStrategy> strategySet =\n+        ($Preconditions.checkNotNull(mode) == Mode.SERIALIZE)\n         ? serializeExclusionStrategies : deserializeExclusionStrategies;\n     strategySet.addAll(Arrays.asList(strategies));\n     return this;\n    * @return a reference to this {@code GsonBuilder} object to fulfill the \"Builder\" pattern\n    */\n   public GsonBuilder registerTypeAdapter(Type type, Object typeAdapter) {\n-    Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-        || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+    $Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n+            || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreator(type, (InstanceCreator<?>) typeAdapter);\n     }\n    * @since 1.7\n    */\n   public GsonBuilder registerTypeHierarchyAdapter(Class<?> baseType, Object typeAdapter) {\n-    Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n-      || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n+    $Preconditions.checkArgument(typeAdapter instanceof JsonSerializer<?>\n+            || typeAdapter instanceof JsonDeserializer<?> || typeAdapter instanceof InstanceCreator<?>);\n     if (typeAdapter instanceof InstanceCreator<?>) {\n       registerInstanceCreatorForTypeHierarchy(baseType, (InstanceCreator<?>) typeAdapter);\n     }\n       serializationStrategies.add(innerClassExclusionStrategy);\n     }\n     if (ignoreVersionsAfter != VersionConstants.IGNORE_VERSIONS) {\n-      VersionExclusionStrategy versionExclusionStrategy = \n+      VersionExclusionStrategy versionExclusionStrategy =\n           new VersionExclusionStrategy(ignoreVersionsAfter);\n       deserializationStrategies.add(versionExclusionStrategy);\n       serializationStrategies.add(versionExclusionStrategy);\n--- a/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonArrayDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Types;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n   @SuppressWarnings(\"unchecked\")\n   protected T constructTarget() {\n     if (!json.isJsonArray()) {\n-      throw new JsonParseException(\"Expecting array found: \" + json); \n+      throw new JsonParseException(\"Expecting array found: \" + json);\n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n-    if (Types.isArray(targetType)) {\n+    if ($Types.isArray(targetType)) {\n       // We know that we are getting back an array of the required type, so\n       // this typecasting is safe.\n-      return (T) objectConstructor.constructArray(Types.getArrayComponentType(targetType),\n+      return (T) objectConstructor.constructArray($Types.getArrayComponentType(targetType),\n           jsonArray.size());\n     }\n     // is a collection\n-    return (T) objectConstructor.construct(Types.getRawType(targetType));\n+    return (T) objectConstructor.construct($Types.getRawType(targetType));\n   }\n \n   public void visitArray(Object array, Type arrayType) {\n     if (!json.isJsonArray()) {\n-      throw new JsonParseException(\"Expecting array found: \" + json); \n+      throw new JsonParseException(\"Expecting array found: \" + json);\n     }\n     JsonArray jsonArray = json.getAsJsonArray();\n     for (int i = 0; i < jsonArray.size(); i++) {\n       if (jsonChild == null || jsonChild.isJsonNull()) {\n         child = null;\n       } else if (jsonChild instanceof JsonObject) {\n-        child = visitChildAsObject(Types.getArrayComponentType(arrayType), jsonChild);\n+        child = visitChildAsObject($Types.getArrayComponentType(arrayType), jsonChild);\n       } else if (jsonChild instanceof JsonArray) {\n-        child = visitChildAsArray(Types.getArrayComponentType(arrayType),\n+        child = visitChildAsArray($Types.getArrayComponentType(arrayType),\n             jsonChild.getAsJsonArray());\n       } else if (jsonChild instanceof JsonPrimitive) {\n-        child = visitChildAsObject(Types.getArrayComponentType(arrayType),\n+        child = visitChildAsObject($Types.getArrayComponentType(arrayType),\n             jsonChild.getAsJsonPrimitive());\n       } else {\n         throw new IllegalStateException();\n   }\n \n   public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) {\n-    throw new JsonParseException(\"Expecting array but found object field \" + f.getName() + \": \" \n+    throw new JsonParseException(\"Expecting array but found object field \" + f.getName() + \": \"\n         + obj);\n   }\n \n   public boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField, Object parent) {\n-    throw new JsonParseException(\"Expecting array but found field \" + f.getName() + \": \" \n+    throw new JsonParseException(\"Expecting array but found field \" + f.getName() + \": \"\n         + parent);\n   }\n \n--- a/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Pair;\n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Pair;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.reflect.Type;\n \n     this.fieldNamingPolicy = fieldNamingPolicy;\n     this.objectConstructor = objectConstructor;\n     this.deserializers = deserializers;\n-    this.json = Preconditions.checkNotNull(json);\n+    this.json = $Preconditions.checkNotNull(json);\n     this.context = context;\n     this.constructed = false;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   public final boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\n-    Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n+    $Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n     if (pair == null) {\n       return false;\n-    }    \n+    }\n     Object value = invokeCustomDeserializer(json, pair);\n     target = (T) value;\n     constructed = true;\n     return true;\n   }\n \n-  protected Object invokeCustomDeserializer(JsonElement element, \n-      Pair<JsonDeserializer<?>, ObjectTypePair> pair) {\n+  protected Object invokeCustomDeserializer(JsonElement element,\n+      $Pair<JsonDeserializer<?>, ObjectTypePair> pair) {\n     if (element == null || element.isJsonNull()) {\n       return null;\n     }\n--- a/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n+++ b/gson/src/main/java/com/google/gson/JsonDeserializerExceptionWrapper.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.reflect.Type;\n \n    * @throws IllegalArgumentException if {@code delegate} is {@code null}.\n    */\n   JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {\n-    this.delegate = Preconditions.checkNotNull(delegate);\n+    this.delegate = $Preconditions.checkNotNull(delegate);\n   }\n \n   public T deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n       throw new JsonParseException(errorMsg.toString(), e);\n     }\n   }\n-  \n+\n   @Override\n   public String toString() {\n     return delegate.toString();\n--- a/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n+++ b/gson/src/main/java/com/google/gson/JsonFieldNameValidator.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n  */\n class JsonFieldNameValidator {\n   private static final String COMMON_PATTERN = \"[a-zA-Z][a-zA-Z0-9\\\\ \\\\$_\\\\-]*$\";\n-  \n+\n   private static final Pattern JSON_FIELD_NAME_PATTERN =\n       Pattern.compile(\"(^\" + COMMON_PATTERN + \")|(^[\\\\$_]\" + COMMON_PATTERN + \")\");\n \n-  \n+\n   /**\n    * Performs validation on the JSON field name to ensure it is a valid field name.\n    *\n    * @throws IllegalArgumentException if the field name is an invalid JSON field name\n    */\n   public String validate(String fieldName) {\n-    Preconditions.checkNotNull(fieldName);\n-    Preconditions.checkArgument(!\"\".equals(fieldName.trim()));\n+    $Preconditions.checkNotNull(fieldName);\n+    $Preconditions.checkArgument(!\"\".equals(fieldName.trim()));\n \n     Matcher matcher = JSON_FIELD_NAME_PATTERN.matcher(fieldName);\n     if (!matcher.matches()) {\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.io.IOException;\n import java.util.LinkedHashMap;\n     if (value == null) {\n       value = JsonNull.createJsonNull();\n     }\n-    members.put(Preconditions.checkNotNull(property), value);\n+    members.put($Preconditions.checkNotNull(property), value);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonObjectDeserializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Pair;\n-import com.google.gson.internal.Primitives;\n+import com.google.gson.internal.$Pair;\n+import com.google.gson.internal.$Primitives;\n \n import java.lang.reflect.Type;\n \n   public void visitObjectField(FieldAttributes f, Type typeOfF, Object obj) {\n     try {\n       if (!json.isJsonObject()) {\n-        throw new JsonParseException(\"Expecting object found: \" + json); \n+        throw new JsonParseException(\"Expecting object found: \" + json);\n       }\n       JsonObject jsonObject = json.getAsJsonObject();\n       String fName = getFieldName(f);\n   public void visitArrayField(FieldAttributes f, Type typeOfF, Object obj) {\n     try {\n       if (!json.isJsonObject()) {\n-        throw new JsonParseException(\"Expecting object found: \" + json); \n+        throw new JsonParseException(\"Expecting object found: \" + json);\n       }\n       JsonObject jsonObject = json.getAsJsonObject();\n       String fName = getFieldName(f);\n     try {\n       String fName = getFieldName(f);\n       if (!json.isJsonObject()) {\n-        throw new JsonParseException(\"Expecting object found: \" + json); \n+        throw new JsonParseException(\"Expecting object found: \" + json);\n       }\n       JsonElement child = json.getAsJsonObject().get(fName);\n-      boolean isPrimitive = Primitives.isPrimitive(declaredTypeOfField);\n+      boolean isPrimitive = $Primitives.isPrimitive(declaredTypeOfField);\n       if (child == null) { // Child will be null if the field wasn't present in Json\n         return true;\n       } else if (child.isJsonNull()) {\n         return true;\n       }\n       ObjectTypePair objTypePair = new ObjectTypePair(null, declaredTypeOfField, false);\n-      Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n+      $Pair<JsonDeserializer<?>, ObjectTypePair> pair = objTypePair.getMatchingHandler(deserializers);\n       if (pair == null) {\n         return false;\n-      }      \n+      }\n       Object value = invokeCustomDeserializer(child, pair);\n       if (value != null || !isPrimitive) {\n         f.set(parent, value);\n--- a/gson/src/main/java/com/google/gson/JsonPrimitive.java\n+++ b/gson/src/main/java/com/google/gson/JsonPrimitive.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.io.IOException;\n import java.math.BigDecimal;\n       char c = ((Character) primitive).charValue();\n       this.value = String.valueOf(c);\n     } else {\n-      Preconditions.checkArgument(primitive instanceof Number\n-          || isPrimitiveOrString(primitive));\n+      $Preconditions.checkArgument(primitive instanceof Number\n+              || isPrimitiveOrString(primitive));\n       this.value = primitive;\n     }\n   }\n--- a/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n+++ b/gson/src/main/java/com/google/gson/JsonSerializationVisitor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Pair;\n-import com.google.gson.internal.Preconditions;\n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Pair;\n+import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n   public void visitArray(Object array, Type arrayType) {\n     assignToRoot(new JsonArray());\n     int length = Array.getLength(array);\n-    Type componentType = Types.getArrayComponentType(arrayType);\n+    Type componentType = $Types.getArrayComponentType(arrayType);\n     for (int i = 0; i < length; ++i) {\n       Object child = Array.get(array, i);\n       // we should not get more specific component type yet since it is possible\n    */\n   @SuppressWarnings(\"unchecked\")\n   private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\n-    Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\n+    $Pair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\n     if (pair == null) {\n       return null;\n     }\n   public boolean visitFieldUsingCustomHandler(\n       FieldAttributes f, Type declaredTypeOfField, Object parent) {\n     try {\n-      Preconditions.checkState(root.isJsonObject());\n+      $Preconditions.checkState(root.isJsonObject());\n       Object obj = f.get(parent);\n       if (obj == null) {\n         if (serializeNulls) {\n   }\n \n   private void assignToRoot(JsonElement newRoot) {\n-    root = Preconditions.checkNotNull(newRoot);\n+    root = $Preconditions.checkNotNull(newRoot);\n   }\n \n   private boolean isFieldNull(FieldAttributes f, Object obj) {\n--- a/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/MapTypeAdapter.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Types;\n \n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n     JsonObject map = new JsonObject();\n     Type childGenericType = null;\n     if (typeOfSrc instanceof ParameterizedType) {\n-      Class<?> rawTypeOfSrc = Types.getRawType(typeOfSrc);\n-      childGenericType = Types.getMapKeyAndValueTypes(typeOfSrc, rawTypeOfSrc)[1];\n+      Class<?> rawTypeOfSrc = $Types.getRawType(typeOfSrc);\n+      childGenericType = $Types.getMapKeyAndValueTypes(typeOfSrc, rawTypeOfSrc)[1];\n     }\n \n     for (Map.Entry entry : (Set<Map.Entry>) src.entrySet()) {\n     // Use ObjectConstructor to create instance instead of hard-coding a specific type.\n     // This handles cases where users are using their own subclass of Map.\n     Map<Object, Object> map = constructMapType(typeOfT, context);\n-    Type[] keyAndValueTypes = Types.getMapKeyAndValueTypes(typeOfT, Types.getRawType(typeOfT));\n+    Type[] keyAndValueTypes = $Types.getMapKeyAndValueTypes(typeOfT, $Types.getRawType(typeOfT));\n     for (Map.Entry<String, JsonElement> entry : json.getAsJsonObject().entrySet()) {\n       Object key = context.deserialize(new JsonPrimitive(entry.getKey()), keyAndValueTypes[0]);\n       Object value = context.deserialize(entry.getValue(), keyAndValueTypes[1]);\n--- a/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n+++ b/gson/src/main/java/com/google/gson/MappedObjectConstructor.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Types;\n-import com.google.gson.internal.UnsafeAllocator;\n+import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$UnsafeAllocator;\n \n import java.lang.reflect.Array;\n import java.lang.reflect.Type;\n  * @author Joel Leitch\n  */\n final class MappedObjectConstructor implements ObjectConstructor {\n-  private static final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n+  private static final $UnsafeAllocator unsafeAllocator = $UnsafeAllocator.create();\n   private static final DefaultConstructorAllocator defaultConstructorAllocator =\n       new DefaultConstructorAllocator(500);\n \n   }\n \n   public Object constructArray(Type type, int length) {\n-    return Array.newInstance(Types.getRawType(type), length);\n+    return Array.newInstance($Types.getRawType(type), length);\n   }\n \n   @SuppressWarnings({\"unchecked\", \"cast\"})\n   private <T> T constructWithAllocators(Type typeOfT) {\n     try {\n-      Class<T> clazz = (Class<T>) Types.getRawType(typeOfT);\n+      Class<T> clazz = (Class<T>) $Types.getRawType(typeOfT);\n       T obj = defaultConstructorAllocator.newInstance(clazz);\n       return (obj == null)\n           ? unsafeAllocator.newInstance(clazz)\n--- a/gson/src/main/java/com/google/gson/MemoryRefStack.java\n+++ b/gson/src/main/java/com/google/gson/MemoryRefStack.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.util.Stack;\n \n    * @return the object that was added\n    */\n   public ObjectTypePair push(ObjectTypePair obj) {\n-    Preconditions.checkNotNull(obj);\n+    $Preconditions.checkNotNull(obj);\n     return stack.push(obj);\n   }\n \n--- a/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n+++ b/gson/src/main/java/com/google/gson/ModifyFirstLetterNamingPolicy.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.annotation.Annotation;\n import java.lang.reflect.Type;\n    * @throws IllegalArgumentException if {@code modifier} is null\n    */\n   ModifyFirstLetterNamingPolicy(LetterModifier modifier) {\n-    this.letterModifier = Preconditions.checkNotNull(modifier);\n+    this.letterModifier = $Preconditions.checkNotNull(modifier);\n   }\n \n   @Override\n--- a/gson/src/main/java/com/google/gson/ObjectNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ObjectNavigator.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Primitives;\n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Primitives;\n \n import java.lang.reflect.Type;\n \n /**\n  * Provides ability to apply a visitor to an object and all of its fields\n  * recursively.\n- * \n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  */\n \n     /**\n      * This is called to visit an object using a custom handler\n-     * \n+     *\n      * @return true if a custom handler exists, false otherwise\n      */\n     public boolean visitUsingCustomHandler(ObjectTypePair objTypePair);\n         Object parent);\n \n     void visitPrimitive(Object primitive);\n-    \n+\n     /**\n      * Retrieve the current target\n      */\n    * @param objTypePair The object,type (fully genericized) being navigated\n    */\n   public void accept(ObjectTypePair objTypePair, Visitor visitor) {\n-    if (exclusionStrategy.shouldSkipClass(Types.getRawType(objTypePair.type))) {\n+    if (exclusionStrategy.shouldSkipClass($Types.getRawType(objTypePair.type))) {\n       return;\n     }\n     boolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\n       objTypePair.setObject(objectToVisit);\n       visitor.start(objTypePair);\n       try {\n-        if (Types.isArray(objTypePair.type)) {\n+        if ($Types.isArray(objTypePair.type)) {\n           visitor.visitArray(objectToVisit, objTypePair.type);\n         } else if (objTypePair.type == Object.class && isPrimitiveOrString(objectToVisit)) {\n           // TODO(Joel): this is only used for deserialization of \"primitives\"\n   private static boolean isPrimitiveOrString(Object objectToVisit) {\n     Class<?> realClazz = objectToVisit.getClass();\n     return realClazz == Object.class || realClazz == String.class\n-        || Primitives.unwrap(realClazz).isPrimitive();\n+        || $Primitives.unwrap(realClazz).isPrimitive();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ObjectTypePair.java\n+++ b/gson/src/main/java/com/google/gson/ObjectTypePair.java\n  */\n package com.google.gson;\n \n-import com.google.gson.internal.Pair;\n+import com.google.gson.internal.$Pair;\n \n import java.lang.reflect.Type;\n \n     return String.format(\"preserveType: %b, type: %s, obj: %s\", preserveType, type, obj);\n   }\n \n-  <HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(\n+  <HANDLER> $Pair<HANDLER, ObjectTypePair> getMatchingHandler(\n       ParameterizedTypeHandlerMap<HANDLER> handlers) {\n     HANDLER handler = null;\n     if (!preserveType && obj != null) {\n       // First try looking up the handler for the actual type\n-      ObjectTypePair moreSpecificType = toMoreSpecificType();    \n+      ObjectTypePair moreSpecificType = toMoreSpecificType();\n       handler = handlers.getHandlerFor(moreSpecificType.type);\n       if (handler != null) {\n-        return new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n+        return new $Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n       }\n     }\n     // Try the specified type\n     handler = handlers.getHandlerFor(type);\n-    return handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this);\n+    return handler == null ? null : new $Pair<HANDLER, ObjectTypePair>(handler, this);\n   }\n \n-  ObjectTypePair toMoreSpecificType() {    \n+  ObjectTypePair toMoreSpecificType() {\n     if (preserveType || obj == null) {\n       return this;\n     }\n     return new ObjectTypePair(obj, actualType, preserveType);\n   }\n \n-  Type getMoreSpecificType() {    \n+  Type getMoreSpecificType() {\n     if (preserveType || obj == null) {\n       return type;\n     }\n \n   // This takes care of situations where the field was declared as an Object, but the\n   // actual value contains something more specific. See Issue 54.\n-  // TODO (inder): This solution will not work if the field is of a generic type, but \n+  // TODO (inder): This solution will not work if the field is of a generic type, but\n   // the actual object is of a raw type (which is a sub-class of the generic type).\n   static Type getActualTypeIfMoreSpecific(Type type, Class<?> actualClass) {\n     if (type instanceof Class<?>) {\n       }\n       if (type == Object.class) {\n         type = actualClass;\n-      } \n+      }\n     }\n     return type;\n   }\n--- a/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n+++ b/gson/src/main/java/com/google/gson/ParameterizedTypeHandlerMap.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Pair;\n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Pair;\n+import com.google.gson.internal.$Types;\n \n import java.lang.reflect.Type;\n import java.util.ArrayList;\n /**\n  * A map that provides ability to associate handlers for a specific type or all\n  * of its sub-types\n- * \n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n- * \n+ *\n  * @param <T> The handler that will be looked up by type\n  */\n final class ParameterizedTypeHandlerMap<T> {\n   private static final Logger logger =\n       Logger.getLogger(ParameterizedTypeHandlerMap.class.getName());\n   private final Map<Type, T> map = new HashMap<Type, T>();\n-  private final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\n+  private final List<$Pair<Class<?>, T>> typeHierarchyList = new ArrayList<$Pair<Class<?>, T>>();\n   private boolean modifiable = true;\n \n   public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\n-    Pair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\n+    $Pair<Class<?>, T> pair = new $Pair<Class<?>, T>(typeOfT, value);\n     registerForTypeHierarchy(pair);\n   }\n \n-  public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\n+  public synchronized void registerForTypeHierarchy($Pair<Class<?>, T> pair) {\n     if (!modifiable) {\n       throw new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n     }\n \n   private int getIndexOfAnOverriddenHandler(Class<?> type) {\n     for (int i = typeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n+      $Pair<Class<?>, T> entry = typeHierarchyList.get(i);\n       if (type.isAssignableFrom(entry.first)) {\n         return i;\n       }\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n     // we want to register the handlers in the same order to preserve priority order\n     for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n+      $Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n       int index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\n       if (index < 0) {\n         registerForTypeHierarchy(entry);\n     // Quite important to traverse the typeHierarchyList from stack bottom first since\n     // we want to register the handlers in the same order to preserve priority order\n     for (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\n-      Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n+      $Pair<Class<?>, T> entry = other.typeHierarchyList.get(i);\n       registerForTypeHierarchy(entry);\n     }\n   }\n   public synchronized T getHandlerFor(Type type) {\n     T handler = map.get(type);\n     if (handler == null) {\n-      Class<?> rawClass = Types.getRawType(type);\n+      Class<?> rawClass = $Types.getRawType(type);\n       if (rawClass != type) {\n         handler = getHandlerFor(rawClass);\n       }\n   }\n \n   private T getHandlerForTypeHierarchy(Class<?> type) {\n-    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+    for ($Pair<Class<?>, T> entry : typeHierarchyList) {\n       if (entry.first.isAssignableFrom(type)) {\n         return entry.second;\n       }\n   public String toString() {\n     StringBuilder sb = new StringBuilder(\"{mapForTypeHierarchy:{\");\n     boolean first = true;\n-    for (Pair<Class<?>, T> entry : typeHierarchyList) {\n+    for ($Pair<Class<?>, T> entry : typeHierarchyList) {\n       if (first) {\n         first = false;\n       } else {\n   }\n \n   private String typeToString(Type type) {\n-    return Types.getRawType(type).getSimpleName();\n+    return $Types.getRawType(type).getSimpleName();\n   }\n }\n--- a/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n+++ b/gson/src/main/java/com/google/gson/ReflectingFieldNavigator.java\n package com.google.gson;\n \n import com.google.gson.ObjectNavigator.Visitor;\n-import com.google.gson.internal.LruCache;\n-import com.google.gson.internal.Preconditions;\n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$LruCache;\n+import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Preconditions;\n \n import java.lang.reflect.AccessibleObject;\n import java.lang.reflect.Field;\n \n /**\n  * Visits each of the fields of the specified class using reflection\n- * \n+ *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n  * @author Jesse Wilson\n  */\n final class ReflectingFieldNavigator {\n-  private static final LruCache<Type, List<Class<?>>> classCache =\n-    new LruCache<Type, List<Class<?>>>(500);\n-  private static final LruCache<Class<?>, Field[]> fieldsCache =\n-    new LruCache<Class<?>, Field[]>(500);\n+  private static final $LruCache<Type, List<Class<?>>> classCache =\n+    new $LruCache<Type, List<Class<?>>>(500);\n+  private static final $LruCache<Class<?>, Field[]> fieldsCache =\n+    new $LruCache<Class<?>, Field[]>(500);\n \n   private final ExclusionStrategy exclusionStrategy;\n \n    *   object.\n    */\n   ReflectingFieldNavigator(ExclusionStrategy exclusionStrategy) {\n-    this.exclusionStrategy = Preconditions.checkNotNull(exclusionStrategy);\n+    this.exclusionStrategy = $Preconditions.checkNotNull(exclusionStrategy);\n   }\n \n   /**\n   }\n \n   /**\n-   * Returns a list of classes corresponding to the inheritance of specified type \n+   * Returns a list of classes corresponding to the inheritance of specified type\n    */\n   private List<Class<?>> getInheritanceHierarchy(Type type) {\n     List<Class<?>> classes = classCache.get(type);\n     if (classes == null) {\n       classes = new ArrayList<Class<?>>();\n-      Class<?> topLevelClass = Types.getRawType(type);\n+      Class<?> topLevelClass = $Types.getRawType(type);\n       for (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\n         curr.getSuperclass()) {\n         if (!curr.isSynthetic()) {\n       boolean visitedWithCustomHandler =\n           visitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\n       if (!visitedWithCustomHandler) {\n-        if (Types.isArray(declaredTypeOfField)) {\n+        if ($Types.isArray(declaredTypeOfField)) {\n           visitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n         } else {\n           visitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n    * @return the type information for the field\n    */\n   public static Type getTypeInfoForField(Field f, Type typeDefiningF) {\n-    Class<?> rawType = Types.getRawType(typeDefiningF);\n+    Class<?> rawType = $Types.getRawType(typeDefiningF);\n     if (!f.getDeclaringClass().isAssignableFrom(rawType)) {\n       // this field is unrelated to the type; the user probably omitted type information\n       return f.getGenericType();\n     }\n-    return Types.resolve(typeDefiningF, rawType, f.getGenericType());\n+    return $Types.resolve(typeDefiningF, rawType, f.getGenericType());\n   }\n }\n--- a/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n+++ b/gson/src/main/java/com/google/gson/VersionExclusionStrategy.java\n \n import com.google.gson.annotations.Since;\n import com.google.gson.annotations.Until;\n-import com.google.gson.internal.Preconditions;\n+import com.google.gson.internal.$Preconditions;\n \n /**\n  * This strategy will exclude any files and/or class that are passed the\n   private final double version;\n \n   VersionExclusionStrategy(double version) {\n-    Preconditions.checkArgument(version >= 0.0D);\n+    $Preconditions.checkArgument(version >= 0.0D);\n     this.version = version;\n   }\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Cache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * Defines generic cache interface.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public interface $Cache<K, V> {\n+\n+  /**\n+   * Adds the new value object into the cache for the given key.  If the key already\n+   * exists, then this method will override the value for the key.\n+   *\n+   * @param key the key identifier for the {@code value} object\n+   * @param value the value object to store in the cache\n+   */\n+  void addElement(K key, V value);\n+\n+  /**\n+   * Retrieve the cached value for the given {@code key}.\n+   *\n+   * @param key the key identifying the value\n+   * @return the cached value for the given {@code key}\n+   */\n+  V getElement(K key);\n+\n+  /**\n+   * Removes the value from the cache for the given key.\n+   *\n+   * @param key the key identifying the value to remove\n+   * @return the value for the given {@code key}\n+   */\n+  V removeElement(K key);\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$LruCache.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * An implementation of the {@link $Cache} interface that evict objects from the cache using an\n+ * LRU (least recently used) algorithm.  Object start getting evicted from the cache once the\n+ * {@code maxCapacity} is reached.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class $LruCache<K, V> extends LinkedHashMap<K, V> implements $Cache<K, V> {\n+  private static final long serialVersionUID = 1L;\n+\n+  private final int maxCapacity;\n+\n+  public $LruCache(int maxCapacity) {\n+    super(maxCapacity, 0.7F, true);\n+    this.maxCapacity = maxCapacity;\n+  }\n+\n+  public synchronized void addElement(K key, V value) {\n+    put(key, value);\n+  }\n+\n+  public synchronized V getElement(K key) {\n+    return get(key);\n+  }\n+\n+  public synchronized V removeElement(K key) {\n+    return remove(key);\n+  }\n+\n+  @Override\n+  protected boolean removeEldestEntry(Map.Entry<K, V> entry) {\n+    return size() > maxCapacity;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Pair.java\n+/*\n+ * Copyright (C) 2009 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * A simple object that holds onto a pair of object references, first and second.\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ *\n+ * @param <FIRST>\n+ * @param <SECOND>\n+ */\n+public final class $Pair<FIRST, SECOND> {\n+  public final FIRST first;\n+  public final SECOND second;\n+\n+  public $Pair(FIRST first, SECOND second) {\n+    this.first = first;\n+    this.second = second;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 17 * ((first != null) ? first.hashCode() : 0)\n+        + 17 * ((second != null) ? second.hashCode() : 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof $Pair<?, ?>)) {\n+      return false;\n+    }\n+\n+    $Pair<?, ?> that = ($Pair<?, ?>) o;\n+    return equal(this.first, that.first) && equal(this.second, that.second);\n+  }\n+\n+  private static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"{%s,%s}\", first, second);\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Preconditions.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+/**\n+ * A simple utility class used to check method Preconditions.\n+ *\n+ * <pre>\n+ * public long divideBy(long value) {\n+ *   Preconditions.checkArgument(value != 0);\n+ *   return this.value / value;\n+ * }\n+ * </pre>\n+ *\n+ * @author Inderjeet Singh\n+ * @author Joel Leitch\n+ */\n+public final class $Preconditions {\n+  public static <T> T checkNotNull(T obj) {\n+    if (obj == null) {\n+      throw new NullPointerException();\n+    }\n+    return obj;\n+  }\n+\n+  public static void checkArgument(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalArgumentException();\n+    }\n+  }\n+\n+  public static void checkState(boolean condition) {\n+    if (!condition) {\n+      throw new IllegalStateException();\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Primitives.java\n+/*\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+\n+import java.lang.reflect.Type;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Contains static utility methods pertaining to primitive types and their\n+ * corresponding wrapper types.\n+ *\n+ * @author Kevin Bourrillion\n+ */\n+public final class $Primitives {\n+  private $Primitives() {}\n+\n+  /** A map from primitive types to their corresponding wrapper types. */\n+  private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n+\n+  /** A map from wrapper types to their corresponding primitive types. */\n+  private static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n+\n+  // Sad that we can't use a BiMap. :(\n+\n+  static {\n+    Map<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\n+    Map<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n+\n+    add(primToWrap, wrapToPrim, boolean.class, Boolean.class);\n+    add(primToWrap, wrapToPrim, byte.class, Byte.class);\n+    add(primToWrap, wrapToPrim, char.class, Character.class);\n+    add(primToWrap, wrapToPrim, double.class, Double.class);\n+    add(primToWrap, wrapToPrim, float.class, Float.class);\n+    add(primToWrap, wrapToPrim, int.class, Integer.class);\n+    add(primToWrap, wrapToPrim, long.class, Long.class);\n+    add(primToWrap, wrapToPrim, short.class, Short.class);\n+    add(primToWrap, wrapToPrim, void.class, Void.class);\n+\n+    PRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\n+    WRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n+  }\n+\n+  private static void add(Map<Class<?>, Class<?>> forward,\n+      Map<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\n+    forward.put(key, value);\n+    backward.put(value, key);\n+  }\n+\n+  /**\n+   * Returns true if this type is a primitive.\n+   */\n+  public static boolean isPrimitive(Type type) {\n+    return PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n+  }\n+\n+  /**\n+   * Returns {@code true} if {@code type} is one of the nine\n+   * primitive-wrapper types, such as {@link Integer}.\n+   *\n+   * @see Class#isPrimitive\n+   */\n+  public static boolean isWrapperType(Class<?> type) {\n+    return WRAPPER_TO_PRIMITIVE_TYPE.containsKey(\n+        $Preconditions.checkNotNull(type));\n+  }\n+\n+  /**\n+   * Returns the corresponding wrapper type of {@code type} if it is a primitive\n+   * type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     wrap(int.class) == Integer.class\n+   *     wrap(Integer.class) == Integer.class\n+   *     wrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> wrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n+        $Preconditions.checkNotNull(type));\n+    return (wrapped == null) ? type : wrapped;\n+  }\n+\n+  /**\n+   * Returns the corresponding primitive type of {@code type} if it is a\n+   * wrapper type; otherwise returns {@code type} itself. Idempotent.\n+   * <pre>\n+   *     unwrap(Integer.class) == int.class\n+   *     unwrap(int.class) == int.class\n+   *     unwrap(String.class) == String.class\n+   * </pre>\n+   */\n+  public static <T> Class<T> unwrap(Class<T> type) {\n+    // cast is safe: long.class and Long.class are both of type Class<Long>\n+    @SuppressWarnings(\"unchecked\")\n+    Class<T> unwrapped = (Class<T>) WRAPPER_TO_PRIMITIVE_TYPE.get(\n+        $Preconditions.checkNotNull(type));\n+    return (unwrapped == null) ? type : unwrapped;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$Types.java\n+/**\n+ * Copyright (C) 2008 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import static com.google.gson.internal.$Preconditions.checkArgument;\n+import static com.google.gson.internal.$Preconditions.checkNotNull;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.GenericDeclaration;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.lang.reflect.WildcardType;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Properties;\n+\n+/**\n+ * Static methods for working with types.\n+ *\n+ * @author Bob Lee\n+ * @author Jesse Wilson\n+ */\n+public final class $Types {\n+  static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\n+\n+  private $Types() {}\n+\n+  /**\n+   * Returns a new parameterized type, applying {@code typeArguments} to\n+   * {@code rawType} and enclosed by {@code ownerType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} parameterized type.\n+   */\n+  public static ParameterizedType newParameterizedTypeWithOwner(\n+      Type ownerType, Type rawType, Type... typeArguments) {\n+    return new ParameterizedTypeImpl(ownerType, rawType, typeArguments);\n+  }\n+\n+  /**\n+   * Returns an array type whose elements are all instances of\n+   * {@code componentType}.\n+   *\n+   * @return a {@link java.io.Serializable serializable} generic array type.\n+   */\n+  public static GenericArrayType arrayOf(Type componentType) {\n+    return new GenericArrayTypeImpl(componentType);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown type that extends {@code bound}.\n+   * For example, if {@code bound} is {@code CharSequence.class}, this returns\n+   * {@code ? extends CharSequence}. If {@code bound} is {@code Object.class},\n+   * this returns {@code ?}, which is shorthand for {@code ? extends Object}.\n+   */\n+  public static WildcardType subtypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { bound }, EMPTY_TYPE_ARRAY);\n+  }\n+\n+  /**\n+   * Returns a type that represents an unknown supertype of {@code bound}. For\n+   * example, if {@code bound} is {@code String.class}, this returns {@code ?\n+   * super String}.\n+   */\n+  public static WildcardType supertypeOf(Type bound) {\n+    return new WildcardTypeImpl(new Type[] { Object.class }, new Type[] { bound });\n+  }\n+\n+  /**\n+   * Returns a type that is functionally equal but not necessarily equal\n+   * according to {@link Object#equals(Object) Object.equals()}. The returned\n+   * type is {@link java.io.Serializable}.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static Type canonicalize(Type type) {\n+    if (type instanceof Class) {\n+      Class<?> c = (Class<?>) type;\n+      return c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType p = (ParameterizedType) type;\n+      return new ParameterizedTypeImpl(p.getOwnerType(),\n+          p.getRawType(), p.getActualTypeArguments());\n+\n+    } else if (type instanceof GenericArrayType) {\n+      GenericArrayType g = (GenericArrayType) type;\n+      return new GenericArrayTypeImpl(g.getGenericComponentType());\n+\n+    } else if (type instanceof WildcardType) {\n+      WildcardType w = (WildcardType) type;\n+      return new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n+\n+    } else {\n+      // type is either serializable as-is or unsupported\n+      return type;\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Class<?> getRawType(Type type) {\n+    if (type instanceof Class<?>) {\n+      // type is a normal class.\n+      return (Class<?>) type;\n+\n+    } else if (type instanceof ParameterizedType) {\n+      ParameterizedType parameterizedType = (ParameterizedType) type;\n+\n+      // I'm not exactly sure why getRawType() returns Type instead of Class.\n+      // Neal isn't either but suspects some pathological case related\n+      // to nested classes exists.\n+      Type rawType = parameterizedType.getRawType();\n+      checkArgument(rawType instanceof Class);\n+      return (Class<?>) rawType;\n+\n+    } else if (type instanceof GenericArrayType) {\n+      Type componentType = ((GenericArrayType)type).getGenericComponentType();\n+      return Array.newInstance(getRawType(componentType), 0).getClass();\n+\n+    } else if (type instanceof TypeVariable) {\n+      // we could use the variable's bounds, but that won't work if there are multiple.\n+      // having a raw type that's more general than necessary is okay\n+      return Object.class;\n+\n+    } else if (type instanceof WildcardType) {\n+      return getRawType(((WildcardType) type).getUpperBounds()[0]);\n+\n+    } else {\n+      String className = type == null ? \"null\" : type.getClass().getName();\n+      throw new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+          + \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n+    }\n+  }\n+\n+  static boolean equal(Object a, Object b) {\n+    return a == b || (a != null && a.equals(b));\n+  }\n+\n+  /**\n+   * Returns true if {@code a} and {@code b} are equal.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static boolean equals(Type a, Type b) {\n+    if (a == b) {\n+      // also handles (a == null && b == null)\n+      return true;\n+\n+    } else if (a instanceof Class) {\n+      // Class already specifies equals().\n+      return a.equals(b);\n+\n+    } else if (a instanceof ParameterizedType) {\n+      if (!(b instanceof ParameterizedType)) {\n+        return false;\n+      }\n+\n+      // TODO: save a .clone() call\n+      ParameterizedType pa = (ParameterizedType) a;\n+      ParameterizedType pb = (ParameterizedType) b;\n+      return equal(pa.getOwnerType(), pb.getOwnerType())\n+          && pa.getRawType().equals(pb.getRawType())\n+          && Arrays.equals(pa.getActualTypeArguments(), pb.getActualTypeArguments());\n+\n+    } else if (a instanceof GenericArrayType) {\n+      if (!(b instanceof GenericArrayType)) {\n+        return false;\n+      }\n+\n+      GenericArrayType ga = (GenericArrayType) a;\n+      GenericArrayType gb = (GenericArrayType) b;\n+      return equals(ga.getGenericComponentType(), gb.getGenericComponentType());\n+\n+    } else if (a instanceof WildcardType) {\n+      if (!(b instanceof WildcardType)) {\n+        return false;\n+      }\n+\n+      WildcardType wa = (WildcardType) a;\n+      WildcardType wb = (WildcardType) b;\n+      return Arrays.equals(wa.getUpperBounds(), wb.getUpperBounds())\n+          && Arrays.equals(wa.getLowerBounds(), wb.getLowerBounds());\n+\n+    } else if (a instanceof TypeVariable) {\n+      if (!(b instanceof TypeVariable)) {\n+        return false;\n+      }\n+      TypeVariable<?> va = (TypeVariable<?>) a;\n+      TypeVariable<?> vb = (TypeVariable<?>) b;\n+      return va.getGenericDeclaration() == vb.getGenericDeclaration()\n+          && va.getName().equals(vb.getName());\n+\n+    } else {\n+      // This isn't a type we support. Could be a generic array type, wildcard type, etc.\n+      return false;\n+    }\n+  }\n+\n+  private static int hashCodeOrZero(Object o) {\n+    return o != null ? o.hashCode() : 0;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static String typeToString(Type type) {\n+    return type instanceof Class ? ((Class<?>) type).getName() : type.toString();\n+  }\n+\n+  /**\n+   * Returns the generic supertype for {@code supertype}. For example, given a class {@code\n+   * IntegerSet}, the result for when supertype is {@code Set.class} is {@code Set<Integer>} and the\n+   * result when the supertype is {@code Collection.class} is {@code Collection<Integer>}.\n+   */\n+  static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\n+    if (toResolve == rawType) {\n+      return context;\n+    }\n+\n+    // we skip searching through interfaces if unknown is an interface\n+    if (toResolve.isInterface()) {\n+      Class<?>[] interfaces = rawType.getInterfaces();\n+      for (int i = 0, length = interfaces.length; i < length; i++) {\n+        if (interfaces[i] == toResolve) {\n+          return rawType.getGenericInterfaces()[i];\n+        } else if (toResolve.isAssignableFrom(interfaces[i])) {\n+          return getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n+        }\n+      }\n+    }\n+\n+    // check our supertypes\n+    if (!rawType.isInterface()) {\n+      while (rawType != Object.class) {\n+        Class<?> rawSupertype = rawType.getSuperclass();\n+        if (rawSupertype == toResolve) {\n+          return rawType.getGenericSuperclass();\n+        } else if (toResolve.isAssignableFrom(rawSupertype)) {\n+          return getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n+        }\n+        rawType = rawSupertype;\n+      }\n+    }\n+\n+    // we can't resolve this further\n+    return toResolve;\n+  }\n+\n+  /**\n+   * Returns the generic form of {@code supertype}. For example, if this is {@code\n+   * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code\n+   * Iterable.class}.\n+   *\n+   * @param supertype a superclass of, or interface implemented by, this.\n+   */\n+  static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n+    checkArgument(supertype.isAssignableFrom(contextRawType));\n+    return resolve(context, contextRawType,\n+        $Types.getGenericSupertype(context, contextRawType, supertype));\n+  }\n+\n+  /**\n+   * Returns true if this type is an array.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  public static boolean isArray(Type type) {\n+    return type instanceof GenericArrayType\n+        || (type instanceof Class && ((Class<?>) type).isArray());\n+  }\n+\n+  /**\n+   * Returns the component type of this array type.\n+   * @throws ClassCastException if this type is not an array.\n+   */\n+  public static Type getArrayComponentType(Type array) {\n+    return array instanceof GenericArrayType\n+        ? ((GenericArrayType) array).getGenericComponentType()\n+        : ((Class<?>) array).getComponentType();\n+  }\n+\n+  /**\n+   * Returns the element type of this collection type.\n+   * @throws IllegalArgumentException if this type is not a collection.\n+   */\n+  public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\n+    Type collectionType = getSupertype(context, contextRawType, Collection.class);\n+    return ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n+  }\n+\n+  /**\n+   * Returns a two element array containing this map's key and value types in\n+   * positions 0 and 1 respectively.\n+   */\n+  public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n+    /*\n+     * Work around a problem with the declaration of java.util.Properties. That\n+     * class should extend Hashtable<String, String>, but it's declared to\n+     * extend Hashtable<Object, Object>.\n+     */\n+    if (context == Properties.class) {\n+      return new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n+    }\n+\n+    Type mapType = getSupertype(context, contextRawType, Map.class);\n+    ParameterizedType mapParameterizedType = (ParameterizedType) mapType;\n+    return mapParameterizedType.getActualTypeArguments();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\n+    // this implementation is made a little more complicated in an attempt to avoid object-creation\n+    while (true) {\n+      if (toResolve instanceof TypeVariable) {\n+        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n+        if (toResolve == typeVariable) {\n+          return toResolve;\n+        }\n+\n+      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n+        Class<?> original = (Class<?>) toResolve;\n+        Type componentType = original.getComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof GenericArrayType) {\n+        GenericArrayType original = (GenericArrayType) toResolve;\n+        Type componentType = original.getGenericComponentType();\n+        Type newComponentType = resolve(context, contextRawType, componentType);\n+        return componentType == newComponentType\n+            ? original\n+            : arrayOf(newComponentType);\n+\n+      } else if (toResolve instanceof ParameterizedType) {\n+        ParameterizedType original = (ParameterizedType) toResolve;\n+        Type ownerType = original.getOwnerType();\n+        Type newOwnerType = resolve(context, contextRawType, ownerType);\n+        boolean changed = newOwnerType != ownerType;\n+\n+        Type[] args = original.getActualTypeArguments();\n+        for (int t = 0, length = args.length; t < length; t++) {\n+          Type resolvedTypeArgument = resolve(context, contextRawType, args[t]);\n+          if (resolvedTypeArgument != args[t]) {\n+            if (!changed) {\n+              args = args.clone();\n+              changed = true;\n+            }\n+            args[t] = resolvedTypeArgument;\n+          }\n+        }\n+\n+        return changed\n+            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n+            : original;\n+\n+      } else if (toResolve instanceof WildcardType) {\n+        WildcardType original = (WildcardType) toResolve;\n+        Type[] originalLowerBound = original.getLowerBounds();\n+        Type[] originalUpperBound = original.getUpperBounds();\n+\n+        if (originalLowerBound.length == 1) {\n+          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0]);\n+          if (lowerBound != originalLowerBound[0]) {\n+            return supertypeOf(lowerBound);\n+          }\n+        } else if (originalUpperBound.length == 1) {\n+          Type upperBound = resolve(context, contextRawType, originalUpperBound[0]);\n+          if (upperBound != originalUpperBound[0]) {\n+            return subtypeOf(upperBound);\n+          }\n+        }\n+        return original;\n+\n+      } else {\n+        return toResolve;\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable unknown) {\n+    Class<?> declaredByRaw = declaringClassOf(unknown);\n+\n+    // we can't reduce this further\n+    if (declaredByRaw == null) {\n+      return unknown;\n+    }\n+\n+    Type declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\n+    if (declaredBy instanceof ParameterizedType) {\n+      int index = indexOf(declaredByRaw.getTypeParameters(), unknown);\n+      return ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n+    }\n+\n+    return unknown;\n+  }\n+\n+  private static int indexOf(Object[] array, Object toFind) {\n+    for (int i = 0; i < array.length; i++) {\n+      if (toFind.equals(array[i])) {\n+        return i;\n+      }\n+    }\n+    throw new NoSuchElementException();\n+  }\n+\n+  /**\n+   * Returns the declaring class of {@code typeVariable}, or {@code null} if it was not declared by\n+   * a class.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  private static Class<?> declaringClassOf(TypeVariable typeVariable) {\n+    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\n+    return genericDeclaration instanceof Class\n+        ? (Class<?>) genericDeclaration\n+        : null;\n+  }\n+\n+  private static void checkNotPrimitive(Type type) {\n+    checkArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n+  }\n+\n+  private static class ParameterizedTypeImpl implements ParameterizedType, Serializable {\n+    private final Type ownerType;\n+    private final Type rawType;\n+    private final Type[] typeArguments;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n+      // require an owner type if the raw type needs it\n+      if (rawType instanceof Class<?>) {\n+        Class rawTypeAsClass = (Class) rawType;\n+        checkArgument(ownerType != null || rawTypeAsClass.getEnclosingClass() == null);\n+        checkArgument(ownerType == null || rawTypeAsClass.getEnclosingClass() != null);\n+      }\n+\n+      this.ownerType = ownerType == null ? null : canonicalize(ownerType);\n+      this.rawType = canonicalize(rawType);\n+      this.typeArguments = typeArguments.clone();\n+      for (int t = 0; t < this.typeArguments.length; t++) {\n+        checkNotNull(this.typeArguments[t]);\n+        checkNotPrimitive(this.typeArguments[t]);\n+        this.typeArguments[t] = canonicalize(this.typeArguments[t]);\n+      }\n+    }\n+\n+    public Type[] getActualTypeArguments() {\n+      return typeArguments.clone();\n+    }\n+\n+    public Type getRawType() {\n+      return rawType;\n+    }\n+\n+    public Type getOwnerType() {\n+      return ownerType;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof ParameterizedType\n+          && $Types.equals(this, (ParameterizedType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      return Arrays.hashCode(typeArguments)\n+          ^ rawType.hashCode()\n+          ^ hashCodeOrZero(ownerType);\n+    }\n+\n+    @Override public String toString() {\n+      StringBuilder stringBuilder = new StringBuilder(30 * (typeArguments.length + 1));\n+      stringBuilder.append(typeToString(rawType));\n+\n+      if (typeArguments.length == 0) {\n+        return stringBuilder.toString();\n+      }\n+\n+      stringBuilder.append(\"<\").append(typeToString(typeArguments[0]));\n+      for (int i = 1; i < typeArguments.length; i++) {\n+        stringBuilder.append(\", \").append(typeToString(typeArguments[i]));\n+      }\n+      return stringBuilder.append(\">\").toString();\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  private static class GenericArrayTypeImpl implements GenericArrayType, Serializable {\n+    private final Type componentType;\n+\n+    public GenericArrayTypeImpl(Type componentType) {\n+      this.componentType = canonicalize(componentType);\n+    }\n+\n+    public Type getGenericComponentType() {\n+      return componentType;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return o instanceof GenericArrayType\n+          && $Types.equals(this, (GenericArrayType) o);\n+    }\n+\n+    @Override public int hashCode() {\n+      return componentType.hashCode();\n+    }\n+\n+    @Override public String toString() {\n+      return typeToString(componentType) + \"[]\";\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+\n+  /**\n+   * The WildcardType interface supports multiple upper bounds and multiple\n+   * lower bounds. We only support what the Java 6 language needs - at most one\n+   * bound. If a lower bound is set, the upper bound must be Object.class.\n+   */\n+  private static class WildcardTypeImpl implements WildcardType, Serializable {\n+    private final Type upperBound;\n+    private final Type lowerBound;\n+\n+    public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\n+      checkArgument(lowerBounds.length <= 1);\n+      checkArgument(upperBounds.length == 1);\n+\n+      if (lowerBounds.length == 1) {\n+        checkNotNull(lowerBounds[0]);\n+        checkNotPrimitive(lowerBounds[0]);\n+        checkArgument(upperBounds[0] == Object.class);\n+        this.lowerBound = canonicalize(lowerBounds[0]);\n+        this.upperBound = Object.class;\n+\n+      } else {\n+        checkNotNull(upperBounds[0]);\n+        checkNotPrimitive(upperBounds[0]);\n+        this.lowerBound = null;\n+        this.upperBound = canonicalize(upperBounds[0]);\n+      }\n+    }\n+\n+    public Type[] getUpperBounds() {\n+      return new Type[] { upperBound };\n+    }\n+\n+    public Type[] getLowerBounds() {\n+      return lowerBound != null ? new Type[] { lowerBound } : EMPTY_TYPE_ARRAY;\n+    }\n+\n+    @Override public boolean equals(Object other) {\n+      return other instanceof WildcardType\n+          && $Types.equals(this, (WildcardType) other);\n+    }\n+\n+    @Override public int hashCode() {\n+      // this equals Arrays.hashCode(getLowerBounds()) ^ Arrays.hashCode(getUpperBounds());\n+      return (lowerBound != null ? 31 + lowerBound.hashCode() : 1)\n+          ^ (31 + upperBound.hashCode());\n+    }\n+\n+    @Override public String toString() {\n+      if (lowerBound != null) {\n+        return \"? super \" + typeToString(lowerBound);\n+      } else if (upperBound == Object.class) {\n+        return \"?\";\n+      } else {\n+        return \"? extends \" + typeToString(upperBound);\n+      }\n+    }\n+\n+    private static final long serialVersionUID = 0;\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/$UnsafeAllocator.java\n+/*\n+ * Copyright (C) 2011 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamClass;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Do sneaky things to allocate objects without invoking their constructors.\n+ *\n+ * @author Joel Leitch\n+ * @author Jesse Wilson\n+ */\n+public abstract class $UnsafeAllocator {\n+  public abstract <T> T newInstance(Class<T> c) throws Exception;\n+\n+  public static $UnsafeAllocator create() {\n+    // try JVM\n+    // public class Unsafe {\n+    //   public Object allocateInstance(Class<?> type);\n+    // }\n+    try {\n+      Class<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\n+      Field f = unsafeClass.getDeclaredField(\"theUnsafe\");\n+      f.setAccessible(true);\n+      final Object unsafe = f.get(null);\n+      final Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\n+      return new $UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) allocateInstance.invoke(unsafe, c);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvikvm, pre-gingerbread\n+    // public class ObjectInputStream {\n+    //   private static native Object newInstance(\n+    //     Class<?> instantiationClass, Class<?> constructorClass);\n+    // }\n+    try {\n+      final Method newInstance = ObjectInputStream.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, Class.class);\n+      newInstance.setAccessible(true);\n+      return new $UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, Object.class);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // try dalvivkm, post-gingerbread\n+    // public class ObjectStreamClass {\n+    //   private static native int getConstructorId(Class<?> c);\n+    //   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n+    // }\n+    try {\n+      Method getConstructorId = ObjectStreamClass.class\n+          .getDeclaredMethod(\"getConstructorId\", Class.class);\n+      getConstructorId.setAccessible(true);\n+      final int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\n+      final Method newInstance = ObjectStreamClass.class\n+          .getDeclaredMethod(\"newInstance\", Class.class, int.class);\n+      newInstance.setAccessible(true);\n+      return new $UnsafeAllocator() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T newInstance(Class<T> c) throws Exception {\n+          return (T) newInstance.invoke(null, c, constructorId);\n+        }\n+      };\n+    } catch (Exception ignored) {\n+    }\n+\n+    // give up\n+    return new $UnsafeAllocator() {\n+      @Override\n+      public <T> T newInstance(Class<T> c) {\n+        throw new UnsupportedOperationException(\"Cannot allocate \" + c);\n+      }\n+    };\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n+++ b/gson/src/main/java/com/google/gson/reflect/TypeToken.java\n \n package com.google.gson.reflect;\n \n-import com.google.gson.internal.Preconditions;\n-import com.google.gson.internal.Types;\n-\n+import com.google.gson.internal.$Types;\n+import com.google.gson.internal.$Preconditions;\n import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.Method;\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n import java.lang.reflect.TypeVariable;\n  *\n  * <p>This syntax cannot be used to create type literals that have wildcard\n  * parameters, such as {@code Class<?>} or {@code List<? extends CharSequence>}.\n- * Such type tokens must be constructed programatically, either by {@link\n- * Method#getGenericReturnType extracting types from members} or by using the\n- * {@link Types} factory class.\n  *\n  * @author Bob Lee\n  * @author Sven Mawson\n   @SuppressWarnings(\"unchecked\")\n   protected TypeToken() {\n     this.type = getSuperclassTypeParameter(getClass());\n-    this.rawType = (Class<? super T>) Types.getRawType(type);\n+    this.rawType = (Class<? super T>) $Types.getRawType(type);\n     this.hashCode = type.hashCode();\n   }\n \n    */\n   @SuppressWarnings(\"unchecked\")\n   TypeToken(Type type) {\n-    this.type = Types.canonicalize(Preconditions.checkNotNull(type));\n-    this.rawType = (Class<? super T>) Types.getRawType(this.type);\n+    this.type = $Types.canonicalize($Preconditions.checkNotNull(type));\n+    this.rawType = (Class<? super T>) $Types.getRawType(this.type);\n     this.hashCode = this.type.hashCode();\n   }\n \n   /**\n-   * Returns the type from super class's type parameter in {@link Types#canonicalize(java.lang.reflect.Type)\n+   * Returns the type from super class's type parameter in {@link $Types#canonicalize\n    * canonical form}.\n    */\n   @SuppressWarnings(\"unchecked\")\n       throw new RuntimeException(\"Missing type parameter.\");\n     }\n     ParameterizedType parameterized = (ParameterizedType) superclass;\n-    return Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n+    return $Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n   }\n \n   /**\n     }\n \n     if (type instanceof Class<?>) {\n-      return rawType.isAssignableFrom(Types.getRawType(from));\n+      return rawType.isAssignableFrom($Types.getRawType(from));\n     } else if (type instanceof ParameterizedType) {\n       return isAssignableFrom(from, (ParameterizedType) type,\n           new HashMap<String, Type>());\n     } else if (type instanceof GenericArrayType) {\n-      return rawType.isAssignableFrom(Types.getRawType(from))\n+      return rawType.isAssignableFrom($Types.getRawType(from))\n           && isAssignableFrom(from, (GenericArrayType) type);\n     } else {\n       throw buildUnexpectedTypeError(\n     }\n \n     // First figure out the class and any type information.\n-    Class<?> clazz = Types.getRawType(from);\n+    Class<?> clazz = $Types.getRawType(from);\n     ParameterizedType ptype = null;\n     if (from instanceof ParameterizedType) {\n       ptype = (ParameterizedType) from;\n \n   @Override public final boolean equals(Object o) {\n     return o instanceof TypeToken<?>\n-        && Types.equals(type, ((TypeToken<?>) o).type);\n+        && $Types.equals(type, ((TypeToken<?>) o).type);\n   }\n \n   @Override public final String toString() {\n-    return Types.typeToString(type);\n+    return $Types.typeToString(type);\n   }\n \n   /**\n--- a/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/GenericArrayTypeTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Types;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n import java.util.List;\n \n /**\n- * Unit tests for the {@code GenericArrayType}s created by the {@link Types} class.\n+ * Unit tests for the {@code GenericArrayType}s created by the {@link $Types} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    ourType = Types.arrayOf(Types.newParameterizedTypeWithOwner(null, List.class, String.class));\n+    ourType = $Types.arrayOf($Types.newParameterizedTypeWithOwner(null, List.class, String.class));\n   }\n \n   public void testOurTypeFunctionality() throws Exception {\n     Type parameterizedType = new TypeToken<List<String>>() {}.getType();\n     Type genericArrayType = new TypeToken<List<String>[]>() {}.getType();\n-    \n+\n     assertEquals(parameterizedType, ourType.getGenericComponentType());\n     assertEquals(genericArrayType, ourType);\n     assertEquals(genericArrayType.hashCode(), ourType.hashCode());\n--- a/gson/src/test/java/com/google/gson/LruCacheTest.java\n+++ b/gson/src/test/java/com/google/gson/LruCacheTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Cache;\n-import com.google.gson.internal.LruCache;\n+import com.google.gson.internal.$Cache;\n+import com.google.gson.internal.$LruCache;\n \n import junit.framework.TestCase;\n \n /**\n- * Unit test for the {@link LruCache} class.\n+ * Unit test for the {@link $LruCache} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n public class LruCacheTest extends TestCase {\n \n   public void testCacheHitAndMiss() throws Exception {\n-    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n-    \n+    $Cache<String, Integer> cache = new $LruCache<String, Integer>(3);\n+\n     String key = \"key1\";\n     assertNull(cache.getElement(key));\n     cache.addElement(key, 1);\n     assertEquals(1, cache.getElement(key).intValue());\n-    \n+\n     String key2 = \"key2\";\n     cache.addElement(key2, 2);\n     assertEquals(1, cache.getElement(key).intValue());\n     assertEquals(2, cache.getElement(key2).intValue());\n   }\n-  \n+\n   public void testCacheKeyOverwrite() throws Exception {\n-    Cache<String, Integer> cache = new LruCache<String, Integer>(3);\n-    \n+    $Cache<String, Integer> cache = new $LruCache<String, Integer>(3);\n+\n     String key = \"key1\";\n     assertNull(cache.getElement(key));\n     cache.addElement(key, 1);\n     assertEquals(1, cache.getElement(key).intValue());\n-    \n+\n     cache.addElement(key, 5);\n     assertEquals(5, cache.getElement(key).intValue());\n   }\n-  \n+\n   public void testCacheEviction() throws Exception {\n-    Cache<String, Integer> cache = new LruCache<String, Integer>(5);\n+    $Cache<String, Integer> cache = new $LruCache<String, Integer>(5);\n \n     cache.addElement(\"key1\", 1);\n     cache.addElement(\"key2\", 2);\n--- a/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n+++ b/gson/src/test/java/com/google/gson/ParameterizedTypeTest.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Types;\n import com.google.gson.reflect.TypeToken;\n \n import junit.framework.TestCase;\n import java.util.List;\n \n /**\n- * Unit tests for {@code ParamterizedType}s created by the {@link Types} class.\n+ * Unit tests for {@code ParamterizedType}s created by the {@link $Types} class.\n  *\n  * @author Inderjeet Singh\n  * @author Joel Leitch\n   @Override\n   protected void setUp() throws Exception {\n     super.setUp();\n-    ourType = Types.newParameterizedTypeWithOwner(null, List.class, String.class);\n+    ourType = $Types.newParameterizedTypeWithOwner(null, List.class, String.class);\n   }\n \n   public void testOurTypeFunctionality() throws Exception {\n--- a/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n+++ b/gson/src/test/java/com/google/gson/ParamterizedTypeFixtures.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.Primitives;\n-import com.google.gson.internal.Types;\n+import com.google.gson.internal.$Primitives;\n+import com.google.gson.internal.$Types;\n \n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n \n     private String getExpectedJson(Object obj) {\n       Class<?> clazz = obj.getClass();\n-      if (Primitives.isWrapperType(Primitives.wrap(clazz))) {\n+      if ($Primitives.isWrapperType($Primitives.wrap(clazz))) {\n         return obj.toString();\n       } else if (obj.getClass().equals(String.class)) {\n         return \"\\\"\" + obj.toString() + \"\\\"\";\n     @SuppressWarnings(\"unchecked\")\n     public static<T> String getExpectedJson(MyParameterizedType<T> obj) {\n       Class<T> clazz = (Class<T>) obj.value.getClass();\n-      boolean addQuotes = !clazz.isArray() && !Primitives.unwrap(clazz).isPrimitive();\n+      boolean addQuotes = !clazz.isArray() && !$Primitives.unwrap(clazz).isPrimitive();\n       StringBuilder sb = new StringBuilder(\"{\\\"\");\n       sb.append(obj.value.getClass().getSimpleName()).append(\"\\\":\");\n       if (addQuotes) {\n     public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,\n         JsonDeserializationContext context) throws JsonParseException {\n       Type genericClass = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];\n-      Class<?> rawType = Types.getRawType(genericClass);\n+      Class<?> rawType = $Types.getRawType(genericClass);\n       String className = rawType.getSimpleName();\n       T value = (T) json.getAsJsonObject().get(className).getAsObject();\n-      if (Primitives.isPrimitive(genericClass)) {\n+      if ($Primitives.isPrimitive(genericClass)) {\n         PrimitiveTypeAdapter typeAdapter = new PrimitiveTypeAdapter();\n         value = (T) typeAdapter.adaptType(value, rawType);\n       }\n--- a/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n+++ b/gson/src/test/java/com/google/gson/PrimitiveTypeAdapter.java\n \n package com.google.gson;\n \n+import com.google.gson.internal.$Primitives;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n \n-import com.google.gson.JsonParseException;\n-import com.google.gson.internal.Primitives;\n-\n /**\n  * Handles type conversion from some object to some primitive (or primitive\n  * wrapper instance).\n- * \n+ *\n  * @author Joel Leitch\n  */\n final class PrimitiveTypeAdapter {\n \n   @SuppressWarnings(\"unchecked\")\n   public <T> T adaptType(Object from, Class<T> to) {\n-    Class<?> aClass = Primitives.wrap(to);\n-    if (Primitives.isWrapperType(aClass)) {\n+    Class<?> aClass = $Primitives.wrap(to);\n+    if ($Primitives.isWrapperType(aClass)) {\n       if (aClass == Character.class) {\n         String value = from.toString();\n         if (value.length() == 1) {", "timestamp": 1301433866, "metainfo": ""}