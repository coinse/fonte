{"sha": "af4879dbb782bb13fd95e3b406a55d80272ddff3", "log": "Move interceptors from 'alpha' to 'extras'.  This makes the feature less risky to use! It now uses our TypeAdapterFactory infrastructure rather than relying on parallel infrastructure.", "commit": "\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/interceptors/Intercept.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.interceptors;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\n+/**\n+ * Use this annotation to indicate various interceptors for class instances after\n+ * they have been processed by Gson. For example, you can use it to validate an instance\n+ * after it has been deserialized from Json.\n+ * Here is an example of how this annotation is used:\n+ * <p>Here is an example of how this annotation is used:\n+ * <p><pre>\n+ * &#64Intercept(postDeserialize=UserValidator.class)\n+ * public class User {\n+ *   String name;\n+ *   String password;\n+ *   String emailAddress;\n+ * }\n+ *\n+ * public class UserValidator implements JsonPostDeserializer&lt;User&gt; {\n+ *   public void postDeserialize(User user) {\n+ *     // Do some checks on user\n+ *     if (user.name == null || user.password == null) {\n+ *       throw new JsonParseException(\"name and password are required fields.\");\n+ *     }\n+ *     if (user.emailAddress == null) {\n+ *       emailAddress = \"unknown\"; // assign a default value.\n+ *     }\n+ *   }\n+ * }\n+ * </pre></p>\n+ *\n+ * @author Inderjeet Singh\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(ElementType.TYPE)\n+public @interface Intercept {\n+\n+  /**\n+   * Specify the class that provides the methods that should be invoked after an instance\n+   * has been deserialized.\n+   */\n+  @SuppressWarnings(\"rawtypes\")\n+  public Class<? extends JsonPostDeserializer> postDeserialize();\n+}\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/interceptors/InterceptorFactory.java\n+package com.google.gson.interceptors;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+\n+/**\n+ * A type adapter factory that implements {@code @Intercept}.\n+ */\n+public final class InterceptorFactory implements TypeAdapterFactory {\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\n+    Intercept intercept = type.getRawType().getAnnotation(Intercept.class);\n+    if (intercept == null) {\n+      return null;\n+    }\n+\n+    TypeAdapter<T> delegate = gson.getDelegateAdapter(this, type);\n+    return new InterceptorAdapter<T>(delegate, intercept);\n+  }\n+\n+  static class InterceptorAdapter<T> extends TypeAdapter<T> {\n+    private final TypeAdapter<T> delegate;\n+    private final JsonPostDeserializer<T> postDeserializer;\n+\n+    @SuppressWarnings(\"unchecked\") // ?\n+    public InterceptorAdapter(TypeAdapter<T> delegate, Intercept intercept) {\n+      try {\n+        this.delegate = delegate;\n+        this.postDeserializer = intercept.postDeserialize().newInstance();\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    @Override public void write(JsonWriter out, T value) throws IOException {\n+      delegate.write(out, value);\n+    }\n+\n+    @Override public T read(JsonReader in) throws IOException {\n+      T result = delegate.read(in);\n+      postDeserializer.postDeserialize(result);\n+      return result;\n+    }\n+  }\n+}\n--- /dev/null\n+++ b/extras/src/main/java/com/google/gson/interceptors/JsonPostDeserializer.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.interceptors;\n+\n+import com.google.gson.InstanceCreator;\n+\n+/**\n+ * This interface is implemented by a class that wishes to inspect or modify an object\n+ * after it has been deserialized. You must define a no-args constructor or register an\n+ * {@link InstanceCreator} for such a class.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public interface JsonPostDeserializer<T> {\n+\n+  /**\n+   * This method is called by Gson after the object has been deserialized from Json.\n+   */\n+  public void postDeserialize(T object);\n+}\n--- /dev/null\n+++ b/extras/src/test/java/com/google/gson/interceptors/InterceptorTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.interceptors;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.reflect.TypeToken;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Unit tests for {@link Intercept} and {@link JsonPostDeserializer}.\n+ *\n+ * @author Inderjeet Singh\n+ */\n+public final class InterceptorTest extends TestCase {\n+\n+  private Gson gson;\n+\n+  @Override\n+  public void setUp() throws Exception {\n+    super.setUp();\n+    this.gson = new GsonBuilder()\n+        .registerTypeAdapterFactory(new InterceptorFactory())\n+        .enableComplexMapKeySerialization()\n+        .create();\n+  }\n+\n+  public void testExceptionsPropagated() {\n+    try {\n+      gson.fromJson(\"{}\", User.class);\n+      fail();\n+    } catch (JsonParseException expected) {}\n+  }\n+\n+  public void testTopLevelClass() {\n+    User user = gson.fromJson(\"{name:'bob',password:'pwd'}\", User.class);\n+    assertEquals(User.DEFAULT_EMAIL, user.email);\n+  }\n+\n+  public void testList() {\n+    List<User> list = gson.fromJson(\"[{name:'bob',password:'pwd'}]\", new TypeToken<List<User>>(){}.getType());\n+    User user = list.get(0);\n+    assertEquals(User.DEFAULT_EMAIL, user.email);\n+  }\n+\n+  public void testCollection() {\n+    Collection<User> list = gson.fromJson(\"[{name:'bob',password:'pwd'}]\", new TypeToken<Collection<User>>(){}.getType());\n+    User user = list.iterator().next();\n+    assertEquals(User.DEFAULT_EMAIL, user.email);\n+  }\n+\n+  public void testMapKeyAndValues() {\n+    Type mapType = new TypeToken<Map<User, Address>>(){}.getType();\n+    try {\n+      gson.fromJson(\"[[{name:'bob',password:'pwd'},{}]]\", mapType);\n+      fail();\n+    } catch (JsonSyntaxException expected) {}\n+    Map<User, Address> map = gson.fromJson(\"[[{name:'bob',password:'pwd'},{city:'Mountain View',state:'CA',zip:'94043'}]]\",\n+        mapType);\n+    Entry<User, Address> entry = map.entrySet().iterator().next();\n+    assertEquals(User.DEFAULT_EMAIL, entry.getKey().email);\n+    assertEquals(Address.DEFAULT_FIRST_LINE, entry.getValue().firstLine);\n+  }\n+\n+  public void testField() {\n+    UserGroup userGroup = gson.fromJson(\"{user:{name:'bob',password:'pwd'}}\", UserGroup.class);\n+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\n+  }\n+\n+  public void testCustomTypeAdapter() {\n+    Gson gson = new GsonBuilder()\n+        .registerTypeAdapter(User.class, new TypeAdapter<User>() {\n+          @Override public void write(JsonWriter out, User value) throws IOException {\n+            throw new UnsupportedOperationException();\n+          }\n+\n+          @Override public User read(JsonReader in) throws IOException {\n+            in.beginObject();\n+            in.nextName();\n+            String name = in.nextString();\n+            in.nextName();\n+            String password = in.nextString();\n+            in.endObject();\n+            return new User(name, password);\n+          }\n+        })\n+        .registerTypeAdapterFactory(new InterceptorFactory())\n+        .create();\n+    UserGroup userGroup = gson.fromJson(\"{user:{name:'bob',password:'pwd'}}\", UserGroup.class);\n+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\n+  }\n+\n+  public void testDirectInvocationOfTypeAdapter() throws Exception {\n+    TypeAdapter<UserGroup> adapter = gson.getAdapter(UserGroup.class);\n+    UserGroup userGroup = adapter.fromJson(\"{\\\"user\\\":{\\\"name\\\":\\\"bob\\\",\\\"password\\\":\\\"pwd\\\"}}\");\n+    assertEquals(User.DEFAULT_EMAIL, userGroup.user.email);\n+  }\n+\n+  @SuppressWarnings(\"unused\")\n+  private static final class UserGroup {\n+    User user;\n+    String city;\n+  }\n+\n+  @Intercept(postDeserialize = UserValidator.class)\n+  @SuppressWarnings(\"unused\")\n+  private static final class User {\n+    static final String DEFAULT_EMAIL = \"invalid@invalid.com\";\n+    String name;\n+    String password;\n+    String email;\n+    Address address;\n+    public User(String name, String password) {\n+      this.name = name;\n+      this.password = password;\n+    }\n+  }\n+\n+  public static final class UserValidator implements JsonPostDeserializer<User> {\n+    public void postDeserialize(User user) {\n+      if (user.name == null || user.password == null) {\n+        throw new JsonSyntaxException(\"name and password are required fields.\");\n+      }\n+      if (user.email == null) user.email = User.DEFAULT_EMAIL;\n+    }\n+  }\n+\n+  @Intercept(postDeserialize = AddressValidator.class)\n+  @SuppressWarnings(\"unused\")\n+  private static final class Address {\n+    static final String DEFAULT_FIRST_LINE = \"unknown\";\n+    String firstLine;\n+    String secondLine;\n+    String city;\n+    String state;\n+    String zip;\n+  }\n+\n+  public static final class AddressValidator implements JsonPostDeserializer<Address> {\n+    public void postDeserialize(Address address) {\n+      if (address.city == null || address.state == null || address.zip == null) {\n+        throw new JsonSyntaxException(\"Address city, state and zip are required fields.\");\n+      }\n+      if (address.firstLine == null) address.firstLine = Address.DEFAULT_FIRST_LINE;\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n \n package com.google.gson;\n \n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.Reader;\n-import java.io.StringReader;\n-import java.io.StringWriter;\n-import java.io.Writer;\n-import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n import com.google.gson.internal.ConstructorConstructor;\n import com.google.gson.internal.Excluder;\n-import com.google.gson.internal.ObjectConstructor;\n import com.google.gson.internal.Primitives;\n import com.google.gson.internal.Streams;\n-import com.google.gson.internal.alpha.Intercept;\n-import com.google.gson.internal.alpha.JsonPostDeserializer;\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n import com.google.gson.stream.MalformedJsonException;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.Writer;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * This is the main class for using Gson. Gson is typically used by first constructing a\n       TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\n       TypeAdapter<T> typeAdapter = getAdapter(typeToken);\n       T object = typeAdapter.read(reader);\n-      invokeInterceptorIfNeeded(object, (Class<T>) typeToken.getRawType());\n       return object;\n     } catch (EOFException e) {\n       /*\n     }\n   }\n \n-  @SuppressWarnings(\"unchecked\")\n-  private <T> void invokeInterceptorIfNeeded(T object, Type type) {\n-    TypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(type);\n-    Class<T> clazz = (Class<T>) typeToken.getRawType();\n-    invokeInterceptorIfNeeded(object, clazz);\n-  }\n-\n-  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-  private <T> void invokeInterceptorIfNeeded(T object, Class<T> clazz) {\n-    Intercept interceptor = clazz.getAnnotation(Intercept.class);\n-    if (interceptor == null) return;\n-    // TODO: We don't need to construct an instance of postDeserializer every time. we can\n-    // create it once and cache it.\n-    Class<? extends JsonPostDeserializer> postDeserializerClass = interceptor.postDeserialize();\n-    ObjectConstructor<? extends JsonPostDeserializer> objectConstructor =\n-        constructorConstructor.get(TypeToken.get(postDeserializerClass));\n-    JsonPostDeserializer<T> postDeserializer = objectConstructor.construct();\n-    postDeserializer.postDeserialize(object);\n-  }\n-\n   @Override\n   public String toString() {\n   \tStringBuilder sb = new StringBuilder(\"{\")\n         .append(\"}\");\n   \treturn sb.toString();\n   }\n-\n-  /**\n-   * Not part of the Gson API. Do not use.\n-   */\n-  public static final class $Internal$Access {\n-    public static <T> void invokeInterceptor(Gson gson, T instance, Type type) {\n-      gson.invokeInterceptorIfNeeded(instance, type);\n-    }\n-    public static <T> void invokeInterceptor(Gson gson, T instance, Class<T> clazz) {\n-      gson.invokeInterceptorIfNeeded(instance, clazz);\n-    }\n-  }\n }\n--- a/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ArrayTypeAdapter.java\n     in.beginArray();\n     while (in.hasNext()) {\n       E instance = componentTypeAdapter.read(in);\n-      Gson.$Internal$Access.invokeInterceptor(context, instance, componentType);\n       list.add(instance);\n     }\n     in.endArray();\n--- a/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/CollectionTypeAdapterFactory.java\n       in.beginArray();\n       while (in.hasNext()) {\n         E instance = elementTypeAdapter.read(in);\n-        Gson.$Internal$Access.invokeInterceptor(context, instance, elementType);\n         collection.add(instance);\n       }\n       in.endArray();\n--- a/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/MapTypeAdapterFactory.java\n  */\n \n package com.google.gson.internal.bind;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n \n import com.google.gson.Gson;\n import com.google.gson.JsonElement;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Adapts maps to either JSON objects or JSON arrays.\n         while (in.hasNext()) {\n           in.beginArray(); // entry array\n           K key = keyTypeAdapter.read(in);\n-          Gson.$Internal$Access.invokeInterceptor(context, key, keyType);\n-\n           V value = valueTypeAdapter.read(in);\n-          Gson.$Internal$Access.invokeInterceptor(context, value, valueType);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n             throw new JsonSyntaxException(\"duplicate key: \" + key);\n         while (in.hasNext()) {\n           JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\n           K key = keyTypeAdapter.read(in);\n-          Gson.$Internal$Access.invokeInterceptor(context, key, keyType);\n           V value = valueTypeAdapter.read(in);\n-          Gson.$Internal$Access.invokeInterceptor(context, value, valueType);\n           V replaced = map.put(key, value);\n           if (replaced != null) {\n             throw new JsonSyntaxException(\"duplicate key: \" + key);\n--- a/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n-        Gson.$Internal$Access.invokeInterceptor(context, fieldValue, fieldType.getRawType());\n         if (fieldValue != null || !isPrimitive) {\n           field.set(value, fieldValue);\n         }", "timestamp": 1351013790, "metainfo": ""}