{"sha": "dea305503ad8827121e8212248c271f1f2f90048", "log": "Merge pull request #800 from google/nullsafe_regression_bugfix  Fixed a regression in Gson 2.6 where Gson caused NPE if the TypeAdapt\u2026", "commit": "\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java\n   static TypeAdapter<?> getTypeAdapter(ConstructorConstructor constructorConstructor, Gson gson,\n       TypeToken<?> fieldType, JsonAdapter annotation) {\n     Class<?> value = annotation.value();\n-    final TypeAdapter<?> typeAdapter;\n+    TypeAdapter<?> typeAdapter;\n     if (TypeAdapter.class.isAssignableFrom(value)) {\n       Class<TypeAdapter<?>> typeAdapterClass = (Class<TypeAdapter<?>>) value;\n       typeAdapter = constructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n       throw new IllegalArgumentException(\n           \"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n     }\n-\n-    return typeAdapter.nullSafe();\n+    if (typeAdapter != null) {\n+      typeAdapter = typeAdapter.nullSafe();\n+    }\n+    return typeAdapter;\n   }\n }\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/regression/JsonAdapterNullSafeTest.java\n+/*\n+ * Copyright (C) 2016 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.google.gson.regression;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.annotations.JsonAdapter;\n+import com.google.gson.reflect.TypeToken;\n+\n+import junit.framework.TestCase;\n+\n+public class JsonAdapterNullSafeTest extends TestCase {\n+  private final Gson gson = new Gson();\n+\n+  public void testNullSafeBugSerialize() throws Exception {\n+    Device device = new Device(\"ec57803e\");\n+    gson.toJson(device);\n+  }\n+\n+  public void testNullSafeBugDeserialize() throws Exception {\n+    Device device = gson.fromJson(\"{'id':'ec57803e2'}\", Device.class);\n+    assertEquals(\"ec57803e2\", device.id);\n+  }\n+\n+  @JsonAdapter(Device.JsonAdapterFactory.class)\n+  private static final class Device {\n+    String id;\n+    Device(String id) {\n+      this.id = id;\n+    }\n+\n+    static final class JsonAdapterFactory implements TypeAdapterFactory {\n+      // The recursiveCall in {@link Device.JsonAdapterFactory} is the source of this bug\n+      // because we use it to return a null type adapter on a recursive call.\n+      private static final ThreadLocal<Boolean> recursiveCall = new ThreadLocal<Boolean>();\n+\n+      @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+      @Override public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {\n+        if (type.getRawType() != Device.class || recursiveCall.get() != null) {\n+          recursiveCall.set(null); // clear for subsequent use\n+          return null;\n+        }\n+        recursiveCall.set(Boolean.TRUE);\n+        return (TypeAdapter) gson.getDelegateAdapter(this, type);\n+      }\n+    }\n+  }\n+}", "timestamp": 1456511759, "metainfo": ""}