{"sha": "46b4346505d85885f2dee28b24d4d2d15190564e", "log": "Get JsonReader2 to the point that it's passing most tests.  Still missing:   - non-execute prefixes  - rolling back 'pos' when a double fails to parse  - octal prefix failures", "commit": "\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader2.java\n+/*\n+ * Copyright (C) 2010 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.stream;\n+\n+import java.io.Closeable;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.Reader;\n+\n+/**\n+ * Reads a JSON (<a href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>)\n+ * encoded value as a stream of tokens. This stream includes both literal\n+ * values (strings, numbers, booleans, and nulls) as well as the begin and\n+ * end delimiters of objects and arrays. The tokens are traversed in\n+ * depth-first order, the same order that they appear in the JSON document.\n+ * Within JSON objects, name/value pairs are represented by a single token.\n+ *\n+ * <h3>Parsing JSON</h3>\n+ * To create a recursive descent parser for your own JSON streams, first create\n+ * an entry point method that creates a {@code JsonReader}.\n+ *\n+ * <p>Next, create handler methods for each structure in your JSON text. You'll\n+ * need a method for each object type and for each array type.\n+ * <ul>\n+ *   <li>Within <strong>array handling</strong> methods, first call {@link\n+ *       #beginArray} to consume the array's opening bracket. Then create a\n+ *       while loop that accumulates values, terminating when {@link #hasNext}\n+ *       is false. Finally, read the array's closing bracket by calling {@link\n+ *       #endArray}.\n+ *   <li>Within <strong>object handling</strong> methods, first call {@link\n+ *       #beginObject} to consume the object's opening brace. Then create a\n+ *       while loop that assigns values to local variables based on their name.\n+ *       This loop should terminate when {@link #hasNext} is false. Finally,\n+ *       read the object's closing brace by calling {@link #endObject}.\n+ * </ul>\n+ * <p>When a nested object or array is encountered, delegate to the\n+ * corresponding handler method.\n+ *\n+ * <p>When an unknown name is encountered, strict parsers should fail with an\n+ * exception. Lenient parsers should call {@link #skipValue()} to recursively\n+ * skip the value's nested tokens, which may otherwise conflict.\n+ *\n+ * <p>If a value may be null, you should first check using {@link #peek()}.\n+ * Null literals can be consumed using either {@link #nextNull()} or {@link\n+ * #skipValue()}.\n+ *\n+ * <h3>Example</h3>\n+ * Suppose we'd like to parse a stream of messages such as the following: <pre> {@code\n+ * [\n+ *   {\n+ *     \"id\": 912345678901,\n+ *     \"text\": \"How do I read a JSON stream in Java?\",\n+ *     \"geo\": null,\n+ *     \"user\": {\n+ *       \"name\": \"json_newb\",\n+ *       \"followers_count\": 41\n+ *      }\n+ *   },\n+ *   {\n+ *     \"id\": 912345678902,\n+ *     \"text\": \"@json_newb just use JsonReader!\",\n+ *     \"geo\": [50.454722, -104.606667],\n+ *     \"user\": {\n+ *       \"name\": \"jesse\",\n+ *       \"followers_count\": 2\n+ *     }\n+ *   }\n+ * ]}</pre>\n+ * This code implements the parser for the above structure: <pre>   {@code\n+ *\n+ *   public List<Message> readJsonStream(InputStream in) throws IOException {\n+ *     JsonReader reader = new JsonReader(new InputStreamReader(in, \"UTF-8\"));\n+ *     try {\n+ *       return readMessagesArray(reader);\n+ *     } finally {\n+ *       reader.close();\n+ *     }\n+ *   }\n+ *\n+ *   public List<Message> readMessagesArray(JsonReader reader) throws IOException {\n+ *     List<Message> messages = new ArrayList<Message>();\n+ *\n+ *     reader.beginArray();\n+ *     while (reader.hasNext()) {\n+ *       messages.add(readMessage(reader));\n+ *     }\n+ *     reader.endArray();\n+ *     return messages;\n+ *   }\n+ *\n+ *   public Message readMessage(JsonReader reader) throws IOException {\n+ *     long id = -1;\n+ *     String text = null;\n+ *     User user = null;\n+ *     List<Double> geo = null;\n+ *\n+ *     reader.beginObject();\n+ *     while (reader.hasNext()) {\n+ *       String name = reader.nextName();\n+ *       if (name.equals(\"id\")) {\n+ *         id = reader.nextLong();\n+ *       } else if (name.equals(\"text\")) {\n+ *         text = reader.nextString();\n+ *       } else if (name.equals(\"geo\") && reader.peek() != JsonToken.NULL) {\n+ *         geo = readDoublesArray(reader);\n+ *       } else if (name.equals(\"user\")) {\n+ *         user = readUser(reader);\n+ *       } else {\n+ *         reader.skipValue();\n+ *       }\n+ *     }\n+ *     reader.endObject();\n+ *     return new Message(id, text, user, geo);\n+ *   }\n+ *\n+ *   public List<Double> readDoublesArray(JsonReader reader) throws IOException {\n+ *     List<Double> doubles = new ArrayList<Double>();\n+ *\n+ *     reader.beginArray();\n+ *     while (reader.hasNext()) {\n+ *       doubles.add(reader.nextDouble());\n+ *     }\n+ *     reader.endArray();\n+ *     return doubles;\n+ *   }\n+ *\n+ *   public User readUser(JsonReader reader) throws IOException {\n+ *     String username = null;\n+ *     int followersCount = -1;\n+ *\n+ *     reader.beginObject();\n+ *     while (reader.hasNext()) {\n+ *       String name = reader.nextName();\n+ *       if (name.equals(\"name\")) {\n+ *         username = reader.nextString();\n+ *       } else if (name.equals(\"followers_count\")) {\n+ *         followersCount = reader.nextInt();\n+ *       } else {\n+ *         reader.skipValue();\n+ *       }\n+ *     }\n+ *     reader.endObject();\n+ *     return new User(username, followersCount);\n+ *   }}</pre>\n+ *\n+ * <h3>Number Handling</h3>\n+ * This reader permits numeric values to be read as strings and string values to\n+ * be read as numbers. For example, both elements of the JSON array {@code\n+ * [1, \"1\"]} may be read using either {@link #nextInt} or {@link #nextString}.\n+ * This behavior is intended to prevent lossy numeric conversions: double is\n+ * JavaScript's only numeric type and very large values like {@code\n+ * 9007199254740993} cannot be represented exactly on that platform. To minimize\n+ * precision loss, extremely large values should be written and read as strings\n+ * in JSON.\n+ *\n+ * <a name=\"nonexecuteprefix\"/><h3>Non-Execute Prefix</h3>\n+ * Web servers that serve private data using JSON may be vulnerable to <a\n+ * href=\"http://en.wikipedia.org/wiki/JSON#Cross-site_request_forgery\">Cross-site\n+ * request forgery</a> attacks. In such an attack, a malicious site gains access\n+ * to a private JSON file by executing it with an HTML {@code <script>} tag.\n+ *\n+ * <p>Prefixing JSON files with <code>\")]}'\\n\"</code> makes them non-executable\n+ * by {@code <script>} tags, disarming the attack. Since the prefix is malformed\n+ * JSON, strict parsing fails when it is encountered. This class permits the\n+ * non-execute prefix when {@link #setLenient(boolean) lenient parsing} is\n+ * enabled.\n+ *\n+ * <p>Each {@code JsonReader} may be used to read a single JSON stream. Instances\n+ * of this class are not thread safe.\n+ *\n+ * @author Jesse Wilson\n+ * @since 1.6\n+ */\n+public class JsonReader2 implements Closeable {\n+  private static final int PEEKED_NONE = 0;\n+  private static final int PEEKED_BEGIN_OBJECT = 1;\n+  private static final int PEEKED_END_OBJECT = 2;\n+  private static final int PEEKED_BEGIN_ARRAY = 3;\n+  private static final int PEEKED_END_ARRAY = 4;\n+  private static final int PEEKED_TRUE = 5;\n+  private static final int PEEKED_FALSE = 6;\n+  private static final int PEEKED_NULL = 7;\n+  private static final int PEEKED_SINGLE_QUOTED = 8;\n+  private static final int PEEKED_DOUBLE_QUOTED = 9;\n+  private static final int PEEKED_UNQUOTED = 10;\n+  private static final int PEEKED_SINGLE_QUOTED_NAME = 11;\n+  private static final int PEEKED_DOUBLE_QUOTED_NAME = 12;\n+  private static final int PEEKED_UNQUOTED_NAME = 13;\n+  /** When this is returned, the integer value is stored in peekedInteger. */\n+  private static final int PEEKED_INTEGER = 14;\n+  private static final int PEEKED_NUMBER = 15;\n+  private static final int PEEKED_EOF = 16;\n+\n+  /** The input JSON. */\n+  private final Reader in;\n+\n+  /** True to accept non-spec compliant JSON */\n+  private boolean lenient = false;\n+\n+  /**\n+   * Use a manual buffer to easily read and unread upcoming characters, and\n+   * also so we can create strings without an intermediate StringBuilder.\n+   * We decode literals directly out of this buffer, so it must be at least as\n+   * long as the longest token that can be reported as a number.\n+   */\n+  private final char[] buffer = new char[1024];\n+  private int pos = 0;\n+  private int limit = 0;\n+\n+  /*\n+   * The offset of the first character in the buffer.\n+   */\n+  private int bufferStartLine = 1;\n+  private int bufferStartColumn = 1;\n+\n+  private int peeked = PEEKED_NONE;\n+\n+  /**\n+   * A peeked value that was composed entirely of digits with an optional\n+   * leading dash. Positive values may not have a leading 0.\n+   */\n+  private long peekedInteger;\n+\n+  /**\n+   * The number of characters in the peeked number.\n+   */\n+  private int peekedNumberLength;\n+\n+  /*\n+   * The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n+   */\n+  private int[] stack = new int[32];\n+  private int stackSize = 0;\n+  {\n+    stack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n+  }\n+\n+  /**\n+   * Creates a new instance that reads a JSON-encoded stream from {@code in}.\n+   */\n+  public JsonReader2(Reader in) {\n+    if (in == null) {\n+      throw new NullPointerException(\"in == null\");\n+    }\n+    this.in = in;\n+  }\n+\n+  /**\n+   * Configure this parser to be  be liberal in what it accepts. By default,\n+   * this parser is strict and only accepts JSON as specified by <a\n+   * href=\"http://www.ietf.org/rfc/rfc4627.txt\">RFC 4627</a>. Setting the\n+   * parser to lenient causes it to ignore the following syntax errors:\n+   *\n+   * <ul>\n+   *   <li>Streams that start with the <a href=\"#nonexecuteprefix\">non-execute\n+   *       prefix</a>, <code>\")]}'\\n\"</code>.\n+   *   <li>Streams that include multiple top-level values. With strict parsing,\n+   *       each stream must contain exactly one top-level value.\n+   *   <li>Top-level values of any type. With strict parsing, the top-level\n+   *       value must be an object or an array.\n+   *   <li>Numbers may be {@link Double#isNaN() NaNs} or {@link\n+   *       Double#isInfinite() infinities}.\n+   *   <li>End of line comments starting with {@code //} or {@code #} and\n+   *       ending with a newline character.\n+   *   <li>C-style comments starting with {@code /*} and ending with\n+   *       {@code *}{@code /}. Such comments may not be nested.\n+   *   <li>Names that are unquoted or {@code 'single quoted'}.\n+   *   <li>Strings that are unquoted or {@code 'single quoted'}.\n+   *   <li>Array elements separated by {@code ;} instead of {@code ,}.\n+   *   <li>Unnecessary array separators. These are interpreted as if null\n+   *       was the omitted value.\n+   *   <li>Names and values separated by {@code =} or {@code =>} instead of\n+   *       {@code :}.\n+   *   <li>Name/value pairs separated by {@code ;} instead of {@code ,}.\n+   * </ul>\n+   */\n+  public final void setLenient(boolean lenient) {\n+    this.lenient = lenient;\n+  }\n+\n+  /**\n+   * Returns true if this parser is liberal in what it accepts.\n+   */\n+  public final boolean isLenient() {\n+    return lenient;\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * beginning of a new array.\n+   */\n+  public void beginArray() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    if (p == PEEKED_BEGIN_ARRAY) {\n+      push(JsonScope.EMPTY_ARRAY);\n+      peeked = PEEKED_NONE;\n+    } else {\n+      throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * end of the current array.\n+   */\n+  public void endArray() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    if (p == PEEKED_END_ARRAY) {\n+      stackSize--;\n+      peeked = PEEKED_NONE;\n+    } else {\n+      throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * beginning of a new object.\n+   */\n+  public void beginObject() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    if (p == PEEKED_BEGIN_OBJECT) {\n+      push(JsonScope.EMPTY_OBJECT);\n+      peeked = PEEKED_NONE;\n+    } else {\n+      throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is the\n+   * end of the current object.\n+   */\n+  public void endObject() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    if (p == PEEKED_END_OBJECT) {\n+      stackSize--;\n+      peeked = PEEKED_NONE;\n+    } else {\n+      throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+  }\n+\n+  /**\n+   * Returns true if the current array or object has another element.\n+   */\n+  public boolean hasNext() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    return p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n+  }\n+\n+  /**\n+   * Returns the type of the next token without consuming it.\n+   */\n+  public JsonToken peek() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+\n+    switch (p) {\n+    case PEEKED_BEGIN_OBJECT:\n+      return JsonToken.BEGIN_OBJECT;\n+    case PEEKED_END_OBJECT:\n+      return JsonToken.END_OBJECT;\n+    case PEEKED_BEGIN_ARRAY:\n+      return JsonToken.BEGIN_ARRAY;\n+    case PEEKED_END_ARRAY:\n+      return JsonToken.END_ARRAY;\n+    case PEEKED_SINGLE_QUOTED_NAME:\n+    case PEEKED_DOUBLE_QUOTED_NAME:\n+    case PEEKED_UNQUOTED_NAME:\n+      return JsonToken.NAME;\n+    case PEEKED_TRUE:\n+    case PEEKED_FALSE:\n+      return JsonToken.BOOLEAN;\n+    case PEEKED_NULL:\n+      return JsonToken.NULL;\n+    case PEEKED_SINGLE_QUOTED:\n+    case PEEKED_DOUBLE_QUOTED:\n+    case PEEKED_UNQUOTED:\n+      return JsonToken.STRING;\n+    case PEEKED_INTEGER:\n+    case PEEKED_NUMBER:\n+      return JsonToken.NUMBER;\n+    case PEEKED_EOF:\n+      return JsonToken.END_DOCUMENT;\n+    default:\n+      throw new AssertionError();\n+    }\n+  }\n+\n+  private int doPeek() throws IOException {\n+    int peekStack = stack[stackSize - 1];\n+    if (peekStack == JsonScope.EMPTY_ARRAY) {\n+      stack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n+    } else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n+      // Look for a comma before the next element.\n+      int c = nextNonWhitespace(true);\n+      switch (c) {\n+      case ']':\n+        return peeked = PEEKED_END_ARRAY;\n+      case ';':\n+        checkLenient(); // fall-through\n+      case ',':\n+        break;\n+      default:\n+        throw syntaxError(\"Unterminated array\");\n+      }\n+    } else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\n+      stack[stackSize - 1] = JsonScope.DANGLING_NAME;\n+      // Look for a comma before the next element.\n+      if (peekStack == JsonScope.NONEMPTY_OBJECT) {\n+        int c = nextNonWhitespace(true);\n+        switch (c) {\n+        case '}':\n+          return peeked = PEEKED_END_OBJECT;\n+        case ';':\n+          checkLenient(); // fall-through\n+        case ',':\n+          break;\n+        default:\n+          throw syntaxError(\"Unterminated object\");\n+        }\n+      }\n+      int c = nextNonWhitespace(true);\n+      switch (c) {\n+      case '\"':\n+        return peeked = PEEKED_DOUBLE_QUOTED_NAME;\n+      case '\\'':\n+        checkLenient();\n+        return peeked = PEEKED_SINGLE_QUOTED_NAME;\n+      case '}':\n+        if (peekStack != JsonScope.NONEMPTY_OBJECT) {\n+          return peeked = PEEKED_END_OBJECT;\n+        } else {\n+          throw syntaxError(\"Expected name\");\n+        }\n+      default:\n+        checkLenient();\n+        pos--; // Don't consume the first character in an unquoted string.\n+        if (isLiteral((char) c)) {\n+          return peeked = PEEKED_UNQUOTED_NAME;\n+        } else {\n+          throw syntaxError(\"Expected name\");\n+        }\n+      }\n+    } else if (peekStack == JsonScope.DANGLING_NAME) {\n+      stack[stackSize - 1] = JsonScope.NONEMPTY_OBJECT;\n+      // Look for a colon before the value.\n+      int c = nextNonWhitespace(true);\n+      switch (c) {\n+      case ':':\n+        break;\n+      case '=':\n+        checkLenient();\n+        if ((pos < limit || fillBuffer(1)) && buffer[pos] == '>') {\n+          pos++;\n+        }\n+        break;\n+      default:\n+        throw syntaxError(\"Expected ':'\");\n+      }\n+    } else if (peekStack == JsonScope.EMPTY_DOCUMENT) {\n+      stack[stackSize - 1] = JsonScope.NONEMPTY_DOCUMENT;\n+    } else if (peekStack == JsonScope.NONEMPTY_DOCUMENT) {\n+      int c = nextNonWhitespace(false);\n+      if (c == -1) {\n+        return peeked = PEEKED_EOF;\n+      } else {\n+        checkLenient();\n+        pos--;\n+      }\n+    } else if (peekStack == JsonScope.CLOSED) {\n+      throw new IllegalStateException(\"JsonReader is closed\");\n+    }\n+\n+    int c = nextNonWhitespace(true);\n+    switch (c) {\n+    case ']':\n+      if (peekStack == JsonScope.EMPTY_ARRAY) {\n+        return peeked = PEEKED_END_ARRAY;\n+      }\n+      // fall-through to handle \",]\"\n+    case ';':\n+    case ',':\n+      // In lenient mode, a 0-length literal in an array means 'null'.\n+      if (peekStack == JsonScope.EMPTY_ARRAY || peekStack == JsonScope.NONEMPTY_ARRAY) {\n+        checkLenient();\n+        pos--;\n+        return peeked = PEEKED_NULL;\n+      } else {\n+        throw syntaxError(\"Unexpected value\");\n+      }\n+    case '\\'':\n+      checkLenient();\n+      return peeked = PEEKED_SINGLE_QUOTED;\n+    case '\"':\n+      if (stackSize == 1) {\n+        checkLenient();\n+      }\n+      return peeked = PEEKED_DOUBLE_QUOTED;\n+    case '[':\n+      return peeked = PEEKED_BEGIN_ARRAY;\n+    case '{':\n+      return peeked = PEEKED_BEGIN_OBJECT;\n+    default:\n+      pos--; // Don't consume the first character in a literal value.\n+    }\n+\n+    if (stackSize == 1) {\n+      checkLenient();\n+    }\n+\n+    int result = peekKeyword();\n+    if (result != PEEKED_NONE) {\n+      return result;\n+    }\n+\n+    result = peekNumber();\n+    if (result != PEEKED_NONE) {\n+      return result;\n+    }\n+\n+    if (!isLiteral(buffer[pos])) {\n+      throw syntaxError(\"Expected value\");\n+    }\n+\n+    checkLenient();\n+    return peeked = PEEKED_UNQUOTED;\n+  }\n+\n+  private int peekKeyword() throws IOException {\n+    // Figure out which keyword we're matching against by its first character.\n+    char c = buffer[pos];\n+    String keyword;\n+    String keywordUpper;\n+    int peeking;\n+    if (c == 't' || c == 'T') {\n+      keyword = \"true\";\n+      keywordUpper = \"TRUE\";\n+      peeking = PEEKED_TRUE;\n+    } else if (c == 'f' || c == 'F') {\n+      keyword = \"false\";\n+      keywordUpper = \"FALSE\";\n+      peeking = PEEKED_FALSE;\n+    } else if (c == 'n' || c == 'N') {\n+      keyword = \"null\";\n+      keywordUpper = \"NULL\";\n+      peeking = PEEKED_NULL;\n+    } else {\n+      return PEEKED_NONE;\n+    }\n+\n+    // Confirm that chars [1..length) match the keyword.\n+    int length = keyword.length();\n+    for (int i = 1; i < length; i++) {\n+      if (pos + i >= limit && !fillBuffer(i + 1)) {\n+        return PEEKED_NONE;\n+      }\n+      c = buffer[pos + i];\n+      if (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\n+        return PEEKED_NONE;\n+      }\n+    }\n+\n+    if ((pos + length < limit || fillBuffer(length + 1))\n+        && isLiteral(buffer[pos + length])) {\n+      return PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n+    }\n+\n+    // We've found the keyword followed either by EOF or by a non-literal character.\n+    pos += length;\n+    return peeked = peeking;\n+  }\n+\n+  private int peekNumber() throws IOException {\n+    long integer = 0; // Negative to accommodate Long.MIN_VALUE more easily.\n+    boolean negative = false;\n+    boolean fitsInLong = true;\n+    int i = 0;\n+    int c = get(i);\n+\n+    // TODO: figure out a way to speed up repopulating 'c'\n+\n+    if (c == '-') {\n+      negative = true;\n+      c = get(++i);\n+    }\n+\n+    if (c == '0') {\n+      c = get(++i);\n+    } else if (c >= '1' && c <= '9') {\n+      integer -= (c - '0');\n+      c = get(++i);\n+      while (c >= '0' && c <= '9') {\n+        long newInteger = integer * 10 - (c - '0');\n+        fitsInLong &= newInteger < integer;\n+        integer = newInteger;\n+        c = get(++i);\n+      }\n+    } else {\n+      return PEEKED_NONE;\n+    }\n+\n+    if (c == -1 || !isLiteral((char) c)) {\n+      if (fitsInLong) {\n+        peekedInteger = negative ? integer : -integer;\n+        pos += i;\n+        return peeked = PEEKED_INTEGER;\n+      } else {\n+        peekedNumberLength = i;\n+        return peeked = PEEKED_NUMBER;\n+      }\n+    }\n+\n+    if (c == '.') {\n+      c = get(++i);\n+      while (c >= '0' && c <= '9') {\n+        c = get(++i);\n+      }\n+    }\n+\n+    if (c == 'e' || c == 'E') {\n+      c = get(++i);\n+      if (c == '+' || c == '-') {\n+        c = get(++i);\n+      }\n+      if (c >= '0' && c <= '9') {\n+        c = get(++i);\n+        while (c >= '0' && c <= '9') {\n+          c = get(++i);\n+        }\n+      } else {\n+        return PEEKED_NONE;\n+      }\n+    }\n+\n+    if (c == -1 || !isLiteral((char) c)) {\n+      peekedNumberLength = i;\n+      return peeked = PEEKED_NUMBER;\n+    }\n+\n+    return PEEKED_NONE;\n+  }\n+\n+  /**\n+   * Returns a character at position {@code pos + offset}, reading additional\n+   * bytes into the buffer if necessary.\n+   */\n+  private int get(int offset) throws IOException {\n+    return (pos + offset < limit || fillBuffer(offset + 1)) ? buffer[pos + offset] : -1;\n+  }\n+\n+  private boolean isLiteral(char c) throws IOException {\n+    switch (c) {\n+    case '/':\n+    case '\\\\':\n+    case ';':\n+    case '#':\n+    case '=':\n+      checkLenient(); // fall-through\n+    case '{':\n+    case '}':\n+    case '[':\n+    case ']':\n+    case ':':\n+    case ',':\n+    case ' ':\n+    case '\\t':\n+    case '\\f':\n+    case '\\r':\n+    case '\\n':\n+      return false;\n+    default:\n+      return true;\n+    }\n+  }\n+\n+  /**\n+   * Returns the next token, a {@link com.google.gson.stream.JsonToken#NAME property name}, and\n+   * consumes it.\n+   *\n+   * @throws java.io.IOException if the next token in the stream is not a property\n+   *     name.\n+   */\n+  public String nextName() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    String result;\n+    if (p == PEEKED_UNQUOTED_NAME) {\n+      result = nextUnquotedValue();\n+    } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n+      result = nextQuotedValue('\\'');\n+    } else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n+      result = nextQuotedValue('\"');\n+    } else {\n+      throw new IllegalStateException(\"Expected a name but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+    peeked = PEEKED_NONE;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,\n+   * consuming it. If the next token is a number, this method will return its\n+   * string form.\n+   *\n+   * @throws IllegalStateException if the next token is not a string or if\n+   *     this reader is closed.\n+   */\n+  public String nextString() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    String result;\n+    if (p == PEEKED_UNQUOTED) {\n+      result = nextUnquotedValue();\n+    } else if (p == PEEKED_SINGLE_QUOTED) {\n+      result = nextQuotedValue('\\'');\n+    } else if (p == PEEKED_DOUBLE_QUOTED) {\n+      result = nextQuotedValue('\"');\n+    } else if (p == PEEKED_INTEGER) {\n+      result = Long.toString(peekedInteger);\n+    } else if (p == PEEKED_NUMBER) {\n+      result = new String(buffer, pos, peekedNumberLength);\n+      pos += peekedNumberLength;\n+    } else {\n+      throw new IllegalStateException(\"Expected a string but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+    peeked = PEEKED_NONE;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,\n+   * consuming it.\n+   *\n+   * @throws IllegalStateException if the next token is not a boolean or if\n+   *     this reader is closed.\n+   */\n+  public boolean nextBoolean() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    if (p == PEEKED_TRUE) {\n+      peeked = PEEKED_NONE;\n+      return true;\n+    } else if (p == PEEKED_FALSE) {\n+      peeked = PEEKED_NONE;\n+      return false;\n+    }\n+    throw new IllegalStateException(\"Expected a boolean but was \" + peek()\n+        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+  }\n+\n+  /**\n+   * Consumes the next token from the JSON stream and asserts that it is a\n+   * literal null.\n+   *\n+   * @throws IllegalStateException if the next token is not null or if this\n+   *     reader is closed.\n+   */\n+  public void nextNull() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+    if (p == PEEKED_NULL) {\n+      peeked = PEEKED_NONE;\n+    } else {\n+      throw new IllegalStateException(\"Expected null but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+  }\n+\n+  /**\n+   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,\n+   * consuming it. If the next token is a string, this method will attempt to\n+   * parse it as a double using {@link Double#parseDouble(String)}.\n+   *\n+   * @throws IllegalStateException if the next token is not a literal value.\n+   * @throws NumberFormatException if the next literal value cannot be parsed\n+   *     as a double, or is non-finite.\n+   */\n+  public double nextDouble() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+\n+    if (p == PEEKED_INTEGER) {\n+      peeked = PEEKED_NONE;\n+      return (double) peekedInteger;\n+    }\n+\n+    String asString;\n+    if (p == PEEKED_NUMBER) {\n+      asString = new String(buffer, pos, peekedNumberLength);\n+      pos += peekedNumberLength;\n+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n+      asString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n+    } else if (p == PEEKED_UNQUOTED) {\n+      asString = nextUnquotedValue();\n+    } else {\n+      throw new IllegalStateException(\"Expected a double but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+\n+    double result = Double.parseDouble(asString); // don't catch this NumberFormatException.\n+    if (!lenient && (Double.isNaN(result) || Double.isInfinite(result))) {\n+      throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+    peeked = PEEKED_NONE;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,\n+   * consuming it. If the next token is a string, this method will attempt to\n+   * parse it as a long. If the next token's numeric value cannot be exactly\n+   * represented by a Java {@code long}, this method throws.\n+   *\n+   * @throws IllegalStateException if the next token is not a literal value.\n+   * @throws NumberFormatException if the next literal value cannot be parsed\n+   *     as a number, or exactly represented as a long.\n+   */\n+  public long nextLong() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+\n+    if (p == PEEKED_INTEGER) {\n+      peeked = PEEKED_NONE;\n+      return peekedInteger;\n+    }\n+\n+    String asString;\n+    if (p == PEEKED_NUMBER) {\n+      asString = new String(buffer, pos, peekedNumberLength);\n+      pos += peekedNumberLength;\n+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n+      asString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n+      try {\n+        long result = Long.parseLong(asString);\n+        peeked = PEEKED_NONE;\n+        return result;\n+      } catch (NumberFormatException ignored) {\n+        // Fall back to parse as a double below.\n+      }\n+    } else {\n+      throw new IllegalStateException(\"Expected a long but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+\n+    double asDouble = Double.parseDouble(asString); // don't catch this NumberFormatException.\n+    long result = (long) asDouble;\n+    if (result != asDouble) { // Make sure no precision was lost casting to 'long'.\n+      throw new NumberFormatException(\"Expected a long but was \" + asString\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+    peeked = PEEKED_NONE;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the string up to but not including {@code quote}, unescaping any\n+   * character escape sequences encountered along the way. The opening quote\n+   * should have already been read. This consumes the closing quote, but does\n+   * not include it in the returned string.\n+   *\n+   * @param quote either ' or \".\n+   * @throws NumberFormatException if any unicode escape sequences are\n+   *     malformed.\n+   */\n+  private String nextQuotedValue(char quote) throws IOException {\n+    // Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\n+    char[] buffer = this.buffer;\n+    StringBuilder builder = null;\n+    while (true) {\n+      int p = pos;\n+      int l = limit;\n+      /* the index of the first character not yet appended to the builder. */\n+      int start = p;\n+      while (p < l) {\n+        int c = buffer[p++];\n+\n+        if (c == quote) {\n+          pos = p;\n+          if (false /* TODO: fast skipping */) {\n+            return \"skipped!\";\n+          } else if (builder == null) {\n+            return new String(buffer, start, p - start - 1);\n+          } else {\n+            builder.append(buffer, start, p - start - 1);\n+            return builder.toString();\n+          }\n+\n+        } else if (c == '\\\\') {\n+          pos = p;\n+          if (builder == null) {\n+            builder = new StringBuilder();\n+          }\n+          builder.append(buffer, start, p - start - 1);\n+          builder.append(readEscapeCharacter());\n+          p = pos;\n+          l = limit;\n+          start = p;\n+        }\n+      }\n+\n+      if (builder == null) {\n+        builder = new StringBuilder();\n+      }\n+      builder.append(buffer, start, p - start);\n+      pos = p;\n+      if (!fillBuffer(1)) {\n+        throw syntaxError(\"Unterminated string\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns an unquoted value as a string.\n+   */\n+  @SuppressWarnings(\"fallthrough\")\n+  private String nextUnquotedValue() throws IOException {\n+    StringBuilder builder = null;\n+    int i = 0;\n+\n+    findNonLiteralCharacter:\n+    while (true) {\n+      for (; pos + i < limit; i++) {\n+        switch (buffer[pos + i]) {\n+        case '/':\n+        case '\\\\':\n+        case ';':\n+        case '#':\n+        case '=':\n+          checkLenient(); // fall-through\n+        case '{':\n+        case '}':\n+        case '[':\n+        case ']':\n+        case ':':\n+        case ',':\n+        case ' ':\n+        case '\\t':\n+        case '\\f':\n+        case '\\r':\n+        case '\\n':\n+          break findNonLiteralCharacter;\n+        }\n+      }\n+\n+      // Attempt to load the entire literal into the buffer at once.\n+      if (i < buffer.length) {\n+        if (fillBuffer(i + 1)) {\n+          continue;\n+        } else {\n+          break;\n+        }\n+      }\n+\n+      // use a StringBuilder when the value is too long. This is too long to be a number!\n+      if (builder == null) {\n+        builder = new StringBuilder();\n+      }\n+      builder.append(buffer, pos, i);\n+      pos += i;\n+      i = 0;\n+      if (!fillBuffer(1)) {\n+        break;\n+      }\n+    }\n+\n+    String result;\n+    if (false /* TODO: fast skipping */) {\n+      result = \"skipped!\";\n+    } else if (builder == null) {\n+      result = new String(buffer, pos, i);\n+    } else {\n+      builder.append(buffer, pos, i);\n+      result = builder.toString();\n+    }\n+    pos += i;\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,\n+   * consuming it. If the next token is a string, this method will attempt to\n+   * parse it as an int. If the next token's numeric value cannot be exactly\n+   * represented by a Java {@code int}, this method throws.\n+   *\n+   * @throws IllegalStateException if the next token is not a literal value.\n+   * @throws NumberFormatException if the next literal value cannot be parsed\n+   *     as a number, or exactly represented as an int.\n+   */\n+  public int nextInt() throws IOException {\n+    int p = peeked;\n+    if (p == PEEKED_NONE) {\n+      p = doPeek();\n+    }\n+\n+    int result;\n+    if (p == PEEKED_INTEGER) {\n+      result = (int) peekedInteger;\n+      if (peekedInteger != result) { // Make sure no precision was lost casting to 'int'.\n+        throw new NumberFormatException(\"Expected an int but was \" + peekedInteger\n+            + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+      }\n+      peeked = PEEKED_NONE;\n+      return result;\n+    }\n+\n+    String asString;\n+    if (p == PEEKED_NUMBER) {\n+      asString = new String(buffer, pos, peekedNumberLength);\n+      pos += peekedNumberLength;\n+    } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_DOUBLE_QUOTED) {\n+      asString = nextQuotedValue(p == PEEKED_SINGLE_QUOTED ? '\\'' : '\"');\n+      try {\n+        result = Integer.parseInt(asString);\n+        peeked = PEEKED_NONE;\n+        return result;\n+      } catch (NumberFormatException ignored) {\n+        // Fall back to parse as a double below.\n+      }\n+    } else {\n+      throw new IllegalStateException(\"Expected an int but was \" + peek()\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+\n+    double asDouble = Double.parseDouble(asString); // don't catch this NumberFormatException.\n+    result = (int) asDouble;\n+    if (result != asDouble) { // Make sure no precision was lost casting to 'int'.\n+      throw new NumberFormatException(\"Expected an int but was \" + asString\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    }\n+    peeked = PEEKED_NONE;\n+    return result;\n+  }\n+\n+  /**\n+   * Closes this JSON reader and the underlying {@link java.io.Reader}.\n+   */\n+  public void close() throws IOException {\n+    peeked = PEEKED_NONE;\n+    stack[0] = JsonScope.CLOSED;\n+    stackSize = 1;\n+    in.close();\n+  }\n+\n+  /**\n+   * Skips the next value recursively. If it is an object or array, all nested\n+   * elements are skipped. This method is intended for use when the JSON token\n+   * stream contains unrecognized or unhandled values.\n+   */\n+  public void skipValue() throws IOException {\n+    int count = 0;\n+    do {\n+      int p = doPeek();\n+      if (p == PEEKED_BEGIN_ARRAY) {\n+        push(JsonScope.EMPTY_ARRAY);\n+        count++;\n+      } else if (p == PEEKED_BEGIN_OBJECT) {\n+        push(JsonScope.EMPTY_OBJECT);\n+        count++;\n+      } else if (p == PEEKED_END_ARRAY) {\n+        stackSize--;\n+        count--;\n+      } else if (p == PEEKED_END_OBJECT) {\n+        stackSize--;\n+        count--;\n+      } else if (p == PEEKED_UNQUOTED_NAME || p == PEEKED_UNQUOTED) {\n+        nextUnquotedValue();\n+      } else if (p == PEEKED_SINGLE_QUOTED || p == PEEKED_SINGLE_QUOTED_NAME) {\n+        nextQuotedValue('\\'');\n+      } else if (p == PEEKED_DOUBLE_QUOTED || p == PEEKED_DOUBLE_QUOTED_NAME) {\n+        nextQuotedValue('\"');\n+      } else if (p == PEEKED_NUMBER) {\n+        pos += peekedNumberLength;\n+      }\n+      peeked = PEEKED_NONE;\n+    } while (count != 0);\n+  }\n+\n+  private void push(int newTop) {\n+    if (stackSize == stack.length) {\n+      int[] newStack = new int[stackSize * 2];\n+      System.arraycopy(stack, 0, newStack, 0, stackSize);\n+      stack = newStack;\n+    }\n+    stack[stackSize++] = newTop;\n+  }\n+\n+  /**\n+   * Returns true once {@code limit - pos >= minimum}. If the data is\n+   * exhausted before that many characters are available, this returns\n+   * false.\n+   */\n+  private boolean fillBuffer(int minimum) throws IOException {\n+    char[] buffer = this.buffer;\n+\n+    // Before clobbering the old characters, update where buffer starts\n+    // Using locals here saves ~2%.\n+    int line = bufferStartLine;\n+    int column = bufferStartColumn;\n+    for (int i = 0, p = pos; i < p; i++) {\n+      if (buffer[i] == '\\n') {\n+        line++;\n+        column = 1;\n+      } else {\n+        column++;\n+      }\n+    }\n+    bufferStartLine = line;\n+    bufferStartColumn = column;\n+\n+    if (limit != pos) {\n+      limit -= pos;\n+      System.arraycopy(buffer, pos, buffer, 0, limit);\n+    } else {\n+      limit = 0;\n+    }\n+\n+    pos = 0;\n+    int total;\n+    while ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\n+      limit += total;\n+\n+      // if this is the first read, consume an optional byte order mark (BOM) if it exists\n+      if (bufferStartLine == 1 && bufferStartColumn == 1 && limit > 0 && buffer[0] == '\\ufeff') {\n+        pos++;\n+        bufferStartColumn--;\n+      }\n+\n+      if (limit >= minimum) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private int getLineNumber() {\n+    int result = bufferStartLine;\n+    for (int i = 0; i < pos; i++) {\n+      if (buffer[i] == '\\n') {\n+        result++;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private int getColumnNumber() {\n+    int result = bufferStartColumn;\n+    for (int i = 0; i < pos; i++) {\n+      if (buffer[i] == '\\n') {\n+        result = 1;\n+      } else {\n+        result++;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  /**\n+   * Returns the next character in the stream that is neither whitespace nor a\n+   * part of a comment. When this returns, the returned character is always at\n+   * {@code buffer[pos-1]}; this means the caller can always push back the\n+   * returned character by decrementing {@code pos}.\n+   */\n+  private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n+    /*\n+     * This code uses ugly local variables 'p' and 'l' representing the 'pos'\n+     * and 'limit' fields respectively. Using locals rather than fields saves\n+     * a few field reads for each whitespace character in a pretty-printed\n+     * document, resulting in a 5% speedup. We need to flush 'p' to its field\n+     * before any (potentially indirect) call to fillBuffer() and reread both\n+     * 'p' and 'l' after any (potentially indirect) call to the same method.\n+     */\n+    char[] buffer = this.buffer;\n+    int p = pos;\n+    int l = limit;\n+    while (true) {\n+      if (p == l) {\n+        pos = p;\n+        if (!fillBuffer(1)) {\n+          break;\n+        }\n+        p = pos;\n+        l = limit;\n+      }\n+\n+      int c = buffer[p++];\n+      switch (c) {\n+      case '\\t':\n+      case ' ':\n+      case '\\n':\n+      case '\\r':\n+        continue;\n+\n+      case '/':\n+        pos = p;\n+        if (p == l) {\n+          pos--; // push back '/' so it's still in the buffer when this method returns\n+          boolean charsLoaded = fillBuffer(2);\n+          pos++; // consume the '/' again\n+          if (!charsLoaded) {\n+            return c;\n+          }\n+        }\n+\n+        checkLenient();\n+        char peek = buffer[pos];\n+        switch (peek) {\n+        case '*':\n+          // skip a /* c-style comment */\n+          pos++;\n+          if (!skipTo(\"*/\")) {\n+            throw syntaxError(\"Unterminated comment\");\n+          }\n+          p = pos + 2;\n+          l = limit;\n+          continue;\n+\n+        case '/':\n+          // skip a // end-of-line comment\n+          pos++;\n+          skipToEndOfLine();\n+          p = pos;\n+          l = limit;\n+          continue;\n+\n+        default:\n+          return c;\n+        }\n+\n+      case '#':\n+        pos = p;\n+        /*\n+         * Skip a # hash end-of-line comment. The JSON RFC doesn't\n+         * specify this behaviour, but it's required to parse\n+         * existing documents. See http://b/2571423.\n+         */\n+        checkLenient();\n+        skipToEndOfLine();\n+        p = pos;\n+        l = limit;\n+        continue;\n+\n+      default:\n+        pos = p;\n+        return c;\n+      }\n+    }\n+    if (throwOnEof) {\n+      throw new EOFException(\"End of input\"\n+          + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+    } else {\n+      return -1;\n+    }\n+  }\n+\n+  private void checkLenient() throws IOException {\n+    if (!lenient) {\n+      throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n+    }\n+  }\n+\n+  /**\n+   * Advances the position until after the next newline character. If the line\n+   * is terminated by \"\\r\\n\", the '\\n' must be consumed as whitespace by the\n+   * caller.\n+   */\n+  private void skipToEndOfLine() throws IOException {\n+    while (pos < limit || fillBuffer(1)) {\n+      char c = buffer[pos++];\n+      if (c == '\\r' || c == '\\n') {\n+        break;\n+      }\n+    }\n+  }\n+\n+  private boolean skipTo(String toFind) throws IOException {\n+    outer:\n+    for (; pos + toFind.length() <= limit || fillBuffer(toFind.length()); pos++) {\n+      for (int c = 0; c < toFind.length(); c++) {\n+        if (buffer[pos + c] != toFind.charAt(c)) {\n+          continue outer;\n+        }\n+      }\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName()\n+        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber();\n+  }\n+\n+  /**\n+   * Unescapes the character identified by the character or characters that\n+   * immediately follow a backslash. The backslash '\\' should have already\n+   * been read. This supports both unicode escapes \"u000A\" and two-character\n+   * escapes \"\\n\".\n+   *\n+   * @throws NumberFormatException if any unicode escape sequences are\n+   *     malformed.\n+   */\n+  private char readEscapeCharacter() throws IOException {\n+    if (pos == limit && !fillBuffer(1)) {\n+      throw syntaxError(\"Unterminated escape sequence\");\n+    }\n+\n+    char escaped = buffer[pos++];\n+    switch (escaped) {\n+    case 'u':\n+      if (pos + 4 > limit && !fillBuffer(4)) {\n+        throw syntaxError(\"Unterminated escape sequence\");\n+      }\n+      // Equivalent to Integer.parseInt(stringPool.get(buffer, pos, 4), 16);\n+      char result = 0;\n+      for (int i = pos, end = i + 4; i < end; i++) {\n+        char c = buffer[i];\n+        result <<= 4;\n+        if (c >= '0' && c <= '9') {\n+          result += (c - '0');\n+        } else if (c >= 'a' && c <= 'f') {\n+          result += (c - 'a' + 10);\n+        } else if (c >= 'A' && c <= 'F') {\n+          result += (c - 'A' + 10);\n+        } else {\n+          throw new NumberFormatException(\"\\\\u\" + new String(buffer, pos, 4));\n+        }\n+      }\n+      pos += 4;\n+      return result;\n+\n+    case 't':\n+      return '\\t';\n+\n+    case 'b':\n+      return '\\b';\n+\n+    case 'n':\n+      return '\\n';\n+\n+    case 'r':\n+      return '\\r';\n+\n+    case 'f':\n+      return '\\f';\n+\n+    case '\\'':\n+    case '\"':\n+    case '\\\\':\n+    default:\n+      return escaped;\n+    }\n+  }\n+\n+  /**\n+   * Throws a new IO exception with the given message and a context snippet\n+   * with this reader's content.\n+   */\n+  private IOException syntaxError(String message) throws IOException {\n+    throw new MalformedJsonException(message\n+        + \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n+  }\n+\n+  /*static {\n+    JsonReaderInternalAccess.INSTANCE = new JsonReaderInternalAccess() {\n+      @Override public void promoteNameToValue(JsonReader reader) throws IOException {\n+        if (reader instanceof JsonTreeReader) {\n+          ((JsonTreeReader)reader).promoteNameToValue();\n+          return;\n+        }\n+        int p = reader.peeked;\n+        if (p == PEEKED_NONE) {\n+          p = reader.doPeek();\n+        }\n+        if (p == PEEKED_DOUBLE_QUOTED_NAME) {\n+          reader.peeked = PEEKED_DOUBLE_QUOTED;\n+        } else if (p == PEEKED_SINGLE_QUOTED_NAME) {\n+          reader.peeked = PEEKED_SINGLE_QUOTED;\n+        } else if (p == PEEKED_UNQUOTED_NAME) {\n+          reader.peeked = PEEKED_UNQUOTED;\n+        } else {\n+          throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"\n+              + \" at line \" + reader.getLineNumber() + \" column \" + reader.getColumnNumber());\n+        }\n+      }\n+    };\n+  }*/\n+}\n--- a/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n+++ b/gson/src/test/java/com/google/gson/stream/JsonReaderTest.java\n \n package com.google.gson.stream;\n \n+import com.google.gson.JsonSyntaxException;\n+import com.google.gson.reflect.TypeToken;\n import java.io.EOFException;\n import java.io.IOException;\n import java.io.StringReader;\n+import java.lang.reflect.Type;\n import java.util.Arrays;\n+import java.util.Map;\n import junit.framework.TestCase;\n \n public final class JsonReaderTest extends TestCase {\n     assertEquals(-9223372036854775808L, reader.nextLong());\n   }\n \n+  /**\n+   * This test fails because there's no double for -9223372036854775809, and our\n+   * long parsing uses Double.parseDouble() for fractional values.\n+   */\n   public void testPeekLargerThanLongMinValue() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[-9223372036854775809]\"));\n+    reader.setLenient(true);\n+    reader.beginArray();\n+    assertEquals(JsonToken.NUMBER, reader.peek());\n+    try {\n+      reader.nextLong();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    assertEquals(-9223372036854775809d, reader.nextDouble());\n+  }\n+\n+  public void testPeekMuchLargerThanLongMinValue() throws IOException {\n     JsonReader reader = new JsonReader(new StringReader(\"[-92233720368547758080]\"));\n     reader.setLenient(true);\n     reader.beginArray();\n     reader.close();\n   }\n \n+  public void testIntegerMismatchFailuresDoNotAdvance() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"[1.5]\"));\n+    reader.beginArray();\n+    try {\n+      reader.nextInt();\n+      fail();\n+    } catch (NumberFormatException expected) {\n+    }\n+    assertEquals(1.5d, reader.nextDouble());\n+    reader.endArray();\n+  }\n+\n   public void testStringNullIsNotNull() throws IOException {\n     JsonReader reader = new JsonReader(new StringReader(\"[\\\"null\\\"]\"));\n     reader.beginArray();\n     }\n   }\n \n+  public void testStrictTopLevelString() {\n+    JsonReader reader = new JsonReader(new StringReader(\"\\\"a\\\"\"));\n+    try {\n+      reader.nextBoolean();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientTopLevelString() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"\\\"a\\\"\"));\n+    reader.setLenient(true);\n+    assertEquals(\"a\", reader.nextString());\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n   public void testStrictTopLevelValueType() {\n     JsonReader reader = new JsonReader(new StringReader(\"true\"));\n     try {\n   }\n \n   public void testFailWithPosition() throws IOException {\n-    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n+    testFailWithPosition(\"Expected value at line 6 column 3\",\n         \"[\\n\\n\\n\\n\\n0,}]\");\n   }\n \n   public void testFailWithPositionGreaterThanBufferSize() throws IOException {\n     String spaces = repeat(' ', 8192);\n-    testFailWithPosition(\"Expected literal value at line 6 column 3\",\n+    testFailWithPosition(\"Expected value at line 6 column 3\",\n         \"[\\n\\n\" + spaces + \"\\n\\n\\n0,}]\");\n   }\n \n   public void testFailWithPositionIsOffsetByBom() throws IOException {\n-    testFailWithPosition(\"Expected literal value at line 1 column 4\",\n+    testFailWithPosition(\"Expected value at line 1 column 4\",\n         \"\\ufeff[0,}]\");\n   }\n   \n     assertEquals(JsonToken.STRING, reader.peek());\n   }\n \n+  public void testEmptyStringName() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"\\\":true}\"));\n+    reader.setLenient(true);\n+    assertEquals(JsonToken.BEGIN_OBJECT, reader.peek());\n+    reader.beginObject();\n+    assertEquals(JsonToken.NAME, reader.peek());\n+    assertEquals(\"\", reader.nextName());\n+    assertEquals(JsonToken.BOOLEAN, reader.peek());\n+    assertEquals(true, reader.nextBoolean());\n+    assertEquals(JsonToken.END_OBJECT, reader.peek());\n+    reader.endObject();\n+    assertEquals(JsonToken.END_DOCUMENT, reader.peek());\n+  }\n+\n+  public void testStrictExtraCommasInMaps() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":\\\"b\\\",}\"));\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(\"b\", reader.nextString());\n+    try {\n+      reader.peek();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n+  public void testLenientExtraCommasInMaps() throws IOException {\n+    JsonReader reader = new JsonReader(new StringReader(\"{\\\"a\\\":\\\"b\\\",}\"));\n+    reader.setLenient(true);\n+    reader.beginObject();\n+    assertEquals(\"a\", reader.nextName());\n+    assertEquals(\"b\", reader.nextString());\n+    try {\n+      reader.peek();\n+      fail();\n+    } catch (IOException expected) {\n+    }\n+  }\n+\n   private String repeat(char c, int count) {\n     char[] array = new char[count];\n     Arrays.fill(array, c);", "timestamp": 1345953729, "metainfo": ""}