{"sha": "14f16e2d0c3c60338d69a3e0f653b8b876fdc1be", "log": "Adding Red-Black Tree implementation and tying it into the Gson bindings.", "commit": "\n--- a/gson/src/main/java/com/google/gson/JsonObject.java\n+++ b/gson/src/main/java/com/google/gson/JsonObject.java\n \n package com.google.gson;\n \n-import com.google.gson.internal.$Gson$Preconditions;\n-import com.google.gson.internal.StringMap;\n+import com.google.gson.internal.LinkedTreeMap;\n+\n import java.util.Map;\n import java.util.Set;\n \n  * @author Joel Leitch\n  */\n public final class JsonObject extends JsonElement {\n-  // We are using a linked hash map because it is important to preserve\n-  // the order in which elements are inserted. This is needed to ensure\n-  // that the fields of an object are inserted in the order they were\n-  // defined in the class.\n-  private final StringMap<JsonElement> members = new StringMap<JsonElement>();\n-\n-  /**\n-   * Creates an empty JsonObject.\n-   */\n-  public JsonObject() {\n-  }\n+  private final LinkedTreeMap<String, JsonElement> members =\n+      new LinkedTreeMap<String, JsonElement>();\n \n   @Override\n   JsonObject deepCopy() {\n     if (value == null) {\n       value = JsonNull.INSTANCE;\n     }\n-    members.put($Gson$Preconditions.checkNotNull(property), value);\n+    members.put(property, value);\n   }\n \n   /**\n    * @return the member matching the name. Null if no such member exists.\n    */\n   public JsonElement get(String memberName) {\n-    if (members.containsKey(memberName)) {\n-      JsonElement member = members.get(memberName);\n-      return member == null ? JsonNull.INSTANCE : member;\n-    }\n-    return null;\n+    return members.get(memberName);\n   }\n \n   /**\n--- a/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n+++ b/gson/src/main/java/com/google/gson/internal/ConstructorConstructor.java\n \n import com.google.gson.InstanceCreator;\n import com.google.gson.reflect.TypeToken;\n+\n import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.ParameterizedType;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.SortedMap;\n import java.util.SortedSet;\n+import java.util.TreeMap;\n import java.util.TreeSet;\n \n /**\n     }\n \n     if (Map.class.isAssignableFrom(rawType)) {\n-      if (type instanceof ParameterizedType\n-          && ((ParameterizedType) type).getActualTypeArguments()[0] == String.class) {\n+      if (SortedMap.class.isAssignableFrom(rawType)) {\n         return new ObjectConstructor<T>() {\n           public T construct() {\n-            return (T) new StringMap<Object>();\n+            return (T) new TreeMap<Object, Object>();\n+          }\n+        };\n+      } else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\n+          TypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\n+        return new ObjectConstructor<T>() {\n+          public T construct() {\n+            return (T) new LinkedHashMap<Object, Object>();\n           }\n         };\n       } else {\n         return new ObjectConstructor<T>() {\n           public T construct() {\n-            return (T) new LinkedHashMap<Object, Object>();\n+            return (T) new LinkedTreeMap<String, Object>();\n           }\n         };\n       }\n-      // TODO: SortedMap ?\n     }\n \n     return null;\n   }\n+\n \n   private <T> ObjectConstructor<T> newUnsafeAllocator(\n       final Type type, final Class<? super T> rawType) {\n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/LinkedTreeMap.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.io.ObjectStreamException;\n+import java.io.Serializable;\n+import java.util.AbstractMap;\n+import java.util.AbstractSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A map with a {@code Comparable} key that is implemented as a red-black tree.\n+ *\n+ * <p>A red-black tree offers quicker insert operations than AVL trees; however, slower \"find\"\n+ * operations.\n+ *\n+ * <p>This implementation was derived from the JDK's TreeMap class.\n+ */\n+public class LinkedTreeMap<K extends Comparable<K>, V>\n+    extends AbstractMap<K, V> implements Serializable {\n+  private static final boolean BLACK = false;\n+  private static final boolean RED = true;\n+\n+  // Size stored as a field for optimization instead of recursing tree.\n+  private int size = 0;\n+\n+  private TreeNode<K, V> root;\n+\n+  // Store the head and tail to preserve the ordering of nodes inserted into tree\n+  private TreeNode<K, V> head;\n+  private TreeNode<K, V> tail;\n+\n+  public Set<Map.Entry<K, V>> entrySet() {\n+    return new EntrySet();\n+  }\n+\n+  public boolean containsKey(K key) {\n+    return (find(key) != null);\n+  }\n+\n+  public V get(K key) {\n+    TreeNode<K, V> entry = find(key);\n+    return (entry == null) ? null : entry.getValue();\n+  }\n+\n+  public V put(K key, V value) {\n+    $Gson$Preconditions.checkNotNull(key);\n+    if (root == null) {\n+      root = new TreeNode<K, V>(null, null, key, value);\n+      head = root;\n+      tail = root;\n+      size++;\n+      return null;\n+    } else {\n+      return findAndUpdateOrCreateNode(key, value);\n+    }\n+  }\n+\n+  private V findAndUpdateOrCreateNode(K key, V value) {\n+    TreeNode<K, V> parent;\n+    int lastCompare;\n+\n+    TreeNode<K, V> entry = root;\n+    do {\n+      parent = entry;\n+      lastCompare = key.compareTo(entry.key);\n+      if (lastCompare < 0) {\n+        entry = entry.left;\n+      } else if (lastCompare > 0) {\n+        entry = entry.right;\n+      } else {\n+        V rval = entry.getValue();\n+        entry.setValue(value);\n+        return rval;\n+      }\n+    } while (entry != null);\n+\n+    size++;\n+\n+    // Create a new node and set up the tree edges\n+    TreeNode<K, V> newEntry = new TreeNode<K, V>(parent, tail, key, value);\n+    if (lastCompare < 0) {\n+      parent.left = newEntry;\n+    } else if (lastCompare > 0) {\n+      parent.right = newEntry;\n+    }\n+\n+    tail.next = newEntry;\n+    tail = newEntry;\n+    rebalanceAfterInsert(newEntry);\n+    return null;\n+  }\n+\n+  private void rebalanceAfterInsert(TreeNode<K, V> x) {\n+    x.color = RED;\n+\n+    while (x != null && x != root && x.parent.color == RED) {\n+      if (x.parent == leftOf(parentOf(parentOf(x)))) {\n+        TreeNode<K, V> y = rightOf(parentOf(parentOf(x)));\n+        if (colorOf(y) == RED) {\n+          setColor(parentOf(x), BLACK);\n+          setColor(y, BLACK);\n+          setColor(parentOf(parentOf(x)), RED);\n+          x = parentOf(parentOf(x));\n+        } else {\n+          if (x == rightOf(parentOf(x))) {\n+            x= parentOf(x);\n+            rotateLeft(x);\n+          }\n+          setColor(parentOf(x), BLACK);\n+          setColor(parentOf(parentOf(x)), RED);\n+          rotateRight(parentOf(parentOf(x)));\n+        }\n+      } else {\n+        TreeNode<K, V> y = leftOf(parentOf(parentOf(x)));\n+        if (colorOf(y) == RED) {\n+          setColor(parentOf(x), BLACK);\n+          setColor(y, BLACK);\n+          setColor(parentOf(parentOf(x)), RED);\n+          x = parentOf(parentOf(x));\n+        } else {\n+          if (x == leftOf(parentOf(x))) {\n+            x = parentOf(x);\n+            rotateRight(x);\n+          }\n+          setColor(parentOf(x), BLACK);\n+          setColor(parentOf(parentOf(x)), RED);\n+          rotateLeft(parentOf(parentOf(x)));\n+        }\n+      }\n+    }\n+    root.color = BLACK;\n+  }\n+\n+  private static <K extends Comparable<K>, V> TreeNode<K, V> parentOf(TreeNode<K, V> e) {\n+    return (e != null ? e.parent : null);\n+  }\n+\n+  private static <K extends Comparable<K>, V> boolean colorOf(TreeNode<K, V> e) {\n+    return (e != null ? e.color : BLACK);\n+  }\n+\n+  private static <K extends Comparable<K>, V> TreeNode<K, V> leftOf(TreeNode<K, V> e) {\n+    return (e != null ? e.left : null);\n+  }\n+\n+  private static <K extends Comparable<K>, V> TreeNode<K, V> rightOf(TreeNode<K, V> e) {\n+    return (e != null ? e.right : null);\n+  }\n+\n+  private static <K extends Comparable<K>, V> void setColor(TreeNode<K, V> e, boolean c) {\n+    if (e != null){\n+      e.color = c;\n+    }\n+  }\n+\n+  private static <K extends Comparable<K>, V> TreeNode<K, V> successor(TreeNode<K, V> t) {\n+    if (t == null) {\n+      return null;\n+    } else if (t.right != null) {\n+      TreeNode<K, V> p = t.right;\n+      while (p.left != null) {\n+        p = p.left;\n+      }\n+      return p;\n+    } else {\n+      TreeNode<K, V> p = t.parent;\n+      TreeNode<K, V> ch = t;\n+      while (p != null && ch == p.right) {\n+        ch = p;\n+        p = p.parent;\n+      }\n+      return p;\n+    }\n+  }\n+\n+  private void rotateLeft(TreeNode<K, V> p) {\n+    if (p != null) {\n+      TreeNode<K, V> r = p.right;\n+      p.right = r.left;\n+      if (r.left != null) {\n+        r.left.parent = p;\n+      }\n+      r.parent = p.parent;\n+      if (p.parent == null) {\n+        root = r;\n+      } else if (p.parent.left == p) {\n+        p.parent.left = r;\n+      } else {\n+        p.parent.right = r;\n+      }\n+      r.left = p;\n+      p.parent = r;\n+    }\n+  }\n+\n+  private void rotateRight(TreeNode<K, V> p) {\n+    if (p != null) {\n+      TreeNode<K, V> l = p.left;\n+      p.left = l.right;\n+      if (l.right != null) {\n+        l.right.parent = p;\n+      }\n+      l.parent = p.parent;\n+      if (p.parent == null) {\n+        root = l;\n+      } else if (p.parent.right == p) {\n+        p.parent.right = l;\n+      } else {\n+        p.parent.left = l;\n+      }\n+      l.right = p;\n+      p.parent = l;\n+    }\n+  }\n+\n+  public V remove(K key) {\n+    TreeNode<K, V> entry = find(key);\n+    if (entry == null) {\n+      return null;\n+    } else {\n+      size--;\n+      V rval = entry.getValue();\n+      preserveOrderForRemoval(entry);\n+      removeNode(entry);\n+      return rval;\n+    }\n+  }\n+\n+  private void removeNode(TreeNode<K, V> p) {\n+    if (p.left != null && p.right != null) {\n+      TreeNode<K, V> s = successor(p);\n+      p.key = s.key;\n+      p.value = s.value;\n+      p = s;\n+    }\n+\n+    TreeNode<K, V> replacement = (p.left != null ? p.left : p.right);\n+    if (replacement != null) {\n+      // Link replacement to parent\n+      replacement.parent = p.parent;\n+      if (p.parent == null) {\n+        root = replacement;\n+      } else if (p == p.parent.left) {\n+        p.parent.left  = replacement;\n+      } else {\n+        p.parent.right = replacement;\n+      }\n+\n+      // Null out links so they are OK to use by fixAfterDeletion.\n+      p.left = null;\n+      p.right = null;\n+      p.parent = null;\n+\n+      // Fix replacement\n+      if (p.color == BLACK) {\n+        fixAfterDeletion(replacement);\n+      }\n+    } else if (p.parent == null) { // return if we are the only node.\n+      root = null;\n+    } else { //  No children. Use self as phantom replacement and unlink.\n+      if (p.color == BLACK) {\n+        fixAfterDeletion(p);\n+      }\n+\n+      if (p.parent != null) {\n+        if (p == p.parent.left) {\n+          p.parent.left = null;\n+        } else if (p == p.parent.right) {\n+          p.parent.right = null;\n+        }\n+        p.parent = null;\n+      }\n+    }\n+  }\n+\n+  private void preserveOrderForRemoval(TreeNode<K, V> p) {\n+    // Preserve insertion order for entry set iteration\n+    if (p == head) {\n+      head = p.next;\n+    }\n+    if (p == tail) {\n+      tail = p.previous;\n+    }\n+\n+    TreeNode<K, V> previousNode = p.previous;\n+    TreeNode<K, V> nextNode = p.next;\n+    if (previousNode != null) {\n+      previousNode.next = nextNode;\n+    }\n+    if (nextNode != null) {\n+      nextNode.previous = previousNode;\n+    }\n+  }\n+\n+  private void fixAfterDeletion(TreeNode<K, V> x) {\n+    while (x != root && colorOf(x) == BLACK) {\n+      if (x == leftOf(parentOf(x))) {\n+        TreeNode<K, V> sib = rightOf(parentOf(x));\n+\n+        if (colorOf(sib) == RED) {\n+          setColor(sib, BLACK);\n+          setColor(parentOf(x), RED);\n+          rotateLeft(parentOf(x));\n+          sib = rightOf(parentOf(x));\n+        }\n+\n+        if (colorOf(leftOf(sib))  == BLACK &&\n+            colorOf(rightOf(sib)) == BLACK) {\n+          setColor(sib, RED);\n+          x = parentOf(x);\n+        } else {\n+          if (colorOf(rightOf(sib)) == BLACK) {\n+            setColor(leftOf(sib), BLACK);\n+            setColor(sib, RED);\n+            rotateRight(sib);\n+            sib = rightOf(parentOf(x));\n+          }\n+          setColor(sib, colorOf(parentOf(x)));\n+          setColor(parentOf(x), BLACK);\n+          setColor(rightOf(sib), BLACK);\n+          rotateLeft(parentOf(x));\n+          x = root;\n+        }\n+      } else { // symmetric\n+        TreeNode<K, V> sib = leftOf(parentOf(x));\n+\n+        if (colorOf(sib) == RED) {\n+          setColor(sib, BLACK);\n+          setColor(parentOf(x), RED);\n+          rotateRight(parentOf(x));\n+          sib = leftOf(parentOf(x));\n+        }\n+\n+        if (colorOf(rightOf(sib)) == BLACK &&\n+            colorOf(leftOf(sib)) == BLACK) {\n+          setColor(sib, RED);\n+          x = parentOf(x);\n+        } else {\n+          if (colorOf(leftOf(sib)) == BLACK) {\n+            setColor(rightOf(sib), BLACK);\n+            setColor(sib, RED);\n+            rotateLeft(sib);\n+            sib = leftOf(parentOf(x));\n+          }\n+          setColor(sib, colorOf(parentOf(x)));\n+          setColor(parentOf(x), BLACK);\n+          setColor(leftOf(sib), BLACK);\n+          rotateRight(parentOf(x));\n+          x = root;\n+        }\n+      }\n+    }\n+\n+    setColor(x, BLACK);\n+  }\n+\n+  public int size() {\n+    return size;\n+  }\n+\n+  /**\n+   * If somebody is unlucky enough to have to serialize one of these, serialize\n+   * it as a LinkedHashMap so that they won't need Gson on the other side to\n+   * deserialize it. Using serialization defeats our DoS defence, so most apps\n+   * shouldn't use it.\n+   */\n+  private Object writeReplace() throws ObjectStreamException {\n+    return new LinkedHashMap<K, V>(this);\n+  }\n+\n+  private TreeNode<K, V> find(K key) {\n+    for (TreeNode<K, V> entry = root; entry != null; ) {\n+      int compareVal = key.compareTo(entry.key);\n+      if (compareVal < 0) {\n+        entry = entry.left;\n+      } else if (compareVal > 0) {\n+        entry = entry.right;\n+      } else {\n+        return entry;\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static class TreeNode<K extends Comparable<K>, V> implements Map.Entry<K, V> {\n+    private K key;\n+    private V value;\n+    private TreeNode<K, V> parent;\n+    private TreeNode<K, V> left;\n+    private TreeNode<K, V> right;\n+\n+    // Used for rebalance tree\n+    private boolean color = BLACK;\n+\n+    // This is used for preserving the insertion order\n+    private TreeNode<K, V> next;\n+    private TreeNode<K, V> previous;\n+\n+    TreeNode(TreeNode<K, V> parent, TreeNode<K, V> previous, K key, V value) {\n+      this.parent = parent;\n+      this.previous = previous;\n+      this.key = key;\n+      this.value = value;\n+    }\n+\n+    public K getKey() {\n+      return key;\n+    }\n+\n+    public V getValue() {\n+      return value;\n+    }\n+\n+    // I'd like to make this throw an UnsupportedOperationException; however,\n+    public V setValue(V value) {\n+      V rval = this.value;\n+      this.value = value;\n+      return rval;\n+    }\n+\n+    @Override\n+    public final boolean equals(Object o) {\n+      if (!(o instanceof Entry)) {\n+        return false;\n+      }\n+      Entry<?, ?> e = (Entry<?, ?>) o;\n+      Object eValue = e.getValue();\n+      return key.equals(e.getKey())\n+          && (value == null ? eValue == null : value.equals(eValue));\n+    }\n+\n+    @Override\n+    public final int hashCode() {\n+      return key.hashCode() ^ (value == null ? 0 : value.hashCode());\n+    }\n+\n+    @Override\n+    public final String toString() {\n+      return key + \"=\" + value;\n+    }\n+  }\n+\n+  class EntrySet extends AbstractSet<Entry<K, V>> {\n+    @Override\n+    public Iterator<Map.Entry<K, V>> iterator() {\n+      return new LinkedTreeIterator(head);\n+    }\n+\n+    @Override\n+    public int size() {\n+      return LinkedTreeMap.this.size();\n+    }\n+  }\n+\n+  private class LinkedTreeIterator implements Iterator<Map.Entry<K, V>> {\n+    private TreeNode<K, V> current;\n+\n+    private LinkedTreeIterator(TreeNode<K, V> first) {\n+      this.current = first;\n+    }\n+\n+    public boolean hasNext() {\n+      return current != null;\n+    }\n+\n+    public Map.Entry<K, V> next() {\n+      TreeNode<K, V> rval = current;\n+      current = current.next;\n+      return rval;\n+    }\n+\n+    public final void remove() {\n+      LinkedTreeMap.this.remove(current.getKey());\n+    }\n+  }\n+}\n--- a/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/ObjectTypeAdapter.java\n import com.google.gson.Gson;\n import com.google.gson.TypeAdapter;\n import com.google.gson.TypeAdapterFactory;\n-import com.google.gson.internal.StringMap;\n+import com.google.gson.internal.LinkedTreeMap;\n import com.google.gson.reflect.TypeToken;\n import com.google.gson.stream.JsonReader;\n import com.google.gson.stream.JsonToken;\n import com.google.gson.stream.JsonWriter;\n+\n import java.io.IOException;\n import java.util.ArrayList;\n import java.util.List;\n       return list;\n \n     case BEGIN_OBJECT:\n-      Map<String, Object> map = new StringMap<Object>();\n+      Map<String, Object> map = new LinkedTreeMap<String, Object>();\n       in.beginObject();\n       while (in.hasNext()) {\n         map.put(in.nextName(), read(in));\n--- a/gson/src/test/java/com/google/gson/JsonObjectTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonObjectTest.java\n     JsonElement removedElement = jsonObj.remove(propertyName);\n     assertEquals(value, removedElement);\n     assertFalse(jsonObj.has(propertyName));\n+    assertNull(jsonObj.get(propertyName));\n   }\n \n   public void testAddingNullPropertyValue() throws Exception {\n--- a/gson/src/test/java/com/google/gson/JsonParserTest.java\n+++ b/gson/src/test/java/com/google/gson/JsonParserTest.java\n \n   public void testReadWriteTwoObjects() throws Exception {\n     Gson gson = new Gson();\n-    CharArrayWriter writer= new CharArrayWriter();\n+    CharArrayWriter writer = new CharArrayWriter();\n     BagOfPrimitives expectedOne = new BagOfPrimitives(1, 1, true, \"one\");\n     writer.write(gson.toJson(expectedOne).toCharArray());\n     BagOfPrimitives expectedTwo = new BagOfPrimitives(2, 2, false, \"two\");\n--- a/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/DefaultTypeAdaptersTest.java\n     assertEquals(\"{\\\"foo\\\":1,\\\"bar\\\":2}\", gson.toJson(object, JsonElement.class));\n   }\n \n-  public void testJsonObjectDeerialization() {\n+  public void testJsonObjectDeserialization() {\n     JsonObject object = new JsonObject();\n     object.add(\"foo\", new JsonPrimitive(1));\n     object.add(\"bar\", new JsonPrimitive(2));\n-    assertEquals(object, gson.fromJson(\"{\\\"foo\\\":1,\\\"bar\\\":2}\", JsonElement.class));\n+\n+    JsonElement actual = gson.fromJson(\"{\\\"foo\\\":1,\\\"bar\\\":2}\", JsonElement.class);\n+    assertEquals(object, actual);\n   }\n \n   public void testJsonNullDeerialization() {\n--- a/gson/src/test/java/com/google/gson/functional/MapTest.java\n+++ b/gson/src/test/java/com/google/gson/functional/MapTest.java\n \n package com.google.gson.functional;\n \n-import java.lang.reflect.Type;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.Map;\n-import java.util.TreeMap;\n-\n-import junit.framework.TestCase;\n-\n import com.google.gson.Gson;\n import com.google.gson.GsonBuilder;\n import com.google.gson.InstanceCreator;\n import com.google.gson.internal.$Gson$Types;\n import com.google.gson.reflect.TypeToken;\n \n+import junit.framework.TestCase;\n+\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n /**\n  * Functional test for Json serialization and deserialization for Maps\n  *\n   public void testMapDeserializationWithIntegerKeys() {\n     Type typeOfMap = new TypeToken<Map<Integer, String>>() {}.getType();\n     Map<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n+    assertEquals(1, map.size());\n+    assertTrue(map.containsKey(123));\n+    assertEquals(\"456\", map.get(123));\n+  }\n+\n+  public void testHashMapDeserialization() throws Exception {\n+    Type typeOfMap = new TypeToken<HashMap<Integer, String>>() {}.getType();\n+    HashMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n+    assertEquals(1, map.size());\n+    assertTrue(map.containsKey(123));\n+    assertEquals(\"456\", map.get(123));\n+  }\n+\n+  public void testSortedMap() throws Exception {\n+    Type typeOfMap = new TypeToken<SortedMap<Integer, String>>() {}.getType();\n+    SortedMap<Integer, String> map = gson.fromJson(\"{\\\"123\\\":\\\"456\\\"}\", typeOfMap);\n     assertEquals(1, map.size());\n     assertTrue(map.containsKey(123));\n     assertEquals(\"456\", map.get(123));\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/LinkedTreeMapTest.java\n+/*\n+ * Copyright (C) 2012 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import com.google.gson.common.MoreAsserts;\n+\n+import junit.framework.TestCase;\n+\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Unit tests for {@code LinkedTreeMap} class.\n+ *\n+ * @author Joel Leitch\n+ */\n+public class LinkedTreeMapTest extends TestCase {\n+\n+  public void testPutAndGet() throws Exception {\n+    LinkedTreeMap<String, Integer> map = new LinkedTreeMap<String, Integer>();\n+    map.put(\"B\", 2);\n+    map.put(\"A\", 1);\n+    map.put(\"C\", 3);\n+\n+    assertTrue(map.containsKey(\"A\"));\n+    assertTrue(map.containsKey(\"B\"));\n+    assertTrue(map.containsKey(\"C\"));\n+    assertFalse(map.containsKey(\"D\"));\n+\n+    assertEquals(1, (int) map.get(\"A\"));\n+    assertEquals(2, (int) map.get(\"B\"));\n+    assertEquals(3, (int) map.get(\"C\"));\n+    assertEquals(3, map.entrySet().size());\n+\n+    assertEquals(1, (int) map.put(\"A\", 4));\n+    assertTrue(map.containsKey(\"A\"));\n+    assertEquals(4, (int) map.get(\"A\"));\n+    assertEquals(3, map.entrySet().size());\n+\n+    // Ensure entry set size is same as map size\n+    assertEquals(map.size(), map.entrySet().size());\n+  }\n+\n+  public void testSingleElement() throws Exception {\n+    LinkedTreeMap<String, Integer> map = new LinkedTreeMap<String, Integer>();\n+    map.put(\"A\", 1);\n+    assertEquals(1, map.size());\n+\n+    assertEquals(1, (int) map.get(\"A\"));\n+    map.remove(\"A\");\n+    assertEquals(0, map.size());\n+\n+    // Ensure the map and entry set are empty\n+    assertTrue(map.entrySet().isEmpty());\n+    assertTrue(map.isEmpty());\n+  }\n+\n+  public void testAddAndRemove() throws Exception {\n+    LinkedTreeMap<String, Integer> map = new LinkedTreeMap<String, Integer>();\n+    map.put(\"A\", 1);\n+    map.put(\"B\", 2);\n+    map.put(\"C\", 3);\n+    map.put(\"D\", 4);\n+    map.put(\"E\", 5);\n+    map.put(\"F\", 6);\n+\n+    assertEquals(3, (int) map.remove(\"C\"));\n+    assertEquals(5, map.size());\n+    assertIterationOrder(map.entrySet(),\n+        new String[] { \"A\", \"B\", \"D\", \"E\", \"F\" }, new int[] { 1, 2, 4, 5, 6 });\n+\n+    // Remove a non-existent key\n+    assertNull(map.remove(\"G\"));\n+    assertEquals(5, map.size());\n+\n+    // Remove the first element\n+    assertEquals(1, (int) map.remove(\"A\"));\n+    assertIterationOrder(map.entrySet(),\n+        new String[] { \"B\", \"D\", \"E\", \"F\" }, new int[] { 2, 4, 5, 6 });\n+\n+    // Remove the last element\n+    assertEquals(6, (int) map.remove(\"F\"));\n+    assertIterationOrder(map.entrySet(),\n+        new String[] { \"B\", \"D\", \"E\" }, new int[] { 2, 4, 5 });\n+  }\n+\n+  public void testInsertionOrderPreserved() throws Exception {\n+    LinkedTreeMap<String, Integer> map = new LinkedTreeMap<String, Integer>();\n+    String[] keys = { \"B\", \"A\", \"D\", \"C\", \"Z\", \"W\", \"E\", \"F\", \"T\" };\n+    int[] values = new int[keys.length];\n+    for (int i = 0; i < keys.length; ++i) {\n+      values[i] = i;\n+      map.put(keys[i], i);\n+    }\n+\n+    Set<Map.Entry<String,Integer>> entries = map.entrySet();\n+    assertEquals(keys.length, entries.size());\n+    assertIterationOrder(entries, keys, values);\n+  }\n+\n+  public void testEqualsAndHashCode() throws Exception {\n+    LinkedTreeMap<String, Integer> map1 = new LinkedTreeMap<String, Integer>();\n+    map1.put(\"A\", 1);\n+    map1.put(\"B\", 2);\n+    map1.put(\"C\", 3);\n+    map1.put(\"D\", 4);\n+\n+    LinkedTreeMap<String, Integer> map2 = new LinkedTreeMap<String, Integer>();\n+    map2.put(\"C\", 3);\n+    map2.put(\"B\", 2);\n+    map2.put(\"D\", 4);\n+    map2.put(\"A\", 1);\n+\n+    MoreAsserts.assertEqualsAndHashCode(map1, map2);\n+  }\n+\n+  private void assertIterationOrder(Set<Map.Entry<String, Integer>> entries, String[] keys, int[] values) {\n+    int i = 0;\n+    for (Iterator<Map.Entry<String, Integer>> iterator = entries.iterator(); iterator.hasNext(); ++i) {\n+      Map.Entry<String, Integer> entry = iterator.next();\n+      assertEquals(keys[i], entry.getKey());\n+      assertEquals(values[i], (int) entry.getValue());\n+    }\n+  }\n+}", "timestamp": 1349925349, "metainfo": ""}