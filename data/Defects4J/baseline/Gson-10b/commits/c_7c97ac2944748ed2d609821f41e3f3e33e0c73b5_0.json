{"sha": "7c97ac2944748ed2d609821f41e3f3e33e0c73b5", "log": "Updated Gson version to 2.3-SNAPSHOT since this is a new feature. Added support for a magic field GSON_TYPE_ADAPTER in a class. This adapter is automatically invoked if present. The field must be present in the class (not in any super-type), and must be strongly typed as TypeAdapter<T>.", "commit": "\n--- a/gson/src/main/java/com/google/gson/Gson.java\n+++ b/gson/src/main/java/com/google/gson/Gson.java\n import com.google.gson.internal.bind.ArrayTypeAdapter;\n import com.google.gson.internal.bind.CollectionTypeAdapterFactory;\n import com.google.gson.internal.bind.DateTypeAdapter;\n+import com.google.gson.internal.bind.FieldTypeAdapterFactory;\n import com.google.gson.internal.bind.JsonTreeReader;\n import com.google.gson.internal.bind.JsonTreeWriter;\n import com.google.gson.internal.bind.MapTypeAdapterFactory;\n     // type adapters for composite and user-defined types\n     factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n     factories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\n+    factories.add(new FieldTypeAdapterFactory());\n     factories.add(new ReflectiveTypeAdapterFactory(\n         constructorConstructor, fieldNamingPolicy, excluder));\n \n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n     }\n   }\n \n+  /**\n+   * Given a parameterized type A&lt;B,C&gt;, returns B. If the specified type is not\n+   * a generic type, returns null.\n+   */\n+  public static Type getFirstTypeArgument(Type type) {\n+    try {\n+      if (!(type instanceof ParameterizedType)) return null;\n+      ParameterizedType ptype = (ParameterizedType) type;\n+      Type[] actualTypeArguments = ptype.getActualTypeArguments();\n+      if (actualTypeArguments.length == 0) return null;\n+      return canonicalize(actualTypeArguments[0]);\n+    } catch (Exception e) {\n+      return null;\n+    }\n+  }\n+\n   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n     Class<?> declaredByRaw = declaringClassOf(unknown);\n \n--- /dev/null\n+++ b/gson/src/main/java/com/google/gson/internal/bind/FieldTypeAdapterFactory.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal.bind;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.TypeAdapterFactory;\n+import com.google.gson.internal.$Gson$Types;\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * Given a type T, looks for the magic static field named GSON_TYPE_ADAPTER of type\n+ * TypeAdapter&lt;T&gt; and uses it as the default type adapter.\n+ *\n+ * @since 2.3\n+ */\n+public final class FieldTypeAdapterFactory implements TypeAdapterFactory {\n+  private static final String FIELD_ADAPTER_NAME = \"GSON_TYPE_ADAPTER\";\n+\n+  @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n+  public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\n+    Class<? super T> clazz = targetType.getRawType();\n+    try {\n+      Field typeAdapterField = clazz.getDeclaredField(FIELD_ADAPTER_NAME);\n+      typeAdapterField.setAccessible(true);\n+      if (!Modifier.isStatic(typeAdapterField.getModifiers())) return null;\n+      Object fieldAdapterValue = typeAdapterField.get(null);\n+      if (fieldAdapterValue != null && fieldAdapterValue instanceof TypeAdapter) {\n+        // We know that the GSON_TYPE_ADAPTER field is of type TypeAdapter.\n+        // However, we need to assert that its type variable TypeAdapter<TypeVariable> matches\n+        // the target type\n+        Type fieldTypeVariable = $Gson$Types.getFirstTypeArgument(typeAdapterField.getGenericType());\n+        if (targetType.getType().equals(fieldTypeVariable)) {\n+          return (TypeAdapter) fieldAdapterValue;\n+        }\n+      }\n+    } catch (Exception e) { // ignore1\n+    }\n+    return null;\n+  }\n+\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/functional/GsonFieldTypeAdapterTest.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.functional;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import junit.framework.TestCase;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.JsonSerializationContext;\n+import com.google.gson.JsonSerializer;\n+import com.google.gson.TypeAdapter;\n+import com.google.gson.stream.JsonReader;\n+import com.google.gson.stream.JsonWriter;\n+\n+/**\n+ * Functional tests for the magic field GSON_TYPE_ADAPTER present in a class.\n+ */\n+@SuppressWarnings(\"unused\")\n+public final class GsonFieldTypeAdapterTest extends TestCase {\n+\n+  public void testFieldAdapterInvoked() {\n+    String json = new Gson().toJson(new ClassWithFieldAdapter(\"bar\"));\n+    assertEquals(\"\\\"fieldAdapter\\\"\", json);\n+  }\n+\n+  public void testRegisteredAdapterOverridesFieldAdapter() {\n+    TypeAdapter<ClassWithFieldAdapter> typeAdapter = new TypeAdapter<ClassWithFieldAdapter>() {\n+      @Override public void write(JsonWriter out, ClassWithFieldAdapter value) throws IOException {\n+        out.value(\"registeredAdapter\");\n+      }\n+      @Override public ClassWithFieldAdapter read(JsonReader in) throws IOException {\n+        return new ClassWithFieldAdapter(in.nextString());\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(ClassWithFieldAdapter.class, typeAdapter)\n+      .create();\n+    String json = gson.toJson(new ClassWithFieldAdapter(\"abcd\"));\n+    assertEquals(\"\\\"registeredAdapter\\\"\", json);\n+  }\n+\n+  /**\n+   * The serializer overrides field adapter, but for deserializer the fieldAdapter is used.\n+   */\n+  public void testRegisteredSerializerOverridesFieldAdapter() {\n+    JsonSerializer<ClassWithFieldAdapter> serializer = new JsonSerializer<ClassWithFieldAdapter>() {\n+      public JsonElement serialize(ClassWithFieldAdapter src, Type typeOfSrc,\n+          JsonSerializationContext context) {\n+        return new JsonPrimitive(\"registeredSerializer\");\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(ClassWithFieldAdapter.class, serializer)\n+      .create();\n+    String json = gson.toJson(new ClassWithFieldAdapter(\"abcd\"));\n+    assertEquals(\"\\\"registeredSerializer\\\"\", json);\n+    ClassWithFieldAdapter target = gson.fromJson(\"abcd\", ClassWithFieldAdapter.class);\n+    assertEquals(\"fieldAdapter\", target.value);\n+  }\n+\n+  /**\n+   * The deserializer overrides field adapter, but for serializer the fieldAdapter is used.\n+   */\n+  public void testRegisteredDeserializerOverridesFieldAdapter() {\n+    JsonDeserializer<ClassWithFieldAdapter> deserializer = new JsonDeserializer<ClassWithFieldAdapter>() {\n+      public ClassWithFieldAdapter deserialize(JsonElement json, Type typeOfT,\n+          JsonDeserializationContext context) throws JsonParseException {\n+        return new ClassWithFieldAdapter(\"registeredDeserializer\");\n+      }\n+    };\n+    Gson gson = new GsonBuilder()\n+      .registerTypeAdapter(ClassWithFieldAdapter.class, deserializer)\n+      .create();\n+    String json = gson.toJson(new ClassWithFieldAdapter(\"abcd\"));\n+    assertEquals(\"\\\"fieldAdapter\\\"\", json);\n+    ClassWithFieldAdapter target = gson.fromJson(\"abcd\", ClassWithFieldAdapter.class);\n+    assertEquals(\"registeredDeserializer\", target.value);\n+  }\n+\n+  public void testFieldAdapterNotInvokedIfNull() {\n+    String json = new Gson().toJson(new ClassWithNullFieldAdapter(\"bar\"));\n+    assertEquals(\"{\\\"value\\\":\\\"bar\\\"}\", json);\n+  }\n+\n+  public void testNonStaticFieldAdapterNotInvoked() {\n+    String json = new Gson().toJson(new ClassWithNonStaticFieldAdapter(\"bar\"));\n+    assertFalse(json.contains(\"fieldAdapter\"));\n+  }\n+\n+  public void testIncorrectTypeAdapterNotInvoked() {\n+    String json = new Gson().toJson(new ClassWithIncorrectFieldAdapter(\"bar\"));\n+    assertFalse(json.contains(\"fieldAdapter\"));\n+  }\n+\n+  public void testSuperclassTypeAdapterNotInvoked() {\n+    String json = new Gson().toJson(new ClassWithSuperClassFieldAdapter(\"bar\"));\n+    assertFalse(json.contains(\"fieldAdapter\"));\n+  }\n+\n+  private static class ClassWithFieldAdapter {\n+    final String value;\n+    ClassWithFieldAdapter(String value) {\n+      this.value = value;\n+    }\n+    private static final TypeAdapter<ClassWithFieldAdapter> GSON_TYPE_ADAPTER =\n+        new TypeAdapter<GsonFieldTypeAdapterTest.ClassWithFieldAdapter>() {\n+      @Override public void write(JsonWriter out, ClassWithFieldAdapter value) throws IOException {\n+        out.value(\"fieldAdapter\");\n+      }\n+      @Override public ClassWithFieldAdapter read(JsonReader in) throws IOException {\n+        in.nextString();\n+        return new ClassWithFieldAdapter(\"fieldAdapter\");\n+      }\n+    };\n+  }\n+\n+  private static final class ClassWithSuperClassFieldAdapter extends ClassWithFieldAdapter {\n+    ClassWithSuperClassFieldAdapter(String value) {\n+      super(value);\n+    }\n+  }\n+\n+  private static final class ClassWithNullFieldAdapter {\n+    final String value;\n+    ClassWithNullFieldAdapter(String value) {\n+      this.value = value;\n+    }\n+    private static final TypeAdapter<ClassWithFieldAdapter> GSON_TYPE_ADAPTER = null;\n+  }\n+\n+  private static final class ClassWithNonStaticFieldAdapter {\n+    final String value;\n+    ClassWithNonStaticFieldAdapter(String value) {\n+      this.value = value;\n+    }\n+    private final TypeAdapter<ClassWithNonStaticFieldAdapter> GSON_TYPE_ADAPTER =\n+        new TypeAdapter<ClassWithNonStaticFieldAdapter>() {\n+      @Override public void write(JsonWriter out, ClassWithNonStaticFieldAdapter value) throws IOException {\n+        out.value(\"fieldAdapter\");\n+      }\n+      @Override public ClassWithNonStaticFieldAdapter read(JsonReader in) throws IOException {\n+        in.nextString();\n+        return new ClassWithNonStaticFieldAdapter(\"fieldAdapter\");\n+      }\n+    };\n+  }\n+\n+  private static final class ClassWithIncorrectFieldAdapter {\n+    final String value;\n+    ClassWithIncorrectFieldAdapter(String value) {\n+      this.value = value;\n+    }\n+    // Note that the type is NOT TypeAdapter<ClassWithIncorrectFieldAdapter> so this\n+    // field should be ignored.\n+    private static final TypeAdapter<ClassWithFieldAdapter> GSON_TYPE_ADAPTER =\n+        new TypeAdapter<GsonFieldTypeAdapterTest.ClassWithFieldAdapter>() {\n+      @Override public void write(JsonWriter out, ClassWithFieldAdapter value) throws IOException {\n+        out.value(\"fieldAdapter\");\n+      }\n+      @Override public ClassWithFieldAdapter read(JsonReader in) throws IOException {\n+        in.nextString();\n+        return new ClassWithFieldAdapter(\"fieldAdapter\");\n+      }\n+    };\n+  }\n+}\n--- /dev/null\n+++ b/gson/src/test/java/com/google/gson/internal/GsonTypesTest.java\n+/*\n+ * Copyright (C) 2014 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.google.gson.internal;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+\n+import junit.framework.TestCase;\n+\n+public final class GsonTypesTest extends TestCase {\n+\n+  public void testNewParameterizedTypeWithoutOwner() {\n+    // List<A>. List is a top-level class\n+    Type type = $Gson$Types.newParameterizedTypeWithOwner(null, List.class, A.class);\n+    assertEquals(A.class, $Gson$Types.getFirstTypeArgument(type));\n+\n+    // A<B>. A is a static inner class.\n+    type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class);\n+    assertEquals(B.class, $Gson$Types.getFirstTypeArgument(type));\n+\n+    final class D {\n+    }\n+    try {\n+      // D<A> is not allowed since D is not a static inner class\n+      $Gson$Types.newParameterizedTypeWithOwner(null, D.class, A.class);\n+    } catch (IllegalArgumentException expected) {}\n+\n+    // A<D> is allowed.\n+    type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, D.class);\n+    assertEquals(D.class, $Gson$Types.getFirstTypeArgument(type));\n+  }\n+\n+  public void testGetFirstTypeArgument() {\n+    assertNull($Gson$Types.getFirstTypeArgument(A.class));\n+\n+    Type type = $Gson$Types.newParameterizedTypeWithOwner(null, A.class, B.class, C.class);\n+    assertEquals(B.class, $Gson$Types.getFirstTypeArgument(type));\n+  }\n+\n+  private static final class A {\n+  }\n+  private static final class B {\n+  }\n+  private static final class C {\n+  }\n+}", "timestamp": 1394309293, "metainfo": ""}